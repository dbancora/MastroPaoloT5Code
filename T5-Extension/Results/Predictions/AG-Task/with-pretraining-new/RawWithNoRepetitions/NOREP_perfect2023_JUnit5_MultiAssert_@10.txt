************************************
[+] input: isEmpty_notIfAnyPhasesHaveMarbles() { var bag = MarbleBag.empty(); assertTrue(bag.isEmpty()); bag.add(1, bearId, 0); bag.add(2, frogId, 1000); "<AssertPlaceHolder>"; }
isEmpty() { return 0 == size(); }
[*] target: assertFalse(bag.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( bag. isEmpty() )
************************************
************************************
[+] input: givenByteArray_whenCreatingSegment_thenAccessorsReturnCorrectValues() { // Given byte[] testData = new byte[]{ (byte) -83, (byte) 64, 0x00, 0x05,         // Key Size 0x00, 0x00, 0x00, 0x05, // Value Size 0x48, 0x65, 0x6C, 0x6C, 0x6F, // Key: "Hello" 0x57, 0x6F, 0x72, 0x6C, 0x64  // Value: "World" };  // When Segment segment = Segment.fromByteArray(testData);  // Then assertArrayEquals(testData, segment.getBytes()); assertArrayEquals("Hello".getBytes(), segment.getKey()); assertArrayEquals("World".getBytes(), segment.getValue()); assertEquals(5, segment.getKeySize()); assertEquals(5, segment.getValueSize()); assertEquals(-83, segment.getCrc()[0]); assertEquals(64, segment.getCrc()[1]); assertTrue(segment.isSegmentValid()); "<AssertPlaceHolder>"; }
isChecksumValid() { byte[] crc = crc16(); return crc[0] == bytes[0] && crc[1] == bytes[1]; }
[*] target: assertTrue(segment.isChecksumValid())
[-] pred: org. junit. Assert. assertTrue ( segment. isChecksumValid() )
************************************
************************************
[+] input: testEmptyStruct() { final SchemaBuilder emptyStructSchemaBuilder = SchemaBuilder.struct(); assertEquals(0, emptyStructSchemaBuilder.fields().size()); new Struct(emptyStructSchemaBuilder);  final Schema emptyStructSchema = emptyStructSchemaBuilder.build(); "<AssertPlaceHolder>"; new Struct(emptyStructSchema); }
fields() { if (type != Type.STRUCT) throw new DataException("Cannot list fields on non-struct type"); return new ArrayList<>(fields.values()); }
[*] target: assertEquals(0, emptyStructSchema.fields().size())
[-] pred: org. junit. Assert. assertEquals ( 0, emptyStructSchema. fields ( ). size ( ) )
************************************
************************************
[+] input: testDisconnectWithoutShutdownShouldCauseException() { DisconnectException de = new DisconnectException(); when(networkClient.poll(anyLong(), anyLong())).thenThrow(de); when(networkClient.active()).thenReturn(true);  AtomicReference<Throwable> throwable = new AtomicReference<>(); final InterBrokerSendThread thread = new TestInterBrokerSendThread(networkClient, throwable::getAndSet); thread.pollOnce(100);  verify(networkClient).poll(anyLong(), anyLong()); verify(networkClient).active(); verifyNoMoreInteractions(networkClient);  Throwable thrown = throwable.get(); "<AssertPlaceHolder>"; assertInstanceOf(FatalExitError.class, thrown); }
pollOnce(long maxTimeoutMs) { try { drainGeneratedRequests(); long now = time.milliseconds(); final long timeout = sendRequests(now, maxTimeoutMs); networkClient.poll(timeout, now); now = time.milliseconds(); checkDisconnects(now); failExpiredRequests(now); unsentRequests.clean(); } catch (FatalExitError fee) { throw fee; } catch (Throwable t) { if (t instanceof DisconnectException && !networkClient.active()) { // DisconnectException is expected when NetworkClient#initiateClose is called return; } if (t instanceof InterruptedException && !isRunning()) { // InterruptedException is expected when shutting down. Throw the error to ShutdownableThread to handle throw t; } log.error("unhandled exception caught in InterBrokerSendThread", t); // rethrow any unhandled exceptions as FatalExitError so the JVM will be terminated // as we will be in an unknown state with potentially some requests dropped and not // being able to make progress. Known and expected Errors should have been appropriately // dealt with already. throw new FatalExitError(); } }
[*] target: assertNotNull(thrown)
[-] pred: org. junit. Assert. assertNotNull ( thrown )
************************************
************************************
[+] input: testMemberIdGeneration() { MockPartitionAssignor assignor = new MockPartitionAssignor("range"); GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .withConsumerGroupAssignors(Collections.singletonList(assignor)) .withMetadataImage(MetadataImage.EMPTY) .build();  assignor.prepareGroupAssignment(new GroupAssignment( Collections.emptyMap() ));  CoordinatorResult<ConsumerGroupHeartbeatResponseData, CoordinatorRecord> result = context.consumerGroupHeartbeat( new ConsumerGroupHeartbeatRequestData() .setGroupId("group-foo") .setMemberEpoch(0) .setServerAssignor("range") .setRebalanceTimeoutMs(5000) .setSubscribedTopicNames(Arrays.asList("foo", "bar")) .setTopicPartitions(Collections.emptyList()));  // Verify that a member id was generated for the new member. String memberId = result.response().memberId(); "<AssertPlaceHolder>"; assertNotEquals("", memberId);  // The response should get a bumped epoch and should not // contain any assignment because we did not provide // topics metadata. assertEquals( new ConsumerGroupHeartbeatResponseData() .setMemberId(memberId) .setMemberEpoch(1) .setHeartbeatIntervalMs(5000) .setAssignment(new ConsumerGroupHeartbeatResponseData.Assignment()), result.response() ); }
consumerGroupHeartbeat( RequestContext context, ConsumerGroupHeartbeatRequestData request ) throws ApiException { throwIfConsumerGroupHeartbeatRequestIsInvalid(request);  if (request.memberEpoch() == LEAVE_GROUP_MEMBER_EPOCH || request.memberEpoch() == LEAVE_GROUP_STATIC_MEMBER_EPOCH) { // -1 means that the member wants to leave the group. // -2 means that a static member wants to leave the group. return consumerGroupLeave( request.groupId(), request.instanceId(), request.memberId(), request.memberEpoch() ); } else { // Otherwise, it is a regular heartbeat. return consumerGroupHeartbeat( request.groupId(), request.memberId(), request.memberEpoch(), request.instanceId(), request.rackId(), request.rebalanceTimeoutMs(), context.clientId(), context.clientAddress.toString(), request.subscribedTopicNames(), request.serverAssignor(), request.topicPartitions() ); } }
[*] target: assertNotNull(memberId)
[-] pred: org. junit. Assert. assertNotNull ( memberId )
************************************
************************************
[+] input: Exception { final List<UserPermission> actualPermissions = permissionPersistence.listPermissionsForOrganization(MockData.ORGANIZATION_ID_1); final List<Permission> expectedPermissions = MockData.permissions().stream() .filter(p -> p.getOrganizationId() != null && p.getOrganizationId().equals(MockData.ORGANIZATION_ID_1)) .toList();  Assertions."<AssertPlaceHolder>"; for (final UserPermission actualPermission : actualPermissions) { Assertions.assertTrue(expectedPermissions.stream() .anyMatch(expectedPermission -> expectedPermission.getPermissionId().equals(actualPermission.getPermission().getPermissionId()) && actualPermission.getUser().getUserId().equals(expectedPermission.getUserId()))); } }
listPermissionsForOrganization(final UUID organizationId) throws IOException { return this.database.query(ctx -> listPermissionsForOrganization(ctx, organizationId)); }
[*] target: assertEquals(expectedPermissions.size(), actualPermissions.size())
[-] pred: org. junit. Assert. assertEquals ( expectedPermissions. size ( ), actualPermissions. size ( ) )
************************************
************************************
[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLL(-2)D")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x00, 0x13, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x11, 0x00, 0x01, 0x02 }));  final ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x00, 0x13, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x11, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred: org. junit. Assert. assertNotNull ( frame )
************************************
************************************
[+] input: testError() { String errorCode = "errorCode"; String errorDescription = "errorDescription"; String errorUri = "errorUri"; OAuthBearerTokenCallback callback = new OAuthBearerTokenCallback(); callback.error(errorCode, errorDescription, errorUri); assertEquals(errorCode, callback.errorCode()); assertEquals(errorDescription, callback.errorDescription()); assertEquals(errorUri, callback.errorUri()); "<AssertPlaceHolder>"; }
token() { return token; }
[*] target: assertNull(callback.token())
[-] pred: org. junit. Assert. assertNull ( callback. token() )
************************************
************************************
[+] input: remove() { assertEquals(3, m.size()); m.remove(66); assertEquals(3, m.size()); m.remove(3); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(2, m.size())
[-] pred: org. junit. Assert. assertEquals ( 2, m. size() )
************************************
************************************
[+] input: ConfigNotFoundException { setupStandardDefinitionMock(createAdvancedAuth() .withPredicateKey(List.of(CREDENTIALS, AUTH_TYPE)) .withPredicateValue("")); final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: convertRedefinesTest() { ASTTransformer transformer = new ASTTransformer();  Resource testResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertRedefinesTest/model.ast.json").readAllBytes()); testResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) testResource.getContents().get(0); Package packageObject = (Package) namespace.getMember().get(0);  EObject attributeUsage = packageObject.getMember().get(0); assertInstanceOf(AttributeUsage.class, attributeUsage); AttributeUsage typedAttributeUsage = (AttributeUsage) attributeUsage; assertEquals("Packets::'packet header'", typedAttributeUsage.getQualifiedName());  EObject redefinedAttributeUsage = packageObject.getMember().get(1); assertInstanceOf(AttributeUsage.class, redefinedAttributeUsage); AttributeUsage typedRedefinedAttributeUsage = (AttributeUsage) redefinedAttributeUsage; assertEquals("Packets::'packet secondary header'", typedRedefinedAttributeUsage.getQualifiedName());  assertEquals(1, typedRedefinedAttributeUsage.getOwnedRelationship().size()); assertEquals(1, typedRedefinedAttributeUsage.getOwnedRedefinition().size()); Redefinition redefinition = typedRedefinedAttributeUsage.getOwnedRedefinition().get(0);  assertEquals(typedAttributeUsage, redefinition.getRedefinedFeature()); assertEquals(typedRedefinedAttributeUsage, redefinition.getRedefiningFeature()); }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(testResource)
[-] pred: org. junit. Assert. assertNotNull ( testResource )
************************************
************************************
[+] input: test() { final DSLContext dslContext = getDslContext(); V0_55_1_003__EditRefreshTable.editRefreshTable(dslContext); final Set<String> index = dslContext.select() .from(table("pg_indexes")) .where(field("tablename").eq(STREAM_REFRESHES_TABLE)) .fetch() .stream() .map(c -> c.getValue("indexdef", String.class)) .collect(Collectors.toSet()); "<AssertPlaceHolder>"; assertTrue(index.contains( "CREATE UNIQUE INDEX stream_refreshes_pkey ON public.stream_refreshes USING btree (id)")); assertTrue(index.contains( "CREATE INDEX stream_refreshes_connection_id_idx ON public.stream_refreshes USING btree (connection_id)")); assertTrue(index.contains( "CREATE INDEX stream_refreshes_connection_id_stream_name_idx ON public.stream_refreshes " + "USING btree (connection_id, stream_name)")); assertTrue(index.contains( "CREATE INDEX stream_refreshes_connection_id_stream_name_stream_namespace_idx ON public.stream_refreshes" + " USING btree (connection_id, stream_name, stream_namespace)")); }
editRefreshTable(final DSLContext ctx) { ctx.truncate(STREAM_REFRESHES_TABLE).execute(); ctx.dropTable(STREAM_REFRESHES_TABLE).execute();  final Field<UUID> id = DSL.field("id", SQLDataType.UUID.nullable(false)); ctx.createTable(STREAM_REFRESHES_TABLE) .columns(id, connectionId, streamName, streamNamespace, createdAtField) .constraints( primaryKey(id), foreignKey(connectionId).references("connection", "id").onDeleteCascade()) .execute();  final String indexCreationQuery = String.format("CREATE INDEX ON %s USING btree (%s)", STREAM_REFRESHES_TABLE, connectionId.getName()); final String indexCreationQuery2 = String.format("CREATE INDEX ON %s USING btree (%s, %s)", STREAM_REFRESHES_TABLE, connectionId.getName(), streamName.getName()); final String indexCreationQuery3 = String.format("CREATE INDEX ON %s USING btree (%s, %s, %s)", STREAM_REFRESHES_TABLE, connectionId.getName(), streamName.getName(), streamNamespace.getName()); ctx.execute(indexCreationQuery); ctx.execute(indexCreationQuery2); ctx.execute(indexCreationQuery3); }
[*] target: assertEquals(4, index.size())
[-] pred: org. junit. Assert. assertEquals ( 4, index. size ( ) )
************************************
************************************
[+] input: shouldDetectAABBOverlapsWithFiltering() { // Given AABBf testForOverlap = new AABBf(1.0f, 5.1f, 0.0f, 2.0f, 10.0f, 0.0f); AABBTree<TestEntity> tree = givenTree(); TestEntity entity1 = new TestEntity(1, 0.0f, 0.0f, 10.0f, 10.0f); TestEntity entity2 = new TestEntity(2, -5.0f, 0.0f, 10.0f, 10.0f); tree.add(entity1); tree.add(entity2);  // When List<TestEntity> result = new ArrayList<>(); List<TestEntity> filteredResult = new ArrayList<>(); tree.detectOverlaps(testForOverlap, result); tree.detectOverlaps(testForOverlap, e -> e.getLongId() != 2, filteredResult);  // Then assertEquals(2, result.size()); "<AssertPlaceHolder>"; assertEquals(1, filteredResult.getFirst().getLongId()); }
size() { return objects.size(); }
[*] target: assertEquals(1, filteredResult.size())
[-] pred: org. junit. Assert. assertEquals ( 1, filteredResult. size ( ) )
************************************
************************************
[+] input: Exception { List<String> producerProps = Collections.singletonList("acks=1");  Properties prop = ProducerPerformance.readProps(producerProps, null, "1234", true);  "<AssertPlaceHolder>"; assertEquals("perf-producer-client", prop.getProperty("client.id")); }
readProps(List<String> producerProps, String producerConfig, String transactionalId, boolean transactionsEnabled) throws IOException { Properties props = new Properties(); if (producerConfig != null) { props.putAll(Utils.loadProps(producerConfig)); } if (producerProps != null) for (String prop : producerProps) { String[] pieces = prop.split("="); if (pieces.length != 2) throw new IllegalArgumentException("Invalid property: " + prop); props.put(pieces[0], pieces[1]); }  props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); if (transactionsEnabled) props.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, transactionalId); if (props.getProperty(ProducerConfig.CLIENT_ID_CONFIG) == null) { props.put(ProducerConfig.CLIENT_ID_CONFIG, "perf-producer-client"); } return props; }
[*] target: assertNotNull(prop)
[-] pred: org. junit. Assert. assertNotNull ( prop )
************************************
************************************
[+] input: Exception { ModelRepository modelRepository = Mockito.mock(ModelRepository.class); ModelService modelService = mockModelService(modelRepository); ModelReq modelReq = mockModelReq_update(); ModelDO modelDO = ModelConverter.convert(mockModelReq(), User.getFakeUser()); when(modelRepository.getModelById(modelReq.getId())).thenReturn(modelDO); User user = User.getFakeUser(); user.setName("alice"); ModelResp actualModelResp = modelService.updateModel(modelReq, user); ModelResp expectedModelResp = buildExpectedModelResp_update(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("admin", actualModelResp.getCreatedBy()); Assertions.assertEquals("alice", actualModelResp.getUpdatedBy()); }
updateModel(ModelReq modelReq, User user) throws Exception { checkParams(modelReq); ModelDO modelDO = modelRepository.getModelById(modelReq.getId()); ModelConverter.convert(modelDO, modelReq, user); modelRepository.updateModel(modelDO); batchCreateDimension(modelDO, user); batchCreateMetric(modelDO, user); return ModelConverter.convert(modelDO); }
[*] target: assertEquals(expectedModelResp, actualModelResp)
[-] pred: org. junit. Assert. assertEquals ( expectedModelResp, actualModelResp )
************************************
************************************
[+] input: testContainerOpenAndCloseListener() { // Open listener AtomicBoolean openFlag = new AtomicBoolean(false); container.addOnOpenListener(viewer -> { openFlag.set(true); }); container.onOpen(null); assertTrue(openFlag.get());  // Close listener AtomicBoolean closeFlag = new AtomicBoolean(false); container.addOnCloseListener(viewer -> { closeFlag.set(true); }); container.onClose(null); "<AssertPlaceHolder>"; }
onClose(ContainerViewer viewer);  void addOnOpenListener(Consumer<ContainerViewer> listener);  void removeOnOpenListener(Consumer<ContainerViewer> listener);  void addOnCloseListener(Consumer<ContainerViewer> listener);  void removeOnCloseListener(Consumer<ContainerViewer> listener);  void addOnSlotChangeListener(int slot, Consumer<ItemStack> listener);  void removeOnSlotChangeListener(int slot, Consumer<ItemStack> listener);  default ContainerSlotType getSlotType(int slot) { return getContainerType().getSlotType(slot); }
[*] target: assertTrue(closeFlag.get())
[-] pred: org. junit. Assert. assertTrue ( closeFlag. get ( ) )
************************************
************************************
[+] input: testErrorsInOnCloseCallbacksAreNotSwallowed() { IdempotentCloser ic = new IdempotentCloser();  // Verify initial invariants. assertFalse(ic.isClosed());  // Upon close, our onClose callback will throw an error. First ensure that it is thrown at the user. assertThrows(RuntimeException.class, () -> ic.close(CALLBACK_WITH_RUNTIME_EXCEPTION));  // Make sure the IdempotentCloser is still closed, though. "<AssertPlaceHolder>"; }
isClosed() { return isClosed.get(); }
[*] target: assertTrue(ic.isClosed())
[-] pred: org. junit. Assert. assertTrue ( ic. isClosed() )
************************************
************************************
[+] input: testThreeNodeQuorumVoteRejected() { int node1 = 1; int node2 = 2; CandidateState state = newCandidateState( voterSetWithLocal(Arrays.asList(node1, node2)) ); assertFalse(state.isVoteGranted()); assertFalse(state.isVoteRejected()); assertEquals(Utils.mkSet(node1, node2), state.unrecordedVoters()); assertTrue(state.recordRejectedVote(node1)); assertEquals(Collections.singleton(node2), state.unrecordedVoters()); assertFalse(state.isVoteGranted()); assertFalse(state.isVoteRejected()); assertTrue(state.recordRejectedVote(node2)); assertEquals(Collections.emptySet(), state.unrecordedVoters()); assertFalse(state.isVoteGranted()); "<AssertPlaceHolder>"; }
isVoteRejected() { return numGranted() + numUnrecorded() < majoritySize(); }
[*] target: assertTrue(state.isVoteRejected())
[-] pred: org. junit. Assert. assertTrue ( state. isVoteRejected() )
************************************
************************************
[+] input: APIException { AppStoreServerAPIClient client = getClientWithBody("models/extendSubscriptionRenewalDateResponse.json", request -> { Assertions.assertEquals("PUT", request.method()); Assertions.assertEquals("/inApps/v1/subscriptions/extend/4124214", request.url().encodedPath()); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(expectedMediaType, body.contentType()); Buffer buffer = new Buffer(); try { body.writeTo(buffer); } catch (IOException e) { throw new RuntimeException(e); } Map<String, Object> root; try { root = new ObjectMapper().readValue(buffer.readUtf8(), Map.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } Assertions.assertEquals(45, ((Number) root.get("extendByDays")).intValue()); Assertions.assertEquals(1, ((Number) root.get("extendReasonCode")).intValue()); Assertions.assertEquals("fdf964a4-233b-486c-aac1-97d8d52688ac", root.get("requestIdentifier")); });  ExtendRenewalDateRequest extendRenewalDateRequest = new ExtendRenewalDateRequest() .extendByDays(45) .extendReasonCode(ExtendReasonCode.CUSTOMER_SATISFACTION) .requestIdentifier("fdf964a4-233b-486c-aac1-97d8d52688ac");  ExtendRenewalDateResponse extendRenewalDateResponse = client.extendSubscriptionRenewalDate("4124214", extendRenewalDateRequest);  Assertions.assertNotNull(extendRenewalDateResponse); Assertions.assertEquals("2312412", extendRenewalDateResponse.getOriginalTransactionId()); Assertions.assertEquals("9993", extendRenewalDateResponse.getWebOrderLineItemId()); Assertions.assertTrue(extendRenewalDateResponse.getSuccess()); Assertions.assertEquals(1698148900000L, extendRenewalDateResponse.getEffectiveDate()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred: org. junit. Assert. assertNotNull ( body )
************************************
************************************
[+] input: increaseProtocolAdapterMetric_whenAlreadyExists_thenIncrementAndRegister() { protocolAdapterMetrics.increaseProtocolAdapterMetric("test");  final Counter counter = metricRegistry.getCounters().get(PROTOCOL_ADAPTER_PREFIX + "test.current"); "<AssertPlaceHolder>"; assertEquals(1L, counter.getCount()); }
increaseProtocolAdapterMetric(final @NotNull String protocolType) { metricRegistry.counter(PROTOCOL_ADAPTER_PREFIX + protocolType + ".current").inc(); currentAdapters.incrementAndGet(); }
[*] target: assertNotNull(counter)
[-] pred: org. junit. Assert. assertNotNull ( counter )
************************************
************************************
[+] input: idleBeat() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.idleBeat(new IdleBeatParam(jobId));  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(500, retval.getCode()); Assertions.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(IdleBeatParam idleBeatParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: testValueCanBeNull() { ApiMessageAndVersion key = new ApiMessageAndVersion(new ConsumerGroupMetadataKey(), (short) 0); CoordinatorRecord record = new CoordinatorRecord(key, null); assertEquals(key, record.key()); "<AssertPlaceHolder>"; }
value() { return this.value; }
[*] target: assertNull(record.value())
[-] pred: org. junit. Assert. assertNull ( record. value() )
************************************
************************************
[+] input: testSinkTasksStdout() { sinkProperties.remove(FileStreamSinkConnector.FILE_CONFIG); connector.start(sinkProperties); List<Map<String, String>> taskConfigs = connector.taskConfigs(1); "<AssertPlaceHolder>"; assertNull(taskConfigs.get(0).get(FileStreamSinkConnector.FILE_CONFIG)); }
taskConfigs(int maxTasks) { ArrayList<Map<String, String>> configs = new ArrayList<>(); for (int i = 0; i < maxTasks; i++) { configs.add(props); } return configs; }
[*] target: assertEquals(1, taskConfigs.size())
[-] pred: org. junit. Assert. assertEquals ( 1, taskConfigs. size ( ) )
************************************
************************************
[+] input: testError() { String errorStatus = "errorStatus"; String errorScope = "errorScope"; String errorOpenIDConfiguration = "errorOpenIDConfiguration"; OAuthBearerValidatorCallback callback = new OAuthBearerValidatorCallback(TOKEN.value()); callback.error(errorStatus, errorScope, errorOpenIDConfiguration); assertEquals(errorStatus, callback.errorStatus()); assertEquals(errorScope, callback.errorScope()); assertEquals(errorOpenIDConfiguration, callback.errorOpenIDConfiguration()); "<AssertPlaceHolder>"; }
token() { return token; }
[*] target: assertNull(callback.token())
[-] pred: org. junit. Assert. assertNull ( callback. token() )
************************************
************************************
[+] input: testGetEntriesInKeyPath_WithClassFilter() { Nibbles key1 = Nibbles.fromHexString("1234"); Nibbles key2 = Nibbles.fromHexString("12345678"); PendingInsertUpdate update1 = mock(PendingInsertUpdate.class); PendingTrieNodeChange update2 = mock(PendingTrieNodeChange.class); changes.put(key1, update1); changes.put(key2, update2);  List<Map.Entry<Nibbles, PendingInsertUpdate>> entries = trieChanges.getEntriesInKeyPath( PendingInsertUpdate.class, Nibbles.fromHexString("123456789")); "<AssertPlaceHolder>"; assertEquals(update1, entries.get(0).getValue()); }
getEntriesInKeyPath( @Nullable Class<P> clazz, Nibbles key) { Stream<Map.Entry<Nibbles, PendingTrieNodeChange>> stream = changes.subMap( Nibbles.EMPTY, true, key, true).entrySet().stream();  if (clazz != null) { stream = stream .filter(e -> clazz.isInstance(e.getValue())); }  return stream .filter(e -> key.startsWith(e.getKey())) .map(e -> Map.entry(e.getKey(), (P) e.getValue())) .toList(); }
[*] target: assertEquals(1, entries.size())
[-] pred: org. junit. Assert. assertEquals ( 1, entries. size ( ) )
************************************
************************************
[+] input: Exception { // Arrange JSONArray odinMessages = new JSONArray(); odinMessages.put(new JSONObject().put("role", "assistant") .put("content", "Some message.")); odinMessages.put(new JSONObject().put("role", "user") .put("content", "Hello!")); odinMessages.put(new JSONObject().put("role", "assistant") .put("content", "some other message.")); //The message history contains a new user prompt (unanswered user message) odinMessages.put(new JSONObject().put("role", "prompt") .put("content", "some new prompt"));  // mocking context List<Context.CapturedData> capturedDataList = new ArrayList<>(); capturedDataList.add(new Context.CapturedData("Clipboard", "Test content")); when(context.getCapturedDataList()).thenReturn(capturedDataList);  // Act Request request = requestBuilder.buildRequest(context, odinMessages, gptSettingsJsonObject);  // Assert "<AssertPlaceHolder>"; assertEquals("POST", request.method()); assertEquals("https://api.openai.com/v1/chat/completions", request.url().toString()); assertEquals(MediaType.parse("application/json; charset=utf-8"), request.body().contentType());    }
buildRequest(Context context, JSONArray odinMessages, JSONObject gptSettingsJsonObject) throws Exception{ // setting defaults String openaiApiKey = System.getenv("OPENAI_API_KEY_ODIN_FIRST"); String apiUrl = "https://api.openai.com/v1/chat/completions"; /* TO DO: Read from a config file (if any) and update defaults. */   boolean hasNewPrompt = false; String model = "gpt-4o-mini"; if (gptSettingsJsonObject.getString("gptProvider").equals("OpenAI (gpt-3.5-turbo)")) model = "gpt-3.5-turbo";  MediaType JSON = MediaType.parse("application/json; charset=utf-8");  JSONObject jsonBody = new JSONObject();  JSONArray messages = new JSONArray(); messages.put(new JSONObject().put("role", "system").put("content", "You are a helpful assistant."));  // Add text context List<Context.CapturedData> capturedDataList = context.getCapturedDataList(); for (Context.CapturedData capturedData : capturedDataList) { String captureMethod = capturedData.getCaptureMethod(); String capturedText = capturedData.getCapturedText(); if (captureMethod.equals("Clipboard")) { messages.put(new JSONObject().put("role", "system").put("content", "The text content from a portion of the user's clipboard is as follows: " + capturedText)); } else if (captureMethod.equals("Regionshot (OCR)")) { messages.put(new JSONObject().put("role", "system").put("content", "The text content captured by OCR from a portion of the user's screen is as follows: " + capturedText)); } else if (captureMethod.equals("Scrollshot (OCR)")) { messages.put(new JSONObject().put("role", "system").put("content", "The text content captured by OCR from a portion of the user's screen is included below. It might have some redundant lines. \n" + capturedText)); } else if (captureMethod.equals("File (Live)")) { messages.put(new JSONObject().put("role", "system").put("content", "The content of a file is included below: \n" + capturedText)); } } if(model.equals("gpt-4o-mini")) { //Add image context for (Context.CapturedData capturedData : capturedDataList) { String captureMethod = capturedData.getCaptureMethod(); String capturedText = capturedData.getCapturedText(); if (captureMethod.equals("Image File (Live)")) { messages.put(new JSONObject() .put("role", "user") .put("content", new JSONArray() .put(new JSONObject() .put("type", "text") .put("text", "This is an image. ")) .put(new JSONObject() .put("type", "image_url") .put("image_url", new JSONObject() .put("url", "data:image/png;base64," + capturedText)))) ); } } }  // Add chat history  for (int i = 0; i < odinMessages.length(); i++) { JSONObject message = odinMessages.getJSONObject(i); String role = message.getString("role"); String content = message.getString("content");  if ("user".equals(role)) { // Process user messages logger.info("User: " + content); messages.put(new JSONObject().put("role", "user").put("content", content)); } else if ("assistant".equals(role)) { // Process assistant messages logger.info("Assistant: " + content); messages.put(new JSONObject().put("role", "assistant").put("content", content)); } else if ("prompt".equals(role)) { // Process the prompt message logger.info("Prompt: " + content); messages.put(new JSONObject().put("role", "user").put("content", content)); hasNewPrompt = true; } else { // Handle other roles if needed logger.info("Unknown role: " + role); }  // If 'jsonInfo' field is present in the message, you can extract it like this: if (message.has("jsonInfo")) { String jsonInfo = message.getString("jsonInfo"); // Process jsonInfo if needed } }  if (!hasNewPrompt) { return null; // No new prompt to send } /* no longer needed, since the default is 16k if(GptOpsHelper.countWordsInJSONArray(messages) > 2000){ model = "gpt-3.5-turbo-16k"; } */ jsonBody.put("model", model);  jsonBody.put("messages", messages);  double temperatureDouble = gptSettingsJsonObject.getDouble("temperature"); float temperatureFloat = (float) temperatureDouble; jsonBody.put("temperature", temperatureFloat);  jsonBody.put("stream", true);  RequestBody requestBody = RequestBody.create(jsonBody.toString(), JSON); Request request = new Request.Builder() .url(apiUrl) .addHeader("Authorization", "Bearer " + openaiApiKey) .post(requestBody) .build(); return request; }
[*] target: assertNotNull(request)
[-] pred: org. junit. Assert. assertNotNull ( request )
************************************
************************************
[+] input: testConsumerGroupDescribeBeforeAndAfterCommittingOffset() { String consumerGroupId = "consumerGroupId"; int epoch = 10; String memberId1 = "memberId1"; String memberId2 = "memberId2"; String topicName = "topicName"; Uuid topicId = Uuid.randomUuid(); MetadataImage metadataImage = new MetadataImageBuilder() .addTopic(topicId, topicName, 3) .build();  MockPartitionAssignor assignor = new MockPartitionAssignor("range"); GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .withConsumerGroupAssignors(Collections.singletonList(assignor)) .withMetadataImage(metadataImage) .build();  ConsumerGroupMember.Builder memberBuilder1 = new ConsumerGroupMember.Builder(memberId1) .setSubscribedTopicNames(Collections.singletonList(topicName)); context.replay(CoordinatorRecordHelpers.newMemberSubscriptionRecord(consumerGroupId, memberBuilder1.build())); context.replay(CoordinatorRecordHelpers.newGroupEpochRecord(consumerGroupId, epoch + 1));  Map<Uuid, Set<Integer>> assignmentMap = new HashMap<>(); assignmentMap.put(topicId, Collections.emptySet());  ConsumerGroupMember.Builder memberBuilder2 = new ConsumerGroupMember.Builder(memberId2); context.replay(CoordinatorRecordHelpers.newMemberSubscriptionRecord(consumerGroupId, memberBuilder2.build())); context.replay(CoordinatorRecordHelpers.newTargetAssignmentRecord(consumerGroupId, memberId2, assignmentMap)); context.replay(CoordinatorRecordHelpers.newCurrentAssignmentRecord(consumerGroupId, memberBuilder2.build())); context.replay(CoordinatorRecordHelpers.newGroupEpochRecord(consumerGroupId, epoch + 2));  List<ConsumerGroupDescribeResponseData.DescribedGroup> actual = context.groupMetadataManager.consumerGroupDescribe(Collections.singletonList(consumerGroupId), context.lastCommittedOffset); ConsumerGroupDescribeResponseData.DescribedGroup describedGroup = new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupId(consumerGroupId) .setErrorCode(Errors.GROUP_ID_NOT_FOUND.code()); List<ConsumerGroupDescribeResponseData.DescribedGroup> expected = Collections.singletonList( describedGroup ); assertEquals(expected, actual);  // Commit the offset and test again context.commit();  actual = context.groupMetadataManager.consumerGroupDescribe(Collections.singletonList(consumerGroupId), context.lastCommittedOffset); describedGroup = new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupId(consumerGroupId) .setMembers(Arrays.asList( memberBuilder1.build().asConsumerGroupDescribeMember(new Assignment(Collections.emptyMap()), metadataImage.topics()), memberBuilder2.build().asConsumerGroupDescribeMember(new Assignment(assignmentMap), metadataImage.topics()) )) .setGroupState(ConsumerGroup.ConsumerGroupState.ASSIGNING.toString()) .setAssignorName("range") .setGroupEpoch(epoch + 2); expected = Collections.singletonList( describedGroup ); "<AssertPlaceHolder>"; }
build() { if (logContext == null) logContext = new LogContext(); if (snapshotRegistry == null) snapshotRegistry = new SnapshotRegistry(logContext); if (metadataImage == null) metadataImage = MetadataImage.EMPTY; if (time == null) time = Time.SYSTEM;  if (timer == null) throw new IllegalArgumentException("Timer must be set."); if (consumerGroupAssignors == null || consumerGroupAssignors.isEmpty()) throw new IllegalArgumentException("Assignors must be set before building."); if (metrics == null) throw new IllegalArgumentException("GroupCoordinatorMetricsShard must be set.");  return new GroupMetadataManager( snapshotRegistry, logContext, time, timer, metrics, consumerGroupAssignors, metadataImage, consumerGroupMaxSize, consumerGroupSessionTimeoutMs, consumerGroupHeartbeatIntervalMs, consumerGroupMetadataRefreshIntervalMs, classicGroupMaxSize, classicGroupInitialRebalanceDelayMs, classicGroupNewMemberJoinTimeoutMs, classicGroupMinSessionTimeoutMs, classicGroupMaxSessionTimeoutMs, consumerGroupMigrationPolicy ); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: isOrderInConsumingReturnsFalse() { Long currentLocalDateTimeMillis = 123456789L; when(order.getBillingStartDateMillis()).thenReturn(null); when(order.getBillingEndDateMillis()).thenReturn(null);  Boolean result = orderOtsHelper.isOrderInConsuming(order, currentLocalDateTimeMillis);  assertTrue(result);  when(order.getBillingStartDateMillis()).thenReturn(123456L); when(order.getBillingEndDateMillis()).thenReturn(1234567L);  result = orderOtsHelper.isOrderInConsuming(order, currentLocalDateTimeMillis);  "<AssertPlaceHolder>"; }
isOrderInConsuming(OrderDTO orderDTO, Long currentLocalDateTimeMillis) { if (orderDTO == null || orderDTO.getBillingStartDateMillis() == null || orderDTO.getBillingEndDateMillis() == null) { return Boolean.TRUE; } return currentLocalDateTimeMillis >= orderDTO.getBillingStartDateMillis() && currentLocalDateTimeMillis < orderDTO.getBillingEndDateMillis(); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testGetNestServiceByIdNonExistingServiceId() { SpecificationConfig.ServiceConfig result = specificationConfig.getNestServiceById("3"); "<AssertPlaceHolder>"; assertEquals("1", result.getId()); assertEquals("Service 1", result.getName()); }
getNestServiceById(String serviceId) { if (StringUtils.isEmpty(serviceId)) { return serviceConfigs.get(0); } else { Optional<ServiceConfig> serviceConfig = serviceConfigs.stream().filter(service -> service.getId().equals(serviceId)).findFirst(); return serviceConfig.orElse(serviceConfigs.get(0)); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final ListenableFuture<Integer> lf = SettableFuture.create(); final CompletableFuture<Integer> cf = toCompletableFuture(lf, testExecutor, true);  assertTrue(cf.cancel(false)); waitForAllCfsToComplete(cf); waitForAllLfsToComplete(lf);  assertTrue(lf.isCancelled()); assertThrowsExactly(CancellationException.class, lf::get); "<AssertPlaceHolder>"; assertThrowsExactly(CancellationException.class, cf::get); }
isCancelled() { return cf.isCancelled(); }
[*] target: assertTrue(cf.isCancelled())
[-] pred: org. junit. Assert. assertTrue ( cf. isCancelled ( ) )
************************************
************************************
[+] input: testInstantiation() { var operation = new UberJarOperation(); assertTrue(operation.jarSourceFiles().isEmpty()); assertTrue(operation.sourceDirectories().isEmpty()); assertNull(operation.destinationDirectory()); assertNull(operation.destinationFileName()); "<AssertPlaceHolder>"; }
mainClass() { return mainClass_; }
[*] target: assertNull(operation.mainClass())
[-] pred: org. junit. Assert. assertNull ( operation. mainClass() )
************************************
************************************
[+] input: testFromIcebergSingleColumn() { IcebergPartitionSpecExtractor extractor = IcebergPartitionSpecExtractor.getInstance();  Schema iceSchema = new Schema( Types.NestedField.required(0, "data_int", Types.IntegerType.get()), Types.NestedField.required(1, "key_string", Types.StringType.get())); PartitionSpec icePartitionSpec = PartitionSpec.builderFor(iceSchema).identity("key_string").build();  InternalSchema irSchema = InternalSchema.builder() .name("test_schema") .fields( Arrays.asList( InternalField.builder() .name("data_int") .schema(InternalSchema.builder().dataType(InternalType.INT).build()) .build(), InternalField.builder() .name("key_string") .fieldId(1) .schema(InternalSchema.builder().dataType(InternalType.STRING).build()) .build())) .build();  List<InternalPartitionField> irPartitionSpec = extractor.fromIceberg(icePartitionSpec, iceSchema, irSchema); Assertions."<AssertPlaceHolder>"; InternalField sourceField = irPartitionSpec.get(0).getSourceField(); Assertions.assertEquals("key_string", sourceField.getName()); Assertions.assertEquals(1, sourceField.getFieldId()); Assertions.assertEquals(InternalType.STRING, sourceField.getSchema().getDataType()); Assertions.assertEquals( PartitionTransformType.VALUE, irPartitionSpec.get(0).getTransformType()); }
fromIceberg( PartitionSpec iceSpec, Schema iceSchema, InternalSchema irSchema) { if (iceSpec.isUnpartitioned()) { return Collections.emptyList(); }  List<InternalPartitionField> irPartitionFields = new ArrayList<>(iceSpec.fields().size()); for (PartitionField iceField : iceSpec.fields()) { // fetch the ice field from the schema to properly handle hidden partition fields int sourceColumnId = iceField.sourceId(); Types.NestedField iceSchemaField = iceSchema.findField(sourceColumnId);  InternalField irField = SchemaFieldFinder.getInstance().findFieldByPath(irSchema, iceSchemaField.name()); InternalPartitionField irPartitionField = InternalPartitionField.builder() .sourceField(irField) .transformType(fromIcebergTransform(iceField.transform())) .build(); irPartitionFields.add(irPartitionField); }  return irPartitionFields; }
[*] target: assertEquals(1, irPartitionSpec.size())
[-] pred: org. junit. Assert. assertEquals ( 1, irPartitionSpec. size ( ) )
************************************
************************************
[+] input: testInstantiation() { var operation = new WarOperation(); assertTrue(operation.libSourceDirectories().isEmpty()); assertTrue(operation.classesSourceDirectories().isEmpty()); assertTrue(operation.jarSourceFiles().isEmpty()); assertNull(operation.webappDirectory()); assertNull(operation.webXmlFile()); assertNull(operation.destinationDirectory()); "<AssertPlaceHolder>"; }
destinationFileName() { return destinationFileName_; }
[*] target: assertNull(operation.destinationFileName())
[-] pred: org. junit. Assert. assertNull ( operation. destinationFileName() )
************************************
************************************
[+] input: testGetCompileTransitiveDependenciesPlay() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("com.typesafe.play", "play_2.13", new VersionNumber(2, 8, 19))); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(48, dependencies.size()); assertEquals(""" com.typesafe.play:play_2.13:2.8.19 org.scala-lang:scala-library:2.13.10 com.typesafe.play:build-link:2.8.19 com.typesafe.play:play-streams_2.13:2.8.19 com.typesafe.play:twirl-api_2.13:1.5.1 org.slf4j:slf4j-api:1.7.36 org.slf4j:jul-to-slf4j:1.7.36 org.slf4j:jcl-over-slf4j:1.7.36 com.typesafe.akka:akka-actor_2.13:2.6.20 com.typesafe.akka:akka-actor-typed_2.13:2.6.20 com.typesafe.akka:akka-slf4j_2.13:2.6.20 com.typesafe.akka:akka-serialization-jackson_2.13:2.6.20 com.fasterxml.jackson.core:jackson-core:2.11.4 com.fasterxml.jackson.core:jackson-annotations:2.11.4 com.fasterxml.jackson.datatype:jackson-datatype-jdk8:2.11.4 com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.11.4 com.fasterxml.jackson.core:jackson-databind:2.11.4 com.typesafe.play:play-json_2.13:2.8.2 com.google.guava:guava:30.1.1-jre io.jsonwebtoken:jjwt:0.9.1 jakarta.xml.bind:jakarta.xml.bind-api:2.3.3 jakarta.transaction:jakarta.transaction-api:1.3.3 javax.inject:javax.inject:1 org.scala-lang.modules:scala-java8-compat_2.13:1.0.2 com.typesafe:ssl-config-core_2.13:0.4.3 org.scala-lang.modules:scala-parser-combinators_2.13:1.1.2 com.typesafe.play:play-exceptions:2.8.19 org.reactivestreams:reactive-streams:1.0.3 com.typesafe.akka:akka-stream_2.13:2.6.20 org.scala-lang.modules:scala-xml_2.13:1.2.0 com.typesafe:config:1.4.2 com.fasterxml.jackson.module:jackson-module-parameter-names:2.11.4 com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:2.11.4 com.fasterxml.jackson.module:jackson-module-scala_2.13:2.11.4 org.lz4:lz4-java:1.8.0 com.typesafe.play:play-functional_2.13:2.8.2 org.scala-lang:scala-reflect:2.13.1 joda-time:joda-time:2.10.5 com.google.guava:failureaccess:1.0.1 com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava com.google.code.findbugs:jsr305:3.0.2 org.checkerframework:checker-qual:3.8.0 com.google.errorprone:error_prone_annotations:2.5.1 com.google.j2objc:j2objc-annotations:1.3 jakarta.activation:jakarta.activation-api:1.2.2 com.typesafe.akka:akka-protobuf-v3_2.13:2.6.20 com.fasterxml.jackson.module:jackson-module-paranamer:2.11.4 com.thoughtworks.paranamer:paranamer:2.8""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: testGetProcedures() { Routine mockProcedure = createMockProcedure(); when(bigQueryServiceMock.fetchRoutine(anyString(), anyString())) .thenReturn(Result.success(mockProcedure));  FunctionSignature expectedSignatureForMockProcedure = expectedSignatureForMockProcedure();  List<ProcedureInfo> procedures = bigqueryResourceProvider.getProcedures("project", ImmutableList.of("reference"));  "<AssertPlaceHolder>"; assertTrue( CatalogTestUtils.functionSignatureEquals( expectedSignatureForMockProcedure, procedures.get(0).getSignature())); }
getProcedures(String projectId, List<String> functionReferences) { return this.getRoutinesOfType(projectId, functionReferences, BigQueryAPIRoutineType.PROCEDURE) .stream() .map(this::buildProcedure) .collect(Collectors.toList()); }
[*] target: assertEquals(1, procedures.size())
[-] pred: org. junit. Assert. assertEquals ( 1, procedures. size ( ) )
************************************
************************************
[+] input: buildEntityType() { EntityType<Entity> type = EntityType.Builder.createNothing(MobCategory.MISC) .alwaysUpdateVelocity(true) .build();  "<AssertPlaceHolder>"; assertTrue(type.trackDeltas()); }
build() { throw new AssertionError("Implemented in Mixin"); }
[*] target: assertNotNull(type)
[-] pred: org. junit. Assert. assertNotNull ( type )
************************************
************************************
[+] input: testGetCurrentUser() { // set up a mock request context, details don't matter, just needed to make the // @RequestScope work on the CommunityCurrentUserService ServerRequestContext.with(HttpRequest.GET("/"), () -> { try { final User expectedUser = new User().withUserId(UserPersistence.DEFAULT_USER_ID); when(userPersistence.getDefaultUser()).thenReturn(Optional.ofNullable(expectedUser));  // First call - should fetch default user from userPersistence final User user1 = currentUserService.getCurrentUser(); Assertions.assertEquals(expectedUser, user1);  // Second call - should use cached user final User user2 = currentUserService.getCurrentUser(); Assertions."<AssertPlaceHolder>";  // Verify that getDefaultUser is called only once verify(userPersistence, times(1)).getDefaultUser(); } catch (final IOException e) { fail(e); } }); }
getCurrentUser() { if (this.retrievedDefaultUser == null) { try { this.retrievedDefaultUser = userPersistence.getDefaultUser().orElseThrow(); log.debug("Setting current user for request to retrieved default user: {}", retrievedDefaultUser); } catch (final Exception e) { throw new RuntimeException("Could not get the current user due to an internal error.", e); } } return this.retrievedDefaultUser; }
[*] target: assertEquals(expectedUser, user2)
[-] pred: org. junit. Assert. assertEquals ( expectedUser, user2 )
************************************
************************************
[+] input: testIdTrackingWithFieldRemoval() { // create initial schema with 2 fields and assign IDs Schema initial = Schema.createRecord( "test1", null, "hudi", false, Arrays.asList( new Schema.Field("field1", Schema.create(Schema.Type.STRING)), new Schema.Field("field2", Schema.create(Schema.Type.STRING)))); Schema initialWithIdTracking = idTracker.addIdTracking(initial, Option.empty(), false); // remove the second field Schema withFieldRemoved = Schema.createRecord( "test2", null, "hudi", false, Collections.singletonList( new Schema.Field("field1", Schema.create(Schema.Type.STRING)))); Schema withFieldRemovedAndIdTracking = idTracker.addIdTracking(withFieldRemoved, Option.of(initialWithIdTracking), false); IdTracking actualWithFieldRemoved = idTracker.getIdTracking(withFieldRemovedAndIdTracking).get(); IdTracking expectedWithFieldRemoved = new IdTracking(Collections.singletonList(new IdMapping("field1", 1)), 2); assertEquals(expectedWithFieldRemoved, actualWithFieldRemoved); // Adding a new field should be tracked with ID 3 Schema withFieldAdded = Schema.createRecord( "test2", null, "hudi", false, Arrays.asList( new Schema.Field("field1", Schema.create(Schema.Type.STRING)), new Schema.Field("field3", Schema.create(Schema.Type.STRING)))); Schema withFieldAddedAndIdTracking = idTracker.addIdTracking(withFieldAdded, Option.of(withFieldRemovedAndIdTracking), false); IdTracking actualWithFieldAdded = idTracker.getIdTracking(withFieldAddedAndIdTracking).get(); IdTracking expectedWithFieldAdded = new IdTracking(Arrays.asList(new IdMapping("field1", 1), new IdMapping("field3", 3)), 3); "<AssertPlaceHolder>"; }
getIdTracking(Schema schema) { try { Object propValue = schema.getObjectProp(ID_TRACKING); if (propValue == null) { return Option.empty(); } return Option.of( ID_TRACKING_READER.readValue((JsonNode) OBJECT_MAPPER.valueToTree(propValue))); } catch (IOException ex) { throw new UncheckedIOException(ex); } }
[*] target: assertEquals(expectedWithFieldAdded, actualWithFieldAdded)
[-] pred: org. junit. Assert. assertEquals ( expectedWithFieldAdded, actualWithFieldAdded )
************************************
************************************
[+] input: IOException { BaseMetalake metalake = createBaseMakeLake(RandomIdGenerator.INSTANCE.nextId(), metalakeName, auditInfo); backend.insert(metalake, false);  TagMetaService tagMetaService = TagMetaService.getInstance(); TagEntity tagEntity1 = TagEntity.builder() .withId(RandomIdGenerator.INSTANCE.nextId()) .withName("tag1") .withNamespace(TagManager.ofTagNamespace(metalakeName)) .withComment("comment") .withProperties(props) .withAuditInfo(auditInfo) .build(); tagMetaService.insertTag(tagEntity1, false);  boolean deleted = tagMetaService.deleteTag(TagManager.ofTagIdent(metalakeName, "tag1")); Assertions."<AssertPlaceHolder>";  deleted = tagMetaService.deleteTag(TagManager.ofTagIdent(metalakeName, "tag1")); Assertions.assertFalse(deleted);  Exception excep = Assertions.assertThrows( NoSuchEntityException.class, () -> tagMetaService.getTagByIdentifier(TagManager.ofTagIdent(metalakeName, "tag1"))); Assertions.assertEquals("No such tag entity: tag1", excep.getMessage()); }
insertTag(TagEntity tagEntity, boolean overwritten) throws IOException { Namespace ns = tagEntity.namespace(); String metalakeName = ns.level(0);  try { Long metalakeId = MetalakeMetaService.getInstance().getMetalakeIdByName(metalakeName);  TagPO.Builder builder = TagPO.builder().withMetalakeId(metalakeId); TagPO tagPO = POConverters.initializeTagPOWithVersion(tagEntity, builder);  SessionUtils.doWithCommit( TagMetaMapper.class, mapper -> { if (overwritten) { mapper.insertTagMetaOnDuplicateKeyUpdate(tagPO); } else { mapper.insertTagMeta(tagPO); } }); } catch (RuntimeException e) { ExceptionUtils.checkSQLException(e, Entity.EntityType.TAG, tagEntity.toString()); throw e; } }
[*] target: assertTrue(deleted)
[-] pred: org. junit. Assert. assertTrue ( deleted )
************************************
************************************
[+] input: testEqualsAndHashNameIdentifier() { NameIdentifier id1 = NameIdentifier.parse("a.b.c"); NameIdentifier id2 = NameIdentifier.parse("a.b.c");  assertTrue(id1.equals(id2)); assertTrue(id2.equals(id1)); "<AssertPlaceHolder>"; }
hashCode() { return Arrays.hashCode(new int[] {namespace.hashCode(), name.hashCode()}); }
[*] target: assertEquals(id1.hashCode(), id2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( id1. hashCode ( ), id2. hashCode ( ) )
************************************
************************************
[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }));  ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); frame = port.getNextFrame(); assertNotNull(frame); assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred: org. junit. Assert. assertNotNull ( frame )
************************************
************************************
[+] input: buildUndoSQL() { OracleUndoInsertExecutor executor = upperCase(); String sql = executor.buildUndoSQL(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("DELETE")); Assertions.assertTrue(sql.contains("ID")); Assertions.assertTrue(sql.contains("TABLE_NAME")); }
buildUndoSQL() { TableRecords afterImage = sqlUndoLog.getAfterImage(); List<Row> afterImageRows = afterImage.getRows(); if (CollectionUtils.isEmpty(afterImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } return generateDeleteSql(afterImageRows,afterImage); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: testVoidFuture() { RequestFuture<Void> future = new RequestFuture<>(); future.complete(null); assertTrue(future.isDone()); "<AssertPlaceHolder>"; }
value() { if (!succeeded()) throw new IllegalStateException("Attempt to retrieve value from future which hasn't successfully completed"); return (T) result.get(); }
[*] target: assertNull(future.value())
[-] pred: org. junit. Assert. assertNull ( future. value() )
************************************
************************************
[+] input: decreaseProtocolAdapterMetric() { metricRegistry.counter(PROTOCOL_ADAPTER_PREFIX + "test.current").inc(2);  protocolAdapterMetrics.decreaseProtocolAdapterMetric("test");  final Counter counter = metricRegistry.getCounters().get(PROTOCOL_ADAPTER_PREFIX + "test.current"); "<AssertPlaceHolder>"; assertEquals(1L, counter.getCount()); }
decreaseProtocolAdapterMetric(final @NotNull String protocolType) { metricRegistry.counter(PROTOCOL_ADAPTER_PREFIX + protocolType + ".current").dec(); currentAdapters.decrementAndGet(); }
[*] target: assertNotNull(counter)
[-] pred: org. junit. Assert. assertNotNull ( counter )
************************************
************************************
[+] input: testClear() { BoundedList<String> list = BoundedList.newArrayBacked(3); list.add("a"); list.add("a"); list.add("c"); list.clear(); assertEquals(Arrays.asList(), list); "<AssertPlaceHolder>"; }
isEmpty() { return underlying.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: testTieredLoadBalancer() { List<Upstream> upstreams = List.of( new Upstream("endpoint1", null, 1, 0), new Upstream("endpoint2", null, 9, 1) ); TieredBalancer balancer = new TieredBalancer("model1", upstreams);  // verify all requests go to the highest tier for (int j = 0; j < 50; j++) { UpstreamState upstream = balancer.next(); "<AssertPlaceHolder>"; assertEquals("endpoint1", upstream.getUpstream().getEndpoint()); } }
next();
[*] target: assertNotNull(upstream)
[-] pred: org. junit. Assert. assertNotNull ( upstream )
************************************
************************************
[+] input: testShouldRecordForDebugLevelSensor() { Sensor debugSensor = new Sensor(null, "debugSensor", null, INFO_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.DEBUG); assertFalse(debugSensor.shouldRecord());  debugSensor = new Sensor(null, "debugSensor", null, DEBUG_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.DEBUG); assertTrue(debugSensor.shouldRecord());  debugSensor = new Sensor(null, "debugSensor", null, TRACE_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.DEBUG); "<AssertPlaceHolder>"; }
shouldRecord() { return this.recordingLevel.shouldRecord(config.recordLevel().id); }
[*] target: assertTrue(debugSensor.shouldRecord())
[-] pred: org. junit. Assert. assertTrue ( debugSensor. shouldRecord() )
************************************
************************************
[+] input: login() { LoginRequest request = new LoginRequest(); request.setUsername("admin"); request.setPassword("123456"); request.setIsQuick(true); LoginTokenDto tokenDto = userService.login(request); "<AssertPlaceHolder>"; assertNotNull(tokenDto.getAccessToken()); }
login(LoginRequest request) { User user = lambdaQuery().eq(User::getUsername, request.getUsername()).one(); if (user == null) { throw new BizException(BizResponseCode.ERR_10002); } // 预览环境下可快速登录，不用验证码 if (Boolean.TRUE.equals(request.getIsQuick()) && Boolean.TRUE.equals(previewProperties.getPreview())) { return login(request, user); } if (StrUtil.isBlank(request.getCaptchaKey()) || !captchaService.verify(request.getCaptchaKey(), request.getCaptcha())) { throw new BizException(BizResponseCode.ERR_10003); } return login(request, user); }
[*] target: assertNotNull(tokenDto)
[-] pred: org. junit. Assert. assertNotNull ( tokenDto )
************************************
************************************
[+] input: negativeLifetime() { OAuthBearerToken token = new BasicOAuthBearerToken("not.valid.token", Collections.emptySet(), -1L, "jdoe", 0L); assertEquals("not.valid.token", token.value()); assertTrue(token.scope().isEmpty()); assertEquals(-1L, token.lifetimeMs()); assertEquals("jdoe", token.principalName()); "<AssertPlaceHolder>"; }
startTimeMs() { return startTimeMs; }
[*] target: assertEquals(0L, token.startTimeMs())
[-] pred: org. junit. Assert. assertEquals ( 0L, token. startTimeMs() )
************************************
************************************
[+] input: testExtractClaims_02() { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); Future<ExtractedClaims> future = validator.extractClaims("bad-auth-header"); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.failed()); assertNotNull(res.cause()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: IOException { int numChunks = 4; int chunkSize = 32; int totalSize = numChunks * chunkSize;  Queue<Send> sends = new LinkedList<>(); ByteBuffer[] chunks = new ByteBuffer[numChunks];  for (int i = 0; i < numChunks; i++) { ByteBuffer buffer = ByteBuffer.wrap(TestUtils.randomBytes(chunkSize)); chunks[i] = buffer; sends.add(new ByteBufferSend(buffer)); }  MultiRecordsSend send = new MultiRecordsSend(sends); assertEquals(totalSize, send.size());  for (int i = 0; i < numChunks; i++) { assertEquals(numChunks - i, send.numResidentSends()); NonOverflowingByteBufferChannel out = new NonOverflowingByteBufferChannel(chunkSize); send.writeTo(out); out.close(); assertEquals(chunks[i], out.buffer()); }  assertEquals(0, send.numResidentSends()); "<AssertPlaceHolder>"; }
completed() { return current == null; }
[*] target: assertTrue(send.completed())
[-] pred: org. junit. Assert. assertTrue ( send. completed() )
************************************
************************************
[+] input: testDice_getLastRoll() { Dice dice = new Dice(); int result = dice.roll(); assertEquals(result, dice.getLastRoll());  result = dice.roll(); "<AssertPlaceHolder>"; }
getLastRoll() { if (lastRoll == 0) { throw new IllegalStateException("This dice has not yet been rolled"); }  return lastRoll; }
[*] target: assertEquals(result, dice.getLastRoll())
[-] pred: org. junit. Assert. assertEquals ( result, dice. getLastRoll ( ) )
************************************
************************************
[+] input: testCreatingFromATestContainer() { final DataSource dataSource = Databases.createDataSource(container); "<AssertPlaceHolder>"; assertEquals(HikariDataSource.class, dataSource.getClass()); assertEquals(10, ((HikariDataSource) dataSource).getHikariConfigMXBean().getMaximumPoolSize()); }
createDataSource(final JdbcDatabaseContainer container) { return DataSourceFactory.create(container.getUsername(), container.getPassword(), container.getDriverClassName(), container.getJdbcUrl()); }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: testHasHeartbeatSatisfied() { ClassicGroupMember member = new ClassicGroupMember( "member", Optional.of("group-instance-id"), "client-id", "client-host", 10, 4500, "generic", new JoinGroupRequestProtocolCollection(), EMPTY_ASSIGNMENT );  assertFalse(member.hasSatisfiedHeartbeat());  member.setIsNew(true); assertFalse(member.hasSatisfiedHeartbeat());  member.setIsNew(false); member.setAwaitingJoinFuture(new CompletableFuture<>()); assertTrue(member.hasSatisfiedHeartbeat());  member.setAwaitingJoinFuture(null); member.setAwaitingSyncFuture(new CompletableFuture<>()); "<AssertPlaceHolder>"; }
hasSatisfiedHeartbeat() { if (isNew) { // New members can be expired even while awaiting join, so we check this first return false; } else { // Members that are awaiting a rebalance automatically satisfy expected heartbeats return isAwaitingJoin() || isAwaitingSync(); } }
[*] target: assertTrue(member.hasSatisfiedHeartbeat())
[-] pred: org. junit. Assert. assertTrue ( member. hasSatisfiedHeartbeat() )
************************************
************************************
[+] input: test_correct_relevant_memories_and_correct_amount_are_fetched() { MemoryStream stream = new MemoryStream(); stream.add(new Observation("memory")); stream.add(new Observation("")); stream.add(new Observation("2")); stream.add(new Observation("3")); stream.add(new Observation("4")); stream.add(new Observation("5")); stream.add(new Observation("6")); stream.add(new Observation("7")); stream.add(new Observation("8")); stream.add(new Observation("memory two")); stream.add(new Observation("9"));  List<Memory> memories = stream.getRelevantMemories("memory", -1);  "<AssertPlaceHolder>"; assertEquals("memory", memories.get(0).getDescription()); assertEquals("memory two", memories.get(1).getDescription()); }
getRelevantMemories(String query, int minImportance) { // score, memory index Map<Double, Integer> scores = new HashMap<Double, Integer>();  for (Memory memory : memories) { if (memory.getImportance() >= minImportance) { double score = memory.getScore(query); scores.put(score, memories.indexOf(memory)); } }  List<Double> keys = new ArrayList<Double>(scores.keySet()); Collections.sort(keys);  List<Integer> indices = scores.values().stream().collect(Collectors.toList());  if (scores.size() > 3) { double first = keys.get(keys.size() - 1); double second = keys.get(keys.size() - 2); double third = keys.get(keys.size() - 3);  indices = List.of(scores.get(first), scores.get(second), scores.get(third)); }  List<Memory> memCopies = new ArrayList<Memory>();  for (int index : indices) { memCopies.add(memories.get(index)); }  return memCopies; }
[*] target: assertEquals(3, memories.size())
[-] pred: org. junit. Assert. assertEquals ( 3, memories. size ( ) )
************************************
************************************
[+] input: testCollectFilter() { metrics.addMetric(metricName, (config, now) -> 100.0);  testEmitter.reconfigurePredicate(k -> !k.key().name().endsWith(".count")); collector.collect(testEmitter); List<SinglePointMetric> result = testEmitter.emittedMetrics();  // Should get exactly 1 Kafka measurables because we excluded the count measurable "<AssertPlaceHolder>";  Metric counter = result.get(0).builder().build();  assertTrue(counter.hasGauge()); assertEquals(100L, counter.getGauge().getDataPoints(0).getAsDouble(), 0.0); }
collect(MetricsEmitter metricsEmitter) { for (Map.Entry<MetricKey, KafkaMetric> entry : ledger.getMetrics()) { MetricKey metricKey = entry.getKey(); KafkaMetric metric = entry.getValue();  try { collectMetric(metricsEmitter, metricKey, metric); } catch (Exception e) { // catch and log to continue processing remaining metrics log.error("Error processing Kafka metric {}", metricKey, e); } } }
[*] target: assertEquals(1, result.size())
[-] pred: org. junit. Assert. assertEquals ( 1, result. size ( ) )
************************************
************************************
[+] input: SQLException { createBaseObjects();  final StandardSync syncGa = createStandardSync(source1, destination1); syncGa.setNotifySchemaChangesByEmail(true); standardSyncPersistence.writeStandardSync(syncGa); final StandardSync syncGa2 = createStandardSync(source2, destination2); syncGa2.setNotifySchemaChangesByEmail(true); standardSyncPersistence.writeStandardSync(syncGa2);  syncGa.setNotifySchemaChangesByEmail(false); standardSyncPersistence.writeStandardSync(syncGa); final List<NotificationConfigurationRecord> notificationConfigurations = getNotificationConfigurations();  "<AssertPlaceHolder>"; assertEquals(NotificationType.email, notificationConfigurations.stream().filter(notificationConfigurationRecord -> notificationConfigurationRecord.getConnectionId() .equals(syncGa.getConnectionId())).map(NotificationConfigurationRecord::getNotificationType).findFirst().get()); assertFalse(notificationConfigurations.stream().filter(notificationConfigurationRecord -> notificationConfigurationRecord.getConnectionId() .equals(syncGa.getConnectionId())).map(NotificationConfigurationRecord::getEnabled).findFirst().get()); }
writeStandardSync(final StandardSync standardSync) throws IOException { database.transaction(ctx -> { writeStandardSync(standardSync, ctx); return null; }); }
[*] target: assertEquals(2, notificationConfigurations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, notificationConfigurations. size ( ) )
************************************
************************************
[+] input: testGetValidTokenWhenTokenExists() { User user = new User(); user.setEmail("E1"); PasswordResetRequest request = new PasswordResetRequest(); request.setEmail("E1"); request.setToken("T1");  PasswordResetToken token = service.createTokenWithUser(user); //doReturn(Optional.of(token)).when(repository).findByToken("T1"); doReturn(token).when(repository).findByToken("T1"); PasswordResetToken validToken = service.getValidToken(request);  "<AssertPlaceHolder>"; assertEquals(user, validToken.getUser()); verify(repository, times(1)).findByToken("T1"); }
getValidToken(PasswordResetRequest request) { String tokenID = request.getToken(); PasswordResetToken token = repository.findByToken(tokenID); if (ObjectUtils.isEmpty(token)) { throw new ResourceNotFoundException("Password Reset Token", "Token Id", tokenID); }  matchEmail(token, request.getEmail()); verifyExpiration(token); return token; }
[*] target: assertEquals(token, validToken)
[-] pred: org. junit. Assert. assertEquals ( token, validToken )
************************************
************************************
[+] input: testCreateConfigsDatabaseMigrationCheck() { final var dslContext = mock(DSLContext.class); final var flyway = mock(Flyway.class); final var minimumMigrationVersion = "1.2.3"; final var timeoutMs = 500L; final var check = DatabaseCheckFactory.createConfigsDatabaseMigrationCheck(dslContext, flyway, minimumMigrationVersion, timeoutMs);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(ConfigsDatabaseMigrationCheck.class, check.getClass()); Assertions.assertTrue(check.getDatabaseAvailabilityCheck().isPresent()); Assertions.assertEquals(ConfigsDatabaseAvailabilityCheck.class, check.getDatabaseAvailabilityCheck().get().getClass()); Assertions.assertEquals(minimumMigrationVersion, check.getMinimumFlywayVersion()); Assertions.assertEquals(timeoutMs, check.getTimeoutMs()); Assertions.assertTrue(check.getFlyway().isPresent()); Assertions.assertEquals(flyway, check.getFlyway().get()); }
createConfigsDatabaseMigrationCheck(final DSLContext dslContext, final Flyway flyway, final String minimumMigrationVersion, final long timeoutMs) { return new ConfigsDatabaseMigrationCheck(createConfigsDatabaseAvailabilityCheck(dslContext, timeoutMs), flyway, minimumMigrationVersion, timeoutMs); }
[*] target: assertNotNull(check)
[-] pred: org. junit. Assert. assertNotNull ( check )
************************************
************************************
[+] input: testListCommodities() { String nextToken = "nextToken"; List<BaseOtsHelper.OtsFilter> filters = Collections.singletonList(new BaseOtsHelper.OtsFilter("key", Collections.singletonList("value"))); ListResult<CommodityDTO> expectedResult = new ListResult<>(); expectedResult.setData(Collections.emptyList()); expectedResult.setCount(0L); expectedResult.setNextToken(nextToken);  when(mockBaseOtsHelper.listEntities(eq(TABLE_NAME), eq(CommodityOtsConstant.SEARCH_INDEX_NAME), eq(filters), any(), any(), eq(nextToken), isNull(), eq(CommodityDTO.class))) .thenReturn(expectedResult);  ListResult<CommodityDTO> result = commodityOtsHelper.listCommodities(nextToken, filters, null);  "<AssertPlaceHolder>"; assertNotNull(result); assertEquals(0L, result.getCount()); }
listCommodities(String nextToken, List<BaseOtsHelper.OtsFilter> filters, List<Sort.Sorter> sorters) { return baseOtsHelper.listEntities(TABLE_NAME, CommodityOtsConstant.SEARCH_INDEX_NAME, filters, null, null, nextToken, sorters, CommodityDTO.class); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testCreatingAFlywayInstanceWithDefaults() { final String migrationFileLocation = "classpath:io/airbyte/db/instance/toys/migrations"; final DataSource dataSource = Databases.createDataSource(container); final Flyway flyway = FlywayFactory.create(dataSource, INSTALLED_BY, DB_IDENTIFIER, migrationFileLocation); "<AssertPlaceHolder>"; assertTrue(flyway.getConfiguration().isBaselineOnMigrate()); assertEquals(FlywayFactory.BASELINE_DESCRIPTION, flyway.getConfiguration().getBaselineDescription()); assertEquals(FlywayFactory.BASELINE_VERSION, flyway.getConfiguration().getBaselineVersion().getVersion()); assertEquals(FlywayFactory.BASELINE_ON_MIGRATION, flyway.getConfiguration().isBaselineOnMigrate()); assertEquals(INSTALLED_BY, flyway.getConfiguration().getInstalledBy()); assertEquals(String.format(FlywayFactory.MIGRATION_TABLE_FORMAT, DB_IDENTIFIER), flyway.getConfiguration().getTable()); assertEquals(migrationFileLocation, flyway.getConfiguration().getLocations()[0].getDescriptor()); }
create(final DataSource dataSource, final String installedBy, final String dbIdentifier, final String... migrationFileLocations) { return create(dataSource, installedBy, dbIdentifier, BASELINE_VERSION, BASELINE_DESCRIPTION, BASELINE_ON_MIGRATION, migrationFileLocations); }
[*] target: assertNotNull(flyway)
[-] pred: org. junit. Assert. assertNotNull ( flyway )
************************************
************************************
[+] input: InterruptedException { MirrorHeartbeatTask heartbeatTask = new MirrorHeartbeatTask(); heartbeatTask.start(TestUtils.makeProps("source.cluster.alias", "testSource", "target.cluster.alias", "testTarget")); List<SourceRecord> records = heartbeatTask.poll(); "<AssertPlaceHolder>"; Map<String, ?> sourcePartition = records.iterator().next().sourcePartition(); assertEquals(sourcePartition.get(Heartbeat.SOURCE_CLUSTER_ALIAS_KEY), "testSource", "sourcePartition's " + Heartbeat.SOURCE_CLUSTER_ALIAS_KEY + " record was not created"); assertEquals(sourcePartition.get(Heartbeat.TARGET_CLUSTER_ALIAS_KEY), "testTarget", "sourcePartition's " + Heartbeat.TARGET_CLUSTER_ALIAS_KEY + " record was not created"); }
poll() throws InterruptedException { // pause to throttle, unless we've stopped if (stopped.await(interval.toMillis(), TimeUnit.MILLISECONDS)) { // SourceWorkerTask expects non-zero batches or null return null; } long timestamp = System.currentTimeMillis(); Heartbeat heartbeat = new Heartbeat(sourceClusterAlias, targetClusterAlias, timestamp); SourceRecord record = new SourceRecord( heartbeat.connectPartition(), MirrorUtils.wrapOffset(0), heartbeatsTopic, 0, Schema.BYTES_SCHEMA, heartbeat.recordKey(), Schema.BYTES_SCHEMA, heartbeat.recordValue(), timestamp); return Collections.singletonList(record); }
[*] target: assertEquals(1, records.size())
[-] pred: org. junit. Assert. assertEquals ( 1, records. size ( ) )
************************************
************************************
[+] input: testBasicClose() { IdempotentCloser ic = new IdempotentCloser(); assertFalse(ic.isClosed()); ic.close(); "<AssertPlaceHolder>"; }
isClosed() { return isClosed.get(); }
[*] target: assertTrue(ic.isClosed())
[-] pred: org. junit. Assert. assertTrue ( ic. isClosed() )
************************************
************************************
[+] input: testGetCompileTransitiveDependenciesJettyFullExclusion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14)) .exclude("*", "*")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(1, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: convertAssignment1Test() { ASTTransformer transformer = new ASTTransformer();  // Import Namespace ScalarValues Resource namespaceResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertAssignmentTest/assignment1.ast.json").readAllBytes()); namespaceResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) namespaceResource.getContents().get(0); Package packageAssignment1 = (Package) namespace.getMember().get(0);  PartDefinition partDefinitionCounter = (PartDefinition) packageAssignment1.getMember().get(0);  AttributeUsage attributeUsagecount = (AttributeUsage) partDefinitionCounter.getMember().get(0);  assertEquals(0, ((LiteralInteger) attributeUsagecount.getValuation().getValue()).getValue());  ActionUsage actionUsageincr = (ActionUsage) partDefinitionCounter.getMember().get(1);  AssignmentActionUsage assignmentActionUsage = (AssignmentActionUsage) actionUsageincr.getMember().get(0);  assertEquals(attributeUsagecount, assignmentActionUsage.getReferent());  // to check and fix if needed // assertEquals(1, ((LiteralInteger) assignmentActionUsage.getTargetArgument()).getValue());  Expression expression = assignmentActionUsage.getValueExpression(); // Expression -> 1  assertEquals(null, expression);  }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(namespaceResource)
[-] pred: org. junit. Assert. assertNotNull ( namespaceResource )
************************************
************************************
[+] input: testDoesCompleteReassignmentAllNewReplicas() { PartitionReassignmentReplicas replicas = new PartitionReassignmentReplicas( partitionAssignment(Arrays.asList(0, 1, 2)), partitionAssignment(Arrays.asList(3, 4, 5))); "<AssertPlaceHolder>"; Optional<PartitionReassignmentReplicas.CompletedReassignment> reassignmentOptional = replicas.maybeCompleteReassignment(Arrays.asList(0, 1, 2, 3, 4, 5)); assertTrue(reassignmentOptional.isPresent()); PartitionReassignmentReplicas.CompletedReassignment completedReassignment = reassignmentOptional.get(); assertEquals(Arrays.asList(3, 4, 5), completedReassignment.isr); assertEquals(Arrays.asList(3, 4, 5), completedReassignment.replicas); }
isReassignmentInProgress() { return isReassignmentInProgress( removing, adding); }
[*] target: assertTrue(replicas.isReassignmentInProgress())
[-] pred: org. junit. Assert. assertTrue ( replicas. isReassignmentInProgress() )
************************************
************************************
[+] input: createTranscriptionTest() { //Grab OpenAI API key from system environment variables (gradle.properties) String apiKey = System.getenv("OPEN_AI_API_KEY"); String organization = System.getenv("OPEN_AI_ORGANIZATION"); assertNotNull(apiKey); assertNotNull(organization);  //Example audio file that we are going to upload to OpenAI to have a transcript of Path audioPath = getAudioPath(); assertNotNull(audioPath);  //Data that we are going to be sending to the API AudioData audioTranscriptionData = AudioData.builder() //Set the path for the audio file .setFilePath(audioPath) //Use the whisper-1 model for translation .setModel("whisper-1") //Option to specify language of the audio file //audioTranscriptionData.setLanguage("en"); .build();  //Additional tests on creating that data assertAll( () -> assertNotNull(AudioData.create(audioTranscriptionData.getFilePath())), () -> assertNotNull(AudioData.create(audioTranscriptionData.getFilePath(), Locale.FRENCH)), () -> assertNotNull(AudioData.create(audioTranscriptionData.getFilePath(), "fr")), () -> assertNotNull(audioTranscriptionData.getModel()) );  //Create OpenAI instance using API key & organization //Organization is optional OpenAI openAI = OpenAI.builder() .setApiKey(apiKey) .setOrganization(organization) .createTranscription(audioTranscriptionData) .build() //Finally, send our request to the API, this initiates the request (after .build()) .sendRequest();  assertNotNull(openAI);  //Call the CreateTranscription API from OpenAI & create instance Optional<CreateTranscription> optionalCreateTranscription = openAI.transcription(); assertFalse(optionalCreateTranscription.isEmpty());  //Additionally check the getter method is not null assertNotNull(openAI.getTranscription());  CreateTranscription createTranscription = optionalCreateTranscription.get();  //Transcript as a string (Audio File -> English) String transcript = createTranscription.asText(); assertNotNull(transcript); assertFalse(transcript.isEmpty());  //Get id from data structure example AudioResponseData responseData = createTranscription.asData(); assertNotNull(responseData);  assertNotNull(createTranscription.asNormalizedText());  //Json example String json = createTranscription.asJson(); "<AssertPlaceHolder>"; assertFalse(json.isEmpty()); }
asJson() { if(this.deserializedData == null) { this.deserializedData = deserialize(AudioResponseData.class); } if (!(this.deserializedData instanceof AudioResponseData)) { return null; } return JacksonJsonDeserializer.valuesAsString((AudioResponseData) this.deserializedData); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: shouldIncludeRecordsThatHappenedOnWindowStart() { final UnlimitedWindows w = UnlimitedWindows.of().startOn(ofEpochMilli(ANY_START_TIME)); final Map<Long, UnlimitedWindow> matchedWindows = w.windowsFor(w.startMs); "<AssertPlaceHolder>"; assertEquals(new UnlimitedWindow(ANY_START_TIME), matchedWindows.get(ANY_START_TIME)); }
size() { return Long.MAX_VALUE; }
[*] target: assertEquals(1, matchedWindows.size())
[-] pred: org. junit. Assert. assertEquals ( 1, matchedWindows. size() )
************************************
************************************
[+] input: executeQuery_TwoArgsOutOfOrder() { APIQuery query = new APIQuery(); query.setQuery("SELECT * FROM USERS WHERE ID >= :id AND NAME = :name AND ID = :id");  ObjectMapper mapper = new ObjectMapper(); ObjectNode args = mapper.createObjectNode(); args.put("id", 1); args.put("name", "John Doe");  String result = executor.executeQuery(query, args); "<AssertPlaceHolder>"; assertTrue(result.contains(""ID":1")); assertTrue(result.contains(""NAME":"John Doe"")); }
executeQuery(APIQuery query, JsonNode arguments) { Map<String, Object> paramMap = objectMapper.convertValue(arguments, Map.class); List<Map<String, Object>> rows = jdbcTemplate.query(query.getQuery(), paramMap, new ColumnMapRowMapper()); ArrayNode arrayNode = objectMapper.createArrayNode();  for (Map<String, Object> row : rows) { ObjectNode jsonObject = objectMapper.convertValue(row, ObjectNode.class); arrayNode.add(jsonObject); }  return arrayNode.toString(); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testBuildSentryExceptionsPythonMultilineValue() { final String stacktrace = """ Traceback (most recent call last): File "/usr/local/lib/python3.9/site-packages/grpc/_channel.py", line 849, in _end_unary_response_blocking raise _InactiveRpcError(state) grpc._channel._InactiveRpcError: <_InactiveRpcError of RPC that terminated with: status = StatusCode.INTERNAL details = "Internal error encountered." >  During handling of the above exception, another exception occurred:  Traceback (most recent call last): File "/usr/local/lib/python3.9/site-packages/google/api_core/exceptions.py", line 553, in _parse_grpc_error_details status = rpc_status.from_call(rpc_exc) AttributeError: 'NoneType' object has no attribute 'from_call' """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.PYTHON, parsedException.platform()); Assertions.assertEquals(2, exceptionList.size());  final String expectedValue = """ <_InactiveRpcError of RPC that terminated with: status = StatusCode.INTERNAL details = "Internal error encountered." >""";  assertExceptionContent(exceptionList.get(0), "grpc._channel._InactiveRpcError", expectedValue, List.of( Map.of( ABS_PATH, "/usr/local/lib/python3.9/site-packages/grpc/_channel.py", LINE_NO, 849, FUNCTION, "_end_unary_response_blocking", CONTEXT_LINE, "raise _InactiveRpcError(state)")));  assertExceptionContent(exceptionList.get(1), "AttributeError", "'NoneType' object has no attribute 'from_call'", List.of( Map.of( ABS_PATH, "/usr/local/lib/python3.9/site-packages/google/api_core/exceptions.py", LINE_NO, 553, FUNCTION, "_parse_grpc_error_details", CONTEXT_LINE, "status = rpc_status.from_call(rpc_exc)"))); }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred: org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )
************************************
************************************
[+] input: testJellyfinStudioItem() { JellyfinStudioItem studioItem = new JellyfinStudioItem();  String name = "TestName"; studioItem.setName(name); assertEquals(name, studioItem.getName());  String id = "TestID"; studioItem.setId(id); "<AssertPlaceHolder>"; }
getId() { return id; }
[*] target: assertEquals(id, studioItem.getId())
[-] pred: org. junit. Assert. assertEquals ( id, studioItem. getId() )
************************************
************************************
[+] input: buildUndoSQL() { String sql = executor.buildUndoSQL().toLowerCase(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("delete")); Assertions.assertTrue(sql.contains("id")); }
buildUndoSQL() { TableRecords afterImage = sqlUndoLog.getAfterImage(); List<Row> afterImageRows = afterImage.getRows(); if (CollectionUtils.isEmpty(afterImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } return generateDeleteSql(afterImageRows,afterImage); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: testFindVariablesWithSingleVariable() { String input = "Hello, {name}!"; List<String> variables = findVariables(input);  "<AssertPlaceHolder>"; assertEquals("name", variables.get(0)); }
findVariables(String input) { List<String> variables = new ArrayList<>(); Matcher matcher = PATTERN.matcher(input); while (matcher.find()) { variables.add(matcher.group(1)); } return variables; }
[*] target: assertEquals(1, variables.size())
[-] pred: org. junit. Assert. assertEquals ( 1, variables. size ( ) )
************************************
************************************
[+] input: putFirst() { var map = new MutableHashedLinkedMap<String, Integer>(); map.put("second", 2); map.put("third", 3);  var old = map.putFirst("first", 1);  "<AssertPlaceHolder>"; assertArrayEquals(arr("first", "second", "third"), keysArray(map)); assertArrayEquals(arr(1, 2, 3), valuesArray(map)); }
putFirst(K key, V value) { if (head != null) return putBefore(head.getKey(), key, value); return put(key, value); }
[*] target: assertNull(old)
[-] pred: org. junit. Assert. assertNull ( old )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/getStatusOfSubscriptionRenewalDateExtensionsResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v1/subscriptions/extend/mass/20fba8a0-2b80-4a7d-a17f-85c1854727f8/com.example.product", request.url().encodedPath()); Assertions."<AssertPlaceHolder>"; });  MassExtendRenewalDateStatusResponse massExtendRenewalDateStatusResponse = client.getStatusOfSubscriptionRenewalDateExtensions("com.example.product", "20fba8a0-2b80-4a7d-a17f-85c1854727f8");  Assertions.assertNotNull(massExtendRenewalDateStatusResponse); Assertions.assertEquals("20fba8a0-2b80-4a7d-a17f-85c1854727f8", massExtendRenewalDateStatusResponse.getRequestIdentifier()); Assertions.assertTrue(massExtendRenewalDateStatusResponse.getComplete()); Assertions.assertEquals(1698148900000L, massExtendRenewalDateStatusResponse.getCompleteDate()); Assertions.assertEquals(30, massExtendRenewalDateStatusResponse.getSucceededCount()); Assertions.assertEquals(2, massExtendRenewalDateStatusResponse.getFailedCount()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred: org. junit. Assert. assertNull ( request. body() )
************************************
************************************
[+] input: testNode1Child() { MetadataNode child = NODE.child("1"); "<AssertPlaceHolder>"; assertEquals("BrokerRegistration(id=1, epoch=1001, " + "incarnationId=MJkaH0j0RwuC3W2GHQHtWA, " + "listeners=[], " + "supportedFeatures={metadata.version: 1-4}, " + "rack=Optional.empty, " + "fenced=false, " + "inControlledShutdown=false, " + "isMigratingZkBroker=false, " + "directories=[JsnDDNVyTL289kYk6sPzig, anCdBWcFTlu8gE1wP6bh3g])", child.stringify()); }
child(String name) { try { Integer brokerId = Integer.valueOf(name); BrokerRegistration registration = image.brokers().get(brokerId); if (registration == null) return null; return new MetadataLeafNode(registration.toString()); } catch (NumberFormatException e) { return null; } }
[*] target: assertNotNull(child)
[-] pred: org. junit. Assert. assertNotNull ( child )
************************************
************************************
[+] input: buildLivingEntityType() { EntityType<LivingEntity> type = FabricEntityType.Builder.createLiving((t, w) -> null, MobCategory.MISC, living -> living .defaultAttributes(FabricEntityTypeTest::createAttributes) ).build();  "<AssertPlaceHolder>"; assertNotNull(DefaultAttributes.getSupplier(type)); }
build() { throw new AssertionError("Implemented in Mixin"); }
[*] target: assertNotNull(type)
[-] pred: org. junit. Assert. assertNotNull ( type )
************************************
************************************
[+] input: testGetTopicMetadataOfflinePartitions() { buildFetcher(); assignFromUser(singleton(tp0)); MetadataResponse originalResponse = newMetadataResponse(Errors.NONE); //baseline ok response  //create a response based on the above one with all partitions being leaderless List<MetadataResponse.TopicMetadata> altTopics = new ArrayList<>(); for (MetadataResponse.TopicMetadata item : originalResponse.topicMetadata()) { List<MetadataResponse.PartitionMetadata> partitions = item.partitionMetadata(); List<MetadataResponse.PartitionMetadata> altPartitions = new ArrayList<>(); for (MetadataResponse.PartitionMetadata p : partitions) { altPartitions.add(new MetadataResponse.PartitionMetadata( p.error, p.topicPartition, Optional.empty(), //no leader Optional.empty(), p.replicaIds, p.inSyncReplicaIds, p.offlineReplicaIds )); } MetadataResponse.TopicMetadata alteredTopic = new MetadataResponse.TopicMetadata( item.error(), item.topic(), item.isInternal(), altPartitions ); altTopics.add(alteredTopic); } Node controller = originalResponse.controller(); MetadataResponse altered = RequestTestUtils.metadataResponse( originalResponse.brokers(), originalResponse.clusterId(), controller != null ? controller.id() : MetadataResponse.NO_CONTROLLER_ID, altTopics);  client.prepareResponse(altered);  List<PartitionInfo> topicMetadata = topicMetadataFetcher.getTopicMetadata(topicName, false, time.timer(5000L));  "<AssertPlaceHolder>"; assertFalse(topicMetadata.isEmpty()); //noinspection ConstantConditions assertEquals(metadata.fetch().partitionCountForTopic(topicName).longValue(), topicMetadata.size()); }
getTopicMetadata(String topic, boolean allowAutoTopicCreation, Timer timer) { MetadataRequest.Builder request = new MetadataRequest.Builder(Collections.singletonList(topic), allowAutoTopicCreation); Map<String, List<PartitionInfo>> topicMetadata = getTopicMetadata(request, timer); return topicMetadata.get(topic); }
[*] target: assertNotNull(topicMetadata)
[-] pred: org. junit. Assert. assertNotNull ( topicMetadata )
************************************
************************************
[+] input: testFirstTick() { CompletableFuture<Void> tick = ticker.tick(); "<AssertPlaceHolder>"; assertFalse(tick.isDone()); }
tick() { return maybeNextTick(); }
[*] target: assertNotNull(tick)
[-] pred: org. junit. Assert. assertNotNull ( tick )
************************************
************************************
[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }));  ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); frame = port.getNextFrame(); assertNotNull(frame); assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred: org. junit. Assert. assertNotNull ( frame )
************************************
************************************
[+] input: ConfigNotFoundException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); when(actorDefinitionVersionHelper.getSourceVersion(any(), eq(workspaceId), eq(sourceId))).thenReturn(testSourceVersion.withSpec(null)); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final ObjectNode expectedConfig = ((ObjectNode) Jsons.clone(config)); for (final String key : oauthParameters.keySet()) { expectedConfig.set(key, Jsons.jsonNode(oauthParameters.get(key))); } "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: testConversionTargetFromNameForDELTA() { ConversionTarget tc = ConversionTargetFactory.getInstance().createConversionTargetForName(TableFormat.DELTA); "<AssertPlaceHolder>"; TargetTable targetTable = getPerTableConfig(TableFormat.DELTA); Configuration conf = new Configuration(); conf.set("spark.master", "local"); tc.init(targetTable, conf); assertEquals(tc.getTableFormat(), TableFormat.DELTA); }
createConversionTargetForName(String tableFormatName) { ServiceLoader<ConversionTarget> loader = ServiceLoader.load(ConversionTarget.class); for (ConversionTarget target : loader) { if (target.getTableFormat().equalsIgnoreCase(tableFormatName)) { return target; } } throw new NotSupportedException("Target format is not yet supported: " + tableFormatName); }
[*] target: assertNotNull(tc)
[-] pred: org. junit. Assert. assertNotNull ( tc )
************************************
************************************
[+] input: testUpdateColumnDefaultValue() { String[] fieldName = {"existing_column"}; Expression newDefaultValue = Literals.of("Default Value", Types.VarCharType.of(255)); UpdateColumnDefaultValue updateColumnDefaultValue = (UpdateColumnDefaultValue) TableChange.updateColumnDefaultValue(fieldName, newDefaultValue);  assertArrayEquals(fieldName, updateColumnDefaultValue.fieldName()); "<AssertPlaceHolder>"; }
getNewDefaultValue() { return newDefaultValue; }
[*] target: assertEquals(newDefaultValue, updateColumnDefaultValue.getNewDefaultValue())
[-] pred: org. junit. Assert. assertEquals ( newDefaultValue, updateColumnDefaultValue. getNewDefaultValue() )
************************************
************************************
[+] input: testCreateWithProfileDataAndLineRangeStartOnly() { CommandLineArgs args = CommandLineArgs.create(persistency, new String[] { "--source", anySourceCode, "--profiledata", anyProfileData } );  assertEquals(anySourceCode, args.sourceCode); assertEquals(anyProfileData, args.profileData); "<AssertPlaceHolder>"; }
hasErrors() { return !StringUtil.isNullOrEmpty(errors); }
[*] target: assertFalse(args.hasErrors())
[-] pred: org. junit. Assert. assertFalse ( args. hasErrors() )
************************************
************************************
[+] input: testExecute() { final Supplier<String> supplier = mock(Supplier.class); when(supplier.get()).thenReturn("hello");  final TemporalResponse<String> response = temporalClient.execute(JOB_RUN_CONFIG, supplier);  "<AssertPlaceHolder>"; assertTrue(response.getOutput().isPresent()); assertEquals("hello", response.getOutput().get()); assertTrue(response.getMetadata().isSucceeded()); assertEquals(logPath, response.getMetadata().getLogPath()); }
execute(final JobRunConfig jobRunConfig, final Supplier<T> executor) { final Path jobRoot = TemporalUtils.getJobRoot(workspaceRoot, jobRunConfig.getJobId(), jobRunConfig.getAttemptId()); final Path logPath = TemporalUtils.getLogPath(jobRoot);  T operationOutput = null; RuntimeException exception = null;  try { operationOutput = executor.get(); } catch (final RuntimeException e) { exception = e; }  boolean succeeded = exception == null; if (succeeded && operationOutput instanceof ConnectorJobOutput) { succeeded = getConnectorJobSucceeded((ConnectorJobOutput) operationOutput); }  final JobMetadata metadata = new JobMetadata(succeeded, logPath); return new TemporalResponse<>(operationOutput, metadata); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testGetCurrentUser() { // set up a mock request context, details don't matter, just needed to make the // @RequestScope work on the SecurityAwareCurrentUserService ServerRequestContext.with(HttpRequest.GET("/"), () -> { try { final String authUserId = "testUser"; final User expectedUser = new User().withAuthUserId(authUserId);  when(securityService.username()).thenReturn(Optional.of(authUserId)); when(userPersistence.getUserByAuthId(authUserId)).thenReturn(Optional.of(expectedUser));  // First call - should fetch from userPersistence final User user1 = currentUserService.getCurrentUser(); Assertions.assertEquals(expectedUser, user1);  // Second call - should use cached user final User user2 = currentUserService.getCurrentUser(); Assertions."<AssertPlaceHolder>";  // Verify that getUserByAuthId is called only once verify(userPersistence, times(1)).getUserByAuthId(authUserId); } catch (final IOException e) { fail(e); } }); }
getCurrentUser() { if (this.retrievedCurrentUser == null) { try { final String authUserId = securityService.username().orElseThrow(); this.retrievedCurrentUser = userPersistence.getUserByAuthId(authUserId).orElseThrow(); log.debug("Setting current user for request to: {}", retrievedCurrentUser); } catch (final Exception e) { throw new AuthException("Could not get the current Airbyte user due to an internal error.", e); } } return this.retrievedCurrentUser; }
[*] target: assertEquals(expectedUser, user2)
[-] pred: org. junit. Assert. assertEquals ( expectedUser, user2 )
************************************
************************************
[+] input: testGetCompileTransitiveDependenciesMaven() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.apache.maven", "maven-core", new VersionNumber(3, 9, 0))); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(32, dependencies.size()); assertEquals(""" org.apache.maven:maven-core:3.9.0 org.apache.maven:maven-model:3.9.0 org.apache.maven:maven-settings:3.9.0 org.apache.maven:maven-settings-builder:3.9.0 org.apache.maven:maven-builder-support:3.9.0 org.apache.maven:maven-repository-metadata:3.9.0 org.apache.maven:maven-artifact:3.9.0 org.apache.maven:maven-plugin-api:3.9.0 org.apache.maven:maven-model-builder:3.9.0 org.apache.maven:maven-resolver-provider:3.9.0 org.apache.maven.resolver:maven-resolver-impl:1.9.4 org.apache.maven.resolver:maven-resolver-api:1.9.4 org.apache.maven.resolver:maven-resolver-spi:1.9.4 org.apache.maven.resolver:maven-resolver-util:1.9.4 org.apache.maven.shared:maven-shared-utils:3.3.4 org.eclipse.sisu:org.eclipse.sisu.plexus:0.3.5 org.eclipse.sisu:org.eclipse.sisu.inject:0.3.5 com.google.inject:guice:5.1.0 com.google.guava:guava:30.1-jre com.google.guava:failureaccess:1.0.1 javax.inject:javax.inject:1 org.codehaus.plexus:plexus-utils:3.4.2 org.codehaus.plexus:plexus-classworlds:2.6.0 org.codehaus.plexus:plexus-interpolation:1.26 org.codehaus.plexus:plexus-component-annotations:2.1.0 org.apache.commons:commons-lang3:3.8.1 org.slf4j:slf4j-api:1.7.36 org.codehaus.plexus:plexus-sec-dispatcher:2.0 org.apache.maven.resolver:maven-resolver-named-locks:1.9.4 javax.annotation:javax.annotation-api:1.2 aopalliance:aopalliance:1.0 org.codehaus.plexus:plexus-cipher:2.0""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: testCreatingVerticalAdjacent() { Vertex cell1 = new Cell(1); Vertex cell2 = new Cell(2);  cell1.creatingVerticalAdjacent(cell2);  assertEquals(1, cell1.getAdjacents().size()); "<AssertPlaceHolder>"; }
getAdjacents() { return this.adjacents; }
[*] target: assertEquals(1, cell2.getAdjacents().size())
[-] pred: org. junit. Assert. assertEquals ( 1, cell2. getAdjacents(). size ( ) )
************************************
************************************
[+] input: givenCorruptedKeySegment_whenCheckingChecksum_thenIsChecksumValidReturnsFalse() { // Given byte[] testData = new byte[]{ (byte) -83, (byte) 64, 0x00, 0x05,         // Key Size 0x00, 0x00, 0x00, 0x05, // Value Size 0x48, 0x65, 0x6C, 0x6C, 0x6E, // Key: "Hello" (Bit Flipped) 0x57, 0x6F, 0x72, 0x6C, 0x64  // Value: "World" };  // When Segment corruptedSegment = Segment.fromByteArray(testData);  // Then assertFalse(corruptedSegment.isChecksumValid()); "<AssertPlaceHolder>"; }
isSegmentValid() { return isChecksumValid() && getKeySize() > 0 && getValueSize() >= 0 && bytes.length == CRC_LENGTH + KEY_SIZE_LENGTH + VALUE_SIZE_LENGTH + getKeySize() + getValueSize(); }
[*] target: assertFalse(corruptedSegment.isSegmentValid())
[-] pred: org. junit. Assert. assertFalse ( corruptedSegment. isSegmentValid ( ) )
************************************
************************************
[+] input: givenValidUserClaims_whenTokensGenerated_thenReturnAysToken() { // Given AysUser mockUser = new AysUserBuilder() .withValidValues() .build(); Claims mockUserClaims = mockUser.getClaims();  // When Mockito.when(tokenConfiguration.getIssuer()).thenReturn(MOCK_ISSUER); Mockito.when(tokenConfiguration.getAccessTokenExpireMinute()).thenReturn(MOCK_ACCESS_TOKEN_EXPIRE_MINUTE); Mockito.when(tokenConfiguration.getRefreshTokenExpireDay()).thenReturn(MOCK_REFRESH_TOKEN_EXPIRE_DAY); Mockito.when(tokenConfiguration.getPrivateKey()).thenReturn(MOCK_PRIVATE_KEY);  // Then AysToken aysToken = tokenService.generate(mockUserClaims);  Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(aysToken.getAccessToken()); Assertions.assertNotNull(aysToken.getAccessTokenExpiresAt()); Assertions.assertNotNull(aysToken.getRefreshToken());  // Verify Mockito.verify(tokenConfiguration, Mockito.times(1)).getIssuer(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getAccessTokenExpireMinute(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getRefreshTokenExpireDay(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getPrivateKey(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getPublicKey(); Mockito.verifyNoMoreInteractions(tokenConfiguration); }
generate(final Claims claims) {  final long currentTimeMillis = System.currentTimeMillis();  final JwtBuilder tokenBuilder = this.initializeTokenBuilder(currentTimeMillis);  final Date accessTokenExpiresAt = DateUtils.addMinutes( new Date(currentTimeMillis), tokenConfiguration.getAccessTokenExpireMinute() ); final String accessToken = tokenBuilder .id(AysRandomUtil.generateUUID()) .expiration(accessTokenExpiresAt) .claims(claims) .compact();  final Date refreshTokenExpiresAt = DateUtils.addDays( new Date(currentTimeMillis), tokenConfiguration.getRefreshTokenExpireDay() ); final String refreshToken = tokenBuilder .id(AysRandomUtil.generateUUID()) .expiration(refreshTokenExpiresAt) .claim(AysTokenClaims.USER_ID.getValue(), claims.get(AysTokenClaims.USER_ID.getValue())) .compact();  return AysToken.builder() .accessToken(accessToken) .accessTokenExpiresAt(accessTokenExpiresAt.toInstant().getEpochSecond()) .refreshToken(refreshToken) .build(); }
[*] target: assertNotNull(aysToken)
[-] pred: org. junit. Assert. assertNotNull ( aysToken )
************************************
************************************
[+] input: queryAssignment() { QueryAssignmentRequest request = QueryAssignmentRequest.newBuilder() .setTopic(Resource.newBuilder().setName("topic").build()) .setGroup(Resource.newBuilder().setName("group").build()) .build();  CompletableFuture<QueryAssignmentResponse> future = routeActivity.queryAssignment(ProxyContextExt.create(), request); "<AssertPlaceHolder>"; assertTrue(future.isDone()); assertFalse(future.isCompletedExceptionally());  QueryAssignmentResponse response = future.join(); assertEquals(Code.OK, response.getStatus().getCode()); assertEquals(1, response.getAssignmentsList().size());  MessageQueue queue = response.getAssignmentsList().get(0).getMessageQueue(); assertEquals(2, queue.getId());  Broker broker = queue.getBroker(); assertEquals("1_2", broker.getName()); assertEquals(1, broker.getEndpoints().getAddressesCount());  apache.rocketmq.v2.Address addresses = broker.getEndpoints().getAddresses(0); assertEquals("broker", addresses.getHost()); assertEquals(10911, addresses.getPort());  }
queryAssignment(ProxyContext ctx, QueryAssignmentRequest request) { return super.queryAssignment(ctx, request).thenApply(response -> { QueryAssignmentResponse.Builder newBuilder = QueryAssignmentResponse.newBuilder(response); List<Assignment> assignmentsList = newBuilder.getAssignmentsList(); for (int i = 0; i < assignmentsList.size(); i++) { Assignment assignment = assignmentsList.get(i); MessageQueue messageQueue = assignment.getMessageQueue(); VirtualQueue virtualQueue = new VirtualQueue(messageQueue.getBroker().getName());  MessageQueue newQueue = MessageQueue.newBuilder(messageQueue).setId(virtualQueue.physicalQueueId()).build(); Assignment newAssignment = Assignment.newBuilder(assignment).setMessageQueue(newQueue).build(); newBuilder.setAssignments(i, newAssignment); } return newBuilder.build(); }); }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: ConfigNotFoundException { setupStandardDefinitionMock(createAdvancedAuth() .withPredicateKey(null) .withPredicateValue(null)); final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: testJoinPrepareAndCommitWithUnknownMemberId() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.UNKNOWN_MEMBER_ID);  int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId); coordinator.invokeCompletedOffsetCommitCallbacks();  "<AssertPlaceHolder>"; assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: testInstantiation() { var operation = new PrecompileOperation(); assertTrue(operation.templateTypes().isEmpty()); assertTrue(operation.sourceDirectories().isEmpty()); "<AssertPlaceHolder>"; }
destinationDirectory() { return destinationDirectory_; }
[*] target: assertNull(operation.destinationDirectory())
[-] pred: org. junit. Assert. assertNull ( operation. destinationDirectory() )
************************************
************************************
[+] input: testRender() { Map<String, Object> model = createTestMap(); model.put("key3", 100);  // Create a simple template with placeholders for keys in the generative String template = "This is a {key1}, it is {key2}, and it costs {key3}"; PromptTemplate promptTemplate = new PromptTemplate(template, model);  // The expected result after rendering the template with the generative String expected = "This is a value1, it is true, and it costs 100"; String result = promptTemplate.render();  // Check that the rendered string matches the expected result assertEquals(expected, result);  model.put("key3", 200); expected = "This is a value1, it is true, and it costs 200"; result = promptTemplate.render(model); "<AssertPlaceHolder>"; }
render(Map<String, Object> model) { validate(model); for (Entry<String, Object> entry : model.entrySet()) { if (this.st.getAttribute(entry.getKey()) != null) { this.st.remove(entry.getKey()); } if (entry.getValue() instanceof Resource) { this.st.add(entry.getKey(), renderResource((Resource) entry.getValue())); } else { this.st.add(entry.getKey(), entry.getValue()); }  } return this.st.render(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: NoSuchAlgorithmException { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); IdentityProvider provider1 = mock(IdentityProvider.class); when(provider1.match(any(DecodedJWT.class))).thenReturn(false); IdentityProvider provider2 = mock(IdentityProvider.class); when(provider2.match(any(DecodedJWT.class))).thenReturn(false); List<IdentityProvider> providerList = List.of(provider1, provider2); validator.setProviders(providerList); KeyPair keyPair = generateRsa256Pair(); Algorithm algorithm = Algorithm.RSA256((RSAPublicKey) keyPair.getPublic(), (RSAPrivateKey) keyPair.getPrivate()); String token = JWT.create().withClaim("iss", "unknown-issuer").sign(algorithm); Future<ExtractedClaims> future = validator.extractClaims(getBearerHeaderValue(token)); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.failed()); assertNotNull(res.cause()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testMigrationBlankDatabase() { final DSLContext ctx = getDslContext();  // this test is specifically ensuring that lack of a workspace record does not cause an error // while creating the default user and organization. assertEquals(0, ctx.fetchCount(DSL.table("workspace")));  V0_50_19_001__CreateDefaultOrganizationAndUser.createDefaultUserAndOrganization(ctx);  // verify that a User record was written to the database final var userRecord = ctx.selectFrom(DSL.table(USER_TABLE)) .where(DSL.field("id").eq(EXPECTED_DEFAULT_USER_ID)) .fetchOne(); "<AssertPlaceHolder>"; assertEquals("", userRecord.get(DSL.field("email", String.class))); assertEquals("Default User", userRecord.get(DSL.field("name", String.class))); assertNull(userRecord.get(DSL.field("default_workspace_id", UUID.class)));  // verify that an Organization record was written to the database final var organizationRecord = ctx.selectFrom(DSL.table("organization")) .where(DSL.field("id").eq(EXPECTED_DEFAULT_ORGANIZATION_ID)) .fetchOne(); assertNotNull(organizationRecord); assertEquals("", organizationRecord.get(DSL.field("email", String.class))); assertEquals("Default Organization", organizationRecord.get(DSL.field("name", String.class))); assertEquals(EXPECTED_DEFAULT_USER_ID, organizationRecord.get(DSL.field("user_id", UUID.class)));  // verify that a permission record was written to add the User to the Organization final var userPermissionRecord = ctx.selectFrom(DSL.table("permission")) .where(DSL.field("user_id").eq(EXPECTED_DEFAULT_USER_ID)) .fetch() .get(0); assertNotNull(userPermissionRecord); assertEquals(EXPECTED_DEFAULT_ORGANIZATION_ID, userPermissionRecord.get(DSL.field("organization_id", SQLDataType.UUID))); }
createDefaultUserAndOrganization(final DSLContext ctx) { // return early if a default user or default organization already exist. // this shouldn't happen in practice, but if this migration somehow gets run // multiple times or an instance is for some reason already using the // all-zero UUID, we don't want to overwrite any existing records. if (ctx.fetchExists(select() .from(DSL.table(USER_TABLE)) .where(ID_COLUMN.eq(DEFAULT_USER_ID)))) { LOGGER.info("Default user already exists. Skipping this migration."); return; }  if (ctx.fetchExists(select() .from(DSL.table(ORGANIZATION_TABLE)) .where(ID_COLUMN.eq(DEFAULT_ORGANIZATION_ID)))) { LOGGER.info("Default organization already exists. Skipping this migration."); return; }  final Optional<UUID> workspaceIdOptional = getDefaultWorkspaceIdOptional(ctx); final String email = workspaceIdOptional.flatMap(workspaceId -> getWorkspaceEmailOptional(ctx, workspaceId)).orElse(DEFAULT_EMAIL); final UUID defaultWorkspaceId = workspaceIdOptional.orElse(null);  // insert the default User record ctx.insertInto(DSL.table(USER_TABLE)) .columns(ID_COLUMN, EMAIL_COLUMN, NAME_COLUMN, AUTH_USER_ID_COLUMN, DEFAULT_WORKSPACE_ID_COLUMN, STATUS_COLUMN, AUTH_PROVIDER_COLUMN) .values(DEFAULT_USER_ID, email, DEFAULT_USER_NAME, DEFAULT_USER_ID.toString(), defaultWorkspaceId, DEFAULT_USER_STATUS, DEFAULT_AUTH_PROVIDER) .execute();  ctx.insertInto(DSL.table(ORGANIZATION_TABLE)) .columns(ID_COLUMN, EMAIL_COLUMN, NAME_COLUMN, USER_ID_COLUMN) .values(DEFAULT_ORGANIZATION_ID, email, DEFAULT_ORGANIZATION_NAME, DEFAULT_USER_ID) .execute();  // update the default workspace to point to the default organization if (workspaceIdOptional.isPresent()) { LOGGER.info("Updating default workspace with ID {} to belong to default organization with ID {}", workspaceIdOptional.get(), DEFAULT_ORGANIZATION_ID); ctx.update(DSL.table(WORKSPACE_TABLE)) .set(ORGANIZATION_ID_COLUMN, DEFAULT_ORGANIZATION_ID) .where(ID_COLUMN.eq(workspaceIdOptional.get())) .execute(); } else { LOGGER.info("No default workspace found. Skipping update of default workspace to point to default organization."); }  // grant the default user admin permissions on the default organization LOGGER.info("Granting ORGANIZATION_ADMIN permission to default user with ID {} on default organization with ID {}", DEFAULT_USER_ID, DEFAULT_ORGANIZATION_ID); ctx.insertInto(DSL.table(PERMISSION_TABLE)) .columns(ID_COLUMN, USER_ID_COLUMN, ORGANIZATION_ID_COLUMN, PERMISSION_TYPE_COLUMN) .values(UUID.randomUUID(), DEFAULT_USER_ID, DEFAULT_ORGANIZATION_ID, PermissionType.ORGANIZATION_ADMIN) .execute(); }
[*] target: assertNotNull(userRecord)
[-] pred: org. junit. Assert. assertNotNull ( userRecord )
************************************
************************************
[+] input: testExtractClaims_01() { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); Future<ExtractedClaims> future = validator.extractClaims(null); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.succeeded()); assertNull(res.result()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: Exception { buildFetcher(2);  MetadataResponse initialMetadataResponse = RequestTestUtils.metadataUpdateWithIds(1, singletonMap(topicName, 1), topicIds); client.updateMetadata(initialMetadataResponse); assignFromUser(Collections.singleton(tp0)); subscriptions.seek(tp0, 0L);  AtomicInteger fetchesRemaining = new AtomicInteger(1000); executorService = Executors.newSingleThreadExecutor(); Future<?> future = executorService.submit(() -> { long nextOffset = 0; long nextEpoch = 0; while (fetchesRemaining.get() > 0) { synchronized (consumerClient) { if (!client.requests().isEmpty()) { ClientRequest request = client.requests().peek(); FetchRequest fetchRequest = (FetchRequest) request.requestBuilder().build(); int epoch = fetchRequest.metadata().epoch(); assertTrue(epoch == 0 || epoch == nextEpoch, String.format("Unexpected epoch expected %d got %d", nextEpoch, epoch)); nextEpoch++; LinkedHashMap<TopicIdPartition, FetchResponseData.PartitionData> responseMap = new LinkedHashMap<>(); responseMap.put(tidp0, new FetchResponseData.PartitionData() .setPartitionIndex(tp0.partition()) .setHighWatermark(nextOffset + 2) .setLastStableOffset(nextOffset + 2) .setLogStartOffset(0) .setRecords(buildRecords(nextOffset, 2, nextOffset))); nextOffset += 2; client.respondToRequest(request, FetchResponse.of(Errors.NONE, 0, 123, responseMap)); consumerClient.poll(time.timer(0)); } } } return fetchesRemaining.get(); }); long nextFetchOffset = 0; while (fetchesRemaining.get() > 0 && !future.isDone()) { if (sendFetches() == 1) { synchronized (consumerClient) { consumerClient.poll(time.timer(0)); } } if (fetcher.hasCompletedFetches()) { Map<TopicPartition, List<ConsumerRecord<byte[], byte[]>>> fetchedRecords = fetchRecords(); if (!fetchedRecords.isEmpty()) { fetchesRemaining.decrementAndGet(); List<ConsumerRecord<byte[], byte[]>> records = fetchedRecords.get(tp0); "<AssertPlaceHolder>"; assertEquals(nextFetchOffset, records.get(0).offset()); assertEquals(nextFetchOffset + 1, records.get(1).offset()); nextFetchOffset += 2; } assertTrue(fetchRecords().isEmpty()); } } assertEquals(0, future.get()); }
sendFetches() { final Map<Node, FetchSessionHandler.FetchRequestData> fetchRequests = prepareFetchRequests(); sendFetchesInternal( fetchRequests, (fetchTarget, data, clientResponse) -> { synchronized (Fetcher.this) { handleFetchSuccess(fetchTarget, data, clientResponse); } }, (fetchTarget, data, error) -> { synchronized (Fetcher.this) { handleFetchFailure(fetchTarget, data, error); } }); return fetchRequests.size(); }
[*] target: assertEquals(2, records.size())
[-] pred: org. junit. Assert. assertEquals ( 2, records. size ( ) )
************************************
************************************
[+] input: testCountCloses() { AtomicInteger onCloseCounter = new AtomicInteger(); IdempotentCloser ic = new IdempotentCloser();  // Verify initial invariants. assertFalse(ic.isClosed()); assertEquals(0, onCloseCounter.get());  // Close with our onClose callback to increment our counter. ic.close(onCloseCounter::getAndIncrement); assertTrue(ic.isClosed()); assertEquals(1, onCloseCounter.get());  // Close with our onClose callback again, but verify it wasn't invoked as it was previously closed. ic.close(onCloseCounter::getAndIncrement); "<AssertPlaceHolder>"; assertEquals(1, onCloseCounter.get()); }
isClosed() { return isClosed.get(); }
[*] target: assertTrue(ic.isClosed())
[-] pred: org. junit. Assert. assertTrue ( ic. isClosed() )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/requestTestNotificationResponse.json", request -> { Assertions.assertEquals("POST", request.method()); Assertions.assertEquals("/inApps/v1/notifications/test", request.url().encodedPath()); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertNull(body.contentType()); try { Assertions.assertEquals(0, body.contentLength()); } catch (IOException e) { throw new RuntimeException(e); } });  SendTestNotificationResponse sendTestNotificationResponse = client.requestTestNotification();  Assertions.assertNotNull(sendTestNotificationResponse); Assertions.assertEquals("ce3af791-365e-4c60-841b-1674b43c1609", sendTestNotificationResponse.getTestNotificationToken()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred: org. junit. Assert. assertNotNull ( body )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/transactionInfoResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v1/transactions/1234", request.url().encodedPath()); Assertions."<AssertPlaceHolder>"; });  TransactionInfoResponse transactionInfoResponse = client.getTransactionInfo("1234");  Assertions.assertNotNull(transactionInfoResponse); Assertions.assertEquals("signed_transaction_info_value", transactionInfoResponse.getSignedTransactionInfo()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred: org. junit. Assert. assertNull ( request. body() )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getAppStoreServerAPIClient("", request -> { Assertions.assertEquals("PUT", request.method()); Assertions.assertEquals("/inApps/v1/transactions/consumption/49571273", request.url().encodedPath()); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(expectedMediaType, body.contentType()); Buffer buffer = new Buffer(); try { body.writeTo(buffer); } catch (IOException e) { throw new RuntimeException(e); } Map<String, Object> root; try { root = new ObjectMapper().readValue(buffer.readUtf8(), Map.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } Assertions.assertTrue((Boolean) root.get("customerConsented")); Assertions.assertEquals(1, ((Number) root.get("consumptionStatus")).intValue()); Assertions.assertEquals(2, ((Number) root.get("platform")).intValue()); Assertions.assertFalse((Boolean) root.get("sampleContentProvided")); Assertions.assertEquals(3, ((Number) root.get("deliveryStatus")).intValue()); Assertions.assertEquals("7389a31a-fb6d-4569-a2a6-db7d85d84813", root.get("appAccountToken")); Assertions.assertEquals(4, ((Number) root.get("accountTenure")).intValue()); Assertions.assertEquals(5, ((Number) root.get("playTime")).intValue()); Assertions.assertEquals(6, ((Number) root.get("lifetimeDollarsRefunded")).intValue()); Assertions.assertEquals(7, ((Number) root.get("lifetimeDollarsPurchased")).intValue()); Assertions.assertEquals(4, ((Number) root.get("userStatus")).intValue()); Assertions.assertEquals(3, ((Number) root.get("refundPreference")).intValue()); });  ConsumptionRequest consumptionRequest = new ConsumptionRequest() .customerConsented(true) .consumptionStatus(ConsumptionStatus.NOT_CONSUMED) .platform(Platform.NON_APPLE) .sampleContentProvided(false) .deliveryStatus(DeliveryStatus.DID_NOT_DELIVER_DUE_TO_SERVER_OUTAGE) .appAccountToken(UUID.fromString("7389a31a-fb6d-4569-a2a6-db7d85d84813")) .accountTenure(AccountTenure.THIRTY_DAYS_TO_NINETY_DAYS) .playTime(PlayTime.ONE_DAY_TO_FOUR_DAYS) .lifetimeDollarsRefunded(LifetimeDollarsRefunded.ONE_THOUSAND_DOLLARS_TO_ONE_THOUSAND_NINE_HUNDRED_NINETY_NINE_DOLLARS_AND_NINETY_NINE_CENTS) .lifetimeDollarsPurchased(LifetimeDollarsPurchased.TWO_THOUSAND_DOLLARS_OR_GREATER) .userStatus(UserStatus.LIMITED_ACCESS) .refundPreference(RefundPreference.NO_PREFERENCE);  client.sendConsumptionData("49571273", consumptionRequest); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred: org. junit. Assert. assertNotNull ( body )
************************************
************************************
[+] input: sendMessage() { SystemProperties systemProperties = SystemProperties.newBuilder() .setMessageId("123") .setMessageType(MessageType.NORMAL) .build();  Message message = Message.newBuilder() .setTopic(Resource.newBuilder().setName("topic").build()) .setSystemProperties(systemProperties) .build();  SendMessageRequest request = SendMessageRequest.newBuilder() .addMessages(message) .build();  CompletableFuture<SendMessageResponse> future = sendMessageActivity.sendMessage(ProxyContextExt.create(), request); "<AssertPlaceHolder>"; assertTrue(future.isDone()); assertFalse(future.isCompletedExceptionally());  SendMessageResponse response = future.join(); assertEquals(Code.OK, response.getStatus().getCode()); assertEquals(1, response.getEntriesList().size());  SendResultEntry entry = response.getEntriesList().get(0); assertEquals("123", entry.getMessageId()); assertEquals(Code.OK, entry.getStatus().getCode()); }
sendMessage(ProxyContext ctx, SendMessageRequest request) { CompletableFuture<SendMessageResponse> future = new CompletableFuture<>();  ProxyContextExt contextExt = (ProxyContextExt) ctx; Tracer tracer = contextExt.tracer().get(); Span rootSpan = tracer.spanBuilder("SendMessage") .setNoParent() .setSpanKind(SpanKind.SERVER) .setAttribute(ContextVariable.PROTOCOL_TYPE, ctx.getProtocolType()) .setAttribute(ContextVariable.ACTION, ctx.getAction()) .setAttribute(ContextVariable.CLIENT_ID, ctx.getClientID()) .startSpan(); contextExt.attachSpan(rootSpan);  try { if (request.getMessagesCount() <= 0) { throw new GrpcProxyException(Code.MESSAGE_CORRUPTED, "no message to send"); }  List<Message> messageList = request.getMessagesList(); apache.rocketmq.v2.Message message = messageList.get(0); Resource topic = message.getTopic(); validateTopic(topic);  future = this.messagingProcessor.sendMessage( ctx, new SendMessageQueueSelector(request), GrpcConverter.getInstance().wrapResourceWithNamespace(topic), buildSysFlag(message), buildMessage(ctx, request.getMessagesList(), topic) ).thenApply(result -> convertToSendMessageResponse(ctx, request, result)) .whenComplete((response, throwable) -> { if (response != null) { rootSpan.setAttribute("code", response.getStatus().getCode().name().toLowerCase()); } TraceHelper.endSpan(contextExt, rootSpan, throwable); }); } catch (Throwable t) { TraceHelper.endSpan(contextExt, rootSpan, t); future.completeExceptionally(t); } return future; }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: buildMobEntityType() { EntityType<Mob> type = FabricEntityType.Builder.createMob((t, w) -> null, MobCategory.MISC, mob -> mob .spawnRestriction(SpawnPlacementTypes.ON_GROUND, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, Pig::checkMobSpawnRules) .defaultAttributes(FabricEntityTypeTest::createAttributes) ).build();  "<AssertPlaceHolder>"; assertEquals(SpawnPlacementTypes.ON_GROUND, SpawnPlacements.getPlacementType(type)); assertNotNull(DefaultAttributes.getSupplier(type)); }
build() { throw new AssertionError("Implemented in Mixin"); }
[*] target: assertNotNull(type)
[-] pred: org. junit. Assert. assertNotNull ( type )
************************************
************************************
[+] input: testEquals() { Version version1 = new Version("1.0", "0.1"); Version version2 = new Version("1.0", "0.1"); assertEquals(version1, version2); assertEquals(version1.hashCode(), version2.hashCode()); assertEquals(version1.toString(), version2.toString()); assertNotEquals(version1, null); assertNotEquals(version1, ""); assertNotEquals(version1, "1.0"); assertNotEquals(version1, 1.0); assertNotEquals(version1, new Object()); assertNotEquals(version1, new Version("1.1", "0.1")); version1 = new Version("", ""); assertTrue(version1.isEmpty()); version1 = new Version(null, null); assertTrue(version1.isEmpty()); version1 = new Version(null, ""); assertTrue(version1.isEmpty()); version1 = new Version("", null); "<AssertPlaceHolder>"; }
isEmpty() { return min == null || max == null || min.isEmpty() || max.isEmpty(); }
[*] target: assertTrue(version1.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( version1. isEmpty() )
************************************
************************************
[+] input: testGenerateTokenPair() { // Given String userId = "sampleUserId";  // When TokenPair tokenPair = jwtTokenGenerator.generateTokenPair(userId);  // Then "<AssertPlaceHolder>"; assertNotNull(tokenPair.accessToken()); assertNotNull(tokenPair.refreshToken()); }
generateTokenPair(String userId) { String accessToken = generateAccessToken(userId); String refreshToken = generateRefreshToken(userId); return new TokenPair(accessToken, refreshToken); }
[*] target: assertNotNull(tokenPair)
[-] pred: org. junit. Assert. assertNotNull ( tokenPair )
************************************
************************************
[+] input: testShouldEmitMetricSelectorAll() { ClientTelemetryEmitter emitter = new ClientTelemetryEmitter(ClientTelemetryUtils.SELECTOR_ALL_METRICS, true);  assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric1"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric.producer.bytes"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("org.io.test.metric"))); "<AssertPlaceHolder>"; }
shouldEmitDeltaMetrics() { return deltaMetrics; }
[*] target: assertTrue(emitter.shouldEmitDeltaMetrics())
[-] pred: org. junit. Assert. assertTrue ( emitter. shouldEmitDeltaMetrics() )
************************************
************************************
[+] input: Exception { doInitTransactions();  transactionManager.beginTransaction(); transactionManager.maybeAddPartition(tp0);  Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);  prepareAddPartitionsToTxn(tp0, Errors.NONE); runUntil(() -> !client.hasPendingResponses()); assertTrue(accumulator.hasUndrained());  // committing the transaction should cause the unsent batch to be flushed transactionManager.beginCommit(); runUntil(() -> !accumulator.hasUndrained()); assertTrue(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest()); assertFalse(responseFuture.isDone());  // until the produce future returns, we will not send EndTxn AtomicInteger numRuns = new AtomicInteger(0); runUntil(() -> numRuns.incrementAndGet() >= 4); assertFalse(accumulator.hasUndrained()); assertTrue(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest()); assertFalse(responseFuture.isDone());  // now the produce response returns sendProduceResponse(Errors.NONE, producerId, epoch); runUntil(responseFuture::isDone); assertFalse(accumulator.hasUndrained()); assertFalse(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest());  // now we send EndTxn runUntil(transactionManager::hasInFlightRequest); sendEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, producerId, epoch);  runUntil(transactionManager::isReady); "<AssertPlaceHolder>"; }
hasInFlightRequest() { return inFlightRequestCorrelationId != NO_INFLIGHT_REQUEST_CORRELATION_ID; }
[*] target: assertFalse(transactionManager.hasInFlightRequest())
[-] pred: org. junit. Assert. assertFalse ( transactionManager. hasInFlightRequest ( ) )
************************************
************************************
[+] input: testCreatingADslContext() { final DataSource dataSource = DataSourceFactory.create(container.getUsername(), container.getPassword(), container.getDriverClassName(), container.getJdbcUrl()); final SQLDialect dialect = SQLDialect.POSTGRES; final DSLContext dslContext = DSLContextFactory.create(dataSource, dialect); "<AssertPlaceHolder>"; assertEquals(dialect, dslContext.configuration().dialect()); }
create(final DataSource dataSource, final SQLDialect dialect) { return DSL.using(dataSource, dialect); }
[*] target: assertNotNull(dslContext)
[-] pred: org. junit. Assert. assertNotNull ( dslContext )
************************************
************************************
[+] input: testGetCompileTransitiveDependenciesJetty() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14))); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(6, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14 org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.eclipse.jetty:jetty-http:11.0.14 org.eclipse.jetty:jetty-io:11.0.14 org.slf4j:slf4j-api:2.0.5 org.eclipse.jetty:jetty-util:11.0.14""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: UnknownHostException { clientMetricsManager.updateSubscription("sub-1", ClientMetricsTestUtils.defaultProperties()); Properties properties = new Properties(); properties.put("metrics", ClientMetricsConfigs.ALL_SUBSCRIBED_METRICS_CONFIG); clientMetricsManager.updateSubscription("sub-2", properties);  assertEquals(2, clientMetricsManager.subscriptions().size());  GetTelemetrySubscriptionsRequest request = new GetTelemetrySubscriptionsRequest.Builder( new GetTelemetrySubscriptionsRequestData(), true).build();  GetTelemetrySubscriptionsResponse response = clientMetricsManager.processGetTelemetrySubscriptionRequest( request, ClientMetricsTestUtils.requestContext());  assertNotNull(response.data().clientInstanceId()); assertTrue(response.data().subscriptionId() != 0);  assertEquals(1, response.data().requestedMetrics().size()); assertTrue(response.data().requestedMetrics().contains(ClientMetricsConfigs.ALL_SUBSCRIBED_METRICS_CONFIG));  assertEquals(4, response.data().acceptedCompressionTypes().size()); assertEquals(ClientMetricsTestUtils.DEFAULT_PUSH_INTERVAL_MS, response.data().pushIntervalMs()); assertTrue(response.data().deltaTemporality()); assertEquals(100, response.data().telemetryMaxBytes()); assertEquals(Errors.NONE, response.error());  ClientMetricsInstance instance = clientMetricsManager.clientInstance(response.data().clientInstanceId()); "<AssertPlaceHolder>"; assertEquals(Errors.NONE, instance.lastKnownError()); }
clientInstance(Uuid clientInstanceId) { return clientInstanceCache.get(clientInstanceId); }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
************************************
[+] input: getAllCatalogs() { Iterable<CatalogEntity> catalogEntities = catalogService.getAllCatalogs();  "<AssertPlaceHolder>";  catalogEntities.forEach(v -> { assertTrue(v.getProductId().startsWith("CATALOG-")); }); }
getAllCatalogs() { return catalogRepository.findAll(); }
[*] target: assertNotNull(catalogEntities)
[-] pred: org. junit. Assert. assertNotNull ( catalogEntities )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getAppStoreServerAPIClient("", request -> { Assertions.assertEquals("PUT", request.method()); Assertions.assertEquals("/inApps/v1/transactions/consumption/49571273", request.url().encodedPath()); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(expectedMediaType, body.contentType()); Buffer buffer = new Buffer(); try { body.writeTo(buffer); } catch (IOException e) { throw new RuntimeException(e); } Map<String, Object> root; try { root = new ObjectMapper().readValue(buffer.readUtf8(), Map.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } Assertions.assertTrue((Boolean) root.get("customerConsented")); Assertions.assertEquals(1, ((Number) root.get("consumptionStatus")).intValue()); Assertions.assertEquals(2, ((Number) root.get("platform")).intValue()); Assertions.assertFalse((Boolean) root.get("sampleContentProvided")); Assertions.assertEquals(3, ((Number) root.get("deliveryStatus")).intValue()); Assertions.assertEquals("", root.get("appAccountToken")); Assertions.assertEquals(4, ((Number) root.get("accountTenure")).intValue()); Assertions.assertEquals(5, ((Number) root.get("playTime")).intValue()); Assertions.assertEquals(6, ((Number) root.get("lifetimeDollarsRefunded")).intValue()); Assertions.assertEquals(7, ((Number) root.get("lifetimeDollarsPurchased")).intValue()); Assertions.assertEquals(4, ((Number) root.get("userStatus")).intValue()); Assertions.assertEquals(3, ((Number) root.get("refundPreference")).intValue()); });  ConsumptionRequest consumptionRequest = new ConsumptionRequest() .customerConsented(true) .consumptionStatus(ConsumptionStatus.NOT_CONSUMED) .platform(Platform.NON_APPLE) .sampleContentProvided(false) .deliveryStatus(DeliveryStatus.DID_NOT_DELIVER_DUE_TO_SERVER_OUTAGE) .accountTenure(AccountTenure.THIRTY_DAYS_TO_NINETY_DAYS) .playTime(PlayTime.ONE_DAY_TO_FOUR_DAYS) .lifetimeDollarsRefunded(LifetimeDollarsRefunded.ONE_THOUSAND_DOLLARS_TO_ONE_THOUSAND_NINE_HUNDRED_NINETY_NINE_DOLLARS_AND_NINETY_NINE_CENTS) .lifetimeDollarsPurchased(LifetimeDollarsPurchased.TWO_THOUSAND_DOLLARS_OR_GREATER) .userStatus(UserStatus.LIMITED_ACCESS) .refundPreference(RefundPreference.NO_PREFERENCE);  client.sendConsumptionData("49571273", consumptionRequest); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred: org. junit. Assert. assertNotNull ( body )
************************************
************************************
[+] input: makeOneSignCycle() { StartSignatureRequest request = new StartSignatureRequest(CLIENT_IP, new Base64String(this.visibleData)); StartTransactionResponse response = this.rpApi.startSignature(request);  Assertions.assertNotNull(response); Assertions.assertNotNull(response.getOrderRef()); Assertions.assertNotNull(response.getAutoStartToken()); Assertions.assertNotNull(response.getQrStartToken()); Assertions.assertNotNull(response.getQrStartSecret());  // Collect CollectResponse collectResponse = this.rpApi.collect(response.getOrderRef()); Assertions.assertNotNull(collectResponse);  Assertions.assertNotNull(collectResponse.getOrderRef()); Assertions.assertEquals(response.getOrderRef(), collectResponse.getOrderRef());  Assertions.assertNotNull(collectResponse.getStatus()); Assertions.assertEquals("pending", collectResponse.getStatus()); Assertions.assertNotNull(collectResponse.getHintCode()); Assertions.assertEquals("outstandingTransaction", collectResponse.getHintCode());  // Cancel boolean cancelResponse = this.rpApi.cancel(response.getOrderRef()); Assertions."<AssertPlaceHolder>"; }
cancel(String orderRef) { try { CancelRequest request = new CancelRequest(orderRef); ObjectMapper mapper = new ObjectMapper(); String jsonRequest = mapper.writeValueAsString(request);  long startTime = System.currentTimeMillis(); String result = this.post("cancel", jsonRequest); long elapsedTime = System.currentTimeMillis() - startTime; if (result == null) { this.logger.warn("Query to cancel transaction " + "failed after {} ms.", elapsedTime); return false; }  this.logger.info("Received json string from BankID RP after {} ms.", elapsedTime); return result.trim().equals("{}"); } catch (Exception e) { this.logger.warn("IOException while starting authentication: {}", e.getMessage()); return false; } }
[*] target: assertTrue(cancelResponse)
[-] pred: org. junit. Assert. assertTrue ( cancelResponse )
************************************
************************************
[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); "<AssertPlaceHolder>"; assertNoTracking(); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(config, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( config, actualConfig )
************************************
************************************
[+] input: givenValidUserClaimsAndRefreshToken_whenAccessTokenGenerated_thenReturnAysToken() { // Given AysUser mockUser = new AysUserBuilder() .withValidValues() .build(); Claims mockUserClaims = mockUser.getClaims();  // When Mockito.when(tokenConfiguration.getIssuer()).thenReturn(MOCK_ISSUER); Mockito.when(tokenConfiguration.getAccessTokenExpireMinute()).thenReturn(MOCK_ACCESS_TOKEN_EXPIRE_MINUTE); Mockito.when(tokenConfiguration.getRefreshTokenExpireDay()).thenReturn(MOCK_REFRESH_TOKEN_EXPIRE_DAY); Mockito.when(tokenConfiguration.getPrivateKey()).thenReturn(MOCK_PRIVATE_KEY);  // Then AysToken aysToken = tokenService.generate(mockUserClaims, mockUserToken.getRefreshToken());  Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(aysToken.getAccessToken()); Assertions.assertNotNull(aysToken.getAccessTokenExpiresAt()); Assertions.assertNotNull(aysToken.getRefreshToken());  // Verify Mockito.verify(tokenConfiguration, Mockito.times(1)).getIssuer(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getAccessTokenExpireMinute(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getRefreshTokenExpireDay(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getPrivateKey(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getPublicKey(); Mockito.verifyNoMoreInteractions(tokenConfiguration); }
generate(final Claims claims, final String refreshToken) {  final long currentTimeMillis = System.currentTimeMillis();  final Date accessTokenExpiresAt = DateUtils.addMinutes( new Date(currentTimeMillis), tokenConfiguration.getAccessTokenExpireMinute() ); final String accessToken = this.initializeTokenBuilder(currentTimeMillis) .id(AysRandomUtil.generateUUID()) .expiration(accessTokenExpiresAt) .claims(claims) .compact();  return AysToken.builder() .accessToken(accessToken) .accessTokenExpiresAt(accessTokenExpiresAt.toInstant().getEpochSecond()) .refreshToken(refreshToken) .build(); }
[*] target: assertNotNull(aysToken)
[-] pred: org. junit. Assert. assertNotNull ( aysToken )
************************************
************************************
[+] input: testFindNearest_whenExistingPointIsProvided_returnsZeroDistance() { KDTreeNearestNeighbor<String, Object> nearestNeighbor = this.kdTree.findNearest( new Builder() .latitude(25.2012544) .longitude(55.2569389) .build(), 2);  Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(nearestNeighbor.getDistance()); Assertions.assertEquals(0.0, nearestNeighbor.getDistance()); Assertions.assertNotNull(nearestNeighbor.getKdTreeObject()); Assertions.assertEquals("7", nearestNeighbor.getKdTreeObject().getId()); }
findNearest(Point point, double distance) { // Initialize the object to store the nearest neighbor and its distance. KDTreeNearestNeighbor<T, O> nearestNeighbor = new KDTreeNearestNeighbor<>(); // Call the recursive helper method with the root node, point, distance, and closestPoints list findNearest(this.root, point, distance, 0, nearestNeighbor); // Return the list of the closest points return nearestNeighbor; }
[*] target: assertNotNull(nearestNeighbor)
[-] pred: org. junit. Assert. assertNotNull ( nearestNeighbor )
************************************
************************************
[+] input: testExecuteWithConnectorJobFailure() { final Supplier<ConnectorJobOutput> supplier = mock(Supplier.class); final FailureReason mockFailureReason = mock(FailureReason.class); final ConnectorJobOutput connectorJobOutput = new ConnectorJobOutput() .withFailureReason(mockFailureReason); when(supplier.get()).thenReturn(connectorJobOutput);  final TemporalResponse<ConnectorJobOutput> response = temporalClient.execute(JOB_RUN_CONFIG, supplier);  "<AssertPlaceHolder>"; assertTrue(response.getOutput().isPresent()); assertEquals(connectorJobOutput, response.getOutput().get()); assertFalse(response.getMetadata().isSucceeded()); assertEquals(logPath, response.getMetadata().getLogPath()); }
execute(final JobRunConfig jobRunConfig, final Supplier<T> executor) { final Path jobRoot = TemporalUtils.getJobRoot(workspaceRoot, jobRunConfig.getJobId(), jobRunConfig.getAttemptId()); final Path logPath = TemporalUtils.getLogPath(jobRoot);  T operationOutput = null; RuntimeException exception = null;  try { operationOutput = executor.get(); } catch (final RuntimeException e) { exception = e; }  boolean succeeded = exception == null; if (succeeded && operationOutput instanceof ConnectorJobOutput) { succeeded = getConnectorJobSucceeded((ConnectorJobOutput) operationOutput); }  final JobMetadata metadata = new JobMetadata(succeeded, logPath); return new TemporalResponse<>(operationOutput, metadata); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testSetLogAppendTimeV1() { MemoryRecords records = MemoryRecords.withRecords(RecordBatch.MAGIC_VALUE_V1, 0L, Compression.gzip().build(), TimestampType.CREATE_TIME, new SimpleRecord(1L, "a".getBytes(), "1".getBytes()), new SimpleRecord(2L, "b".getBytes(), "2".getBytes()), new SimpleRecord(3L, "c".getBytes(), "3".getBytes()));  long logAppendTime = 15L;  ByteBufferLegacyRecordBatch batch = new ByteBufferLegacyRecordBatch(records.buffer()); batch.setMaxTimestamp(TimestampType.LOG_APPEND_TIME, logAppendTime); assertEquals(TimestampType.LOG_APPEND_TIME, batch.timestampType()); assertEquals(logAppendTime, batch.maxTimestamp()); assertTrue(batch.isValid());  List<MutableRecordBatch> recordBatches = Utils.toList(records.batches().iterator()); assertEquals(1, recordBatches.size()); assertEquals(TimestampType.LOG_APPEND_TIME, recordBatches.get(0).timestampType()); assertEquals(logAppendTime, recordBatches.get(0).maxTimestamp());  for (Record record : records.records()) "<AssertPlaceHolder>"; }
timestamp() { return outerRecord().timestamp(); }
[*] target: assertEquals(logAppendTime, record.timestamp())
[-] pred: org. junit. Assert. assertEquals ( logAppendTime, record. timestamp() )
************************************
************************************
[+] input: testConstructWithModel() { // 'given' setAnyProfileConfigurationTo(profile);  // 'when' String name = "copy"; Profile profile2 = Profile.createFromModel(name, profile);  // 'then' "<AssertPlaceHolder>"; assertProfileMatches(profile2); }
toString() { return name; }
[*] target: assertEquals(name, profile2.toString())
[-] pred: org. junit. Assert. assertEquals ( name, profile2. toString() )
************************************
************************************
[+] input: testShouldEmitMetric() { Predicate<? super MetricKeyable> selector = ClientTelemetryUtils.getSelectorFromRequestedMetrics( Collections.singletonList("io.test.metric")); ClientTelemetryEmitter emitter = new ClientTelemetryEmitter(selector, true);  assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric1"))); assertTrue(emitter.shouldEmitMetric(new MetricKey("io.test.metric.producer.bytes"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("io.test"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("org.io.test.metric"))); "<AssertPlaceHolder>"; }
shouldEmitDeltaMetrics() { return deltaMetrics; }
[*] target: assertTrue(emitter.shouldEmitDeltaMetrics())
[-] pred: org. junit. Assert. assertTrue ( emitter. shouldEmitDeltaMetrics() )
************************************
************************************
[+] input: IOException { var result = subject.load(audio, pathToAudioFile);  // Assert successful loading "<AssertPlaceHolder>"; assertEquals(audio.getId(), result.getId()); assertEquals(audio.getWaveformKey(), result.getWaveformKey()); assertEquals(pathToAudioFile, result.pathToAudioFile()); assertEquals(2, result.format().getChannels()); assertEquals(48000, result.format().getSampleRate()); assertEquals(32, result.format().getSampleSizeInBits()); assertEquals(8, result.format().getFrameSize()); assertEquals(48000, result.format().getFrameRate()); assertFalse(result.format().isBigEndian()); assertEquals(17364, result.data().length); assertEquals(2, result.data()[0].length); assertFalse(result.isDifferent(audio));  // Assert isDifferent() method when id and waveform key are changed var audio_differentIdAndWaveformKey = new InstrumentAudio(); audio_differentIdAndWaveformKey.setId(UUID.randomUUID()); audio_differentIdAndWaveformKey.setWaveformKey("test-audio2.wav"); assertTrue(result.isDifferent(audio_differentIdAndWaveformKey));  // Assert isDifferent() method when only waveform key is changed var audio_differentWaveformKey = new InstrumentAudio(); audio_differentWaveformKey.setId(audio.getId()); audio_differentWaveformKey.setWaveformKey("test-audio2.wav"); assertTrue(result.isDifferent(audio_differentWaveformKey)); }
load(InstrumentAudio audio, String path) throws IOException, UnsupportedAudioFileException { AudioFormat format = AudioSystem.getAudioFileFormat(new File(path)).getFormat(); return load(audio, path, format); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: buildUndoSQL() { OracleUndoDeleteExecutor executor = upperCase();  String sql = executor.buildUndoSQL(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("INSERT")); Assertions.assertTrue(sql.contains("ID")); Assertions.assertTrue(sql.contains("TABLE_NAME")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } Row row = beforeImageRows.get(0); List<Field> fields = new ArrayList<>(row.nonPrimaryKeys()); fields.addAll(getOrderedPkList(beforeImage,row,JdbcConstants.ORACLE));  // delete sql undo log before image all field come from table meta, need add escape. // see BaseTransactionalExecutor#buildTableRecords String insertColumns = fields.stream() .map(field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.ORACLE)) .collect(Collectors.joining(", ")); String insertValues = fields.stream().map(field -> "?") .collect(Collectors.joining(", "));  return String.format(INSERT_SQL_TEMPLATE, sqlUndoLog.getTableName(), insertColumns, insertValues); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: testTwoNodeQuorumVoteGranted() { int otherNodeId = 1; CandidateState state = newCandidateState( voterSetWithLocal(Collections.singletonList(otherNodeId)) ); assertFalse(state.isVoteGranted()); assertFalse(state.isVoteRejected()); assertEquals(Collections.singleton(otherNodeId), state.unrecordedVoters()); assertTrue(state.recordGrantedVote(otherNodeId)); assertEquals(Collections.emptySet(), state.unrecordedVoters()); assertFalse(state.isVoteRejected()); "<AssertPlaceHolder>"; }
isVoteGranted() { return numGranted() >= majoritySize(); }
[*] target: assertTrue(state.isVoteGranted())
[-] pred: org. junit. Assert. assertTrue ( state. isVoteGranted() )
************************************
************************************
[+] input: Exception { // Given String postUrl = String.format("https://api.fga.example/stores/%s/check", DEFAULT_STORE_ID); String expectedBody = String.format( "{"tuple_key":{"user":"%s","relation":"%s","object":"%s"},"contextual_tuples":null,"authorization_model_id":"%s","trace":null,"context":null}", DEFAULT_USER, "owner", DEFAULT_OBJECT, DEFAULT_AUTH_MODEL_ID); mockHttpClient .onPost(postUrl) .withBody(is(expectedBody)) .withHeader(CLIENT_METHOD_HEADER, "BatchCheck") .withHeader(CLIENT_BULK_REQUEST_ID_HEADER, anyValidUUID()) .doReturn(200, "{"allowed":false}"); ClientListRelationsRequest request = new ClientListRelationsRequest() .relations(List.of("owner")) ._object(DEFAULT_OBJECT) .user(DEFAULT_USER); ClientListRelationsOptions options = new ClientListRelationsOptions().authorizationModelId(DEFAULT_AUTH_MODEL_ID);  // When ClientListRelationsResponse response = fga.listRelations(request, options).get();  // Then mockHttpClient .verify() .post(postUrl) .withBody(is(expectedBody)) .withHeader(CLIENT_METHOD_HEADER, "BatchCheck") .withHeader(CLIENT_BULK_REQUEST_ID_HEADER, anyValidUUID()) .called(1); "<AssertPlaceHolder>"; assertNotNull(response.getRelations()); assertTrue(response.getRelations().isEmpty()); }
listRelations( ClientListRelationsRequest request, ClientListRelationsOptions listRelationsOptions) throws FgaInvalidParameterException { if (request.getRelations() == null || request.getRelations().isEmpty()) { throw new FgaInvalidParameterException( "At least 1 relation to check has to be provided when calling ListRelations"); }  var options = listRelationsOptions != null ? listRelationsOptions : new ClientListRelationsOptions().maxParallelRequests(DEFAULT_MAX_METHOD_PARALLEL_REQS); if (options.getAdditionalHeaders() == null) { options.additionalHeaders(new HashMap<>()); } options.getAdditionalHeaders().putIfAbsent(CLIENT_METHOD_HEADER, "ListRelations"); options.getAdditionalHeaders() .putIfAbsent(CLIENT_BULK_REQUEST_ID_HEADER, randomUUID().toString());  var batchCheckRequests = request.getRelations().stream() .map(relation -> new ClientCheckRequest() .user(request.getUser()) .relation(relation) ._object(request.getObject()) .contextualTuples(request.getContextualTupleKeys()) .context(request.getContext())) .collect(Collectors.toList());  return this.batchCheck(batchCheckRequests, options.asClientBatchCheckOptions()) .thenCompose(responses -> call(() -> ClientListRelationsResponse.fromBatchCheckResponses(responses))); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: shouldCreateRemoveTaskAction() { final TaskId taskId = new TaskId(0, 0); final CompletableFuture<StateUpdater.RemovedTaskResult> future = new CompletableFuture<>();  final TaskAndAction removeTask = createRemoveTask(taskId, future);  assertEquals(REMOVE, removeTask.action()); assertEquals(taskId, removeTask.taskId()); "<AssertPlaceHolder>"; final Exception exceptionForTask = assertThrows(IllegalStateException.class, removeTask::task); assertEquals("Action type REMOVE cannot have a task!", exceptionForTask.getMessage()); }
futureForRemove() { if (action != Action.REMOVE) { throw new IllegalStateException("Action type " + action + " cannot have a future with a single result!"); } return futureForRemove; }
[*] target: assertEquals(future, removeTask.futureForRemove())
[-] pred: org. junit. Assert. assertEquals ( future, removeTask. futureForRemove() )
************************************
************************************
[+] input: testMultiPartFileToWebResponse() { try { byte[] fileContent = "Sample file content".getBytes(); MockMultipartFile file = new MockMultipartFile("file", "sample.txt", "text/plain", fileContent);  ResponseEntity<byte[]> responseEntity = WebResponseUtils.multiPartFileToWebResponse(file);  "<AssertPlaceHolder>"; assertEquals(HttpStatus.OK, responseEntity.getStatusCode()); assertNotNull(responseEntity.getBody());  HttpHeaders headers = responseEntity.getHeaders(); assertNotNull(headers); assertEquals(MediaType.TEXT_PLAIN, headers.getContentType()); assertNotNull(headers.getContentDisposition());  } catch (IOException e) { fail("Exception thrown: " + e.getMessage()); } }
multiPartFileToWebResponse(MultipartFile file) throws IOException { String fileName = Filenames.toSimpleFileName(file.getOriginalFilename()); MediaType mediaType = MediaType.parseMediaType(file.getContentType());  byte[] bytes = file.getBytes();  return bytesToWebResponse(bytes, fileName, mediaType); }
[*] target: assertNotNull(responseEntity)
[-] pred: org. junit. Assert. assertNotNull ( responseEntity )
************************************
************************************
[+] input: 공부미션을_생성한다() { // given MissionCreateRequest missionCreateRequest = new MissionCreateRequest( "testMissionName", "testMissionContent", MissionCategory.STUDY, MissionVisibility.ALL, MissionPeriod.TWO_WEEKS, LocalTime.of(21, 0));  // when MissionCreateResponse mission = missionService.createMission(missionCreateRequest);  // then "<AssertPlaceHolder>"; assertEquals("testMissionName", mission.name()); assertEquals("testMissionContent", mission.content()); assertEquals(MissionCategory.STUDY, mission.category()); assertEquals(MissionVisibility.ALL, mission.visibility()); }
createMission(MissionCreateRequest missionCreateRequest) { Mission mission = createMissionEntity(missionCreateRequest); Mission saveMission = missionRepository.save(mission); return MissionCreateResponse.from(saveMission); }
[*] target: assertNotNull(mission)
[-] pred: org. junit. Assert. assertNotNull ( mission )
************************************
************************************
[+] input: should_create() { String id = "Test" + newSnowflakeId();  TestAggregate aggregate = new TestAggregate(id); assertEquals(id, aggregate.getId()); assertEquals(TEST_USER.getTenantId(), aggregate.getTenantId());  assertEquals(TEST_USER.getMemberId(), aggregate.getCreatedBy()); assertNotNull(aggregate.getCreatedAt());  assertNull(aggregate.getEvents()); assertNull(aggregate.getOpsLogs());  "<AssertPlaceHolder>"; }
getIdentifier() { return id; }
[*] target: assertEquals(id, aggregate.getIdentifier())
[-] pred: org. junit. Assert. assertEquals ( id, aggregate. getIdentifier() )
************************************
************************************
[+] input: Exception { File payloadFile = createTempFile("Hello\nKafka"); String payloadFilePath = payloadFile.getAbsolutePath(); String payloadDelimiter = "\n";  List<byte[]> payloadByteList = ProducerPerformance.readPayloadFile(payloadFilePath, payloadDelimiter);  "<AssertPlaceHolder>"; assertEquals("Hello", new String(payloadByteList.get(0))); assertEquals("Kafka", new String(payloadByteList.get(1))); }
readPayloadFile(String payloadFilePath, String payloadDelimiter) throws IOException { List<byte[]> payloadByteList = new ArrayList<>(); if (payloadFilePath != null) { Path path = Paths.get(payloadFilePath); System.out.println("Reading payloads from: " + path.toAbsolutePath()); if (Files.notExists(path) || Files.size(path) == 0)  { throw new IllegalArgumentException("File does not exist or empty file provided."); }  String[] payloadList = new String(Files.readAllBytes(path), StandardCharsets.UTF_8).split(payloadDelimiter);  System.out.println("Number of messages read: " + payloadList.length);  for (String payload : payloadList) { payloadByteList.add(payload.getBytes(StandardCharsets.UTF_8)); } } return payloadByteList; }
[*] target: assertEquals(2, payloadByteList.size())
[-] pred: org. junit. Assert. assertEquals ( 2, payloadByteList. size ( ) )
************************************
************************************
[+] input: testTemporalSdkTimeoutsStringValues() { final Duration rpcTimeout = Duration.ofSeconds(25); final Duration rpcLongPollTimeout = Duration.ofSeconds(35); final Duration rpcQueryTimeout = Duration.ofSeconds(45); final Map<String, Object> timeouts = Map.of( "temporal.sdk.timeouts.rpc-timeout", "25s", "temporal.sdk.timeouts.rpc-long-poll-timeout", "35s", "temporal.sdk.timeouts.rpc-query-timeout", "45s");  final ApplicationContext ctx = ApplicationContext.run(timeouts); final TemporalSdkTimeouts temporalSdkTimeouts = ctx.getBean(TemporalSdkTimeouts.class);  assertEquals(rpcTimeout, temporalSdkTimeouts.getRpcTimeout()); assertEquals(rpcLongPollTimeout, temporalSdkTimeouts.getRpcLongPollTimeout()); "<AssertPlaceHolder>"; }
getRpcQueryTimeout() { return rpcQueryTimeout; }
[*] target: assertEquals(rpcQueryTimeout, temporalSdkTimeouts.getRpcQueryTimeout())
[-] pred: org. junit. Assert. assertEquals ( rpcQueryTimeout, temporalSdkTimeouts. getRpcQueryTimeout ( ) )
************************************
************************************
[+] input: shouldRejectSpansByName() { // given SpanExporter underTest = SpanDataModifier.builder(delegate) .rejectSpansByName(spanName -> spanName.equals("span2")) .rejectSpansByName(spanName -> spanName.equals("span4")) .build();  SpanData span1 = TestSpanHelper.span("span1"); SpanData span2 = TestSpanHelper.span("span2"); SpanData span3 = TestSpanHelper.span("span3"); SpanData span4 = TestSpanHelper.span("span4");  CompletableResultCode expectedResult = new CompletableResultCode(); when(delegate.export(spansCaptor.capture())).thenReturn(expectedResult);  // when CompletableResultCode result = underTest.export(asList(span1, span2, span3, span4));  // then "<AssertPlaceHolder>";  assertThat(spansCaptor.getValue()) .satisfiesExactly( s -> assertThat(s).hasName(span1.getName()), s -> assertThat(s).hasName(span3.getName())); }
build() { SpanExporter modifier = delegate; if (!spanAttributeReplacements.isEmpty()) { modifier = new AttributeModifyingSpanExporter( delegate, new HashMap<>(spanAttributeReplacements)); } return FilteringSpanExporter.builder(modifier) .rejectSpansWithAttributesMatching(new HashMap<>(rejectSpanAttributesPredicates)) .rejectSpansNamed(rejectSpanNamesPredicate) .build(); }
[*] target: assertSame(expectedResult, result)
[-] pred: org. junit. Assert. assertSame ( expectedResult, result )
************************************
************************************
[+] input: Exception { destination.accept(STATE_MESSAGE2); destination.accept(STATE_MESSAGE1); destination.notifyEndOfInput();  assertFalse(destination.isFinished()); assertEquals(STATE_MESSAGE2, destination.attemptRead().get()); assertEquals(STATE_MESSAGE1, destination.attemptRead().get()); "<AssertPlaceHolder>"; }
isFinished() { return isFinished && messages.isEmpty(); }
[*] target: assertTrue(destination.isFinished())
[-] pred: org. junit. Assert. assertTrue ( destination. isFinished() )
************************************
************************************
[+] input: Exception { FileOutputStream fos = null; try { File propsFile = Files.createTempFile("tmp_test", ".properties").toFile(); fos = new FileOutputStream(propsFile); props.store(fos, "test");  ConfigEntry<String> stringConf = new ConfigBuilder("test").stringConf().createWithDefault("test-default"); ConfigEntry<Integer> intConf = new ConfigBuilder("gravitino.test.test-int").intConf(); ConfigEntry<Boolean> booleanConf = new ConfigBuilder("gravitino.test.test-boolean").booleanConf();  // Do not load default system properties, loading from file. DummyConfig config = new DummyConfig(false); config.loadFromProperties(config.loadPropertiesFromFile(propsFile));  // Config "stringConf" will not load into Config, so it will return the value from the file String value = config.get(stringConf); Assertions.assertEquals("test-default", value);  // Config "intConf" will load into Config, so it will return the value from the file Integer intValue = config.get(intConf); Assertions.assertEquals(1, intValue);  // Config "booleanConf" will load into Config, so it will return the value from the file Boolean booleanValue = config.get(booleanConf); Assertions."<AssertPlaceHolder>"; } finally { if (fos != null) { fos.close(); fos = null; } } }
get(ConfigEntry<T> entry) throws NoSuchElementException { return entry.readFrom(configMap); }
[*] target: assertEquals(true, booleanValue)
[-] pred: org. junit. Assert. assertEquals ( true, booleanValue )
************************************
************************************
[+] input: givenLoginRequest_WhenCustomerRole_ReturnSuccess() {  // given LoginRequest request = LoginRequest.builder() .email("customer@bookdelivery.com") .password("customer_password") .build();  User mockUser = User.builder() .email(request.getEmail()) .fullName("Test User") .username("testuser") .password("hashedPassword") .role(Role.ROLE_CUSTOMER) .build();  Authentication mockAuthentication = new UsernamePasswordAuthenticationToken( request.getEmail(), request.getPassword());  // when when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class))) .thenReturn(mockAuthentication); when(jwtUtils.generateJwtToken(mockAuthentication)).thenReturn("mockedToken"); when(userRepository.findByEmail(request.getEmail())).thenReturn(Optional.of(mockUser)); when(refreshTokenService.createRefreshToken(any(User.class))) .thenReturn("actualRefreshToken");  // then JWTResponse jwtResponse = authService.login(request);  "<AssertPlaceHolder>"; assertEquals(request.getEmail(), jwtResponse.getEmail()); assertEquals("mockedToken", jwtResponse.getToken()); assertEquals("actualRefreshToken", jwtResponse.getRefreshToken());  }
login(LoginRequest request) {  UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword());  Authentication auth = authenticationManager.authenticate(authToken); SecurityContextHolder.getContext().setAuthentication(auth); String jwtToken = jwtUtils.generateJwtToken(auth);  User user = userRepository.findByEmail(request.getEmail()).orElseThrow(UserNotFoundException::new);  return JWTResponse.builder() .email(request.getEmail()) .token(jwtToken) .refreshToken(refreshTokenService.createRefreshToken(user)) .build(); }
[*] target: assertNotNull(jwtResponse)
[-] pred: org. junit. Assert. assertNotNull ( jwtResponse )
************************************
************************************
[+] input: IOException { RecordHeaders headers = new RecordHeaders(); headers.add(new RecordHeader("key", "value".getBytes())); headers.add(new RecordHeader("key1", "key1value".getBytes())); headers.add(new RecordHeader("key", "value2".getBytes())); headers.add(new RecordHeader("key2", "key2value".getBytes()));   Iterator<Header> keyHeaders = headers.headers("key").iterator(); assertHeader("key", "value", keyHeaders.next()); assertHeader("key", "value2", keyHeaders.next()); assertFalse(keyHeaders.hasNext());  keyHeaders = headers.headers("key1").iterator(); assertHeader("key1", "key1value", keyHeaders.next()); assertFalse(keyHeaders.hasNext());  keyHeaders = headers.headers("key2").iterator(); assertHeader("key2", "key2value", keyHeaders.next()); "<AssertPlaceHolder>";  }
hasNext() { return original.hasNext(); }
[*] target: assertFalse(keyHeaders.hasNext())
[-] pred: org. junit. Assert. assertFalse ( keyHeaders. hasNext ( ) )
************************************
************************************
[+] input: testLimit_ApiKeySuccess_KeyExist() { Key key = new Key(); key.setRole("role"); key.setKey("key"); key.setProject("api-key"); Config config = new Config(); Role role = new Role(); Limit limit = new Limit(); limit.setDay(10000); limit.setMinute(100); role.setLimits(Map.of("model", limit)); config.setRoles(Map.of("role", role)); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); apiKeyData.setPerRequestKey("per-request-key"); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, null, "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  when(vertx.executeBlocking(any(Callable.class), eq(false))).thenAnswer(invocation -> { Callable<?> callable = invocation.getArgument(0); return Future.succeededFuture(callable.call()); });  TokenUsage tokenUsage = new TokenUsage(); tokenUsage.setTotalTokens(90); proxyContext.setTokenUsage(tokenUsage);  Future<Void> increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  Future<RateLimitResult> checkLimitFuture = rateLimiter.limit(proxyContext);  assertNotNull(checkLimitFuture); assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.OK, checkLimitFuture.result().status());  increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  checkLimitFuture = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.TOO_MANY_REQUESTS, checkLimitFuture.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(checkLimitFuture)
[-] pred: org. junit. Assert. assertNotNull ( checkLimitFuture )
************************************
************************************
[+] input: isRight() { Either<String, Integer> stringIntegerEither = Either.right(5); assertFalse(stringIntegerEither.isLeft()); "<AssertPlaceHolder>"; }
isRight() { return this.right != null; }
[*] target: assertTrue(stringIntegerEither.isRight())
[-] pred: org. junit. Assert. assertTrue ( stringIntegerEither. isRight() )
************************************
************************************
[+] input: getAll_shouldReturnAllCategories() { List<Category> categories = new ArrayList<>(List.of(new Category(), new Category()));  // Given when(categoryRepository.findAll()).thenReturn(categories);  // When List<Category> allCategories = serviceTest.getAll();  // Then "<AssertPlaceHolder>"; assertEquals(categories.size(), allCategories.size()); assertTrue(allCategories.containsAll(categories)); verify(categoryRepository, times(1)).findAll(); }
getAll() { return categoryRepository.findAll(); }
[*] target: assertNotNull(allCategories)
[-] pred: org. junit. Assert. assertNotNull ( allCategories )
************************************
************************************
[+] input: testBuildSentryExceptionsPythonNoValue() { final String stacktrace = """ Traceback (most recent call last): File "/airbyte/connector-errors/error.py", line 33, in incremental raise RuntimeError() RuntimeError """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.PYTHON, parsedException.platform()); Assertions.assertEquals(1, exceptionList.size());  assertExceptionContent(exceptionList.get(0), "RuntimeError", null, List.of( Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 33, FUNCTION, "incremental", CONTEXT_LINE, "raise RuntimeError()"))); }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred: org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )
************************************
************************************
[+] input: IOException { final DestinationRead expectedDestinationRead = new DestinationRead() .name(destinationConnection.getName()) .destinationDefinitionId(standardDestinationDefinition.getDestinationDefinitionId()) .workspaceId(destinationConnection.getWorkspaceId()) .destinationId(destinationConnection.getDestinationId()) .connectionConfiguration(destinationConnection.getConfiguration()) .destinationName(standardDestinationDefinition.getName()) .icon(ICON_URL) .isVersionOverrideApplied(IS_VERSION_OVERRIDE_APPLIED) .supportState(SUPPORT_STATE); final DestinationIdRequestBody destinationIdRequestBody = new DestinationIdRequestBody().destinationId(expectedDestinationRead.getDestinationId());  when(secretsProcessor.prepareSecretsForOutput(destinationConnection.getConfiguration(), destinationDefinitionSpecificationRead.getConnectionSpecification())) .thenReturn(destinationConnection.getConfiguration()); when(configRepository.getDestinationConnection(destinationConnection.getDestinationId())).thenReturn(destinationConnection); when(configRepository.getStandardDestinationDefinition(standardDestinationDefinition.getDestinationDefinitionId())) .thenReturn(standardDestinationDefinition); when(actorDefinitionVersionHelper.getDestinationVersion(standardDestinationDefinition, destinationConnection.getWorkspaceId(), destinationConnection.getDestinationId())) .thenReturn(destinationDefinitionVersion);  final DestinationRead actualDestinationRead = destinationHandler.getDestination(destinationIdRequestBody);  "<AssertPlaceHolder>";  // make sure the icon was loaded into actual svg content assertTrue(expectedDestinationRead.getIcon().startsWith("https://"));  verify(actorDefinitionVersionHelper).getDestinationVersion(standardDestinationDefinition, destinationConnection.getWorkspaceId(), destinationConnection.getDestinationId()); verify(secretsProcessor) .prepareSecretsForOutput(destinationConnection.getConfiguration(), destinationDefinitionSpecificationRead.getConnectionSpecification()); }
getDestination(final DestinationIdRequestBody destinationIdRequestBody) throws JsonValidationException, IOException, ConfigNotFoundException { return buildDestinationRead(destinationIdRequestBody.getDestinationId()); }
[*] target: assertEquals(expectedDestinationRead, actualDestinationRead)
[-] pred: org. junit. Assert. assertEquals ( expectedDestinationRead, actualDestinationRead )
************************************
************************************
[+] input: test_correct_relevant_memories_and_correct_amount_are_fetched2() { MemoryStream stream = new MemoryStream(); stream.add(new Observation("i love playing basketball")); stream.add(new Observation("on saturday i slept in")); stream.add(new Observation("i completed my homework")); stream.add(new Observation("finished my homework")); stream.add(new Observation("woke up and made breakfast")); stream.add(new Observation("played video games for an hour")); stream.add(new Observation("played soccer for an hour")); stream.add(new Observation("played Battlefield 1 for an hour")); stream.add(new Observation("likes to play video games")); stream.add(new Observation("saw a bird fly by")); stream.add(new Observation("memory")); stream.add(new Observation("memory two"));  List<Memory> memories = stream.getRelevantMemories("memory", 0);  "<AssertPlaceHolder>"; assertEquals("memory", memories.get(0).getDescription()); assertEquals("memory two", memories.get(1).getDescription()); }
getRelevantMemories(String query, int minImportance) { // score, memory index Map<Double, Integer> scores = new HashMap<Double, Integer>();  for (Memory memory : memories) { if (memory.getImportance() >= minImportance) { double score = memory.getScore(query); scores.put(score, memories.indexOf(memory)); } }  List<Double> keys = new ArrayList<Double>(scores.keySet()); Collections.sort(keys);  List<Integer> indices = scores.values().stream().collect(Collectors.toList());  if (scores.size() > 3) { double first = keys.get(keys.size() - 1); double second = keys.get(keys.size() - 2); double third = keys.get(keys.size() - 3);  indices = List.of(scores.get(first), scores.get(second), scores.get(third)); }  List<Memory> memCopies = new ArrayList<Memory>();  for (int index : indices) { memCopies.add(memories.get(index)); }  return memCopies; }
[*] target: assertEquals(3, memories.size())
[-] pred: org. junit. Assert. assertEquals ( 3, memories. size ( ) )
************************************
************************************
[+] input: parseJsonToChainSpec() { String pathToPolkadotTestJSON = "./src/test/resources/short_polkadot.json"; try { ChainSpec chainSpec = ChainSpec.newFromJSON(pathToPolkadotTestJSON); String actualName = chainSpec.getName(); String expectedName = "Polkadot"; "<AssertPlaceHolder>";  String actualId = chainSpec.getId(); String expectedId = "polkadot"; assertEquals(expectedId, actualId);  ChainType actualChainType = chainSpec.getChainType(); ChainType expectedChainType = ChainType.LIVE; assertEquals(expectedChainType, actualChainType);  String actualProtocolId = chainSpec.getProtocolId(); String expectedProtocolId = "dot"; assertEquals(expectedProtocolId, actualProtocolId);  String[] actualForkBlocks = chainSpec.getForkBlocks(); assertNull(actualForkBlocks);  String[] actualBadBlocks = chainSpec.getBadBlocks(); assertNull(actualBadBlocks);  String actualConsensusEngine = chainSpec.getConsensusEngine(); assertNull(actualConsensusEngine);  String[] actualBootNodes = chainSpec.getBootNodes(); String[] expectedBootNodes = new String[]{ "/dns/polkadot-connect-0.parity.io/tcp/443/wss/p2p/12D3KooWEPmjoRpDSUuiTjvyNDd8fejZ9eNWH5bE965nyBMDrB4o", "/dns/cc1-1.parity.tech/tcp/30333/p2p/12D3KooWFN2mhgpkJsDBuNuE5427AcDrsib8EoqGMZmkxWwx3Md4"}; assertArrayEquals(expectedBootNodes, actualBootNodes);  TelemetryEndpoint[] actualTelemetryEndpoints = chainSpec.getTelemetryEndpoints(); TelemetryEndpoint[] expectedTelemetryEndpoints = new TelemetryEndpoint[] { new TelemetryEndpoint("wss://telemetry.polkadot.io/submit/", 0) }; assertArrayEquals(expectedTelemetryEndpoints, actualTelemetryEndpoints);  Map<ByteString, ByteString> actualTopValue = chainSpec.getGenesis().getTop(); Map<String, String> expectedRawTopValue = new LinkedHashMap(); expectedRawTopValue.put("0x9c5d795d0297be56027a4b2464e3339763e6d3c1fb15805edfd024172ea4817d9e40ca7bd1fd588ca534ee6b96a65ca8a53ec232dda838cc3cd2bd1887904906", "0x11bc2c7ea454e083cea1186239abc83733200e78"); expectedRawTopValue.put("0x9c5d795d0297be56027a4b2464e333979c5d795d0297be56027a4b2464e33397eb0718ce75762eeba4570943d5b2de2afb9085b6", "0x000e760ff72301000000000000000000");  Function<String, ByteString> parser = hex -> ByteString.fromHex(StringUtils.remove0xPrefix(hex));  Map<ByteString, ByteString> expectedTopValue = expectedRawTopValue.entrySet().stream().collect(Collectors.toMap( e -> parser.apply(e.getKey()), e -> parser.apply(e.getValue()) ));  assertEquals(expectedTopValue, actualTopValue);  Map<String, PropertyValue> actualProperties = chainSpec.getProperties();  ObjectMapper mapper = new ObjectMapper(); Map<String, JsonNode> expectedProperties = new LinkedHashMap<>(); expectedProperties.put("ss58Format", mapper.valueToTree(0)); expectedProperties.put("tokenDecimals", mapper.valueToTree(10)); expectedProperties.put("tokenSymbol", mapper.valueToTree("DOT"));  assertEquals(expectedProperties, actualProperties); } catch (IOException e) { log.log(Level.SEVERE, "Error loading chain spec from json", e); fail(); } }
newFromJSON(String pathToChainSpecJSON) throws IOException { final boolean failOnUnknownProperties = false; ObjectMapper objectMapper = new ObjectMapper() .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, failOnUnknownProperties); var file = new File(pathToChainSpecJSON);  return objectMapper.readValue(file, ChainSpec.class); }
[*] target: assertEquals(expectedName, actualName)
[-] pred: org. junit. Assert. assertEquals ( expectedName, actualName )
************************************
************************************
[+] input: licenseSettersAndToStringTest() { License license = new License(); license.setType("Type2"); license.setVersion("Version2"); license.setUrl("https://url2.com");  assertEquals("Type2", license.getType()); assertEquals("Version2", license.getVersion()); assertEquals("https://url2.com", license.getUrl());  String expectedString = "Licence{name='Type2', version='Version2', url='https://url2.com'}"; "<AssertPlaceHolder>"; }
toString() { return "Licence{" + "name='" + type + ''' + ", version='" + version + ''' + ", url='" + url + ''' + '}'; }
[*] target: assertEquals(expectedString, license.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedString, license. toString ( ) )
************************************
************************************
[+] input: testCreateRuleDetailsError() { boolean exceptionThrown = false; try { ruleDocumentation.createRuleDetails(-1); } catch (IllegalArgumentException e) { exceptionThrown = true; } assertTrue(exceptionThrown);  exceptionThrown = false; try { ruleDocumentation.createRuleDetails(rules.length); } catch (IllegalArgumentException e) { exceptionThrown = true; } "<AssertPlaceHolder>"; }
createRuleDetails(int ruleIndex) { if (ruleIndex < 0 || ruleIndex >= rules.length) throw new IllegalArgumentException();  final String NAV_PREVIOUS_RULE = "<-- previous rule"; final String NAV_OVERVIEW = "overview"; final String NAV_NEXT_RULE = "next rule -->"; final String NAV_SEPARATOR = " | ";  MarkdownBuilder mb = MarkdownBuilder.create();  Rule rule = rules[ruleIndex];  // navigation to "<-- previous rule | overview | next rule -->" mb.startNewParagraph(); if (ruleIndex > 0) { mb.appendLink(NAV_PREVIOUS_RULE, getRuleDocumentationFileName(ruleIndex - 1)); } else { mb.appendText(NAV_PREVIOUS_RULE); } mb.appendText(NAV_SEPARATOR); mb.appendLink(NAV_OVERVIEW, "../" + RULES_FILE); mb.appendText(NAV_SEPARATOR); if (ruleIndex + 1 < rules.length) { mb.appendLink(NAV_NEXT_RULE, getRuleDocumentationFileName(ruleIndex + 1)); } else { mb.appendText(NAV_NEXT_RULE); }  // rule name, description, references, options, example code rule.toDocumentation(mb);  // links to Rule implementation and tests mb.startNewHeading("Related code", 2); mb.startNewBullet(1); mb.appendLink("Rule implementation", getRuleImplementationLink(rule)); mb.startNewBullet(1); mb.appendLink("Tests", getRuleTestClassLink(rule));  mb.finishBuild(); return mb.toString();  }
[*] target: assertTrue(exceptionThrown)
[-] pred: org. junit. Assert. assertTrue ( exceptionThrown )
************************************
************************************
[+] input: testWorkSpaceIDUsage() { AzureCliCredentialsProvider provider = getAzureCliCredentialsProvider(mockTokenSource()); DatabricksConfig config = new DatabricksConfig() .setHost(".azuredatabricks.net") .setCredentialsProvider(provider) .setAzureWorkspaceResourceId(WORKSPACE_RESOURCE_ID); ArgumentCaptor<List<String>> argument = ArgumentCaptor.forClass(List.class);  HeaderFactory header = provider.configure(config);  String token = header.headers().get("Authorization"); assertEquals(token, TOKEN_TYPE + " " + TOKEN); Mockito.verify(provider, times(2)).getToken(any(), argument.capture());  List<String> value = argument.getValue(); value = value.subList(value.size() - 2, value.size()); List<String> expected = Arrays.asList("--subscription", SUBSCRIPTION); "<AssertPlaceHolder>"; }
getToken(DatabricksConfig config, List<String> cmd) { CliTokenSource token = new CliTokenSource(cmd, "tokenType", "accessToken", "expiresOn", config.getEnv()); token.getToken(); // We need this to check if the CLI is installed and to validate the config. return token; }
[*] target: assertEquals(expected, value)
[-] pred: org. junit. Assert. assertEquals ( expected, value )
************************************
************************************
[+] input: testFindUserByEmail_ExistingUser() { // given String email = "test@example.com"; User user = new User(); user.setEmail(email); when(userRepository.findByEmail(email)).thenReturn(Optional.of(user));  // when User foundUser = underTestUserService.findUserByEmail(email);  // then "<AssertPlaceHolder>"; assertEquals(email, foundUser.getEmail()); verify(userRepository).findByEmail(email); }
findUserByEmail(String email) { return userRepository .findByEmail(email) .orElseThrow(() -> new UserNotFoundException("no user with email: " + email + " found")); }
[*] target: assertNotNull(foundUser)
[-] pred: org. junit. Assert. assertNotNull ( foundUser )
************************************
************************************
[+] input: ConfigNotFoundException { setupStandardDefinitionMock(createAdvancedAuth() .withPredicateKey(List.of("some_random_fields", AUTH_TYPE)) .withPredicateValue(OAUTH)); final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); setupOAuthParamMocks(generateOAuthParameters()); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); "<AssertPlaceHolder>"; assertNoTracking(); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(config, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( config, actualConfig )
************************************
************************************
[+] input: testShouldThrottle() { for (short version : ApiKeys.OFFSET_FETCH.allVersions()) { if (version < 8) { OffsetFetchResponse response = new OffsetFetchResponse(throttleTimeMs, Errors.NONE, partitionDataMap); if (version >= 4) { assertTrue(response.shouldClientThrottle(version)); } else { assertFalse(response.shouldClientThrottle(version)); } } else { OffsetFetchResponse response = new OffsetFetchResponse( throttleTimeMs, Collections.singletonMap(groupOne, Errors.NOT_COORDINATOR), Collections.singletonMap(groupOne, partitionDataMap)); "<AssertPlaceHolder>"; } } }
shouldClientThrottle(short version) { return version >= 4; }
[*] target: assertTrue(response.shouldClientThrottle(version))
[-] pred: org. junit. Assert. assertTrue ( response. shouldClientThrottle( version ) )
************************************
************************************
[+] input: testDoesCompleteReassignmentSomeNewReplicas() { PartitionReassignmentReplicas replicas = new PartitionReassignmentReplicas( partitionAssignment(Arrays.asList(0, 1, 2)), partitionAssignment(Arrays.asList(0, 1, 3))); "<AssertPlaceHolder>"; Optional<PartitionReassignmentReplicas.CompletedReassignment> reassignmentOptional = replicas.maybeCompleteReassignment(Arrays.asList(0, 1, 2, 3)); assertTrue(reassignmentOptional.isPresent()); PartitionReassignmentReplicas.CompletedReassignment completedReassignment = reassignmentOptional.get(); assertEquals(Arrays.asList(0, 1, 3), completedReassignment.isr); assertEquals(Arrays.asList(0, 1, 3), completedReassignment.replicas); }
isReassignmentInProgress() { return isReassignmentInProgress( removing, adding); }
[*] target: assertTrue(replicas.isReassignmentInProgress())
[-] pred: org. junit. Assert. assertTrue ( replicas. isReassignmentInProgress() )
************************************
************************************
[+] input: testVersionCompare() { GravitinoVersion version1 = new GravitinoVersion("2.5.3", "2023-01-01", "1234567"); // test equal GravitinoVersion version2 = new GravitinoVersion("2.5.3", "2023-01-01", "1234567"); assertEquals(0, version1.compareTo(version2));  // test less than version1 = new GravitinoVersion("2.5.3", "2023-01-01", "1234567"); version2 = new GravitinoVersion("2.5.4", "2023-01-01", "1234567"); assertTrue(version1.compareTo(version2) < 0);  // test greater than version1 = new GravitinoVersion("2.5.3", "2023-01-01", "1234567"); version2 = new GravitinoVersion("2.5.2", "2023-01-01", "1234567"); assertTrue(version1.compareTo(version2) > 0);  // test equal with suffix version1 = new GravitinoVersion("2.5.3", "2023-01-01", "1234567"); version2 = new GravitinoVersion("2.5.3-SNAPSHOT", "2023-01-01", "1234567"); "<AssertPlaceHolder>"; }
compareTo(Object o) { if (!(o instanceof GravitinoVersion)) { return 1; } GravitinoVersion other = (GravitinoVersion) o;  int[] left = getVersionNumber(); int[] right = other.getVersionNumber(); for (int i = 0; i < VERSION_PART_NUMBER; i++) { int v = left[i] - right[i]; if (v != 0) { return v; } } return 0; }
[*] target: assertEquals(0, version1.compareTo(version2))
[-] pred: org. junit. Assert. assertEquals ( 0, version1. compareTo ( version2 ) )
************************************
************************************
[+] input: testAuthorizationFailed() { // Try connecting connectionStates.connecting(nodeId1, time.milliseconds(), "localhost");  time.sleep(100);  connectionStates.authenticationFailed(nodeId1, time.milliseconds(), new AuthenticationException("No path to CA for certificate!")); time.sleep(1000); assertEquals(connectionStates.connectionState(nodeId1), ConnectionState.AUTHENTICATION_FAILED); assertNotNull(connectionStates.authenticationException(nodeId1)); assertFalse(connectionStates.hasReadyNodes(time.milliseconds())); assertFalse(connectionStates.canConnect(nodeId1, time.milliseconds()));  time.sleep(connectionStates.connectionDelay(nodeId1, time.milliseconds()) + 1);  assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds())); connectionStates.ready(nodeId1); "<AssertPlaceHolder>"; }
authenticationException(String id) { NodeConnectionState state = nodeState.get(id); return state != null ? state.authenticationException : null; }
[*] target: assertNull(connectionStates.authenticationException(nodeId1))
[-] pred: org. junit. Assert. assertNull ( connectionStates. authenticationException(nodeId1 ) )
************************************
************************************
[+] input: testBytesToWebResponse() { try { byte[] bytes = "Sample bytes".getBytes(); String docName = "sample.txt"; MediaType mediaType = MediaType.TEXT_PLAIN;  ResponseEntity<byte[]> responseEntity = WebResponseUtils.bytesToWebResponse(bytes, docName, mediaType);  "<AssertPlaceHolder>"; assertEquals(HttpStatus.OK, responseEntity.getStatusCode()); assertNotNull(responseEntity.getBody());  HttpHeaders headers = responseEntity.getHeaders(); assertNotNull(headers); assertEquals(MediaType.TEXT_PLAIN, headers.getContentType()); assertNotNull(headers.getContentDisposition());   } catch (IOException e) { fail("Exception thrown: " + e.getMessage()); } }
bytesToWebResponse( byte[] bytes, String docName, MediaType mediaType) throws IOException {  // Return the PDF as a response HttpHeaders headers = new HttpHeaders(); headers.setContentType(mediaType); headers.setContentLength(bytes.length); String encodedDocName = URLEncoder.encode(docName, StandardCharsets.UTF_8.toString()) .replaceAll("\\+", "%20"); headers.setContentDispositionFormData("attachment", encodedDocName); return new ResponseEntity<>(bytes, headers, HttpStatus.OK); }
[*] target: assertNotNull(responseEntity)
[-] pred: org. junit. Assert. assertNotNull ( responseEntity )
************************************
************************************
[+] input: IOException { // Until https://github.com/airbytehq/airbyte/issues/7624 is solved, we need to handle nested oauth // parameters final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateNestedOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = Jsons.jsonNode(Map.of( EXISTING_FIELD_NAME, EXISTING_FIELD_VALUE, CREDENTIALS, Map.of( API_SECRET, SECRET_TWO, AUTH_TYPE, OAUTH, API_CLIENT, ((Map<String, String>) oauthParameters.get(CREDENTIALS)).get(API_CLIENT)))); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/getAllSubscriptionStatusesResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v1/subscriptions/4321", request.url().encodedPath()); Assertions.assertEquals(List.of("2", "1"), request.url().queryParameterValues("status")); Assertions."<AssertPlaceHolder>"; });  StatusResponse statusResponse = client.getAllSubscriptionStatuses("4321", new Status[] {Status.EXPIRED, Status.ACTIVE});  Assertions.assertNotNull(statusResponse); Assertions.assertEquals(Environment.LOCAL_TESTING, statusResponse.getEnvironment()); Assertions.assertEquals("LocalTesting", statusResponse.getRawEnvironment()); Assertions.assertEquals("com.example", statusResponse.getBundleId()); Assertions.assertEquals(5454545L, statusResponse.getAppAppleId());  SubscriptionGroupIdentifierItem item = new SubscriptionGroupIdentifierItem() .subscriptionGroupIdentifier("sub_group_one") .lastTransactions(List.of( new LastTransactionsItem() .status(Status.ACTIVE) .originalTransactionId("3749183") .signedTransactionInfo("signed_transaction_one") .signedRenewalInfo("signed_renewal_one"), new LastTransactionsItem() .status(Status.REVOKED) .originalTransactionId("5314314134") .signedTransactionInfo("signed_transaction_two") .signedRenewalInfo("signed_renewal_two") )); SubscriptionGroupIdentifierItem secondItem = new SubscriptionGroupIdentifierItem() .subscriptionGroupIdentifier("sub_group_two") .lastTransactions(List.of( new LastTransactionsItem() .status(Status.EXPIRED) .originalTransactionId("3413453") .signedTransactionInfo("signed_transaction_three") .signedRenewalInfo("signed_renewal_three") )); Assertions.assertEquals(List.of(item, secondItem), statusResponse.getData()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred: org. junit. Assert. assertNull ( request. body ( ) )
************************************
************************************
[+] input: testFromIcebergMultiColumn() { IcebergPartitionSpecExtractor extractor = IcebergPartitionSpecExtractor.getInstance();  Schema iceSchema = new Schema( Types.NestedField.required(0, "key_year", Types.DateType.get()), Types.NestedField.required(1, "key_string", Types.StringType.get())); PartitionSpec icePartitionSpec = PartitionSpec.builderFor(iceSchema).identity("key_string").year("key_year").build();  InternalSchema irSchema = InternalSchema.builder() .name("test_schema") .fields( Arrays.asList( InternalField.builder() .name("key_year") .fieldId(10) .schema(InternalSchema.builder().dataType(InternalType.DATE).build()) .build(), InternalField.builder() .name("key_string") .fieldId(11) .schema(InternalSchema.builder().dataType(InternalType.STRING).build()) .build())) .build();  List<InternalPartitionField> irPartitionSpec = extractor.fromIceberg(icePartitionSpec, iceSchema, irSchema); Assertions."<AssertPlaceHolder>";  InternalField sourceField = irPartitionSpec.get(0).getSourceField(); Assertions.assertEquals("key_string", sourceField.getName()); Assertions.assertEquals(11, sourceField.getFieldId()); Assertions.assertEquals(InternalType.STRING, sourceField.getSchema().getDataType()); Assertions.assertEquals( PartitionTransformType.VALUE, irPartitionSpec.get(0).getTransformType());  sourceField = irPartitionSpec.get(1).getSourceField(); Assertions.assertEquals("key_year", sourceField.getName()); Assertions.assertEquals(10, sourceField.getFieldId()); Assertions.assertEquals(InternalType.DATE, sourceField.getSchema().getDataType()); Assertions.assertEquals(PartitionTransformType.YEAR, irPartitionSpec.get(1).getTransformType()); }
fromIceberg( PartitionSpec iceSpec, Schema iceSchema, InternalSchema irSchema) { if (iceSpec.isUnpartitioned()) { return Collections.emptyList(); }  List<InternalPartitionField> irPartitionFields = new ArrayList<>(iceSpec.fields().size()); for (PartitionField iceField : iceSpec.fields()) { // fetch the ice field from the schema to properly handle hidden partition fields int sourceColumnId = iceField.sourceId(); Types.NestedField iceSchemaField = iceSchema.findField(sourceColumnId);  InternalField irField = SchemaFieldFinder.getInstance().findFieldByPath(irSchema, iceSchemaField.name()); InternalPartitionField irPartitionField = InternalPartitionField.builder() .sourceField(irField) .transformType(fromIcebergTransform(iceField.transform())) .build(); irPartitionFields.add(irPartitionField); }  return irPartitionFields; }
[*] target: assertEquals(2, irPartitionSpec.size())
[-] pred: org. junit. Assert. assertEquals ( 2, irPartitionSpec. size ( ) )
************************************
************************************
[+] input: testLimit_ApiKeyLimitNotFound() { Key key = new Key(); key.setRole("role"); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(new Config(), request, apiKeyData, null, "trace-id", "span-id"); proxyContext.setDeployment(new Model());  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.FORBIDDEN, result.result().status()); }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { assertFalse(destination.isFinished()); destination.notifyEndOfInput(); "<AssertPlaceHolder>"; }
isFinished() { return isFinished && messages.isEmpty(); }
[*] target: assertTrue(destination.isFinished())
[-] pred: org. junit. Assert. assertTrue ( destination. isFinished() )
************************************
************************************
[+] input: testEquals() { IndexPathNode indexPathNode = new IndexPathNode(token, charSource); IndexPathNode indexPathNode2 = new IndexPathNode(token, charSource); assertEquals(indexPathNode, indexPathNode2); "<AssertPlaceHolder>"; }
hashCode() { if (hashCodeSet) { return hashCode; } hashCode = CharSequenceUtils.hashCode(this); hashCodeSet = true; return hashCode; }
[*] target: assertEquals(indexPathNode.hashCode(), indexPathNode2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( indexPathNode. hashCode(), indexPathNode2. hashCode() )
************************************
************************************
[+] input: testCloseClearsData() { // We don't use the try-with-resources approach because we want to have access to the FetchBuffer after // the try block so that we can run our asserts on the object. FetchBuffer fetchBuffer = null;  try { fetchBuffer = new FetchBuffer(logContext); assertNull(fetchBuffer.nextInLineFetch()); assertTrue(fetchBuffer.isEmpty());  fetchBuffer.add(completedFetch(topicAPartition0)); assertFalse(fetchBuffer.isEmpty());  fetchBuffer.setNextInLineFetch(completedFetch(topicAPartition0)); assertNotNull(fetchBuffer.nextInLineFetch()); } finally { if (fetchBuffer != null) fetchBuffer.close(); }  assertNull(fetchBuffer.nextInLineFetch()); "<AssertPlaceHolder>"; }
isEmpty() { try { lock.lock(); return completedFetches.isEmpty(); } finally { lock.unlock(); } }
[*] target: assertTrue(fetchBuffer.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( fetchBuffer. isEmpty() )
************************************
************************************
[+] input: testToken() { OAuthBearerTokenCallback callback = new OAuthBearerTokenCallback(); callback.token(TOKEN); assertSame(TOKEN, callback.token()); assertNull(callback.errorCode()); assertNull(callback.errorDescription()); "<AssertPlaceHolder>"; }
errorUri() { return errorUri; }
[*] target: assertNull(callback.errorUri())
[-] pred: org. junit. Assert. assertNull ( callback. errorUri() )
************************************
************************************
[+] input: testIterator() { int max = 10; List<Integer> l = new ArrayList<>(); for (int i = 0; i < max; i++) l.add(i); ListIterator<Integer> iter = new ListIterator<>(l); for (int i = 0; i < max; i++) { Integer value = i; assertEquals(value, iter.peek()); assertTrue(iter.hasNext()); assertEquals(value, iter.next()); } "<AssertPlaceHolder>"; }
hasNext() { switch (state) { case FAILED: throw new IllegalStateException("Iterator is in failed state"); case DONE: return false; case READY: return true; default: return maybeComputeNext(); } }
[*] target: assertFalse(iter.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iter. hasNext() )
************************************
************************************
[+] input: checkCardOwner_Success() { // given when(cardBoardRepository.findCardBoardByUserId(userId)).thenReturn(cardBoard);  // when boolean result1 = cardBoardUseCase.checkCardOwner(userId, 1); boolean result2 = cardBoardUseCase.checkCardOwner(userId, 2); boolean result3 = cardBoardUseCase.checkCardOwner(userId, 3);  // then "<AssertPlaceHolder>"; assertTrue(result2); assertTrue(result3); verify(cardBoardRepository, times(3)).findCardBoardByUserId(userId); }
checkCardOwner(int userId, int cardId) { CardBoard cardBoard = cardBoardRepository.findCardBoardByUserId(userId); isCardBoardNotFound(cardBoard); return cardBoard.isCardOwner(userId, cardId); }
[*] target: assertTrue(result1)
[-] pred: org. junit. Assert. assertTrue ( result1 )
************************************
************************************
[+] input: Exception { String keyId = "abc123"; MockTime time = new MockTime(); HttpsJwks httpsJwks = spyHttpsJwks();  try (RefreshingHttpsJwks refreshingHttpsJwks = getRefreshingHttpsJwks(time, httpsJwks)) { refreshingHttpsJwks.init(); assertTrue(refreshingHttpsJwks.maybeExpediteRefresh(keyId)); "<AssertPlaceHolder>"; } }
maybeExpediteRefresh(String keyId) { if (keyId.length() > MISSING_KEY_ID_MAX_KEY_LENGTH) { // Although there's no limit on the length of the key ID, they're generally // "reasonably" short. If we have a very long key ID length, we're going to assume // the JWT is malformed, and we will not actually try to resolve the key. // // In this case, let's prevent blowing out our memory in two ways: // //     1. Don't try to resolve the key as the large ID will sit in our cache //     2. Report the issue in the logs but include only the first N characters int actualLength = keyId.length(); String trimmedKeyId = keyId.substring(0, MISSING_KEY_ID_MAX_KEY_LENGTH); String snippet = String.format("%s (trimmed to first %d characters out of %d total)", trimmedKeyId, MISSING_KEY_ID_MAX_KEY_LENGTH, actualLength); log.warn("Key ID {} was too long to cache", snippet); return false; } else { try { refreshLock.writeLock().lock();  Long nextCheckTime = missingKeyIds.get(keyId); long currTime = time.milliseconds(); log.debug("For key ID {}, nextCheckTime: {}, currTime: {}", keyId, nextCheckTime, currTime);  if (nextCheckTime == null || nextCheckTime <= currTime) { // If there's no entry in the missing key ID cache for the incoming key ID, // or it has expired, schedule a refresh ASAP. nextCheckTime = currTime + MISSING_KEY_ID_CACHE_IN_FLIGHT_MS; missingKeyIds.put(keyId, nextCheckTime); executorService.schedule(this::refresh, 0, TimeUnit.MILLISECONDS); return true; } else { return false; } } finally { refreshLock.writeLock().unlock(); } } }
[*] target: assertFalse(refreshingHttpsJwks.maybeExpediteRefresh(keyId))
[-] pred: org. junit. Assert. assertFalse ( refreshingHttpsJwks. maybeExpediteRefresh ( keyId ) )
************************************
************************************
[+] input: testCreateJobsDatabaseAvailabilityCheck() { final var dslContext = mock(DSLContext.class); final var timeoutMs = 500L; final var check = DatabaseCheckFactory.createJobsDatabaseAvailabilityCheck(dslContext, timeoutMs);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(JobsDatabaseAvailabilityCheck.class, check.getClass()); Assertions.assertEquals(timeoutMs, check.getTimeoutMs()); Assertions.assertTrue(check.getDslContext().isPresent()); Assertions.assertEquals(dslContext, check.getDslContext().get()); }
createJobsDatabaseAvailabilityCheck(final DSLContext dslContext, final long timeoutMs) { return new JobsDatabaseAvailabilityCheck(dslContext, timeoutMs); }
[*] target: assertNotNull(check)
[-] pred: org. junit. Assert. assertNotNull ( check )
************************************
************************************
[+] input: givenValidAdminUserClaimsAndRefreshToken_whenAccessTokenGenerated_thenReturnAysToken() { // Given AysUser mockUser = new AysUserBuilder() .withValidValues() .build(); Claims mockUserClaims = mockUser.getClaims();  // When Mockito.when(tokenConfiguration.getIssuer()).thenReturn(MOCK_ISSUER); Mockito.when(tokenConfiguration.getAccessTokenExpireMinute()).thenReturn(MOCK_ACCESS_TOKEN_EXPIRE_MINUTE); Mockito.when(tokenConfiguration.getRefreshTokenExpireDay()).thenReturn(MOCK_REFRESH_TOKEN_EXPIRE_DAY); Mockito.when(tokenConfiguration.getPrivateKey()).thenReturn(MOCK_PRIVATE_KEY);  // Then AysToken aysToken = tokenService.generate(mockUserClaims, mockAdminUserToken.getRefreshToken());  Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(aysToken.getAccessToken()); Assertions.assertNotNull(aysToken.getAccessTokenExpiresAt()); Assertions.assertNotNull(aysToken.getRefreshToken());  // Verify Mockito.verify(tokenConfiguration, Mockito.times(1)).getIssuer(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getAccessTokenExpireMinute(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getRefreshTokenExpireDay(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getPrivateKey(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getPublicKey(); Mockito.verifyNoMoreInteractions(tokenConfiguration); }
generate(final Claims claims, final String refreshToken) {  final long currentTimeMillis = System.currentTimeMillis();  final Date accessTokenExpiresAt = DateUtils.addMinutes( new Date(currentTimeMillis), tokenConfiguration.getAccessTokenExpireMinute() ); final String accessToken = this.initializeTokenBuilder(currentTimeMillis) .id(AysRandomUtil.generateUUID()) .expiration(accessTokenExpiresAt) .claims(claims) .compact();  return AysToken.builder() .accessToken(accessToken) .accessTokenExpiresAt(accessTokenExpiresAt.toInstant().getEpochSecond()) .refreshToken(refreshToken) .build(); }
[*] target: assertNotNull(aysToken)
[-] pred: org. junit. Assert. assertNotNull ( aysToken )
************************************
************************************
[+] input: testGetCompileRuntimeTransitiveDependenciesJunit() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.junit.jupiter", "junit-jupiter", new VersionNumber(5, 9, 2))); var dependencies_compile = resolver.getAllDependencies(compile, runtime); assertNotNull(dependencies_compile); assertEquals(8, dependencies_compile.size()); assertEquals(""" org.junit.jupiter:junit-jupiter:5.9.2 org.junit.jupiter:junit-jupiter-api:5.9.2 org.junit.jupiter:junit-jupiter-params:5.9.2 org.junit.jupiter:junit-jupiter-engine:5.9.2 org.opentest4j:opentest4j:1.2.0 org.junit.platform:junit-platform-commons:1.9.2 org.apiguardian:apiguardian-api:1.1.2 org.junit.platform:junit-platform-engine:1.9.2""", StringUtils.join(dependencies_compile, "\n")); var dependencies_runtime = resolver.getAllDependencies(runtime); "<AssertPlaceHolder>"; assertEquals(2, dependencies_runtime.size()); assertEquals(""" org.junit.jupiter:junit-jupiter:5.9.2 org.junit.jupiter:junit-jupiter-engine:5.9.2""", StringUtils.join(dependencies_runtime, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies_runtime)
[-] pred: org. junit. Assert. assertNotNull ( dependencies_runtime )
************************************
************************************
[+] input: countTokens_fullRequest() { var content = new Content( List.of(new TextPart("What is the airspeed velocity of an unladen swallow?")), "user"); var request = new CountTokensRequest( List.of(content), new GenerateContentRequest("models/gemini-1.5-flash-001", List.of(content), List.of(), null, null, null, null, null)); GeminiCountResponse response = service.countTokens(GeminiService.GEMINI_PRO, request); "<AssertPlaceHolder>"; System.out.println(response); assertThat(response.totalTokens()).isEqualTo(13); }
countTokens(String model, CountTokensRequest request) { return geminiInterface.countTokens(model, request); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: Exception { // prepare String path = "user/" + userId + "/" + file.getName(); assertTrue(path.endsWith("mp4")); minioService.uploadObject(file, minioConfiguration.getStoreBucket(), path); // test videoService.download("minio.bucket.store://" + path, "download/" + videoId); File src = new File("download/" + videoId); src.deleteOnExit(); "<AssertPlaceHolder>"; }
download(String path, String outputName) throws Exception;
[*] target: assertTrue(src.exists())
[-] pred: org. junit. Assert. assertTrue ( src. exists ( ) )
************************************
************************************
[+] input: TARGET_FIND_SERVICE_TEST() {  Long targetId = 123L; Target target = Target.builder() .id(targetId) .nickname("sujin") .build();  when(targetFindPort.findTarget(targetId)).thenReturn(Optional.of(target));  TargetDto result = targetFindService.findTarget(targetId);  "<AssertPlaceHolder>"; assertEquals(TargetDtoMapper.toTargetDto(target), result);  }
findTarget(Long targetId) { Target target = targetFindPort.findTarget(targetId).orElseThrow(() -> { throw new TargetDoesNotExistException(targetId); }); return TargetDtoMapper.toTargetDto(target); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: queryRoute() { QueryRouteRequest request = QueryRouteRequest.newBuilder() .setTopic(Resource.newBuilder().setName("topic").build()) .build();  CompletableFuture<QueryRouteResponse> future = routeActivity.queryRoute(ProxyContextExt.create(), request); "<AssertPlaceHolder>"; assertTrue(future.isDone()); assertFalse(future.isCompletedExceptionally());  QueryRouteResponse response = future.join(); assertEquals(Code.OK, response.getStatus().getCode()); assertEquals(1, response.getMessageQueuesList().size());  MessageQueue queue = response.getMessageQueuesList().get(0); assertEquals(2, queue.getId());  Broker broker = queue.getBroker(); assertEquals("1_2", broker.getName()); assertEquals(1, broker.getEndpoints().getAddressesCount());  apache.rocketmq.v2.Address addresses = broker.getEndpoints().getAddresses(0); assertEquals("broker", addresses.getHost()); assertEquals(10911, addresses.getPort()); }
queryRoute(ProxyContext ctx, QueryRouteRequest request) { return super.queryRoute(ctx, request).thenApply(response -> { QueryRouteResponse.Builder newBuilder = QueryRouteResponse.newBuilder(response); List<MessageQueue> mqList = newBuilder.getMessageQueuesList(); for (int i = 0; i < mqList.size(); i++) { MessageQueue messageQueue = mqList.get(i); VirtualQueue virtualQueue = new VirtualQueue(messageQueue.getBroker().getName());  MessageQueue newQueue = MessageQueue.newBuilder(messageQueue).setId(virtualQueue.physicalQueueId()).build(); newBuilder.setMessageQueues(i, newQueue); } return newBuilder.build(); }); }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: shouldDropConsumerGroupOffsetsOnAbortIfTransactionsAreEnabled() { buildMockProducer(true); producer.initTransactions(); producer.beginTransaction();  String group = "g"; Map<TopicPartition, OffsetAndMetadata> groupCommit = new HashMap<TopicPartition, OffsetAndMetadata>() { { put(new TopicPartition(topic, 0), new OffsetAndMetadata(42L, null)); put(new TopicPartition(topic, 1), new OffsetAndMetadata(73L, null)); } }; producer.sendOffsetsToTransaction(groupCommit, new ConsumerGroupMetadata(group)); producer.abortTransaction();  producer.beginTransaction(); producer.commitTransaction(); assertTrue(producer.consumerGroupOffsetsHistory().isEmpty());  producer.beginTransaction(); producer.sendOffsetsToTransaction(groupCommit, new ConsumerGroupMetadata(group)); producer.abortTransaction();  producer.beginTransaction(); producer.commitTransaction(); "<AssertPlaceHolder>"; }
consumerGroupOffsetsHistory() { return new ArrayList<>(this.consumerGroupOffsets); }
[*] target: assertTrue(producer.consumerGroupOffsetsHistory().isEmpty())
[-] pred: org. junit. Assert. assertTrue (producer.consumerGroupOffsetsHistory ( ). isEmpty ( ) )
************************************
************************************
[+] input: testGetCompileTransitiveDependenciesJettyFullGroupExclusion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14)) .exclude("org.eclipse.jetty", "*")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(3, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14 org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.slf4j:slf4j-api:2.0.5""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: testOf() { IkonProvider ikonProvider = new FontAwesomeIkonProvider(); IkonData ikonData = IkonData.of(ikonProvider); assertEquals(ikonProvider.getIkon().getSimpleName(), ikonData.getName()); "<AssertPlaceHolder>"; }
getIkonProvider() { return ikonProvider; }
[*] target: assertEquals(ikonProvider, ikonData.getIkonProvider())
[-] pred: org. junit. Assert. assertEquals ( ikonProvider, ikonData. getIkonProvider() )
************************************
************************************
[+] input: testDynamicBlock() { long firstId = 1309418324L; int blockSize = 5391; int brokerId = 5;  ProducerIdsBlock block = new ProducerIdsBlock(brokerId, firstId, blockSize); assertEquals(firstId, block.firstProducerId()); assertEquals(firstId + blockSize - 1, block.lastProducerId()); assertEquals(firstId + blockSize, block.nextBlockFirstId()); assertEquals(blockSize, block.size()); "<AssertPlaceHolder>"; }
assignedBrokerId() { return assignedBrokerId; }
[*] target: assertEquals(brokerId, block.assignedBrokerId())
[-] pred: org. junit. Assert. assertEquals ( brokerId, block. assignedBrokerId() )
************************************
************************************
[+] input: testCreateUser() { UserManagementService.UserDTO userDTO = new UserManagementService.UserDTO(); userDTO.setFirstName("John"); userDTO.setLastName("Doe"); userDTO.setEmail("john.doe@example.com");  UserManagementService.User user = UserManagementService.createUser(userDTO); "<AssertPlaceHolder>"; assertEquals("John", user.getFirstName()); }
createUser(UserDTO userDTO){ Function<UserDTO, UserDTO> pipeline = UserManagementService:: validateUser; return pipeline .andThen(UserManagementService:: createUserFromDto) .andThen(user -> Repository.save(user)) .apply(userDTO); }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: testUpstreamRefresh() { Config config = new Config(); Map<String, Model> models = new HashMap<>(); config.setModels(models);  Model model = new Model(); model.setName("model1"); model.setUpstreams(List.of( new Upstream("endpoint1", null, 1, 1), new Upstream("endpoint2", null, 1, 1) ));  models.put("model1", model); UpstreamRouteProvider upstreamRouteProvider = new UpstreamRouteProvider(); upstreamRouteProvider.onUpdate(config);  UpstreamRoute route = upstreamRouteProvider.get(new DeploymentUpstreamProvider(model)); Upstream upstream;  // fail 2 upstreams for (int i = 0; i < 2; i++) { upstream = route.get(); assertNotNull(upstream); route.fail(HttpStatus.TOO_MANY_REQUESTS, 100); route.next(); }  upstream = route.get(); "<AssertPlaceHolder>";  Model model1 = new Model(); model1.setName("model1"); model1.setUpstreams(List.of( new Upstream("endpoint2", null, 1, 1), new Upstream("endpoint1", null, 1, 1) ));  models.put("model1", model1); upstreamRouteProvider.onUpdate(config);  // upstreams remains the same, state must not be invalidated route = upstreamRouteProvider.get(new DeploymentUpstreamProvider(model1));  upstream = route.get(); assertNull(upstream);  Model model2 = new Model(); model2.setName("model1"); model2.setUpstreams(List.of( new Upstream("endpoint2", null, 5, 1), new Upstream("endpoint1", null, 1, 1) ));  models.put("model1", model2); upstreamRouteProvider.onUpdate(config);  // upstreams updated, current state must be evicted route = upstreamRouteProvider.get(new DeploymentUpstreamProvider(model2));  upstream = route.get(); assertNotNull(upstream); assertEquals("endpoint2", upstream.getEndpoint()); }
next();
[*] target: assertNull(upstream)
[-] pred: org. junit. Assert. assertNull ( upstream )
************************************
************************************
[+] input: shouldReturnPresenceOfMetrics() { final Metrics metrics = new Metrics(); final Sensor sensor = metrics.sensor("sensor");  assertFalse(sensor.hasMetrics());  sensor.add( new MetricName("name1", "group1", "description1", Collections.emptyMap()), new WindowedSum() );  assertTrue(sensor.hasMetrics());  sensor.add( new MetricName("name2", "group2", "description2", Collections.emptyMap()), new CumulativeCount() );  "<AssertPlaceHolder>"; }
hasMetrics() { return !metrics.isEmpty(); }
[*] target: assertTrue(sensor.hasMetrics())
[-] pred: org. junit. Assert. assertTrue ( sensor. hasMetrics() )
************************************
************************************
[+] input: NoSuchAlgorithmException { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); IdentityProvider provider1 = mock(IdentityProvider.class); when(provider1.match(any(DecodedJWT.class))).thenReturn(false); IdentityProvider provider2 = mock(IdentityProvider.class); when(provider2.match(any(DecodedJWT.class))).thenReturn(true); when(provider2.extractClaimsFromJwt(any(DecodedJWT.class))).thenReturn(Future.succeededFuture(new ExtractedClaims("sub", Collections.emptyList(), "hash", Map.of()))); List<IdentityProvider> providerList = List.of(provider1, provider2); validator.setProviders(providerList); KeyPair keyPair = generateRsa256Pair(); Algorithm algorithm = Algorithm.RSA256((RSAPublicKey) keyPair.getPublic(), (RSAPrivateKey) keyPair.getPrivate()); String token = JWT.create().withClaim("iss", "issuer2").sign(algorithm); Future<ExtractedClaims> future = validator.extractClaims(getBearerHeaderValue(token)); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.succeeded()); ExtractedClaims claims = res.result(); assertNotNull(claims); assertEquals("sub", claims.sub()); assertEquals(Collections.emptyList(), claims.userRoles()); assertEquals("hash", claims.userHash()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testClaimToken() { User user = new User(); PasswordResetToken unusedTokenA = service.createTokenWithUser(user); PasswordResetToken unusedTokenB = service.createTokenWithUser(user); PasswordResetToken unusedTokenC = service.createTokenWithUser(user);  when(repository.findActiveTokensForUser(user)).thenReturn(ImmutableList.of( unusedTokenA, unusedTokenB, unusedTokenC ));  // we are using tokenB, hence it should be marked as "claimed" PasswordResetToken claimedToken = service.claimToken(unusedTokenB); verify(repository, times(1)).findActiveTokensForUser(user); "<AssertPlaceHolder>"; assertEquals(user, claimedToken.getUser());  // only token B is claimed assertFalse(unusedTokenA.getClaimed()); assertTrue(unusedTokenB.getClaimed()); assertFalse(unusedTokenC.getClaimed());  // all tokens should be marked inactive regardless of claimed/unclaimed assertFalse(unusedTokenA.getActive()); assertFalse(claimedToken.getActive()); assertFalse(unusedTokenC.getActive()); }
claimToken(PasswordResetToken token) { User user = token.getUser(); token.setClaimed(true);  CollectionUtils.emptyIfNull(repository.findActiveTokensForUser(user)) .forEach(t -> t.setActive(false));  return token; }
[*] target: assertEquals(unusedTokenB, claimedToken)
[-] pred: org. junit. Assert. assertEquals ( unusedTokenB, claimedToken )
************************************
************************************
[+] input: testSourceTasksStdin() { sourceProperties.remove(FileStreamSourceConnector.FILE_CONFIG); connector.start(sourceProperties); List<Map<String, String>> taskConfigs = connector.taskConfigs(1); "<AssertPlaceHolder>"; assertNull(taskConfigs.get(0).get(FileStreamSourceConnector.FILE_CONFIG)); }
taskConfigs(int maxTasks) { ArrayList<Map<String, String>> configs = new ArrayList<>(); // Only one input stream makes sense. configs.add(props); return configs; }
[*] target: assertEquals(1, taskConfigs.size())
[-] pred: org. junit. Assert. assertEquals ( 1, taskConfigs. size ( ) )
************************************
************************************
[+] input: testClearStateForStreamsToBackfill() { final List<io.airbyte.config.StreamDescriptor> streamsToBackfill = List.of(DOMAIN_STREAM_DESCRIPTOR); final State updatedState = BackfillHelper.clearStateForStreamsToBackfill(STATE, streamsToBackfill); "<AssertPlaceHolder>"; final var typedState = StateMessageHelper.getTypedState(updatedState.getState()); assertEquals(1, typedState.get().getStateMessages().size()); assertEquals(JsonNodeFactory.instance.nullNode(), typedState.get().getStateMessages().getFirst().getStream().getStreamState()); }
clearStateForStreamsToBackfill(final State inputState, final List<StreamDescriptor> streamsToBackfill) { if (inputState == null) { // This would be the case for a Full Refresh sync. return null; } final var stateOptional = StateMessageHelper.getTypedState(inputState.getState()); if (stateOptional.isEmpty()) { return null; // No state, no backfill. } final StateWrapper state = stateOptional.get(); final StateType type = state.getStateType(); if (!StateType.STREAM.equals(type)) { return null; // Only backfill for per-stream state. } boolean stateWasModified = false; for (final var stateMessage : state.getStateMessages()) { if (!AirbyteStateMessage.AirbyteStateType.STREAM.equals(stateMessage.getType())) { continue; } if (!streamsToBackfill.contains( ProtocolConverters.toInternal(stateMessage.getStream().getStreamDescriptor()))) { continue; } // It's listed in the streams to backfill, so we write the state to null. stateMessage.getStream().setStreamState(JsonNodeFactory.instance.nullNode()); stateWasModified = true; } return stateWasModified ? StateMessageHelper.getState(state) : null; }
[*] target: assertNotNull(updatedState)
[-] pred: org. junit. Assert. assertNotNull ( updatedState )
************************************
************************************
[+] input: buildUndoSQL() { String sql = executor.buildUndoSQL().toLowerCase(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("insert")); Assertions.assertTrue(sql.contains("id")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } Row row = beforeImageRows.get(0); List<Field> fields = new ArrayList<>(row.nonPrimaryKeys()); fields.addAll(getOrderedPkList(beforeImage,row,JdbcConstants.MYSQL));  // delete sql undo log before image all field come from table meta, need add escape. // see BaseTransactionalExecutor#buildTableRecords String insertColumns = fields.stream() .map(field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.MYSQL)) .collect(Collectors.joining(", ")); String insertValues = fields.stream().map(field -> "?") .collect(Collectors.joining(", "));  return String.format(INSERT_SQL_TEMPLATE, sqlUndoLog.getTableName(), insertColumns, insertValues); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); when(configRepository.getSourceOAuthParameterOptional(any(), any())).thenReturn(Optional.of( new SourceOAuthParameter() .withOauthParameterId(UUID.randomUUID()) .withSourceDefinitionId(sourceDefinitionId) .withWorkspaceId(workspaceId) .withConfiguration(Jsons.jsonNode(oauthParameters)))); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: shouldSetSessionIdAsSpanAttribute() { when(sessionId.getSessionId()).thenReturn("42");  SessionIdSpanAppender underTest = new SessionIdSpanAppender(sessionId);  assertTrue(underTest.isStartRequired()); underTest.onStart(Context.root(), span);  verify(span).setAttribute(SESSION_ID_KEY, "42");  "<AssertPlaceHolder>"; }
isEndRequired() { return false; }
[*] target: assertFalse(underTest.isEndRequired())
[-] pred: org. junit. Assert. assertFalse ( underTest. isEndRequired() )
************************************
************************************
[+] input: testRequestHeaderV1() { short apiVersion = 1; RequestHeader header = new RequestHeader(ApiKeys.FIND_COORDINATOR, apiVersion, "", 10); assertEquals(1, header.headerVersion());  ByteBuffer buffer = RequestTestUtils.serializeRequestHeader(header); assertEquals(10, buffer.remaining()); RequestHeader deserialized = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { short apiKey = -1; try { // We derive the header version from the request api version, so we read that first. // The request api version is part of `RequestHeaderData`, so we reset the buffer position after the read. int bufferStartPositionForHeader = buffer.position(); apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); short headerVersion = ApiKeys.forId(apiKey).requestHeaderVersion(apiVersion); buffer.position(bufferStartPositionForHeader); final RequestHeaderData headerData = new RequestHeaderData(new ByteBufferAccessor(buffer), headerVersion); // Due to a quirk in the protocol, client ID is marked as nullable. // However, we treat a null client ID as equivalent to an empty client ID. if (headerData.clientId() == null) { headerData.setClientId(""); } final RequestHeader header = new RequestHeader(headerData, headerVersion); // Size of header is calculated by the shift in the position of buffer's start position during parsing. // Prior to parsing, the buffer's start position points to header data and after the parsing operation // the buffer's start position points to api message. For more information on how the buffer is // constructed, see RequestUtils#serialize() header.size = Math.max(buffer.position() - bufferStartPositionForHeader, 0); return header; } catch (UnsupportedVersionException e) { throw new InvalidRequestException("Unknown API key " + apiKey, e); } catch (Throwable ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + apiKey, ex); } }
[*] target: assertEquals(header, deserialized)
[-] pred: org. junit. Assert. assertEquals ( header, deserialized )
************************************
************************************
[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: testExceptionToModelView() { // Create a mock Model Model model = new org.springframework.ui.ExtendedModelMap();  // Create a test exception Exception ex = new Exception("Test Exception");  // Call the method under test ModelAndView modelAndView = ErrorUtils.exceptionToModelView(model, ex);  // Verify the result "<AssertPlaceHolder>"; assertEquals("Test Exception", modelAndView.getModel().get("errorMessage")); assertNotNull(modelAndView.getModel().get("stackTrace")); }
exceptionToModelView(Model model, Exception ex) { StringWriter sw = new StringWriter(); ex.printStackTrace(new PrintWriter(sw)); String stackTrace = sw.toString();  ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("errorMessage", ex.getMessage()); modelAndView.addObject("stackTrace", stackTrace); return modelAndView; }
[*] target: assertNotNull(modelAndView)
[-] pred: org. junit. Assert. assertNotNull ( modelAndView )
************************************
************************************
[+] input: idleBeat() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 15;  // Act final ReturnT<String> retval = executorBiz.idleBeat(new IdleBeatParam(jobId));  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(500, retval.getCode()); Assertions.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(IdleBeatParam idleBeatParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: testBatchedErrors() { Map<TopicPartition, Errors> txn1Errors = Collections.singletonMap(tp1, errorOne); Map<TopicPartition, Errors> txn2Errors = Collections.singletonMap(tp1, errorOne);  AddPartitionsToTxnResult transaction1 = AddPartitionsToTxnResponse.resultForTransaction("txn1", txn1Errors); AddPartitionsToTxnResult transaction2 = AddPartitionsToTxnResponse.resultForTransaction("txn2", txn2Errors);  AddPartitionsToTxnResultCollection results = new AddPartitionsToTxnResultCollection(); results.add(transaction1); results.add(transaction2);  AddPartitionsToTxnResponse response = new AddPartitionsToTxnResponse(new AddPartitionsToTxnResponseData().setResultsByTransaction(results));  assertEquals(txn1Errors, errorsForTransaction(response.getTransactionTopicResults("txn1"))); assertEquals(txn2Errors, errorsForTransaction(response.getTransactionTopicResults("txn2")));  Map<String, Map<TopicPartition, Errors>> expectedErrors = new HashMap<>(); expectedErrors.put("txn1", txn1Errors); expectedErrors.put("txn2", txn2Errors); "<AssertPlaceHolder>"; }
errors() { Map<String, Map<TopicPartition, Errors>> errorsMap = new HashMap<>();  if (!this.data.resultsByTopicV3AndBelow().isEmpty()) { errorsMap.put(V3_AND_BELOW_TXN_ID, errorsForTransaction(this.data.resultsByTopicV3AndBelow())); }  for (AddPartitionsToTxnResult result : this.data.resultsByTransaction()) { errorsMap.put(result.transactionalId(), errorsForTransaction(result.topicResults())); }  return errorsMap; }
[*] target: assertEquals(expectedErrors, response.errors())
[-] pred: org. junit. Assert. assertEquals ( expectedErrors, response. errors() )
************************************
************************************
[+] input: JsonProcessingException { Model model = new Model(); Map<String, Object> defaults = Map.of("key1", true, "key2", 123, "key3", 0.45, "key4", "str"); model.setDefaults(defaults); when(context.getDeployment()).thenReturn(model); Mockito.doCallRealMethod().when(context).setRequestBody(any(Buffer.class)); when(context.getRequestBody()).thenCallRealMethod(); Throwable error = fn.apply((ObjectNode) ProxyUtil.MAPPER.readTree("{}")); "<AssertPlaceHolder>"; String json = context.getRequestBody().toString(StandardCharsets.UTF_8); ObjectNode result = (ObjectNode) ProxyUtil.MAPPER.readTree(json); assertNotNull(result); assertEquals(123, result.get("key2").asInt()); assertEquals(0.45, result.get("key3").asDouble()); assertEquals("str", result.get("key4").asText()); assertTrue(result.get("key1").asBoolean()); }
apply(ObjectNode tree) { try { if (applyDefaults(context, tree)) { context.setRequestBody(Buffer.buffer(ProxyUtil.MAPPER.writeValueAsBytes(tree))); } return null; } catch (Throwable e) { context.respond(HttpStatus.BAD_REQUEST); log.warn("Can't apply default parameters to deployment {}. Trace: {}. Span: {}. Error: {}", context.getDeployment().getName(), context.getTraceId(), context.getSpanId(), e.getMessage()); return e; } }
[*] target: assertNull(error)
[-] pred: org. junit. Assert. assertNull ( error )
************************************
************************************
[+] input: testCreateJobsDatabaseMigrationCheck() { final var dslContext = mock(DSLContext.class); final var flyway = mock(Flyway.class); final var minimumMigrationVersion = "1.2.3"; final var timeoutMs = 500L; final var check = DatabaseCheckFactory.createJobsDatabaseMigrationCheck(dslContext, flyway, minimumMigrationVersion, timeoutMs);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(JobsDatabaseMigrationCheck.class, check.getClass()); Assertions.assertTrue(check.getDatabaseAvailabilityCheck().isPresent()); Assertions.assertEquals(JobsDatabaseAvailabilityCheck.class, check.getDatabaseAvailabilityCheck().get().getClass()); Assertions.assertEquals(minimumMigrationVersion, check.getMinimumFlywayVersion()); Assertions.assertEquals(timeoutMs, check.getTimeoutMs()); Assertions.assertTrue(check.getFlyway().isPresent()); Assertions.assertEquals(flyway, check.getFlyway().get()); }
createJobsDatabaseMigrationCheck(final DSLContext dslContext, final Flyway flyway, final String minimumMigrationVersion, final long timeoutMs) { return new JobsDatabaseMigrationCheck(createJobsDatabaseAvailabilityCheck(dslContext, timeoutMs), flyway, minimumMigrationVersion, timeoutMs); }
[*] target: assertNotNull(check)
[-] pred: org. junit. Assert. assertNotNull ( check )
************************************
************************************
[+] input: APIException { AppStoreServerAPIClient client = getClientWithBody("models/extendRenewalDateForAllActiveSubscribersResponse.json", request -> { Assertions.assertEquals("POST", request.method()); Assertions.assertEquals("/inApps/v1/subscriptions/extend/mass", request.url().encodedPath()); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(expectedMediaType, body.contentType()); Buffer buffer = new Buffer(); try { body.writeTo(buffer); } catch (IOException e) { throw new RuntimeException(e); } Map<String, Object> root; try { root = new ObjectMapper().readValue(buffer.readUtf8(), Map.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } Assertions.assertEquals(45, ((Number) root.get("extendByDays")).intValue()); Assertions.assertEquals(1, ((Number) root.get("extendReasonCode")).intValue()); Assertions.assertEquals("fdf964a4-233b-486c-aac1-97d8d52688ac", root.get("requestIdentifier")); Assertions.assertEquals(List.of("USA", "MEX"), root.get("storefrontCountryCodes")); Assertions.assertEquals("com.example.productId", root.get("productId")); });  MassExtendRenewalDateRequest extendRenewalDateRequest = new MassExtendRenewalDateRequest() .extendByDays(45) .extendReasonCode(ExtendReasonCode.CUSTOMER_SATISFACTION) .requestIdentifier("fdf964a4-233b-486c-aac1-97d8d52688ac") .storefrontCountryCodes(List.of("USA", "MEX")) .productId("com.example.productId");  MassExtendRenewalDateResponse massExtendRenewalDateResponse = client.extendRenewalDateForAllActiveSubscribers(extendRenewalDateRequest);  Assertions.assertNotNull(massExtendRenewalDateResponse); Assertions.assertEquals("758883e8-151b-47b7-abd0-60c4d804c2f5", massExtendRenewalDateResponse.getRequestIdentifier()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred: org. junit. Assert. assertNotNull ( body )
************************************
************************************
[+] input: kill() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.kill(new KillParam(jobId));  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(200, retval.getCode()); Assertions.assertNull(retval.getMsg()); }
kill(KillParam killParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: testChildPartitionIdNull() { MetadataNode child1 = NODE.child("1"); MetadataNode child2 = NODE.child("a"); "<AssertPlaceHolder>"; assertNull(child2); }
child(String name) { if (name.equals("name")) { return new MetadataLeafNode(image.name()); } else if (name.equals("id")) { return new MetadataLeafNode(image.id().toString()); } else { int partitionId; try { partitionId = Integer.parseInt(name); } catch (NumberFormatException e) { return null; } PartitionRegistration registration = image.partitions().get(partitionId); if (registration == null) return null; return new MetadataLeafNode(registration.toString()); } }
[*] target: assertNull(child1)
[-] pred: org. junit. Assert. assertNull ( child1 )
************************************
************************************
[+] input: testOnJoinPrepareWithOffsetCommitShouldKeepJoinAfterRebalanceTimeout() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.empty(), false)) { int generationId = 42; String memberId = "consumer-42";  Timer pollTimer = time.timer(0L); boolean res = coordinator.onJoinPrepare(pollTimer, generationId, memberId); assertFalse(res);  pollTimer = time.timer(100L); time.sleep(rebalanceTimeoutMs); client.respond(offsetCommitResponse(singletonMap(t1p, Errors.UNKNOWN_TOPIC_OR_PARTITION))); res = coordinator.onJoinPrepare(pollTimer, generationId, memberId); "<AssertPlaceHolder>";  assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
onJoinPrepare(Timer timer, int generation, String memberId) { log.debug("Executing onJoinPrepare with generation {} and memberId {}", generation, memberId); if (joinPrepareTimer == null) { // We should complete onJoinPrepare before rebalanceTimeoutMs, // and continue to join group to avoid member got kicked out from group joinPrepareTimer = time.timer(rebalanceConfig.rebalanceTimeoutMs); } else { joinPrepareTimer.update(); }  // async commit offsets prior to rebalance if auto-commit enabled // and there is no in-flight offset commit request if (autoCommitEnabled && autoCommitOffsetRequestFuture == null) { maybeMarkPartitionsPendingRevocation(); autoCommitOffsetRequestFuture = maybeAutoCommitOffsetsAsync(); }  // wait for commit offset response before timer expired if (autoCommitOffsetRequestFuture != null) { Timer pollTimer = timer.remainingMs() < joinPrepareTimer.remainingMs() ? timer : joinPrepareTimer; client.poll(autoCommitOffsetRequestFuture, pollTimer); joinPrepareTimer.update();  // Keep retrying/waiting the offset commit when: // 1. offset commit haven't done (and joinPrepareTimer not expired) // 2. failed with retriable exception (and joinPrepareTimer not expired) // Otherwise, continue to revoke partitions, ex: // 1. if joinPrepareTimer has expired // 2. if offset commit failed with non-retriable exception // 3. if offset commit success boolean onJoinPrepareAsyncCommitCompleted = true; if (joinPrepareTimer.isExpired()) { log.error("Asynchronous auto-commit of offsets failed: joinPrepare timeout. Will continue to join group"); } else if (!autoCommitOffsetRequestFuture.isDone()) { onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && autoCommitOffsetRequestFuture.isRetriable()) { log.debug("Asynchronous auto-commit of offsets failed with retryable error: {}. Will retry it.", autoCommitOffsetRequestFuture.exception().getMessage()); onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && !autoCommitOffsetRequestFuture.isRetriable()) { log.error("Asynchronous auto-commit of offsets failed: {}. Will continue to join group.", autoCommitOffsetRequestFuture.exception().getMessage()); } if (autoCommitOffsetRequestFuture.isDone()) { autoCommitOffsetRequestFuture = null; } if (!onJoinPrepareAsyncCommitCompleted) { pollTimer.sleep(Math.min(pollTimer.remainingMs(), rebalanceConfig.retryBackoffMs)); timer.update(); return false; } }  // the generation / member-id can possibly be reset by the heartbeat thread // upon getting errors or heartbeat timeouts; in this case whatever is previously // owned partitions would be lost, we should trigger the callback and cleanup the assignment; // otherwise we can proceed normally and revoke the partitions depending on the protocol, // and in that case we should only change the assignment AFTER the revoke callback is triggered // so that users can still access the previously owned partitions to commit offsets etc. Exception exception = null; final SortedSet<TopicPartition> revokedPartitions = new TreeSet<>(COMPARATOR); if (generation == Generation.NO_GENERATION.generationId || memberId.equals(Generation.NO_GENERATION.memberId)) { revokedPartitions.addAll(subscriptions.assignedPartitions());  if (!revokedPartitions.isEmpty()) { log.info("Giving away all assigned partitions as lost since generation/memberID has been reset," + "indicating that consumer is in old state or no longer part of the group"); exception = rebalanceListenerInvoker.invokePartitionsLost(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet()); } } else { switch (protocol) { case EAGER: // revoke all partitions revokedPartitions.addAll(subscriptions.assignedPartitions()); exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet());  break;  case COOPERATIVE: // only revoke those partitions that are not in the subscription anymore. Set<TopicPartition> ownedPartitions = new HashSet<>(subscriptions.assignedPartitions()); revokedPartitions.addAll(ownedPartitions.stream() .filter(tp -> !subscriptions.subscription().contains(tp.topic())) .collect(Collectors.toSet()));  if (!revokedPartitions.isEmpty()) { exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  ownedPartitions.removeAll(revokedPartitions); subscriptions.assignFromSubscribed(ownedPartitions); }  break; } }  isLeader = false; subscriptions.resetGroupSubscription(); joinPrepareTimer = null; autoCommitOffsetRequestFuture = null; timer.update();  if (exception != null) { throw new KafkaException("User rebalance callback throws an error", exception); } return true; }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: JsonProcessingException { doCallRealMethod().when(context).setStreamingRequest(anyBoolean()); when(context.isStreamingRequest()).thenCallRealMethod();  Throwable error = fn.apply((ObjectNode) ProxyUtil.MAPPER.readTree("{"stream": false}"));  "<AssertPlaceHolder>"; assertFalse(context.isStreamingRequest()); }
apply(ObjectNode tree) { JsonNode stream = tree.get("stream"); boolean result = stream != null && stream.asBoolean(false); context.setStreamingRequest(result); return null; }
[*] target: assertNull(error)
[-] pred: org. junit. Assert. assertNull ( error )
************************************
************************************
[+] input: IOException { // Until https://github.com/airbytehq/airbyte/issues/7624 is solved, we need to handle nested oauth // parameters final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateNestedOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) ((Map<String, Object>) oauthParameters.get(CREDENTIALS)).get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: shouldOpen() { var batchSize = 33; Loader loader = new TestLoader(600, batchSize, 33); MetaData metaData = loader.open();  int numberItems = metaData.getNumberItems(); int lastBatchSize = numberItems % batchSize; int numberBatches = metaData.getNumberBatches();  for (int i = 0; i < numberBatches; i++) { BatchData batchData = loader.readBatch(); "<AssertPlaceHolder>";  int itemsRead = metaData.getItemsRead();  int inputSize = metaData.getInputSize(); int expectedSize = metaData.getNumberOfClasses();  Matrix input = new Matrix(inputSize, itemsRead, batchData.getInputBatch()); Matrix expected = new Matrix(expectedSize, itemsRead, batchData.getExpectedBatch());  System.out.println(input.sum()); assertTrue(input.sum() != 0.0);  assertTrue(expected.sum() == itemsRead);  if (i == numberBatches - 1) { assertEquals(itemsRead, lastBatchSize); } else { assertEquals(itemsRead, batchSize); } } }
readBatch();  default void reset() {}
[*] target: assertNotNull(batchData)
[-] pred: org. junit. Assert. assertNotNull ( batchData )
************************************
************************************
[+] input: testGetCompileRuntimeTransitiveDependenciesMariaDb() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.mariadb.jdbc", "mariadb-java-client", new VersionNumber(3, 1, 3))); var dependencies_compile = resolver.getAllDependencies(compile, runtime); assertNotNull(dependencies_compile); assertEquals(9, dependencies_compile.size()); assertEquals(""" org.mariadb.jdbc:mariadb-java-client:3.1.3 com.github.waffle:waffle-jna:3.2.0 net.java.dev.jna:jna:5.12.1 net.java.dev.jna:jna-platform:5.12.1 org.slf4j:jcl-over-slf4j:1.7.36 org.slf4j:slf4j-api:1.7.36 com.github.ben-manes.caffeine:caffeine:2.9.3 org.checkerframework:checker-qual:3.23.0 com.google.errorprone:error_prone_annotations:2.10.0""", StringUtils.join(dependencies_compile, "\n")); var dependencies_runtime = resolver.getAllDependencies(runtime); "<AssertPlaceHolder>"; assertEquals(1, dependencies_runtime.size()); assertEquals(""" org.mariadb.jdbc:mariadb-java-client:3.1.3""", StringUtils.join(dependencies_runtime, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies_runtime)
[-] pred: org. junit. Assert. assertNotNull ( dependencies_runtime )
************************************
************************************
[+] input: testConversionTargetFromNameForICEBERG() { ConversionTarget tc = ConversionTargetFactory.getInstance().createConversionTargetForName(TableFormat.ICEBERG); "<AssertPlaceHolder>"; TargetTable targetTable = getPerTableConfig(TableFormat.ICEBERG); Configuration conf = new Configuration(); conf.setStrings("spark.master", "local"); tc.init(targetTable, conf); assertEquals(tc.getTableFormat(), TableFormat.ICEBERG); }
createConversionTargetForName(String tableFormatName) { ServiceLoader<ConversionTarget> loader = ServiceLoader.load(ConversionTarget.class); for (ConversionTarget target : loader) { if (target.getTableFormat().equalsIgnoreCase(tableFormatName)) { return target; } } throw new NotSupportedException("Target format is not yet supported: " + tableFormatName); }
[*] target: assertNotNull(tc)
[-] pred: org. junit. Assert. assertNotNull ( tc )
************************************
************************************
[+] input: testGetNestServiceByIdExistingServiceId() { SpecificationConfig.ServiceConfig result = specificationConfig.getNestServiceById("1"); "<AssertPlaceHolder>"; assertEquals("1", result.getId()); assertEquals("Service 1", result.getName()); }
getNestServiceById(String serviceId) { if (StringUtils.isEmpty(serviceId)) { return serviceConfigs.get(0); } else { Optional<ServiceConfig> serviceConfig = serviceConfigs.stream().filter(service -> service.getId().equals(serviceId)).findFirst(); return serviceConfig.orElse(serviceConfigs.get(0)); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testInvalidCrc() { MemoryRecords records = MemoryRecords.withRecords(RecordBatch.MAGIC_VALUE_V2, 0L, Compression.NONE, TimestampType.CREATE_TIME, new SimpleRecord(1L, "a".getBytes(), "1".getBytes()), new SimpleRecord(2L, "b".getBytes(), "2".getBytes()), new SimpleRecord(3L, "c".getBytes(), "3".getBytes()));  ByteBuffer buffer = records.buffer(); buffer.putInt(DefaultRecordBatch.LAST_OFFSET_DELTA_OFFSET, 23);  DefaultRecordBatch batch = new DefaultRecordBatch(buffer); "<AssertPlaceHolder>"; assertThrows(CorruptRecordException.class, batch::ensureValid); }
isValid() { return sizeInBytes() >= RECORD_BATCH_OVERHEAD && checksum() == computeChecksum(); }
[*] target: assertFalse(batch.isValid())
[-] pred: org. junit. Assert. assertFalse ( batch. isValid() )
************************************
************************************
[+] input: IllegalAccessException { final ActivityOptions activityOptions = ActivityOptions.newBuilder() .setHeartbeatTimeout(Duration.ofSeconds(30)) .setStartToCloseTimeout(Duration.ofSeconds(120)) .setRetryOptions(RetryOptions.newBuilder() .setMaximumAttempts(5) .setInitialInterval(Duration.ofSeconds(30)) .setMaximumInterval(Duration.ofSeconds(600)) .build()) .build();  final BeanIdentifier activityOptionsBeanIdentifier = mock(BeanIdentifier.class); final BeanRegistration activityOptionsBeanRegistration = mock(BeanRegistration.class); when(activityOptionsBeanIdentifier.getName()).thenReturn("activityOptions"); when(activityOptionsBeanRegistration.getIdentifier()).thenReturn(activityOptionsBeanIdentifier); when(activityOptionsBeanRegistration.getBean()).thenReturn(activityOptions);  final TemporalProxyHelper temporalProxyHelper = new TemporalProxyHelper(List.of(activityOptionsBeanRegistration)); temporalProxyHelper.setActivityStubGenerator((c, a) -> mock(c));  final Class<ValidTestWorkflowImpl> proxy = temporalProxyHelper.proxyWorkflowClass(ValidTestWorkflowImpl.class);  "<AssertPlaceHolder>";  final ValidTestWorkflowImpl proxyImplementation = proxy.getDeclaredConstructor().newInstance(); proxyImplementation.run(); Assertions.assertTrue(proxyImplementation.isHasRun()); }
proxyWorkflowClass(final Class<T> workflowImplClass) { log.debug("Creating a Temporal proxy for worker class '{}' with interface '{}'...", workflowImplClass.getName(), workflowImplClass.getInterfaces()[0]); return (Class<T>) WORKFLOW_PROXY_CACHE.findOrInsert(workflowImplClass.getClassLoader(), workflowImplClass, () -> { final Set<Method> workflowMethods = findAnnotatedMethods(workflowImplClass, WorkflowMethod.class); final Set<Method> signalMethods = findAnnotatedMethods(workflowImplClass, SignalMethod.class); final Set<Method> queryMethods = findAnnotatedMethods(workflowImplClass, QueryMethod.class);  final Set<Method> proxiedMethods = new HashSet<>(); proxiedMethods.add((Method) workflowMethods.toArray()[0]); proxiedMethods.addAll(signalMethods.stream().collect(Collectors.toList())); proxiedMethods.addAll(queryMethods.stream().collect(Collectors.toList()));  final Class<T> type = (Class<T>) new ByteBuddy() .subclass(workflowImplClass) .name(workflowImplClass.getSimpleName() + "Proxy") .implement(workflowImplClass.getInterfaces()[0]) .method(ElementMatchers.anyOf(proxiedMethods.toArray(new Method[] {}))) .intercept( MethodDelegation.to(generateInterceptor(workflowImplClass, availableActivityOptions))) .make() .load(workflowImplClass.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER) .getLoaded();  log.debug("Temporal workflow proxy '{}' created for worker class '{}' with interface '{}'.", type.getName(), workflowImplClass.getName(), workflowImplClass.getInterfaces()[0]); return type; }); }
[*] target: assertNotNull(proxy)
[-] pred: org. junit. Assert. assertNotNull ( proxy )
************************************
************************************
[+] input: shouldPublishMessagesOnlyAfterCommitIfTransactionsAreEnabled() { buildMockProducer(true); producer.initTransactions(); producer.beginTransaction();  producer.send(record1); producer.send(record2);  assertTrue(producer.history().isEmpty());  producer.commitTransaction();  List<ProducerRecord<byte[], byte[]>> expectedResult = new ArrayList<>(); expectedResult.add(record1); expectedResult.add(record2);  "<AssertPlaceHolder>"; }
history() { return new ArrayList<>(this.sent); }
[*] target: assertEquals(expectedResult, producer.history())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, producer. history() )
************************************
************************************
[+] input: Exception { GetTelemetrySubscriptionsRequest subscriptionsRequest = new GetTelemetrySubscriptionsRequest.Builder( new GetTelemetrySubscriptionsRequestData(), true).build();  GetTelemetrySubscriptionsResponse subscriptionsResponse = clientMetricsManager.processGetTelemetrySubscriptionRequest( subscriptionsRequest, ClientMetricsTestUtils.requestContext());  PushTelemetryRequest request = new PushTelemetryRequest.Builder( new PushTelemetryRequestData() .setClientInstanceId(subscriptionsResponse.data().clientInstanceId()) .setSubscriptionId(subscriptionsResponse.data().subscriptionId()) .setMetrics("test-data".getBytes(StandardCharsets.UTF_8)), true).build();  PushTelemetryResponse response = clientMetricsManager.processPushTelemetryRequest( request, ClientMetricsTestUtils.requestContext()); // Immediate push request should succeed. assertEquals(Errors.NONE, response.error());  response = clientMetricsManager.processPushTelemetryRequest( request, ClientMetricsTestUtils.requestContext()); // Second push request should fail with throttle error. assertEquals(Errors.THROTTLING_QUOTA_EXCEEDED, response.error());  ClientMetricsInstance instance = clientMetricsManager.clientInstance(subscriptionsResponse.data().clientInstanceId()); "<AssertPlaceHolder>"; assertFalse(instance.terminating()); assertEquals(Errors.THROTTLING_QUOTA_EXCEEDED, instance.lastKnownError()); // Should have 1 throttle error metrics. assertEquals((double) 1, getMetric(ClientMetricsManager.ClientMetricsStats.THROTTLE + "-count").metricValue()); assertTrue((double) getMetric(ClientMetricsManager.ClientMetricsStats.THROTTLE + "-rate").metricValue() > 0); // Should have 1 successful export metrics as well. assertEquals((double) 1, getMetric(ClientMetricsManager.ClientMetricsStats.PLUGIN_EXPORT + "-count").metricValue()); assertEquals((double) 0, getMetric(ClientMetricsManager.ClientMetricsStats.PLUGIN_ERROR + "-count").metricValue()); assertNotEquals(Double.NaN, getMetric(ClientMetricsManager.ClientMetricsStats.PLUGIN_EXPORT_TIME + "-avg").metricValue()); assertNotEquals(Double.NaN, getMetric(ClientMetricsManager.ClientMetricsStats.PLUGIN_EXPORT_TIME + "-max").metricValue()); }
clientInstance(Uuid clientInstanceId) { return clientInstanceCache.get(clientInstanceId); }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/getNotificationHistoryResponse.json", request -> { Assertions.assertEquals("POST", request.method()); Assertions.assertEquals("/inApps/v1/notifications/history", request.url().encodedPath()); Assertions.assertEquals("a036bc0e-52b8-4bee-82fc-8c24cb6715d6", request.url().queryParameter("paginationToken")); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(expectedMediaType, body.contentType()); Buffer buffer = new Buffer(); try { body.writeTo(buffer); } catch (IOException e) { throw new RuntimeException(e); } Map<String, Object> root; try { root = new ObjectMapper().readValue(buffer.readUtf8(), Map.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } Assertions.assertEquals(1698148900000L, ((Number) root.get("startDate")).longValue()); Assertions.assertEquals(1698148950000L, ((Number) root.get("endDate")).longValue()); Assertions.assertEquals("SUBSCRIBED", root.get("notificationType")); Assertions.assertEquals("INITIAL_BUY", root.get("notificationSubtype")); Assertions.assertEquals("999733843", root.get("transactionId")); Assertions.assertTrue((Boolean) root.get("onlyFailures")); });  NotificationHistoryRequest notificationHistoryRequest = new NotificationHistoryRequest() .startDate(1698148900000L) .endDate(1698148950000L) .notificationType(NotificationTypeV2.SUBSCRIBED) .notificationSubtype(Subtype.INITIAL_BUY) .transactionId("999733843") .onlyFailures(true);  NotificationHistoryResponse notificationHistoryResponse = client.getNotificationHistory("a036bc0e-52b8-4bee-82fc-8c24cb6715d6", notificationHistoryRequest);  Assertions.assertNotNull(notificationHistoryResponse); Assertions.assertEquals("57715481-805a-4283-8499-1c19b5d6b20a", notificationHistoryResponse.getPaginationToken()); Assertions.assertTrue(notificationHistoryResponse.getHasMore()); List<NotificationHistoryResponseItem> expectedNotificationHistory = List.of( new NotificationHistoryResponseItem() .sendAttempts(List.of( new SendAttemptItem() .attemptDate(1698148900000L) .sendAttemptResult(SendAttemptResult.NO_RESPONSE), new SendAttemptItem() .attemptDate(1698148950000L) .sendAttemptResult(SendAttemptResult.SUCCESS) )) .signedPayload("signed_payload_one"), new NotificationHistoryResponseItem() .sendAttempts(List.of( new SendAttemptItem() .attemptDate(1698148800000L) .sendAttemptResult(SendAttemptResult.CIRCULAR_REDIRECT) )) .signedPayload("signed_payload_two") ); Assertions.assertEquals(expectedNotificationHistory, notificationHistoryResponse.getNotificationHistory()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred: org. junit. Assert. assertNotNull ( body )
************************************
************************************
[+] input: iteratorInOrder() { var map = new MutableHashedLinkedMap<String, Integer>(); map.put("first", 1); map.put("second", 2); map.put("third", 3);  var itr = map.iterator();  assertEquals("first", itr.next().getKey()); assertEquals("second", itr.next().getKey()); assertEquals("third", itr.next().getKey()); "<AssertPlaceHolder>"; }
hasNext() { return current != null; }
[*] target: assertFalse(itr.hasNext())
[-] pred: org. junit. Assert. assertFalse ( itr. hasNext() )
************************************
************************************
[+] input: testGetCompileDependenciesMaven() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.apache.maven", "maven-core", new VersionNumber(3, 9, 0))); var dependencies = resolver.getDirectDependencies(compile); "<AssertPlaceHolder>"; assertEquals(26, dependencies.size()); assertEquals(""" org.apache.maven:maven-model:3.9.0 org.apache.maven:maven-settings:3.9.0 org.apache.maven:maven-settings-builder:3.9.0 org.apache.maven:maven-builder-support:3.9.0 org.apache.maven:maven-repository-metadata:3.9.0 org.apache.maven:maven-artifact:3.9.0 org.apache.maven:maven-plugin-api:3.9.0 org.apache.maven:maven-model-builder:3.9.0 org.apache.maven:maven-resolver-provider:3.9.0 org.apache.maven.resolver:maven-resolver-impl:1.9.4 org.apache.maven.resolver:maven-resolver-api:1.9.4 org.apache.maven.resolver:maven-resolver-spi:1.9.4 org.apache.maven.resolver:maven-resolver-util:1.9.4 org.apache.maven.shared:maven-shared-utils:3.3.4 org.eclipse.sisu:org.eclipse.sisu.plexus:0.3.5 org.eclipse.sisu:org.eclipse.sisu.inject:0.3.5 com.google.inject:guice:5.1.0 com.google.guava:guava:30.1-jre com.google.guava:failureaccess:1.0.1 javax.inject:javax.inject:1 org.codehaus.plexus:plexus-utils:3.4.2 org.codehaus.plexus:plexus-classworlds:2.6.0 org.codehaus.plexus:plexus-interpolation:1.26 org.codehaus.plexus:plexus-component-annotations:2.1.0 org.apache.commons:commons-lang3:3.8.1 org.slf4j:slf4j-api:1.7.36""", StringUtils.join(dependencies, "\n")); }
getDirectDependencies(Scope... scopes) { var pom_dependencies = getMavenPom(dependency_).getDependencies(scopes); var result = new DependencySet(); for (var dependency : pom_dependencies) { result.add(resolution_.overrideDependency(dependency.convertToDependency())); } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: testCreateProduct() { when(brandRepository.findById(any())).thenReturn(Optional.of(brand1)); when(productRepository.save(any(Product.class))).thenReturn(product1);    // mock the repository call to return the product we have created  ProductRequest productRequest = new ProductRequest(product1.getName(), "Description", "Image", product1.getPrice(), "Category", brand1.getName(), "", 10); ResponseEntity<ProductResponse> response = productService.createProduct(productRequest, 1L);  "<AssertPlaceHolder>"; assertEquals(product1.getName(), response.getBody().name()); assertEquals(product1.getPrice(), response.getBody().price()); assertEquals(product1.getStock(), response.getBody().stock()); assertEquals(product1.getBrand().getName(), response.getBody().brandName()); }
createProduct(ProductRequest productRequest, Long storeId) { // create brand if not found Brand brand = brandRepository.findByName(productRequest.brandName()) .orElseGet(() -> { Brand newBrand = Brand.builder() .name(productRequest.brandName()) .image(productRequest.brandImage().getBytes()) .build();  brandRepository.save(newBrand);  return newBrand; });  Product product = Product.builder() .storeId(storeId) .name(productRequest.name()) .description(productRequest.description()) .image(productRequest.image().getBytes()) .price(productRequest.price()) .category(productRequest.category()) .brand(brandRepository.findById(brand.getId()) .orElseThrow(() -> new RuntimeException("Brand not found"))) .stock(productRequest.stock()) .created(Instant.now()) .build();  productRepository.save(product);  return new ResponseEntity<>(mapProductToResponse(product), HttpStatus.CREATED); }
[*] target: assertEquals(HttpStatus.CREATED, response.getStatusCode())
[-] pred: org. junit. Assert. assertEquals ( HttpStatus.CREATED, response. getStatusCode ( ) )
************************************
************************************
[+] input: givenIncorrectValueLengthSegment_whenCheckingSegmentValid_thenIsSegmentValidReturnsFalse() { // Given byte[] testData = new byte[]{ (byte) -43, (byte) -70, 0x00, 0x05,         // Key Size 0x00, 0x00, 0x00, 0x06, // Value Size (Incorrect) 0x48, 0x65, 0x6C, 0x6C, 0x6F, // Key: "Hello" 0x57, 0x6F, 0x72, 0x6C, 0x64  // Value: "World" };  // When Segment corruptedSegment = Segment.fromByteArray(testData);  // Then assertTrue(corruptedSegment.isChecksumValid()); "<AssertPlaceHolder>"; }
isSegmentValid() { return isChecksumValid() && getKeySize() > 0 && getValueSize() >= 0 && bytes.length == CRC_LENGTH + KEY_SIZE_LENGTH + VALUE_SIZE_LENGTH + getKeySize() + getValueSize(); }
[*] target: assertFalse(corruptedSegment.isSegmentValid())
[-] pred: org. junit. Assert. assertFalse ( corruptedSegment. isSegmentValid ( ) )
************************************
************************************
[+] input: testUnsupportedOperation() { Response response = Utils.unsupportedOperation("Unsupported operation"); "<AssertPlaceHolder>"; assertEquals(Response.Status.METHOD_NOT_ALLOWED.getStatusCode(), response.getStatus()); assertEquals(MediaType.APPLICATION_JSON, response.getMediaType().toString()); ErrorResponse errorResponse = (ErrorResponse) response.getEntity(); assertEquals("Unsupported operation", errorResponse.getMessage()); }
unsupportedOperation(String message) { return unsupportedOperation(message, null); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: convertFeatureTypingTest() { ASTTransformer transformer = new ASTTransformer();  Resource testResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertFeatureTypingTest/model.ast.json").readAllBytes()); testResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) testResource.getContents().get(0); Package packageObject = (Package) namespace.getMember().get(0);  EObject attributeDefinition = packageObject.getMember().get(0); assertInstanceOf(AttributeDefinition.class, attributeDefinition); AttributeDefinition typedAttributeDefinition = (AttributeDefinition) attributeDefinition; assertEquals("attributeDefinition", typedAttributeDefinition.getDeclaredName()); assertEquals("package::attributeDefinition", typedAttributeDefinition.getQualifiedName());  EObject portDefinition = packageObject.getMember().get(1); assertInstanceOf(PortDefinition.class, portDefinition); PortDefinition typedPortDefinition = (PortDefinition) portDefinition; assertEquals("portDefinition", typedPortDefinition.getDeclaredName());  assertEquals(1, typedPortDefinition.getMember().size()); EObject referenceUsage = typedPortDefinition.getMember().get(0); assertInstanceOf(ReferenceUsage.class, referenceUsage); ReferenceUsage typedReferenceUsage = (ReferenceUsage) referenceUsage; assertEquals("referenceUsage", typedReferenceUsage.getDeclaredName());  assertEquals(1, typedReferenceUsage.getOwnedTyping().size()); FeatureTyping featureTyping = typedReferenceUsage.getOwnedTyping().get(0);  assertEquals(typedReferenceUsage, featureTyping.getTypedFeature()); assertEquals(typedAttributeDefinition, featureTyping.getType());  assertEquals(1, typedReferenceUsage.getOwnedRelationship().size()); assertEquals(1, typedReferenceUsage.getOwnedSpecialization().size()); Specialization specialisation = typedReferenceUsage.getOwnedSpecialization().get(0); assertEquals(typedAttributeDefinition, specialisation.getGeneral()); }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(testResource)
[-] pred: org. junit. Assert. assertNotNull ( testResource )
************************************
************************************
[+] input: testReplaceAtJsonNodeLoudMultipleReplace() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE); ((ArrayNode) expected.get(ONE)).set(0, REPLACEMENT_JSON); ((ArrayNode) expected.get(ONE)).set(1, REPLACEMENT_JSON); ((ArrayNode) expected.get(ONE)).set(2, REPLACEMENT_JSON);  final JsonNode actual = JsonPaths.replaceAtJsonNodeLoud(JSON_NODE, LIST_ALL_QUERY, REPLACEMENT_JSON); "<AssertPlaceHolder>"; }); }
replaceAtJsonNodeLoud(final JsonNode json, final String jsonPath, final JsonNode replacement) { assertIsJsonPath(jsonPath); return JsonPath.parse(Jsons.clone(json)).set(jsonPath, replacement).json(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { String mechanism = OAuthBearerLoginModule.OAUTHBEARER_MECHANISM; Duration tokenExpirationDuration = Duration.ofSeconds(1); SaslServer saslServer = mock(SaslServer.class);  MockTime time = new MockTime(); try ( MockedStatic<?> ignored = mockSaslServer(saslServer, mechanism, time, tokenExpirationDuration); MockedStatic<?> ignored2 = mockKafkaPrincipal("[principal-type]", "[principal-name"); TransportLayer transportLayer = mockTransportLayer() ) {  SaslServerAuthenticator authenticator = getSaslServerAuthenticatorForOAuth(mechanism, transportLayer, time, 0L);  mockRequest(saslHandshakeRequest(mechanism), transportLayer); authenticator.authenticate();  when(saslServer.isComplete()).thenReturn(false).thenReturn(true); mockRequest(saslAuthenticateRequest(), transportLayer); authenticator.authenticate();  long atTokenExpiryNanos = time.nanoseconds() + tokenExpirationDuration.toNanos(); "<AssertPlaceHolder>";  ByteBuffer secondResponseSent = getResponses(transportLayer).get(1); consumeSizeAndHeader(secondResponseSent); SaslAuthenticateResponse response = SaslAuthenticateResponse.parse(secondResponseSent, (short) 2); assertEquals(tokenExpirationDuration.toMillis(), response.sessionLifetimeMs()); } }
serverSessionExpirationTimeNanos() { return reauthInfo.sessionExpirationTimeNanos; }
[*] target: assertEquals(atTokenExpiryNanos, authenticator.serverSessionExpirationTimeNanos())
[-] pred: org. junit. Assert. assertEquals ( atTokenExpiryNanos, authenticator. serverSessionExpirationTimeNanos ( ) )
************************************
************************************
[+] input: getAllTags_ShouldReturnAllTags() { // given Tag tag1 = new Tag("tag1"); Tag tag2 = new Tag("tag2"); List<Tag> tags = Arrays.asList(tag1, tag2);  when(tagRepository.findAll()).thenReturn(tags);  // when List<Tag> returnedTags = sut.getAllTags();  // then "<AssertPlaceHolder>"; assertEquals(2, returnedTags.size()); assertTrue(returnedTags.contains(tag1) && returnedTags.contains(tag2)); }
getAllTags() { // Note: If there are too many tags, recommend apply cursor based pagination. return tagRepository.findAll(); }
[*] target: assertNotNull(returnedTags)
[-] pred: org. junit. Assert. assertNotNull ( returnedTags )
************************************
************************************
[+] input: testBuildSentryExceptionsJava() { final String stacktrace = """ java.lang.ArithmeticException: / by zero at io.airbyte.integrations.base.AirbyteTraceMessageUtilityTest.testCorrectStacktraceFormat(AirbyteTraceMessageUtilityTest.java:61) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) at app//org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at jdk.proxy2/jdk.proxy2.$Proxy5.stop(Unknown Source) at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74) """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.JAVA, parsedException.platform()); Assertions.assertEquals(1, exceptionList.size());  assertExceptionContent(exceptionList.get(0), "java.lang.ArithmeticException", "/ by zero", List.of( Map.of( FILENAME, "GradleWorkerMain.java", LINE_NO, 74, MODULE, "worker.org.gradle.process.internal.worker.GradleWorkerMain", FUNCTION, "main"), Map.of( MODULE, "jdk.proxy2.$Proxy5", FUNCTION, "stop"), Map.of( FILENAME, "ThrowableCollector.java", LINE_NO, 73, MODULE, "org.junit.platform.engine.support.hierarchical.ThrowableCollector", FUNCTION, "execute"), Map.of( FILENAME, "NodeTestTask.java", LINE_NO, 141, MODULE, "org.junit.platform.engine.support.hierarchical.NodeTestTask", FUNCTION, "lambda$executeRecursively$8"), Map.of( FILENAME, "ExecutableInvoker.java", LINE_NO, 115, MODULE, "org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall", FUNCTION, "lambda$ofVoidMethod$0"), Map.of( "isNative", true, MODULE, "jdk.internal.reflect.NativeMethodAccessorImpl", FUNCTION, "invoke0"), Map.of( FILENAME, "AirbyteTraceMessageUtilityTest.java", LINE_NO, 61, MODULE, "io.airbyte.integrations.base.AirbyteTraceMessageUtilityTest", FUNCTION, "testCorrectStacktraceFormat"))); }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred: org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )
************************************
************************************
[+] input: twoArgsConstructor() { String imageUrl = "http://example.com/image.jpg"; String linkUrl = "http://example.com/link"; ImageQuickLink imageQuickLink = new ImageQuickLink(imageUrl, linkUrl); "<AssertPlaceHolder>"; assertEquals(linkUrl, imageQuickLink.getLinkUrl()); }
getImageUrl() { return imageUrl; }
[*] target: assertEquals(imageUrl, imageQuickLink.getImageUrl())
[-] pred: org. junit. Assert. assertEquals ( imageUrl, imageQuickLink. getImageUrl() )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/lookupOrderIdResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v1/lookup/W002182", request.url().encodedPath()); Assertions."<AssertPlaceHolder>"; });  OrderLookupResponse orderLookupResponse = client.lookUpOrderId("W002182");  Assertions.assertNotNull(orderLookupResponse); Assertions.assertEquals(OrderLookupStatus.INVALID, orderLookupResponse.getStatus()); Assertions.assertEquals(1, orderLookupResponse.getRawStatus()); Assertions.assertEquals(List.of("signed_transaction_one", "signed_transaction_two"), orderLookupResponse.getSignedTransactions()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred: org. junit. Assert. assertNull ( request. body() )
************************************
************************************
[+] input: Exception { doInitTransactions();  transactionManager.beginTransaction(); transactionManager.maybeAddPartition(tp0);  Future<RecordMetadata> responseFuture = appendToAccumulator(tp0);  prepareAddPartitionsToTxn(tp0, Errors.NONE); runUntil(() -> !transactionManager.hasPartitionsToAdd()); assertTrue(accumulator.hasUndrained());  accumulator.beginFlush(); runUntil(() -> !accumulator.hasUndrained()); assertFalse(accumulator.hasUndrained()); assertTrue(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest());  // now we begin the commit with the produce request still pending transactionManager.beginCommit(); AtomicInteger numRuns = new AtomicInteger(0); runUntil(() -> numRuns.incrementAndGet() >= 4); assertFalse(accumulator.hasUndrained()); assertTrue(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest()); assertFalse(responseFuture.isDone());  // now the produce response returns sendProduceResponse(Errors.NONE, producerId, epoch); runUntil(responseFuture::isDone); assertFalse(accumulator.hasUndrained()); assertFalse(accumulator.hasIncomplete()); assertFalse(transactionManager.hasInFlightRequest());  // now we send EndTxn runUntil(transactionManager::hasInFlightRequest); sendEndTxnResponse(Errors.NONE, TransactionResult.COMMIT, producerId, epoch); runUntil(transactionManager::isReady); "<AssertPlaceHolder>"; }
hasInFlightRequest() { return inFlightRequestCorrelationId != NO_INFLIGHT_REQUEST_CORRELATION_ID; }
[*] target: assertFalse(transactionManager.hasInFlightRequest())
[-] pred: org. junit. Assert. assertFalse ( transactionManager. hasInFlightRequest ( ) )
************************************
************************************
[+] input: 검색된_회원의_팔로우_상태를_확인할_수_있다() { // given String searchNickname = "잘생긴"; Member currentMember = memberRepository.save( Member.createNormalMember(Profile.createProfile("도모", "도모 이미지 URL"))); Member searchMember1 = memberRepository.save( Member.createNormalMember( Profile.createProfile("잘생긴 윤범", "윤범 이미지 URL"))); Member searchMember2 = memberRepository.save( Member.createNormalMember( Profile.createProfile("잘생긴 재현", "재현 이미지 URL"))); Member searchMember3 = memberRepository.save( Member.createNormalMember( Profile.createProfile("잘생긴 우병", "우병 이미지 URL")));  // 도모가 윤범이만 팔로우 memberRelationRepository.save( MemberRelation.createMemberRelation(currentMember, searchMember1));  // 재현이가 도모만 팔로우 memberRelationRepository.save( MemberRelation.createMemberRelation(searchMember2, currentMember));  // when List<MemberSearchResponse> responses = memberService.searchMemberNickname(searchNickname);  // then "<AssertPlaceHolder>";  // 도모와 우병은 팔로우관계가 아니다. assertEquals(FollowStatus.NOT_FOLLOWING, responses.get(0).followStatus());  // 도모만 윤범이를 팔로우하고있다. assertEquals(FollowStatus.FOLLOWING, responses.get(1).followStatus());  // 재현이만 도모를 팔로우하고있다. assertEquals(FollowStatus.FOLLOWED_BY_ME, responses.get(2).followStatus()); }
searchMemberNickname(String nickname) { final Member currentMember = memberUtil.getCurrentMember(); final String escapingNickname = escapeSpecialCharacters(nickname); if (escapingNickname.isBlank()) { return List.of(); }  List<Member> members = memberRepository.nicknameSearch( escapingNickname, currentMember.getProfile().getNickname()); List<MemberRelation> memberRelationBySourceId = memberRelationRepository.findAllBySourceIdAndTargetIn( currentMember.getId(), members); List<MemberRelation> memberRelationByTargetId = memberRelationRepository.findAllByTargetId(currentMember.getId());  List<MemberSearchResponse> response = new ArrayList<>(); for (Member member : members) { boolean existRelation = false; for (MemberRelation memberRelation : memberRelationBySourceId) { if (member.getId().equals(memberRelation.getTarget().getId())) { existRelation = true; break; } }  if (existRelation) { // 닉네임 검색한 애들 중 내가 팔로우한 애라면 response.add(MemberSearchResponse.toFollowingResponse(member)); continue; }  // 내가 팔로우를 하지 않았을 때 Optional<MemberRelation> optionalMemberRelation = memberRelationByTargetId.stream() .filter( memberRelation -> member.getId() .equals(memberRelation.getSource().getId())) .findFirst(); if (optionalMemberRelation.isPresent()) { // 상대방만 나를 팔로우 하고 있을  때 response.add(MemberSearchResponse.toFollowedByMeResponse(member)); continue; }  // 아니라면 서로 팔로우가 아닌 상태 response.add(MemberSearchResponse.toNotFollowingResponse(member)); } response = response.stream() .sorted(Comparator.comparing(MemberSearchResponse::nickname)) .sorted( Comparator.comparing( MemberSearchResponse -> MemberSearchResponse.nickname().equals(nickname) ? 0 : 1)) .collect(Collectors.toList()); return response; }
[*] target: assertEquals(3, responses.size())
[-] pred: org. junit. Assert. assertEquals ( 3, responses. size ( ) )
************************************
************************************
[+] input: convertConjugatedPortTest() { ASTTransformer transformer = new ASTTransformer();  Resource testResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertConjugatedPortTest/model.ast.json").readAllBytes()); testResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) testResource.getContents().get(0); Package packageObject = (Package) namespace.getMember().get(0);  AttributeDefinition tempAttributeDefinition = (AttributeDefinition) packageObject.getMember().get(0); assertEquals("Temp", tempAttributeDefinition.getName());  PortDefinition tempPortPortDefinition = (PortDefinition) packageObject.getMember().get(1); assertEquals("TempPort", tempPortPortDefinition.getName()); AttributeUsage temperatureAttributeUsage = tempPortPortDefinition.getOwnedAttribute().get(0); assertEquals("temperature", temperatureAttributeUsage.getName()); assertEquals(tempAttributeDefinition, temperatureAttributeUsage.getOwnedSpecialization().get(0).getGeneral());  PartDefinition tempPortClassicPartDefinition = (PartDefinition) packageObject.getMember().get(2); assertEquals("TempPortClassic", tempPortClassicPartDefinition.getName()); PortUsage tempPortClassicPortUsage = tempPortClassicPartDefinition.getOwnedPort().get(0); assertEquals("tempPortClassic", tempPortClassicPortUsage.getName()); assertEquals(tempPortPortDefinition, tempPortClassicPortUsage.getOwnedSpecialization().get(0).getGeneral());  PartDefinition tempPortConjPartDefinition = (PartDefinition) packageObject.getMember().get(3); assertEquals("TempPortConj", tempPortConjPartDefinition.getName()); PortUsage tempPortConjPortUsage = tempPortConjPartDefinition.getOwnedPort().get(0); assertEquals("tempPortConj", tempPortConjPortUsage.getName());  assertEquals(1, tempPortConjPortUsage.getOwnedTyping().size()); }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(testResource)
[-] pred: org. junit. Assert. assertNotNull ( testResource )
************************************
************************************
[+] input: shouldBuildWithAllParameters() { var fileId = "file-123";  var request = builder .fileId(fileId) .build();  "<AssertPlaceHolder>"; assertEquals(fileId, request.fileId()); }
build() { validateRequiredFields();  return new CreateAssistantFileRequest( this.fileId ); }
[*] target: assertNotNull(request)
[-] pred: org. junit. Assert. assertNotNull ( request )
************************************
************************************
[+] input: testJoinPrepareWithDisableAutoCommit() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, false, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);  int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId);  "<AssertPlaceHolder>"; assertTrue(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
onJoinPrepare(Timer timer, int generation, String memberId) { log.debug("Executing onJoinPrepare with generation {} and memberId {}", generation, memberId); if (joinPrepareTimer == null) { // We should complete onJoinPrepare before rebalanceTimeoutMs, // and continue to join group to avoid member got kicked out from group joinPrepareTimer = time.timer(rebalanceConfig.rebalanceTimeoutMs); } else { joinPrepareTimer.update(); }  // async commit offsets prior to rebalance if auto-commit enabled // and there is no in-flight offset commit request if (autoCommitEnabled && autoCommitOffsetRequestFuture == null) { maybeMarkPartitionsPendingRevocation(); autoCommitOffsetRequestFuture = maybeAutoCommitOffsetsAsync(); }  // wait for commit offset response before timer expired if (autoCommitOffsetRequestFuture != null) { Timer pollTimer = timer.remainingMs() < joinPrepareTimer.remainingMs() ? timer : joinPrepareTimer; client.poll(autoCommitOffsetRequestFuture, pollTimer); joinPrepareTimer.update();  // Keep retrying/waiting the offset commit when: // 1. offset commit haven't done (and joinPrepareTimer not expired) // 2. failed with retriable exception (and joinPrepareTimer not expired) // Otherwise, continue to revoke partitions, ex: // 1. if joinPrepareTimer has expired // 2. if offset commit failed with non-retriable exception // 3. if offset commit success boolean onJoinPrepareAsyncCommitCompleted = true; if (joinPrepareTimer.isExpired()) { log.error("Asynchronous auto-commit of offsets failed: joinPrepare timeout. Will continue to join group"); } else if (!autoCommitOffsetRequestFuture.isDone()) { onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && autoCommitOffsetRequestFuture.isRetriable()) { log.debug("Asynchronous auto-commit of offsets failed with retryable error: {}. Will retry it.", autoCommitOffsetRequestFuture.exception().getMessage()); onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && !autoCommitOffsetRequestFuture.isRetriable()) { log.error("Asynchronous auto-commit of offsets failed: {}. Will continue to join group.", autoCommitOffsetRequestFuture.exception().getMessage()); } if (autoCommitOffsetRequestFuture.isDone()) { autoCommitOffsetRequestFuture = null; } if (!onJoinPrepareAsyncCommitCompleted) { pollTimer.sleep(Math.min(pollTimer.remainingMs(), rebalanceConfig.retryBackoffMs)); timer.update(); return false; } }  // the generation / member-id can possibly be reset by the heartbeat thread // upon getting errors or heartbeat timeouts; in this case whatever is previously // owned partitions would be lost, we should trigger the callback and cleanup the assignment; // otherwise we can proceed normally and revoke the partitions depending on the protocol, // and in that case we should only change the assignment AFTER the revoke callback is triggered // so that users can still access the previously owned partitions to commit offsets etc. Exception exception = null; final SortedSet<TopicPartition> revokedPartitions = new TreeSet<>(COMPARATOR); if (generation == Generation.NO_GENERATION.generationId || memberId.equals(Generation.NO_GENERATION.memberId)) { revokedPartitions.addAll(subscriptions.assignedPartitions());  if (!revokedPartitions.isEmpty()) { log.info("Giving away all assigned partitions as lost since generation/memberID has been reset," + "indicating that consumer is in old state or no longer part of the group"); exception = rebalanceListenerInvoker.invokePartitionsLost(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet()); } } else { switch (protocol) { case EAGER: // revoke all partitions revokedPartitions.addAll(subscriptions.assignedPartitions()); exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet());  break;  case COOPERATIVE: // only revoke those partitions that are not in the subscription anymore. Set<TopicPartition> ownedPartitions = new HashSet<>(subscriptions.assignedPartitions()); revokedPartitions.addAll(ownedPartitions.stream() .filter(tp -> !subscriptions.subscription().contains(tp.topic())) .collect(Collectors.toSet()));  if (!revokedPartitions.isEmpty()) { exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  ownedPartitions.removeAll(revokedPartitions); subscriptions.assignFromSubscribed(ownedPartitions); }  break; } }  isLeader = false; subscriptions.resetGroupSubscription(); joinPrepareTimer = null; autoCommitOffsetRequestFuture = null; timer.update();  if (exception != null) { throw new KafkaException("User rebalance callback throws an error", exception); } return true; }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: Exception { try (InputStream key = this.getClass().getClassLoader().getResourceAsStream("certs/testSigningKey.p8")) { Assertions.assertNotNull(key); var tokenGenerator = new BearerTokenAuthenticator(new String(key.readAllBytes()), "keyId", "issuerId", "bundleId"); String token = tokenGenerator.generateToken(); Assertions."<AssertPlaceHolder>"; } }
generateToken() { return JWT.create() .withAudience(APP_STORE_CONNECT_AUDIENCE) .withExpiresAt(Instant.now().plus(ChronoUnit.MINUTES.getDuration().multipliedBy(5))) .withIssuer(issuerId) .withKeyId(keyId) .withPayload(Map.of(BUNDLE_ID_KEY, bundleId)) .sign(Algorithm.ECDSA256(signingKey)); }
[*] target: assertNotNull(token)
[-] pred: org. junit. Assert. assertNotNull ( token )
************************************
************************************
[+] input: testJoinPrepareAndCommitWithCoordinatorNotAvailable() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.COORDINATOR_NOT_AVAILABLE);  int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId); coordinator.invokeCompletedOffsetCommitCallbacks();  "<AssertPlaceHolder>"; assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertTrue(coordinator.coordinatorUnknown()); } }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertFalse(res)
[-] pred: org. junit. Assert. assertFalse ( res )
************************************
************************************
[+] input: testBoasToWebResponse() { try { ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write("Sample PDF content".getBytes()); String docName = "sample.pdf";  ResponseEntity<byte[]> responseEntity = WebResponseUtils.boasToWebResponse(baos, docName);  "<AssertPlaceHolder>"; assertEquals(HttpStatus.OK, responseEntity.getStatusCode()); assertNotNull(responseEntity.getBody());  HttpHeaders headers = responseEntity.getHeaders(); assertNotNull(headers); assertEquals(MediaType.APPLICATION_PDF, headers.getContentType()); assertNotNull(headers.getContentDisposition()); //assertEquals("attachment; filename="sample.pdf"", headers.getContentDisposition().toString());  } catch (IOException e) { fail("Exception thrown: " + e.getMessage()); } }
boasToWebResponse( ByteArrayOutputStream baos, String docName) throws IOException { return WebResponseUtils.bytesToWebResponse(baos.toByteArray(), docName); }
[*] target: assertNotNull(responseEntity)
[-] pred: org. junit. Assert. assertNotNull ( responseEntity )
************************************
************************************
[+] input: testCommitAfterLeaveGroup() { // enable auto-assignment subscriptions.subscribe(singleton(topic1), Optional.of(rebalanceListener));  joinAsFollowerAndReceiveAssignment(coordinator, singletonList(t1p));  // now switch to manual assignment client.prepareResponse(new LeaveGroupResponse(new LeaveGroupResponseData() .setErrorCode(Errors.NONE.code()))); subscriptions.unsubscribe(); coordinator.maybeLeaveGroup("test commit after leave"); subscriptions.assignFromUser(singleton(t1p));  // the client should not reuse generation/memberId from auto-subscribed generation client.prepareResponse(body -> { OffsetCommitRequest commitRequest = (OffsetCommitRequest) body; return commitRequest.data().memberId().equals(OffsetCommitRequest.DEFAULT_MEMBER_ID) && commitRequest.data().generationIdOrMemberEpoch() == OffsetCommitRequest.DEFAULT_GENERATION_ID; }, offsetCommitResponse(singletonMap(t1p, Errors.NONE)));  AtomicBoolean success = new AtomicBoolean(false); coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success)); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; assertEquals(coordinator.inFlightAsyncCommits.get(), 0); }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertTrue(success.get())
[-] pred: org. junit. Assert. assertTrue ( success. get ( ) )
************************************
************************************
[+] input: testInstantiation() { var builder = new MetadataBuilder(); assertNull(builder.info()); "<AssertPlaceHolder>"; }
updated() { return timestamp_; }
[*] target: assertNull(builder.updated())
[-] pred: org. junit. Assert. assertNull ( builder. updated() )
************************************
************************************
[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }));  final ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred: org. junit. Assert. assertNotNull ( frame )
************************************
************************************
[+] input: testNullableMetadataV0ToV7() { PartitionData pd = new PartitionData( offset, leaderEpochOne, null, Errors.UNKNOWN_TOPIC_OR_PARTITION); // test PartitionData.equals with null metadata assertEquals(pd, pd); partitionDataMap.clear(); partitionDataMap.put(new TopicPartition(topicOne, partitionOne), pd);  OffsetFetchResponse response = new OffsetFetchResponse(throttleTimeMs, Errors.GROUP_AUTHORIZATION_FAILED, partitionDataMap); OffsetFetchResponseData expectedData = new OffsetFetchResponseData() .setErrorCode(Errors.GROUP_AUTHORIZATION_FAILED.code()) .setThrottleTimeMs(throttleTimeMs) .setTopics(Collections.singletonList( new OffsetFetchResponseTopic() .setName(topicOne) .setPartitions(Collections.singletonList( new OffsetFetchResponsePartition() .setPartitionIndex(partitionOne) .setCommittedOffset(offset) .setCommittedLeaderEpoch(leaderEpochOne.orElse(-1)) .setErrorCode(Errors.UNKNOWN_TOPIC_OR_PARTITION.code()) .setMetadata(null)) )) ); "<AssertPlaceHolder>"; }
data() { return data; }
[*] target: assertEquals(expectedData, response.data())
[-] pred: org. junit. Assert. assertEquals ( expectedData, response. data() )
************************************
************************************
[+] input: builderChangesShouldNotApplyToAlreadyDecoratedExporter() { // given SpanDataModifier builder = SpanDataModifier.builder(delegate); SpanExporter underTest = builder.build();  builder.rejectSpansByName(spanName -> spanName.equals("span")) .rejectSpansByAttributeValue(ATTRIBUTE, value -> true) .removeSpanAttribute(ATTRIBUTE, value -> true) .replaceSpanAttribute(ATTRIBUTE, value -> "abc");  SpanData span = TestSpanHelper.span("span", Attributes.of(ATTRIBUTE, "test"));  CompletableResultCode expectedResult = new CompletableResultCode(); when(delegate.export(spansCaptor.capture())).thenReturn(expectedResult);  // when CompletableResultCode result = underTest.export(singletonList(span));  // then "<AssertPlaceHolder>";  assertThat(spansCaptor.getValue()) .satisfiesExactly( s -> assertThat(s) .hasName(span.getName()) .hasAttributes(span.getAttributes())); }
replaceSpanAttribute( AttributeKey<T> attributeKey, Function<? super T, ? extends T> attributeValueModifier) {  spanAttributeReplacements.compute( attributeKey, (k, oldValue) -> oldValue == null ? attributeValueModifier : ((Function<T, T>) oldValue).andThen(attributeValueModifier)); return this; }
[*] target: assertSame(expectedResult, result)
[-] pred: org. junit. Assert. assertSame ( expectedResult, result )
************************************
************************************
[+] input: givenCorruptedValueSizeSegment_whenCheckingChecksum_thenIsChecksumValidReturnsFalse() { // Given byte[] testData = new byte[]{ (byte) -83, (byte) 64, 0x00, 0x05,         // Key Size 0x00, 0x00, 0x01, 0x05, // Value Size (Bit Flipped) 0x48, 0x65, 0x6C, 0x6C, 0x6F, // Key: "Hello" 0x57, 0x6F, 0x72, 0x6C, 0x64  // Value: "World" };  // When Segment corruptedSegment = Segment.fromByteArray(testData);  // Then assertFalse(corruptedSegment.isChecksumValid()); "<AssertPlaceHolder>"; }
isSegmentValid() { return isChecksumValid() && getKeySize() > 0 && getValueSize() >= 0 && bytes.length == CRC_LENGTH + KEY_SIZE_LENGTH + VALUE_SIZE_LENGTH + getKeySize() + getValueSize(); }
[*] target: assertFalse(corruptedSegment.isSegmentValid())
[-] pred: org. junit. Assert. assertFalse ( corruptedSegment. isSegmentValid ( ) )
************************************
************************************
[+] input: testErrorCountsNoTopLevelError() { for (short version : LEADER_AND_ISR.allVersions()) { LeaderAndIsrResponse response; if (version < 5) { List<LeaderAndIsrPartitionError> partitions = createPartitions("foo", asList(Errors.NONE, Errors.CLUSTER_AUTHORIZATION_FAILED)); response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData() .setErrorCode(Errors.NONE.code()) .setPartitionErrors(partitions), version); } else { Uuid id = Uuid.randomUuid(); LeaderAndIsrTopicErrorCollection topics = createTopic(id, asList(Errors.NONE, Errors.CLUSTER_AUTHORIZATION_FAILED)); response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData() .setErrorCode(Errors.NONE.code()) .setTopics(topics), version); } Map<Errors, Integer> errorCounts = response.errorCounts(); "<AssertPlaceHolder>"; assertEquals(2, errorCounts.get(Errors.NONE).intValue()); assertEquals(1, errorCounts.get(Errors.CLUSTER_AUTHORIZATION_FAILED).intValue()); } }
errorCounts() { Errors error = error(); if (error != Errors.NONE) { // Minor optimization since the top-level error applies to all partitions if (version < 5) return Collections.singletonMap(error, data.partitionErrors().size() + 1); return Collections.singletonMap(error, data.topics().stream().mapToInt(t -> t.partitionErrors().size()).sum() + 1); } Map<Errors, Integer> errors; if (version < 5) errors = errorCounts(data.partitionErrors().stream().map(l -> Errors.forCode(l.errorCode()))); else errors = errorCounts(data.topics().stream().flatMap(t -> t.partitionErrors().stream()).map(l -> Errors.forCode(l.errorCode()))); updateErrorCounts(errors, Errors.NONE); return errors; }
[*] target: assertEquals(2, errorCounts.size())
[-] pred: org. junit. Assert. assertEquals ( 2, errorCounts. size ( ) )
************************************
************************************
[+] input: testShouldRecordForInfoLevelSensor() { Sensor infoSensor = new Sensor(null, "infoSensor", null, INFO_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.INFO); assertTrue(infoSensor.shouldRecord());  infoSensor = new Sensor(null, "infoSensor", null, DEBUG_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.INFO); assertTrue(infoSensor.shouldRecord());  infoSensor = new Sensor(null, "infoSensor", null, TRACE_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.INFO); "<AssertPlaceHolder>"; }
shouldRecord() { return this.recordingLevel.shouldRecord(config.recordLevel().id); }
[*] target: assertTrue(infoSensor.shouldRecord())
[-] pred: org. junit. Assert. assertTrue ( infoSensor. shouldRecord() )
************************************
************************************
[+] input: testExtractClaims_03() { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); Future<ExtractedClaims> future = validator.extractClaims("bearer bad-token"); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.failed()); assertNotNull(res.cause()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: buildUndoSQLByUpperCase() { OracleUndoUpdateExecutor executor = upperCaseSQL();  String sql = executor.buildUndoSQL(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("UPDATE")); Assertions.assertTrue(sql.contains("ID")); Assertions.assertTrue(sql.contains("AGE")); Assertions.assertTrue(sql.contains("TABLE_NAME")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); // TODO } Row row = beforeImageRows.get(0);  List<Field> nonPkFields = row.nonPrimaryKeys(); // update sql undo log before image all field come from table meta. need add escape. // see BaseTransactionalExecutor#buildTableRecords String updateColumns = nonPkFields.stream().map( field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.ORACLE) + " = ?").collect( Collectors.joining(", "));  List<String> pkNameList = getOrderedPkList(beforeImage, row, JdbcConstants.ORACLE).stream().map( e -> e.getName()).collect(Collectors.toList()); String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList, JdbcConstants.ORACLE);  return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(), updateColumns, whereSql); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: testBuildRequestMultipleTopicsWithReadCommitted() { ListOffsetsHandler handler = new ListOffsetsHandler( offsetTimestampsByPartition, new ListOffsetsOptions(IsolationLevel.READ_COMMITTED), logContext); ListOffsetsRequest request = handler.buildBatchedRequest(node.id(), offsetTimestampsByPartition.keySet()).build(); List<ListOffsetsTopic> topics = request.topics(); "<AssertPlaceHolder>"; Map<TopicPartition, ListOffsetsPartition> partitions = new HashMap<>(); for (ListOffsetsTopic topic : topics) { for (ListOffsetsPartition partition : topic.partitions()) { partitions.put(new TopicPartition(topic.name(), partition.partitionIndex()), partition); } } assertEquals(4, partitions.size()); for (Map.Entry<TopicPartition, ListOffsetsPartition> entry : partitions.entrySet()) { assertExpectedTimestamp(entry.getKey(), entry.getValue().timestamp()); } assertEquals(IsolationLevel.READ_COMMITTED, request.isolationLevel()); }
buildBatchedRequest(int brokerId, Set<TopicPartition> keys) { Map<String, ListOffsetsTopic> topicsByName = CollectionUtils.groupPartitionsByTopic( keys, topicName -> new ListOffsetsTopic().setName(topicName), (listOffsetsTopic, partitionId) -> { TopicPartition topicPartition = new TopicPartition(listOffsetsTopic.name(), partitionId); long offsetTimestamp = offsetTimestampsByPartition.get(topicPartition); listOffsetsTopic.partitions().add( new ListOffsetsPartition() .setPartitionIndex(partitionId) .setTimestamp(offsetTimestamp)); }); boolean supportsMaxTimestamp = keys .stream() .anyMatch(key -> offsetTimestampsByPartition.get(key) == ListOffsetsRequest.MAX_TIMESTAMP);  return ListOffsetsRequest.Builder .forConsumer(true, options.isolationLevel(), supportsMaxTimestamp) .setTargetTimes(new ArrayList<>(topicsByName.values())); }
[*] target: assertEquals(2, topics.size())
[-] pred: org. junit. Assert. assertEquals ( 2, topics. size ( ) )
************************************
************************************
[+] input: Exception { final SimpleExampleMessageData message = new SimpleExampleMessageData(); message.setMyStruct(new SimpleExampleMessageData.MyStruct().setStructId(25).setArrayInStruct( Collections.singletonList(new SimpleExampleMessageData.StructArray().setArrayFieldId(20)) )); message.setMyTaggedStruct(new SimpleExampleMessageData.TaggedStruct().setStructId("abc"));  message.setProcessId(Uuid.randomUuid()); message.setMyNullableString("notNull"); message.setMyInt16((short) 3); message.setMyString("test string"); SimpleExampleMessageData duplicate = message.duplicate(); "<AssertPlaceHolder>"; assertEquals(message, duplicate); duplicate.setMyTaggedIntArray(Collections.singletonList(123)); assertNotEquals(duplicate, message); assertNotEquals(message, duplicate);  testAllMessageRoundTripsFromVersion((short) 2, message); }
duplicate();
[*] target: assertEquals(duplicate, message)
[-] pred: org. junit. Assert. assertEquals ( duplicate, message )
************************************
************************************
[+] input: testLongToByte() { long v = 259; byte[] b = ByteUtils.longToByte(v); Assertions.assertArrayEquals(new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03}, b); long v2 = ByteUtils.byteToLong(b); Assertions."<AssertPlaceHolder>"; }
byteToLong(byte[] bytes) { ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES); buffer.order(ByteOrder.BIG_ENDIAN); buffer.put(bytes); buffer.flip(); return buffer.getLong(); }
[*] target: assertEquals(v, v2)
[-] pred: org. junit. Assert. assertEquals ( v, v2 )
************************************
************************************
[+] input: IOException { String mechanism = OAuthBearerLoginModule.OAUTHBEARER_MECHANISM; SaslServer saslServer = mock(SaslServer.class); MockTime time = new MockTime(0, 1, 1000); Duration tokenExpiryShorterThanMaxReauth = Duration.ofSeconds(2); long maxReauthMs = tokenExpiryShorterThanMaxReauth.multipliedBy(2).toMillis();  try ( MockedStatic<?> ignored = mockSaslServer(saslServer, mechanism, time, tokenExpiryShorterThanMaxReauth); MockedStatic<?> ignored2 = mockKafkaPrincipal("[principal-type]", "[principal-name"); TransportLayer transportLayer = mockTransportLayer() ) {  SaslServerAuthenticator authenticator = getSaslServerAuthenticatorForOAuth(mechanism, transportLayer, time, maxReauthMs);  mockRequest(saslHandshakeRequest(mechanism), transportLayer); authenticator.authenticate();  when(saslServer.isComplete()).thenReturn(false).thenReturn(true); mockRequest(saslAuthenticateRequest(), transportLayer); authenticator.authenticate();  long atTokenExpiryNanos = time.nanoseconds() + tokenExpiryShorterThanMaxReauth.toNanos(); "<AssertPlaceHolder>";  ByteBuffer secondResponseSent = getResponses(transportLayer).get(1); consumeSizeAndHeader(secondResponseSent); SaslAuthenticateResponse response = SaslAuthenticateResponse.parse(secondResponseSent, (short) 2); assertEquals(tokenExpiryShorterThanMaxReauth.toMillis(), response.sessionLifetimeMs()); } }
serverSessionExpirationTimeNanos() { return reauthInfo.sessionExpirationTimeNanos; }
[*] target: assertEquals(atTokenExpiryNanos, authenticator.serverSessionExpirationTimeNanos())
[-] pred: org. junit. Assert. assertEquals ( atTokenExpiryNanos, authenticator. serverSessionExpirationTimeNanos ( ) )
************************************
************************************
[+] input: testAStar() { var builder = new BlockNodePoolBuilder(); var nodes = builder.build(10, BlockNode::new); var start = builder.getCenter(); BlockNode goal = null; for (var node : nodes) { node.setToOffsetFromCenter(BlockPos.ZERO); if (node.getCurrent().equals(new BlockPos(3, 2, 2))) { goal = node; } }  assertNotNull(goal); Cancellation cancellation = new Cancellation(); AStar<BlockNode> aStar = new AStar<>(start, goal); var result = aStar.run(cancellation); assertNotNull(result); assertEquals(new BlockNode(new BlockPos(3, 2, 2)), result.getPath().get(0)); assertEquals(new BlockNode(new BlockPos(3, 1, 2)), result.getPath().get(1)); assertEquals(new BlockNode(new BlockPos(3, 1, 1)), result.getPath().get(2)); assertEquals(new BlockNode(new BlockPos(2, 1, 1)), result.getPath().get(3)); assertEquals(new BlockNode(new BlockPos(2, 0, 1)), result.getPath().get(4)); assertEquals(new BlockNode(new BlockPos(2, 0, 0)), result.getPath().get(5)); assertEquals(new BlockNode(new BlockPos(1, 0, 0)), result.getPath().get(6)); assertEquals(new BlockNode(new BlockPos(0, 0, 0)), result.getPath().get(7)); assertFalse(cancellation.isCancelled()); cancellation.setCancelled(true); assertTrue(cancellation.isCancelled()); aStar = new AStar<>(start, goal); result = aStar.run(cancellation); "<AssertPlaceHolder>"; }
run(Cancellation cancellation) { setFScore(start, heuristic(goal, start)); return super.run(cancellation); }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testExecuteWithException() { final Supplier<String> supplier = mock(Supplier.class); when(supplier.get()).thenThrow(IllegalStateException.class);  final TemporalResponse<String> response = temporalClient.execute(JOB_RUN_CONFIG, supplier);  "<AssertPlaceHolder>"; assertFalse(response.getOutput().isPresent()); assertFalse(response.getMetadata().isSucceeded()); assertEquals(logPath, response.getMetadata().getLogPath()); }
execute(final JobRunConfig jobRunConfig, final Supplier<T> executor) { final Path jobRoot = TemporalUtils.getJobRoot(workspaceRoot, jobRunConfig.getJobId(), jobRunConfig.getAttemptId()); final Path logPath = TemporalUtils.getLogPath(jobRoot);  T operationOutput = null; RuntimeException exception = null;  try { operationOutput = executor.get(); } catch (final RuntimeException e) { exception = e; }  boolean succeeded = exception == null; if (succeeded && operationOutput instanceof ConnectorJobOutput) { succeeded = getConnectorJobSucceeded((ConnectorJobOutput) operationOutput); }  final JobMetadata metadata = new JobMetadata(succeeded, logPath); return new TemporalResponse<>(operationOutput, metadata); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testNode1Child() { MetadataNode child = NODE.child("2"); "<AssertPlaceHolder>"; assertEquals("ControllerRegistration(id=2, " + "incarnationId=adGo6sTPS0uJshjvdTUmqQ, " + "zkMigrationReady=false, " + "listeners=[], " + "supportedFeatures={metadata.version: 1-4})", child.stringify()); }
child(String name) { try { Integer brokerId = Integer.valueOf(name); ControllerRegistration registration = image.controllers().get(brokerId); if (registration == null) return null; return new MetadataLeafNode(registration.toString()); } catch (NumberFormatException e) { return null; } }
[*] target: assertNotNull(child)
[-] pred: org. junit. Assert. assertNotNull ( child )
************************************
************************************
[+] input: testInvalidRecordSize() { MemoryRecords records = MemoryRecords.withRecords(RecordBatch.MAGIC_VALUE_V2, 0L, Compression.NONE, TimestampType.CREATE_TIME, new SimpleRecord(1L, "a".getBytes(), "1".getBytes()), new SimpleRecord(2L, "b".getBytes(), "2".getBytes()), new SimpleRecord(3L, "c".getBytes(), "3".getBytes()));  ByteBuffer buffer = records.buffer(); buffer.putInt(DefaultRecordBatch.LENGTH_OFFSET, 10);  DefaultRecordBatch batch = new DefaultRecordBatch(buffer); "<AssertPlaceHolder>"; assertThrows(CorruptRecordException.class, batch::ensureValid); }
isValid() { return sizeInBytes() >= RECORD_BATCH_OVERHEAD && checksum() == computeChecksum(); }
[*] target: assertFalse(batch.isValid())
[-] pred: org. junit. Assert. assertFalse ( batch. isValid() )
************************************
************************************
[+] input: testFindNearest() { KDTreeNearestNeighbor<String, Object> nearestNeighbor = this.kdTree.findNearest( new Builder() .latitude(25.2028848) .longitude(55.289930) .build(), 2);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(1.1603729958857059, nearestNeighbor.getDistance()); Assertions.assertEquals("6", nearestNeighbor.getKdTreeObject().getId()); }
findNearest(Point point, double distance) { // Initialize the object to store the nearest neighbor and its distance. KDTreeNearestNeighbor<T, O> nearestNeighbor = new KDTreeNearestNeighbor<>(); // Call the recursive helper method with the root node, point, distance, and closestPoints list findNearest(this.root, point, distance, 0, nearestNeighbor); // Return the list of the closest points return nearestNeighbor; }
[*] target: assertNotNull(nearestNeighbor)
[-] pred: org. junit. Assert. assertNotNull ( nearestNeighbor )
************************************
************************************
[+] input: testKeyStoresExist() { Properties kafkaClientProperties = new Properties(); kafkaClientProperties.setProperty(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG, TEST_KEYSTORE_PATH); kafkaClientProperties.setProperty(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG, TEST_TRUSTSTORE_PATH); kafkaClientProperties.setProperty(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, TEST_PASSWORD); kafkaClientProperties.setProperty(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, TEST_PASSWORD);  // nonexistent keystore Properties kafkaClientPropertiesNonexistentKeystore = new Properties(); kafkaClientPropertiesNonexistentKeystore.setProperty(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG, TEST_NONEXISTENT_PATH); kafkaClientPropertiesNonexistentKeystore.setProperty(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG, TEST_TRUSTSTORE_PATH); kafkaClientPropertiesNonexistentKeystore.setProperty(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, TEST_PASSWORD); kafkaClientPropertiesNonexistentKeystore.setProperty(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, TEST_PASSWORD);  // nonexistent both keystore and truststore Properties kafkaClientPropertiesNonexistent = new Properties(); kafkaClientPropertiesNonexistent.setProperty(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG, TEST_NONEXISTENT_PATH); kafkaClientPropertiesNonexistent.setProperty(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG, TEST_NONEXISTENT_PATH); kafkaClientPropertiesNonexistent.setProperty(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, TEST_PASSWORD); kafkaClientPropertiesNonexistent.setProperty(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, TEST_PASSWORD);  boolean bothExists = KafkaSslUtils.keyStoresExist(kafkaClientProperties); boolean nonexistentKeystore = KafkaSslUtils.keyStoresExist(kafkaClientPropertiesNonexistentKeystore); boolean bothNotExists = KafkaSslUtils.keyStoresExist(kafkaClientPropertiesNonexistent);  "<AssertPlaceHolder>"; assertFalse(nonexistentKeystore); assertFalse(bothNotExists); }
keyStoresExist(Properties kafkaClientProperties) { for (String path : Arrays.asList(kafkaClientProperties.getProperty(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG), kafkaClientProperties.getProperty(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG))) { Path p = Paths.get(path); if (!Files.exists(p)) { return false; } } return true; }
[*] target: assertTrue(bothExists)
[-] pred: org. junit. Assert. assertTrue ( bothExists )
************************************
************************************
[+] input: basic() { OAuthBearerToken token = new BasicOAuthBearerToken("not.valid.token", Collections.emptySet(), 0L, "jdoe", 0L); assertEquals("not.valid.token", token.value()); assertTrue(token.scope().isEmpty()); assertEquals(0L, token.lifetimeMs()); assertEquals("jdoe", token.principalName()); "<AssertPlaceHolder>"; }
startTimeMs() { return startTimeMs; }
[*] target: assertEquals(0L, token.startTimeMs())
[-] pred: org. junit. Assert. assertEquals ( 0L, token. startTimeMs() )
************************************
************************************
[+] input: NoSuchAlgorithmException { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); IdentityProvider provider = mock(IdentityProvider.class); when(provider.hasUserinfoUrl()).thenReturn(false); when(provider.extractClaimsFromJwt(any(DecodedJWT.class))).thenReturn(Future.succeededFuture(new ExtractedClaims("sub", Collections.emptyList(), "hash", Map.of()))); List<IdentityProvider> providerList = List.of(provider); validator.setProviders(providerList); KeyPair keyPair = generateRsa256Pair(); Algorithm algorithm = Algorithm.RSA256((RSAPublicKey) keyPair.getPublic(), (RSAPrivateKey) keyPair.getPrivate()); String token = JWT.create().withClaim("iss", "issuer").sign(algorithm); Future<ExtractedClaims> future = validator.extractClaims(getBearerHeaderValue(token)); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.succeeded()); ExtractedClaims claims = res.result(); assertNotNull(claims); assertEquals("sub", claims.sub()); assertEquals(Collections.emptyList(), claims.userRoles()); assertEquals("hash", claims.userHash()); verify(provider, never()).match(any(DecodedJWT.class)); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testGetCompileDependenciesJettyOverride2() { var resolver = new DependencyResolver(new VersionResolution(new HierarchicalProperties().put(PROPERTY_OVERRIDE_PREFIX, "org.slf4j:slf4j-api:2.0.11,org.eclipse.jetty:jetty-io:11.0.13,org.eclipse.jetty:jetty-server:11.0.15")), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14))); var dependencies = resolver.getDirectDependencies(compile); "<AssertPlaceHolder>"; assertEquals(4, dependencies.size()); assertEquals(""" org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.eclipse.jetty:jetty-http:11.0.15 org.eclipse.jetty:jetty-io:11.0.13 org.slf4j:slf4j-api:2.0.11""", StringUtils.join(dependencies, "\n")); }
getDirectDependencies(Scope... scopes) { var pom_dependencies = getMavenPom(dependency_).getDependencies(scopes); var result = new DependencySet(); for (var dependency : pom_dependencies) { result.add(resolution_.overrideDependency(dependency.convertToDependency())); } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: testLingerBeginsOnFirstWrite() { int leaderEpoch = 17; long baseOffset = 157; int lingerMs = 50; int maxBatchSize = 512;  Mockito.when(memoryPool.tryAllocate(maxBatchSize)) .thenReturn(ByteBuffer.allocate(maxBatchSize));  BatchAccumulator<String> acc = buildAccumulator( leaderEpoch, baseOffset, lingerMs, maxBatchSize );  time.sleep(15); assertEquals(baseOffset, acc.append(leaderEpoch, singletonList("a"), OptionalLong.empty(), false)); assertEquals(lingerMs, acc.timeUntilDrain(time.milliseconds())); assertFalse(acc.isEmpty());  time.sleep(lingerMs / 2); assertEquals(lingerMs / 2, acc.timeUntilDrain(time.milliseconds())); assertFalse(acc.isEmpty());  time.sleep(lingerMs / 2); assertEquals(0, acc.timeUntilDrain(time.milliseconds())); assertTrue(acc.needsDrain(time.milliseconds())); "<AssertPlaceHolder>"; }
isEmpty() { // The linger timer begins running when we have pending batches. // We use this to infer when the accumulator is empty to avoid the // need to acquire the append lock. return !lingerTimer.isRunning(); }
[*] target: assertFalse(acc.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( acc. isEmpty ( ) )
************************************
************************************
[+] input: convertSubclassificationTest() { ASTTransformer transformer = new ASTTransformer();  Resource testResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertSubclassificationTest/model.ast.json").readAllBytes()); testResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) testResource.getContents().get(0); Package packageObject = (Package) namespace.getMember().get(0);  PartDefinition part1Definition = (PartDefinition) packageObject.getMember().get(0); assertEquals("Part1", part1Definition.getName()); AttributeUsage attribute1AttributeUsage = part1Definition.getOwnedAttribute().get(0); assertEquals("attribute1", attribute1AttributeUsage.getName());  PartDefinition part2Definition = (PartDefinition) packageObject.getMember().get(1); assertEquals("Part2", part2Definition.getName()); AttributeUsage attribute2AttributeUsage = part2Definition.getOwnedAttribute().get(0); assertEquals("attribute2", attribute2AttributeUsage.getName());  assertEquals(1, part2Definition.getOwnedSubclassification().size()); assertEquals(part1Definition, part2Definition.getOwnedSubclassification().get(0).getSuperclassifier()); assertEquals(part2Definition, part2Definition.getOwnedSubclassification().get(0).getSubclassifier());  }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(testResource)
[-] pred: org. junit. Assert. assertNotNull ( testResource )
************************************
************************************
[+] input: test() { Time time = new MockTime(); OverloadCircuitBreaker breaker = new OverloadCircuitBreaker(time); assertFalse(breaker.isOverload()); breaker.overload(); assertTrue(breaker.isOverload()); breaker.success(); assertTrue(breaker.isOverload()); time.sleep(OverloadCircuitBreaker.HALF_OPEN_WINDOW_MS); breaker.success(); "<AssertPlaceHolder>"; }
isOverload() { return state != State.OPEN; }
[*] target: assertFalse(breaker.isOverload())
[-] pred: org. junit. Assert. assertFalse ( breaker. isOverload() )
************************************
************************************
[+] input: testBlockTreeAddBlock() { Pair<BlockTree, List<Hash256>> result = createFlatTree(1); BlockTree bt = result.getValue0(); List<Hash256> hashes = result.getValue1();  BlockHeader header = createHeader(hashes.get(1), 2); Hash256 hash = header.getHash(); bt.addBlock(header, Instant.ofEpochSecond(0));  BlockNode blockNode = bt.getNode(hash); BlockNode leafBlockNode = bt.getLeaves().load(blockNode.getHash());  "<AssertPlaceHolder>";  Hash256 oldHash = getHash("01"); leafBlockNode = bt.getLeaves().load(oldHash); assertNull(leafBlockNode); }
getNode(final Hash256 hash) { if (Objects.equals(root.getHash(), hash)) { return root; }  for (BlockNode leaf : leaves.nodes()) { if (Objects.equals(leaf.getHash(), hash)) { return leaf; } }  for (BlockNode child : root.getChildren()) { BlockNode n = child.getNode(hash); if (n != null) { return n; } }  return null; }
[*] target: assertNotNull(leafBlockNode)
[-] pred: org. junit. Assert. assertNotNull ( leafBlockNode )
************************************
************************************
[+] input: getUsers() { var result = subject.getUsers();  "<AssertPlaceHolder>"; assertEquals(user1.getId(), result.stream().findFirst().orElseThrow().getId()); }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred: org. junit. Assert. assertEquals ( 1, result. size() )
************************************
************************************
[+] input: DatabaseException { Set<String> words = db.loadDictionary();  Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(words.contains("fred")); Assertions.assertTrue(words.contains("barney")); Assertions.assertTrue(words.contains("betty")); Assertions.assertTrue(words.contains("wilma")); }
loadDictionary() throws DatabaseException {  String sql = "select word from dictionary"; try (PreparedStatement stmt = conn.prepareStatement(sql)) {  Set<String> words = new HashSet<>(); try (ResultSet rs = stmt.executeQuery()) { while (rs.next()) { String word = rs.getString(1); words.add(word); } }  return words; } catch (SQLException e) { throw new DatabaseException("fillDictionary failed", e); } }
[*] target: assertEquals(4, words.size())
[-] pred: org. junit. Assert. assertEquals ( 4, words. size ( ) )
************************************
************************************
[+] input: testLimit_ApiKeyLimitNotFoundWithNullRole() { Key key = new Key(); key.setKey("key"); key.setProject("project"); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(new Config(), request, apiKeyData, null, "trace-id", "span-id"); proxyContext.setDeployment(new Model());  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.FORBIDDEN, result.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: generatesPrivateKey() { Ed25519PrivateKey ed25519PrivateKey = Ed25519Utils.generateKeyPair(); PeerId peerId = PeerId.fromPubKey(ed25519PrivateKey.publicKey());  "<AssertPlaceHolder>"; assertNotNull(ed25519PrivateKey.publicKey()); assertNotNull(peerId); }
generateKeyPair() { final Ed25519PrivateKeyParameters parameters = new Ed25519PrivateKeyParameters(new SecureRandom());  return new Ed25519PrivateKey(parameters); }
[*] target: assertNotNull(ed25519PrivateKey)
[-] pred: org. junit. Assert. assertNotNull ( ed25519PrivateKey )
************************************
************************************
[+] input: testGetCompileTransitiveDependenciesJettyExclusion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14)) .exclude("org.slf4j", "slf4j-api")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(5, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14 org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.eclipse.jetty:jetty-http:11.0.14 org.eclipse.jetty:jetty-io:11.0.14 org.eclipse.jetty:jetty-util:11.0.14""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: getProjectgetProjectUsers() { var result = subject.getProjectUsers();  "<AssertPlaceHolder>"; assertEquals(project1_user.getId(), result.stream().findFirst().orElseThrow().getId()); }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(1, result.size())
[-] pred: org. junit. Assert. assertEquals ( 1, result. size() )
************************************
************************************
[+] input: test() { final DSLContext dslContext = getDslContext(); final boolean tableExists = generationTableExists(dslContext);  assertFalse(tableExists);  V0_55_1_002__AddGenerationTable.createGenerationTable(dslContext);  final boolean tableExistsPostMigration = generationTableExists(dslContext);  "<AssertPlaceHolder>";  final Set<String> index = dslContext.select() .from(table("pg_indexes")) .where(field("tablename").eq(STREAM_GENERATION_TABLE_NAME)) .fetch() .stream() .map(c -> c.getValue("indexdef", String.class)) .collect(Collectors.toSet()); assertEquals(3, index.size()); assertTrue(index.contains("CREATE UNIQUE INDEX stream_generation_pkey ON public.stream_generation USING btree (id)")); assertTrue(index.contains( "CREATE INDEX stream_generation_connection_id_stream_name_generation_id_idx " + "ON public.stream_generation USING btree (connection_id, stream_name, generation_id DESC)")); assertTrue(index.contains( "CREATE INDEX stream_generation_connection_id_stream_name_stream_namespac_idx ON public.stream_generation " + "USING btree (connection_id, stream_name, stream_namespace, generation_id DESC)")); }
createGenerationTable(final DSLContext ctx) { final Field<UUID> id = DSL.field("id", SQLDataType.UUID.nullable(false)); final Field<UUID> connectionId = DSL.field("connection_id", SQLDataType.UUID.nullable(false)); final Field<String> streamName = DSL.field("stream_name", SQLDataType.VARCHAR.nullable(false)); final Field<String> streamNamespace = DSL.field("stream_namespace", SQLDataType.VARCHAR.nullable(true)); final Field<Long> generationId = DSL.field("generation_id", SQLDataType.BIGINT.nullable(false)); final Field<Long> startJobId = DSL.field("start_job_id", SQLDataType.BIGINT.nullable(false)); final Field<OffsetDateTime> createdAt = DSL.field("created_at", SQLDataType.TIMESTAMPWITHTIMEZONE.nullable(false).defaultValue(currentOffsetDateTime())); final Field<OffsetDateTime> updatedAt = DSL.field("updated_at", SQLDataType.TIMESTAMPWITHTIMEZONE.nullable(false).defaultValue(currentOffsetDateTime()));  ctx.createTable(STREAM_GENERATION_TABLE_NAME) .columns(id, connectionId, streamName, streamNamespace, generationId, startJobId, createdAt, updatedAt) .constraints( primaryKey(id), foreignKey(connectionId).references("connection", "id").onDeleteCascade()) .execute();  final String indexCreationQuery = String.format("CREATE INDEX ON %s USING btree (%s, %s, %s DESC)", STREAM_GENERATION_TABLE_NAME, connectionId.getName(), streamName.getName(), generationId.getName()); final String indexCreationQuery2 = String.format("CREATE INDEX ON %s USING btree (%s, %s, %s, %s DESC)", STREAM_GENERATION_TABLE_NAME, connectionId.getName(), streamName.getName(), streamNamespace.getName(), generationId.getName()); ctx.execute(indexCreationQuery); ctx.execute(indexCreationQuery2); }
[*] target: assertTrue(tableExistsPostMigration)
[-] pred: org. junit. Assert. assertTrue ( tableExistsPostMigration )
************************************
************************************
[+] input: givenLoginRequest_WhenWhenAdminRole_ReturnSuccess() {  // given LoginRequest request = LoginRequest.builder() .email("admin@bookdelivery.com") .password("admin_password") .build();  User mockUser = User.builder() .email(request.getEmail()) .fullName("Test User") .username("testuser") .password("hashedPassword") .role(Role.ROLE_CUSTOMER) .build();  Authentication mockAuthentication = new UsernamePasswordAuthenticationToken( request.getEmail(), request.getPassword());  // when when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class))) .thenReturn(mockAuthentication); when(jwtUtils.generateJwtToken(mockAuthentication)).thenReturn("mockedToken"); when(userRepository.findByEmail(request.getEmail())).thenReturn(Optional.of(mockUser)); when(refreshTokenService.createRefreshToken(any(User.class))) .thenReturn("actualRefreshToken");  // then JWTResponse jwtResponse = authService.login(request);  "<AssertPlaceHolder>"; assertEquals(request.getEmail(), jwtResponse.getEmail()); assertEquals("mockedToken", jwtResponse.getToken()); assertEquals("actualRefreshToken", jwtResponse.getRefreshToken());  }
login(LoginRequest request) {  UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword());  Authentication auth = authenticationManager.authenticate(authToken); SecurityContextHolder.getContext().setAuthentication(auth); String jwtToken = jwtUtils.generateJwtToken(auth);  User user = userRepository.findByEmail(request.getEmail()).orElseThrow(UserNotFoundException::new);  return JWTResponse.builder() .email(request.getEmail()) .token(jwtToken) .refreshToken(refreshTokenService.createRefreshToken(user)) .build(); }
[*] target: assertNotNull(jwtResponse)
[-] pred: org. junit. Assert. assertNotNull ( jwtResponse )
************************************
************************************
[+] input: testCreatingHorizontalAdjacent() { Vertex cell1 = new Cell(1); Vertex cell2 = new Cell(2);  cell1.creatingHorizontalAdjacent(cell2);  assertEquals(1, cell1.getAdjacents().size()); "<AssertPlaceHolder>"; }
getAdjacents() { return this.adjacents; }
[*] target: assertEquals(1, cell2.getAdjacents().size())
[-] pred: org. junit. Assert. assertEquals ( 1, cell2. getAdjacents(). size ( ) )
************************************
************************************
[+] input: testGenerateIdentity() { // Given  // When String generatedIdentity = ulidIdentityGenerator.generateIdentity();  // Then "<AssertPlaceHolder>"; assertTrue(generatedIdentity.matches("[0-9A-Z]{26}"), "Generated identity should be a valid ULID"); }
generateIdentity() { return UlidCreator.getMonotonicUlid().toString(); }
[*] target: assertNotNull(generatedIdentity)
[-] pred: org. junit. Assert. assertNotNull ( generatedIdentity )
************************************
************************************
[+] input: testBuildSentryExceptionsPythonChained() { final String stacktrace = """ Traceback (most recent call last): File "/airbyte/connector-errors/error.py", line 31, in read_records failing_method() File "/airbyte/connector-errors/error.py", line 36, in failing_method raise HTTPError(http_error_msg, response=self) requests.exceptions.HTTPError: 400 Client Error: Bad Request for url: https://airbyte.com  The above exception was the direct cause of the following exception:  Traceback (most recent call last): File "/airbyte/connector-errors/error.py", line 39, in <module> main() File "/airbyte/connector-errors/error.py", line 13, in main sync_mode("incremental") File "/airbyte/connector-errors/error.py", line 17, in sync_mode incremental() File "/airbyte/connector-errors/error.py", line 33, in incremental raise RuntimeError("My other error") from err RuntimeError: My other error """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.PYTHON, parsedException.platform()); Assertions.assertEquals(2, exceptionList.size());  assertExceptionContent(exceptionList.get(0), "requests.exceptions.HTTPError", "400 Client Error: Bad Request for url: https://airbyte.com", List.of( Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 31, FUNCTION, "read_records", CONTEXT_LINE, "failing_method()"), Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 36, FUNCTION, "failing_method", CONTEXT_LINE, "raise HTTPError(http_error_msg, response=self)")));  assertExceptionContent(exceptionList.get(1), "RuntimeError", "My other error", List.of( Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 39, FUNCTION, "<module>", CONTEXT_LINE, "main()"), Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 13, FUNCTION, "main", CONTEXT_LINE, "sync_mode("incremental")"), Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 17, FUNCTION, "sync_mode", CONTEXT_LINE, "incremental()"), Map.of( ABS_PATH, ERROR_PATH, LINE_NO, 33, FUNCTION, "incremental", CONTEXT_LINE, "raise RuntimeError("My other error") from err")));  }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred: org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )
************************************
************************************
[+] input: ConfigNotFoundException { setupStandardDefinitionMock(createAdvancedAuth() .withPredicateKey(List.of(CREDENTIALS, AUTH_TYPE)) .withPredicateValue("wrong_auth_type")); final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); setupOAuthParamMocks(generateOAuthParameters()); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); "<AssertPlaceHolder>"; assertNoTracking(); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(config, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( config, actualConfig )
************************************
************************************
[+] input: JsonProcessingException { doCallRealMethod().when(context).setStreamingRequest(anyBoolean()); when(context.isStreamingRequest()).thenCallRealMethod();  Throwable error = fn.apply((ObjectNode) ProxyUtil.MAPPER.readTree("{}"));  "<AssertPlaceHolder>"; assertFalse(context.isStreamingRequest()); }
apply(ObjectNode tree) { JsonNode stream = tree.get("stream"); boolean result = stream != null && stream.asBoolean(false); context.setStreamingRequest(result); return null; }
[*] target: assertNull(error)
[-] pred: org. junit. Assert. assertNull ( error )
************************************
************************************
[+] input: givenCorruptedValueSegment_whenCheckingChecksum_thenIsChecksumValidReturnsFalse() { // Given byte[] testData = new byte[]{ (byte) -83, (byte) 64, 0x00, 0x05,         // Key Size 0x00, 0x00, 0x00, 0x05, // Value Size 0x48, 0x65, 0x6C, 0x6C, 0x6F, // Key: "Hello" 0x57, 0x6F, 0x62, 0x6C, 0x65  // Value: "World" (Bit Flipped) };  // When Segment corruptedSegment = Segment.fromByteArray(testData);  // Then assertFalse(corruptedSegment.isChecksumValid()); "<AssertPlaceHolder>"; }
isSegmentValid() { return isChecksumValid() && getKeySize() > 0 && getValueSize() >= 0 && bytes.length == CRC_LENGTH + KEY_SIZE_LENGTH + VALUE_SIZE_LENGTH + getKeySize() + getValueSize(); }
[*] target: assertFalse(corruptedSegment.isSegmentValid())
[-] pred: org. junit. Assert. assertFalse ( corruptedSegment. isSegmentValid ( ) )
************************************
************************************
[+] input: testShouldRecordForTraceLevelSensor() { Sensor traceSensor = new Sensor(null, "traceSensor", null, INFO_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.TRACE); assertFalse(traceSensor.shouldRecord());  traceSensor = new Sensor(null, "traceSensor", null, DEBUG_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.TRACE); assertFalse(traceSensor.shouldRecord());  traceSensor = new Sensor(null, "traceSensor", null, TRACE_CONFIG, new SystemTime(), 0, Sensor.RecordingLevel.TRACE); "<AssertPlaceHolder>"; }
shouldRecord() { return this.recordingLevel.shouldRecord(config.recordLevel().id); }
[*] target: assertTrue(traceSensor.shouldRecord())
[-] pred: org. junit. Assert. assertTrue ( traceSensor. shouldRecord ( ) )
************************************
************************************
[+] input: shouldDetectAABBOverlaps() { // Given AABBf testForOverlap = new AABBf(1.0f, 5.1f, 0.0f, 2.0f, 10.0f, 0.0f); AABBTree<TestEntity> tree = givenTree(); TestEntity entity1 = new TestEntity(1, -20.0f, 0.0f, 10.0f, 10.0f); TestEntity entity2 = new TestEntity(2, -5.0f, 0.0f, 10.0f, 10.0f); tree.add(entity1); tree.add(entity2);  // When List<TestEntity> result = new ArrayList<>(); tree.detectOverlaps(testForOverlap, result);  // Then "<AssertPlaceHolder>"; assertEquals(2, result.getFirst().getLongId()); }
size() { return objects.size(); }
[*] target: assertEquals(1, result.size())
[-] pred: org. junit. Assert. assertEquals ( 1, result. size ( ) )
************************************
************************************
[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }));  ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); frame = port.getNextFrame(); assertNotNull(frame); assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred: org. junit. Assert. assertNotNull ( frame )
************************************
************************************
[+] input: complete() { Message message = new Message(Role.USER, "Who is the most renowed French football player?"); String model = MistralService.MISTRAL_SMALL_LATEST; ChatResponse response = service.complete(model, List.of(message)); "<AssertPlaceHolder>"; System.out.println(response); assertEquals("mistral-small-latest", response.model()); System.out.println(response.choices().getFirst().message().content()); }
complete(String model, List<Message> messages) { ChatRequest request = new ChatRequest(model, messages, 0.7);  return restClient.post() .uri("/v1/chat/completions") .header("Authorization", "Bearer " + apiKey) .header("Content-Type", "application/json") .header("Accept", "application/json") .body(request) .retrieve() .body(ChatResponse.class); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: Exception { setupCoordinator();  mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); mockClient.prepareResponse(joinGroupFollowerResponse(1, memberId, leaderId, Errors.NONE)); mockClient.prepareResponse(syncGroupResponse(Errors.NONE));  final RuntimeException e = new RuntimeException();  // raise the error when the background thread tries to send a heartbeat mockClient.prepareResponse(body -> { if (body instanceof HeartbeatRequest) throw e; return false; }, heartbeatResponse(Errors.UNKNOWN_SERVER_ERROR)); coordinator.ensureActiveGroup(); mockTime.sleep(HEARTBEAT_INTERVAL_MS);  try { long startMs = System.currentTimeMillis(); while (System.currentTimeMillis() - startMs < 1000) { Thread.sleep(10); coordinator.timeToNextHeartbeat(0); } fail("Expected timeToNextHeartbeat to raise an error in 1 second"); } catch (RuntimeException exception) { assertEquals(exception, e); }  try { long startMs = System.currentTimeMillis(); while (System.currentTimeMillis() - startMs < 1000) { Thread.sleep(10); coordinator.pollHeartbeat(mockTime.milliseconds()); } fail("Expected pollHeartbeat to raise an error in 1 second"); } catch (RuntimeException exception) { "<AssertPlaceHolder>"; } }
pollHeartbeat(long now) { if (heartbeatThread != null) { if (heartbeatThread.hasFailed()) { // set the heartbeat thread to null and raise an exception. If the user catches it, // the next call to ensureActiveGroup() will spawn a new heartbeat thread. RuntimeException cause = heartbeatThread.failureCause(); heartbeatThread = null; throw cause; } // Awake the heartbeat thread if needed if (heartbeat.shouldHeartbeat(now)) { notify(); } heartbeat.poll(now); } }
[*] target: assertEquals(exception, e)
[-] pred: org. junit. Assert. assertEquals ( exception, e )
************************************
************************************
[+] input: testDescribeIndex() { IndexDescription indexDescription = client.describeIndex(INDEX_NAME); "<AssertPlaceHolder>"; assertNotNull(indexDescription.getDatabase()); assertNotNull(indexDescription.getStatus());  // Assert database information Database database = indexDescription.getDatabase(); assertAll( () -> assertEquals(INDEX_NAME, database.getName()), () -> assertEquals(COSINE, database.getMetric()), () -> assertEquals(3, database.getDimension()), () -> assertEquals(1, database.getReplicas()), () -> assertEquals(1, database.getShards()), () -> assertEquals(1, database.getPods()), () -> assertEquals("p1.x1", database.getPodType()));  // Assert status information Status status = indexDescription.getStatus(); assertAll( () -> assertNotNull(status), () -> assertTrue(status.getWaiting().isEmpty()), () -> assertTrue(status.getCrashed().isEmpty()), () -> { String host = String.format("%s-%s.svc.%s.pinecone.io", INDEX_NAME, "b43e233", System.getenv("PINECONE_ENV")); assertEquals(host, status.getHost()); }, () -> assertEquals(433, status.getPort()), () -> assertEquals("Ready", status.getState()), () -> assertTrue(status.isReady())); }
describeIndex(String name) { return indexService.describeIndex(name).blockingGet(); }
[*] target: assertNotNull(indexDescription)
[-] pred: org. junit. Assert. assertNotNull ( indexDescription )
************************************
************************************
[+] input: testIsOnSingleLine() { Token firstToken = buildCommand("a = 3  *  ( "comment" + LINE_SEP + "4 + 5 ).", 2); try { Term term = Term.createSimple(firstToken); assertTrue(term.isOnSingleLine());  term = Term.createArithmetic(firstToken); assertFalse(term.isOnSingleLine());  firstToken = buildCommand("a = 3 * 5.", 2); term = Term.createArithmetic(firstToken); "<AssertPlaceHolder>"; } catch (UnexpectedSyntaxException ex) { fail(); } }
isOnSingleLine() { if (firstToken == lastToken) return true; Token token = firstToken.getNext(); while (token != null) { if (token.lineBreaks > 0) return false; if (token == lastToken) break; token = token.getNext(); } return true; }
[*] target: assertTrue(term.isOnSingleLine())
[-] pred: org. junit. Assert. assertTrue ( term. isOnSingleLine ( ) )
************************************
************************************
[+] input: testLimit_ApiKeySuccess_KeyNotFound() { Key key = new Key(); key.setRole("role"); key.setKey("key"); key.setProject("api-key"); Config config = new Config(); Role role = new Role(); Limit limit = new Limit(); role.setLimits(Map.of("model", limit)); config.setRoles(Map.of("role", role)); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, null, "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  when(vertx.executeBlocking(any(Callable.class), eq(false))).thenAnswer(invocation -> { Callable<?> callable = invocation.getArgument(0); return Future.succeededFuture(callable.call()); });  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.OK, result.result().status()); }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: JellyfinFolderMetadataTest() { JellyfinFolderMetadata metadata = new JellyfinFolderMetadata();  String name = "TestMetadata"; metadata.setName(name); assertEquals(name, metadata.getName());  String overview = "Overview"; metadata.setOverview(overview); assertEquals(overview, metadata.getOverview());     String type = "Type"; metadata.setType(type); "<AssertPlaceHolder>";   }
getType() { return type; }
[*] target: assertEquals(type, metadata.getType())
[-] pred: org. junit. Assert. assertEquals ( type, metadata. getType() )
************************************
************************************
[+] input: shouldApplyTimeoutToFirstSpanAfterAppBeingMovedToForeground() { TestClock clock = TestClock.create(); SessionIdTimeoutHandler timeoutHandler = new SessionIdTimeoutHandler(clock, DEFAULT_SESSION_TIMEOUT);  timeoutHandler.onApplicationBackgrounded(); timeoutHandler.bump();  // the first span after app is moved to the foreground gets timed out timeoutHandler.onApplicationForegrounded(); clock.advance(20, TimeUnit.MINUTES); assertTrue(timeoutHandler.hasTimedOut()); timeoutHandler.bump();  // after the initial span it's the same as the usual foreground scenario clock.advance(Duration.ofHours(4)); "<AssertPlaceHolder>"; }
hasTimedOut() { // don't apply sessionId timeout to apps in the foreground if (state == State.FOREGROUND) { return false; } long elapsedTime = clock.nanoTime() - timeoutStartNanos; return elapsedTime >= sessionTimeout.toNanos(); }
[*] target: assertFalse(timeoutHandler.hasTimedOut())
[-] pred: org. junit. Assert. assertFalse ( timeoutHandler. hasTimedOut() )
************************************
************************************
[+] input: testOnJoinPrepareWithOffsetCommitShouldKeepJoinAfterNonRetryableException() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.empty(), false)) { int generationId = 42; String memberId = "consumer-42";  Timer pollTimer = time.timer(100L); client.prepareResponse(offsetCommitResponse(singletonMap(t1p, Errors.UNKNOWN_MEMBER_ID))); boolean res = coordinator.onJoinPrepare(pollTimer, generationId, memberId); "<AssertPlaceHolder>";  assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
onJoinPrepare(Timer timer, int generation, String memberId) { log.debug("Executing onJoinPrepare with generation {} and memberId {}", generation, memberId); if (joinPrepareTimer == null) { // We should complete onJoinPrepare before rebalanceTimeoutMs, // and continue to join group to avoid member got kicked out from group joinPrepareTimer = time.timer(rebalanceConfig.rebalanceTimeoutMs); } else { joinPrepareTimer.update(); }  // async commit offsets prior to rebalance if auto-commit enabled // and there is no in-flight offset commit request if (autoCommitEnabled && autoCommitOffsetRequestFuture == null) { maybeMarkPartitionsPendingRevocation(); autoCommitOffsetRequestFuture = maybeAutoCommitOffsetsAsync(); }  // wait for commit offset response before timer expired if (autoCommitOffsetRequestFuture != null) { Timer pollTimer = timer.remainingMs() < joinPrepareTimer.remainingMs() ? timer : joinPrepareTimer; client.poll(autoCommitOffsetRequestFuture, pollTimer); joinPrepareTimer.update();  // Keep retrying/waiting the offset commit when: // 1. offset commit haven't done (and joinPrepareTimer not expired) // 2. failed with retriable exception (and joinPrepareTimer not expired) // Otherwise, continue to revoke partitions, ex: // 1. if joinPrepareTimer has expired // 2. if offset commit failed with non-retriable exception // 3. if offset commit success boolean onJoinPrepareAsyncCommitCompleted = true; if (joinPrepareTimer.isExpired()) { log.error("Asynchronous auto-commit of offsets failed: joinPrepare timeout. Will continue to join group"); } else if (!autoCommitOffsetRequestFuture.isDone()) { onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && autoCommitOffsetRequestFuture.isRetriable()) { log.debug("Asynchronous auto-commit of offsets failed with retryable error: {}. Will retry it.", autoCommitOffsetRequestFuture.exception().getMessage()); onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && !autoCommitOffsetRequestFuture.isRetriable()) { log.error("Asynchronous auto-commit of offsets failed: {}. Will continue to join group.", autoCommitOffsetRequestFuture.exception().getMessage()); } if (autoCommitOffsetRequestFuture.isDone()) { autoCommitOffsetRequestFuture = null; } if (!onJoinPrepareAsyncCommitCompleted) { pollTimer.sleep(Math.min(pollTimer.remainingMs(), rebalanceConfig.retryBackoffMs)); timer.update(); return false; } }  // the generation / member-id can possibly be reset by the heartbeat thread // upon getting errors or heartbeat timeouts; in this case whatever is previously // owned partitions would be lost, we should trigger the callback and cleanup the assignment; // otherwise we can proceed normally and revoke the partitions depending on the protocol, // and in that case we should only change the assignment AFTER the revoke callback is triggered // so that users can still access the previously owned partitions to commit offsets etc. Exception exception = null; final SortedSet<TopicPartition> revokedPartitions = new TreeSet<>(COMPARATOR); if (generation == Generation.NO_GENERATION.generationId || memberId.equals(Generation.NO_GENERATION.memberId)) { revokedPartitions.addAll(subscriptions.assignedPartitions());  if (!revokedPartitions.isEmpty()) { log.info("Giving away all assigned partitions as lost since generation/memberID has been reset," + "indicating that consumer is in old state or no longer part of the group"); exception = rebalanceListenerInvoker.invokePartitionsLost(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet()); } } else { switch (protocol) { case EAGER: // revoke all partitions revokedPartitions.addAll(subscriptions.assignedPartitions()); exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet());  break;  case COOPERATIVE: // only revoke those partitions that are not in the subscription anymore. Set<TopicPartition> ownedPartitions = new HashSet<>(subscriptions.assignedPartitions()); revokedPartitions.addAll(ownedPartitions.stream() .filter(tp -> !subscriptions.subscription().contains(tp.topic())) .collect(Collectors.toSet()));  if (!revokedPartitions.isEmpty()) { exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  ownedPartitions.removeAll(revokedPartitions); subscriptions.assignFromSubscribed(ownedPartitions); }  break; } }  isLeader = false; subscriptions.resetGroupSubscription(); joinPrepareTimer = null; autoCommitOffsetRequestFuture = null; timer.update();  if (exception != null) { throw new KafkaException("User rebalance callback throws an error", exception); } return true; }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: testGetCommodityWithNoSpecification() { GetCommodityParam getParam = new GetCommodityParam(); getParam.setCommodityCode("COMMODITY1"); CommodityDTO expectedCommodityDTO = new CommodityDTO(); expectedCommodityDTO.setCommodityName("Test Commodity"); expectedCommodityDTO.setCommodityCode("COMMODITY1"); List<String> MONTHS = IntStream.rangeClosed(1, 6) .mapToObj(i -> i + ":Month") .collect(Collectors.toList()); Map<String, List<String>> map = new HashMap<>(); map.put("COMMODITY1", MONTHS); expectedCommodityDTO.setAllowedPaymentDurations(map); expectedCommodityDTO.setPayPeriods("[1,2,3,4,5,6]"); expectedCommodityDTO.setPayPeriodUnit("Month"); ListResult<CommoditySpecificationDTO> commoditySpecificationsResponse = ListResult.genSuccessListResult( Collections.emptyList(), 0);  new Expectations() {{ commodityOtsHelper.getCommodity(anyString); result = expectedCommodityDTO;  commoditySpecificationService.listAllSpecifications((UserInfoModel) any, (ListCommoditySpecificationParam) any); result = commoditySpecificationsResponse; }}; CommodityDTO commodityDTO = commodityService.getCommodity(getParam); "<AssertPlaceHolder>"; Map<String, List<String>> allowedPaymentDurations = commodityDTO.getAllowedPaymentDurations(); assertEquals(MONTHS, allowedPaymentDurations.get("COMMODITY1")); }
getCommodity(GetCommodityParam param) { CommodityDTO commodity = commodityOtsHelper.getCommodity(param.getCommodityCode()); ListCommoditySpecificationParam listCommoditySpecificationParam = new ListCommoditySpecificationParam(); listCommoditySpecificationParam.setCommodityCode(param.getCommodityCode()); ListResult<CommoditySpecificationDTO> commoditySpecifications = commoditySpecificationService. listAllSpecifications(null, listCommoditySpecificationParam); Map<String, List<String>> allowedPaymentDurations = new HashMap<>(); if (commoditySpecifications.getData() != null && !commoditySpecifications.getData().isEmpty()) { for (CommoditySpecificationDTO commoditySpecification : commoditySpecifications.getData()) { String payPeriodsStr = commoditySpecification.getPayPeriods(); String specificationName = commoditySpecification.getSpecificationName(); String payPeriodUnit = commoditySpecification.getPayPeriodUnit(); setAllowedPaymentDurations(specificationName, payPeriodUnit, payPeriodsStr, allowedPaymentDurations); } } else { setAllowedPaymentDurations(commodity.getCommodityCode(), commodity.getPayPeriodUnit(), commodity.getPayPeriods(), allowedPaymentDurations); } commodity.setAllowedPaymentDurations(allowedPaymentDurations); return commodity; }
[*] target: assertEquals(expectedCommodityDTO, commodityDTO)
[-] pred: org. junit. Assert. assertEquals ( expectedCommodityDTO, commodityDTO )
************************************
************************************
[+] input: testReplaceAtString() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE); ((ArrayNode) expected.get(ONE)).set(1, REPLACEMENT_STRING);  final JsonNode actual = JsonPaths.replaceAtString(JSON_NODE, LIST_ONE_QUERY, REPLACEMENT_STRING); "<AssertPlaceHolder>"; }); }
replaceAtString(final JsonNode json, final String jsonPath, final String replacement) { return replaceAtJsonNode(json, jsonPath, Jsons.jsonNode(replacement)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { var out = Objects.requireNonNull(System.out); int count = 20; CountDownLatch latch = new CountDownLatch(count); ListLogOutput output = new ListLogOutput(); output.setConsumer((event, body) -> { latch.countDown(); }); var gum = RainbowGum.builder().route(b -> { b.appender("console", a -> { a.output(LogOutput.ofStandardOut()); a.encoder(LogFormatter.builder().message().newline().encoder()); }); /* * This has to be the second one so that it happens after the console output. */ b.appender("list", a -> { a.output(output); a.encoder(LogFormatter.builder().message().newline().encoder()); }); b.publisher(PublisherFactory.ofAsync(100)); }).build(); try (var g = gum.start()) { for (int i = 0; i < count; i++) { TestEventBuilder.of().to(gum).event().message("" + i).log(); } latch.await(); out.println("done"); var responses = g.config().publisherRegistry().status(); String actual = """ [Response[type=interface io.jstach.rainbowgum.LogPublisher, name=default, status=QueueStatus[count=0, max=100, level=INFO]]] """ .trim(); String expected = responses.toString(); "<AssertPlaceHolder>"; } List<String> lines = output.events().stream().map(e -> e.getValue().trim()).toList(); int i = 0; for (var line : lines) { String actual = line; String expected = "" + i; assertEquals(expected, actual); i++; }  }
status() throws Exception { return new Status.QueueStatus(queue.size(), bufferSize); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldDetectRayIntersection() { // Given AABBTree<TestEntity> tree = givenTree(); Rayf ray = new Rayf(0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f); TestEntity entity1 = new TestEntity(1, 2.0f, 0.0f, 3.0f, 3.0f); TestEntity entity2 = new TestEntity(2, -5.0f, 0.0f, 3.0f, 2.0f); tree.add(entity1); tree.add(entity2);  // When List<TestEntity> intersecting = new ArrayList<>(); tree.detectRayIntersection(ray, intersecting);  // Then "<AssertPlaceHolder>"; assertEquals(1L, intersecting.getFirst().getLongId()); }
size() { return objects.size(); }
[*] target: assertEquals(1, intersecting.size())
[-] pred: org. junit. Assert. assertEquals ( 1, intersecting. size ( ) )
************************************
************************************
[+] input: testGetReleases() { Release[] releases = Program.getReleases(); "<AssertPlaceHolder>"; assertTrue(releases.length > 0);  // server time may be 1 day behind due to different time zones, therefore tolerate one extra day for release dates LocalDate dayAfterTomorrow = LocalDate.now().plusDays(2);  Release lastRelease = null; for (Release release : releases) { assertFalse(StringUtil.isNullOrEmpty(release.toString()));  assertTrue(release.wasEarlierThan(dayAfterTomorrow.getYear(), dayAfterTomorrow.getMonthValue(), dayAfterTomorrow.getDayOfMonth())); if (lastRelease != null) { assertTrue(release.wasEarlierThan(lastRelease.releaseDate)); }  lastRelease = release; } }
getReleases() { return new Release[] { Release.create("1.18.0", 2024,  7,  8), Release.create("1.17.0", 2024,  6, 24), Release.create("1.16.0", 2024,  4, 12), Release.create("1.15.0", 2024,  3, 25), Release.create("1.14.0", 2024,  3, 11), Release.create("1.13.0", 2024,  1,  5), Release.create("1.12.0", 2023, 11, 27), Release.create("1.11.0", 2023, 11,  6), Release.create("1.10.0", 2023, 11,  1), Release.create("1.9.0",  2023, 10, 30), Release.create("1.8.0",  2023, 10, 23), Release.create("1.7.0",  2023, 10, 10), Release.create("1.6.0",  2023, 10,  2), Release.create("1.5.0",  2023,  7,  5), Release.create("1.4.0",  2023,  6, 12), Release.create("1.3.0",  2023,  6,  6), Release.create("1.2.0",  2023,  5, 22), Release.create("1.1.0",  2023,  5,  7), Release.create("1.0.0",  2023,  4, 21) }; }
[*] target: assertNotNull(releases)
[-] pred: org. junit. Assert. assertNotNull ( releases )
************************************
************************************
[+] input: testBuildSentryExceptionsDbtCompilationErrorDefault() { final String stacktrace = """ AirbyteDbtError:\s Encountered an error: Compilation Error in model banking_test (models/generated/airbyte_tables/public/banking_test.sql) Model 'model.airbyte_utils.banking_test' (models/generated/airbyte_tables/public/banking_test.sql) depends on a source named 'public._airbyte_raw_banking_test' which was not found """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.OTHER, parsedException.platform()); Assertions.assertEquals(1, exceptionList.size());  assertExceptionContent(exceptionList.get(0), "DbtCompilationError", "Model 'model.airbyte_utils.banking_test' (models/generated/airbyte_tables/public/banking_test.sql) depends on a source named 'public._airbyte_raw_banking_test' which was not found", List.of()); }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred: org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )
************************************
************************************
[+] input: fromGoodConfig() { ExpiringCredentialRefreshConfig expiringCredentialRefreshConfig = new ExpiringCredentialRefreshConfig( new ConfigDef().withClientSaslSupport().parse(Collections.emptyMap()), true); assertEquals(Double.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_WINDOW_FACTOR), Double.valueOf(expiringCredentialRefreshConfig.loginRefreshWindowFactor())); assertEquals(Double.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_WINDOW_JITTER), Double.valueOf(expiringCredentialRefreshConfig.loginRefreshWindowJitter())); assertEquals(Short.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_MIN_PERIOD_SECONDS), Short.valueOf(expiringCredentialRefreshConfig.loginRefreshMinPeriodSeconds())); assertEquals(Short.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_BUFFER_SECONDS), Short.valueOf(expiringCredentialRefreshConfig.loginRefreshBufferSeconds())); "<AssertPlaceHolder>"; }
loginRefreshReloginAllowedBeforeLogout() { return loginRefreshReloginAllowedBeforeLogout; }
[*] target: assertTrue(expiringCredentialRefreshConfig.loginRefreshReloginAllowedBeforeLogout())
[-] pred: org. junit. Assert. assertTrue ( expiringCredentialRefreshConfig. loginRefreshReloginAllowedBeforeLogout() )
************************************
************************************
[+] input: testGetCompileTransitiveDependenciesRIFE2() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("com.uwyn.rife2", "rife2")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(1, dependencies.size()); assertEquals(""" com.uwyn.rife2:rife2""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: testGetCompileTransitiveDependenciesJettyFullArtifactExclusion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14)) .exclude("*", "jetty-http") .exclude("*", "slf4j-api")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(4, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14 org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.eclipse.jetty:jetty-io:11.0.14 org.eclipse.jetty:jetty-util:11.0.14""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: buildUndoSQL() { String sql = executor.buildUndoSQL().toLowerCase(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("update")); Assertions.assertTrue(sql.contains("id")); Assertions.assertTrue(sql.contains("age")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); // TODO } Row row = beforeImageRows.get(0);  List<Field> nonPkFields = row.nonPrimaryKeys(); // update sql undo log before image all field come from table meta. need add escape. // see BaseTransactionalExecutor#buildTableRecords String updateColumns = nonPkFields.stream().map( field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.MYSQL) + " = ?").collect( Collectors.joining(", "));  List<String> pkNameList = getOrderedPkList(beforeImage, row, JdbcConstants.MYSQL).stream().map(e -> e.getName()) .collect(Collectors.toList()); String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList, JdbcConstants.MYSQL);  return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(), updateColumns, whereSql); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: shouldGetHostsForStore() { when(streamsMetadata.stateStoreNames()) .thenReturn(Set.of("store"));  when(streamsMetadata.hostInfo()) .thenReturn(new HostInfo("host1", 1234));  when(streamsMetadata.topicPartitions()) .thenReturn(Set.of(new TopicPartition("topic", 0)));  when(interactiveQueriesService.getStreamsMetadataForStore("store")) .thenReturn(List.of(streamsMetadata));  List<com.michelin.kstreamplify.store.StreamsMetadata> response = interactiveQueriesController.getStreamsMetadataForStore("store").getBody();  "<AssertPlaceHolder>"; assertEquals(streamsMetadata.stateStoreNames(), response.get(0).getStateStoreNames()); assertEquals(streamsMetadata.hostInfo().host(), response.get(0).getHostInfo().host()); assertEquals(streamsMetadata.hostInfo().port(), response.get(0).getHostInfo().port()); assertTrue(response.get(0).getTopicPartitions().contains("topic-0")); }
getStreamsMetadataForStore(@PathVariable("store") final String store) { return ResponseEntity .ok() .contentType(MediaType.APPLICATION_JSON) .body(interactiveQueriesService.getStreamsMetadataForStore(store) .stream() .map(streamsMetadata -> new StreamsMetadata( streamsMetadata.stateStoreNames(), streamsMetadata.hostInfo(), streamsMetadata.topicPartitions())) .toList() ); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: convertAssignment2Test() { ASTTransformer transformer = new ASTTransformer();  // Import Namespace ScalarValues Resource namespaceResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertAssignmentTest/assignment2.ast.json").readAllBytes()); namespaceResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) namespaceResource.getContents().get(0); Package packageAssignment1 = (Package) namespace.getMember().get(0);  ActionUsage actionUsageCounter = (ActionUsage) packageAssignment1.getMember().get(0); AttributeUsage attributeUsagecount = (AttributeUsage) actionUsageCounter.getMember().get(0); AssignmentActionUsage assignmentActionUsage = (AssignmentActionUsage) actionUsageCounter.getMember().get(1);  assertEquals(attributeUsagecount, assignmentActionUsage.getReferent());  // to check and fix if needed OperatorExpression operatorExpression = (OperatorExpression) assignmentActionUsage.getTargetArgument(); // assertEquals("+", operatorExpression.getOperator()); // To implement assertEquals(1, (LiteralInteger) operatorExpression.getOperand().get(0));  Expression expression = assignmentActionUsage.getValueExpression(); // Expression -> 1  assertEquals(null, expression);  }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(namespaceResource)
[-] pred: org. junit. Assert. assertNotNull ( namespaceResource )
************************************
************************************
[+] input: testReplaceAtJsonNodeLoud() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE); ((ArrayNode) expected.get(ONE)).set(1, REPLACEMENT_JSON);  final JsonNode actual = JsonPaths.replaceAtJsonNodeLoud(JSON_NODE, LIST_ONE_QUERY, REPLACEMENT_JSON); "<AssertPlaceHolder>"; }); }
replaceAtJsonNodeLoud(final JsonNode json, final String jsonPath, final JsonNode replacement) { assertIsJsonPath(jsonPath); return JsonPath.parse(Jsons.clone(json)).set(jsonPath, replacement).json(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { try (SqlSession session = getSessionFactory().openSession()) { S3StreamSetObjectMapper mapper = session.getMapper(S3StreamSetObjectMapper.class);  S3StreamSetObject walObject = new S3StreamSetObject(); walObject.setNodeId(1); walObject.setObjectSize(128L); walObject.setObjectId(2L); walObject.setSequenceId(3L); walObject.setBaseDataTimestamp(new Date()); walObject.setCommittedTimestamp(new Date()); walObject.setCreatedTimestamp(new Date()); SubStreams subStreams = SubStreams.newBuilder() .putSubStreams(1, SubStream.newBuilder().setStreamId(1).setStartOffset(0).setEndOffset(10).build()) .putSubStreams(2, SubStream.newBuilder().setStreamId(2).setStartOffset(0).setEndOffset(10).build()) .putSubStreams(3, SubStream.newBuilder().setStreamId(3).setStartOffset(0).setEndOffset(10).build()) .build(); walObject.setSubStreams(JsonFormat.printer().print(subStreams)); int rowsAffected = mapper.create(walObject); Assertions."<AssertPlaceHolder>";  Assertions.assertTrue(mapper.streamExclusive(1, 1)); Assertions.assertTrue(mapper.streamExclusive(1, 2)); Assertions.assertTrue(mapper.streamExclusive(1, 3));  Assertions.assertFalse(mapper.streamExclusive(2, 1)); Assertions.assertFalse(mapper.streamExclusive(2, 2)); Assertions.assertFalse(mapper.streamExclusive(2, 3)); } }
setSubStreams(String subStreams) { this.subStreams = subStreams; }
[*] target: assertEquals(1, rowsAffected)
[-] pred: org. junit. Assert. assertEquals ( 1, rowsAffected )
************************************
************************************
[+] input: shouldGetByKey() { when(interactiveQueriesService.getByKey("store", "key")) .thenReturn(new StateStoreRecord("key1", "value1", 1L));  StateStoreRecord response = interactiveQueriesController .getByKey("store", "key").getBody();  "<AssertPlaceHolder>"; assertEquals("key1", response.getKey()); assertEquals("value1", response.getValue()); assertEquals(1L, response.getTimestamp()); }
getByKey(@PathVariable("store") String store, @PathVariable("key") String key) { return ResponseEntity .ok() .contentType(MediaType.APPLICATION_JSON) .body(interactiveQueriesService.getByKey(store, key)); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testCreateConfigsDatabaseAvailabilityCheck() { final var dslContext = mock(DSLContext.class); final var timeoutMs = 500L; final var check = DatabaseCheckFactory.createConfigsDatabaseAvailabilityCheck(dslContext, timeoutMs);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(ConfigsDatabaseAvailabilityCheck.class, check.getClass()); Assertions.assertEquals(timeoutMs, check.getTimeoutMs()); Assertions.assertTrue(check.getDslContext().isPresent()); Assertions.assertEquals(dslContext, check.getDslContext().get()); }
createConfigsDatabaseAvailabilityCheck(final DSLContext dslContext, final long timeoutMs) { return new ConfigsDatabaseAvailabilityCheck(dslContext, timeoutMs); }
[*] target: assertNotNull(check)
[-] pred: org. junit. Assert. assertNotNull ( check )
************************************
************************************
[+] input: convertImportTest() { ASTTransformer transformer = new ASTTransformer();  // Import Namespace ScalarValues Resource namespaceResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertImportTest/model.ast.json").readAllBytes()); namespaceResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace testNamespace = (Namespace) namespaceResource.getContents().get(0);  PartUsage p11 = (PartUsage) testNamespace.resolve("ImportTest::Pkg1::p11").getMemberElement(); PartDefinition p211 = (PartDefinition) testNamespace.resolve("ImportTest::Pkg2::Pkg21::Pkg211::P211").getMemberElement(); PartDefinition p12 = (PartDefinition) testNamespace.resolve("ImportTest::Pkg1::P12").getMemberElement();  assertEquals(p211, p11.getOwnedSpecialization().get(0).getGeneral()); assertEquals(p12, p211.getOwnedSubclassification().get(0).getSuperclassifier()); }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(namespaceResource)
[-] pred: org. junit. Assert. assertNotNull ( namespaceResource )
************************************
************************************
[+] input: IOException { testAssociateAndDisassociateTagsWithMetadataObject();  TagMetaService tagMetaService = TagMetaService.getInstance();  // Test list tags for catalog List<TagEntity> tagEntities = tagMetaService.listTagsForMetadataObject( NameIdentifier.of(metalakeName, "catalog1"), Entity.EntityType.CATALOG); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue( tagEntities.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag2"))); Assertions.assertTrue( tagEntities.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag3")));  // Test list tags for schema List<TagEntity> tagEntities1 = tagMetaService.listTagsForMetadataObject( NameIdentifier.of(metalakeName, "catalog1", "schema1"), Entity.EntityType.SCHEMA);  Assertions.assertEquals(2, tagEntities1.size()); Assertions.assertTrue( tagEntities1.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag2"))); Assertions.assertTrue( tagEntities1.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag3")));  // Test list tags for table List<TagEntity> tagEntities2 = tagMetaService.listTagsForMetadataObject( NameIdentifier.of(metalakeName, "catalog1", "schema1", "table1"), Entity.EntityType.TABLE);  Assertions.assertEquals(2, tagEntities2.size()); Assertions.assertTrue( tagEntities2.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag2"))); Assertions.assertTrue( tagEntities2.stream().anyMatch(tagEntity -> tagEntity.name().equals("tag3")));  // Test list tags for non-existent metadata object Assertions.assertThrows( NoSuchEntityException.class, () -> tagMetaService.listTagsForMetadataObject( NameIdentifier.of(metalakeName, "catalog1", "schema1", "table2"), Entity.EntityType.TABLE)); }
getInstance() { return INSTANCE; }
[*] target: assertEquals(2, tagEntities.size())
[-] pred: org. junit. Assert. assertEquals ( 2, tagEntities. size ( ) )
************************************
************************************
[+] input: testCompareWithUnknownTaggedFields() { CreateTopicsRequestData createTopics = new CreateTopicsRequestData(); createTopics.setTimeoutMs(123); CreateTopicsRequestData createTopics2 = new CreateTopicsRequestData(); createTopics2.setTimeoutMs(123); assertEquals(createTopics, createTopics2); assertEquals(createTopics2, createTopics); // Call the accessor, which will create a new empty list. createTopics.unknownTaggedFields(); // Verify that the equalities still hold after the new empty list has been created. assertEquals(createTopics, createTopics2); assertEquals(createTopics2, createTopics); createTopics.unknownTaggedFields().add(new RawTaggedField(0, new byte[] {0})); assertNotEquals(createTopics, createTopics2); assertNotEquals(createTopics2, createTopics); createTopics2.unknownTaggedFields().add(new RawTaggedField(0, new byte[] {0})); "<AssertPlaceHolder>"; assertEquals(createTopics2, createTopics); }
unknownTaggedFields();
[*] target: assertEquals(createTopics, createTopics2)
[-] pred: org. junit. Assert. assertEquals ( createTopics, createTopics2 )
************************************
************************************
[+] input: Exception { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken); // Act final ReturnT<String> retval = executorBiz.beat();  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(200, retval.getCode()); Assertions.assertNull(retval.getMsg()); }
beat();
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: testIntToByte() { int v = 258; byte[] b = ByteUtils.intToByte(v); Assertions.assertArrayEquals(new byte[] {0x00, 0x00, 0x01, 0x02}, b); int v2 = ByteUtils.byteToInt(b); Assertions."<AssertPlaceHolder>"; }
byteToInt(byte[] bytes) { ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES); buffer.order(ByteOrder.BIG_ENDIAN); buffer.put(bytes); buffer.flip(); return buffer.getInt(); }
[*] target: assertEquals(v, v2)
[-] pred: org. junit. Assert. assertEquals ( v, v2 )
************************************
************************************
[+] input: testToken() { OAuthBearerValidatorCallback callback = new OAuthBearerValidatorCallback(TOKEN.value()); callback.token(TOKEN); assertSame(TOKEN, callback.token()); assertNull(callback.errorStatus()); assertNull(callback.errorScope()); "<AssertPlaceHolder>"; }
errorOpenIDConfiguration() { return errorOpenIDConfiguration; }
[*] target: assertNull(callback.errorOpenIDConfiguration())
[-] pred: org. junit. Assert. assertNull ( callback. errorOpenIDConfiguration() )
************************************
************************************
[+] input: testAssignOnEmptyTopicPartition() { consumer = newConsumer(); completeUnsubscribeApplicationEventSuccessfully();  consumer.assign(Collections.emptyList()); assertTrue(consumer.subscription().isEmpty()); "<AssertPlaceHolder>"; }
assignment() { acquireAndEnsureOpen(); try { return Collections.unmodifiableSet(subscriptions.assignedPartitions()); } finally { release(); } }
[*] target: assertTrue(consumer.assignment().isEmpty())
[-] pred: org. junit. Assert. assertTrue ( consumer. assignment(). isEmpty ( ) )
************************************
************************************
[+] input: testJoinPrepareAndCommitCompleted() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE); int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId); coordinator.invokeCompletedOffsetCommitCallbacks();  "<AssertPlaceHolder>"; assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: givenServerHttpRequestAndServerHttpResponseAndWebSocketHandlerAndMapAttributes_whenBeforeHandshake_thenTokenNull() { // Given when(request.getURI()).thenReturn(URI.create("/websocket/"));  // When Map<String, Object> attributes = new HashMap<>(); boolean result = webSocketInterceptor.beforeHandshake(request, response, wsHandler, attributes);  // Then "<AssertPlaceHolder>"; assertTrue(attributes.isEmpty()); verify(jwtTokenProvider, never()).validateToken(anyString()); }
beforeHandshake(@NonNull ServerHttpRequest request, @NonNull ServerHttpResponse response, @NonNull WebSocketHandler wsHandler, @NonNull Map<String, Object> attributes) { log.debug("Received an incoming websocket channel request"); String token = getTokenFromPath(request.getURI().getPath()); if (token == null || !jwtTokenProvider.validateToken(token, false)) { log.error("Invalid token or token not present in WebSocket request"); return false; } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testSnapshot() { SnapshottableSamples sequence = new SnapshottableSamples(512); for (int i = 0; i < 1000; i++) { sequence.append(i); } for (int i = 0; i < 100; i++) { sequence.snapshot(); } Snapshot snapshot = sequence.snapshot(); Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(snapshot.getPrev()); Assertions.assertNull(snapshot.getPrev().getPrev()); }
snapshot() { if (this.prev != null) { this.prev.setPrev(null); } Snapshot snapshot = new Snapshot(prev, values); this.prev = snapshot; return snapshot; }
[*] target: assertNotNull(snapshot)
[-] pred: org. junit. Assert. assertNotNull ( snapshot )
************************************
************************************
[+] input: IOException { PartitionMetadataFile partitionMetadataFile = new PartitionMetadataFile(file, null);  Uuid topicId = Uuid.randomUuid(); partitionMetadataFile.record(topicId); partitionMetadataFile.maybeFlush();  // The following content is encoded by PartitionMetadata#encode, which is invoked during the flush List<String> lines = Files.readAllLines(file.toPath()); "<AssertPlaceHolder>"; assertEquals("version: 0", lines.get(0)); assertEquals("topic_id: " + topicId, lines.get(1)); }
maybeFlush() { // We check dirtyTopicId first to avoid having to take the lock unnecessarily in the frequently called log append path if (dirtyTopicIdOpt.isPresent()) { // We synchronize on the actual write to disk synchronized (lock) { dirtyTopicIdOpt.ifPresent(topicId -> { try { try (FileOutputStream fileOutputStream = new FileOutputStream(tempPath().toFile()); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fileOutputStream, StandardCharsets.UTF_8))) { writer.write(new PartitionMetadata(CURRENT_VERSION, topicId).encode()); writer.flush(); fileOutputStream.getFD().sync(); }  Utils.atomicMoveWithFallback(tempPath(), path()); } catch (IOException e) { String msg = "Error while writing partition metadata file " + file.getAbsolutePath(); logDirFailureChannel.maybeAddOfflineLogDir(logDir(), msg, e); throw new KafkaStorageException(msg, e); } dirtyTopicIdOpt = Optional.empty(); }); } } }
[*] target: assertEquals(2, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 2, lines. size ( ) )
************************************
************************************
[+] input: testBuildSentryExceptionsDbtDatabaseErrorDefault() { final String stacktrace = """ AirbyteDbtError:\s 1 of 1 ERROR creating table model public.midaug_start_users............................................................. [[31mERROR[0m in 0.24s] [33mDatabase Error in model midaug_start_users (models/generated/airbyte_incremental/public/midaug_start_users.sql)[0m 1292 (22007): Truncated incorrect DOUBLE value: 'ABC' compiled SQL at ../build/run/airbyte_utils/models/generated/airbyte_incremental/public/midaug_start_users.sql 1 of 1 ERROR creating table model public.midaug_start_users............................................................. [[31mERROR[0m in 0.24s] [33mDatabase Error in model midaug_start_users (models/generated/airbyte_incremental/public/midaug_start_users.sql)[0m 1292 (22007): Truncated incorrect DOUBLE value: 'ABC' compiled SQL at ../build/run/airbyte_utils/models/generated/airbyte_incremental/public/midaug_start_users.sql """;  final Optional<SentryParsedException> optionalSentryExceptions = exceptionHelper.buildSentryExceptions(stacktrace); Assertions."<AssertPlaceHolder>";  final SentryParsedException parsedException = optionalSentryExceptions.get(); final List<SentryException> exceptionList = parsedException.exceptions(); Assertions.assertEquals(SentryExceptionPlatform.OTHER, parsedException.platform()); Assertions.assertEquals(1, exceptionList.size());  assertExceptionContent(exceptionList.get(0), "DbtDatabaseError", "1292 (22007): Truncated incorrect DOUBLE value: 'ABC'", List.of()); }
buildSentryExceptions(final String stacktrace) { return Exceptions.swallowWithDefault(() -> { if (stacktrace.startsWith("Traceback (most recent call last):")) { return buildPythonSentryExceptions(stacktrace); } if (stacktrace.contains("\tat ") && (stacktrace.contains(".java") || stacktrace.contains(".kt"))) { return buildJavaSentryExceptions(stacktrace); } if (stacktrace.startsWith("AirbyteDbtError: ")) { return buildNormalizationDbtSentryExceptions(stacktrace); }  return Optional.empty(); }, Optional.empty()); }
[*] target: assertTrue(optionalSentryExceptions.isPresent())
[-] pred: org. junit. Assert. assertTrue ( optionalSentryExceptions. isPresent ( ) )
************************************
************************************
[+] input: testMatchesSupportedProtocols() { JoinGroupRequestProtocolCollection protocols = new JoinGroupRequestProtocolCollection(); protocols.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[]{0}));  ClassicGroupMember member = new ClassicGroupMember( "member", Optional.of("group-instance-id"), "client-id", "client-host", 10, 4500, "generic", protocols, new byte[0] );  JoinGroupRequestProtocolCollection collection = new JoinGroupRequestProtocolCollection(); collection.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[] {0}));  assertTrue(member.matches(collection));  collection = new JoinGroupRequestProtocolCollection(); collection.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[] {1}));  assertFalse(member.matches(collection));  collection = new JoinGroupRequestProtocolCollection(); collection.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[0]));  assertFalse(member.matches(collection));  collection = new JoinGroupRequestProtocolCollection(); collection.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[0]));  collection.add(new JoinGroupRequestProtocol() .setName("roundrobin") .setMetadata(new byte[0]));  assertFalse(member.matches(collection)); "<AssertPlaceHolder>"; }
matches(JoinGroupRequestProtocolCollection protocols) { return protocols.equals(this.supportedProtocols); }
[*] target: assertTrue(member.matches(protocols))
[-] pred: org. junit. Assert. assertTrue ( member. matches ( protocols ) )
************************************
************************************
[+] input: testLimit_User_LimitFound() { Config config = new Config();  Role role1 = new Role(); Limit limit = new Limit(); limit.setDay(10000); limit.setMinute(100); role1.setLimits(Map.of("model", limit));  Role role2 = new Role(); limit = new Limit(); limit.setDay(20000); limit.setMinute(200); role2.setLimits(Map.of("model", limit));  config.getRoles().put("role1", role1); config.getRoles().put("role2", role2);  ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setPerRequestKey("per-request-key"); apiKeyData.setExtractedClaims(new ExtractedClaims("sub", List.of("role1", "role2"), "user-hash", Map.of())); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, null, "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  when(vertx.executeBlocking(any(Callable.class), eq(false))).thenAnswer(invocation -> { Callable<?> callable = invocation.getArgument(0); return Future.succeededFuture(callable.call()); });  TokenUsage tokenUsage = new TokenUsage(); tokenUsage.setTotalTokens(150); proxyContext.setTokenUsage(tokenUsage);  Future<Void> increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  Future<RateLimitResult> checkLimitFuture = rateLimiter.limit(proxyContext);  assertNotNull(checkLimitFuture); assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.OK, checkLimitFuture.result().status());  increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  checkLimitFuture = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.TOO_MANY_REQUESTS, checkLimitFuture.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(checkLimitFuture)
[-] pred: org. junit. Assert. assertNotNull ( checkLimitFuture )
************************************
************************************
[+] input: testDropPartition() { Partition testDrop = Partitions.identity( "p3", new String[][] {{"col1"}}, new Literal[] {Literals.stringLiteral("v2")}, Maps.newHashMap()); partitionOperationDispatcher.addPartition(TABLE_IDENT, testDrop); Assertions.assertTrue( partitionOperationDispatcher.partitionExists(TABLE_IDENT, testDrop.name()));  Assertions.assertTrue( partitionOperationDispatcher.partitionExists(TABLE_IDENT, testDrop.name()));  boolean dropped = partitionOperationDispatcher.dropPartition(TABLE_IDENT, testDrop.name()); Assertions."<AssertPlaceHolder>"; Assertions.assertFalse( partitionOperationDispatcher.partitionExists(TABLE_IDENT, testDrop.name())); }
dropPartition(NameIdentifier tableIdent, String partitionName) { return doWithTable( tableIdent, p -> p.dropPartition(partitionName), NoSuchPartitionException.class); }
[*] target: assertTrue(dropped)
[-] pred: org. junit. Assert. assertTrue ( dropped )
************************************
************************************
[+] input: testShouldEmitMetricSelectorNone() { ClientTelemetryEmitter emitter = new ClientTelemetryEmitter(ClientTelemetryUtils.SELECTOR_NO_METRICS, true);  assertFalse(emitter.shouldEmitMetric(new MetricKey("io.test.metric"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("io.test.metric1"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("io.test.metric.producer.bytes"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("io.test"))); assertFalse(emitter.shouldEmitMetric(new MetricKey("org.io.test.metric"))); "<AssertPlaceHolder>"; }
shouldEmitDeltaMetrics() { return deltaMetrics; }
[*] target: assertTrue(emitter.shouldEmitDeltaMetrics())
[-] pred: org. junit. Assert. assertTrue ( emitter. shouldEmitDeltaMetrics() )
************************************
************************************
[+] input: Exception { List<String> producerProps = Collections.singletonList("client.id=producer-1");  Properties prop = ProducerPerformance.readProps(producerProps, null, "1234", true);  "<AssertPlaceHolder>"; assertEquals("producer-1", prop.getProperty("client.id")); }
readProps(List<String> producerProps, String producerConfig, String transactionalId, boolean transactionsEnabled) throws IOException { Properties props = new Properties(); if (producerConfig != null) { props.putAll(Utils.loadProps(producerConfig)); } if (producerProps != null) for (String prop : producerProps) { String[] pieces = prop.split("="); if (pieces.length != 2) throw new IllegalArgumentException("Invalid property: " + prop); props.put(pieces[0], pieces[1]); }  props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); if (transactionsEnabled) props.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, transactionalId); if (props.getProperty(ProducerConfig.CLIENT_ID_CONFIG) == null) { props.put(ProducerConfig.CLIENT_ID_CONFIG, "perf-producer-client"); } return props; }
[*] target: assertNotNull(prop)
[-] pred: org. junit. Assert. assertNotNull ( prop )
************************************
************************************
[+] input: testReadCheckpointsTopicError() { Set<String> consumerGroups = new HashSet<>(); consumerGroups.add("group1");  MirrorCheckpointTaskConfig config = mock(MirrorCheckpointTaskConfig.class); when(config.checkpointsTopic()).thenReturn("checkpoint.topic");  try (CheckpointStore store = new CheckpointStore(config, consumerGroups) { @Override void readCheckpointsImpl(MirrorCheckpointTaskConfig config, Callback<ConsumerRecord<byte[], byte[]>> consumedCallback) { consumedCallback.onCompletion(null, newCheckpointRecord("group1", "topic", 1, 0, 0)); consumedCallback.onCompletion(new TopicAuthorizationException("test"), null); } }) {  assertFalse(store.start(), "expected start to return failure"); "<AssertPlaceHolder>"; assertTrue(store.checkpointsPerConsumerGroup.isEmpty()); } }
isInitialized() { return isInitialized; }
[*] target: assertTrue(store.isInitialized())
[-] pred: org. junit. Assert. assertTrue ( store. isInitialized() )
************************************
************************************
[+] input: decodeJsonString() { final String encodedString = niceJson("hello `b `n `b `u1234 "); final String result = CharArrayUtils.decodeJsonString(encodedString.toCharArray(), 0, encodedString.length());  final int expectedCount = encodedString.length() - 3 - 5; "<AssertPlaceHolder>"; assertEquals("hello \b \n \b \u1234 ", result); }
decodeJsonString(char[] chars, int startIndex, int endIndex) { int length = endIndex - startIndex; char[] builder = new char[calculateLengthAfterEncoding(chars, startIndex, endIndex, length)]; char c; int index = startIndex; int idx = 0;  while (true) { c = chars[index]; if (c == '\' && index < (endIndex - 1)) { index++; c = chars[index]; if (c != 'u') { builder[idx] = controlMap[c]; idx++; } else {  if (index + 4 < endIndex) { char unicode = getUnicode(chars, index); builder[idx] = unicode; index += 4; idx++; } }  } else { builder[idx] = c; idx++; } if (index >= (endIndex - 1)) { break; } index++; } return new String(builder);  }
[*] target: assertEquals(expectedCount, result.length())
[-] pred: org. junit. Assert. assertEquals ( expectedCount, result. length ( ) )
************************************
************************************
[+] input: testCreateToken() { Long userId = 1L;  RefreshTokenProvider refreshTokenProvider = new RefreshTokenProvider(validTimeInDays); RefreshToken refreshToken = refreshTokenProvider.createToken(userId);  "<AssertPlaceHolder>"; assertEquals(userId, refreshToken.userId()); assertTrue(refreshToken.expiredAt().isAfter(LocalDateTime.now().minusDays(1)));  LocalDateTime expectedExpirationTime = LocalDateTime.now().plusDays(validTimeInDays); assertEquals(expectedExpirationTime.truncatedTo(ChronoUnit.SECONDS), refreshToken.expiredAt().truncatedTo(ChronoUnit.SECONDS)); }
createToken(Long userId) { return RefreshToken.create(userId, validTimeInDays); }
[*] target: assertNotNull(refreshToken)
[-] pred: org. junit. Assert. assertNotNull ( refreshToken )
************************************
************************************
[+] input: testAddToClosedQueueFails() { final BoundedConcurrentLinkedQueue<Record> queue = getQueue(defaultMaxSize);  assertTrue(queue.add(record1)); queue.close(); assertFalse(queue.add(record2)); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, queue.size())
[-] pred: org. junit. Assert. assertEquals ( 1, queue. size() )
************************************
************************************
[+] input: testTwoNodeQuorumVoteRejected() { int otherNodeId = 1; CandidateState state = newCandidateState( voterSetWithLocal(Collections.singletonList(otherNodeId)) ); assertFalse(state.isVoteGranted()); assertFalse(state.isVoteRejected()); assertEquals(Collections.singleton(otherNodeId), state.unrecordedVoters()); assertTrue(state.recordRejectedVote(otherNodeId)); assertFalse(state.isVoteGranted()); "<AssertPlaceHolder>"; }
isVoteRejected() { return numGranted() + numUnrecorded() < majoritySize(); }
[*] target: assertTrue(state.isVoteRejected())
[-] pred: org. junit. Assert. assertTrue ( state. isVoteRejected() )
************************************
************************************
[+] input: testGetCompileDependenciesJettyOverride1() { var resolver = new DependencyResolver(new VersionResolution(new HierarchicalProperties().put(PROPERTY_OVERRIDE_PREFIX, "org.slf4j:slf4j-api:2.0.13")), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14))); var dependencies = resolver.getDirectDependencies(compile); "<AssertPlaceHolder>"; assertEquals(4, dependencies.size()); assertEquals(""" org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.eclipse.jetty:jetty-http:11.0.14 org.eclipse.jetty:jetty-io:11.0.14 org.slf4j:slf4j-api:2.0.13""", StringUtils.join(dependencies, "\n")); }
getDirectDependencies(Scope... scopes) { var pom_dependencies = getMavenPom(dependency_).getDependencies(scopes); var result = new DependencySet(); for (var dependency : pom_dependencies) { result.add(resolution_.overrideDependency(dependency.convertToDependency())); } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: convertAliasTest() { ASTTransformer transformer = new ASTTransformer();  Resource testResource = null; try { String fileContent = new String(this.getClass().getClassLoader().getResourceAsStream("ASTTransformerTest/convertAliasTest/model.ast.json").readAllBytes()); testResource = transformer.convertResource(new ByteArrayInputStream(fileContent.getBytes()), new ResourceSetImpl()); } catch (IOException e) { fail(e); }  "<AssertPlaceHolder>";  Namespace namespace = (Namespace) testResource.getContents().get(0); Package packageObject = (Package) namespace.getMember().get(0); Package definitionsPackage = (Package) packageObject.getMember().get(0); assertEquals("Definitions", definitionsPackage.getName()); assertEquals("AliasImport::Definitions", definitionsPackage.getQualifiedName()); PartDefinition vehiculePartDefinition = (PartDefinition) definitionsPackage.getOwnedElement().get(0); assertEquals("Vehicle", vehiculePartDefinition.getName());  Membership carMembership = definitionsPackage.getOwnedMembership().get(1); assertEquals("Car", carMembership.getName()); assertEquals(vehiculePartDefinition, carMembership.getMemberElement()); assertEquals(definitionsPackage, carMembership.getOwningRelatedElement()); assertEquals(definitionsPackage, carMembership.getMembershipOwningNamespace());  assertEquals(definitionsPackage.getOwnedMembership().get(0), namespace.resolve("AliasImport::Definitions::Vehicle"));  assertEquals(vehiculePartDefinition, namespace.resolve("AliasImport::Definitions::Vehicle").getMemberElement()); assertEquals(vehiculePartDefinition, namespace.resolve("AliasImport::Definitions::Car").getMemberElement());  // To check and fix if needed // assertEquals("AliasImport::Definitions::Car", carMembership.getQualifiedName()); // assertEquals(definitionsPackage, carMembership.getOwningNamespace()); // assertEquals(definitionsPackage, carMembership.getOwner());  Package usagesPackage = (Package) packageObject.getMember().get(1); assertEquals("Usages", usagesPackage.getName());  PartUsage vehiculePartUsage = (PartUsage) usagesPackage.getOwnedElement().get(0); assertEquals("vehicle", vehiculePartUsage.getName());  assertEquals(vehiculePartDefinition, vehiculePartUsage.getOwnedSpecialization().get(0).getGeneral()); }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNotNull(testResource)
[-] pred: org. junit. Assert. assertNotNull ( testResource )
************************************
************************************
[+] input: testCreateSentryHubWithDSN() { final String sentryDSN = "https://public@sentry.example.com/1"; final IHub sentryHub = SentryJobErrorReportingClient.createSentryHubWithDSN(sentryDSN); "<AssertPlaceHolder>"; assertEquals(sentryDSN, sentryHub.getOptions().getDsn()); assertFalse(sentryHub.getOptions().isAttachStacktrace()); assertFalse(sentryHub.getOptions().isEnableUncaughtExceptionHandler()); }
createSentryHubWithDSN(final String sentryDSN) { if (sentryDSN == null || sentryDSN.isEmpty()) { return NoOpHub.getInstance(); }  final SentryOptions options = new SentryOptions(); options.setDsn(sentryDSN); options.setAttachStacktrace(false); options.setEnableUncaughtExceptionHandler(false); return new Hub(options); }
[*] target: assertNotNull(sentryHub)
[-] pred: org. junit. Assert. assertNotNull ( sentryHub )
************************************
************************************
[+] input: loadPrivateKey() { Ed25519PrivateKey ed25519PrivateKey = Ed25519Utils.loadPrivateKey(PRIVATE_KEY_BYTE); PeerId peerId = PeerId.fromPubKey(ed25519PrivateKey.publicKey());  "<AssertPlaceHolder>"; assertNotNull(ed25519PrivateKey.publicKey()); assertNotNull(peerId); assertEquals(PEER_ID, peerId.toBase58()); }
loadPrivateKey(final byte[] keyData) { final Ed25519PrivateKeyParameters parameters = new Ed25519PrivateKeyParameters(keyData);  return new Ed25519PrivateKey(parameters); }
[*] target: assertNotNull(ed25519PrivateKey)
[-] pred: org. junit. Assert. assertNotNull ( ed25519PrivateKey )
************************************
************************************
[+] input: modify() { Attributes attr1 = buildAttr(1); SpanData span1 = TestSpanHelper.span("span1", attr1); Attributes attr2 = buildAttr(2); SpanData span2 = TestSpanHelper.span("span2", attr2); Attributes attr3 = buildAttr(3); SpanData span3 = TestSpanHelper.span("span3", attr3); Collection<SpanData> spans = Arrays.asList(span1, span2, span3); Map<AttributeKey<?>, Function<?, ?>> modifiers = new HashMap<>(); modifiers.put(stringKey("foo1"), x -> "" + x + x); modifiers.put(stringKey("foo3"), x -> "3" + x + x); modifiers.put(stringKey("boop2"), x -> "2" + x + x);  CompletableResultCode expectedResult = mock(CompletableResultCode.class); when(exporter.export(spansCaptor.capture())).thenReturn(expectedResult);  AttributeModifyingSpanExporter underTest = new AttributeModifyingSpanExporter(exporter, modifiers); CompletableResultCode result = underTest.export(spans); "<AssertPlaceHolder>"; assertThat(spansCaptor.getValue()) .satisfiesExactly( s -> assertThat(s) .hasAttributesSatisfyingExactly( equalTo(stringKey("foo1"), "bar1bar1"), equalTo(stringKey("bar1"), "baz1"), equalTo(stringKey("boop1"), "beep1")), s -> assertThat(s) .hasAttributesSatisfyingExactly( equalTo(stringKey("foo2"), "bar2"), equalTo(stringKey("bar2"), "baz2"), equalTo(stringKey("boop2"), "2beep2beep2")), s -> assertThat(s) .hasAttributesSatisfyingExactly( equalTo(stringKey("foo3"), "3bar3bar3"), equalTo(stringKey("bar3"), "baz3"), equalTo(stringKey("boop3"), "beep3"))); }
export(Collection<SpanData> spans) { if (spanAttributeReplacements.isEmpty()) { return delegate.export(spans); }  List<SpanData> modifiedSpans = spans.stream().map(this::doModify).collect(Collectors.toList()); return delegate.export(modifiedSpans); }
[*] target: assertSame(expectedResult, result)
[-] pred: org. junit. Assert. assertSame ( expectedResult, result )
************************************
************************************
[+] input: shouldApplyCustomTimeoutToFirstSpanAfterAppBeingMovedToForeground() { TestClock clock = TestClock.create(); SessionIdTimeoutHandler timeoutHandler = new SessionIdTimeoutHandler(clock, Duration.ofNanos(5));  timeoutHandler.onApplicationBackgrounded(); timeoutHandler.bump();  // the first span after app is moved to the foreground gets timed out timeoutHandler.onApplicationForegrounded(); clock.advance(6, TimeUnit.MINUTES); assertTrue(timeoutHandler.hasTimedOut()); timeoutHandler.bump();  // after the initial span it's the same as the usual foreground scenario clock.advance(Duration.ofHours(4)); "<AssertPlaceHolder>"; }
hasTimedOut() { // don't apply sessionId timeout to apps in the foreground if (state == State.FOREGROUND) { return false; } long elapsedTime = clock.nanoTime() - timeoutStartNanos; return elapsedTime >= sessionTimeout.toNanos(); }
[*] target: assertFalse(timeoutHandler.hasTimedOut())
[-] pred: org. junit. Assert. assertFalse ( timeoutHandler. hasTimedOut() )
************************************
************************************
[+] input: testUpdateMember() { JoinGroupRequestProtocolCollection protocols = new JoinGroupRequestProtocolCollection(); protocols.add(new JoinGroupRequestProtocol() .setName("roundrobin") .setMetadata(new byte[0]));  ClassicGroupMember member = new ClassicGroupMember( memberId, Optional.empty(), clientId, clientHost, rebalanceTimeoutMs, sessionTimeoutMs, protocolType, protocols );  group.add(member);  JoinGroupRequestProtocolCollection newProtocols = new JoinGroupRequestProtocolCollection(); newProtocols.add(new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[0]));  newProtocols.add(new JoinGroupRequestProtocol() .setName("roundrobin") .setMetadata(new byte[0]));  int newRebalanceTimeoutMs = 120000; int newSessionTimeoutMs = 20000; group.updateMember(member, newProtocols, newRebalanceTimeoutMs, newSessionTimeoutMs, null);  assertEquals(group.rebalanceTimeoutMs(), newRebalanceTimeoutMs); assertEquals(member.sessionTimeoutMs(), newSessionTimeoutMs); "<AssertPlaceHolder>"; }
supportedProtocols() { return supportedProtocols; }
[*] target: assertEquals(newProtocols, member.supportedProtocols())
[-] pred: org. junit. Assert. assertEquals ( newProtocols, member. supportedProtocols() )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/getRefundHistoryResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v2/refund/lookup/555555", request.url().encodedPath()); Assertions.assertEquals("revision_input", request.url().queryParameter("revision")); Assertions."<AssertPlaceHolder>"; });  RefundHistoryResponse refundHistoryResponse = client.getRefundHistory("555555", "revision_input");  Assertions.assertNotNull(refundHistoryResponse); Assertions.assertEquals(List.of("signed_transaction_one", "signed_transaction_two"), refundHistoryResponse.getSignedTransactions()); Assertions.assertEquals("revision_output", refundHistoryResponse.getRevision()); Assertions.assertTrue(refundHistoryResponse.getHasMore()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred: org. junit. Assert. assertNull ( request. body() )
************************************
************************************
[+] input: testEqualsWithoutGroupInstanceId() { MemberDescription dynamicMemberDescription = new MemberDescription(MEMBER_ID, CLIENT_ID, HOST, ASSIGNMENT);  MemberDescription identityDescription = new MemberDescription(MEMBER_ID, CLIENT_ID, HOST, ASSIGNMENT);  assertNotEquals(STATIC_MEMBER_DESCRIPTION, dynamicMemberDescription); assertNotEquals(STATIC_MEMBER_DESCRIPTION.hashCode(), dynamicMemberDescription.hashCode());  // Check self equality. assertEquals(dynamicMemberDescription, dynamicMemberDescription); assertEquals(dynamicMemberDescription, identityDescription); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(memberId, groupInstanceId, clientId, host, assignment, targetAssignment); }
[*] target: assertEquals(dynamicMemberDescription.hashCode(), identityDescription.hashCode())
[-] pred: org. junit. Assert. assertEquals ( dynamicMemberDescription. hashCode(), identityDescription. hashCode() )
************************************
************************************
[+] input: JsonProcessingException { doCallRealMethod().when(context).setStreamingRequest(anyBoolean()); when(context.isStreamingRequest()).thenCallRealMethod();  Throwable error = fn.apply((ObjectNode) ProxyUtil.MAPPER.readTree("{"stream": true}"));  "<AssertPlaceHolder>"; assertTrue(context.isStreamingRequest()); }
apply(ObjectNode tree) { JsonNode stream = tree.get("stream"); boolean result = stream != null && stream.asBoolean(false); context.setStreamingRequest(result); return null; }
[*] target: assertNull(error)
[-] pred: org. junit. Assert. assertNull ( error )
************************************
************************************
[+] input: testHashCodeAndEqualsWithNull() { ConfigEntry ce0 = new ConfigEntry("abc", null, null, false, false, null, null, null); ConfigEntry ce1 = new ConfigEntry("abc", null, null, false, false, null, null, null); assertEquals(ce0, ce1); "<AssertPlaceHolder>"; }
hashCode() { return entries.hashCode(); }
[*] target: assertEquals(ce0.hashCode(), ce1.hashCode())
[-] pred: org. junit. Assert. assertEquals ( ce0. hashCode ( ), ce1. hashCode ( ) )
************************************
************************************
[+] input: testGetEntriesInKeyPath_NoClassFilter() { Nibbles key1 = Nibbles.fromHexString("1234"); Nibbles key2 = Nibbles.fromHexString("12345678"); PendingTrieNodeChange update1 = mock(PendingTrieNodeChange.class); PendingTrieNodeChange update2 = mock(PendingTrieNodeChange.class); changes.put(key1, update1); changes.put(key2, update2);  List<Map.Entry<Nibbles, PendingTrieNodeChange>> entries = trieChanges.getEntriesInKeyPath( null, Nibbles.fromHexString("123456789")); "<AssertPlaceHolder>"; assertEquals(update1, entries.get(0).getValue()); assertEquals(update2, entries.get(1).getValue()); }
getEntriesInKeyPath( @Nullable Class<P> clazz, Nibbles key) { Stream<Map.Entry<Nibbles, PendingTrieNodeChange>> stream = changes.subMap( Nibbles.EMPTY, true, key, true).entrySet().stream();  if (clazz != null) { stream = stream .filter(e -> clazz.isInstance(e.getValue())); }  return stream .filter(e -> key.startsWith(e.getKey())) .map(e -> Map.entry(e.getKey(), (P) e.getValue())) .toList(); }
[*] target: assertEquals(2, entries.size())
[-] pred: org. junit. Assert. assertEquals ( 2, entries. size ( ) )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/getTestNotificationStatusResponse.json", request -> { Assertions.assertEquals("GET", request.method()); Assertions.assertEquals("/inApps/v1/notifications/test/8cd2974c-f905-492a-bf9a-b2f47c791d19", request.url().encodedPath()); Assertions."<AssertPlaceHolder>"; });  CheckTestNotificationResponse checkTestNotificationResponse = client.getTestNotificationStatus("8cd2974c-f905-492a-bf9a-b2f47c791d19");  Assertions.assertNotNull(checkTestNotificationResponse); Assertions.assertEquals("signed_payload", checkTestNotificationResponse.getSignedPayload()); List<SendAttemptItem> sendAttemptItems = List.of( new SendAttemptItem() .attemptDate(1698148900000L) .sendAttemptResult(SendAttemptResult.NO_RESPONSE), new SendAttemptItem() .attemptDate(1698148950000L) .sendAttemptResult(SendAttemptResult.SUCCESS) ); Assertions.assertEquals(sendAttemptItems, checkTestNotificationResponse.getSendAttempts()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNull(request.body())
[-] pred: org. junit. Assert. assertNull ( request. body() )
************************************
************************************
[+] input: testBlockTreeIsDescendantOf() { Pair<BlockTree, List<Hash256>> result = createFlatTree(4); BlockTree bt = result.getValue0(); List<Hash256> hashes = result.getValue1();  boolean isDescendant = bt.isDescendantOf(bt.getRoot().getHash(), hashes.get(3)); assertTrue(isDescendant);  isDescendant = bt.isDescendantOf(hashes.get(3), bt.getRoot().getHash()); "<AssertPlaceHolder>"; }
isDescendantOf(final Hash256 parent, final Hash256 child) { if (Objects.equals(parent, child)) { return true; }  BlockNode parentBlockNode = getNode(parent); if (parentBlockNode == null) { throw new BlockNodeNotFoundException("Start node not found: " + parent); }  BlockNode childBlockNode = getNode(child); if (childBlockNode == null) { throw new BlockNodeNotFoundException("End node not found: " + child); }  return childBlockNode.isDescendantOf(parentBlockNode); }
[*] target: assertFalse(isDescendant)
[-] pred: org. junit. Assert. assertFalse ( isDescendant )
************************************
************************************
[+] input: testLimit_User_RequestLimit() { Config config = new Config();  Role role1 = new Role(); Limit limit = new Limit(); limit.setRequestDay(10); limit.setRequestHour(1); role1.setLimits(Map.of("model", limit));  Role role2 = new Role(); limit = new Limit(); limit.setRequestDay(20); limit.setRequestHour(1); role2.setLimits(Map.of("model", limit));  config.getRoles().put("role1", role1); config.getRoles().put("role2", role2);  ApiKeyData apiKeyData = new ApiKeyData(); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, new ExtractedClaims("sub", List.of("role1", "role2"), "user-hash", Map.of()), "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  when(vertx.executeBlocking(any(Callable.class), eq(false))).thenAnswer(invocation -> { Callable<?> callable = invocation.getArgument(0); return Future.succeededFuture(callable.call()); });  TokenUsage tokenUsage = new TokenUsage(); tokenUsage.setTotalTokens(150); proxyContext.setTokenUsage(tokenUsage);  Future<Void> increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  Future<RateLimitResult> checkLimitFuture = rateLimiter.limit(proxyContext);  assertNotNull(checkLimitFuture); assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.OK, checkLimitFuture.result().status());  increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  checkLimitFuture = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.TOO_MANY_REQUESTS, checkLimitFuture.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(checkLimitFuture)
[-] pred: org. junit. Assert. assertNotNull ( checkLimitFuture )
************************************
************************************
[+] input: testAttributes() { ApiMessageAndVersion key = new ApiMessageAndVersion(new ConsumerGroupMetadataKey(), (short) 0); ApiMessageAndVersion value = new ApiMessageAndVersion(new ConsumerGroupMetadataValue(), (short) 0); CoordinatorRecord record = new CoordinatorRecord(key, value); assertEquals(key, record.key()); "<AssertPlaceHolder>"; }
value() { return this.value; }
[*] target: assertEquals(value, record.value())
[-] pred: org. junit. Assert. assertEquals ( value, record. value() )
************************************
************************************
[+] input: testJellyfinCredentials() { JellyfinCredentials credentials = new JellyfinCredentials();  String baseURL = "http://localhost:8096"; credentials.setBaseURL(baseURL); assertEquals(baseURL, credentials.getBaseURL());  String tokenAPI = "token"; credentials.setTokenAPI(tokenAPI); "<AssertPlaceHolder>"; }
getTokenAPI() { return tokenAPI; }
[*] target: assertEquals(tokenAPI, credentials.getTokenAPI())
[-] pred: org. junit. Assert. assertEquals ( tokenAPI, credentials. getTokenAPI() )
************************************
************************************
[+] input: Exception { try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(mockCluster(1, 0))) { env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());  env.kafkaClient().prepareResponse(prepareMetadataResponse(env.cluster(), Errors.NONE));  env.kafkaClient().prepareResponseFrom( new ListGroupsResponse(new ListGroupsResponseData() .setErrorCode(Errors.NONE.code()) .setGroups(Arrays.asList( new ListGroupsResponseData.ListedGroup() .setGroupId("group-1") .setProtocolType(ConsumerProtocol.PROTOCOL_TYPE) .setGroupState("Stable"), new ListGroupsResponseData.ListedGroup() .setGroupId("group-2") .setGroupState("Empty")))), env.cluster().nodeById(0));  final ListConsumerGroupsOptions options = new ListConsumerGroupsOptions(); final ListConsumerGroupsResult result = env.adminClient().listConsumerGroups(options); Collection<ConsumerGroupListing> listings = result.valid().get();  "<AssertPlaceHolder>"; List<ConsumerGroupListing> expected = new ArrayList<>(); expected.add(new ConsumerGroupListing("group-2", true, Optional.of(ConsumerGroupState.EMPTY))); expected.add(new ConsumerGroupListing("group-1", false, Optional.of(ConsumerGroupState.STABLE))); assertEquals(expected, listings); assertEquals(0, result.errors().get().size()); } }
listConsumerGroups(ListConsumerGroupsOptions options) { final KafkaFutureImpl<Collection<Object>> all = new KafkaFutureImpl<>(); final long nowMetadata = time.milliseconds(); final long deadline = calcDeadlineMs(nowMetadata, options.timeoutMs()); runnable.call(new Call("findAllBrokers", deadline, new LeastLoadedNodeProvider()) { @Override MetadataRequest.Builder createRequest(int timeoutMs) { return new MetadataRequest.Builder(new MetadataRequestData() .setTopics(Collections.emptyList()) .setAllowAutoTopicCreation(true)); }  @Override void handleResponse(AbstractResponse abstractResponse) { MetadataResponse metadataResponse = (MetadataResponse) abstractResponse; Collection<Node> nodes = metadataResponse.brokers(); if (nodes.isEmpty()) throw new StaleMetadataException("Metadata fetch failed due to missing broker list");  HashSet<Node> allNodes = new HashSet<>(nodes); final ListConsumerGroupsResults results = new ListConsumerGroupsResults(allNodes, all);  for (final Node node : allNodes) { final long nowList = time.milliseconds(); runnable.call(new Call("listConsumerGroups", deadline, new ConstantNodeIdProvider(node.id())) { @Override ListGroupsRequest.Builder createRequest(int timeoutMs) { List<String> states = options.states() .stream() .map(ConsumerGroupState::toString) .collect(Collectors.toList()); List<String> groupTypes = options.types() .stream() .map(GroupType::toString) .collect(Collectors.toList()); return new ListGroupsRequest.Builder(new ListGroupsRequestData() .setStatesFilter(states) .setTypesFilter(groupTypes) ); }  private void maybeAddConsumerGroup(ListGroupsResponseData.ListedGroup group) { String protocolType = group.protocolType(); if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) { final String groupId = group.groupId(); final Optional<ConsumerGroupState> state = group.groupState().equals("") ? Optional.empty() : Optional.of(ConsumerGroupState.parse(group.groupState())); final Optional<GroupType> type = group.groupType().equals("") ? Optional.empty() : Optional.of(GroupType.parse(group.groupType())); final ConsumerGroupListing groupListing = new ConsumerGroupListing( groupId, protocolType.isEmpty(), state, type ); results.addListing(groupListing); } }  @Override void handleResponse(AbstractResponse abstractResponse) { final ListGroupsResponse response = (ListGroupsResponse) abstractResponse; synchronized (results) { Errors error = Errors.forCode(response.data().errorCode()); if (error == Errors.COORDINATOR_LOAD_IN_PROGRESS || error == Errors.COORDINATOR_NOT_AVAILABLE) { throw error.exception(); } else if (error != Errors.NONE) { results.addError(error.exception(), node); } else { for (ListGroupsResponseData.ListedGroup group : response.data().groups()) { maybeAddConsumerGroup(group); } } results.tryComplete(node); } }  @Override void handleFailure(Throwable throwable) { synchronized (results) { results.addError(throwable, node); results.tryComplete(node); } } }, nowList); } }  @Override void handleFailure(Throwable throwable) { KafkaException exception = new KafkaException("Failed to find brokers to send ListGroups", throwable); all.complete(Collections.singletonList(exception)); } }, nowMetadata);  return new ListConsumerGroupsResult(all); }
[*] target: assertEquals(2, listings.size())
[-] pred: org. junit. Assert. assertEquals ( 2, listings. size ( ) )
************************************
************************************
[+] input: shouldEmitSessionIdChangeSpan() { underTest.onChange("123", "456");  List<SpanData> spans = otelTesting.getSpans(); "<AssertPlaceHolder>"; SpanData span = spans.get(0); assertEquals("sessionId.change", span.getName()); Attributes attributes = span.getAttributes(); assertEquals(1, attributes.size()); assertEquals("123", attributes.get(PREVIOUS_SESSION_ID_KEY)); // splunk.rumSessionId attribute is set in the RumAttributeAppender class }
onChange(String oldSessionId, String newSessionId) { tracer.spanBuilder("sessionId.change") .setAttribute(RumConstants.PREVIOUS_SESSION_ID_KEY, oldSessionId) .startSpan() .end(); }
[*] target: assertEquals(1, spans.size())
[-] pred: org. junit. Assert. assertEquals ( 1, spans. size ( ) )
************************************
************************************
[+] input: wasSuccessful() { assertFalse(subject.wasSuccessful());  subject.setSuccess(true);  "<AssertPlaceHolder>"; }
wasSuccessful() { return success; }
[*] target: assertTrue(subject.wasSuccessful())
[-] pred: org. junit. Assert. assertTrue ( subject. wasSuccessful() )
************************************
************************************
[+] input: testReportJobFailureReasonWithNoWorkspace() { final ArgumentCaptor<SentryEvent> eventCaptor = ArgumentCaptor.forClass(SentryEvent.class);  final FailureReason failureReason = new FailureReason() .withFailureOrigin(FailureOrigin.SOURCE) .withFailureType(FailureType.SYSTEM_ERROR) .withInternalMessage(ERROR_MESSAGE) .withTimestamp(System.currentTimeMillis()); final ObjectMapper objectMapper = new ObjectMapper(); final AttemptConfigReportingContext attemptConfig = new AttemptConfigReportingContext(objectMapper.createObjectNode(), objectMapper.createObjectNode(), new State());  sentryErrorReportingClient.reportJobFailureReason(null, failureReason, DOCKER_IMAGE, Map.of(), attemptConfig);  verify(mockSentryHub).captureEvent(eventCaptor.capture()); final SentryEvent actualEvent = eventCaptor.getValue(); final User sentryUser = actualEvent.getUser(); "<AssertPlaceHolder>";  final Message message = actualEvent.getMessage(); assertNotNull(message); assertEquals(ERROR_MESSAGE, message.getFormatted()); }
reportJobFailureReason(@Nullable final StandardWorkspace workspace, final FailureReason failureReason, @Nullable final String dockerImage, final Map<String, String> metadata, @Nullable final AttemptConfigReportingContext attemptConfig) { final SentryEvent event = new SentryEvent();  if (dockerImage != null) { // Remove invalid characters from the release name, use @ so sentry knows how to grab the tag // e.g. airbyte/source-xyz:1.2.0 -> airbyte-source-xyz@1.2.0 // More info at https://docs.sentry.io/product/cli/releases/#creating-releases final String release = dockerImage.replace("/", "-").replace(":", "@"); event.setRelease(release);  // enhance event fingerprint to ensure separate grouping per connector final String[] releaseParts = release.split("@"); if (releaseParts.length > 0) { event.setFingerprints(List.of("{{ default }}", releaseParts[0])); } }  // set workspace as the user in sentry to get impact and priority if (workspace != null) { final User sentryUser = new User(); sentryUser.setId(String.valueOf(workspace.getWorkspaceId())); if (workspace.getName() != null) { sentryUser.setUsername(workspace.getName()); } event.setUser(sentryUser); }  // set metadata as tags event.setTags(metadata);  // set failure reason's internalMessage as event message // Sentry will use this to fuzzy-group if no stacktrace information is available final Message message = new Message(); message.setFormatted(failureReason.getInternalMessage()); event.setMessage(message);  // events can come from any platform event.setPlatform("other");  // attach failure reason stack trace final String failureStackTrace = failureReason.getStacktrace(); if (failureStackTrace != null && !failureStackTrace.isBlank()) { final Optional<SentryParsedException> optParsedException = exceptionHelper.buildSentryExceptions(failureStackTrace); if (optParsedException.isPresent()) { final SentryParsedException parsedException = optParsedException.get(); final String platform = parsedException.platform().getValue(); event.setPlatform(platform); event.setTag(STACKTRACE_PLATFORM_TAG_KEY, platform); event.setExceptions(parsedException.exceptions()); } else { event.setTag(STACKTRACE_PARSE_ERROR_TAG_KEY, "1");  // We couldn't parse the stacktrace, but we can still give it to Sentry for (less accurate) grouping final String normalizedStacktrace = failureStackTrace .replace("\n", ", ") .replace(failureReason.getInternalMessage(), "");  final SentryException sentryException = new SentryException(); sentryException.setValue(normalizedStacktrace); event.setExceptions(List.of(sentryException)); } }  // Attach contexts to provide more debugging info final Contexts contexts = event.getContexts();  final Map<String, String> failureReasonContext = new HashMap<>(); failureReasonContext.put("internalMessage", failureReason.getInternalMessage()); failureReasonContext.put("externalMessage", failureReason.getExternalMessage()); failureReasonContext.put("stacktrace", failureReason.getStacktrace()); failureReasonContext.put("timestamp", failureReason.getTimestamp().toString());  final Metadata failureReasonMeta = failureReason.getMetadata(); if (failureReasonMeta != null) { failureReasonContext.put("metadata", failureReasonMeta.toString()); }  contexts.put("Failure Reason", failureReasonContext);  if (attemptConfig != null) { final Map<String, String> stateContext = new HashMap<>(); stateContext.put("state", attemptConfig.state() != null ? attemptConfig.state().toString() : "null"); contexts.put("State", stateContext); contexts.put("Source Configuration", getContextFromNode(attemptConfig.sourceConfig())); contexts.put("Destination Configuration", getContextFromNode(attemptConfig.destinationConfig())); }  // Send the event to sentry sentryHub.captureEvent(event); }
[*] target: assertNull(sentryUser)
[-] pred: org. junit. Assert. assertNull ( sentryUser )
************************************
************************************
[+] input: testMessageOffsetOnly() { LogOffsetMetadata metadata1 = new LogOffsetMetadata(1L); LogOffsetMetadata metadata2 = new LogOffsetMetadata(1L, 0L, 1); assertTrue(UNKNOWN_OFFSET_METADATA.messageOffsetOnly()); assertFalse(metadata2.messageOffsetOnly()); "<AssertPlaceHolder>"; }
messageOffsetOnly() { return segmentBaseOffset == UNIFIED_LOG_UNKNOWN_OFFSET && relativePositionInSegment == UNKNOWN_FILE_POSITION; }
[*] target: assertTrue(metadata1.messageOffsetOnly())
[-] pred: org. junit. Assert. assertTrue ( metadata1. messageOffsetOnly() )
************************************
************************************
[+] input: getModelsTest() { //Grab OpenAI API key from system environment variables (gradle.properties) String apiKey = System.getenv("OPEN_AI_API_KEY"); String organization = System.getenv("OPEN_AI_ORGANIZATION"); assertNotNull(apiKey); assertNotNull(organization);  //Create OpenAI instance using API key & organization //Organization is optional OpenAI openAI = OpenAI.builder() .setApiKey(apiKey) .setOrganization(organization) //Call the ListModels API from OpenAI & create instance .listModels() .build() //Finally, send our request to the API, this initiates the request (after .build()) .sendRequest();  Optional<ListModels> optionalGetModels = openAI.models(); assertFalse(optionalGetModels.isEmpty());  //Additionally check the getter method is not null assertNotNull(openAI.getModels());  ListModels listModels = optionalGetModels.get();  //Data structure example ModelData[] modelData = listModels.asDataArray(); //You can view all the listed models here assertNotNull(modelData); assertTrue(modelData.length > 0);  //Data list example List<ModelData> modelList = listModels.asDataList(); assertNotNull(modelList); assertFalse(modelList.isEmpty());  //Json example String json = listModels.asJson(); "<AssertPlaceHolder>"; assertFalse(json.isEmpty()); }
asJson() { if(this.deserializedData == null) { this.deserializedData = deserialize(ModelsResponseData.class); } if (!(this.deserializedData instanceof ModelsResponseData)) { return null; } return JacksonJsonDeserializer.valuesAsString((ModelsResponseData) this.deserializedData); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: Exception { JsonNode collection = Json.toJson(""" { "name": "example_collection", "vectors": { "size": 300, "distance": "Cosine" } } """);  JsonNode json = Json.toJson(collection.toString()); "<AssertPlaceHolder>";  assertEquals("example_collection", json.get("name").asText()); JsonNode vectorConfig = json.get("vectors"); assertEquals(300, vectorConfig.get("size").asInt()); assertEquals("Cosine", vectorConfig.get("distance").asText()); }
toJson(String content) throws JsonProcessingException { JsonNode json = mapper.readTree(content); if (json == null) { return null; } return json; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: givenCorruptedKeySizeSegment_whenCheckingChecksum_thenIsChecksumValidReturnsFalse() { // Given byte[] testData = new byte[]{ (byte) -83, (byte) 64, 0x01, 0x45,         // Key Size (Bit Flipped) 0x00, 0x00, 0x00, 0x05, // Value Size 0x48, 0x65, 0x6C, 0x6C, 0x6F, // Key: "Hello" 0x57, 0x6F, 0x72, 0x6C, 0x64  // Value: "World" };  // When Segment corruptedSegment = Segment.fromByteArray(testData);  // Then assertFalse(corruptedSegment.isChecksumValid()); "<AssertPlaceHolder>"; }
isSegmentValid() { return isChecksumValid() && getKeySize() > 0 && getValueSize() >= 0 && bytes.length == CRC_LENGTH + KEY_SIZE_LENGTH + VALUE_SIZE_LENGTH + getKeySize() + getValueSize(); }
[*] target: assertFalse(corruptedSegment.isSegmentValid())
[-] pred: org. junit. Assert. assertFalse ( corruptedSegment. isSegmentValid ( ) )
************************************
************************************
[+] input: testGetAutoIncreaseColumn() { TableMeta tableMeta = new TableMeta(); ColumnMeta id = new ColumnMeta(); id.setIsAutoincrement("YES"); tableMeta.getAllColumns().put("id", id); Assertions.assertNotNull(tableMeta.getAutoIncreaseColumn());  tableMeta = new TableMeta(); tableMeta.getAllColumns().put("name", new ColumnMeta()); Assertions."<AssertPlaceHolder>"; }
getAutoIncreaseColumn() { // TODO: how about auto increment but not pk? for (Entry<String, ColumnMeta> entry : allColumns.entrySet()) { ColumnMeta col = entry.getValue(); if ("YES".equalsIgnoreCase(col.getIsAutoincrement())) { return col; } } return null; }
[*] target: assertNull(tableMeta.getAutoIncreaseColumn())
[-] pred: org. junit. Assert. assertNull ( tableMeta. getAutoIncreaseColumn ( ) )
************************************
************************************
[+] input: testStaticMemberRoundRobinAssignmentPersistent() { // Have 3 static members instance1, instance2, instance3 to be persistent // across generations. Their assignment shall be the same. String consumer1 = "consumer1"; String instance1 = "instance1"; String consumer2 = "consumer2"; String instance2 = "instance2"; String consumer3 = "consumer3"; String instance3 = "instance3";  List<MemberInfo> staticMemberInfos = new ArrayList<>(); staticMemberInfos.add(new MemberInfo(consumer1, Optional.of(instance1))); staticMemberInfos.add(new MemberInfo(consumer2, Optional.of(instance2))); staticMemberInfos.add(new MemberInfo(consumer3, Optional.of(instance3)));  // Consumer 4 is a dynamic member. String consumer4 = "consumer4";  Map<String, Integer> partitionsPerTopic = setupPartitionsPerTopicWithTwoTopics(3, 3);  Map<String, Subscription> consumers = new HashMap<>(); for (MemberInfo m : staticMemberInfos) { Subscription subscription = new Subscription(topics(topic1, topic2), null); subscription.setGroupInstanceId(m.groupInstanceId); consumers.put(m.memberId, subscription); } consumers.put(consumer4, new Subscription(topics(topic1, topic2)));  Map<String, List<TopicPartition>> expectedAssignment = new HashMap<>(); expectedAssignment.put(consumer1, partitions(tp(topic1, 0), tp(topic2, 1))); expectedAssignment.put(consumer2, partitions(tp(topic1, 1), tp(topic2, 2))); expectedAssignment.put(consumer3, partitions(tp(topic1, 2))); expectedAssignment.put(consumer4, partitions(tp(topic2, 0)));  Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers); assertEquals(expectedAssignment, assignment);  // Replace dynamic member 4 with a new dynamic member 5. consumers.remove(consumer4); String consumer5 = "consumer5"; consumers.put(consumer5, new Subscription(topics(topic1, topic2)));  expectedAssignment.remove(consumer4); expectedAssignment.put(consumer5, partitions(tp(topic2, 0))); assignment = assignor.assign(partitionsPerTopic, consumers); "<AssertPlaceHolder>"; }
assign(Map<String, Integer> partitionsPerTopic, Map<String, Subscription> subscriptions) { Map<String, List<TopicPartition>> assignment = new HashMap<>(); List<MemberInfo> memberInfoList = new ArrayList<>(); for (Map.Entry<String, Subscription> memberSubscription : subscriptions.entrySet()) { assignment.put(memberSubscription.getKey(), new ArrayList<>()); memberInfoList.add(new MemberInfo(memberSubscription.getKey(), memberSubscription.getValue().groupInstanceId())); }  CircularIterator<MemberInfo> assigner = new CircularIterator<>(Utils.sorted(memberInfoList));  for (TopicPartition partition : allPartitionsSorted(partitionsPerTopic, subscriptions)) { final String topic = partition.topic(); while (!subscriptions.get(assigner.peek().memberId).topics().contains(topic)) assigner.next(); assignment.get(assigner.next().memberId).add(partition); } return assignment; }
[*] target: assertEquals(expectedAssignment, assignment)
[-] pred: org. junit. Assert. assertEquals ( expectedAssignment, assignment )
************************************
************************************
[+] input: makeOneAuthCycle() { StartTransactionResponse response = this.rpApi.startAuthentication(CLIENT_IP);  Assertions.assertNotNull(response); Assertions.assertNotNull(response.getOrderRef()); Assertions.assertNotNull(response.getAutoStartToken()); Assertions.assertNotNull(response.getQrStartToken()); Assertions.assertNotNull(response.getQrStartSecret());  // Collect CollectResponse collectResponse = this.rpApi.collect(response.getOrderRef()); Assertions.assertNotNull(collectResponse);  Assertions.assertNotNull(collectResponse.getOrderRef()); Assertions.assertEquals(response.getOrderRef(), collectResponse.getOrderRef());  Assertions.assertNotNull(collectResponse.getStatus()); Assertions.assertEquals("pending", collectResponse.getStatus()); Assertions.assertNotNull(collectResponse.getHintCode()); Assertions.assertEquals("outstandingTransaction", collectResponse.getHintCode());  // Cancel boolean cancelResponse = this.rpApi.cancel(response.getOrderRef()); Assertions."<AssertPlaceHolder>"; }
cancel(String orderRef) { try { CancelRequest request = new CancelRequest(orderRef); ObjectMapper mapper = new ObjectMapper(); String jsonRequest = mapper.writeValueAsString(request);  long startTime = System.currentTimeMillis(); String result = this.post("cancel", jsonRequest); long elapsedTime = System.currentTimeMillis() - startTime; if (result == null) { this.logger.warn("Query to cancel transaction " + "failed after {} ms.", elapsedTime); return false; }  this.logger.info("Received json string from BankID RP after {} ms.", elapsedTime); return result.trim().equals("{}"); } catch (Exception e) { this.logger.warn("IOException while starting authentication: {}", e.getMessage()); return false; } }
[*] target: assertTrue(cancelResponse)
[-] pred: org. junit. Assert. assertTrue ( cancelResponse )
************************************
************************************
[+] input: testCreatingADslContextFromADataSource() { final SQLDialect dialect = SQLDialect.POSTGRES; final DataSource dataSource = Databases.createDataSource(container); final DSLContext dslContext = Databases.createDslContext(dataSource, dialect); "<AssertPlaceHolder>"; assertEquals(dialect, dslContext.configuration().dialect()); }
createDslContext(final DataSource dataSource, final SQLDialect dialect) { return DSLContextFactory.create(dataSource, dialect); }
[*] target: assertNotNull(dslContext)
[-] pred: org. junit. Assert. assertNotNull ( dslContext )
************************************
************************************
[+] input: Exception { final DSLContext ctx = getDslContext();  // ignore all foreign key constraints ctx.execute("SET session_replication_role = replica;");  final UUID badActorCatalogId = insertDummyActorCatalog(ctx, V0_50_16_002__RemoveInvalidSourceStripeCatalog.INVALID_CATALOG_CONTENT_HASH); final UUID goodActorCatalogId = insertDummyActorCatalog(ctx, V0_50_16_002__RemoveInvalidSourceStripeCatalog.VALID_CATALOG_CONTENT_HASH); final UUID otherActorCatalogId = insertDummyActorCatalog(ctx, "other_hash");  final int numberOfConnections = 10;  final List<UUID> badConnectionIds = IntStream.range(0, numberOfConnections) .mapToObj(i -> insertDummyConnection(ctx, badActorCatalogId)) .toList();  final List<UUID> goodConnectionIds = IntStream.range(0, numberOfConnections) .mapToObj(i -> insertDummyConnection(ctx, goodActorCatalogId)) .toList();  final List<UUID> otherConnectionIds = IntStream.range(0, numberOfConnections) .mapToObj(i -> insertDummyConnection(ctx, otherActorCatalogId)) .toList();  V0_50_16_002__RemoveInvalidSourceStripeCatalog.removeInvalidSourceStripeCatalog(ctx);  // check that the bad catalog is deleted final List<Record> badCatalogs = ctx.select() .from(DSL.table("actor_catalog")) .where(DSL.field("id").in(badActorCatalogId)) .fetch();  Assertions."<AssertPlaceHolder>";  // check that the good catalog and other catalog is not deleted final List<Record> goodCatalogs = ctx.select() .from(DSL.table("actor_catalog")) .where(DSL.field("id").in(goodActorCatalogId).or(DSL.field("id").in(otherActorCatalogId))) .fetch();  Assertions.assertEquals(2, goodCatalogs.size());  // check that the previously bad connections and the good connections reference the good catalog // i.e. the bad connections now have a source_catalog_id that references the good catalog final List<Record> previouslyBadConnections = ctx.select() .from(DSL.table("connection")) .where(DSL.field("id").in(badConnectionIds)) .fetch();  Assertions.assertEquals(numberOfConnections, previouslyBadConnections.size()); Assertions.assertTrue(previouslyBadConnections.stream().allMatch(r -> r.get(DSL.field("source_catalog_id")).equals(goodActorCatalogId)));  // check that the good connections still reference the good catalog final List<Record> goodConnections = ctx.select() .from(DSL.table("connection")) .where(DSL.field("id").in(goodConnectionIds)) .fetch();  Assertions.assertEquals(numberOfConnections, goodConnections.size()); Assertions.assertTrue(goodConnections.stream().allMatch(r -> r.get(DSL.field("source_catalog_id")).equals(goodActorCatalogId)));  // check that the other connections still reference the other catalog final List<Record> otherConnections = ctx.select() .from(DSL.table("connection")) .where(DSL.field("id").in(otherConnectionIds)) .fetch();  Assertions.assertEquals(numberOfConnections, otherConnections.size()); Assertions.assertTrue(otherConnections.stream().allMatch(r -> r.get(DSL.field("source_catalog_id")).equals(otherActorCatalogId))); }
removeInvalidSourceStripeCatalog(final DSLContext ctx) {  // get catalog id for invalid catalog (may not exist) final var invalidCatalogIds = ctx.fetch("SELECT id FROM actor_catalog WHERE catalog_hash = {0}", INVALID_CATALOG_CONTENT_HASH);  // get catalog id for valid catalog (may not exist) final var validCatalogIds = ctx.fetch("SELECT id FROM actor_catalog WHERE catalog_hash = {0}", VALID_CATALOG_CONTENT_HASH);  // if no invalid catalog or no valid catalog, do nothing if (invalidCatalogIds.size() == 0 || validCatalogIds.size() == 0) { LOGGER.info("No invalid catalog or no valid catalog found. Skipping migration."); return; }  final var invalidCatalogId = invalidCatalogIds.get(0).getValue("id", UUID.class); final var validCatalogId = validCatalogIds.get(0).getValue("id", UUID.class);  LOGGER.info("Found invalid catalog id: {} and valid catalog id: {}", invalidCatalogId, validCatalogId);  // Transaction start ctx.transaction(configuration -> { final var transactionCtx = DSL.using(configuration);  // For all connections with invalid catalog, update to valid catalog transactionCtx.execute("UPDATE connection SET source_catalog_id = {0} WHERE source_catalog_id = {1}", validCatalogId, invalidCatalogId);  // Delete invalid catalog transactionCtx.execute("DELETE FROM actor_catalog WHERE id = {0}", invalidCatalogId); }); }
[*] target: assertEquals(0, badCatalogs.size())
[-] pred: org. junit. Assert. assertEquals ( 0, badCatalogs. size ( ) )
************************************
************************************
[+] input: testRequestHeaderV2() { short apiVersion = 2; RequestHeader header = new RequestHeader(ApiKeys.CREATE_DELEGATION_TOKEN, apiVersion, "", 10); assertEquals(2, header.headerVersion());  ByteBuffer buffer = RequestTestUtils.serializeRequestHeader(header); assertEquals(11, buffer.remaining()); RequestHeader deserialized = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { short apiKey = -1; try { // We derive the header version from the request api version, so we read that first. // The request api version is part of `RequestHeaderData`, so we reset the buffer position after the read. int bufferStartPositionForHeader = buffer.position(); apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); short headerVersion = ApiKeys.forId(apiKey).requestHeaderVersion(apiVersion); buffer.position(bufferStartPositionForHeader); final RequestHeaderData headerData = new RequestHeaderData(new ByteBufferAccessor(buffer), headerVersion); // Due to a quirk in the protocol, client ID is marked as nullable. // However, we treat a null client ID as equivalent to an empty client ID. if (headerData.clientId() == null) { headerData.setClientId(""); } final RequestHeader header = new RequestHeader(headerData, headerVersion); // Size of header is calculated by the shift in the position of buffer's start position during parsing. // Prior to parsing, the buffer's start position points to header data and after the parsing operation // the buffer's start position points to api message. For more information on how the buffer is // constructed, see RequestUtils#serialize() header.size = Math.max(buffer.position() - bufferStartPositionForHeader, 0); return header; } catch (UnsupportedVersionException e) { throw new InvalidRequestException("Unknown API key " + apiKey, e); } catch (Throwable ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + apiKey, ex); } }
[*] target: assertEquals(header, deserialized)
[-] pred: org. junit. Assert. assertEquals ( header, deserialized )
************************************
************************************
[+] input: testGenerateIBAN() { // When String iban = AccountService.generateIBAN();  // Then "<AssertPlaceHolder>"; assertTrue(iban.matches("[A-Z]{2}\\d{2}-\\d{4}-\\d{4}-\\d{4}-\\d{4}")); }
generateIBAN() { String[] countryCodes = Locale.getISOCountries(); int index = random.nextInt(countryCodes.length); String countryCode = countryCodes[index]; String accountNumber = String.format("%02d-%04d-%04d-%04d-%04d", random.nextInt(100), random.nextInt(10000), random.nextInt(10000), random.nextInt(10000), random.nextInt(10000)); return countryCode + accountNumber; }
[*] target: assertNotNull(iban)
[-] pred: org. junit. Assert. assertNotNull ( iban )
************************************
************************************
[+] input: testReplaceAtStringEmptyReturnNoOp() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE);  final JsonNode actual = JsonPaths.replaceAtString(JSON_NODE, EMPTY_RETURN_QUERY, REPLACEMENT_STRING); "<AssertPlaceHolder>"; }); }
replaceAtString(final JsonNode json, final String jsonPath, final String replacement) { return replaceAtJsonNode(json, jsonPath, Jsons.jsonNode(replacement)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testLimit_ApiKeyLimitNegative() { Key key = new Key(); key.setRole("role"); key.setKey("key"); Config config = new Config(); Role role = new Role(); Limit limit = new Limit(); limit.setDay(-1); role.setLimits(Map.of("model", limit)); config.setRoles(Map.of("role", role)); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, null, "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.FORBIDDEN, result.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )

[+] input: smoothedAverageAtLimitShouldBeSameAsInputInCaseOfConstantData() { Duration smoothingWindow = Duration.ofSeconds(10); long currentTimestamp = 0; ValueStats valueStats = ValueStats.create(smoothingWindow); int inputValue = 5; int iterations = 1000;  for (int i = 0; i < iterations; i++) { valueStats.recordValue(inputValue); currentTimestamp += ONE_SECOND_IN_MILLIS; valueStats.refresh(currentTimestamp); }  double acceptableError = 10E-5; "<AssertPlaceHolder>"; }
getSmoothedAverage() { if (totalCount == 0) { return 0.0; }  return smoothedSum / smoothedCount; }
[*] target: assertEquals(inputValue, valueStats.getSmoothedAverage(), acceptableError)
[-] pred: org. junit. Assert. assertEquals ( inputValue, valueStats. getSmoothedAverage ( ), acceptableError )
************************************
************************************
[+] input: itShouldReturnProperStandardDeviationAtLimit() { Duration smoothingWindow = Duration.ofSeconds(100); long currentTimestamp = 0; ValueStats valueStats = ValueStats.create(smoothingWindow); int iterations = 10000; int minValue = 0; int maxValue = 10; int refreshPeriod = 100;  for (int i = 0; i < iterations; i++) { int currentValue = uniformRandom(minValue, maxValue); valueStats.recordValue(currentValue); currentTimestamp += refreshPeriod; valueStats.refresh(currentTimestamp); }  // standard deviation of uniform distribution double expectedStandardDeviation = sqrt(((maxValue - minValue + 1) * (maxValue - minValue + 1) - 1) / 12.0); double acceptableError = 0.1; "<AssertPlaceHolder>"; }
getSmoothedStandardDeviation() { if (totalCount == 0) { return 0.0; }  double avg = smoothedSum / smoothedCount; double variance = smoothedSqr / smoothedCount - avg * avg; if (variance < 0.0) variance = 0.0; return sqrt(variance); }
[*] target: assertEquals(expectedStandardDeviation, valueStats.getSmoothedStandardDeviation(), acceptableError)
[-] pred: org. junit. Assert. assertEquals ( expectedStandardDeviation, valueStats. getSmoothedStandardDeviation ( ), acceptableError )
************************************
************************************
[+] input: itShouldAccumulateProperly() { Duration smoothingWindow = Duration.ofSeconds(10); long currentTimestamp = 0; ValueStats valueStats_1 = ValueStats.create(smoothingWindow); ValueStats valueStats_2 = ValueStats.create(smoothingWindow); int inputValue_1 = 5; int inputValue_2 = 10; int iterations = 1000;  for (int i = 0; i < iterations; i++) { valueStats_1.recordValue(inputValue_1); valueStats_2.recordValue(inputValue_2); currentTimestamp += ONE_SECOND_IN_MILLIS; valueStats_1.refresh(currentTimestamp); valueStats_2.refresh(currentTimestamp); }  ValueStats accumulator = ValueStats.createAccumulator(); accumulator.add(valueStats_1); accumulator.add(valueStats_2);  double acceptableError = 10E-5; double expectedAccumulatedSmoothedAvg = (5 + 10) / 2.0; "<AssertPlaceHolder>"; }
getSmoothedAverage() { if (totalCount == 0) { return 0.0; }  return smoothedSum / smoothedCount; }
[*] target: assertEquals(expectedAccumulatedSmoothedAvg, accumulator.getSmoothedAverage(), acceptableError)
[-] pred: org. junit. Assert. assertEquals ( expectedAccumulatedSmoothedAvg, accumulator. getSmoothedAverage ( ), acceptableError )
************************************
************************************
[+] input: itShouldAccumulateHistogram() { ValueStats stats_1 = ValueStats.builder(SMOOTHING_WINDOW) .withHistogram(new long[]{5, 10, 15}) .build(); ValueStats stats_2 = ValueStats.builder(SMOOTHING_WINDOW) .withHistogram(new long[]{5, 10, 15}) .build();  // first interval stats_1.recordValue(2); stats_1.recordValue(4); stats_2.recordValue(1);  // second interval stats_1.recordValue(8);  // no data for third interval  // fourth interval stats_2.recordValue(17);  stats_1.refresh(1L); stats_2.refresh(1L);  ValueStats accumulator = ValueStats.createAccumulator(); accumulator.add(stats_1); accumulator.add(stats_2);  List<String> expected = List.of( "(-∞,  5)  :  3", "[ 5, 10)  :  1", "[10, 15)  :  0", "[15, +∞)  :  1" ); "<AssertPlaceHolder>"; }
getHistogram() { if (histogram == null) { return null; }  long[] levels = histogram.levels(); long[] counts = histogram.counts(); assert counts.length == levels.length + 1;  if (Arrays.stream(counts).noneMatch(value -> value != 0)) { return null; }  int left = IntStream.range(0, counts.length).filter(i -> (i > 0 && levels[i - 1] == 0) || counts[i] != 0).findFirst().getAsInt(); int right = IntStream.iterate(levels.length, i -> i - 1).filter(i -> counts[i] != 0).findFirst().getAsInt();  int maxLevelStrLen = max(max(NEG_INF.length(), POS_INF.length()), IntStream.range(left, right).map(i -> Long.toString(levels[i]).length()).max().orElse(0)); int maxValueStrLen = IntStream.rangeClosed(left, right).map(i -> Long.toString(counts[i]).length()).max().orElse(0);  return IntStream.rangeClosed(left, right) .mapToObj(i -> String.format("%c%" + maxLevelStrLen + "s, %" + maxLevelStrLen + "s%c" + "  :  %" + maxValueStrLen + "s", i == 0 ? '(' : '[', i == 0 ? NEG_INF : levels[i - 1], i == levels.length ? POS_INF : levels[i], ')', counts[i])) .collect(toList()); }
[*] target: assertEquals(expected, accumulator.getHistogram())
[-] pred: org. junit. Assert. assertEquals ( expected, accumulator. getHistogram() )
************************************
************************************
[+] input: IOException { Map<String, FileMetadata> before = client.list("**");  Path tempDir = storagePath.resolve(DEFAULT_TEMP_DIR); Files.createDirectories(tempDir); Files.write(tempDir.resolve("systemFile.txt"), "test data".getBytes()); Path folder = tempDir.resolve("folder"); Files.createDirectories(folder); Files.write(folder.resolve("systemFile2.txt"), "test data".getBytes());  Map<String, FileMetadata> after = client.list("**");  "<AssertPlaceHolder>"; }
list(String glob) throws IOException { checkStarted(); if (glob.isEmpty()) return Map.of();  String subdir = extractSubDir(glob); Path subdirectory = resolve(subdir); String subglob = glob.substring(subdir.length());  return findMatching(tempDir, subglob, subdirectory).stream() .collect(Collector.of( (Supplier<Map<String, FileMetadata>>) HashMap::new, uncheckedOf((map, path) -> { FileMetadata metadata = toFileMetadata(path); if (metadata != null) { String filename = TO_REMOTE_NAME.apply(storage.relativize(path).toString()); map.put(filename, metadata); } }), noMergeFunction()) ); }
[*] target: assertEquals(before, after)
[-] pred: org. junit. Assert. assertEquals ( before, after )
************************************
************************************
[+] input: noFailingOutput() { String source = IntStream.range(0, 1000).mapToObj(String::valueOf).collect(joining()); int nOutputs = 10; ChannelByteSplitter splitter = ChannelByteSplitter.create(nOutputs); ByteBuf value = wrapUtf8(source); splitter.withInput(ChannelSuppliers.ofValue(value) .transformWith(ChannelTransformers.chunkBytes(MemSize.of(5), MemSize.of(10)))); List<String> results = new ArrayList<>(); for (int i = 0; i < nOutputs; i++) { splitter.addOutput().set(ChannelConsumers.ofSupplier(supplier -> supplier.toCollector(ByteBufs.collector()) .then(buf -> { results.add(buf.asString(UTF_8)); return Promise.complete(); }))); } await(splitter.getProcessCompletion());  "<AssertPlaceHolder>"; for (String result : results) { assertEquals(source, result); } }
addOutput() { int index = outputs.size(); outputs.add(null); return output -> { checkInReactorThread(this); outputs.set(index, output); tryStart(); }; }
[*] target: assertEquals(nOutputs, results.size())
[-] pred: org. junit. Assert. assertEquals ( nOutputs, results. size ( ) )
************************************
************************************
[+] input: testAsIterator() { List<ByteBuf> expected = List.of(wrapAscii("First"), wrapAscii("Second"), wrapAscii("Third"), wrapAscii("Fourth")); bufs.addAll(expected);  List<ByteBuf> actual = new ArrayList<>(); bufs.asIterator().forEachRemaining(actual::add); "<AssertPlaceHolder>"; }
asIterator() { if (!hasRemaining()) return iteratorOf(); ByteBufIterator iterator = new ByteBufIterator(this); first = last = 0; bufs = null; return iterator; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: transformsToByteBufferInReadMode() { ByteBuf buf = createEmptyByteBufOfSize(8); buf.tail(5); buf.head(2);  ByteBuffer buffer = buf.toReadByteBuffer();  assertEquals(2, buffer.position()); "<AssertPlaceHolder>"; }
limit() { return array.length; }
[*] target: assertEquals(5, buffer.limit())
[-] pred: org. junit. Assert. assertEquals ( 5, buffer. limit() )
************************************
************************************
[+] input: testToCollectorWithException() { ByteBuf value = ByteBufPool.allocate(100); value.put("Test".getBytes(UTF_8)); Exception exception = new Exception("Test Exception"); ChannelSupplier<ByteBuf> supplier = ChannelSuppliers.concat( ChannelSuppliers.ofValue(value), ChannelSuppliers.ofException(exception) );  Exception e = awaitException(supplier.toCollector(ByteBufs.collector())); "<AssertPlaceHolder>"; }
toCollector(Collector<T, A, R> collector) { return collect(this, collector.supplier().get(), BiConsumerEx.of(collector.accumulator()), FunctionEx.of(collector.finisher())); }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: testSwitchingToClosedStream() { ExpectedException expectedException = new ExpectedException();  SwitcherStreamConsumer<Integer> switcher = SwitcherStreamConsumer.create(); ToListStreamConsumer<Integer> consumer1 = ToListStreamConsumer.create(); StreamConsumer<Integer> consumerClosed = StreamConsumers.closingWithError(expectedException); ToListStreamConsumer<Integer> consumer2 = ToListStreamConsumer.create();  AbstractStreamSupplier<Integer> streamSupplier = new AbstractStreamSupplier<>() { final RefInt refInt = new RefInt(0);  @Override protected void onStarted() { switcher.switchTo(consumer1.transformWith(randomlySuspending())); }  @Override protected void onResumed() { while (isReady()) { send(refInt.inc()); int number = refInt.get(); if (number % 10 == 0) { if (number == 10) { switcher.switchTo(consumerClosed.transformWith(randomlySuspending())); } else if (number == 20) { switcher.switchTo(consumer2.transformWith(randomlySuspending())); } else { break; } } } if (refInt.get() == 30) { sendEndOfStream(); } } };  Exception exception = awaitException(streamSupplier.streamTo(switcher));  "<AssertPlaceHolder>"; assertClosedWithError(expectedException, streamSupplier, switcher);  //		assertClosedWithError(consumer1); assertEquals(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), consumer1.getList());  assertClosedWithError(expectedException, consumerClosed); assertFalse(consumer2.isStarted()); }
switchTo(StreamConsumer<T> consumer) { if (CHECKS) checkInReactorThread(this); checkState(!isComplete()); checkState(!isEndOfStream()); assert this.internalSupplier != null;  InternalSupplier internalSupplierOld = this.internalSupplier; InternalSupplier internalSupplierNew = new InternalSupplier();  this.internalSupplier = internalSupplierNew; internalSupplierNew.streamTo(consumer);  internalSupplierOld.sendEndOfStream();  return internalSupplierNew.getAcknowledgement(); }
[*] target: assertSame(expectedException, exception)
[-] pred: org. junit. Assert. assertSame ( expectedException, exception )
************************************
************************************
[+] input: testWithError() { List<DataItemMasterDetail> list = new ArrayList<>();  StreamSupplier<DataItemMaster> source1 = StreamSuppliers.ofValues( new DataItemMaster(10, 10, "masterA"), new DataItemMaster(20, 10, "masterB"), new DataItemMaster(25, 15, "masterB+"), new DataItemMaster(30, 20, "masterC"), new DataItemMaster(40, 20, "masterD"));  StreamSupplier<DataItemDetail> source2 = StreamSuppliers.ofValues( new DataItemDetail(10, "detailX"), new DataItemDetail(20, "detailY"));  StreamLeftJoin<Integer, DataItemMaster, DataItemDetail, DataItemMasterDetail> streamLeftJoin = StreamLeftJoin.create(Integer::compareTo, input -> input.detailId, input -> input.id, new ValueLeftJoiner<>() { @Override public DataItemMasterDetail doInnerJoin(Integer key, DataItemMaster left, DataItemDetail right) { return new DataItemMasterDetail(left.id, left.detailId, left.master, right.detail); }  @Override public DataItemMasterDetail doOuterJoin(Integer key, DataItemMaster left) { return new DataItemMasterDetail(left.id, left.detailId, left.master, null); } } );  ExpectedException exception = new ExpectedException("Test Exception"); StreamConsumer<DataItemMasterDetail> consumer = ToListStreamConsumer.create(list) .transformWith(decorate(promise -> promise.then(item -> Promise.ofException(exception))));  Exception e = awaitException( source1.streamTo(streamLeftJoin.getLeft()), source2.streamTo(streamLeftJoin.getRight()), streamLeftJoin.getOutput().streamTo(consumer) );  "<AssertPlaceHolder>"; assertEquals(1, list.size()); assertClosedWithError(source1); assertClosedWithError(source2); }
getOutput() { return output; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: testSupplierWithError() { ExpectedException exception = new ExpectedException("Test Exception"); StreamSupplier<DataItemMaster> source1 = StreamSuppliers.concat( StreamSuppliers.ofValue(new DataItemMaster(10, 10, "masterA")), StreamSuppliers.closingWithError(exception), StreamSuppliers.ofValue(new DataItemMaster(20, 10, "masterB")), StreamSuppliers.ofValue(new DataItemMaster(25, 15, "masterB+")), StreamSuppliers.ofValue(new DataItemMaster(30, 20, "masterC")), StreamSuppliers.ofValue(new DataItemMaster(40, 20, "masterD")) );  StreamSupplier<DataItemDetail> source2 = StreamSuppliers.concat( StreamSuppliers.ofValue(new DataItemDetail(10, "detailX")), StreamSuppliers.ofValue(new DataItemDetail(20, "detailY")), StreamSuppliers.closingWithError(exception) );  StreamLeftJoin<Integer, DataItemMaster, DataItemDetail, DataItemMasterDetail> streamLeftJoin = StreamLeftJoin.create(Integer::compareTo, input -> input.detailId, input -> input.id, new ValueLeftJoiner<>() { @Override public DataItemMasterDetail doInnerJoin(Integer key, DataItemMaster left, DataItemDetail right) { return new DataItemMasterDetail(left.id, left.detailId, left.master, right.detail); }  @Override public DataItemMasterDetail doOuterJoin(Integer key, DataItemMaster left) { return new DataItemMasterDetail(left.id, left.detailId, left.master, null); } } );  List<DataItemMasterDetail> list = new ArrayList<>(); StreamConsumer<DataItemMasterDetail> consumer = ToListStreamConsumer.create(list);  Exception e = awaitException( source1.streamTo(streamLeftJoin.getLeft()), source2.streamTo(streamLeftJoin.getRight()), streamLeftJoin.getOutput().streamTo(consumer.transformWith(oneByOne())) );  "<AssertPlaceHolder>"; assertEquals(0, list.size()); assertClosedWithError(source1); assertClosedWithError(source2); }
getOutput() { return output; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: testSupplierDisconnectWithError() { StreamSupplier<KeyValue1> source1 = StreamSuppliers.ofValues(new KeyValue1(1, 10.0), new KeyValue1(3, 30.0));  Exception exception = new Exception("Test Exception"); StreamSupplier<KeyValue2> source2 = StreamSuppliers.closingWithError(exception);  StreamSupplier<KeyValue3> source3 = StreamSuppliers.ofValues(new KeyValue3(2, 10.0, 20.0), new KeyValue3(3, 10.0, 20.0));  StreamReducer<Integer, KeyValueResult, KeyValueResult> streamReducer = StreamReducer.<Integer, KeyValueResult, KeyValueResult>builder() .withBufferSize(1) .build();  ToListStreamConsumer<KeyValueResult> consumer = ToListStreamConsumer.create();  Exception e = awaitException( source1.streamTo(streamReducer.newInput(input -> input.key, KeyValue1.REDUCER)), source2.streamTo(streamReducer.newInput(input -> input.key, KeyValue2.REDUCER)), source3.streamTo(streamReducer.newInput(input -> input.key, KeyValue3.REDUCER)),  streamReducer.getOutput().streamTo(consumer) );  "<AssertPlaceHolder>"; assertEquals(0, consumer.getList().size()); assertClosedWithError(consumer); assertClosedWithError(source1); assertClosedWithError(source2); assertClosedWithError(source3); }
getOutput() { return output; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: InterruptedException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); eventloopExecutor.execute(() -> actual.add(finalI)); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>"; }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ExecutionException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); eventloopExecutor.submit(() -> actual.add(finalI)).get(); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>"; }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: InterruptedException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); Integer actualI = eventloopExecutor.<Integer>submit(() -> cb -> cb.accept(finalI, null)).get(); actual.add(actualI); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>";  }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { AsyncServlet servlet = request -> request.loadBody(Integer.MAX_VALUE) .then(body -> HttpResponse.ok200().withBody(body.slice()).toPromise()); Exception exception = new Exception("TestException");  ByteBuf byteBuf = ByteBufPool.allocate(100); byteBuf.put("Test1".getBytes(UTF_8));  HttpRequest testRequest = HttpRequest.post("http://example.com") .withBodyStream(ChannelSuppliers.concat( ChannelSuppliers.ofValue(byteBuf), ChannelSuppliers.ofException(exception) )) .build();  Exception e = awaitException(servlet.serve(testRequest));  "<AssertPlaceHolder>"; }
serve(HttpRequest request) throws Exception;  /** * Wraps given {@link BlockingServlet}
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: MalformedHttpException { byte[] acceptCts = encodeAscii( "text/html;q=, " + "application/xhtml+xml; method=get; q=; bool=true," + "application/xml;q="); List<AcceptMediaType> result = new ArrayList<>(); AcceptMediaType.decode(acceptCts, 0, acceptCts.length, result); List<AcceptMediaType> expected = new ArrayList<>(); expected.add(AcceptMediaType.of(HTML, 100)); expected.add(AcceptMediaType.of(XHTML_APP, 100)); expected.add(AcceptMediaType.of(XML_APP, 100)); "<AssertPlaceHolder>"; }
toString() { return "ContentType{type=" + mime + ", charset=" + charset + '}'; }
[*] target: assertEquals(expected.toString(), result.toString())
[-] pred: org. junit. Assert. assertEquals ( expected. toString ( ), result. toString ( ) )
************************************
************************************
[+] input: testRenderMime() { String expected = "application/json"; ByteBuf buf = ByteBuf.wrapForWriting(new byte[expected.length()]); MediaTypes.render(JSON, buf); String actual = asAscii(buf); "<AssertPlaceHolder>"; }
render(ContentType type, ByteBuf buf) { int pos = render(type, buf.array(), buf.tail()); buf.tail(pos); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testRenderContentType() { String expected = "text/html; charset=utf-8"; ByteBuf buf = ByteBuf.wrapForWriting(new byte[expected.length()]); ContentType type = ContentType.of(HTML, UTF_8); ContentType.render(type, buf); String actual = asAscii(buf); "<AssertPlaceHolder>"; }
render(ContentType type, ByteBuf buf) { int pos = render(type, buf.array(), buf.tail()); buf.tail(pos); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testRenderAcceptContentType() { String expected = "text/html, application/xhtml+xml, application/xml; q=0.9, image/webp, */*; q=0.8"; ByteBuf buf = ByteBuf.wrapForWriting(new byte[expected.length()]); List<AcceptMediaType> acts = new ArrayList<>(); acts.add(AcceptMediaType.of(HTML)); acts.add(AcceptMediaType.of(XHTML_APP)); acts.add(AcceptMediaType.of(MediaTypes.XML_APP, 90)); acts.add(AcceptMediaType.of(WEBP)); acts.add(AcceptMediaType.of(MediaTypes.ANY, 80)); AcceptMediaType.render(acts, buf); String actual = asAscii(buf); "<AssertPlaceHolder>"; }
render(ContentType type, ByteBuf buf) { int pos = render(type, buf.array(), buf.tail()); buf.tail(pos); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: optionalDependency() { String expected = "string"; Injector injector = Injector.of( ModuleBuilder.create() .bind(String.class).to(() -> expected) .bindOptionalDependency(String.class) .build());  OptionalDependency<String> optional = injector.getOptionalDependency(String.class);  assertTrue(optional.isPresent());  String string = optional.get();  "<AssertPlaceHolder>"; }
get() { if (value == null) { throw new NoSuchElementException(); } return value; }
[*] target: assertEquals(expected, string)
[-] pred: org. junit. Assert. assertEquals ( expected, string )
************************************
************************************
[+] input: optionalDependencyEmpty() { Injector injector = Injector.of( ModuleBuilder.create() .bindOptionalDependency(String.class) .build());  OptionalDependency<String> optional = injector.getOptionalDependency(String.class);  "<AssertPlaceHolder>"; }
isPresent() { return value != null; }
[*] target: assertFalse(optional.isPresent())
[-] pred: org. junit. Assert. assertFalse ( optional. isPresent() )
************************************
************************************
[+] input: predicateThrows() { ExpectedException expected = new ExpectedException(); AsyncBiPredicate<Integer, Integer> predicate = AsyncBiPredicate.of((i1, i2) -> { throw expected; });  Exception exception = awaitException(predicate.test(0, 0)); "<AssertPlaceHolder>"; }
test(T t, U u);  /** * Wraps a {@link BiPredicateEx}
[*] target: assertSame(expected, exception)
[-] pred: org. junit. Assert. assertSame ( expected, exception )
************************************
************************************
[+] input: andException() { ExpectedException expected = new ExpectedException(); AsyncBiPredicate<Integer, Integer> predicate = (i1, i2) -> async((i1 + i2) % 2 == 0); AsyncBiPredicate<Integer, Integer> failingPredicate = (i1, i2) -> Promise.ofException(expected); AsyncBiPredicate<Integer, Integer> andPredicate = predicate.and(failingPredicate);  Exception exception = awaitException(andPredicate.test(0, 0)); "<AssertPlaceHolder>"; }
test(T t, U u);  /** * Wraps a {@link BiPredicateEx}
[*] target: assertSame(expected, exception)
[-] pred: org. junit. Assert. assertSame ( expected, exception )
************************************
************************************
[+] input: orException() { ExpectedException expected = new ExpectedException(); AsyncBiPredicate<Integer, Integer> predicate = (i1, i2) -> async((i1 + i2) % 2 == 0); AsyncBiPredicate<Integer, Integer> failingPredicate = (i1, i2) -> Promise.ofException(expected); AsyncBiPredicate<Integer, Integer> orPredicate = predicate.or(failingPredicate);  Exception exception = awaitException(orPredicate.test(0, 0)); "<AssertPlaceHolder>"; }
test(T t, U u);  /** * Wraps a {@link BiPredicateEx}
[*] target: assertSame(expected, exception)
[-] pred: org. junit. Assert. assertSame ( expected, exception )
************************************
************************************
[+] input: predicateThrows() { ExpectedException expected = new ExpectedException(); AsyncPredicate<Integer> predicate = AsyncPredicate.of(i -> { throw expected; });  Exception exception = awaitException(predicate.test(0)); "<AssertPlaceHolder>"; }
test(T t);  /** * Wraps a {@link PredicateEx}
[*] target: assertSame(expected, exception)
[-] pred: org. junit. Assert. assertSame ( expected, exception )
************************************
************************************
[+] input: negateException() { ExpectedException expected = new ExpectedException(); AsyncPredicate<Integer> predicate = i -> Promise.ofException(expected); AsyncPredicate<Integer> notPredicate = predicate.negate();  Exception exception = awaitException(notPredicate.test(0)); "<AssertPlaceHolder>"; }
test(T t);  /** * Wraps a {@link PredicateEx}
[*] target: assertSame(expected, exception)
[-] pred: org. junit. Assert. assertSame ( expected, exception )
************************************
************************************
[+] input: andException() { ExpectedException expected = new ExpectedException(); AsyncPredicate<Integer> predicate = i -> async(i % 2 == 0); AsyncPredicate<Integer> failingPredicate = i -> Promise.ofException(expected); AsyncPredicate<Integer> andPredicate = predicate.and(failingPredicate);  Exception exception = awaitException(andPredicate.test(0)); "<AssertPlaceHolder>"; }
test(T t);  /** * Wraps a {@link PredicateEx}
[*] target: assertSame(expected, exception)
[-] pred: org. junit. Assert. assertSame ( expected, exception )
************************************
************************************
[+] input: orException() { ExpectedException expected = new ExpectedException(); AsyncPredicate<Integer> predicate = i -> async(i % 2 == 0); AsyncPredicate<Integer> failingPredicate = i -> Promise.ofException(expected); AsyncPredicate<Integer> orPredicate = predicate.or(failingPredicate);  Exception exception = awaitException(orPredicate.test(0)); "<AssertPlaceHolder>"; }
test(T t);  /** * Wraps a {@link PredicateEx}
[*] target: assertSame(expected, exception)
[-] pred: org. junit. Assert. assertSame ( expected, exception )
************************************
************************************
[+] input: toListEmptyTest() { List<Integer> list = await(toList()); "<AssertPlaceHolder>"; // asserting immutability try { list.add(123); } catch (UnsupportedOperationException e) { return; } fail(); }
toList() { return Promise.of(List.of()); }
[*] target: assertEquals(0, list.size())
[-] pred: org. junit. Assert. assertEquals ( 0, list. size ( ) )
************************************
************************************
[+] input: testRepeat() { Exception exception = new Exception(); Exception e = awaitException(repeat(() -> { if (counter.get() == 5) { return Promise.ofException(exception); } counter.incrementAndGet(); return Promise.of(true); })); System.out.println(counter); "<AssertPlaceHolder>"; assertEquals(5, counter.get()); }
repeat(AsyncSupplier<Boolean> supplier) { SettablePromise<Void> cb = new SettablePromise<>(); repeatImpl(supplier, cb); return cb; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: test() { BinarySerializer<ExternalClass> serializer = SerializerFactory.builder() .with(ExternalComponent.class, ctx -> new SimpleSerializerDef<ExternalComponent>() { @Override protected BinarySerializer<ExternalComponent> createSerializer(int version, CompatibilityLevel compatibilityLevel) { return new BinarySerializer<>() { @Override public void encode(BinaryOutput out, ExternalComponent item) { out.writeVarInt(item.getX()); out.writeUTF8(item.getY()); }  @Override public ExternalComponent decode(BinaryInput in) throws CorruptedDataException { int x = in.readVarInt(); String y = in.readUTF8();  return new ExternalComponent(x, y); } }; } }) .build() .create(DEFINING_CLASS_LOADER, ExternalClass.class);  ExternalClass original = new ExternalClass( "test", new ExternalComponent( 123, "inner test 1" ), new ExternalComponent( 456, "inner test 2" ) );  ExternalClass copy = doTest(original, serializer);  "<AssertPlaceHolder>"; }
createSerializer(int version, CompatibilityLevel compatibilityLevel);  public final Class<T> getEncodeType() { return encodeType; }
[*] target: assertEquals(original, copy)
[-] pred: org. junit. Assert. assertEquals ( original, copy )
************************************
************************************
[+] input: singleFlushSequential() { wal = FileWriteAheadLog.builder(getCurrentReactor(), executor, path, serializer, uploader) .withCurrentTimeProvider(TestCurrentTimeProvider.ofTimeSequence(100, 10)) .build(); await(wal.start()); List<CrdtData<Long, GSet<Integer>>> expected = List.of( new CrdtData<>(1L, 140, GSet.of(1, 2, 3, 6, 9, 10, 11)), new CrdtData<>(2L, 130, GSet.of(-12, 0, 2, 3, 100, 200)) ); await(wal.put(1L, GSet.of(1, 2, 3))); await(wal.put(2L, GSet.of(-12, 0, 200))); await(wal.put(1L, GSet.of(1, 6))); await(wal.put(2L, GSet.of(2, 3, 100))); await(wal.put(1L, GSet.of(9, 10, 11)));  await(wal.flush());  List<CrdtData<Long, GSet<Integer>>> actual = await(await(storage.download()).toList()); "<AssertPlaceHolder>"; }
flush() { if (CHECKS) checkInReactorThread(this); logger.trace("Flush called"); return flush.run() .whenComplete(flushPromise.recordStats()); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: singleFlushConsecutive() { await(wal.start()); long now = getCurrentReactor().currentTimeMillis(); List<CrdtData<Long, GSet<Integer>>> expected = List.of( new CrdtData<>(1L, now, GSet.of(1, 2, 3, 6, 9, 10, 11)), new CrdtData<>(2L, now, GSet.of(-12, 0, 2, 3, 100, 200)) ); await( wal.put(1L, GSet.of(1, 2, 3)), wal.put(2L, GSet.of(-12, 0, 200)), wal.put(1L, GSet.of(1, 6)), wal.put(2L, GSet.of(2, 3, 100)), wal.put(1L, GSet.of(9, 10, 11)), wal.flush() );  List<CrdtData<Long, GSet<Integer>>> actual = await(await(storage.download()).toList()); "<AssertPlaceHolder>"; }
flush() { if (CHECKS) checkInReactorThread(this); logger.trace("Flush called"); return flush.run() .whenComplete(flushPromise.recordStats()); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: multipleFlushesConsecutive() { await(wal.start()); long now = getCurrentReactor().currentTimeMillis(); List<CrdtData<Long, GSet<Integer>>> expected = List.of( new CrdtData<>(1L, now, GSet.of(1, 2, 3, 6, 9, 10, 11)), new CrdtData<>(2L, now, GSet.of(-12, 0, 2, 3, 100, 200)) ); await( wal.put(1L, GSet.of(1, 2, 3)), wal.put(2L, GSet.of(-12, 0, 200)), wal.put(1L, GSet.of(1, 6)), wal.flush(), wal.put(2L, GSet.of(2, 3, 100)), wal.put(1L, GSet.of(9, 10, 11)), wal.flush() );  List<CrdtData<Long, GSet<Integer>>> actual = await(await(storage.download()).toList()); "<AssertPlaceHolder>"; }
flush() { if (CHECKS) checkInReactorThread(this); logger.trace("Flush called"); return flush.run() .whenComplete(flushPromise.recordStats()); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { Reactor reactor = Reactor.getCurrentReactor(); Path storageDir = temporaryFolder.newFolder().toPath(); FileSystem fs = FileSystem.create(reactor, newCachedThreadPool(), storageDir); await(fs.start()); IAggregationChunkStorage aggregationChunkStorage = AggregationChunkStorage.create( reactor, stubChunkIdGenerator(), FrameFormats.lz4(), fs);  int nChunks = 100; AggregationChunker<KeyValuePair> chunker = AggregationChunker.create( structure, structure.getMeasures(), KeyValuePair.class, singlePartition(), aggregationChunkStorage, classLoader, 1);  Set<Path> expected = IntStream.range(0, nChunks).mapToObj(i -> Paths.get((i + 1) + AggregationChunkStorage.LOG)).collect(toSet());  Random random = ThreadLocalRandom.current(); StreamSupplier<KeyValuePair> supplier = StreamSuppliers.ofStream( Stream.generate(() -> new KeyValuePair(random.nextInt(), random.nextInt(), random.nextLong())) .limit(nChunks));  List<Path> paths = await(supplier.streamTo(chunker) .then(chunker::getResult) .then(protoAggregationChunks -> aggregationChunkStorage.finish(protoAggregationChunks.stream() .map(ProtoAggregationChunk::protoChunkId) .collect(toSet()))) .map($ -> { try (Stream<Path> list = Files.list(storageDir)) { return list.filter(path -> path.toString().endsWith(AggregationChunkStorage.LOG)).collect(toList()); } catch (IOException e) { throw new AssertionError(e); } }));  Set<Path> actual = paths.stream().filter(Files::isRegularFile).map(Path::getFileName).collect(toSet());  "<AssertPlaceHolder>"; }
finish(Set<String> protoChunkIds) { checkInReactorThread(this); return idGenerator.convertToActualChunkIds(protoChunkIds) .mapException(e -> new AggregationException("Failed to convert to actual chunk IDs: " + Utils.toString(protoChunkIds), e)) .then(chunkIds -> { Map<String, String> renameMap = chunkIds.entrySet().stream() .collect(toMap(e -> toTempPath(e.getKey()), e -> toPath(e.getValue()))); return fileSystem.moveAll(renameMap) .mapException(e -> new AggregationException("Failed to finalize chunks: " + Utils.toString(protoChunkIds), e)) .map($ -> chunkIds); }) .whenResult(() -> finishChunks = protoChunkIds.size()) .whenComplete(promiseFinishChunks.recordStats()); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetFullCycles() { int amountBuffers = 10; int bufferCapacity = 100; int expectedNumberCycles = 2; RingBuffer buffer = RingBuffer.create(amountBuffers, bufferCapacity);  byte[] item = new byte[bufferCapacity]; for (int i = 0; i <= expectedNumberCycles; i++) { fillBufferFully(buffer, item, amountBuffers); } "<AssertPlaceHolder>"; }
getFullCycles() { return countCycles; }
[*] target: assertEquals(expectedNumberCycles, buffer.getFullCycles())
[-] pred: org. junit. Assert. assertEquals ( expectedNumberCycles, buffer. getFullCycles() )
************************************
************************************
[+] input: testInvertWithEmptyDiffs() { List<Tuple3<List<TestAdd>, List<TestSet>, List<TestSetName>>> invert = MERGED.invert(List.of()); "<AssertPlaceHolder>"; }
invert(List<O> ops) { if (ops.isEmpty()) { return List.of(); } List<D1> inverted1 = otSystem1.invert(collect(ops, getter1)); List<D2> inverted2 = otSystem2.invert(collect(ops, getter2));  return combineLists2(inverted1, inverted2, constructor); }
[*] target: assertTrue(invert.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( invert. isEmpty ( ) )
************************************
************************************
[+] input: IOException { manager.saveDiff(100, 10L, 25, 1L);  int integer = manager.loadDiff(25, 1L, 10L); "<AssertPlaceHolder>"; }
loadDiff(T state, Long revisionFrom, Long revisionTo) throws IOException { T loaded = tryLoadDiff(state, revisionFrom, revisionTo); if (loaded == null) { throw new IOException("Cannot find diffs between revision " + revisionFrom + " and " + revisionTo); } return loaded; }
[*] target: assertEquals(100, integer)
[-] pred: org. junit. Assert. assertEquals ( 100, integer )
************************************
************************************
[+] input: alive_without_parent() { final var mr = new MockRecord(null); Assert.assertTrue(mr.__isAlive()); mr.__kill(); Assert."<AssertPlaceHolder>"; }
__isAlive() { if (__parent != null) { if (!__parent.__isAlive()) { return false; } } return __alive; }
[*] target: assertFalse(mr.__isAlive())
[-] pred: org. junit. Assert. assertFalse ( mr. __isAlive() )
************************************
************************************
[+] input: testEmptyList() { DynamicArray<Integer> list = new DynamicArray<>(); "<AssertPlaceHolder>"; }
isEmpty() { // YOUR CODE HERE return false; }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: testAddAndRemove() {  DynamicArray<Long> list = new DynamicArray<>(0);  for (int i = 0; i < 55; i++) list.add(44L); for (int i = 0; i < 55; i++) list.remove(44L); assertTrue(list.isEmpty());  for (int i = 0; i < 55; i++) list.add(44L); for (int i = 0; i < 55; i++) list.removeAt(0); assertTrue(list.isEmpty());  for (int i = 0; i < 155; i++) list.add(44L); for (int i = 0; i < 155; i++) list.remove(44L); assertTrue(list.isEmpty());  for (int i = 0; i < 155; i++) list.add(44L); for (int i = 0; i < 155; i++) list.removeAt(0); "<AssertPlaceHolder>"; }
isEmpty() { // YOUR CODE HERE return false; }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: testAddSetRemove() {  DynamicArray<Long> list = new DynamicArray<>(0);  for (int i = 0; i < 55; i++) list.add(44L); for (int i = 0; i < 55; i++) list.set(i, 33L); for (int i = 0; i < 55; i++) list.remove(33L); assertTrue(list.isEmpty());  for (int i = 0; i < 55; i++) list.add(44L); for (int i = 0; i < 55; i++) list.set(i, 33L); for (int i = 0; i < 55; i++) list.removeAt(0); assertTrue(list.isEmpty());  for (int i = 0; i < 155; i++) list.add(44L); for (int i = 0; i < 155; i++) list.set(i, 33L); for (int i = 0; i < 155; i++) list.remove(33L); assertTrue(list.isEmpty());  for (int i = 0; i < 155; i++) list.add(44L); for (int i = 0; i < 155; i++) list.removeAt(0); "<AssertPlaceHolder>"; }
isEmpty() { // YOUR CODE HERE return false; }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: testClear() {  BinaryHeap<String> q; String[] strs = {"aa", "bb", "cc", "dd", "ee"}; q = new BinaryHeap<>(strs); q.clear(); assertEquals(q.size(), 0); "<AssertPlaceHolder>"; }
isEmpty() { // TODO YOUR CODE HERE return false; }
[*] target: assertTrue(q.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( q. isEmpty() )
************************************
************************************
[+] input: retrieve_member_test() { List<LeaderData> retrievedMembers = dlb.retrieveMember(10, 19); "<AssertPlaceHolder>"; for (int i = 0; i < retrievedMembers.size(); i++) { assertEquals(String.valueOf(i + 10), retrievedMembers.get(i).getScore()); } }
retrieveMember(final long startOffset, final long endOffset) { List<LeaderData> leaderDataList = top(endOffset + 1); return leaderDataList.subList((int)startOffset, (int)endOffset + 1); }
[*] target: assertEquals(10, retrievedMembers.size())
[-] pred: org. junit. Assert. assertEquals ( 10, retrievedMembers. size ( ) )
************************************
************************************
[+] input: leaders_i_test() { List<LeaderData> leaders = lb.leaders(2); "<AssertPlaceHolder>"; for (int i = 0; i < leaders.size(); i++) { assertEquals(String.valueOf(i + 10), leaders.get(i).getScore()); } }
leaders(long page) { if (page < 1) { page = 1; }  long totalMembers = totalMembers(); long totalPages = (long)Math.ceil((double)totalMembers / (double)pageSize); if (page > totalPages) { page = totalPages; }  long startOffset = (page - 1) * pageSize; long endOffset = startOffset + pageSize - 1; if (endOffset > totalMembers) { endOffset = totalMembers - 1; }  return retrieveMember(startOffset, endOffset); }
[*] target: assertEquals(10, leaders.size())
[-] pred: org. junit. Assert. assertEquals ( 10, leaders. size ( ) )
************************************
************************************
[+] input: testSetOnJoinResetMoney() { s.setOnJoinResetMoney(false); assertFalse(s.isOnJoinResetMoney()); s.setOnJoinResetMoney(true); "<AssertPlaceHolder>"; }
isOnJoinResetMoney() { return onJoinResetMoney; }
[*] target: assertTrue(s.isOnJoinResetMoney())
[-] pred: org. junit. Assert. assertTrue ( s. isOnJoinResetMoney() )
************************************
************************************
[+] input: testSetCreateIslandOnFirstLoginAbortOnLogout() { s.setCreateIslandOnFirstLoginAbortOnLogout(false); assertFalse(s.isCreateIslandOnFirstLoginAbortOnLogout()); s.setCreateIslandOnFirstLoginAbortOnLogout(true); "<AssertPlaceHolder>"; }
isCreateIslandOnFirstLoginAbortOnLogout() { return createIslandOnFirstLoginAbortOnLogout; }
[*] target: assertTrue(s.isCreateIslandOnFirstLoginAbortOnLogout())
[-] pred: org. junit. Assert. assertTrue ( s. isCreateIslandOnFirstLoginAbortOnLogout() )
************************************
************************************
[+] input: testSetOnJoinResetXP() { s.setOnJoinResetXP(false); assertFalse(s.isOnJoinResetXP()); s.setOnJoinResetXP(true); "<AssertPlaceHolder>"; }
isOnJoinResetXP() { return onJoinResetXP; }
[*] target: assertTrue(s.isOnJoinResetXP())
[-] pred: org. junit. Assert. assertTrue ( s. isOnJoinResetXP() )
************************************
************************************
[+] input: testSetOnLeaveResetXP() { assertFalse(s.isOnLeaveResetXP()); s.setOnLeaveResetXP(true); "<AssertPlaceHolder>"; }
isOnLeaveResetXP() { return onLeaveResetXP; }
[*] target: assertTrue(s.isOnLeaveResetXP())
[-] pred: org. junit. Assert. assertTrue ( s. isOnLeaveResetXP() )
************************************
************************************
[+] input: testSetPasteMissingIslands() { assertFalse(s.isPasteMissingIslands()); s.setPasteMissingIslands(true); "<AssertPlaceHolder>";   }
isPasteMissingIslands() { return pasteMissingIslands; }
[*] target: assertTrue(s.isPasteMissingIslands())
[-] pred: org. junit. Assert. assertTrue ( s. isPasteMissingIslands() )
************************************
************************************
[+] input: testSetTeleportPlayerToIslandUponIslandCreation() { assertTrue(s.isTeleportPlayerToIslandUponIslandCreation()); s.setTeleportPlayerToIslandUponIslandCreation(false); "<AssertPlaceHolder>"; }
isTeleportPlayerToIslandUponIslandCreation() { return teleportPlayerToIslandUponIslandCreation; }
[*] target: assertFalse(s.isTeleportPlayerToIslandUponIslandCreation())
[-] pred: org. junit. Assert. assertFalse ( s. isTeleportPlayerToIslandUponIslandCreation() )
************************************
************************************
[+] input: Exception { // Obtained by prepending the rsa-1024 certificate to the PKCS#7 SignedData certificates set // of v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-2048.apk META-INF/CERT.RSA. The certs // (in the order of appearance in the file) are thus: rsa-1024, rsa-2048. The package's // signing cert is rsa-2048. ApkVerifier.Result result = verify("v1-only-pkcs7-cert-bag-first-cert-not-used.apk"); assertVerified(result); List<X509Certificate> signingCerts = result.getSignerCertificates(); "<AssertPlaceHolder>"; assertEquals( "fb5dbd3c669af9fc236c6991e6387b7f11ff0590997f22d0f5c74ff40e04fca8", HexEncoding.encode(sha256(signingCerts.get(0).getEncoded()))); }
getSignerCertificates() { return mSignerCerts; }
[*] target: assertEquals(1, signingCerts.size())
[-] pred: org. junit. Assert. assertEquals ( 1, signingCerts. size ( ) )
************************************
************************************
[+] input: Exception { // When a min-sdk-version of 33 is explicitly specified, apksig will behave the same as a // device running this API level and only verify a v3.1 signature if it exists. This test // verifies this v3.1 signature is sufficient to report the APK as verified. ApkVerifier.Result result = verifyForMinSdkVersion("v31-rsa-2048_2-tgt-33-1-tgt-28.apk", 33);  assertVerified(result); "<AssertPlaceHolder>"; }
isVerifiedUsingV31Scheme() { return mVerifiedUsingV31Scheme; }
[*] target: assertTrue(result.isVerifiedUsingV31Scheme())
[-] pred: org. junit. Assert. assertTrue ( result. isVerifiedUsingV31Scheme ( ) )
************************************
************************************
[+] input: Exception { byte[] fullFileContent = createFileContent(1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  "<AssertPlaceHolder>"; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException("Unexpected EOF encountered"); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }
[*] target: assertArrayEquals(expectedBytes, resultBytes)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedBytes, resultBytes )
************************************
************************************
[+] input: Exception { byte[] fullFileContent = createFileContent(3 * 1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 2 * 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  "<AssertPlaceHolder>"; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException("Unexpected EOF encountered"); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }
[*] target: assertArrayEquals(expectedBytes, resultBytes)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedBytes, resultBytes )
************************************
************************************
[+] input: NoSuchAlgorithmException { //        AESPair keyPair = AES256.generateKeyPairOld(); //        SecretKey key = keyPair.getKey(); //        byte[] IV = keyPair.getIV(); //        byte[] sk = AES256.serializeSecretKey(key); // //        List<byte[]> listofbytes = new ArrayList<>(); //        listofbytes.add(sk); //        listofbytes.add(IV); // //        byte[] shareBetweenUsers = ByteHelper.concat(listofbytes); //        assertEquals(shareBetweenUsers.length, 32+16); //        assertTrue(Arrays.equals(Arrays.copyOfRange(shareBetweenUsers, 0, 32), sk)); //        assertTrue(Arrays.equals(Arrays.copyOfRange(shareBetweenUsers, 32, shareBetweenUsers.length), IV)); // //        SecretKey reconstructedKey = AES256.deserializeSecretKey(sk); //        boolean r = (key.equals(reconstructedKey)); // //        "<AssertPlaceHolder>"; }
deserializeSecretKey (byte[] sk) { return new SecretKeySpec(sk, 0, sk.length, Constant.AES); }
[*] target: assertTrue(r)
[-] pred: org. junit. Assert. assertTrue ( r )
************************************
************************************
[+] input: Exception { String message = "1";  KeyPair kp2048 = RSA.generateKeyPair(); PublicKey pk = kp2048.getPublic(); PrivateKey sk = kp2048.getPrivate();  byte[] sign = RSA.signAsBytes(message, sk); assertEquals(sign.length, 256);  boolean valid = RSA.verifyAsBytes(message, sign, pk); "<AssertPlaceHolder>"; }
verifyAsBytes(String plainText, byte[] signatureBytes, PublicKey publicKey) throws Exception { java.security.Signature publicSignature = java.security.Signature.getInstance("SHA256withRSA"); publicSignature.initVerify(publicKey); publicSignature.update(plainText.getBytes(UTF_8));  return publicSignature.verify(signatureBytes); }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: Exception { String message = "1"; KeyPair kp4096 = RSA.generateKeyPair(4096); PublicKey pk = kp4096.getPublic(); PrivateKey sk = kp4096.getPrivate();  byte[] sign = RSA.signAsBytes(message, sk); assertEquals(sign.length, 512);  boolean valid = RSA.verifyAsBytes(message, sign, pk); "<AssertPlaceHolder>"; }
verifyAsBytes(String plainText, byte[] signatureBytes, PublicKey publicKey) throws Exception { java.security.Signature publicSignature = java.security.Signature.getInstance("SHA256withRSA"); publicSignature.initVerify(publicKey); publicSignature.update(plainText.getBytes(UTF_8));  return publicSignature.verify(signatureBytes); }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: Exception { KeyPair alice = RSA.generateKeyPair(); KeyPair bob = RSA.generateKeyPair();  byte[] message = SHA256.hash("hello");  byte[] encryptedMessageFromAliceToBob = RSA.encrypt(message, bob.getPublic()); byte[] encryptedMessageFromBobToAlice = RSA.encrypt(message, alice.getPublic());  byte[] bobDecryptsAlicesMessage = RSA.decrypt(encryptedMessageFromAliceToBob, bob.getPrivate()); boolean bobCanReadAlicesMessage = Arrays.equals(bobDecryptsAlicesMessage, message);  System.out.println("Bob can read Alice's message : " + bobCanReadAlicesMessage); assertTrue(bobCanReadAlicesMessage);  byte[] aliceDecryptsBobsMessage = RSA.decrypt(encryptedMessageFromBobToAlice, alice.getPrivate()); boolean aliceCanReadBobsMessage = Arrays.equals(aliceDecryptsBobsMessage, message);  System.out.println("Alice can read Bob's message : " + aliceCanReadBobsMessage); "<AssertPlaceHolder>"; }
decrypt(byte[] encryptedData, PrivateKey privateKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException { Cipher cipher = Cipher.getInstance(Constant.RSA_CIPHER); cipher.init(Cipher.DECRYPT_MODE, privateKey); return cipher.doFinal(encryptedData); }
[*] target: assertTrue(aliceCanReadBobsMessage)
[-] pred: org. junit. Assert. assertTrue ( aliceCanReadBobsMessage )
************************************
************************************
[+] input: NoSuchAlgorithmException { String message = "1"; byte[] messageHash = SHA256.hash(message);  String actualHashHex = "6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b"; byte[] actualHash = ByteHelper.hexStringToByteArray(actualHashHex);  boolean valid = Arrays.equals(messageHash, actualHash); "<AssertPlaceHolder>";  assertEquals(messageHash.length, 32); }
hexStringToByteArray(String hexString){ byte[] bytes = new byte[hexString.length() / 2];  for(int i = 0; i < hexString.length(); i += 2){ String sub = hexString.substring(i, i + 2); Integer intVal = Integer.parseInt(sub, 16); bytes[i / 2] = intVal.byteValue(); String hex = "".format("0x%x", bytes[i / 2]); } return bytes; }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: IOException { //        final List<String> expectedApkFiles = Arrays.asList("base.apk", //                "split_config.en.apk", //                "split_config.hdpi.apk"); //        Collections.sort(expectedApkFiles); //        Path xmlFile = Paths.get(new File(backupLocation, PACKAGE_NAME_APK_SPLITS + ".xml")); //        SBConverter sbConvert = new SBConverter(xmlFile); //        sbConvert.convert(); //        Path newBackupLocation = Prefs.Storage.getAppManagerDirectory().findFile(PACKAGE_NAME_APK_SPLITS).findFile("0_SB"); //        // Verify source //        List<String> actualApkFiles = TarUtilsTest.getFileNamesGZip(Collections.singletonList( //                newBackupLocation.findFile("source.tar.gz.0"))); //        Collections.sort(actualApkFiles); //        "<AssertPlaceHolder>"; //        assertFalse(newBackupLocation.hasFile("data0.tar.gz.0")); //        assertFalse(newBackupLocation.hasFile("data1.tar.gz.0")); //    }
convert() throws BackupException { // Source metadata mSourceMetadata = new MetadataManager.Metadata(); generateMetadata(); // Destination metadata mDestMetadata = new MetadataManager.Metadata(mSourceMetadata); MetadataManager metadataManager = MetadataManager.getNewInstance(); metadataManager.setMetadata(mDestMetadata); // Simulate a backup creation // If the package has another backup named SB, another backup will be created BackupFiles backupFiles; BackupFiles.BackupFile[] backupFileList; try { backupFiles = new BackupFiles(mPackageName, mUserId, new String[]{"SB"}); backupFileList = backupFiles.getBackupPaths(true); } catch (IOException e) { throw new BackupException("Could not get backup files.", e); } for (BackupFiles.BackupFile backupFile : backupFileList) { // We're iterating over a singleton list boolean backupSuccess = false; try { mTempBackupPath = backupFile.getBackupPath(); mCrypto = ConvertUtils.setupCrypto(mDestMetadata); mDestMetadata.backupName = backupFile.backupName; try { mChecksum = backupFile.getChecksum(CryptoUtils.MODE_NO_ENCRYPTION); } catch (IOException e) { throw new BackupException("Failed to create checksum file.", e); } // Backup icon backupIcon(); if (mDestMetadata.flags.backupApkFiles()) { backupApkFile(); } if (mDestMetadata.flags.backupData()) { backupData(); } // Write modified metadata metadataManager.setMetadata(mDestMetadata); try { metadataManager.writeMetadata(backupFile); } catch (IOException e) { throw new BackupException("Failed to write metadata."); } // Store checksum for metadata try { mChecksum.add(MetadataManager.META_FILE, DigestUtils.getHexDigest(mDestMetadata.checksumAlgo, backupFile.getMetadataFile())); } catch (IOException e) { throw new BackupException("Failed to generate checksum for meta.json", e); } mChecksum.close(); // Encrypt checksum try { Path checksumFile = backupFile.getChecksumFile(CryptoUtils.MODE_NO_ENCRYPTION); encrypt(new Path[]{checksumFile}); } catch (IOException e) { throw new BackupException("Failed to encrypt checksums.txt"); } // Replace current backup try { backupFile.commit(); } catch (IOException e) { throw new BackupException("Could not finalise backup.", e); } backupSuccess = true; } catch (BackupException e) { throw e; } catch (Throwable th) { throw new BackupException("Unknown error occurred.", th); } finally { if (!backupSuccess) { backupFile.cleanup(); } if (mCrypto != null) { mCrypto.close(); } mCachedApk.requireParent().delete(); if (backupSuccess) { BackupUtils.putBackupToDbAndBroadcast(ContextUtils.getContext(), mDestMetadata); } } return; } }
[*] target: assertEquals(expectedApkFiles, actualApkFiles)
[-] pred: org. junit. Assert. assertEquals ( expectedApkFiles, actualApkFiles )
************************************
************************************
[+] input: IOException { final List<String> internalStorage = Arrays.asList("code_cache/", "code_cache/com.android.opengl.shaders_cache", "shared_prefs/", "shared_prefs/ca.cmetcalfe.locationshare_preferences.xml", "shared_prefs/_has_set_default_values.xml"); Collections.sort(internalStorage); Path propFile = Paths.get(new File(backupLocation, PACKAGE_NAME_INT + "-20210529-164219.properties")); TBConverter tbConvert = new TBConverter(propFile); tbConvert.convert(); Path newBackupLocation = Prefs.Storage.getAppManagerDirectory().findFile(PACKAGE_NAME_INT).findFile("0_TB"); // Verify source List<String> files = TarUtilsTest.getFileNamesGZip(Collections.singletonList(newBackupLocation.findFile("data0.tar.gz.0"))); Collections.sort(files); "<AssertPlaceHolder>"; assertFalse(newBackupLocation.hasFile("source.tar.gz.0")); assertFalse(newBackupLocation.hasFile("data1.tar.gz.0")); }
convert() throws BackupException { if (mPackageName == null) { throw new BackupException("Could not read package name."); } // Source metadata mSourceMetadata = new MetadataManager.Metadata(); readPropFile(); // Destination metadata mDestMetadata = new MetadataManager.Metadata(mSourceMetadata); // Destination files will be encrypted by the default encryption method mDestMetadata.crypto = CryptoUtils.getMode(); // Destination APK will be renamed mDestMetadata.apkName = "base.apk"; // Destination compression type will be the default compression method mDestMetadata.tarType = Prefs.BackupRestore.getCompressionMethod(); MetadataManager metadataManager = MetadataManager.getNewInstance(); metadataManager.setMetadata(mDestMetadata); // Simulate a backup creation BackupFiles backupFiles; BackupFiles.BackupFile[] backupFileList; try { backupFiles = new BackupFiles(mPackageName, mUserId, new String[]{"TB"}); backupFileList = backupFiles.getBackupPaths(true); } catch (IOException e) { throw new BackupException("Could not get backup files", e); } for (BackupFiles.BackupFile backupFile : backupFileList) { // We're iterating over a singleton list boolean backupSuccess = false; try { mTempBackupPath = backupFile.getBackupPath(); mCrypto = ConvertUtils.setupCrypto(mDestMetadata); mDestMetadata.backupName = backupFile.backupName; try { mChecksum = backupFile.getChecksum(CryptoUtils.MODE_NO_ENCRYPTION); } catch (IOException e) { throw new BackupException("Failed to create checksum file.", e); } // Backup icon backupIcon(); if (mDestMetadata.flags.backupApkFiles()) { backupApkFile(); } if (mDestMetadata.flags.backupData()) { backupData(); } // Write modified metadata metadataManager.setMetadata(mDestMetadata); try { metadataManager.writeMetadata(backupFile); } catch (IOException e) { throw new BackupException("Failed to write metadata.", e); } // Store checksum for metadata try { mChecksum.add(MetadataManager.META_FILE, DigestUtils.getHexDigest(mDestMetadata.checksumAlgo, backupFile.getMetadataFile())); } catch (IOException e) { throw new BackupException("Failed to generate checksum for meta.json", e); } mChecksum.close(); // Encrypt checksum try { Path checksumFile = backupFile.getChecksumFile(CryptoUtils.MODE_NO_ENCRYPTION); encrypt(new Path[]{checksumFile}); } catch (IOException e) { throw new BackupException("Failed to encrypt checksums.txt"); } // Replace current backup: // There's hardly any chance of getting a false here but checks are done anyway. try { backupFile.commit(); } catch (Exception e) { throw new BackupException("Could not finalise backup.", e); } backupSuccess = true; } catch (BackupException e) { throw e; } catch (Throwable th) { throw new BackupException("Unknown error occurred.", th); } finally { if (!backupSuccess) { backupFile.cleanup(); } if (mCrypto != null) { mCrypto.close(); } if (backupSuccess) { BackupUtils.putBackupToDbAndBroadcast(ContextUtils.getContext(), mDestMetadata); } } return; } }
[*] target: assertEquals(internalStorage, files)
[-] pred: org. junit. Assert. assertEquals ( internalStorage, files )
************************************
************************************
[+] input: IOException { try (StringWriter writer = new StringWriter()) { String expected = ""; new CsvWriter(writer).addLine(); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLine() { initIfNotAlready(); checkFieldCountSame(); mCurrentFieldCount = 0; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { try (StringWriter writer = new StringWriter()) { List<String[]> records = new ArrayList<String[]>() {{ add(new String[]{"1", "apple", "10", "9.99"}); add(new String[]{"2", "orange", "5", "4.99"}); }}; String expected = "1,apple,10,9.99\n2,orange,5,4.99"; new CsvWriter(writer).addLines(records); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLines(@NonNull Collection<String[]> lines) throws IOException { addLines(lines, false); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { try (StringWriter writer = new StringWriter()) { String expected = "1,apple,10,9.99"; CsvWriter csvWriter = new CsvWriter(writer); csvWriter.addField("1"); csvWriter.addField("apple"); csvWriter.addField("10"); csvWriter.addField("9.99"); csvWriter.addLine(); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLine() { initIfNotAlready(); checkFieldCountSame(); mCurrentFieldCount = 0; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { try (StringWriter writer = new StringWriter()) { String expected = "1,apple,10,9.99\n2,orange,5,4.99"; CsvWriter csvWriter = new CsvWriter(writer); csvWriter.addField("1"); csvWriter.addField("apple"); csvWriter.addField("10"); csvWriter.addField("9.99"); csvWriter.addLine(); csvWriter.addField("2"); csvWriter.addField("orange"); csvWriter.addField("5"); csvWriter.addField("4.99"); csvWriter.addLine(); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLine() { initIfNotAlready(); checkFieldCountSame(); mCurrentFieldCount = 0; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { Path newFile = tmpPath.createNewFile("am_new_file", null); assertTrue(newFile.exists()); assertEquals(0, newFile.length()); assertThrows(IOException.class, () -> tmpPath.createDirectories("am_new_file/am_new_dir")); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(newFile.delete())
[-] pred: org. junit. Assert. assertTrue ( newFile. delete() )
************************************
************************************
[+] input: IOException { Path path = tmpPath.findOrCreateFile("am_new_file", null); assertTrue(path.isFile()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(path.delete())
[-] pred: org. junit. Assert. assertTrue ( path. delete() )
************************************
************************************
[+] input: IOException { Path path = tmpPath.findOrCreateDirectory("am_new_dir"); assertTrue(path.isDirectory()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(path.delete())
[-] pred: org. junit. Assert. assertTrue ( path. delete() )
************************************
************************************
[+] input: IOException { Path path = tmpPath.createNewDirectory("am_new_dir"); assertTrue(path.isDirectory()); assertThrows(IllegalArgumentException.class, () -> tmpPath.findOrCreateDirectory("am_new_dir/am_another_dir")); assertFalse(path.hasFile("am_another_dir")); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(path.delete())
[-] pred: org. junit. Assert. assertTrue ( path. delete ( ) )
************************************
************************************
[+] input: IOException { Path path = tmpPath.createNewFile("am_new_file", null); assertTrue(path.isFile()); assertThrows(IOException.class, () -> tmpPath.findOrCreateDirectory("am_new_file")); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(path.delete())
[-] pred: org. junit. Assert. assertTrue ( path. delete() )
************************************
************************************
[+] input: IOException { Path src = tmpPath.findOrCreateFile("am_new_file", null); assertTrue(src.renameTo("am_new_file_2")); assertTrue(tmpPath.hasFile("am_new_file_2")); assertFalse(tmpPath.hasFile("am_new_file")); assertEquals(tmpPath.findFile("am_new_file_2"), src); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(src.delete())
[-] pred: org. junit. Assert. assertTrue ( src. delete() )
************************************
************************************
[+] input: IOException { Path src = tmpPath.findOrCreateFile("am_new_file", null); Path dst = tmpPath.findOrCreateFile("am_new_file_2", null); assertFalse(src.renameTo("am_new_file_2")); assertTrue(tmpPath.hasFile("am_new_file")); assertTrue(tmpPath.hasFile("am_new_file_2")); assertEquals(tmpPath.findFile("am_new_file"), src); assertEquals(tmpPath.findFile("am_new_file_2"), dst); assertTrue(src.delete()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(dst.delete())
[-] pred: org. junit. Assert. assertTrue ( dst. delete() )
************************************
************************************
[+] input: IOException { Path src = tmpPath.createNewFile("am_new_file", null); Path dst = tmpPath.createNewFile("moved_file", null); assertFalse(src.moveTo(dst, false)); assertTrue(tmpPath.hasFile("moved_file")); assertTrue(tmpPath.hasFile("am_new_file")); assertNotEquals(dst, src); assertTrue(src.delete()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(dst.delete())
[-] pred: org. junit. Assert. assertTrue ( dst. delete() )
************************************
************************************
[+] input: IOException { Path src = tmpPath.createNewDirectory("am_new_dir"); assertFalse(src.moveTo(src)); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(src.delete())
[-] pred: org. junit. Assert. assertTrue ( src. delete() )
************************************
************************************
[+] input: IOException { Path dst = tmpPath.createNewFile("am_new_file", null); Path child = tmpPath.createNewDirectory("am_new_dir"); child.createNewFile("some_file", null); assertFalse(child.moveTo(dst)); assertTrue(tmpPath.hasFile("am_new_file")); assertTrue(tmpPath.hasFile("am_new_dir")); assertTrue(child.delete()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(dst.delete())
[-] pred: org. junit. Assert. assertTrue ( dst. delete() )
************************************
************************************
[+] input: IOException { Path src = tmpPath.createNewFile("am_new_file", null); Path dst = tmpPath.createNewFile("copied_file", null); assertNotNull(src.copyTo(dst)); assertTrue(tmpPath.hasFile("am_new_file")); assertTrue(tmpPath.hasFile("copied_file")); assertNotEquals(dst, src); assertTrue(src.delete()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(dst.delete())
[-] pred: org. junit. Assert. assertTrue ( dst. delete() )
************************************
************************************
[+] input: IOException { Path src = tmpPath.createNewFile("am_new_file", null); assertNull(src.copyTo(src)); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(src.delete())
[-] pred: org. junit. Assert. assertTrue ( src. delete() )
************************************
************************************
[+] input: IOException { Path src = tmpPath.createNewFile("am_new_file", null); Path dst = tmpPath.createNewFile("copied_file", null); assertNull(src.copyTo(dst, false)); assertTrue(tmpPath.hasFile("am_new_file")); assertTrue(tmpPath.hasFile("copied_file")); assertNotEquals(dst, src); assertTrue(src.delete()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(dst.delete())
[-] pred: org. junit. Assert. assertTrue ( dst. delete() )
************************************
************************************
[+] input: IOException { Path src = tmpPath.createNewDirectory("am_new_dir"); assertNull(src.copyTo(src)); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(src.delete())
[-] pred: org. junit. Assert. assertTrue ( src. delete() )
************************************
************************************
[+] input: IOException { Path dst = tmpPath.createNewFile("am_new_file", null); Path child = tmpPath.createNewDirectory("am_new_dir"); child.createNewFile("some_file", null); assertNull(child.copyTo(dst)); assertTrue(tmpPath.hasFile("am_new_file")); assertTrue(tmpPath.hasFile("am_new_dir")); assertTrue(child.delete()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(dst.delete())
[-] pred: org. junit. Assert. assertTrue ( dst. delete() )
************************************
************************************
[+] input: IOException { try (SplitInputStream splitInputStream = new SplitInputStream(fileList)) { // For 1 KB long expectedSkipBytes = 10024; long actualSkipBytes = splitInputStream.skip(expectedSkipBytes); assertEquals(expectedSkipBytes, actualSkipBytes); // For 1 MB expectedSkipBytes = 1024 * 1024; actualSkipBytes = splitInputStream.skip(expectedSkipBytes); assertEquals(expectedSkipBytes, actualSkipBytes); // For 2 MB expectedSkipBytes = 1024 * 1024 * 2; actualSkipBytes = splitInputStream.skip(expectedSkipBytes); "<AssertPlaceHolder>"; } }
skip(long n) throws IOException { if (n <= 0) return 0; return Math.max(read0(null, 0, (int) n), 0); }
[*] target: assertEquals(expectedSkipBytes, actualSkipBytes)
[-] pred: org. junit. Assert. assertEquals ( expectedSkipBytes, actualSkipBytes )
************************************
************************************
[+] input: IOException { List<Path> pathList = new ArrayList<>(); assert classLoader != null; pathList.add(Paths.get(classLoader.getResource("AppManager_v2.5.22.apks.tar.0").getFile())); pathList.add(Paths.get(classLoader.getResource("AppManager_v2.5.22.apks.tar.1").getFile()));  // Always run tests using SplitInputStream try (SplitInputStream sis = new SplitInputStream(pathList); BufferedInputStream bis = new BufferedInputStream(sis); TarArchiveInputStream tis = new TarArchiveInputStream(bis)) { ArchiveEntry entry; while ((entry = tis.getNextEntry()) != null) { // create a new path, remember check zip slip attack File file = new File("/tmp", entry.getName()); // copy TarArchiveInputStream to newPath try (OutputStream os = Paths.get(file).openOutputStream()) { IoUtils.copy(tis, os); } } }  // Check integrity List<String> expectedHashes = new ArrayList<>(); List<File> fileList = new ArrayList<>(); fileList.add(new File(classLoader.getResource("AppManager_v2.5.22.apks.0").getFile())); fileList.add(new File(classLoader.getResource("AppManager_v2.5.22.apks.1").getFile())); for (File file : fileList) { expectedHashes.add(DigestUtils.getHexDigest(DigestUtils.SHA_256, file)); } List<String> actualHashes = new ArrayList<>(); fileList.clear(); fileList.add(new File("/tmp/AppManager_v2.5.22.apks.0")); fileList.add(new File("/tmp/AppManager_v2.5.22.apks.1")); for (File file : fileList) { if (!file.exists()) { throw new FileNotFoundException(file + " does not exist."); } actualHashes.add(DigestUtils.getHexDigest(DigestUtils.SHA_256, file)); junkFiles.add(file); } "<AssertPlaceHolder>"; }
getNextEntry() throws IOException { return getNextTarEntry(); }
[*] target: assertEquals(expectedHashes, actualHashes)
[-] pred: org. junit. Assert. assertEquals ( expectedHashes, actualHashes )
************************************
************************************
[+] input: should_throw_exception_if_directive_class_not_a_wiring1() { directivePostProcessor.postProcessBeforeInitialization(new CorrectDirective(), "a"); Map<String, SchemaDirectiveWiring> map = (Map<String, SchemaDirectiveWiring>) ReflectionTestUtils.getField(RuntimeWiringRegistry.class, "NAME_AND_DIRECTIVE_WIRING"); "<AssertPlaceHolder>"; assertEquals(1, map.size()); assertTrue(map.containsKey("b")); }
postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { Class<?> targetClass = AopProxyUtils.ultimateTargetClass(bean); if (targetClass.isAnnotationPresent(Directive.class)) { Directive directive = targetClass.getAnnotation(Directive.class); if (bean instanceof SchemaDirectiveWiring) { RuntimeWiringRegistry.registerDirective(directive.value(), (SchemaDirectiveWiring) bean); } else { throw new BeanInitializationException("directive bean must implements SchemaDirectiveWiring! bean:" + beanName); } } return bean; }
[*] target: assertNotNull(map)
[-] pred: org. junit. Assert. assertNotNull ( map )
************************************
************************************
[+] input: should_return_null_if_args_is_empty() { Mock mock = GraphqlPayloadUtil.resolveArguments(new HashMap<>(), Mock.class); "<AssertPlaceHolder>"; }
resolveArguments(Map<String, Object> args, Class<T> clazz) { if (null == args) { return null; } return JSON.parseObject(JSON.toJSONString(args.get(PAYLOAD_KEY)), clazz); }
[*] target: assertNull(mock)
[-] pred: org. junit. Assert. assertNull ( mock )
************************************
************************************
[+] input: testGetProfiler() { AsyncProfilerSupplier asyncProfilerSupplier = new AsyncProfilerSupplier(); AsyncProfiler asyncProfiler = asyncProfilerSupplier.getProfiler();  "<AssertPlaceHolder>"; assertTrue(asyncProfiler instanceof LazyLoadedAsyncProfiler);  LazyLoadedAsyncProfiler lazyLoadedAsyncProfiler = (LazyLoadedAsyncProfiler) asyncProfiler; assertFalse(lazyLoadedAsyncProfiler.getOrLoadAsyncProfiler() instanceof EmptyAsyncProfiler); }
getProfiler() { return asyncProfiler; }
[*] target: assertNotNull(asyncProfiler)
[-] pred: org. junit. Assert. assertNotNull ( asyncProfiler )
************************************
************************************
[+] input: Exception { AgentSink mockedSink = mock(AgentSink.class); PowerMockito.whenNew(AgentSink.class) .withAnyArguments() .then( invocation -> { Endpoint endpoint = invocation.getArgument(2); assertEquals(Endpoint.DEFAULT_TCP_ENDPOINT, endpoint); return mockedSink; });  AgentBasedEnvironment env = new AgentBasedEnvironmentTestImplementation(configuration); ISink sink = env.getSink();  "<AssertPlaceHolder>"; }
getSink() { if (sink == null) { if (config.shouldWriteToStdout()) { sink = new ConsoleSink(); } else { Endpoint endpoint; if (config.getAgentEndpoint().isPresent()) { endpoint = Endpoint.fromURL(config.getAgentEndpoint().get()); } else { log.info( "Endpoint is not defined. Using default: {}", Endpoint.DEFAULT_TCP_ENDPOINT); endpoint = Endpoint.DEFAULT_TCP_ENDPOINT; } sink = new AgentSink( getLogGroupName(), getLogStreamName(), endpoint, new SocketClientFactory(), config.getAsyncBufferSize(), () -> new FibonacciRetryStrategy( Constants.MIN_BACKOFF_MILLIS, Constants.MAX_BACKOFF_MILLIS, Constants.MAX_BACKOFF_JITTER)); } } return sink; }
[*] target: assertEquals(mockedSink, sink)
[-] pred: org. junit. Assert. assertEquals ( mockedSink, sink )
************************************
************************************
[+] input: Exception { String endpointUrl = "http://configured-endpoint:1234"; configuration.setAgentEndpoint(endpointUrl); AgentSink mockedSink = mock(AgentSink.class); PowerMockito.whenNew(AgentSink.class) .withAnyArguments() .then( invocation -> { Endpoint endpoint = invocation.getArgument(2); assertEquals(Endpoint.fromURL(endpointUrl), endpoint); return mockedSink; });  AgentBasedEnvironment env = new AgentBasedEnvironmentTestImplementation(configuration); ISink sink = env.getSink();  "<AssertPlaceHolder>"; }
getSink() { if (sink == null) { if (config.shouldWriteToStdout()) { sink = new ConsoleSink(); } else { Endpoint endpoint; if (config.getAgentEndpoint().isPresent()) { endpoint = Endpoint.fromURL(config.getAgentEndpoint().get()); } else { log.info( "Endpoint is not defined. Using default: {}", Endpoint.DEFAULT_TCP_ENDPOINT); endpoint = Endpoint.DEFAULT_TCP_ENDPOINT; } sink = new AgentSink( getLogGroupName(), getLogStreamName(), endpoint, new SocketClientFactory(), config.getAsyncBufferSize(), () -> new FibonacciRetryStrategy( Constants.MIN_BACKOFF_MILLIS, Constants.MAX_BACKOFF_MILLIS, Constants.MAX_BACKOFF_JITTER)); } } return sink; }
[*] target: assertEquals(mockedSink, sink)
[-] pred: org. junit. Assert. assertEquals ( mockedSink, sink )
************************************
************************************
[+] input: Exception { KubernetesContextFactory mockFactory = new KubernetesContextFactory("", "", ""); KubernetesContext actualKubernetesContext = mockFactory.create(); "<AssertPlaceHolder>"; }
create() throws Exception { if (this.kubernetesService == null) { if (this.kubeConfigFilePath.isEmpty()) { log.info("did not build kubernetes context. kubecfg file path was empty"); return null; } else { this.kubernetesService = new KubernetesService(this.kubeConfigFilePath); } }  KubernetesContext kubernetesContext = new KubernetesContext(this.deploymentName, this.namespace);  V1Pod pod = kubernetesService.getSampleAppPod(this.deploymentName, this.namespace); if (pod != null) { kubernetesContext.setNamespace(Objects.requireNonNull(pod.getMetadata()).getNamespace()); kubernetesContext.setPodName(pod.getMetadata().getName()); kubernetesContext.setPodUid(pod.getMetadata().getUid()); kubernetesContext.setNodeName(Objects.requireNonNull(pod.getSpec()).getNodeName());  /* Currently waiting for RF3339 format to be used before asserting against creation timestamps. https://github.com/open-telemetry/opentelemetry-collector-contrib/pull/24016 String creationTimestamp = pod.getMetadata() .getCreationTimestamp() .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss xx 'UTC'"));  context.getKubernetesContext().setCreationTimeStamp(creationTimestamp); */ }  return kubernetesContext; }
[*] target: assertNull(actualKubernetesContext)
[-] pred: org. junit. Assert. assertNull ( actualKubernetesContext )
************************************
************************************
[+] input: shouldReturnNull() { // When Connection defaultParameters = new Connection();  // Then(assert and act) "<AssertPlaceHolder>"; }
getOrganization() { return this.organization; }
[*] target: assertNull(defaultParameters.getOrganization())
[-] pred: org. junit. Assert. assertNull ( defaultParameters. getOrganization() )
************************************
************************************
[+] input: Exception { String rawEvent = summaryEvent; int index = 5; JSONObject jsonEvent = (JSONObject) new JSONParser().parse(rawEvent);  // ctor parses the event, otherwise throws, which is the primary validation here BEPTestSummaryEvent event = new BEPTestSummaryEvent(rawEvent, index, jsonEvent);  assertFalse(event.isError()); assertFalse(event.isLastMessage()); assertFalse(event.isProcessed()); assertEquals("testSummary", event.getEventType());  assertEquals("//foo:foo-test", event.getTestLabel()); assertEquals( "file:///private/var/tmp/_bazel_mbenioff/8fc74f66fda297c82a847368ee50d6a4/execroot/myrepo/bazel-out/darwin-fastbuild/testlogs/foo/foo-test/test.log", event.getTestLogs().get(0).getUri().toString());  assertEquals("PASSED", event.getTestStatus()); assertEquals(1622354133812L, event.getFirstStartTimeMillis()); assertEquals(1622354134270L, event.getLastStopTimeMillis()); assertEquals(458, event.getTotalRunDurationMillis()); "<AssertPlaceHolder>"; }
getTotalRunCount() { return totalRunCount; }
[*] target: assertEquals(1, event.getTotalRunCount())
[-] pred: org. junit. Assert. assertEquals ( 1, event. getTotalRunCount ( ) )
************************************
************************************
[+] input: testHappyPath() { // to make this a unit test, we need to mock out the computations that would ordinarily involve collaborators // such as Bazel Query, filesystem scanning, and file parsing TestBazelQueryProjectStructureStrategy strategy = new TestBazelQueryProjectStructureStrategy(); addSourcePathForTest(strategy, "source/main/java"); addSourcePathForTest(strategy, "source/test/java"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/main/resources"); addTestResourcePathForTest(strategy, "projects/libs/apple/source/test/resources");  addSimQueryResult(strategy, "source/main/java/com/salesforce/apple/api/Apple.java"); addSimQueryResult(strategy, "source/main/java/com/salesforce/apple/api/ApplePie.java"); addSimQueryResult(strategy, "source/main/resources/fruit/kinds.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/pies.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/cakes.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/sauces.properties"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/AppleTest.java"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/ApplePieTest.java"); addSimQueryResult(strategy, "source/test/resources/test.properties");  // run the test String relPath = FSPathHelper.osSeps("projects/libs/apple"); InMemoryPackageLocation packageLocation = new InMemoryPackageLocation(relPath); ProjectStructure structure = null; try { structure = strategy.doStructureAnalysis(bazelWorkspace, packageLocation, nullCommandRunner); } catch (Exception anyE) { anyE.printStackTrace(); }  // validate "<AssertPlaceHolder>"; assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/main/java"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/main/resources"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/source/test/java"); assertContains(structure.testResourceDirFSPaths, "projects/libs/apple/source/test/resources"); }
doStructureAnalysis(BazelWorkspace bazelWorkspace, BazelPackageLocation packageNode, BazelWorkspaceCommandRunner commandRunner) {  File workspaceRootDir = bazelWorkspace.getBazelWorkspaceRootDirectory(); String packageRelPath = packageNode.getBazelPackageFSRelativePath(); File packageDir = new File(workspaceRootDir, packageRelPath); // TODO move this to the PackageLocation api  String labelPath = packageRelPath.replaceAll(FSPathHelper.WINDOWS_BACKSLASH_REGEX, "/"); BazelLabel packageLabel = new BazelLabel(labelPath, BazelLabel.BAZEL_WILDCARD_ALLTARGETS_STAR);  // execute the expensive query, this will take a few seconds to run at least Collection<String> queryResults = runBazelQueryForSourceFiles(workspaceRootDir, packageLabel, commandRunner);  ProjectStructure structure = processQueryResults(packageRelPath, packageDir, packageLabel, queryResults);  return structure; }
[*] target: assertNotNull(structure)
[-] pred: org. junit. Assert. assertNotNull ( structure )
************************************
************************************
[+] input: testMultipleSourceDirs() { // to make this a unit test, we need to mock out the computations that would ordinarily involve collaborators // such as Bazel Query, filesystem scanning, and file parsing TestBazelQueryProjectStructureStrategy strategy = new TestBazelQueryProjectStructureStrategy(); addSourcePathForTest(strategy, "source/dev/java"); addSourcePathForTest(strategy, "source/dev2/java"); addSourcePathForTest(strategy, "source/test/java"); addSourcePathForTest(strategy, "src/test/java"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/dev/resources/fruit"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/dev2/resources"); addTestResourcePathForTest(strategy, "projects/libs/apple/source/test/resources");  addSimQueryResult(strategy, "source/dev/java/com/salesforce/apple/api/Apple.java"); addSimQueryResult(strategy, "source/dev2/java/com/salesforce/apple/api/ApplePie.java"); addSimQueryResult(strategy, "source/dev/resources/fruit/kinds.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/pies.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/cakes.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/sauces.properties"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/AppleTest.java"); addSimQueryResult(strategy, "src/test/java/com/salesforce/apple/api/ApplePieTest.java"); addSimQueryResult(strategy, "source/test/resources/test.properties");  // run the test String relPath = FSPathHelper.osSeps("projects/libs/apple"); InMemoryPackageLocation packageLocation = new InMemoryPackageLocation(relPath); ProjectStructure structure = strategy.doStructureAnalysis(bazelWorkspace, packageLocation, nullCommandRunner);  // validate "<AssertPlaceHolder>"; assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/dev/java"); assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/dev2/java"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/dev/resources/fruit"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/dev2/resources"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/source/test/java"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/src/test/java"); assertContains(structure.testResourceDirFSPaths, "projects/libs/apple/source/test/resources"); }
doStructureAnalysis(BazelWorkspace bazelWorkspace, BazelPackageLocation packageNode, BazelWorkspaceCommandRunner commandRunner) {  File workspaceRootDir = bazelWorkspace.getBazelWorkspaceRootDirectory(); String packageRelPath = packageNode.getBazelPackageFSRelativePath(); File packageDir = new File(workspaceRootDir, packageRelPath); // TODO move this to the PackageLocation api  String labelPath = packageRelPath.replaceAll(FSPathHelper.WINDOWS_BACKSLASH_REGEX, "/"); BazelLabel packageLabel = new BazelLabel(labelPath, BazelLabel.BAZEL_WILDCARD_ALLTARGETS_STAR);  // execute the expensive query, this will take a few seconds to run at least Collection<String> queryResults = runBazelQueryForSourceFiles(workspaceRootDir, packageLabel, commandRunner);  ProjectStructure structure = processQueryResults(packageRelPath, packageDir, packageLabel, queryResults);  return structure; }
[*] target: assertNotNull(structure)
[-] pred: org. junit. Assert. assertNotNull ( structure )
************************************
************************************
[+] input: testPlot() { double[] nums = new double[]{2710, 2755, 2850, 2880, 2880, 2890, 2920, 2940, 2950, 3050, 3130, 3325}; BoxPlot plot = BoxPlotUtil.plot(nums); TestCase."<AssertPlaceHolder>"; TestCase.assertEquals(3202.5D, plot.getMaxRegion()); TestCase.assertEquals(3000.0D, plot.getQ3()); TestCase.assertEquals(2905.0, plot.getMedian()); TestCase.assertEquals(2865.0, plot.getQ1()); TestCase.assertEquals(2662.5D, plot.getMinRegion()); }
plot(double[] data) { List<Double> collect = Arrays.stream(data).boxed().sorted().collect(Collectors.toList()); data = collect.stream().mapToDouble(i -> i).toArray(); if (data.length <= 2) { return null; }  double max; double q3; double median; double q1; double min; double iqr; if (data.length % 2 == 0) { median = (data[(data.length) / 2 - 1] + data[(data.length) / 2]) / 2; q1 = (data[(data.length) / 4 - 1] + data[(data.length) / 4]) / 2; q3 = (data[((data.length) * 3) / 4 - 1] + data[((data.length) * 3) / 4]) / 2; } else { median = data[(data.length) / 2]; q1 = data[(data.length) / 4]; q3 = data[(data.length * 3) / 4]; } max = data[data.length - 1]; min = data[0]; iqr = q3 - q1;  double maxRegion = q3 + 1.5 * iqr; double minRegion = q1 - 1.5 * iqr;  BoxPlot box = new BoxPlot(); box.setMaxRegion(maxRegion); box.setMax(max); box.setQ3(q3); box.setMedian(median); box.setQ1(q1); box.setMin(min); box.setMinRegion(minRegion); box.setIqr(iqr); return box; }
[*] target: assertNotNull(plot)
[-] pred: org. junit. Assert. assertNotNull ( plot )
************************************
************************************
[+] input: testNullPlot() { double[] nums = new double[]{2710, 2755}; BoxPlot plot = BoxPlotUtil.plot(nums); TestCase."<AssertPlaceHolder>"; }
plot(double[] data) { List<Double> collect = Arrays.stream(data).boxed().sorted().collect(Collectors.toList()); data = collect.stream().mapToDouble(i -> i).toArray(); if (data.length <= 2) { return null; }  double max; double q3; double median; double q1; double min; double iqr; if (data.length % 2 == 0) { median = (data[(data.length) / 2 - 1] + data[(data.length) / 2]) / 2; q1 = (data[(data.length) / 4 - 1] + data[(data.length) / 4]) / 2; q3 = (data[((data.length) * 3) / 4 - 1] + data[((data.length) * 3) / 4]) / 2; } else { median = data[(data.length) / 2]; q1 = data[(data.length) / 4]; q3 = data[(data.length * 3) / 4]; } max = data[data.length - 1]; min = data[0]; iqr = q3 - q1;  double maxRegion = q3 + 1.5 * iqr; double minRegion = q1 - 1.5 * iqr;  BoxPlot box = new BoxPlot(); box.setMaxRegion(maxRegion); box.setMax(max); box.setQ3(q3); box.setMedian(median); box.setQ1(q1); box.setMin(min); box.setMinRegion(minRegion); box.setIqr(iqr); return box; }
[*] target: assertNull(plot)
[-] pred: org. junit. Assert. assertNull ( plot )
************************************
************************************
[+] input: Exception { context.checking(new Expectations() {{ oneOf(crypto).decryptWithPassword(encryptedKey, password, keyStrengthener); will(returnValue(key.getBytes())); oneOf(crypto).isEncryptedWithStrengthenedKey(encryptedKey); will(returnValue(true)); }});  storeDatabaseKey(keyFile, encryptedKeyHex); storeDatabaseKey(keyBackupFile, encryptedKeyHex);  assertEquals(encryptedKeyHex, loadDatabaseKey(keyFile)); assertEquals(encryptedKeyHex, loadDatabaseKey(keyBackupFile));  accountManager.signIn(password); assertTrue(accountManager.hasDatabaseKey()); SecretKey decrypted = accountManager.getDatabaseKey(); "<AssertPlaceHolder>"; assertArrayEquals(key.getBytes(), decrypted.getBytes());  assertEquals(encryptedKeyHex, loadDatabaseKey(keyFile)); assertEquals(encryptedKeyHex, loadDatabaseKey(keyBackupFile)); }
getDatabaseKey() { return databaseKey; }
[*] target: assertNotNull(decrypted)
[-] pred: org. junit. Assert. assertNotNull ( decrypted )
************************************
************************************
[+] input: Exception { context.checking(new Expectations() {{ oneOf(crypto).decryptWithPassword(encryptedKey, password, keyStrengthener); will(returnValue(key.getBytes())); oneOf(crypto).isEncryptedWithStrengthenedKey(encryptedKey); will(returnValue(false)); oneOf(crypto).encryptWithPassword(key.getBytes(), password, keyStrengthener); will(returnValue(newEncryptedKey)); }});  storeDatabaseKey(keyFile, encryptedKeyHex); storeDatabaseKey(keyBackupFile, encryptedKeyHex);  assertEquals(encryptedKeyHex, loadDatabaseKey(keyFile)); assertEquals(encryptedKeyHex, loadDatabaseKey(keyBackupFile));  accountManager.signIn(password); assertTrue(accountManager.hasDatabaseKey()); SecretKey decrypted = accountManager.getDatabaseKey(); "<AssertPlaceHolder>"; assertArrayEquals(key.getBytes(), decrypted.getBytes());  assertEquals(newEncryptedKeyHex, loadDatabaseKey(keyFile)); assertEquals(newEncryptedKeyHex, loadDatabaseKey(keyBackupFile)); }
getDatabaseKey() { return databaseKey; }
[*] target: assertNotNull(decrypted)
[-] pred: org. junit. Assert. assertNotNull ( decrypted )
************************************
************************************
[+] input: Exception { context.checking(new Expectations() {{ oneOf(identityManager).createIdentity(authorName); will(returnValue(identity)); oneOf(identityManager).registerIdentity(identity); oneOf(crypto).generateSecretKey(); will(returnValue(key)); oneOf(crypto).encryptWithPassword(key.getBytes(), password, keyStrengthener); will(returnValue(encryptedKey)); }});  assertFalse(accountManager.hasDatabaseKey());  assertTrue(accountManager.createAccount(authorName, password));  assertTrue(accountManager.hasDatabaseKey()); SecretKey dbKey = accountManager.getDatabaseKey(); "<AssertPlaceHolder>"; assertArrayEquals(key.getBytes(), dbKey.getBytes());  assertEquals(encryptedKeyHex, loadDatabaseKey(keyFile)); assertEquals(encryptedKeyHex, loadDatabaseKey(keyBackupFile)); }
getDatabaseKey() { return databaseKey; }
[*] target: assertNotNull(dbKey)
[-] pred: org. junit. Assert. assertNotNull ( dbKey )
************************************
************************************
[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, tag, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, 0, false);  // Expect the tag, stream header, frame header, payload and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(tag); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, false, payloadLength, 0); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )
************************************
************************************
[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, tag, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, 0, true);  // Expect the tag, stream header, frame header, payload and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(tag); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, true, payloadLength, 0); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )
************************************
************************************
[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, null, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, 0, false);  // Expect the stream header, frame header, payload and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, false, payloadLength, 0); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )
************************************
************************************
[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, null, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, 0, true);  // Expect the stream header, frame header, payload and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, true, payloadLength, 0); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )
************************************
************************************
[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, tag, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, paddingLength, false);  // Expect the tag, stream header, frame header, payload, padding and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(tag); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, false, payloadLength, paddingLength); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[paddingLength]); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )
************************************
************************************
[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, tag, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, paddingLength, true);  // Expect the tag, stream header, frame header, payload, padding and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(tag); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, true, payloadLength, paddingLength); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[paddingLength]); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )
************************************
************************************
[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, null, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, paddingLength, false);  // Expect the stream header, frame header, payload, padding and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, false, payloadLength, paddingLength); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[paddingLength]); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )
************************************
************************************
[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, null, streamHeaderNonce, streamHeaderKey, frameKey);  s.writeFrame(payload, payloadLength, paddingLength, true);  // Expect the stream header, frame header, payload, padding and MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, true, payloadLength, paddingLength); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[paddingLength]); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )
************************************
************************************
[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, tag, streamHeaderNonce, streamHeaderKey, frameKey); int payloadLength1 = 345, paddingLength1 = 456; byte[] payload1 = TestUtils.getRandomBytes(payloadLength1);  s.writeFrame(payload, payloadLength, paddingLength, false); s.writeFrame(payload1, payloadLength1, paddingLength1, true);  // Expect the tag, stream header, first frame header, payload, padding, // MAC, second frame header, payload, padding, MAC ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(tag); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader, false, payloadLength, paddingLength); expected.write(expectedFrameHeader); expected.write(payload); expected.write(new byte[paddingLength]); expected.write(new byte[MAC_LENGTH]); byte[] expectedFrameHeader1 = new byte[FRAME_HEADER_LENGTH]; FrameEncoder.encodeHeader(expectedFrameHeader1, true, payloadLength1, paddingLength1); expected.write(expectedFrameHeader1); expected.write(payload1); expected.write(new byte[paddingLength1]); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
writeFrame(byte[] payload, int payloadLength, int paddingLength, boolean finalFrame) throws IOException { if (payloadLength < 0 || paddingLength < 0) throw new IllegalArgumentException(); if (payloadLength + paddingLength > MAX_PAYLOAD_LENGTH) throw new IllegalArgumentException(); // Don't allow the frame counter to wrap if (frameNumber < 0) throw new IOException(); // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); // Encode the frame header FrameEncoder.encodeHeader(frameHeader, finalFrame, payloadLength, paddingLength); // Encrypt and authenticate the frame header FrameEncoder.encodeNonce(frameNonce, frameNumber, true); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(frameHeader, 0, FRAME_HEADER_PLAINTEXT_LENGTH, frameCiphertext, 0); if (encrypted != FRAME_HEADER_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Combine the payload and padding System.arraycopy(payload, 0, framePlaintext, 0, payloadLength); for (int i = 0; i < paddingLength; i++) framePlaintext[payloadLength + i] = 0; // Encrypt and authenticate the payload and padding FrameEncoder.encodeNonce(frameNonce, frameNumber, false); try { cipher.init(true, frameKey, frameNonce); int encrypted = cipher.process(framePlaintext, 0, payloadLength + paddingLength, frameCiphertext, FRAME_HEADER_LENGTH); if (encrypted != payloadLength + paddingLength + MAC_LENGTH) throw new RuntimeException(); } catch (GeneralSecurityException badCipher) { throw new RuntimeException(badCipher); } // Write the frame out.write(frameCiphertext, 0, FRAME_HEADER_LENGTH + payloadLength + paddingLength + MAC_LENGTH); frameNumber++; }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )
************************************
************************************
[+] input: Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamEncrypterImpl s = new StreamEncrypterImpl(out, cipher, streamNumber, null, streamHeaderNonce, streamHeaderKey, frameKey);  // Flush the stream once s.flush();  // Expect the stream header ByteArrayOutputStream expected = new ByteArrayOutputStream(); expected.write(streamHeaderNonce); expected.write(protocolVersionBytes); expected.write(streamNumberBytes); expected.write(frameKey.getBytes()); expected.write(new byte[MAC_LENGTH]);  "<AssertPlaceHolder>"; }
flush() throws IOException { // Write the tag if required if (writeTag) writeTag(); // Write the stream header if required if (writeStreamHeader) writeStreamHeader(); out.flush(); }
[*] target: assertArrayEquals(expected.toByteArray(), out.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expected. toByteArray ( ), out. toByteArray ( ) )
************************************
************************************
[+] input: Exception { Collection<MessageId> messagesToAck = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToAck(txn, contactId, 123); will(returnValue(messagesToAck)); oneOf(database).lowerAckFlag(txn, contactId, messagesToAck); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Ack a = db.generateAck(transaction, contactId, 123); "<AssertPlaceHolder>"; assertEquals(messagesToAck, a.getMessageIds()); }); }
generateAck(Transaction transaction, ContactId c, int maxMessages) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToAck(txn, c, maxMessages); if (ids.isEmpty()) return null; db.lowerAckFlag(txn, c, ids); return new Ack(ids); }
[*] target: assertNotNull(a)
[-] pred: org. junit. Assert. assertNotNull ( a )
************************************
************************************
[+] input: Exception { MessageId messageId1 = new MessageId(getRandomId()); Collection<MessageId> ids = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToOffer(txn, contactId, 123, maxLatency); will(returnValue(ids)); oneOf(database).updateRetransmissionData(txn, contactId, messageId, maxLatency); oneOf(database).updateRetransmissionData(txn, contactId, messageId1, maxLatency); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Offer o = db.generateOffer(transaction, contactId, 123, maxLatency); "<AssertPlaceHolder>"; assertEquals(ids, o.getMessageIds()); }); }
generateOffer(Transaction transaction, ContactId c, int maxMessages, long maxLatency) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToOffer(txn, c, maxMessages, maxLatency); if (ids.isEmpty()) return null; for (MessageId m : ids) db.updateRetransmissionData(txn, c, m, maxLatency); return new Offer(ids); }
[*] target: assertNotNull(o)
[-] pred: org. junit. Assert. assertNotNull ( o )
************************************
************************************
[+] input: Exception { MessageId messageId1 = new MessageId(getRandomId()); Collection<MessageId> ids = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToRequest(txn, contactId, 123); will(returnValue(ids)); oneOf(database).removeOfferedMessages(txn, contactId, ids); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Request r = db.generateRequest(transaction, contactId, 123); "<AssertPlaceHolder>"; assertEquals(ids, r.getMessageIds()); }); }
generateRequest(Transaction transaction, ContactId c, int maxMessages) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToRequest(txn, c, maxMessages); if (ids.isEmpty()) return null; db.removeOfferedMessages(txn, c, ids); return new Request(ids); }
[*] target: assertNotNull(r)
[-] pred: org. junit. Assert. assertNotNull ( r )
************************************
************************************
[+] input: Exception { Database<Connection> db = open(false);  // Simulating a dirty shutdown here, look at #testShutdownDirty for // details. List<String> unloadedDrivers = unloadDrivers();  try { db.close(); fail(); } catch (Exception e) { // continue }  reloadDrivers(unloadedDrivers);  db = open(true); assertTrue(db.wasDirtyOnInitialisation());  db.close(); db = open(true); "<AssertPlaceHolder>"; }
wasDirtyOnInitialisation() { return wasDirtyOnInitialisation; }
[*] target: assertFalse(db.wasDirtyOnInitialisation())
[-] pred: org. junit. Assert. assertFalse ( db. wasDirtyOnInitialisation ( ) )
************************************
************************************
[+] input: Exception { OutgoingSessionRecord sessionRecord = new OutgoingSessionRecord();  expectCheckForOrphans(); manager.eventOccurred(new TransportActiveEvent(ID));  context.checking(new Expectations() {{ oneOf(pluginManager).getPlugin(ID); will(returnValue(plugin)); oneOf(plugin).createWriter(with(any(TransportProperties.class))); will(returnValue(transportConnectionWriter)); oneOf(transportConnectionWriter).dispose(false); oneOf(connectionManager).manageOutgoingConnection(with(contactId), with(ID), with(any(TransportConnectionWriter.class)), with(sessionRecord)); // The session succeeds. We need to use an action for this, as // createAndWriteTempFileForUpload() waits for it to happen before // returning will(new ConsumeArgumentAction<>(TransportConnectionWriter.class, 2, writer -> { try { writer.dispose(false); } catch (IOException e) { fail(); } } )); }});  File f = manager.createAndWriteTempFileForUpload(contactId, sessionRecord); "<AssertPlaceHolder>"; }
createAndWriteTempFileForUpload(ContactId contactId, OutgoingSessionRecord sessionRecord) throws IOException { File f = createTempFile(UPLOAD_DIR_NAME); // We shouldn't reach this point until the plugin has been started SimplexPlugin plugin = (SimplexPlugin) requireNonNull(pluginManager.getPlugin(ID)); TransportProperties p = new TransportProperties(); p.put(PROP_PATH, f.getAbsolutePath()); TransportConnectionWriter writer = plugin.createWriter(p); if (writer == null) { delete(f); throw new IOException(); } MailboxFileWriter decorated = new MailboxFileWriter(writer); LOG.info("Writing file for upload"); connectionManager.manageOutgoingConnection(contactId, ID, decorated, sessionRecord); if (decorated.awaitDisposal()) { // An exception was thrown during the session - delete the file delete(f); throw new IOException(); } return f; }
[*] target: assertTrue(f.exists())
[-] pred: org. junit. Assert. assertTrue ( f. exists ( ) )
************************************
************************************
[+] input: Exception { Transaction txn = new Transaction(null, true);  context.checking(new Expectations() {{ oneOf(settingsManager).getSettings(txn, SETTINGS_NAMESPACE); will(returnValue(pairedSettings)); }});  MailboxProperties properties = manager.getOwnMailboxProperties(txn); "<AssertPlaceHolder>"; assertEquals(onion, properties.getOnion()); assertEquals(token, properties.getAuthToken()); assertEquals(serverSupports, properties.getServerSupports()); assertTrue(properties.isOwner()); }
getOwnMailboxProperties(Transaction txn) throws DbException { Settings s = settingsManager.getSettings(txn, SETTINGS_NAMESPACE); String onion = s.get(SETTINGS_KEY_ONION); String token = s.get(SETTINGS_KEY_TOKEN); if (isNullOrEmpty(onion) || isNullOrEmpty(token)) return null; List<MailboxVersion> serverSupports = parseServerSupports(s); try { MailboxAuthToken tokenId = MailboxAuthToken.fromString(token); return new MailboxProperties(onion, tokenId, serverSupports); } catch (InvalidMailboxIdException e) { throw new DbException(e); } }
[*] target: assertNotNull(properties)
[-] pred: org. junit. Assert. assertNotNull ( properties )
************************************
************************************
[+] input: Exception { context.checking(new Expectations() {{ oneOf(clientHelper).getGroupMetadataAsDictionary(groupId); will(returnValue(dictionary)); }}); MessageId loadedId = messageTracker.loadStoredMessageId(groupId); "<AssertPlaceHolder>"; assertEquals(messageId, loadedId); }
loadStoredMessageId(GroupId g) throws DbException;  /** * Stores the message id for the respective group id. Exactly one message id * can be stored for any group id at any time, older values are overwritten. */ void storeMessageId(GroupId g, MessageId m) throws DbException;  /** * Marks a message as read or unread and updates the group count. * * @return True if the message was previously marked as read */ boolean setReadFlag(Transaction txn, GroupId g, MessageId m, boolean read) throws DbException;  /** * Resets the {@link GroupCount}
[*] target: assertNotNull(loadedId)
[-] pred: org. junit. Assert. assertNotNull ( loadedId )
************************************
************************************
[+] input: Exception { BdfDictionary query = BdfDictionary.of(new BdfEntry("q", "u")); Message message2 = getMessage(contactGroup.getId()); Collection<MessageId> results = asList(message.getId(), message2.getId()); long time1 = 1L, time2 = 2L; String groupName = getRandomString(MAX_GROUP_NAME_LENGTH); byte[] salt = getRandomBytes(GROUP_SALT_LENGTH); InviteMessage inviteMessage1 = new InviteMessage(message.getId(), contactGroup.getId(), privateGroup.getId(), time1, groupName, author, salt, null, getRandomBytes(5), NO_AUTO_DELETE_TIMER); InviteMessage inviteMessage2 = new InviteMessage(message2.getId(), contactGroup.getId(), privateGroup.getId(), time2, groupName, author, salt, null, getRandomBytes(5), NO_AUTO_DELETE_TIMER); PrivateGroup pg = new PrivateGroup(group, groupName, author, salt);  context.checking(new DbExpectations() {{ oneOf(messageParser).getInvitesAvailableToAnswerQuery(); will(returnValue(query)); oneOf(db).transactionWithResult(with(true), withDbCallable(txn)); oneOf(db).getContacts(txn); will(returnValue(singletonList(contact))); oneOf(contactGroupFactory).createContactGroup(CLIENT_ID, MAJOR_VERSION, contact); will(returnValue(contactGroup)); oneOf(clientHelper).getMessageIds(txn, contactGroup.getId(), query); will(returnValue(results)); // message 1 oneOf(messageParser).getInviteMessage(txn, message.getId()); will(returnValue(inviteMessage1)); oneOf(privateGroupFactory).createPrivateGroup(groupName, author, salt); will(returnValue(pg)); // message 2 oneOf(messageParser).getInviteMessage(txn, message2.getId()); will(returnValue(inviteMessage2)); oneOf(privateGroupFactory).createPrivateGroup(groupName, author, salt); will(returnValue(pg)); }});  Collection<GroupInvitationItem> items = groupInvitationManager.getInvitations(); "<AssertPlaceHolder>"; for (GroupInvitationItem i : items) { assertEquals(contact, i.getCreator()); assertEquals(author, i.getCreator().getAuthor()); assertEquals(privateGroup.getId(), i.getId()); assertEquals(groupName, i.getName()); } }
getInvitations() throws DbException { return db.transactionWithResult(true, this::getInvitations); }
[*] target: assertEquals(2, items.size())
[-] pred: org. junit. Assert. assertEquals ( 2, items. size ( ) )
************************************
************************************
[+] input: testGroupTasksByDate() { List<Task> tasks = new ArrayList<>(); ProjectStub projectStub = new ProjectStub(); ReminderSetting reminderSetting = new ReminderSetting(null, null, 1); Task t1 = TestHelpers.getTaskRepoModel(1L, "Michael_Zhou", "2020-03-03", null, "America/Los_Angeles", "t1", 0, projectStub, null, reminderSetting); Task t2 = TestHelpers.getTaskRepoModel(2L, "Michael_Zhou", "2020-03-04", null, "America/Los_Angeles", "t2", 0, projectStub, null, reminderSetting); Task t3 = TestHelpers.getTaskRepoModel(3L, "Michael_Zhou", "2020-03-05", null, "America/Los_Angeles", "t3", 0, projectStub, null, reminderSetting); Task t4 = TestHelpers.getTaskRepoModel(4L, "Michael_Zhou", "2020-03-06", null, "America/Los_Angeles", "t4", 0, projectStub, null, reminderSetting);  tasks.add(t1); tasks.add(t2); tasks.add(t3); tasks.add(t4);  Map<ZonedDateTime, List<Task>> map = ProjectItemsGrouper.groupTasksByDate(tasks, true, "America/Los_Angeles"); "<AssertPlaceHolder>"; for (Map.Entry<ZonedDateTime, List<Task>> entry : map.entrySet()) { List<Task> t = entry.getValue(); assertTrue(tasks.contains(t.get(0))); } }
groupTasksByDate(List<Task> tasks, boolean keepTaskWithNoDueDate, String timezone) { Map<ZonedDateTime, List<Task>> map = new HashMap<>(); for (Task task : tasks) { String dueDate = task.getDueDate(); String dueTime = task.getDueTime(); if (dueDate == null) { if (!keepTaskWithNoDueDate) { continue; } ZonedDateTime deadline = ZonedDateTimeHelper.getNow(task.getTimezone()); dueDate = deadline.format(ZonedDateTimeHelper.DATE_FORMATTER); dueTime = deadline.format(ZonedDateTimeHelper.TIME_FORMATTER); } ZonedDateTime zonedDateTime = ZonedDateTimeHelper .getDateInDifferentZone(dueDate, dueTime, task.getTimezone(), timezone); map.computeIfAbsent(zonedDateTime, x -> new ArrayList<>()).add(task); } return map; }
[*] target: assertEquals(4, map.size())
[-] pred: org. junit. Assert. assertEquals ( 4, map. size ( ) )
************************************
************************************
[+] input: testAdjustDelta() { String web = "{"delta":{"ops":[{"insert":{"emoji":"joy"}},{"insert":"\\n"}]}}"; DeltaContent deltaContent = new DeltaContent(web); String adjustExpected = "{"delta":{"ops":[{"insert":"\uD83D\uDE02"},{"insert":"\\n"}]}}"; Assert."<AssertPlaceHolder>"; }
toJSON() { return GSON.toJson(this); }
[*] target: assertEquals(adjustExpected, deltaContent.toJSON())
[-] pred: org. junit. Assert. assertEquals ( adjustExpected, deltaContent. toJSON() )
************************************
************************************
[+] input: testEmoji() { String webInsert = "{"emoji":"100"}"; String mobileExpected = "{"insert":"\uD83D\uDCAF"}"; LinkedHashMap emojiMap = GSON.fromJson(webInsert, LinkedHashMap.class); String res = GSON.toJson(DeltaConverter.WebToMobile.webToMobileEmoji(emojiMap)); Assert."<AssertPlaceHolder>"; }
webToMobileEmoji(Map insertMap) { LinkedHashMap mobileElement = new LinkedHashMap(); String val = (String) insertMap.get("emoji"); LOGGER.info(" webToMobileEmoji val=" + val); mobileElement.put("insert", EmojiConverter.nameToSurrogatePair(val).get()); return mobileElement; }
[*] target: assertEquals(mobileExpected, res)
[-] pred: org. junit. Assert. assertEquals ( mobileExpected, res )
************************************
************************************
[+] input: compareEqual() { Tuple t1 = new Tuple("foo", 1d); Tuple t2 = new Tuple("foo", 1d);  assertEquals(0, t1.compareTo(t2)); assertEquals(0, t2.compareTo(t1)); assertTrue(t1.equals(t2)); // directly calling Tuple.equals() "<AssertPlaceHolder>"; // directly calling Tuple.equals() }
equals(Object obj) { if (obj == null) return false; if (obj == this) return true; if (!(obj instanceof Tuple)) return false;  Tuple other = (Tuple) obj; if (!Arrays.equals(element, other.element)) return false; return Objects.equals(score, other.score); }
[*] target: assertTrue(t2.equals(t1))
[-] pred: org. junit. Assert. assertTrue ( t2. equals ( t1 ) )
************************************
************************************
[+] input: compareNoMatch() { Tuple t1 = new Tuple("foo", 1d); Tuple t2 = new Tuple("bar", 2d);  assertEquals(-1, t1.compareTo(t2)); assertEquals(1, t2.compareTo(t1)); assertFalse(t1.equals(t2)); // directly calling Tuple.equals() "<AssertPlaceHolder>"; // directly calling Tuple.equals() }
equals(Object obj) { if (obj == null) return false; if (obj == this) return true; if (!(obj instanceof Tuple)) return false;  Tuple other = (Tuple) obj; if (!Arrays.equals(element, other.element)) return false; return Objects.equals(score, other.score); }
[*] target: assertFalse(t2.equals(t1))
[-] pred: org. junit. Assert. assertFalse ( t2. equals ( t1 ) )
************************************
************************************
[+] input: testSameElement() { Tuple t1 = new Tuple("user1", 10.0); Tuple t2 = new Tuple("user1", 5.0);  // Intentionally skipping compareTo. assertFalse(t1.equals(t2)); // directly calling Tuple.equals() "<AssertPlaceHolder>"; // directly calling Tuple.equals()  HashSet<Tuple> hashSet = new HashSet<Tuple>(); hashSet.add(t1); hashSet.add(t2); assertEquals(2, hashSet.size()); }
equals(Object obj) { if (obj == null) return false; if (obj == this) return true; if (!(obj instanceof Tuple)) return false;  Tuple other = (Tuple) obj; if (!Arrays.equals(element, other.element)) return false; return Objects.equals(score, other.score); }
[*] target: assertFalse(t2.equals(t1))
[-] pred: org. junit. Assert. assertFalse ( t2. equals ( t1 ) )
************************************
************************************
[+] input: canCreateAHit() { CacheGetResult<String> hit = CacheGetResult.hit("180!!!", 180L); "<AssertPlaceHolder>"; }
hit(final T value, final long validFrom) { return CacheGetResultImpl.getHit(value, validFrom); }
[*] target: assertNotNull(hit)
[-] pred: org. junit. Assert. assertNotNull ( hit )
************************************
************************************
[+] input: canCreateAMiss() { CacheGetResult<Object> miss = CacheGetResult.miss(); "<AssertPlaceHolder>"; }
miss() { return CacheGetResultImpl.getMiss(); }
[*] target: assertNotNull(miss)
[-] pred: org. junit. Assert. assertNotNull ( miss )
************************************
************************************
[+] input: cacheGetOnNonExistingRowDoesntCrash() { ChronoDBCache cache = createCacheOfSize(1); String branch = ChronoDBConstants.MASTER_BRANCH_IDENTIFIER; CacheGetResult<Object> result = cache.get(branch, 1234, QualifiedKey.createInDefaultKeyspace("Fake")); "<AssertPlaceHolder>"; assertTrue(result.isMiss()); }
get(final String branch, final long timestamp, final QualifiedKey qualifiedKey) { checkNotNull(branch, "Precondition violation - argument 'branch' must not be NULL!"); checkArgument(timestamp >= 0, "Precondition violation - argument 'timestamp' must not be negative!"); checkNotNull(qualifiedKey, "Precondition violation - argument 'qualifiedKey' must not be NULL!"); this.lock.readLock().lock(); try { Map<QualifiedKey, MosaicRow> qKeyToRow = this.contents.get(branch); if (qKeyToRow == null) { this.statistics.registerMiss(); return CacheGetResult.miss(); // qKeyToRow = Maps.newConcurrentMap(); // this.contents.put(branch, qKeyToRow); } MosaicRow row = qKeyToRow.get(qualifiedKey); if (row == null) { this.statistics.registerMiss(); return CacheGetResult.miss(); } return row.get(timestamp); } finally { this.lock.readLock().unlock(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: canCalculateAdditiveDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Doe"); p2.setHobbies("Swimming", "Skiing", "Cinema", "Reading"); p2.setPets("Cat", "Dog", "Fish"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); indices.add(petsIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertTrue(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(hobbiesIndex, petsIndex), diff.getChangedIndices()); assertEquals(Sets.newHashSet("Cinema", "Reading"), diff.getAdditions(hobbiesIndex)); assertEquals(Sets.newHashSet("Cat", "Dog", "Fish"), diff.getAdditions(petsIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateSubtractiveDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing", "Cinema", "Reading"); p1.setPets("Cat", "Dog", "Fish"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Doe"); p2.setHobbies("Swimming", "Skiing"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); indices.add(petsIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertTrue(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(hobbiesIndex, petsIndex), diff.getChangedIndices()); assertEquals(Sets.newHashSet("Cinema", "Reading"), diff.getRemovals(hobbiesIndex)); assertEquals(Sets.newHashSet("Cat", "Dog", "Fish"), diff.getRemovals(petsIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateEntryAdditionDiff() { Person johnDoe = createJohnDoe(); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex favoriteColorIndex = new DummyIndex(PersonIndexer.favoriteColor(), "favoriteColor"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(favoriteColorIndex); indices.add(hobbiesIndex); indices.add(petsIndex);  // simulate the addition of John Doe IndexValueDiff diff = IndexingUtils.calculateDiff(indices, null, johnDoe); "<AssertPlaceHolder>"; assertTrue(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); assertTrue(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(firstNameIndex, lastNameIndex, hobbiesIndex), diff.getChangedIndices());  assertEquals(Sets.newHashSet("John"), diff.getAdditions(firstNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(firstNameIndex));  assertEquals(Sets.newHashSet("Doe"), diff.getAdditions(lastNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(lastNameIndex));  assertEquals(Sets.newHashSet("Swimming", "Skiing"), diff.getAdditions(hobbiesIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(hobbiesIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateEntryRemovalDiff() { Person johnDoe = createJohnDoe(); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex favoriteColorIndex = new DummyIndex(PersonIndexer.favoriteColor(), "favoriteColor"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(favoriteColorIndex); indices.add(hobbiesIndex); indices.add(petsIndex); // simulate the deletion of John Doe IndexValueDiff diff = IndexingUtils.calculateDiff(indices, johnDoe, null); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertTrue(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertTrue(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(firstNameIndex, lastNameIndex, hobbiesIndex), diff.getChangedIndices());  assertEquals(Collections.emptySet(), diff.getAdditions(firstNameIndex)); assertEquals(Sets.newHashSet("John"), diff.getRemovals(firstNameIndex));  assertEquals(Collections.emptySet(), diff.getAdditions(lastNameIndex)); assertEquals(Sets.newHashSet("Doe"), diff.getRemovals(lastNameIndex));  assertEquals(Collections.emptySet(), diff.getAdditions(hobbiesIndex)); assertEquals(Sets.newHashSet("Swimming", "Skiing"), diff.getRemovals(hobbiesIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateMixedDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Smith"); p2.setHobbies("Skiing", "Cinema"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertTrue(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Collections.emptySet(), diff.getAdditions(firstNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(firstNameIndex)); assertFalse(diff.isIndexChanged(firstNameIndex)); assertEquals(Collections.singleton("Smith"), diff.getAdditions(lastNameIndex)); assertEquals(Collections.singleton("Doe"), diff.getRemovals(lastNameIndex)); assertTrue(diff.isIndexChanged(lastNameIndex)); assertEquals(Collections.singleton("Cinema"), diff.getAdditions(hobbiesIndex)); assertEquals(Collections.singleton("Swimming"), diff.getRemovals(hobbiesIndex)); assertTrue(diff.isIndexChanged(hobbiesIndex)); assertEquals(Sets.newHashSet(lastNameIndex, hobbiesIndex), diff.getChangedIndices()); assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCreateEmptyDiff() { MutableIndexValueDiff diff = new MutableIndexValueDiff(null, null); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmptyAddition() { MutableIndexValueDiff diff = new MutableIndexValueDiff(null, new Object()); assertNotNull(diff); "<AssertPlaceHolder>"; assertTrue(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmptyRemoval() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), null); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertTrue(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmtpyUpdate() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), new Object()); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canDetectThatDiffisAdditive() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), new Object()); DummyIndex testIndex = new DummyIndex(new FirstNameIndexer(), "test"); diff.add(testIndex, "Hello World"); diff.add(testIndex, "Foo Bar"); assertTrue(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertFalse(diff.isMixed()); "<AssertPlaceHolder>"; }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertFalse(diff.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( diff. isEmpty() )
************************************
************************************
[+] input: canDetectThatDiffIsSubtractive() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), new Object()); DummyIndex testIndex = new DummyIndex(new FirstNameIndexer(), "test"); diff.removeSingleValue(testIndex, "Hello World"); diff.removeSingleValue(testIndex, "Foo Bar"); assertFalse(diff.isAdditive()); assertTrue(diff.isSubtractive()); assertFalse(diff.isMixed()); "<AssertPlaceHolder>"; }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertFalse(diff.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( diff. isEmpty() )
************************************
************************************
[+] input: canDetectThatDiffIsMixed() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), new Object()); DummyIndex testIndex = new DummyIndex(new FirstNameIndexer(), "test"); diff.add(testIndex, "Hello World"); diff.removeSingleValue(testIndex, "Foo Bar"); assertFalse(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertTrue(diff.isMixed()); "<AssertPlaceHolder>"; }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertFalse(diff.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( diff. isEmpty() )
************************************
************************************
[+] input: canScanForMigrationChain() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA1.class); expectedClasses.add(MigrationA2.class); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred: org. junit. Assert. assertEquals ( expectedClasses, actualClasses )
************************************
************************************
[+] input: canLimitMigrationChainArbitrarilyBetweenVersions() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); chain = chain.startingAt(ChronosVersion.parse("0.6.0")); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred: org. junit. Assert. assertEquals ( expectedClasses, actualClasses )
************************************
************************************
[+] input: canLimitMigrationChainPreciselyAtVersion() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); chain = chain.startingAt(ChronosVersion.parse("0.5.1")); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA2.class); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred: org. junit. Assert. assertEquals ( expectedClasses, actualClasses )
************************************
************************************
[+] input: serializationFormatOrderingWorks() { InverseUnqualifiedTemporalKey k1 = new InverseUnqualifiedTemporalKey(1, "a"); InverseUnqualifiedTemporalKey k2 = new InverseUnqualifiedTemporalKey(10, "a"); InverseUnqualifiedTemporalKey k3 = new InverseUnqualifiedTemporalKey(1, "aa"); InverseUnqualifiedTemporalKey k4 = new InverseUnqualifiedTemporalKey(100, "aaa"); InverseUnqualifiedTemporalKey k5 = new InverseUnqualifiedTemporalKey(1, "ab"); InverseUnqualifiedTemporalKey k6 = new InverseUnqualifiedTemporalKey(10, "ab"); InverseUnqualifiedTemporalKey k7 = new InverseUnqualifiedTemporalKey(1, "b"); InverseUnqualifiedTemporalKey k8 = new InverseUnqualifiedTemporalKey(10, "b");  List<InverseUnqualifiedTemporalKey> keyList = Lists.newArrayList(k1, k2, k3, k4, k5, k6, k7, k8); List<String> stringList = keyList.stream().map(key -> key.toSerializableFormat()).collect(Collectors.toList()); Collections.sort(keyList); Collections.sort(stringList); System.out.println("Key List:"); for (InverseUnqualifiedTemporalKey key : keyList) { System.out.println("\t" + key.toSerializableFormat()); } System.out.println("String List:"); for (String key : stringList) { System.out.println("\t" + key); } for (int i = 0; i < keyList.size(); i++) { InverseUnqualifiedTemporalKey key = keyList.get(i); String string = stringList.get(i); "<AssertPlaceHolder>"; } }
toSerializableFormat() { String timestampString = Strings.padStart(String.valueOf(this.timestamp), 19, '0'); return timestampString + SEPARATOR + this.key; }
[*] target: assertEquals(key.toSerializableFormat(), string)
[-] pred: org. junit. Assert. assertEquals ( key. toSerializableFormat ( ), string )
************************************
************************************
[+] input: createRangePeriodWorks() { Period range = Period.createRange(0, 100); assertNotNull(range); assertEquals(0, range.getLowerBound()); assertEquals(100, range.getUpperBound()); "<AssertPlaceHolder>"; }
isEmpty() { return this.getLowerBound() >= this.getUpperBound(); }
[*] target: assertFalse(range.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( range. isEmpty() )
************************************
************************************
[+] input: createPointPeriodWorks() { Period point = Period.createPoint(100); assertNotNull(point); assertEquals(100, point.getLowerBound()); assertEquals(101, point.getUpperBound()); "<AssertPlaceHolder>"; }
isEmpty() { return this.getLowerBound() >= this.getUpperBound(); }
[*] target: assertFalse(point.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( point. isEmpty() )
************************************
************************************
[+] input: createEmptyPeriodWorks() { Period empty = Period.empty(); assertNotNull(empty); "<AssertPlaceHolder>"; }
isEmpty() { return this.getLowerBound() >= this.getUpperBound(); }
[*] target: assertTrue(empty.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( empty. isEmpty() )
************************************
************************************
[+] input: emptyPeriodIsSingleton() { Period empty1 = Period.empty(); Period empty2 = Period.empty(); "<AssertPlaceHolder>"; assertNotNull(empty2); assertTrue(empty1 == empty2); }
empty() { return PeriodImpl.empty(); }
[*] target: assertNotNull(empty1)
[-] pred: org. junit. Assert. assertNotNull ( empty1 )
************************************
************************************
[+] input: eternalPeriodIsSingleton() { Period eternal1 = Period.eternal(); Period eternal2 = Period.eternal(); "<AssertPlaceHolder>"; assertNotNull(eternal2); assertTrue(eternal1 == eternal2); }
eternal() { return PeriodImpl.eternal(); }
[*] target: assertNotNull(eternal1)
[-] pred: org. junit. Assert. assertNotNull ( eternal1 )
************************************
************************************
[+] input: testSerializationFormatOrdering() { UnqualifiedTemporalKey k1 = new UnqualifiedTemporalKey("a", 1); UnqualifiedTemporalKey k2 = new UnqualifiedTemporalKey("a", 10); UnqualifiedTemporalKey k3 = new UnqualifiedTemporalKey("aa", 1); UnqualifiedTemporalKey k4 = new UnqualifiedTemporalKey("aaa", 100); UnqualifiedTemporalKey k5 = new UnqualifiedTemporalKey("ab", 1); UnqualifiedTemporalKey k6 = new UnqualifiedTemporalKey("ab", 10); UnqualifiedTemporalKey k7 = new UnqualifiedTemporalKey("b", 1); UnqualifiedTemporalKey k8 = new UnqualifiedTemporalKey("b", 10);  List<UnqualifiedTemporalKey> keyList = Lists.newArrayList(k1, k2, k3, k4, k5, k6, k7, k8); List<String> stringList = keyList.stream().map(key -> key.toSerializableFormat()).collect(Collectors.toList()); Collections.sort(keyList); Collections.sort(stringList); System.out.println("Key List:"); for (UnqualifiedTemporalKey key : keyList) { System.out.println("\t" + key.toSerializableFormat()); } System.out.println("String List:"); for (String key : stringList) { System.out.println("\t" + key); } for (int i = 0; i < keyList.size(); i++) { UnqualifiedTemporalKey key = keyList.get(i); String string = stringList.get(i); "<AssertPlaceHolder>"; } }
toSerializableFormat() { String timestampString = Strings.padStart(String.valueOf(this.timestamp), 19, '0'); return this.key + SEPARATOR + timestampString; }
[*] target: assertEquals(key.toSerializableFormat(), string)
[-] pred: org. junit. Assert. assertEquals ( key. toSerializableFormat ( ), string )
************************************
************************************
[+] input: canCreateInMemoryDatabaseEasily() { // without additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().inMemoryGraph().build()) { assertNotNull(graph); } // with additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().inMemoryGraph(config -> config.assumeCachedValuesAreImmutable(true)).build()) { "<AssertPlaceHolder>"; } }
create();
[*] target: assertNotNull(graph)
[-] pred: org. junit. Assert. assertNotNull ( graph )
************************************
************************************
[+] input: Exception { File directory = Files.createTempDirectory("chronodb-test").toFile(); try { // without additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().exodusGraph(directory.getAbsolutePath()).build()) { assertNotNull(graph); } // with additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().exodusGraph(directory.getAbsolutePath(), config -> config.assumeCachedValuesAreImmutable(true)).build()) { "<AssertPlaceHolder>"; } } finally { FileUtils.deleteDirectory(directory); } }
create();
[*] target: assertNotNull(graph)
[-] pred: org. junit. Assert. assertNotNull ( graph )
************************************
************************************
[+] input: canConvertBetweenEPackageAndXMI() { EPackage ePackage = EcoreFactory.eINSTANCE.createEPackage(); ePackage.setName("MyEPackage"); EClass eClass = EcoreFactory.eINSTANCE.createEClass(); eClass.setName("MyEClass"); EAttribute eAttribute = EcoreFactory.eINSTANCE.createEAttribute(); eAttribute.setName("MyAttribute"); eAttribute.setEType(EcorePackage.Literals.ESTRING); eAttribute.setLowerBound(0); eAttribute.setUpperBound(1); eClass.getEStructuralFeatures().add(eAttribute); EReference eReference = EcoreFactory.eINSTANCE.createEReference(); eReference.setName("self"); eReference.setEType(eClass); eReference.setUpperBound(-1); eReference.setLowerBound(0); eClass.getEStructuralFeatures().add(eReference); ePackage.getEClassifiers().add(eClass);  String xmi = EMFUtils.writeEPackageToXMI(ePackage); assertNotNull(xmi); assertFalse(xmi.trim().isEmpty());  // print it for debugging purposes System.out.println(xmi);  // deserialize EPackage ePackage2 = EMFUtils.readEPackageFromXMI(xmi); "<AssertPlaceHolder>"; assertEquals("MyEPackage", ePackage2.getName()); EClass eClass2 = (EClass) ePackage2.getEClassifier("MyEClass"); assertNotNull(eClass2); assertEquals("MyEClass", eClass2.getName()); EAttribute eAttribute2 = Iterables.getOnlyElement(eClass2.getEAttributes()); assertNotNull(eAttribute2); assertEquals("MyAttribute", eAttribute2.getName()); assertEquals(0, eAttribute2.getLowerBound()); assertEquals(1, eAttribute2.getUpperBound()); assertEquals(EcorePackage.Literals.ESTRING, eAttribute2.getEType()); EReference eReference2 = Iterables.getOnlyElement(eClass2.getEReferences()); assertNotNull(eReference2); assertEquals("self", eReference2.getName()); assertEquals(eClass2, eReference2.getEReferenceType()); assertEquals(0, eReference2.getLowerBound()); assertEquals(-1, eReference2.getUpperBound());  }
readEPackageFromXMI(final String xmiContents) { checkNotNull(xmiContents, "Precondition violation - argument 'xmiContents' must not be NULL!"); try { List<EObject> eObjects = readEObjectsFromXMI(xmiContents); if (eObjects == null || eObjects.isEmpty()) { return null; } EObject singleObject = Iterables.getOnlyElement(eObjects); if (singleObject instanceof EPackage == false) { throw new IllegalStateException( "Attempted to read EPackage from XMI, but encountered EObject with EClass '" + singleObject.eClass().getName() + "'!"); } return (EPackage) singleObject; } catch (XMIConversionFailedException e) { throw new XMIConversionFailedException("Could not read EPackage from XMI data!", e); } }
[*] target: assertNotNull(ePackage2)
[-] pred: org. junit. Assert. assertNotNull ( ePackage2 )
************************************
************************************
[+] input: canGeneratePerson() { Person person = PersonGenerator.generateRandomPerson(); "<AssertPlaceHolder>"; assertNotNull(person.getFirstName()); assertNotNull(person.getLastName()); assertTrue(person.getFirstName().length() > 0); assertTrue(person.getLastName().length() > 0); }
generateRandomPerson() { Person person = new Person(); person.setFirstName(TestUtils.getRandomEntryOf(FIRST_NAMES)); person.setLastName(TestUtils.getRandomEntryOf(LAST_NAMES)); person.setFavoriteColor(TestUtils.getRandomEntryOf(COLORS)); int numberOfHobbies = TestUtils.randomBetween(0, 3); int numberOfPets = TestUtils.randomBetween(0, 2); person.getHobbies().addAll(TestUtils.getRandomUniqueEntriesOf(HOBBIES, numberOfHobbies)); person.getPets().addAll(TestUtils.getRandomUniqueEntriesOf(PETS, numberOfPets)); return person; }
[*] target: assertNotNull(person)
[-] pred: org. junit. Assert. assertNotNull ( person )
************************************
************************************
[+] input: testNoMatchTransitWithResult() { Map<States, State<States, Events>> stateMap = new HashMap<>(); Transition<States, Events> newTransition = new TransitionImpl<>(); newTransition.setSource(StateHelper.getState(stateMap,States.STATE1)); newTransition.setTarget(StateHelper.getState(stateMap,States.STATE2)); newTransition.setEvent(Events.EVENT1); newTransition.setType(TransitionType.EXTERNAL); newTransition.setCondition(context -> false); Object result = newTransition.transitWithResult(new Object(), true); Assert."<AssertPlaceHolder>"; }
transitWithResult(C request, boolean checkCondition);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testMatchTransitWithResult() { Map<States, State<States, Events>> stateMap = new HashMap<>(); Transition<States, Events> newTransition = new TransitionImpl<>(); newTransition.setSource(StateHelper.getState(stateMap,States.STATE1)); newTransition.setTarget(StateHelper.getState(stateMap,States.STATE2)); newTransition.setEvent(Events.EVENT1); newTransition.setType(TransitionType.EXTERNAL); newTransition.setCondition(context -> true, "true"); newTransition.setAction(action -> new Object()); Object result = newTransition.transitWithResult(new Object(), true); Assert."<AssertPlaceHolder>"; }
transitWithResult(C request, boolean checkCondition);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testTransitInternalException() { Map<States, State<States, Events>> stateMap = new HashMap<>(); Transition<States, Events> newTransition = new TransitionImpl<>(); newTransition.setSource(StateHelper.getState(stateMap,States.STATE1)); newTransition.setTarget(StateHelper.getState(stateMap,States.STATE2)); newTransition.setEvent(Events.EVENT1); newTransition.setType(TransitionType.INTERNAL); newTransition.setCondition(context -> true, "true"); newTransition.setAction(action -> new Object()); Object result = newTransition.transitWithResult(new Object(), true); Assert."<AssertPlaceHolder>"; }
transitWithResult(C request, boolean checkCondition);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { ClassLoader classLoader = this.getClass().getClassLoader(); URL resource = classLoader.getResource("test.json"); File f = new File(resource.getPath()); String s = readString(f); StructuredDataEncoder structuredData = new StructuredDataEncoder(s); byte[] msgHash = structuredData.hashStructuredData(); String ownerAddress = "0xE10AA6471B33845FaE88DD7bBeB63c250DA3a639"; String sig = "4f4e0dec5f1d6f99460fea04bc374d96a495d96c0c455d4731902cdbf95525fc77c66ee08346466fe188f521c196f0f06bebb8d1a8df44cb68792514ca24808e2a"; byte[] signatureBytes = Hex.decode(sig); byte v = signatureBytes[64]; Sign.SignatureData sd = new Sign.SignatureData( v, Arrays.copyOfRange(signatureBytes, 0, 32), Arrays.copyOfRange(signatureBytes, 32, 64));  boolean verified = false; for (int i = 0; i < 4; i++) { BigInteger publicKey = Sign.recoverFromSignature( (byte) i, new ECDSASignature( new BigInteger(1, sd.getR()), new BigInteger(1, sd.getS())), msgHash);  if (publicKey != null) { String addressRecovered = Keys.toChecksumAddress(Keys.getAddress(publicKey)); if (addressRecovered.equals(ownerAddress)) { verified = true; break; } } } "<AssertPlaceHolder>"; }
getAddress(byte[] publicKey) { byte[] hash = new Keccak.Digest256().digest(publicKey); return Arrays.copyOfRange(hash, hash.length - 20, hash.length);  // right most 160 bits }
[*] target: assertTrue(verified)
[-] pred: org. junit. Assert. assertTrue ( verified )
************************************
************************************
[+] input: sizeObject_Empty_0() { JsonMetadataView view = new JsonMetadataView(new JsonObject(), String::compareTo); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, view.size())
[-] pred: org. junit. Assert. assertEquals ( 0, view. size() )
************************************
************************************
[+] input: sizeObject_SingleLevelKeys_NumberOfKeys() { JsonObject root = new JsonObject(); root.add("hello", new JsonPrimitive(10)); root.add("world", new JsonPrimitive(true)); root.add("test", new JsonPrimitive("good morning")); JsonMetadataView view = new JsonMetadataView(root, String::compareTo); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(3, view.size())
[-] pred: org. junit. Assert. assertEquals ( 3, view. size() )
************************************
************************************
[+] input: sizeArray_SingleLevelKeys_NumberOfKeys() { JsonArray root = new JsonArray(); root.add(10); root.add(true); root.add("good morning"); JsonMetadataView view = new JsonMetadataView(root); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(3, view.size())
[-] pred: org. junit. Assert. assertEquals ( 3, view. size() )
************************************
************************************
[+] input: sizeArray_MultiLevelKeys_NumberOfTopLevelKeys() { JsonArray root = new JsonArray(); root.add(10); root.add(true); root.add("good morning"); root.add(new JsonObject()); root.get(3).getAsJsonObject().add("metadata", new JsonPrimitive(20)); root.get(3).getAsJsonObject().add("view", new JsonPrimitive(false)); JsonMetadataView view = new JsonMetadataView(root); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(4, view.size())
[-] pred: org. junit. Assert. assertEquals ( 4, view. size() )
************************************
************************************
[+] input: equals_SameColors_Symmetric() { int first = Color.pack(1, 2, 3, 4); int second = Color.pack(1, 2, 3, 4); "<AssertPlaceHolder>"; assertEquals(second, first); }
pack(int red, int green, int blue, int alpha) { checkComponent(red); checkComponent(green); checkComponent(blue); checkComponent(alpha); return (alpha << ALPHA_OFFSET) | (red << RED_OFFSET) | (green << GREEN_OFFSET) | (blue << BLUE_OFFSET); }
[*] target: assertEquals(first, second)
[-] pred: org. junit. Assert. assertEquals ( first, second )
************************************
************************************
[+] input: equals_SameColors_Transitive() { int first = Color.pack(1, 2, 3, 4); int second = Color.pack(1, 2, 3, 4); int third = Color.pack(1, 2, 3, 4); "<AssertPlaceHolder>"; assertEquals(second, third); assertEquals(first, third); }
pack(int red, int green, int blue, int alpha) { checkComponent(red); checkComponent(green); checkComponent(blue); checkComponent(alpha); return (alpha << ALPHA_OFFSET) | (red << RED_OFFSET) | (green << GREEN_OFFSET) | (blue << BLUE_OFFSET); }
[*] target: assertEquals(first, second)
[-] pred: org. junit. Assert. assertEquals ( first, second )
************************************
************************************
[+] input: construct_EmptyArea_ConstructedCorrectly() { Area rect = new Area(0, 0, 0, 0); assertFalse(rect.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, rect.size())
[-] pred: org. junit. Assert. assertEquals ( 0, rect. size ( ) )
************************************
************************************
[+] input: construct_EmptyWidthArea_ConstructedCorrectly() { Area rect = new Area(0, 0, 0, 10); assertFalse(rect.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, rect.size())
[-] pred: org. junit. Assert. assertEquals ( 0, rect. size ( ) )
************************************
************************************
[+] input: construct_EmptyHeightArea_ConstructedCorrectly() { Area rect = new Area(0, 0, 10, 0); assertFalse(rect.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, rect.size())
[-] pred: org. junit. Assert. assertEquals ( 0, rect. size ( ) )
************************************
************************************
[+] input: buildArea_NoPoints_Empty() { Area.Builder builder = new Area.Builder(); Area area = builder.build(); assertFalse(area.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, area.size())
[-] pred: org. junit. Assert. assertEquals ( 0, area. size() )
************************************
************************************
[+] input: list_SomeMatchAllFiltersClient_MatchingFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; assertTrue(resources.contains(ResourceLocation.parse("textures/hello.png"))); assertTrue(resources.contains(ResourceLocation.parse("textures/block/sea/rock/gravel.png"))); }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(2, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 2, resources. size ( ) )
************************************
************************************
[+] input: list_NoneMatchNamespace_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "other", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: list_NoneMatchPathStart_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "other", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: list_EmptyNamespace_NoExceptionIfOriginalAccepts() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: list_EmptyPathStart_NoExceptionIfOriginalAccepts() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; assertTrue(resources.contains(ResourceLocation.parse("textures/hello.png"))); assertTrue(resources.contains(ResourceLocation.parse("textures/block/sea/rock/gravel.png"))); }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(2, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 2, resources. size ( ) )
************************************
************************************
[+] input: list_NoneMatchFilter_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "textures", (file) -> file.endsWith(".jpg"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: list_AllRootResources_NoneFoundForRootNamespace() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, RootResourcesAdapter.ROOT_NAMESPACE, "pack", (file) -> true);  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertTrue(resources.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( resources. isEmpty ( ) )
************************************
************************************
[+] input: list_SomeNonRootMatchPathStart_NoneFoundForRootNamespace() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, RootResourcesAdapter.ROOT_NAMESPACE, "pack", (file) -> true);  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertTrue(resources.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( resources. isEmpty ( ) )
************************************
************************************
[+] input: list_SomeNonRootMatchFileFilter_NoneFoundForRootNamespace() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, RootResourcesAdapter.ROOT_NAMESPACE, "pack", (file) -> file.contains(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertTrue(resources.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( resources. isEmpty ( ) )
************************************
************************************
[+] input: list_AllRootResources_NoneFound() { RootResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "pack", (file) -> true);  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null"); return ImmutableList.of(); }
[*] target: assertTrue(resources.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( resources. isEmpty ( ) )
************************************
************************************
[+] input: construct_NoViews_NoException() { CombinedMetadataView view = new CombinedMetadataView(List.of()); "<AssertPlaceHolder>"; }
size() { return KEY_TO_VIEW.size(); }
[*] target: assertEquals(0, view.size())
[-] pred: org. junit. Assert. assertEquals ( 0, view. size ( ) )
************************************
************************************
[+] input: loadPacks_ValidParameters_OnePackGiven() { ModRepositorySource repositorySource = new ModRepositorySource(MOCK_RESOURCES_SUPPLIER);  AtomicInteger packsConsumed = new AtomicInteger(); repositorySource.loadPacks((pack) -> packsConsumed.getAndIncrement());  "<AssertPlaceHolder>"; }
loadPacks(Consumer<Pack> consumer) { requireNonNull(consumer, "Pack consumer cannot be null");  Pack pack = new Pack( new PackLocationInfo( PACK_ID, Component.literal(TITLE), PackSource.BUILT_IN, Optional.empty() ), PACK_GETTER, new Pack.Metadata(Component.literal(DESCRIPTION), PackCompatibility.COMPATIBLE, FeatureFlagSet.of(), ImmutableList.of() ), new PackSelectionConfig(true, Pack.Position.TOP, true) );  consumer.accept(pack); }
[*] target: assertEquals(1, packsConsumed.get())
[-] pred: org. junit. Assert. assertEquals ( 1, packsConsumed. get ( ) )
************************************
************************************
[+] input: listResources_PathStartDifferent_NoMatches() { List<ResourceCollection> collections = new ArrayList<>(); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/one.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("texture/two.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("text/three.png"))));  OrderedResourceRepository repository = new OrderedResourceRepository(PackType.CLIENT_RESOURCES, collections);  Collection<ResourceLocation> results = repository.list("ext", (file) -> true); "<AssertPlaceHolder>"; }
list(String pathStart, Predicate<String> fileFilter) { requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "Path filter cannot be null");  return COLLECTIONS.stream().flatMap( (collection) -> collection.namespaces(RESOURCE_TYPE).stream().flatMap( (namespace) -> collection.list(RESOURCE_TYPE, namespace, pathStart, fileFilter).stream() ) ).collect(Collectors.toSet()); }
[*] target: assertEquals(0, results.size())
[-] pred: org. junit. Assert. assertEquals ( 0, results. size ( ) )
************************************
************************************
[+] input: listResources_FilterNoMatch_NoMatches() { List<ResourceCollection> collections = new ArrayList<>(); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/one.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/two.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/three.png"))));  OrderedResourceRepository repository = new OrderedResourceRepository(PackType.CLIENT_RESOURCES, collections);  Collection<ResourceLocation> results = repository.list("textures", (file) -> file.endsWith(".jpg")); "<AssertPlaceHolder>"; }
list(String pathStart, Predicate<String> fileFilter) { requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "Path filter cannot be null");  return COLLECTIONS.stream().flatMap( (collection) -> collection.namespaces(RESOURCE_TYPE).stream().flatMap( (namespace) -> collection.list(RESOURCE_TYPE, namespace, pathStart, fileFilter).stream() ) ).collect(Collectors.toSet()); }
[*] target: assertEquals(0, results.size())
[-] pred: org. junit. Assert. assertEquals ( 0, results. size ( ) )
************************************
************************************
[+] input: load_GetAfterLoad_CacheRetrieved() { TextureCache<Integer, Integer> cache = new TextureCache<>( new TextureLoader<>((texStream, metadata) -> 1, MOCK_READERS, LOGGER) );  OrderedResourceRepository repository = makeMockRepository(Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "test/creeper.png", "test/creeper.png.moremcmeta"));  cache.load(repository, 1, "textures", "test");  ImmutableMap<ResourceLocation, Integer> actual = cache.get(1); ImmutableMap<ResourceLocation, Integer> expected = ImmutableMap.<ResourceLocation, Integer>builder() .put(ResourceLocation.parse("textures/bat.png"), 1) .put(ResourceLocation.parse("test/creeper.png"), 1) .build();  "<AssertPlaceHolder>"; }
get(S newState) { requireNonNull(newState, "State cannot be null");  /* If the cache for the desired state is currently being loaded on another thread, the loading thread will hold the lock, and this thread will proceed once the loading thread releases the lock. */ LOCK.lock(); while (!newState.equals(state)) { IS_CURRENT.awaitUninterruptibly(); }  ImmutableMap<ResourceLocation, R> cacheCopy = ImmutableMap.copyOf(CACHE); LOCK.unlock();  return cacheCopy; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: load_ResultsBasedOnSearch_MetadataAppliesToAllFoundTextures() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size() )
************************************
************************************
[+] input: load_SearchRetrievesPack_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorNotPresent_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorBelow_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ), Set.of( "textures/bat_efgh.png" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorInSame_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta", "textures/bat_efgh.png" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorAbove_PackNotFound() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_efgh.png" ), Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  assertFalse( resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ).isPresent() );  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackSameAsFloor_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_abcd.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_InvalidMetadataDuringRead_LoadsValidTextures() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat.png", "textures/bat.png.moremcmeta", "textures/creeper.png", "textures/zombie.png", "textures/creeper.png.moremcmeta", "textures/zombie.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { if (metadataLocation.getPath().contains("creeper")) { throw new InvalidMetadataException("Dummy exception"); }  return MOCK_READER.parse(metadataLocation, metadataStream, resourceRepository); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures"); "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size() )
************************************
************************************
[+] input: load_SilencedInvalidMetadataDuringRead_LoadsValidTextures() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat.png", "textures/bat.png.moremcmeta", "textures/creeper.png", "textures/zombie.png", "textures/creeper.png.moremcmeta", "textures/zombie.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { if (metadataLocation.getPath().contains("creeper")) { throw new InvalidMetadataException("Dummy exception", new Exception(), true); }  return MOCK_READER.parse(metadataLocation, metadataStream, resourceRepository); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures"); "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size() )
************************************
************************************
[+] input: load_DiffFormatMetadataInPackWithTexture_Conflict() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/zombie.png.other"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/creeper.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: load_DiffFormatMetadataInPackAboveTexture_Conflict() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/creeper.png.other"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: load_SameFormatMetadataInPackAboveTexture_CombinerExceptionExcluded() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/creeper.png2.moremcmeta"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: load_SameFormatMetadataInPackWithTexture_CombinerExceptionExcluded() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/zombie.png2.moremcmeta"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/creeper.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: load_DiffNamespaces_AllLoaded() { OrderedResourceRepository repository = makeMockRepository(Set.of( "test:textures/bat.png", "test:textures/bat.png.moremcmeta", "moremcmeta:textures/creeper.png", "moremcmeta:textures/creeper.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta"));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.fromNamespaceAndPath("test", "textures/bat.png"))); assertTrue(locations.containsKey(ResourceLocation.fromNamespaceAndPath("moremcmeta", "textures/creeper.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(3, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 3, locations. size() )
************************************
************************************
[+] input: width_WidthProvided_SameWidthReturned() { CloseableImageFrame frame = new CloseableImageFrame( new FrameReader.FrameData(100, 200, 0, 0), ImmutableList.of(new MockCloseableImage(100, 200)), 1 );  "<AssertPlaceHolder>"; }
width() { checkOpen(); return WIDTH; }
[*] target: assertEquals(100, frame.width())
[-] pred: org. junit. Assert. assertEquals ( 100, frame. width() )
************************************
************************************
[+] input: frames_MultipleFrames_CountReturned() { FrameGroup<PredefinedFrameView> frames = new FrameGroupImpl<>( ImmutableList.of(new MockCloseableImageFrame(1), new MockCloseableImageFrame(1)), (frame, index) -> new PredefinedFrameView(frame) );  "<AssertPlaceHolder>"; }
frames() { return FRAMES.size(); }
[*] target: assertEquals(2, frames.frames())
[-] pred: org. junit. Assert. assertEquals ( 2, frames. frames ( ) )
************************************
************************************
[+] input: width_HasWidth_GetsWidth() { PredefinedFrameView view = new PredefinedFrameView(new MockCloseableImageFrame(100, 200, 1)); "<AssertPlaceHolder>"; }
width() { return FRAME.width(); }
[*] target: assertEquals(100, view.width())
[-] pred: org. junit. Assert. assertEquals ( 100, view. width() )
************************************
************************************
[+] input: basic() { Exchange exchange = new Exchange(); assertEquals(0, exchange.size()); assertFalse(exchange.exists("non-key")); assertFalse(exchange.is("non-key")); assertNull(exchange.get("non-key", String.class)); assertNull(exchange.get("non-key", ExchangeTest.class)); // we can clear on an empty Exchange exchange.clear();  exchange.set("k1", new Date(12345678)); assertTrue(exchange.exists("k1")); assertFalse(exchange.exists("k2")); assertEquals(1, exchange.size()); assertNotNull(exchange.get("k1", Date.class));  try { exchange.get("k1", String.class); fail(); } catch (ClassCastException expected) {  }  // overwrite in place exchange.set("k1", "foo"); assertEquals(1, exchange.size()); assertEquals("foo", exchange.get("k1", String.class)); try { exchange.is("k1"); fail(); } catch (ClassCastException expected) {  }  // handy boolean method exchange.set("k2", true); assertTrue(exchange.is("k2")); assertFalse(exchange.is("k3"));  exchange.clear(); "<AssertPlaceHolder>"; }
size() { return holder.size(); }
[*] target: assertEquals(0, exchange.size())
[-] pred: org. junit. Assert. assertEquals ( 0, exchange. size ( ) )
************************************
************************************
[+] input: neverNPEafterExport() { DomainArtifacts instance = DomainArtifacts.getInstance(); instance.export();  "<AssertPlaceHolder>"; assertNotNull(instance.getSteps()); assertNotNull(instance.getDomains()); assertNotNull(instance.getExtensions()); }
export() { // domains this.domains = new ArrayList<>(InternalIndexer.domainDefMap.size()); domains.addAll(InternalIndexer.domainDefMap.values().stream().map(domainDef -> new Domain(domainDef.getCode(), domainDef.getName())).collect(Collectors.toList()));  // steps this.steps = new HashMap<>(); for (Map.Entry<String, Map<String, StepDef>> entry : InternalIndexer.domainStepDefMap.entrySet()) { final String activity = entry.getKey(); this.steps.put(activity, new ArrayList<>()); for (StepDef stepDef : entry.getValue().values()) { this.steps.get(activity).add(new Step(activity, stepDef.getCode(), stepDef.getName(), stepDef.getTags())); } }  // extensions this.extensions = new ArrayList<>(); // parse indexer pattern extensions for (Map.Entry<Class<? extends IDomainExtension>, List<PatternDef>> entry : InternalIndexer.sortedPatternMap.entrySet()) { final Extension extension = new Extension(entry.getKey()); for (PatternDef patternDef : entry.getValue()) { extension.getPatterns().add(new Pattern(patternDef.getCode(), patternDef.getName())); } for (PartnerDef partnerDef : InternalIndexer.partnerDefMap.values()) { if (partnerDef.getExtension(extension.ext) != null) { // 该前台实现了该扩展点 extension.getPartners().add(new Partner(partnerDef.getCode(), partnerDef.getName())); } }  this.extensions.add(extension); } // parse indexer partner extensions and merge with pattern extensions for (PartnerDef partnerDef : InternalIndexer.partnerDefMap.values()) { for (Class<? extends IDomainExtension> ext : partnerDef.getExtensionDefMap().keySet()) { Extension extensionsOfPattern = null; for (Extension extension : this.extensions) { if (extension.ext == ext) { extensionsOfPattern = extension; break; } }  if (extensionsOfPattern == null) { // this extension is implemented only by Partner final Extension extension = new Extension(ext); extension.getPartners().add(new Partner(partnerDef.getCode(), partnerDef.getName())); this.extensions.add(extension); } else { // this extension is implemented in both Partner and Pattern // do the merge final Partner partner = new Partner(partnerDef.getCode(), partnerDef.getName()); if (!extensionsOfPattern.getPartners().contains(partner)) { extensionsOfPattern.getPartners().add(partner); } } } } }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
************************************
[+] input: runTest() { final String key = "test key"; final String plainText = "hello world input"; final String encrypted = ARIA.encrypt(plainText, key); final String decrypted = ARIA.decrypt(encrypted, key); "<AssertPlaceHolder>"; }
decrypt(String input, String key) { org.apache.commons.codec.binary.Base64 base64 = new org.apache.commons.codec.binary.Base64(); String output = ""; try { SecretKeySpec secretKey = new SecretKeySpec(getKey(key), "ARIA"); Cipher cipher = Cipher.getInstance("ARIA"); cipher.init(Cipher.DECRYPT_MODE, secretKey); output = new String(cipher.doFinal(base64.decode(input.getBytes()))); } catch (GeneralSecurityException e) { e.printStackTrace(); return e.toString(); } return output; }
[*] target: assertEquals(plainText, decrypted)
[-] pred: org. junit. Assert. assertEquals ( plainText, decrypted )
************************************
************************************
[+] input: runTest() { final String key = "key for idea"; final String plainText = "Hello world input text"; final String encrypted = IDEA.encrypt(plainText, key); final String decrypted = IDEA.decrypt(encrypted, key);  "<AssertPlaceHolder>"; }
decrypt(String input, String key) { org.apache.commons.codec.binary.Base64 base64 = new org.apache.commons.codec.binary.Base64(); String output = ""; try { SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), "IDEA"); Cipher cipher = Cipher.getInstance("IDEA"); cipher.init(Cipher.DECRYPT_MODE, secretKey); output = new String(cipher.doFinal(base64.decode(input.getBytes()))); } catch (GeneralSecurityException e) { e.printStackTrace(); return e.toString(); } return output; }
[*] target: assertEquals(plainText, decrypted)
[-] pred: org. junit. Assert. assertEquals ( plainText, decrypted )
************************************
************************************
[+] input: Exception {  String PEMContentsOriginal = "-----BEGIN EC PRIVATE KEY-----\n" + "MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgfLXrITJ2RIoAQhIs\n" + "v7TRRoSJK77n1aQHEhIfV3fS7pWgCgYIKoZIzj0DAQehRANCAAQ9Mg8BWfin/qGh\n" + "v23YwMThH9ta1pzac/HutSBTg2mO2iYE9OzHpSm0/ZgISsF4uxRCC61kNbr5chCU\n" + "U3UiPByE\n" + "-----END EC PRIVATE KEY-----";  PrivateKey privateKey = PEMToKey.getPemPrivateKey(PEMContentsOriginal, "ECDSA");  String PEMContents = PEM.ECPrivateKeyToPEMFormat(privateKey);  "<AssertPlaceHolder>"; }
ECPrivateKeyToPEMFormat(PrivateKey privateKey) { return "-----BEGIN EC PRIVATE KEY-----\n" + new String(encoder.encode(privateKey.getEncoded())) + "\n-----END EC PRIVATE KEY-----"; }
[*] target: assertEquals(PEMContentsOriginal, PEMContents)
[-] pred: org. junit. Assert. assertEquals ( PEMContentsOriginal, PEMContents )
************************************
************************************
[+] input: Exception {  String PEMContentsOriginal = "-----BEGIN PUBLIC KEY-----\n" + "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEVQ6XXBFwG9mAqijwD2DN9Pgq62l0\n" + "oJmXwpptVDHsonyZ3Wl4J5DHBKfRVgD7KUPEwN9lEMjBqVGNSYbI7KP3mw==\n" + "-----END PUBLIC KEY-----";  PublicKey publicKey = PEMToKey.getPemPublicKey(PEMContentsOriginal, "ECDSA");  String PEMContents = PEM.PublicKeyToPEMFormat(publicKey);  "<AssertPlaceHolder>"; }
PublicKeyToPEMFormat(PublicKey publicKey) { return "-----BEGIN PUBLIC KEY-----\n" + new String(encoder.encode(publicKey.getEncoded())) + "\n-----END PUBLIC KEY-----"; }
[*] target: assertEquals(PEMContentsOriginal, PEMContents)
[-] pred: org. junit. Assert. assertEquals ( PEMContentsOriginal, PEMContents )
************************************
************************************
[+] input: testChoose() { Clorus p = new Clorus(2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Plip()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  assertEquals(expected, actual);  p = new Clorus(2); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Plip()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.ATTACK, Direction.TOP);  assertEquals(expected, actual);  p = new Clorus(1); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.REPLICATE, Direction.RIGHT);  assertEquals(expected, actual);  p = new Clorus(0.5); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.MOVE, Direction.RIGHT);  "<AssertPlaceHolder>"; }
chooseAction(Map<Direction, Occupant> neighbors) { List<Direction> empties = getNeighborsOfType(neighbors, "empty"); List<Direction> plip = getNeighborsOfType(neighbors, "plip");  if (empties.size() == 0) { return new Action(Action.ActionType.STAY); } else if (!plip.isEmpty()) { Direction moveDir = HugLifeUtils.randomEntry(plip); return new Action(Action.ActionType.ATTACK, moveDir); } else if (energy >= 1) { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.REPLICATE, moveDir); } else { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.MOVE, moveDir); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testChoose() { Plip p = new Plip(1.2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  //You can create new empties with new Empty(); //Despite what the spec says, you cannot test for Cloruses nearby yet. //Sorry!  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  assertEquals(expected, actual);  p = new Plip(1.2); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.REPLICATE, Direction.RIGHT);  assertEquals(expected, actual);  p = new Plip(0.8); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Clorus()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); Action expected1 = new Action(Action.ActionType.REPLICATE, Direction.RIGHT); Action expected2 = new Action(Action.ActionType.STAY); boolean expectedB = expected1.equals(actual) || expected2.equals(actual); "<AssertPlaceHolder>";  }
chooseAction(Map<Direction, Occupant> neighbors) { List<Direction> empties = getNeighborsOfType(neighbors, "empty"); List<Direction> clorus = getNeighborsOfType(neighbors, "clorus");  if (empties.size() == 0) { return new Action(Action.ActionType.STAY); } else if (energy > 1) { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.REPLICATE, moveDir); } else if (!clorus.isEmpty() && HugLifeUtils.random() >= 0.5) { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.MOVE, moveDir); } else { return new Action(Action.ActionType.STAY); } }
[*] target: assertTrue(expectedB)
[-] pred: org. junit. Assert. assertTrue ( expectedB )
************************************
************************************
[+] input: testChoose() { Plip p = new Plip(1.2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  //You can create new empties with new Empty(); //Despite what the spec says, you cannot test for Cloruses nearby yet. //Sorry!  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  "<AssertPlaceHolder>"; }
chooseAction(Map<Direction, Occupant> neighbors) { return new Action(Action.ActionType.STAY); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetClientValidAddress() { PeerClientPool pool = PeerClientPool.getInstance(); pool.setPort(PORT);  TraceServiceGrpc.TraceServiceBlockingStub client = pool.getClient(VALID_ADDRESS);  "<AssertPlaceHolder>"; }
getClient(final String address) { // TODO: Resolve to IP first, or is hostname good enough? return peerClients.computeIfAbsent(address, addr -> createGRPCClient(addr)); }
[*] target: assertNotNull(client)
[-] pred: org. junit. Assert. assertNotNull ( client )
************************************
************************************
[+] input: IOException { // Set up test server with SSL ServerBuilder sb = Server.builder(); sb.service(GrpcService.builder() .addService(new TestPeerService()) .build()); sb.tls(SSL_CRT_FILE, SSL_KEY_FILE).https(PORT);  try (Server server = sb.build()) { server.start();  // Configure client pool PeerClientPool pool = PeerClientPool.getInstance(); pool.setSsl(true);  final Path certFilePath = Path.of(PeerClientPoolTest.class.getClassLoader().getResource("test-crt.crt").getPath()); final String certAsString = Files.readString(certFilePath); final Certificate certificate = new Certificate(certAsString); pool.setCertificate(certificate); TraceServiceGrpc.TraceServiceBlockingStub client = pool.getClient(LOCALHOST); "<AssertPlaceHolder>";  // Call API should not throw exception client.export(ExportTraceServiceRequest.newBuilder().build()); } }
getClient(final String address) { // TODO: Resolve to IP first, or is hostname good enough? return peerClients.computeIfAbsent(address, addr -> createGRPCClient(addr)); }
[*] target: assertNotNull(client)
[-] pred: org. junit. Assert. assertNotNull ( client )
************************************
************************************
[+] input: IOException {  final String script = ResourceUtil.getResourceFileAsString("module/transform/javascript/script.js");  final TransformConfig config = new TransformConfig(); config.setName("js1"); config.setModule("javascript"); config.setInputs(Arrays.asList("rowInput"));  final JsonArray mappings = new JsonArray(); final JsonObject mappingStateless1 = new JsonObject(); mappingStateless1.addProperty("function", "myFunc1"); mappingStateless1.addProperty("outputType", "float32"); mappingStateless1.addProperty("outputField", "outputFloatField"); mappings.add(mappingStateless1);  final JsonObject mappingStateless2 = new JsonObject(); mappingStateless2.addProperty("function", "myFunc2"); mappingStateless2.addProperty("outputType", "string"); mappingStateless2.addProperty("outputField", "outputStringField"); mappings.add(mappingStateless2);  final JsonObject parameters = new JsonObject(); parameters.addProperty("script", script); parameters.add("mappings", mappings);  final JsonArray groupFields = new JsonArray(); groupFields.add("user"); parameters.add("groupFields", groupFields); config.setParameters(parameters);  final List<Entity> entities = createEntities(); final Schema schema = createRows().get(0).getSchema();  final PCollection<Entity> inputEntities1 = pipeline .apply("CreateDummy1", Create.of(entities)) .apply("WithTimestamp", WithTimestamps.of((Entity r) -> Instant.ofEpochMilli(Timestamps.toMicros(r.getPropertiesOrThrow("timestamp").getTimestampValue())))); final FCollection<Entity> fCollection1 = FCollection.of("rowInput", inputEntities1, DataType.ENTITY, schema);  final Map<String, FCollection<?>> outputs1 = JavaScriptTransform.transform(Arrays.asList(fCollection1), config); final FCollection<Entity> outputJS1 = (FCollection<Entity>) outputs1.get("js1");   final PCollection<Entity> outputPJS1 = outputJS1.getCollection();  PAssert.that(outputPJS1).satisfies(results -> { final List<Entity> resultsList = Lists.newArrayList(results); resultsList.sort(Comparator.comparing(r -> r.getPropertiesOrThrow("timestamp").getTimestampValue().getSeconds()));  Assert."<AssertPlaceHolder>";  Entity row1 = resultsList.get(0); Assert.assertEquals(10D, row1.getPropertiesOrThrow("outputFloatField").getDoubleValue(), DELTA); Assert.assertEquals("Hellostring1", row1.getPropertiesOrThrow("outputStringField").getStringValue());  Entity row2 = resultsList.get(1); Assert.assertEquals(20D, row2.getPropertiesOrThrow("outputFloatField").getDoubleValue(), DELTA); Assert.assertEquals("Hellostring2", row2.getPropertiesOrThrow("outputStringField").getStringValue());  Entity row3 = resultsList.get(2); Assert.assertEquals(30D, row3.getPropertiesOrThrow("outputFloatField").getDoubleValue(), DELTA); Assert.assertEquals("Hellostring3", row3.getPropertiesOrThrow("outputStringField").getStringValue());  return null; });  pipeline.run(); }
transform(List<FCollection<?>> inputs, TransformConfig config) {  final JavaScriptTransformParameters parameters = new Gson().fromJson(config.getParameters(), JavaScriptTransformParameters.class); validateParameters(parameters); setDefaultParameters(parameters);  final Map<String, FCollection<?>> results = new HashMap<>(); for(final FCollection<?> input : inputs) { final String name = config.getName() + (config.getInputs().size() == 1 ? "" : "." + input.getName()); final String nameError = name + OUTPUT_SUFFIX_FAILURES; switch (input.getDataType()) { case AVRO: { final FCollection<GenericRecord> inputCollection = (FCollection<GenericRecord>) input; final Schema outputSchema = createOutputAvroSchema(input.getAvroSchema(), parameters.getMappings()); final Transform<GenericRecord,String,Schema> transform = new Transform<>( parameters, outputSchema.toString(), AvroSchemaUtil::convertSchema, RecordToMapConverter::convert, AvroSchemaUtil::getAsString, (Schema s, GenericRecord r, List<Mapping> mappings, Map<String, Object> values) -> { final GenericRecordBuilder builder = AvroSchemaUtil.copy(r, s); for(var mapping : mappings) { if(!values.containsKey(mapping.getOutputField())) { builder.set(mapping.getOutputField(), null); continue; } switch (mapping.getOutputType()) { case bool: case string: case int32: case int64: case float32: case float64: { builder.set(mapping.getOutputField(), values.get(mapping.getOutputField())); break; } case bytes: { final byte[] bytes = (byte[])values.get(mapping.getOutputField()); builder.set(mapping.getOutputField(), ByteBuffer.wrap(bytes)); break; } case time: { builder.set(mapping.getOutputField(), Long.valueOf(((LocalTime)values.get(mapping.getOutputField())).toNanoOfDay()/1000_000).intValue()); break; } case date: { builder.set(mapping.getOutputField(), Long.valueOf(((LocalDate)values.get(mapping.getOutputField())).toEpochDay()).intValue()); break; } case timestamp: { final Instant instant = (Instant)values.get(mapping.getOutputField()); builder.set(mapping.getOutputField(), instant.getEpochSecond() * 1000_1000 + instant.getNano() / 1000); break; } } } return builder.build(); }); final PCollectionTuple tuple = inputCollection.getCollection().apply(name, transform); final PCollection<GenericRecord> output = tuple.get(transform.tagMain).setCoder(AvroCoder.of(outputSchema)); final PCollection<GenericRecord> error  = tuple.get(transform.tagError).setCoder(AvroCoder.of(input.getAvroSchema())); results.put(name, FCollection.of(name, output, com.mercari.solution.module.DataType.AVRO, outputSchema)); results.put(nameError, FCollection.of(nameError, error, com.mercari.solution.module.DataType.AVRO, input.getAvroSchema())); break; } case ROW: { final FCollection<Row> inputCollection = (FCollection<Row>) input; final org.apache.beam.sdk.schemas.Schema outputSchema = createOutputRowSchema(input.getSchema(), parameters.getMappings()); final Transform<Row,org.apache.beam.sdk.schemas.Schema,org.apache.beam.sdk.schemas.Schema> transform = new Transform<>( parameters, outputSchema, s -> s, RowToMapConverter::convert, RowSchemaUtil::getAsString, (org.apache.beam.sdk.schemas.Schema s, Row r, List<Mapping> mappings, Map<String, Object> values) -> { var builder = RowSchemaUtil.toBuilder(s, r); for(var mapping : mappings) { if(!values.containsKey(mapping.getOutputField())) { builder.withFieldValue(mapping.getOutputField(), null); continue; } switch (mapping.getOutputType()) { case bool: case string: case bytes: case int32: case int64: case float32: case float64: case time: case date: { builder.withFieldValue(mapping.getOutputField(), values.get(mapping.getOutputField())); break; } case timestamp: { final Instant instant = (Instant)values.get(mapping.getOutputField()); builder.withFieldValue(mapping.getOutputField(), DateTimeUtil.toJodaInstant(instant)); break; } } } return builder.build(); }); final PCollectionTuple tuple = inputCollection.getCollection().apply(name, transform); final PCollection<Row> output = tuple.get(transform.tagMain).setCoder(RowCoder.of(outputSchema)); final PCollection<Row> error  = tuple.get(transform.tagError).setCoder(RowCoder.of(input.getSchema())); results.put(name, FCollection.of(name, output, com.mercari.solution.module.DataType.ROW, outputSchema)); results.put(nameError, FCollection.of(nameError, error, com.mercari.solution.module.DataType.ROW, input.getSchema())); break; } case STRUCT: { final FCollection<Struct> inputCollection = (FCollection<Struct>) input; final Type outputType = createOutputStructType(input.getSpannerType(), parameters.getMappings()); final Transform<Struct,Type,Type> transform = new Transform<>( parameters, outputType, s -> s, StructToMapConverter::convert, StructSchemaUtil::getAsString, (Type s, Struct r, List<Mapping> mappings, Map<String, Object> values) -> { var builder = StructSchemaUtil.toBuilder(s, r); for(var mapping : mappings) { final Object value = values.get(mapping.getOutputField()); switch (mapping.getOutputType()) { case bool: builder.set(mapping.getOutputField()).to((Boolean)value); break; case string: builder.set(mapping.getOutputField()).to((String)value); break; case bytes: { final byte[] bytes = (byte[])value; if(bytes == null) { builder.set(mapping.getOutputField()).to((ByteArray)null); } else { builder.set(mapping.getOutputField()).to(ByteArray.copyFrom(bytes)); } break; } case int32: builder.set(mapping.getOutputField()).to((Integer)value); break; case int64: builder.set(mapping.getOutputField()).to((Long)value); break; case float32: builder.set(mapping.getOutputField()).to((Float)value); break; case float64: builder.set(mapping.getOutputField()).to((Double)value); break; case time: { final LocalTime localTime = (LocalTime) value; if(localTime == null) { builder.set(mapping.getOutputField()).to((String) null); } else { builder.set(mapping.getOutputField()).to(localTime.toString()); } break; } case date: { final LocalDate localDate = (LocalDate) value; if(localDate == null) { builder.set(mapping.getOutputField()).to((Date)null); } else { builder.set(mapping.getOutputField()).to(Date .fromYearMonthDay(localDate.getYear(), localDate.getMonthValue(), localDate.getDayOfMonth())); } break; } case timestamp: { final Instant instant = (Instant)values.get(mapping.getOutputField()); if(instant == null) { builder.set(mapping.getOutputField()).to((Timestamp)null); } else { builder.set(mapping.getOutputField()).to(Timestamp .ofTimeSecondsAndNanos(instant.getEpochSecond(), instant.getNano())); } break; } } } return builder.build(); }); final PCollectionTuple tuple = inputCollection.getCollection().apply(name, transform); final PCollection<Struct> output = tuple.get(transform.tagMain).setCoder(inputCollection.getCollection().getCoder()); final PCollection<Struct> error  = tuple.get(transform.tagError).setCoder(inputCollection.getCollection().getCoder()); results.put(name, FCollection.of(name, output, com.mercari.solution.module.DataType.STRUCT, outputType)); results.put(nameError, FCollection.of(nameError, error, com.mercari.solution.module.DataType.STRUCT, input.getSpannerType())); break; } case ENTITY: { final FCollection<Entity> inputCollection = (FCollection<Entity>) input; final org.apache.beam.sdk.schemas.Schema outputSchema = createOutputRowSchema(input.getSchema(), parameters.getMappings()); final Transform<Entity,org.apache.beam.sdk.schemas.Schema,org.apache.beam.sdk.schemas.Schema> transform = new Transform<>( parameters, outputSchema, s -> s, EntityToMapConverter::convert, EntitySchemaUtil::getAsString, (org.apache.beam.sdk.schemas.Schema s, Entity r, List<Mapping> mappings, Map<String, Object> values) -> { var builder = EntitySchemaUtil.toBuilder(s, r); for(var mapping : mappings) { final Object value = values.getOrDefault(mapping.getOutputField(), null); if(value == null) { builder.putProperties(mapping.getOutputField(), Value.newBuilder().setNullValue(NullValue.NULL_VALUE).build()); continue; } switch (mapping.getOutputType()) { case bool: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setBooleanValue((Boolean) value).build()); break; case string: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setStringValue((String) value).build()); break; case bytes: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setBlobValue(ByteString.copyFrom((byte[]) value)).build()); break; case int32: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setIntegerValue((Integer) value).build()); break; case int64: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setIntegerValue((Long) value).build()); break; case float32: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setDoubleValue((Float) value).build()); break; case float64: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setDoubleValue((Double) value).build()); break; case time: case date: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setStringValue(value.toString()).build()); break; case timestamp: { final Instant instant = (Instant) value; builder.putProperties(mapping.getOutputField(), Value.newBuilder() .setTimestampValue(com.google.protobuf.Timestamp.newBuilder() .setSeconds(instant.getEpochSecond()) .setNanos(instant.getNano()) .build()) .build()); break; } } } return builder.build(); }); final PCollectionTuple tuple = inputCollection.getCollection().apply(name, transform); final PCollection<Entity> output = tuple.get(transform.tagMain).setCoder(inputCollection.getCollection().getCoder()); final PCollection<Entity> error  = tuple.get(transform.tagError).setCoder(inputCollection.getCollection().getCoder()); results.put(name, FCollection.of(name, output, com.mercari.solution.module.DataType.ENTITY, outputSchema)); results.put(nameError, FCollection.of(nameError, error, com.mercari.solution.module.DataType.ENTITY, input.getSchema())); break; } default: { throw new IllegalStateException(""); } } }  return results; }
[*] target: assertEquals(3, resultsList.size())
[-] pred: org. junit. Assert. assertEquals ( 3, resultsList. size ( ) )
************************************
************************************
[+] input: RemotingCommandException { final RemotingCommand request = createReplyMsgCommand(DeFiBusRequestCode.SEND_DIRECT_MESSAGE); final RemotingCommand[] response = new RemotingCommand[1]; doAnswer(new Answer() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { response[0] = (RemotingCommand) invocation.getArguments()[0]; return null; } }).when(channelHandlerContext).writeAndFlush(any(Object.class)); RemotingCommand responseToReturn = deFiReplyMessageProcessor.processRequest(channelHandlerContext, request); if (responseToReturn != null) { Assert."<AssertPlaceHolder>"; response[0] = responseToReturn; } Assert.assertEquals(response[0].getCode(), ResponseCode.SUCCESS); Assert.assertEquals(response[0].getOpaque(), request.getOpaque()); }
processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException { SendMessageContext mqtraceContext = null; switch (request.getCode()) { case DeFiBusRequestCode.SEND_DIRECT_MESSAGE_V2: case DeFiBusRequestCode.SEND_DIRECT_MESSAGE: SendMessageRequestHeader requestHeader = parseRequestHeader(request); if (requestHeader == null) { return null; }  mqtraceContext = buildMsgContext(ctx, requestHeader); this.executeSendMessageHookBefore(ctx, request, mqtraceContext); final RemotingCommand response = this.processReplyMessageRequest(ctx, request, mqtraceContext, requestHeader);  this.executeSendMessageHookAfter(response, mqtraceContext); return response; default: log.warn("Unsupported request code :" + request.getCode()); } return null; }
[*] target: assertNull(response[0])
[-] pred: org. junit. Assert. assertNull ( response[0] )
************************************
************************************
[+] input: testInsert() { Temperature one = new Temperature(); one.setTs(new Timestamp(1605024000000l)); one.setTemperature(random.nextFloat() * 50); one.setLocation("望京"); int affectRows = mapper.insertOne(one); Assert."<AssertPlaceHolder>"; }
insertOne(Temperature one);
[*] target: assertEquals(1, affectRows)
[-] pred: org. junit. Assert. assertEquals ( 1, affectRows )
************************************
************************************
[+] input: testInsert() { Weather one = new Weather(); one.setTs(new Timestamp(1605024000000l)); one.setTemperature(random.nextFloat() * 50); one.setHumidity(random.nextInt(100)); one.setLocation("望京"); int affectRows = mapper.insert(one); Assert."<AssertPlaceHolder>"; }
insert(Weather weather);
[*] target: assertEquals(1, affectRows)
[-] pred: org. junit. Assert. assertEquals ( 1, affectRows )
************************************
************************************
[+] input: reset_should_reset_probes() { Agent agent = createAgent(); boolean[] probes = agent.getData() .getExecutionData(Long.valueOf(0x12345678), "Foo", 1) .getProbes(); probes[0] = true;  agent.reset();  "<AssertPlaceHolder>"; }
reset() { data.reset(); }
[*] target: assertFalse(probes[0])
[-] pred: org. junit. Assert. assertFalse ( probes[0] )
************************************
************************************
[+] input: Exception { final Future<Socket> f = executor.submit(new Callable<Socket>() { public Socket call() throws Exception { return serverSocket.accept(); } }); assertBlocks(f); connect().getOutputStream().write(123); final Socket socket = f.get(); "<AssertPlaceHolder>"; assertEquals(123, socket.getInputStream().read()); }
connect() throws Exception { synchronized (lock) { final MockSocketConnection c = new MockSocketConnection(); connection = c.getSocketA(); lock.notifyAll(); while (connection != null) { lock.wait(); } return c.getSocketB(); } }
[*] target: assertNotNull(socket)
[-] pred: org. junit. Assert. assertNotNull ( socket )
************************************
************************************
[+] input: UnknownHostException { final InetAddress addr = controller.getInetAddress("*"); "<AssertPlaceHolder>"; }
getInetAddress(final String address) throws UnknownHostException { if ("*".equals(address)) { return null; } else { return InetAddress.getByName(address); } }
[*] target: assertNull(addr)
[-] pred: org. junit. Assert. assertNull ( addr )
************************************
************************************
[+] input: IOException { locator.add(createFile("org/jacoco/example/Test.java", "AAA"));  "<AssertPlaceHolder>"; final Reader source = locator.getSourceFile("org/jacoco/example", "Test.java"); assertContent("AAA", source); }
isEmpty() { return empty; }
[*] target: assertFalse(locator.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( locator. isEmpty() )
************************************
************************************
[+] input: IOException { createFile("src/org/jacoco/example/Test.java", "AAA"); locator.add(new FileResource(folder.getRoot(), "src"));  "<AssertPlaceHolder>"; final Reader source = locator.getSourceFile("org/jacoco/example", "Test.java"); assertContent("AAA", source); }
isEmpty() { return empty; }
[*] target: assertFalse(locator.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( locator. isEmpty() )
************************************
************************************
[+] input: IOException { createClassfile("bin1", AnalyzerTest.class); final int count = analyzer.analyzeAll(folder.getRoot()); "<AssertPlaceHolder>"; assertClasses("org/jacoco/core/analysis/AnalyzerTest"); }
analyzeAll(final File file) throws IOException { int count = 0; if (file.isDirectory()) { for (final File f : file.listFiles()) { count += analyzeAll(f); } } else { final InputStream in = new FileInputStream(file); try { count += analyzeAll(in, file.getPath()); } finally { in.close(); } } return count; }
[*] target: assertEquals(1, count)
[-] pred: org. junit. Assert. assertEquals ( 1, count )
************************************
************************************
[+] input: testGetNoMatchClasses() { MethodCoverageImpl m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 1); addClass(1, true, "Sample1", null, m);  m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 2); addClass(2, true, "Sample2", null, m);  m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 3); addClass(3, false, "Sample3", null, m);  final Set<String> actual = getNames(coverageBuilder.getNoMatchClasses()); final Set<String> expected = new HashSet<String>(Arrays.asList( "Sample1", "Sample2"));  "<AssertPlaceHolder>"; }
getNoMatchClasses() { final Collection<IClassCoverage> result = new ArrayList<>(); for (final IClassCoverage c : classes.values()) { if (c.isNoMatch()) { result.add(c); } } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetContents() { final boolean[] probes = new boolean[] {}; final ExecutionData a = new ExecutionData(1000, "A", probes); store.put(a); final ExecutionData aa = new ExecutionData(1000, "A", probes); store.put(aa); final ExecutionData b = new ExecutionData(1001, "B", probes); store.put(b); final Set<ExecutionData> actual = new HashSet<ExecutionData>( store.getContents()); final Set<ExecutionData> expected = new HashSet<ExecutionData>( Arrays.asList(a, b)); "<AssertPlaceHolder>"; }
getContents() { return new ArrayList<ExecutionData>(entries.values()); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testIsEmpty() { store.visitSessionInfo(new SessionInfo("A", 123, 456)); "<AssertPlaceHolder>"; }
isEmpty() { return infos.isEmpty(); }
[*] target: assertFalse(store.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( store. isEmpty() )
************************************
************************************
[+] input: IOException { InputStream in = new ByteArrayInputStream("text".getBytes()); ByteArrayOutputStream out = new ByteArrayOutputStream();  int count = instrumenter.instrumentAll(in, out, "Test");  "<AssertPlaceHolder>"; assertEquals("text", new String(out.toByteArray())); }
instrumentAll(final InputStream input, final OutputStream output, final String name) throws IOException { final ContentTypeDetector detector; try { detector = new ContentTypeDetector(input); } catch (final IOException e) { throw instrumentError(name, e); } switch (detector.getType()) { case ContentTypeDetector.CLASSFILE: instrument(detector.getInputStream(), output, name); return 1; case ContentTypeDetector.ZIPFILE: return instrumentZip(detector.getInputStream(), output, name); case ContentTypeDetector.GZFILE: return instrumentGzip(detector.getInputStream(), output, name); case ContentTypeDetector.PACK200FILE: return instrumentPack200(detector.getInputStream(), output, name); default: copy(detector.getInputStream(), output, name); return 0; } }
[*] target: assertEquals(0, count)
[-] pred: org. junit. Assert. assertEquals ( 0, count )
************************************
************************************
[+] input: IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ZipOutputStream zipout = new ZipOutputStream(buffer); zipout.putNextEntry(new ZipEntry("META-INF/MANIFEST.MF")); zipout.putNextEntry(new ZipEntry("META-INF/ALIAS.SF")); zipout.finish(); ByteArrayOutputStream out = new ByteArrayOutputStream();  int count = instrumenter.instrumentAll( new ByteArrayInputStream(buffer.toByteArray()), out, "Test");  "<AssertPlaceHolder>"; ZipInputStream zipin = new ZipInputStream(new ByteArrayInputStream( out.toByteArray())); assertEquals("META-INF/MANIFEST.MF", zipin.getNextEntry().getName()); assertNull(zipin.getNextEntry()); }
instrumentAll(final InputStream input, final OutputStream output, final String name) throws IOException { final ContentTypeDetector detector; try { detector = new ContentTypeDetector(input); } catch (final IOException e) { throw instrumentError(name, e); } switch (detector.getType()) { case ContentTypeDetector.CLASSFILE: instrument(detector.getInputStream(), output, name); return 1; case ContentTypeDetector.ZIPFILE: return instrumentZip(detector.getInputStream(), output, name); case ContentTypeDetector.GZFILE: return instrumentGzip(detector.getInputStream(), output, name); case ContentTypeDetector.PACK200FILE: return instrumentPack200(detector.getInputStream(), output, name); default: copy(detector.getInputStream(), output, name); return 0; } }
[*] target: assertEquals(0, count)
[-] pred: org. junit. Assert. assertEquals ( 0, count )
************************************
************************************
[+] input: IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ZipOutputStream zipout = new ZipOutputStream(buffer); zipout.putNextEntry(new ZipEntry("META-INF/ALIAS.SF")); zipout.finish(); ByteArrayOutputStream out = new ByteArrayOutputStream();  instrumenter.setRemoveSignatures(false); int count = instrumenter.instrumentAll( new ByteArrayInputStream(buffer.toByteArray()), out, "Test");  "<AssertPlaceHolder>"; ZipInputStream zipin = new ZipInputStream(new ByteArrayInputStream( out.toByteArray())); assertEquals("META-INF/ALIAS.SF", zipin.getNextEntry().getName()); assertNull(zipin.getNextEntry()); }
instrumentAll(final InputStream input, final OutputStream output, final String name) throws IOException { final ContentTypeDetector detector; try { detector = new ContentTypeDetector(input); } catch (final IOException e) { throw instrumentError(name, e); } switch (detector.getType()) { case ContentTypeDetector.CLASSFILE: instrument(detector.getInputStream(), output, name); return 1; case ContentTypeDetector.ZIPFILE: return instrumentZip(detector.getInputStream(), output, name); case ContentTypeDetector.GZFILE: return instrumentGzip(detector.getInputStream(), output, name); case ContentTypeDetector.PACK200FILE: return instrumentPack200(detector.getInputStream(), output, name); default: copy(detector.getInputStream(), output, name); return 0; } }
[*] target: assertEquals(0, count)
[-] pred: org. junit. Assert. assertEquals ( 0, count )
************************************
************************************
[+] input: testNoMatch() { ClassCoverageImpl node = new ClassCoverageImpl("Sample", 12345, true); "<AssertPlaceHolder>"; }
isNoMatch() { return noMatch; }
[*] target: assertTrue(node.isNoMatch())
[-] pred: org. junit. Assert. assertTrue ( node. isNoMatch() )
************************************
************************************
[+] input: testFixInstance() { ICounter c1 = CounterImpl.getInstance(30, 30); ICounter c2 = CounterImpl.getInstance(30, 30); "<AssertPlaceHolder>"; }
getInstance(final int missed, final int covered) { if (missed <= SINGLETON_LIMIT && covered <= SINGLETON_LIMIT) { return SINGLETONS[missed][covered]; } else { return new Var(missed, covered); } }
[*] target: assertSame(c1, c2)
[-] pred: org. junit. Assert. assertSame ( c1, c2 )
************************************
************************************
[+] input: testIncrement1() { CounterImpl c = CounterImpl.getInstance(1, 1); c = c.increment(CounterImpl.getInstance(2, 1)); assertEquals(3, c.getMissedCount()); "<AssertPlaceHolder>"; }
getCoveredCount() { return covered; }
[*] target: assertEquals(2, c.getCoveredCount())
[-] pred: org. junit. Assert. assertEquals ( 2, c. getCoveredCount() )
************************************
************************************
[+] input: testEquals1() { ICounter c1 = CounterImpl.getInstance(300, 123); ICounter c2 = CounterImpl.getInstance(300, 123); "<AssertPlaceHolder>"; }
getInstance(final int missed, final int covered) { if (missed <= SINGLETON_LIMIT && covered <= SINGLETON_LIMIT) { return SINGLETONS[missed][covered]; } else { return new Var(missed, covered); } }
[*] target: assertEquals(c1, c2)
[-] pred: org. junit. Assert. assertEquals ( c1, c2 )
************************************
************************************
[+] input: testEquals2() { ICounter c1 = CounterImpl.getInstance(300, 123); ICounter c2 = CounterImpl.getInstance(400, 123); "<AssertPlaceHolder>"; }
equals(final Object obj) { if (obj instanceof ICounter) { final ICounter that = (ICounter) obj; return this.missed == that.getMissedCount() && this.covered == that.getCoveredCount(); } else { return false; } }
[*] target: assertFalse(c1.equals(c2))
[-] pred: org. junit. Assert. assertFalse ( c1. equals ( c2 ) )
************************************
************************************
[+] input: testEquals3() { ICounter c1 = CounterImpl.getInstance(300, 123); ICounter c2 = CounterImpl.getInstance(300, 124); "<AssertPlaceHolder>"; }
equals(final Object obj) { if (obj instanceof ICounter) { final ICounter that = (ICounter) obj; return this.missed == that.getMissedCount() && this.covered == that.getCoveredCount(); } else { return false; } }
[*] target: assertFalse(c1.equals(c2))
[-] pred: org. junit. Assert. assertFalse ( c1. equals ( c2 ) )
************************************
************************************
[+] input: testHashCode1() { ICounter c1 = CounterImpl.getInstance(300, 123); ICounter c2 = CounterImpl.getInstance(300, 123); "<AssertPlaceHolder>"; }
hashCode() { return missed ^ covered * 17; }
[*] target: assertEquals(c1.hashCode(), c2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( c1. hashCode(), c2. hashCode() )
************************************
************************************
[+] input: new_instance_should_have_no_coverage_and_no_branches() { assertEquals(CounterImpl.COUNTER_1_0, instruction.getInstructionCounter()); "<AssertPlaceHolder>"; }
getBranchCounter() { if (branches < 2) { return CounterImpl.COUNTER_0_0; } final int covered = coveredBranches.cardinality(); return CounterImpl.getInstance(branches - covered, covered); }
[*] target: assertEquals(CounterImpl.COUNTER_0_0, instruction.getBranchCounter())
[-] pred: org. junit. Assert. assertEquals ( CounterImpl.COUNTER_0_0, instruction. getBranchCounter() )
************************************
************************************
[+] input: testHashCode() { line = line.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); LineImpl line2 = LineImpl.EMPTY; line2 = line2.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); "<AssertPlaceHolder>"; }
hashCode() { return 23 * instructions.hashCode() ^ branches.hashCode(); }
[*] target: assertEquals(line.hashCode(), line2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( line. hashCode(), line2. hashCode() )
************************************
************************************
[+] input: testEquals1() { line = line.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); LineImpl line2 = LineImpl.EMPTY; line2 = line2.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); "<AssertPlaceHolder>"; }
getInstance(final CounterImpl instructions, final CounterImpl branches) { final int im = instructions.getMissedCount(); final int ic = instructions.getCoveredCount(); final int bm = branches.getMissedCount(); final int bc = branches.getCoveredCount(); if (im <= SINGLETON_INS_LIMIT && ic <= SINGLETON_INS_LIMIT && bm <= SINGLETON_BRA_LIMIT && bc <= SINGLETON_BRA_LIMIT) { return SINGLETONS[im][ic][bm][bc]; } return new Var(instructions, branches); }
[*] target: assertEquals(line, line2)
[-] pred: org. junit. Assert. assertEquals ( line, line2 )
************************************
************************************
[+] input: test0() { final long sum = CRC64.classId(new byte[0]); "<AssertPlaceHolder>"; }
classId(final byte[] bytes) { if (bytes.length > 7 && bytes[6] == 0x00 && bytes[7] == Opcodes.V9) { // To support early versions of Java 9 we did a trick - change of // Java 9 class files version on Java 8. Unfortunately this also // affected class identifiers. long sum = update(0, bytes, 0, 7); sum = update(sum, (byte) Opcodes.V1_8); return update(sum, bytes, 8, bytes.length); } return update(0, bytes, 0, bytes.length); }
[*] target: assertEquals(0L, sum)
[-] pred: org. junit. Assert. assertEquals ( 0L, sum )
************************************
************************************
[+] input: testFieldInsn() { analyzer.successor = false; analyzer.visitFieldInsn(GETFIELD, "Foo", "name", "Ljava/lang/String;"); "<AssertPlaceHolder>"; assertFalse(analyzer.first); }
visitFieldInsn(final int opcode, final String owner, final String name, final String desc) { successor = true; first = false; }
[*] target: assertTrue(analyzer.successor)
[-] pred: org. junit. Assert. assertTrue ( analyzer.successor )
************************************
************************************
[+] input: testGetAppendFalse() { AgentOptions options = new AgentOptions("append=false"); "<AssertPlaceHolder>"; }
getAppend() { return getOption(APPEND, true); }
[*] target: assertFalse(options.getAppend())
[-] pred: org. junit. Assert. assertFalse ( options. getAppend() )
************************************
************************************
[+] input: testGetInclBootstrapClassesTrue() { AgentOptions options = new AgentOptions("inclbootstrapclasses=true"); "<AssertPlaceHolder>"; }
getInclBootstrapClasses() { return getOption(INCLBOOTSTRAPCLASSES, false); }
[*] target: assertTrue(options.getInclBootstrapClasses())
[-] pred: org. junit. Assert. assertTrue ( options. getInclBootstrapClasses() )
************************************
************************************
[+] input: testGetInclBootstrapClassesFalse() { AgentOptions options = new AgentOptions("inclbootstrapclasses=false"); "<AssertPlaceHolder>"; }
getInclBootstrapClasses() { return getOption(INCLBOOTSTRAPCLASSES, false); }
[*] target: assertFalse(options.getInclBootstrapClasses())
[-] pred: org. junit. Assert. assertFalse ( options. getInclBootstrapClasses() )
************************************
************************************
[+] input: testGetInclNoLocationClassesTrue() { AgentOptions options = new AgentOptions("inclnolocationclasses=true"); "<AssertPlaceHolder>"; }
getInclNoLocationClasses() { return getOption(INCLNOLOCATIONCLASSES, false); }
[*] target: assertTrue(options.getInclNoLocationClasses())
[-] pred: org. junit. Assert. assertTrue ( options. getInclNoLocationClasses ( ) )
************************************
************************************
[+] input: testGetInclNoLocationClassesFalse() { AgentOptions options = new AgentOptions("inclnolocationclasses=false"); "<AssertPlaceHolder>"; }
getInclNoLocationClasses() { return getOption(INCLNOLOCATIONCLASSES, false); }
[*] target: assertFalse(options.getInclNoLocationClasses())
[-] pred: org. junit. Assert. assertFalse ( options. getInclNoLocationClasses() )
************************************
************************************
[+] input: testGetDumpOnExit() { AgentOptions options = new AgentOptions("dumponexit=false"); "<AssertPlaceHolder>"; }
getDumpOnExit() { return getOption(DUMPONEXIT, true); }
[*] target: assertFalse(options.getDumpOnExit())
[-] pred: org. junit. Assert. assertFalse ( options. getDumpOnExit() )
************************************
************************************
[+] input: testSetDumpOnExit() { AgentOptions options = new AgentOptions(); options.setDumpOnExit(false); "<AssertPlaceHolder>"; }
getDumpOnExit() { return getOption(DUMPONEXIT, true); }
[*] target: assertFalse(options.getDumpOnExit())
[-] pred: org. junit. Assert. assertFalse ( options. getDumpOnExit() )
************************************
************************************
[+] input: testGetJmx() { AgentOptions options = new AgentOptions("jmx=true"); "<AssertPlaceHolder>"; }
getJmx() { return getOption(JMX, false); }
[*] target: assertTrue(options.getJmx())
[-] pred: org. junit. Assert. assertTrue ( options. getJmx() )
************************************
************************************
[+] input: testSetJmx() { AgentOptions options = new AgentOptions(); options.setJmx(true); "<AssertPlaceHolder>"; }
getJmx() { return getOption(JMX, false); }
[*] target: assertTrue(options.getJmx())
[-] pred: org. junit. Assert. assertTrue ( options. getJmx() )
************************************
************************************
[+] input: Exception { generator = new OfflineInstrumentationAccessGenerator(); MethodRecorder actual = new MethodRecorder(); generator.generateDataAccessor(987654321, "foo/Bar", 17, actual.getVisitor());  MethodRecorder expected = new MethodRecorder(); expected.getVisitor().visitLdcInsn(Long.valueOf(987654321)); expected.getVisitor().visitLdcInsn("foo/Bar"); expected.getVisitor().visitIntInsn(Opcodes.BIPUSH, 17); String rtname = JaCoCo.RUNTIMEPACKAGE.replace('.', '/') + "/Offline"; expected.getVisitor().visitMethodInsn(Opcodes.INVOKESTATIC, rtname, "getProbes", "(JLjava/lang/String;I)[Z", false);  "<AssertPlaceHolder>"; }
generateDataAccessor(final long classid, final String classname, final int probecount, final MethodVisitor mv) { mv.visitLdcInsn(Long.valueOf(classid)); mv.visitLdcInsn(classname); InstrSupport.push(mv, probecount); mv.visitMethodInsn(Opcodes.INVOKESTATIC, runtimeClassName, "getProbes", "(JLjava/lang/String;I)[Z", false); return 4; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { ISourceFileLocator locator = new TestLocator("UTF-8", 17); "<AssertPlaceHolder>"; }
getTabWidth() { return tabWidth; }
[*] target: assertEquals(17, locator.getTabWidth())
[-] pred: org. junit. Assert. assertEquals ( 17, locator. getTabWidth() )
************************************
************************************
[+] input: testMin0() { limit.setMinimum("0"); limit.setMinimum((String) null); "<AssertPlaceHolder>"; }
getMinimum() { return minimum == null ? null : minimum.toPlainString(); }
[*] target: assertNull(limit.getMinimum())
[-] pred: org. junit. Assert. assertNull ( limit. getMinimum() )
************************************
************************************
[+] input: testMax0() { limit.setMaximum("0"); limit.setMaximum((String) null); "<AssertPlaceHolder>"; }
getMaximum() { return maximum == null ? null : maximum.toPlainString(); }
[*] target: assertNull(limit.getMaximum())
[-] pred: org. junit. Assert. assertNull ( limit. getMaximum() )
************************************
************************************
[+] input: Exception { ILanguageNames names = new ILanguageNames() { public String getPackageName(String vmname) { return null; }  public String getQualifiedClassName(String vmname) { return null; }  public String getClassName(String vmname, String vmsignature, String vmsuperclass, String[] vminterfaces) { return null; }  public String getMethodName(String vmclassname, String vmmethodname, String vmdesc, String vmsignature) { return null; }  public String getQualifiedMethodName(String vmclassname, String vmmethodname, String vmdesc, String vmsignature) { return null; } }; formatter.setLanguageNames(names); "<AssertPlaceHolder>"; output.close(); }
getLanguageNames() { return languageNames; }
[*] target: assertSame(names, formatter.getLanguageNames())
[-] pred: org. junit. Assert. assertSame ( names, formatter. getLanguageNames() )
************************************
************************************
[+] input: testIsRootPage1() { "<AssertPlaceHolder>"; }
isRootPage() { return parent == null; }
[*] target: assertFalse(page.isRootPage())
[-] pred: org. junit. Assert. assertFalse ( page. isRootPage() )
************************************
************************************
[+] input: emptyListShouldNotFail() { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(new ArrayList<>(), null, null, null, false); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now, boolean withFederationGateway) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now, withFederationGateway); } }
[*] target: assertNull(theException)
[-] pred: org. junit. Assert. assertNull ( theException )
************************************
************************************
[+] input: Exception { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(null, null, null, null, false); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now, boolean withFederationGateway) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now, withFederationGateway); } }
[*] target: assertNull(theException)
[-] pred: org. junit. Assert. assertNull ( theException )
************************************
************************************
[+] input: forMethod() { Class<StringResponseConverter> clazz = StringResponseConverter.class;  Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) { MethodGenericType methodGenericType = GenericType.forMethod(method); GenericType genericType = methodGenericType.returnType(); if (genericType.isWrapped()) { genericType.resolveGenericOptional(0).ifPresent(c -> System.out.printf("method: %20s, %s\n", method.getName(), c)); } } Assert."<AssertPlaceHolder>"; }
resolveGenericOptional(int... indices);  /** * 解析泛型类，如果指定位置泛型类型不存在，抛出异常 * * @param indices 索引 * @return 泛型实际类型 */ default Class<?> resolveGeneric(int... indices) { return resolveGenericOptional(indices).orElseThrow(GenericTypeException::new); }
[*] target: assertNotNull(clazz)
[-] pred: org. junit. Assert. assertNotNull ( clazz )
************************************
************************************
[+] input: registerUser() { User user = new User(); user.setFirstName(FIRST_NAME); user.setEmail(USER_EMAIL); String userCreated = authenticationService.registerUser(user, "", USER_PASSWORD); Map<String, Object> attributes = new HashMap<>(); attributes.put("firstName", FIRST_NAME); attributes.put("registrationUrl", "http://" + hostname + "/activate/" + user.getActivationCode());  "<AssertPlaceHolder>"; assertNotNull(user.getActivationCode()); assertTrue(CoreMatchers.is(user.getRoles()).matches(Collections.singleton(Role.USER))); verify(userRepository, times(1)).save(user); verify(mailSender, times(1)) .sendMessageHtml( ArgumentMatchers.eq(user.getEmail()), ArgumentMatchers.eq("Activation code"), ArgumentMatchers.eq("registration-template"), ArgumentMatchers.eq(attributes)); }
registerUser(User user, String captcha, String password2) { String url = String.format(captchaUrl, secret, captcha); restTemplate.postForObject(url, Collections.emptyList(), CaptchaResponse.class);  if (user.getPassword() != null && !user.getPassword().equals(password2)) { throw new PasswordException(PASSWORDS_DO_NOT_MATCH); }  if (userRepository.findByEmail(user.getEmail()).isPresent()) { throw new EmailException(EMAIL_IN_USE); } user.setActive(false); user.setRoles(Collections.singleton(Role.USER)); user.setProvider(AuthProvider.LOCAL); user.setActivationCode(UUID.randomUUID().toString()); user.setPassword(passwordEncoder.encode(user.getPassword())); userRepository.save(user);  sendEmail(user, "Activation code", "registration-template", "registrationUrl", "/activate/" + user.getActivationCode()); return "User successfully registered."; }
[*] target: assertNotNull(userCreated)
[-] pred: org. junit. Assert. assertNotNull ( userCreated )
************************************
************************************
[+] input: activateUser() { User user = new User(); user.setActivationCode(USER_ACTIVATION_CODE);  when(userRepository.findByActivationCode(USER_ACTIVATION_CODE)).thenReturn(Optional.of(user)); when(userRepository.save(user)).thenReturn(user); String activated = authenticationService.activateUser(user.getActivationCode()); "<AssertPlaceHolder>"; assertNull(user.getActivationCode()); verify(userRepository, times(1)).save(user); }
activateUser(String code) { User user = userRepository.findByActivationCode(code) .orElseThrow(() -> new ApiRequestException(ACTIVATION_CODE_NOT_FOUND, HttpStatus.NOT_FOUND)); user.setActivationCode(null); user.setActive(true); userRepository.save(user); return "User successfully activated."; }
[*] target: assertNotNull(activated)
[-] pred: org. junit. Assert. assertNotNull ( activated )
************************************
************************************
[+] input: testSelectSingleCommuUserDetail() { // given CommunityUser communityUser = new CommunityUser(); testData(communityUser); // log.debug("communityUser = {}, {}", communityUser.getEmplyrId(), communityUser.getCmmntyId());  // when CommunityUser resultCommunityUser = egovCommuManageDAO.selectSingleCommuUserDetail(communityUser);  // then assertNotNull(resultCommunityUser);  // given CommunityUser communityNoUser = new CommunityUser(); communityNoUser.setCmmntyId(communityUser.getCmmntyId()); communityNoUser.setEmplyrId("00000000000"); // 존재하지 않는 사용자ID  // when resultCommunityUser = egovCommuManageDAO.selectSingleCommuUserDetail(communityNoUser);  // then "<AssertPlaceHolder>"; }
selectSingleCommuUserDetail(CommunityUser cmmntyUser) { return (CommunityUser) selectOne("CommuManage.selectSingleCommuUserDetail", cmmntyUser); }
[*] target: assertNull(resultCommunityUser)
[-] pred: org. junit. Assert. assertNull ( resultCommunityUser )
************************************
************************************
[+] input: Exception { Map<String, Object> values = new HashMap<String, Object>(); values.put("intValue", 1); values.put("booleanValue", true); values.put("stringArray", new String[] { "a", "b", "c" }); TypedMap map = new TypedMap(recordType, values);  map.clear(); "<AssertPlaceHolder>"; }
size() { return inner.size(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size ( ) )
************************************
************************************
[+] input: Exception { EmpVO vo = makeVO();  // insert employerMapper.insertEmployer(vo);  // 검색조건으로 key 설정 EmpVO searchVO = new EmpVO(); searchVO.setEmpName("홍길");  // selectList List<EmpVO> resultList = employerMapper.selectEmployerList(searchVO);  // key 조건에 대한 결과는 한건일 것임 "<AssertPlaceHolder>"; assertTrue(resultList.size() > 0); assertEquals(1, resultList.size()); // assertTrue(resultList.get(0) instanceof DeptVO); checkResult(vo, resultList.get(0));  }
selectEmployerList(EmpVO vo);
[*] target: assertNotNull(resultList)
[-] pred: org. junit. Assert. assertNotNull ( resultList )
************************************
************************************
[+] input: testParse() { GalleryDetailUrlParser.Result result = GalleryDetailUrlParser.parse(url, strict); if (isNull) { "<AssertPlaceHolder>"; } else { assertEquals(gid, result.gid); assertEquals(token, result.token); } }
parse(String url, boolean strict) { if (url == null) { return null; }  Pattern pattern = strict ? URL_STRICT_PATTERN : URL_PATTERN; Matcher m = pattern.matcher(url); if (m.find()) { Result result = new Result(); result.gid = NumberUtils.parseLongSafely(m.group(1), -1L); result.token = m.group(2); if (result.gid < 0) { return null; } return result; } else { return null; } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testParse() { GalleryPageUrlParser.Result result = GalleryPageUrlParser.parse(url, strict); if (isNull) { "<AssertPlaceHolder>"; } else { assertEquals(gid, result.gid); assertEquals(pToken, result.pToken); assertEquals(page, result.page); } }
parse(String url, boolean strict) { if (url == null) { return null; }  Pattern pattern = strict ? URL_STRICT_PATTERN : URL_PATTERN; Matcher m = pattern.matcher(url); if (m.find()) { Result result = new Result(); result.gid = NumberUtils.parseLongSafely(m.group(2), -1L); result.pToken = m.group(1); result.page = NumberUtils.parseIntSafely(m.group(3), 0) - 1; if (result.gid < 0 || result.page < 0) { return null; } return result; } else { return null; } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: RepositoryException { PackageModel packageModelByPath = packageInfoService.getPackageModelByPath("/etc/packages/testGroup/testPackage-3.zip", resourceResolver);  "<AssertPlaceHolder>"; }
getPackageModelByPath(final String packagePath, final ResourceResolver resourceResolver) { final Session session = resourceResolver.adaptTo(Session.class); JcrPackageManager packMgr = basePackageService.getPackageManager(session);  JcrPackage jcrPackage = null; if (session == null) { return null; } try {  Node packageNode = session.getNode(packagePath); if (packageNode != null) { jcrPackage = packMgr.open(packageNode); return getPackageModel(jcrPackage); }  } catch (RepositoryException e) { LOGGER.error("Error during package opening", e); } finally { if (jcrPackage != null) { jcrPackage.close(); } } return null; }
[*] target: assertNull(packageModelByPath)
[-] pred: org. junit. Assert. assertNull ( packageModelByPath )
************************************
************************************
[+] input: shouldReturnFalseWithNonExistingPackage() { PackageInfoModel packageInfoModel = new PackageInfoModel(); packageInfoModel.setPackagePath(TEST_PACKAGE);  boolean result = packageInfoService.packageExists(resourceResolver, packageInfoModel);  "<AssertPlaceHolder>"; }
packageExists(ResourceResolver resourceResolver, PackageInfoModel packageInfoModel) { final Session session = resourceResolver.adaptTo(Session.class); final JcrPackageManager packageMgr = basePackageService.getPackageManager(session); try { List<Node> nodes = packageMgr.listPackages().stream().map(JcrPackage::getNode) .filter(Objects::nonNull).collect(Collectors.toList()); for (Node node : nodes) { if (node.getPath().equals(packageInfoModel.getPackagePath())) { return true; } } } catch (RepositoryException e) { LOGGER.error(String.format(BackpackConstants.PACKAGE_DOES_NOT_EXIST_MESSAGE, packageInfoModel.getPackagePath())); } return false; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: RepositoryException { PackageInfo packageInfo = getDefaultPackageInfo(); DefaultWorkspaceFilter defaultWorkspaceFilter = new DefaultWorkspaceFilter(); defaultWorkspaceFilter.add(new PathFilterSet(PAGE_1)); createPackage(packageInfo, defaultWorkspaceFilter);  PackageInfoModel packageInfoModel = new PackageInfoModel(); packageInfoModel.setPackagePath(PACKAGE_PATH);  boolean result = packageInfoService.packageExists(resourceResolver, packageInfoModel);  "<AssertPlaceHolder>"; }
packageExists(ResourceResolver resourceResolver, PackageInfoModel packageInfoModel) { final Session session = resourceResolver.adaptTo(Session.class); final JcrPackageManager packageMgr = basePackageService.getPackageManager(session); try { List<Node> nodes = packageMgr.listPackages().stream().map(JcrPackage::getNode) .filter(Objects::nonNull).collect(Collectors.toList()); for (Node node : nodes) { if (node.getPath().equals(packageInfoModel.getPackagePath())) { return true; } } } catch (RepositoryException e) { LOGGER.error(String.format(BackpackConstants.PACKAGE_DOES_NOT_EXIST_MESSAGE, packageInfoModel.getPackagePath())); } return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: shouldReturnEmptyListWhenResourceIsNull() { List<String> result = liveCopySearchService.getLiveCopies(resourceResolver, "path", StringUtils.EMPTY);  "<AssertPlaceHolder>"; }
getLiveCopies(ResourceResolver resourceResolver, String path, String sourceSyncPath) { List<String> paths = new ArrayList<>(); Resource resource = resourceResolver.getResource(path); if (resource == null) { return paths; } try { RangeIterator relationships = liveRelationshipManager.getLiveRelationships(resource, null, null); while (relationships.hasNext()) { LiveRelationship relationship = (LiveRelationship) relationships.next(); LiveCopy liveCopy = relationship.getLiveCopy(); String syncPath = StringUtils.defaultIfEmpty(relationship.getSyncPath(), sourceSyncPath); if (liveCopy == null || (StringUtils.isNotBlank(syncPath) && !liveCopy.isDeep())) { continue; } String liveCopyPath = liveCopy.getPath(); if (resourceResolver.getResource(liveCopyPath + syncPath) != null) { paths.add(liveCopyPath + syncPath); } paths.addAll(getLiveCopies(resourceResolver, liveCopyPath, syncPath)); } } catch (WCMException e) { LOGGER.error("Can't get relationships of the resource {}", resource.getPath(), e); } return paths; }
[*] target: assertEquals(0, result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: WCMException { when(liveRelationshipManager.getLiveRelationships(any(), any(), any())).thenThrow(new WCMException("error message"));  List<String> result = liveCopySearchService.getLiveCopies(resourceResolver, "path", StringUtils.EMPTY);  "<AssertPlaceHolder>"; }
getLiveCopies(ResourceResolver resourceResolver, String path, String sourceSyncPath) { List<String> paths = new ArrayList<>(); Resource resource = resourceResolver.getResource(path); if (resource == null) { return paths; } try { RangeIterator relationships = liveRelationshipManager.getLiveRelationships(resource, null, null); while (relationships.hasNext()) { LiveRelationship relationship = (LiveRelationship) relationships.next(); LiveCopy liveCopy = relationship.getLiveCopy(); String syncPath = StringUtils.defaultIfEmpty(relationship.getSyncPath(), sourceSyncPath); if (liveCopy == null || (StringUtils.isNotBlank(syncPath) && !liveCopy.isDeep())) { continue; } String liveCopyPath = liveCopy.getPath(); if (resourceResolver.getResource(liveCopyPath + syncPath) != null) { paths.add(liveCopyPath + syncPath); } paths.addAll(getLiveCopies(resourceResolver, liveCopyPath, syncPath)); } } catch (WCMException e) { LOGGER.error("Can't get relationships of the resource {}", resource.getPath(), e); } return paths; }
[*] target: assertEquals(0, result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: testReset() {  final String defaultValue = Properties.TARGET_CLASS;  final String aString = "foo_foo_foo"; Assert.assertNotEquals(defaultValue, aString);  Properties.TARGET_CLASS = aString; Assert.assertEquals(aString,Properties.TARGET_CLASS);  Properties.getInstance().resetToDefaults(); Assert."<AssertPlaceHolder>"; }
resetToDefaults() { Properties.instance = new Properties(false, true); for (Field f : Properties.class.getFields()) { if (f.isAnnotationPresent(Parameter.class)) { if (defaultMap.containsKey(f)) { try { f.set(null, defaultMap.get(f)); } catch (Exception e) { logger.error("Failed to init property field " + f + " , " + e.getMessage(), e); } } } } }
[*] target: assertEquals(defaultValue,Properties.TARGET_CLASS)
[-] pred: org. junit. Assert. assertEquals ( defaultValue, Properties.TARGET_CLASS )
************************************
************************************
[+] input: testStartsWith() { String prefix = "test"; String str = "blahtestchen"; int result = StringHelper.StringStartsWith(str, prefix, 4); "<AssertPlaceHolder>"; }
StringStartsWith(String value, String prefix, int start) { int len = Math.min(prefix.length(), value.length()); ConstantPoolManager.getInstance().addDynamicConstant(prefix + value); return StringEquals(value.substring(start, Math.min(start + len, value.length())), prefix); }
[*] target: assertTrue(result > 0)
[-] pred: org. junit. Assert. assertTrue ( result > 0 )
************************************
************************************
[+] input: testEndsWith() { String suffix = "test"; String str = "foo bar test"; int result = StringHelper.StringEndsWith(str, suffix); "<AssertPlaceHolder>"; }
StringEndsWith(String value, String suffix) { int len = Math.min(suffix.length(), value.length()); String val1 = value.substring(value.length() - len); ConstantPoolManager.getInstance().addDynamicConstant(value + suffix); return StringEquals(val1, suffix); }
[*] target: assertTrue(result > 0)
[-] pred: org. junit. Assert. assertTrue ( result > 0 )
************************************
************************************
[+] input: IOException {  File dir = JUnitAnalyzer.createNewTmpDir(); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dir.exists());  FileUtils.deleteDirectory(dir); Assert.assertFalse(dir.exists()); }
createNewTmpDir() { File dir = null; String dirName = FileUtils.getTempDirectoryPath() + File.separator + "EvoSuite_" + (dirCounter++) + "_" + +System.currentTimeMillis();  //first create a tmp folder dir = new File(dirName); if (!dir.mkdirs()) { logger.error("Cannot create tmp dir: " + dirName); return null; }  if (!dir.exists()) { logger.error("Weird behavior: we created folder, but Java cannot determine if it exists? Folder: " + dirName); return null; }  return dir; }
[*] target: assertNotNull(dir)
[-] pred: org. junit. Assert. assertNotNull ( dir )
************************************
************************************
[+] input: testCompareEqual() { GoalComparator comparator = new GoalComparator(); ExceptionCoverageTestFitness goal1 = new ExceptionCoverageTestFitness("FooClass", "toString()", MockArithmeticException.class, ExceptionCoverageTestFitness.ExceptionType.EXPLICIT); ExceptionCoverageTestFitness goal2 = new ExceptionCoverageTestFitness("FooClass", "toString()", MockArithmeticException.class, ExceptionCoverageTestFitness.ExceptionType.EXPLICIT); "<AssertPlaceHolder>"; }
compare(TestFitnessFunction o1, TestFitnessFunction o2) { Class<?> c1 = o1.getClass(); Class<?> c2 = o2.getClass(); if(c1.equals(c2)) return o1.compareTo(o2);  if(c1.equals(ExceptionCoverageTestFitness.class)) return -1; else if(c2.equals(ExceptionCoverageTestFitness.class)) return 1;  if(c1.equals(MethodCoverageTestFitness.class)) return -1; else if(c2.equals(MethodCoverageTestFitness.class)) return 1;  if(c1.equals(MethodNoExceptionCoverageTestFitness.class)) return -1; else if(c2.equals(MethodNoExceptionCoverageTestFitness.class)) return 1;  if(c1.equals(OutputCoverageTestFitness.class)) return -1; else if(c2.equals(OutputCoverageTestFitness.class)) return 1;  if(c1.equals(InputCoverageTestFitness.class)) return -1; else if(c2.equals(InputCoverageTestFitness.class)) return 1;  // TODO: Assertion  return 0; }
[*] target: assertEquals(0, comparator.compare(goal1, goal2))
[-] pred: org. junit. Assert. assertEquals ( 0, comparator. compare ( goal1, goal2 ) )
************************************
************************************
[+] input: canFindJDKData() { InheritanceTree it = InheritanceTreeGenerator.readJDKData(); Assert."<AssertPlaceHolder>"; }
readJDKData() { XStream xstream = new XStream(); XStream.setupDefaultSecurity(xstream); xstream.allowTypesByWildcard(new String[] {"org.evosuite.**", "org.jgrapht.**"});  String fileName; if(! PackageInfo.isCurrentlyShaded()) { fileName = "/" + jdkFile; } else { fileName = "/" + shadedJdkFile; }  InputStream inheritance = InheritanceTreeGenerator.class.getResourceAsStream(fileName);  if (inheritance != null) { return (InheritanceTree) xstream.fromXML(inheritance); } else { logger.warn("Found no JDK inheritance tree in the resource path: "+fileName); return null; } }
[*] target: assertNotNull(it)
[-] pred: org. junit. Assert. assertNotNull ( it )
************************************
************************************
[+] input: testFoo() { String targetClassName = Foo.class.getCanonicalName(); GetStaticGraph graph = GetStaticGraphGenerator .generate(targetClassName);  Set<String> expectedClasses = new HashSet<String>(Arrays.asList( Foo.class.getCanonicalName(), Bar1.class.getCanonicalName(), Bar2.class.getCanonicalName(), Bar3.class.getCanonicalName(), Bar4.class.getCanonicalName(), Bar5.class.getCanonicalName(), Bar6.class.getCanonicalName(), Bar7.class.getCanonicalName(), BarBar1.class.getCanonicalName()));  Set<String> allClasses = new HashSet<String>(); allClasses.addAll(graph.getSourceClasses()); allClasses.addAll(graph.getTargetClasses());  assertEquals(expectedClasses, allClasses);  Map<String, Set<String>> expectedStaticFields = new HashMap<String, Set<String>>(); expectedStaticFields.put(Bar2.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar2"))); expectedStaticFields.put(Bar6.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar6"))); expectedStaticFields.put(Bar7.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar7")));  Map<String, Set<String>> staticFields = graph.getStaticFields(); "<AssertPlaceHolder>"; }
getStaticFields() { Map<String, Set<String>> staticFields = new LinkedHashMap<String, Set<String>>(); for (StaticFieldReadEntry read : this.staticFieldReads) { String className = read.getTargetClass().replace('/', '.'); if (!staticFields.containsKey(className)) { staticFields.put(className, new LinkedHashSet<String>()); } staticFields.get(className).add(read.getTargetField()); } return staticFields; }
[*] target: assertEquals(expectedStaticFields, staticFields)
[-] pred: org. junit. Assert. assertEquals ( expectedStaticFields, staticFields )
************************************
************************************
[+] input: testMazeSolution() { char[] solution = "ssssddddwwaawwddddssssddwwww".toCharArray(); int ret_val = Maze.walk(solution); "<AssertPlaceHolder>"; }
walk(char[] moves) { char[][] maze = new char[][] { // row 0 "+-+---+---+".toCharArray(), // row 1 "| |     |#|".toCharArray(), // row 2 "| | --+ | |".toCharArray(), // row 3 "| |   | | |".toCharArray(), // row 4 "| +-- | | |".toCharArray(), // row 5 "|     |   |".toCharArray(), // row 6 "+-----+---+".toCharArray()};   int x, y; // Player position int ox, oy; // Old player position int i = 0; // Iteration number  // Initial position x = 1; y = 1; maze[y][y] = 'X';  // Print some info System.out.print("Maze dimensions: " + W_SIZE + "," + H_SIZE + "\n"); System.out.print("Player pos: " + x + "x" + y + "\n"); System.out.print("Iteration no. " + i + "\n"); System.out.print("The player moves with 'w', 's', 'a' and 'd'\n"); System.out.print("Try to reach the price(#)!\n");  // Draw the maze draw(maze);  // Iterate and run 'program' while (i < moves.length) { ox = x; oy = y; switch (moves[i]) { case 'w': y--; break; case 's': y++; break; case 'a': x--; break; case 'd': x++; break; default: { System.out.println("Invalid move " + moves[i]); return 0; } }  if (maze[y][x] == '#') { System.out.print("You win!\n"); System.out.print("Your solution \n" + Arrays.toString(moves)); return 1; }  if (maze[y][x] != ' ' && !((y == 2 && maze[y][x] == '|' && x > 0 && x < W_SIZE))) { x = ox; y = oy; }  if (ox == x && oy == y) { System.out.print("You lose\n"); return 2; }  maze[y][x] = 'X'; draw(maze); // draw it  i++; }  System.out.print("Treasure not found.\n"); return 3; }
[*] target: assertEquals(1, ret_val)
[-] pred: org. junit. Assert. assertEquals ( 1, ret_val )
************************************
************************************
[+] input: testInvalidMove() { char[] solution = "ssssddddwwaawwddddssssdX".toCharArray(); int ret_val = Maze.walk(solution); "<AssertPlaceHolder>"; }
walk(char[] moves) { char[][] maze = new char[][] { // row 0 "+-+---+---+".toCharArray(), // row 1 "| |     |#|".toCharArray(), // row 2 "| | --+ | |".toCharArray(), // row 3 "| |   | | |".toCharArray(), // row 4 "| +-- | | |".toCharArray(), // row 5 "|     |   |".toCharArray(), // row 6 "+-----+---+".toCharArray()};   int x, y; // Player position int ox, oy; // Old player position int i = 0; // Iteration number  // Initial position x = 1; y = 1; maze[y][y] = 'X';  // Print some info System.out.print("Maze dimensions: " + W_SIZE + "," + H_SIZE + "\n"); System.out.print("Player pos: " + x + "x" + y + "\n"); System.out.print("Iteration no. " + i + "\n"); System.out.print("The player moves with 'w', 's', 'a' and 'd'\n"); System.out.print("Try to reach the price(#)!\n");  // Draw the maze draw(maze);  // Iterate and run 'program' while (i < moves.length) { ox = x; oy = y; switch (moves[i]) { case 'w': y--; break; case 's': y++; break; case 'a': x--; break; case 'd': x++; break; default: { System.out.println("Invalid move " + moves[i]); return 0; } }  if (maze[y][x] == '#') { System.out.print("You win!\n"); System.out.print("Your solution \n" + Arrays.toString(moves)); return 1; }  if (maze[y][x] != ' ' && !((y == 2 && maze[y][x] == '|' && x > 0 && x < W_SIZE))) { x = ox; y = oy; }  if (ox == x && oy == y) { System.out.print("You lose\n"); return 2; }  maze[y][x] = 'X'; draw(maze); // draw it  i++; }  System.out.print("Treasure not found.\n"); return 3; }
[*] target: assertEquals(0, ret_val)
[-] pred: org. junit. Assert. assertEquals ( 0, ret_val )
************************************
************************************
[+] input: testMazeSolution() {  int ret_val = MazeClient.walk('s', 's', 's', 's', 'd', 'd', 'd', 'd', 'w', 'w', 'a', 'a', 'w', 'w', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 'd', 'd', 'w', 'w', 'w', 'w', (char) 0, (char) 0, 28); "<AssertPlaceHolder>"; }
walk(char move0, char move1, char move2, char move3, char move4, char move5, char move6, char move7, char move8, char move9, char move10, char move11, char move12, char move13, char move14, char move15, char move16, char move17, char move18, char move19, char move20, char move21, char move22, char move23, char move24, char move25, char move26, char move27, char move28, char move29, int moveLength) {  char[] moves = new char[] {move0, move1, move2, move3, move4, move5, move6, move7, move8, move9, move10, move11, move12, move13, move14, move15, move16, move17, move18, move19, move20, move21, move22, move23, move24, move25, move26, move27, move28, move29};  return walk(moves, moveLength); }
[*] target: assertEquals(1, ret_val)
[-] pred: org. junit. Assert. assertEquals ( 1, ret_val )
************************************
************************************
[+] input: ClassNotFoundException { Properties.DSE_SOLVER = Properties.SolverType.EVOSUITE_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: ClassNotFoundException { String cvc4_path = System.getenv("cvc4_path"); if (cvc4_path != null) { Properties.CVC4_PATH = cvc4_path; } Assume.assumeTrue(Properties.CVC4_PATH!=null); Properties.DSE_SOLVER = Properties.SolverType.CVC4_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: testConfirmToString() { String res = new OverrideToString().toString(); String diff = res + " a different string";  OverrideToString obj = mock(OverrideToString.class); when(obj.toString()).thenReturn(diff);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(diff, obj.toString())
[-] pred: org. junit. Assert. assertEquals ( diff, obj. toString ( ) )
************************************
************************************
[+] input: testConfirmToStringAbstract() {  String diff = " a different string";  OverrideToStringAbstract obj = mock(OverrideToStringAbstract.class); when(obj.toString()).thenReturn(diff);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(diff, obj.toString())
[-] pred: org. junit. Assert. assertEquals ( diff, obj. toString ( ) )
************************************
************************************
[+] input: testConfirmNumber() { String foo = "foo"; Number number = mock(Number.class); when(number.toString()).thenReturn(foo);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(foo, number.toString())
[-] pred: org. junit. Assert. assertEquals ( foo, number. toString ( ) )
************************************
************************************
[+] input: test() { DifficultDependencyClass dependency = new DifficultDependencyClass(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); dependency.inc(); DifficultClassWithoutCarving foo = new DifficultClassWithoutCarving(); boolean result = foo.testMe(dependency); "<AssertPlaceHolder>"; }
testMe(DifficultDependencyClass dependency) { if(dependency.isTen()) return true; else return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testFactory_daysIn_RInterval() { Days d = new Days(PARIS); "<AssertPlaceHolder>"; }
getDays() { return 0; }
[*] target: assertEquals(0, d.getDays())
[-] pred: org. junit. Assert. assertEquals ( 0, d. getDays() )
************************************
************************************
[+] input: testStrength() { StrengthFitnessComparator comparator = new StrengthFitnessComparator();  NSGAChromosome c1 = new NSGAChromosome(); NSGAChromosome c2 = new NSGAChromosome();  c1.setDistance(0.1); c2.setDistance(0.9); assertEquals(-1, comparator.compare(c1, c2)); // c1 dominates c2  c1.setDistance(0.9); c2.setDistance(0.1); "<AssertPlaceHolder>"; // c2 dominates c1 }
compare(Chromosome c1, Chromosome c2) { if (c1 == null && c2 == null) { return 0; } else if (c1 == null) { return 1; } else if (c2 == null) { return -1; }  double strengthC1 = c1.getDistance(); // TODO: should we change name of the function? double strengthC2 = c2.getDistance();  if (strengthC1 < strengthC2) { return -1; } else if (strengthC1 > strengthC2) { return 1; } else { return 0; } }
[*] target: assertEquals(1, comparator.compare(c1, c2))
[-] pred: org. junit. Assert. assertEquals ( 1, comparator. compare ( c1, c2 ) )
************************************
************************************
[+] input: testRingTopology_leftNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 2);  Chromosome exepcted_individual = population.get(1); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testRingTopology_rightNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 2);  Chromosome exepcted_individual = population.get(3); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testRingTopology_mostLeftNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 0);  Chromosome exepcted_individual = population.get(15); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testRingTopology_mostRightNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 15);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(1); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(9); Chromosome returned_individual = neighbors.get(1);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(6); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(4); Chromosome returned_individual = neighbors.get(3);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(10); Chromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(8); Chromosome returned_individual = neighbors.get(5);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthNorthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 10);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(8);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthSouthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 10);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(9);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testWestWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 5);  Chromosome exepcted_individual = population.get(7); Chromosome returned_individual = neighbors.get(11);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 0);  Chromosome exepcted_individual = population.get(15); Chromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 3);  Chromosome exepcted_individual = population.get(12); Chromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostSouthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 12);  Chromosome exepcted_individual = population.get(3); Chromosome returned_individual = neighbors.get(5);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 15);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: Exception {  ClassLoader loader = new EvoClassLoader(); RuntimeSettings.resetStaticState = true; ClassResetter.getInstance().setClassLoader(loader);  String cut = "com.examples.with.different.packagename.classhandling.FooEnum";  Class<?> klass = loader.loadClass(cut); Method m = klass.getDeclaredMethod("check");  boolean val = false;  val = (Boolean) m.invoke(null); Assert.assertTrue(val);  ClassResetter.getInstance().reset(cut);  //make sure that the reset does not create new enum instance values val = (Boolean) m.invoke(null); Assert."<AssertPlaceHolder>"; }
reset(String classNameWithDots) throws IllegalArgumentException, IllegalStateException{ if(classNameWithDots==null || classNameWithDots.isEmpty()){ throw new IllegalArgumentException("Empty class name in input"); }  if(loader == null){ throw new IllegalStateException("No specified loader"); }  Method m = getResetMethod(classNameWithDots); if(m == null) { return; }  boolean safe = Sandbox.isSafeToExecuteSUTCode();  assert !Sandbox.isSecurityManagerInitialized() || Sandbox.isOnAndExecutingSUTCode();  InstrumentingAgent.activate(); org.evosuite.runtime.Runtime.getInstance().resetRuntime(); boolean wasLoopCheckOn = LoopCounter.getInstance().isActivated();  try { if(!safe){ Sandbox.goingToExecuteUnsafeCodeOnSameThread(); } LoopCounter.getInstance().setActive(false); m.invoke(null, (Object[]) null); } catch (IllegalAccessException | IllegalArgumentException e) { logger.error(""+e,e); } catch (NoClassDefFoundError e){ AtMostOnceLogger.error(logger,e.toString()); } catch(InvocationTargetException e){  Throwable cause = e.getCause(); if(cause instanceof TooManyResourcesException || cause instanceof NoClassDefFoundError){ logWarn(classNameWithDots, e.toString() + ", caused by: "+cause.toString()); } else { StringWriter errors = new StringWriter(); cause.printStackTrace(new PrintWriter(errors)); logWarn(classNameWithDots, e.toString() + ", caused by: "+cause.toString()+"\n"+errors.toString()); // we are only interested in the stack trace of the cause } } finally { if(!safe){ Sandbox.doneWithExecutingUnsafeCodeOnSameThread(); } LoopCounter.getInstance().setActive(wasLoopCheckOn); }  InstrumentingAgent.deactivate(); }
[*] target: assertTrue(val)
[-] pred: org. junit. Assert. assertTrue ( val )
************************************
************************************
[+] input: testInitializeClasses() {   EvoClassLoader loader = new EvoClassLoader(); String className = "com.examples.with.different.packagename.classhandling.TimeA"; //no mocking RuntimeSettings.deactivateAllMocking(); boolean problem = ClassStateSupport.initializeClasses(loader, className); Assert.assertFalse(problem);  //with mocking RuntimeSettings.mockJVMNonDeterminism = true; className = "com.examples.with.different.packagename.classhandling.TimeB"; problem = ClassStateSupport.initializeClasses(loader,className); Assert."<AssertPlaceHolder>"; }
initializeClasses(ClassLoader classLoader, String... classNames) {  boolean problem = false;  List<Class<?>> classes = loadClasses(classLoader, classNames); if(classes.size() != classNames.length) { problem = true; }  initialiseExternalTools(classLoader, classes);  if(RuntimeSettings.isUsingAnyMocking()) {  for (Class<?> clazz : classes) {  if(clazz.isInterface()) { /* FIXME: once we ll start to support Java 8, in which interfaces can have code, we ll need to instrument them as well */ continue; }  if (!InstrumentedClass.class.isAssignableFrom(clazz)) { String msg = "Class " + clazz.getName() + " was not instrumented by EvoSuite. " + "This could happen if you are running JUnit tests in a way that is not handled by EvoSuite, in " + "which some classes are loaded be reflection before the tests are run. Consult the EvoSuite documentation " + "for possible workarounds for this issue."; logger.error(msg); problem = true; //throw new IllegalStateException(msg); // throwing an exception might be a bit too extreme } } }  return problem;  //retransformIfNeeded(classes); // cannot do it, as retransformation does not really work :( }
[*] target: assertFalse(problem)
[-] pred: org. junit. Assert. assertFalse ( problem )
************************************
************************************
[+] input: testDoubleInit() { int n = ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks();  Runtime.getRuntime().addShutdownHook(new Thread(){});  //this should remove the above hook thread ShutdownHookHandler.getInstance().initHandler();  Assert."<AssertPlaceHolder>"; }
getNumberOfAllExistingHooks() { if(hooksReference==null) { return -1; } return hooksReference.size(); }
[*] target: assertEquals(n, ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks())
[-] pred: org. junit. Assert. assertEquals ( n, ShutdownHookHandler.getInstance ( ). getNumberOfAllExistingHooks() )
************************************
************************************
[+] input: testHibernateConfiguration() { EntityManagerFactory factory = MockPersistence.createEntityManagerFactory("foo"); EntityManager em = factory.createEntityManager(); factory.close(); Assert."<AssertPlaceHolder>"; }
createEntityManagerFactory(String persistenceUnitName) { return DBManager.getInstance().getDefaultFactory(); }
[*] target: assertNotNull(em)
[-] pred: org. junit. Assert. assertNotNull ( em )
************************************
************************************
[+] input: testGetCurrentDirectory() {  JFileChooser chooser = new MockJFileChooser(); File dir = chooser.getCurrentDirectory();  Assert."<AssertPlaceHolder>"; Assert.assertTrue(dir instanceof MockFile); }
getCurrentDirectory() { return currentDirectory; }
[*] target: assertTrue(dir.exists())
[-] pred: org. junit. Assert. assertTrue ( dir. exists ( ) )
************************************
************************************
[+] input: Exception {  EvoSuiteLocalAddress addr = new EvoSuiteLocalAddress("127.42.42.42",42); NetworkHandling.sendDataOnTcp(addr,null);  MockServerSocket sut = new MockServerSocket(addr.getPort(), 1, MockInetAddress.getByName(addr.getHost())); Socket socket = sut.accept(); //should not block, should not timeout Assert."<AssertPlaceHolder>"; }
sendDataOnTcp(EvoSuiteLocalAddress sutServer, byte[] data){ if(sutServer==null){ return false; }  NativeTcp connection = VirtualNetwork.getInstance().registerIncomingTcpConnection( DEFAULT_REMOTE_ADDRESS, VirtualNetwork.getInstance().getNewRemoteEphemeralPort(), sutServer.getHost(), sutServer.getPort());  /* * At this point in time the SUT has not opened a connection yet (if it did, * it would had thrown an IOException). * But we can already put the message on the buffer */  if(data != null){ for(byte b : data){ connection.writeToSUT(b); } } //TODO close connection? or should rather be in another helper function?  return true; }
[*] target: assertNotNull(socket)
[-] pred: org. junit. Assert. assertNotNull ( socket )
************************************
************************************
[+] input: Exception { String text = "Hello World!"; EvoSuiteURL url = new EvoSuiteURL("http://evosuite.org/hello.txt");  NetworkHandling.createRemoteTextFile(url,text);  URL mock = MockURL.URL(url.getUrl()); URLConnection connection = mock.openConnection(); Scanner in = new Scanner(connection.getInputStream()); String res = in.nextLine(); Assert."<AssertPlaceHolder>"; }
createRemoteTextFile(EvoSuiteURL url, String text){ if(url == null){ return false; } return VirtualNetwork.getInstance().addRemoteTextFile(url.getUrl(),text); }
[*] target: assertEquals(text,res)
[-] pred: org. junit. Assert. assertEquals ( text, res )
************************************
************************************
[+] input: equalsHashcodeVerify() { TourRating rating1 = new TourRating(tour, 1, 1, "comment"); TourRating rating2 = new TourRating(tour, 1, 1, "comment");  assertEquals(rating1,rating2); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(id, tour, customerId, score, comment); }
[*] target: assertEquals(rating1.hashCode(), rating2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( rating1. hashCode ( ), rating2. hashCode ( ) )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_FORWARDING_ROUTING_V4); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_FORWARDING_NOP_ROUTING_V4) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder().wipeDeferred().build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_FORWARDING_ROUTING_V4); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_FORWARDING_DROP_ROUTING_V4) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_ACL_ACL); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_ACL_NOP_ACL) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .wipeDeferred() .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_ACL_ACL); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_ACL_DROP) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { //     TrafficTreatment treatment = DefaultTrafficTreatment.builder() //             .setOutput(PORT_1) //             .build(); //     PiAction mappedAction = interpreter.mapTreatment( //             treatment, P4InfoConstants.FABRIC_INGRESS_NEXT_SIMPLE); //     PiActionParam param = new PiActionParam(P4InfoConstants.PORT_NUM, PORT_1.toLong()); //     PiAction expectedAction = PiAction.builder() //             .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_OUTPUT_SIMPLE) //             .withParameter(param) //             .build(); //     "<AssertPlaceHolder>"; // }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .setEthSrc(SRC_MAC) .setEthDst(DST_MAC) .setOutput(PORT_1) .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_NEXT_HASHED); PiActionParam ethSrcParam = new PiActionParam(P4InfoConstants.SMAC, SRC_MAC.toBytes()); PiActionParam ethDstParam = new PiActionParam(P4InfoConstants.DMAC, DST_MAC.toBytes()); PiActionParam portParam = new PiActionParam(P4InfoConstants.PORT_NUM, PORT_1.toLong()); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_ROUTING_HASHED) .withParameters(ImmutableList.of(ethSrcParam, ethDstParam, portParam)) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .setVlanId(VLAN_100) .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_NEXT_VLAN); PiActionParam vlanParam = new PiActionParam( P4InfoConstants.VLAN_ID, VLAN_100.toShort()); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_SET_VLAN) .withParameter(vlanParam) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .setMpls(MPLS_10) .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_NEXT_MPLS); PiActionParam mplsParam = new PiActionParam( P4InfoConstants.LABEL, MPLS_10.toInt()); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_SET_MPLS_LABEL) .withParameter(mplsParam) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { PiAction piAction1 = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_ROUTING_HASHED) .withParameter(new PiActionParam( P4InfoConstants.SMAC, ROUTER_MAC.toBytes())) .withParameter(new PiActionParam( P4InfoConstants.DMAC, HOST_MAC.toBytes())) .withParameter(new PiActionParam( P4InfoConstants.PORT_NUM, PORT_1.toLong())) .build(); PiAction piAction2 = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_ROUTING_HASHED) .withParameter(new PiActionParam( P4InfoConstants.SMAC, ROUTER_MAC.toBytes())) .withParameter(new PiActionParam( P4InfoConstants.DMAC, HOST_MAC.toBytes())) .withParameter(new PiActionParam( P4InfoConstants.PORT_NUM, PORT_1.toLong())) .build(); TrafficTreatment treatment1 = DefaultTrafficTreatment.builder() .piTableAction(piAction1) .build(); TrafficTreatment treatment2 = DefaultTrafficTreatment.builder() .piTableAction(piAction2) .build();  NextObjective nextObjective = DefaultNextObjective.builder() .withId(NEXT_ID_1) .withPriority(PRIORITY) .withMeta(VLAN_META) .addTreatment(treatment1) .addTreatment(treatment2) .withType(NextObjective.Type.HASHED) .makePermanent() .fromApp(APP_ID) .add();  ObjectiveTranslation actualTranslation = translatorHashed.doTranslate(nextObjective);  // Expected hashed table flow rule. PiCriterion nextIdCriterion = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_NEXT_ID, NEXT_ID_1) .build(); TrafficSelector nextIdSelector = DefaultTrafficSelector.builder() .matchPi(nextIdCriterion) .build(); PiActionProfileGroupId actionGroupId = PiActionProfileGroupId.of(NEXT_ID_1); TrafficTreatment treatment = DefaultTrafficTreatment.builder() .piTableAction(actionGroupId) .build(); FlowRule expectedFlowRule = DefaultFlowRule.builder() .forDevice(DEVICE_ID) .fromApp(APP_ID) .makePermanent() // FIXME: currently next objective doesn't support priority, ignore this .withPriority(0) .forTable(P4InfoConstants.FABRIC_INGRESS_NEXT_HASHED) .withSelector(nextIdSelector) .withTreatment(treatment) .build();  // Expected group List<TrafficTreatment> treatments = ImmutableList.of(treatment1, treatment2); List<GroupBucket> buckets = treatments.stream() .map(DefaultGroupBucket::createSelectGroupBucket) .collect(Collectors.toList()); GroupBuckets groupBuckets = new GroupBuckets(buckets); PiGroupKey groupKey = new PiGroupKey(P4InfoConstants.FABRIC_INGRESS_NEXT_HASHED, P4InfoConstants.FABRIC_INGRESS_NEXT_HASHED_PROFILE, NEXT_ID_1); GroupDescription expectedGroup = new DefaultGroupDescription( DEVICE_ID, GroupDescription.Type.SELECT, groupBuckets, groupKey, NEXT_ID_1, APP_ID );  ObjectiveTranslation expectedTranslation = ObjectiveTranslation.builder() .addFlowRule(expectedFlowRule) .addFlowRule(vlanMetaFlowRule) .addGroup(expectedGroup) .build();  "<AssertPlaceHolder>";  }
doTranslate(NextObjective obj) throws FabricPipelinerException {  final ObjectiveTranslation.Builder resultBuilder = ObjectiveTranslation.builder();  switch (obj.type()) { case SIMPLE: simpleNext(obj, resultBuilder, false); break; case HASHED: hashedNext(obj, resultBuilder); break; case BROADCAST: if (isXconnect(obj)) { // TODO: re-enable support for xconnext // xconnectNext(obj, resultBuilder); log.warn("Xconnect not supported [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); } else { multicastNext(obj, resultBuilder); } break; default: log.warn("Unsupported NextObjective type [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); }  if (!isGroupModifyOp(obj)) { // Generate next VLAN rules. nextMpls(obj, resultBuilder); nextVlan(obj, resultBuilder); }  return resultBuilder.build(); }
[*] target: assertEquals(expectedTranslation, actualTranslation)
[-] pred: org. junit. Assert. assertEquals ( expectedTranslation, actualTranslation )
************************************
************************************
[+] input: FabricPipelinerException { TrafficTreatment treatment1 = DefaultTrafficTreatment.builder() .setOutput(PORT_1) .build(); TrafficTreatment treatment2 = DefaultTrafficTreatment.builder() .popVlan() .setOutput(PORT_2) .build(); NextObjective nextObjective = DefaultNextObjective.builder() .withId(NEXT_ID_1) .withPriority(PRIORITY) .addTreatment(treatment1) .addTreatment(treatment2) .withMeta(VLAN_META) .withType(NextObjective.Type.BROADCAST) .makePermanent() .fromApp(APP_ID) .add();  ObjectiveTranslation actualTranslation = translatorHashed.doTranslate(nextObjective);  // Should generate 3 flows: // - Multicast table flow that matches on next-id and set multicast group (1) // - Egress VLAN pop handling for treatment2 (0) // - Next VLAN flow (2) // And 2 groups: // - Multicast group  // Expected multicast table flow rule. PiCriterion nextIdCriterion = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_NEXT_ID, NEXT_ID_1) .build(); TrafficSelector nextIdSelector = DefaultTrafficSelector.builder() .matchPi(nextIdCriterion) .build(); PiAction setMcGroupAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_SET_MCAST_GROUP_ID) .withParameter(new PiActionParam( P4InfoConstants.GROUP_ID, NEXT_ID_1)) .build(); TrafficTreatment treatment = DefaultTrafficTreatment.builder() .piTableAction(setMcGroupAction) .build(); FlowRule expectedHashedFlowRule = DefaultFlowRule.builder() .forDevice(DEVICE_ID) .fromApp(APP_ID) .makePermanent() .withPriority(nextObjective.priority()) .forTable(P4InfoConstants.FABRIC_INGRESS_NEXT_MULTICAST) .withSelector(nextIdSelector) .withTreatment(treatment) .build();  // Expected egress VLAN_PUSH flow rule. PiCriterion egressVlanTableMatch = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_EG_PORT, PORT_1.toLong()) .build(); TrafficSelector selectorForEgressVlan = DefaultTrafficSelector.builder() .matchPi(egressVlanTableMatch) .matchVlanId(VLAN_100) .build(); PiAction piActionForEgressVlan = PiAction.builder() .withId(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_PUSH_VLAN) .build(); TrafficTreatment treatmentForEgressVlan = DefaultTrafficTreatment.builder() .piTableAction(piActionForEgressVlan) .build(); FlowRule expectedEgressVlanPushRule = DefaultFlowRule.builder() .withSelector(selectorForEgressVlan) .withTreatment(treatmentForEgressVlan) .forTable(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_EGRESS_VLAN) .makePermanent() .withPriority(nextObjective.priority()) .forDevice(DEVICE_ID) .fromApp(APP_ID) .build();  // Expected egress VLAN POP flow rule. egressVlanTableMatch = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_EG_PORT, PORT_2.toLong()) .build(); selectorForEgressVlan = DefaultTrafficSelector.builder() .matchPi(egressVlanTableMatch) .matchVlanId(VLAN_100) .build(); piActionForEgressVlan = PiAction.builder() .withId(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_POP_VLAN) .build(); treatmentForEgressVlan = DefaultTrafficTreatment.builder() .piTableAction(piActionForEgressVlan) .build(); FlowRule expectedEgressVlanPopRule = DefaultFlowRule.builder() .withSelector(selectorForEgressVlan) .withTreatment(treatmentForEgressVlan) .forTable(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_EGRESS_VLAN) .makePermanent() .withPriority(nextObjective.priority()) .forDevice(DEVICE_ID) .fromApp(APP_ID) .build();  // Expected ALL group. TrafficTreatment allGroupTreatment1 = DefaultTrafficTreatment.builder() .setOutput(PORT_1) .build(); TrafficTreatment allGroupTreatment2 = DefaultTrafficTreatment.builder() .setOutput(PORT_2) .build(); List<TrafficTreatment> allTreatments = ImmutableList.of( allGroupTreatment1, allGroupTreatment2); List<GroupBucket> allBuckets = allTreatments.stream() .map(DefaultGroupBucket::createAllGroupBucket) .collect(Collectors.toList()); GroupBuckets allGroupBuckets = new GroupBuckets(allBuckets); GroupKey allGroupKey = new DefaultGroupKey(FabricUtils.KRYO.serialize(NEXT_ID_1)); GroupDescription expectedAllGroup = new DefaultGroupDescription( DEVICE_ID, GroupDescription.Type.ALL, allGroupBuckets, allGroupKey, NEXT_ID_1, APP_ID );  ObjectiveTranslation expectedTranslation = ObjectiveTranslation.builder() .addFlowRule(expectedHashedFlowRule) .addFlowRule(vlanMetaFlowRule) .addFlowRule(expectedEgressVlanPushRule) .addFlowRule(expectedEgressVlanPopRule) .addGroup(expectedAllGroup) .build();  "<AssertPlaceHolder>"; }
doTranslate(NextObjective obj) throws FabricPipelinerException {  final ObjectiveTranslation.Builder resultBuilder = ObjectiveTranslation.builder();  switch (obj.type()) { case SIMPLE: simpleNext(obj, resultBuilder, false); break; case HASHED: hashedNext(obj, resultBuilder); break; case BROADCAST: if (isXconnect(obj)) { // TODO: re-enable support for xconnext // xconnectNext(obj, resultBuilder); log.warn("Xconnect not supported [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); } else { multicastNext(obj, resultBuilder); } break; default: log.warn("Unsupported NextObjective type [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); }  if (!isGroupModifyOp(obj)) { // Generate next VLAN rules. nextMpls(obj, resultBuilder); nextVlan(obj, resultBuilder); }  return resultBuilder.build(); }
[*] target: assertEquals(expectedTranslation, actualTranslation)
[-] pred: org. junit. Assert. assertEquals ( expectedTranslation, actualTranslation )
************************************
************************************
[+] input: test21() { int[] cellPosition = CellReferenceUtil.getCellPosition("B3"); "<AssertPlaceHolder>"; assertEquals(1, cellPosition[1]); }
getCellPosition(String cellRef){ CellReference cellReference = new CellReference(cellRef); return new int[] { cellReference.getRow(), cellReference.getCol() }; }
[*] target: assertEquals(2, cellPosition[0])
[-] pred: org. junit. Assert. assertEquals ( 2, cellPosition [ 0 ] )
************************************
************************************
[+] input: removeElementFromSingleStack() { Stack stack = Stack.getStack(); stack.push('a'); try { assertEquals('a', stack.pop()); } catch (EmptyStackException e) { e.printStackTrace(); } "<AssertPlaceHolder>"; }
getSize() { return size; }
[*] target: assertEquals(0, stack.getSize())
[-] pred: org. junit. Assert. assertEquals ( 0, stack. getSize() )
************************************
************************************
[+] input: should_merge_existing_and_new_categories() { //given existing CategoryBuilder.createDefaultHierarchy(db);  //when cache.loadExistingCategories(db); Set<CategoryInfo> list = new HashSet<CategoryInfo>(); list.add(new CategoryInfo("A:A1", true)); list.add(new CategoryInfo("B", true)); list.add(new CategoryInfo("A:A1:AA2", true)); list.add(new CategoryInfo("A:A2:AB1", false)); list.add(new CategoryInfo("C", false)); list.add(new CategoryInfo("D:D1", true)); cache.insertCategories(db, list);  //then /** * A            1-12 * - A1         2-7 * -- AA1       3-4 * -- AA2       5-6 * - A2         8-11 * -- AB1       9-10 * B            13-14 * C            15-16 * D            17-20 * - D1         18-19 */ CategoryTree<Category> categories = db.getCategoriesTree(false); "<AssertPlaceHolder>"; assertEquals(4, categories.size());  Category noCategory = db.getCategoryWithParent(Category.NO_CATEGORY_ID); assertEquals(0, noCategory.left); assertEquals(21, noCategory.right);  }
insertCategories(DatabaseAdapter dbAdapter, Set<? extends CategoryInfo> categories) { for (CategoryInfo category : categories) { String name = extractCategoryName(category.name); insertCategory(name, category.isIncome); } if (freshStart) { categoryTree.sortByTitle(); } else { categoryTree.reIndex(); } SQLiteDatabase database = dbAdapter.db(); database.beginTransaction(); try { dbAdapter.insertCategoryTreeInTransaction(categoryTree); database.setTransactionSuccessful(); } finally { database.endTransaction(); } }
[*] target: assertNotNull(categories)
[-] pred: org. junit. Assert. assertNotNull ( categories )
************************************
************************************
[+] input: IOException { qifParserTest.should_parse_a_couple_of_empty_accounts(); doImport();  List<Account> accounts = db.getAllAccountsList(); sortAccountsById(accounts);  "<AssertPlaceHolder>"; assertEquals("My Cash Account", accounts.get(0).title); assertEquals(AccountType.CASH.name(), accounts.get(0).type); assertEquals("My Bank Account", accounts.get(1).title); assertEquals(AccountType.BANK.name(), accounts.get(1).type); }
doImport() throws IOException { long t0 = System.currentTimeMillis(); QifBufferedReader r = new QifBufferedReader(new BufferedReader(new InputStreamReader(new FileInputStream(options.filename), "UTF-8"))); QifParser parser = new QifParser(r, options.dateFormat); parser.parse(); long t1 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Parsing done in "+ TimeUnit.MILLISECONDS.toSeconds(t1-t0)+"s"); doImport(parser); long t2 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Importing done in "+ TimeUnit.MILLISECONDS.toSeconds(t2-t1)+"s"); }
[*] target: assertEquals(2, accounts.size())
[-] pred: org. junit. Assert. assertEquals ( 2, accounts. size ( ) )
************************************
************************************
[+] input: Exception { QifParser p = new QifParser(null, QifDateFormat.EU_FORMAT); //P1 // - cc1 // -- c1 // -- c2 // - cc2 //P2 // - x1 p.categories.add(new QifCategory("P1:cc1:c1", true)); p.categories.add(new QifCategory("P1:cc1", true)); p.categories.add(new QifCategory("P1:cc1:c2", true)); p.categories.add(new QifCategory("P2", false)); p.categories.add(new QifCategory("P2:x1", false)); p.categories.add(new QifCategory("P1", true)); p.categories.add(new QifCategory("P1:cc2", true));  //when doImport(p);  //then CategoryTree<Category> categories = db.getCategoriesTree(false); "<AssertPlaceHolder>"; assertEquals(2, categories.size());  Category c = categories.getAt(0); assertCategory("P1", true, c); assertEquals(2, c.children.size());  assertCategory("cc1", true, c.children.getAt(0)); assertEquals(2, c.children.getAt(0).children.size());  assertCategory("cc2", true, c.children.getAt(1)); assertFalse(c.children.getAt(1).hasChildren());  c = categories.getAt(1); assertCategory("P2", false, c); assertEquals(1, c.children.size());  assertCategory("x1", false, c.children.getAt(0)); }
doImport(QifParser parser) { long t0 = System.currentTimeMillis(); insertPayees(parser.payees); long t1 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Inserting payees done in " + TimeUnit.MILLISECONDS.toSeconds(t1 - t0) + "s"); insertProjects(parser.classes); long t2 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Inserting projects done in "+ TimeUnit.MILLISECONDS.toSeconds(t2-t1)+"s"); categoryCache.insertCategories(dbAdapter, parser.categories); long t3 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Inserting categories done in "+ TimeUnit.MILLISECONDS.toSeconds(t3-t2)+"s"); insertAccounts(parser.accounts); long t4 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Inserting accounts done in "+ TimeUnit.MILLISECONDS.toSeconds(t4-t3)+"s"); insertTransactions(parser.accounts); long t5 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Inserting transactions done in "+ TimeUnit.MILLISECONDS.toSeconds(t5-t4)+"s"); }
[*] target: assertNotNull(categories)
[-] pred: org. junit. Assert. assertNotNull ( categories )
************************************
************************************
[+] input: Exception { qifParserTest.should_parse_multiple_accounts(); doImport();  List<Account> accounts = db.getAllAccountsList(); "<AssertPlaceHolder>";  Account a = accounts.get(0); assertEquals("My Bank Account", a.title); assertEquals(AccountType.BANK.name(), a.type);  List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id); assertEquals(2, transactions.size());  TransactionInfo t = transactions.get(0); assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime); assertEquals(-2000, t.fromAmount);  t = transactions.get(1); assertEquals(DateTime.date(2011, 1, 2).atMidnight().asLong(), t.dateTime); assertEquals(5400, t.fromAmount);  a = accounts.get(1); assertEquals("My Cash Account", a.title); assertEquals(AccountType.CASH.name(), a.type);  transactions = db.getTransactionsForAccount(a.id); assertEquals(3, transactions.size());  t = transactions.get(0); assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime); assertEquals(1000, t.fromAmount);  t = transactions.get(1); assertEquals(DateTime.date(2011, 2, 7).atMidnight().asLong(), t.dateTime); assertEquals(-2345, t.fromAmount);  t = transactions.get(2); assertEquals(DateTime.date(2011, 1, 1).atMidnight().asLong(), t.dateTime); assertEquals(-6780, t.fromAmount); }
doImport() throws IOException { long t0 = System.currentTimeMillis(); QifBufferedReader r = new QifBufferedReader(new BufferedReader(new InputStreamReader(new FileInputStream(options.filename), "UTF-8"))); QifParser parser = new QifParser(r, options.dateFormat); parser.parse(); long t1 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Parsing done in "+ TimeUnit.MILLISECONDS.toSeconds(t1-t0)+"s"); doImport(parser); long t2 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Importing done in "+ TimeUnit.MILLISECONDS.toSeconds(t2-t1)+"s"); }
[*] target: assertEquals(2, accounts.size())
[-] pred: org. junit. Assert. assertEquals ( 2, accounts. size ( ) )
************************************
************************************
[+] input: Exception { qifParserTest.should_parse_transfers(); doImport();  List<Account> accounts = db.getAllAccountsList(); "<AssertPlaceHolder>";  Account a = accounts.get(0); assertEquals("My Bank Account", a.title); assertEquals(AccountType.BANK.name(), a.type);  List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id); assertEquals(1, transactions.size());  TransactionInfo t = transactions.get(0); assertTrue("Should be a transfer from bank to cash", t.isTransfer()); assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime); assertEquals("My Bank Account", t.fromAccount.title); assertEquals(-2000, t.fromAmount); assertEquals("My Cash Account", t.toAccount.title); assertEquals(2000, t.toAmount); assertEquals("Vacation", t.project.title);  a = accounts.get(1); assertEquals("My Cash Account", a.title); assertEquals(AccountType.CASH.name(), a.type);  transactions = db.getTransactionsForAccount(a.id); assertEquals(0, transactions.size()); }
doImport() throws IOException { long t0 = System.currentTimeMillis(); QifBufferedReader r = new QifBufferedReader(new BufferedReader(new InputStreamReader(new FileInputStream(options.filename), "UTF-8"))); QifParser parser = new QifParser(r, options.dateFormat); parser.parse(); long t1 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Parsing done in "+ TimeUnit.MILLISECONDS.toSeconds(t1-t0)+"s"); doImport(parser); long t2 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Importing done in "+ TimeUnit.MILLISECONDS.toSeconds(t2-t1)+"s"); }
[*] target: assertEquals(2, accounts.size())
[-] pred: org. junit. Assert. assertEquals ( 2, accounts. size ( ) )
************************************
************************************
[+] input: Exception { qifParserTest.should_parse_transfer_splits(); doImport();  List<Account> accounts = db.getAllAccountsList(); "<AssertPlaceHolder>";  Account a = accounts.get(0); assertEquals("My Bank Account", a.title); assertEquals(AccountType.BANK.name(), a.type);  List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id); assertEquals(0, transactions.size());  a = accounts.get(1); assertEquals("My Cash Account", a.title); assertEquals(AccountType.CASH.name(), a.type);  transactions = db.getTransactionsForAccount(a.id); assertEquals(1, transactions.size());  TransactionInfo t = transactions.get(0); assertEquals(-210000, t.fromAmount);  List<TransactionInfo> splits = getSplitsForTransaction(t.id); assertEquals(2, splits.size());  TransactionInfo s = splits.get(0); assertEquals("A1", s.category.title); assertEquals(-110000, s.fromAmount); assertEquals("Note on first split", s.note);  s = splits.get(1); assertTrue(s.isTransfer()); assertEquals("My Bank Account", s.toAccount.title); assertEquals(-100000, s.fromAmount); assertEquals(100000, s.toAmount); }
doImport() throws IOException { long t0 = System.currentTimeMillis(); QifBufferedReader r = new QifBufferedReader(new BufferedReader(new InputStreamReader(new FileInputStream(options.filename), "UTF-8"))); QifParser parser = new QifParser(r, options.dateFormat); parser.parse(); long t1 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Parsing done in "+ TimeUnit.MILLISECONDS.toSeconds(t1-t0)+"s"); doImport(parser); long t2 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Importing done in "+ TimeUnit.MILLISECONDS.toSeconds(t2-t1)+"s"); }
[*] target: assertEquals(2, accounts.size())
[-] pred: org. junit. Assert. assertEquals ( 2, accounts. size ( ) )
************************************
************************************
[+] input: formatHijriDate() { String str = UiUtils.formatHijriDate(10, "Safar", 1415); "<AssertPlaceHolder>"; }
formatHijriDate(int day, String monthName, int year) { NumberFormat numberFormat = NumberFormat.getInstance(); String date = numberFormat.format(day) + " " + monthName + " " + numberFormat.format(year); return date.replaceAll("[٬،.,]", ""); }
[*] target: assertNotNull(str)
[-] pred: org. junit. Assert. assertNotNull ( str )
************************************
************************************
[+] input: testGetFittestChromosome() { Chromosome c1 = new Chromosome() { public double fitness() { return 0; } }; Chromosome c2 = new Chromosome() { public double fitness() { return 10; } }; Chromosome c3 = new Chromosome() { public double fitness() { return 15; } };  ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> (); chromosomes.add(c1); chromosomes.add(c2); chromosomes.add(c3);  ListPopulation population = new ListPopulation(chromosomes,10) {  public Population nextGeneration() { // not important return null; } };  "<AssertPlaceHolder>"; }
getFittestChromosome() { // best so far Chromosome bestChromosome = this.chromosomes.get(0); for (Chromosome chromosome : this.chromosomes) { if (chromosome.compareTo(bestChromosome) > 0) { // better chromosome found bestChromosome = chromosome; } } return bestChromosome; }
[*] target: assertEquals(c3, population.getFittestChromosome())
[-] pred: org. junit. Assert. assertEquals ( c3, population. getFittestChromosome ( ) )
************************************
************************************
[+] input: dimension2() { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l)); EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {  // first expected cluster new EuclideanIntegerPoint(new int[] { -15,  3 }), new EuclideanIntegerPoint(new int[] { -15,  4 }), new EuclideanIntegerPoint(new int[] { -15,  5 }), new EuclideanIntegerPoint(new int[] { -14,  3 }), new EuclideanIntegerPoint(new int[] { -14,  5 }), new EuclideanIntegerPoint(new int[] { -13,  3 }), new EuclideanIntegerPoint(new int[] { -13,  4 }), new EuclideanIntegerPoint(new int[] { -13,  5 }),  // second expected cluster new EuclideanIntegerPoint(new int[] { -1,  0 }), new EuclideanIntegerPoint(new int[] { -1, -1 }), new EuclideanIntegerPoint(new int[] {  0, -1 }), new EuclideanIntegerPoint(new int[] {  1, -1 }), new EuclideanIntegerPoint(new int[] {  1, -2 }),  // third expected cluster new EuclideanIntegerPoint(new int[] { 13,  3 }), new EuclideanIntegerPoint(new int[] { 13,  4 }), new EuclideanIntegerPoint(new int[] { 14,  4 }), new EuclideanIntegerPoint(new int[] { 14,  7 }), new EuclideanIntegerPoint(new int[] { 16,  5 }), new EuclideanIntegerPoint(new int[] { 16,  6 }), new EuclideanIntegerPoint(new int[] { 17,  4 }), new EuclideanIntegerPoint(new int[] { 17,  7 })  }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 3, 10);  "<AssertPlaceHolder>"; boolean cluster1Found = false; boolean cluster2Found = false; boolean cluster3Found = false; for (Cluster<EuclideanIntegerPoint> cluster : clusters) { int[] center = cluster.getCenter().getPoint(); if (center[0] < 0) { cluster1Found = true; assertEquals(8, cluster.getPoints().size()); assertEquals(-14, center[0]); assertEquals( 4, center[1]); } else if (center[1] < 0) { cluster2Found = true; assertEquals(5, cluster.getPoints().size()); assertEquals( 0, center[0]); assertEquals(-1, center[1]); } else { cluster3Found = true; assertEquals(8, cluster.getPoints().size()); assertEquals(15, center[0]); assertEquals(5, center[1]); } } assertTrue(cluster1Found); assertTrue(cluster2Found); assertTrue(cluster3Found);  }
cluster(final Collection<T> points, final int k, final int maxIterations) { // create the initial clusters List<Cluster<T>> clusters = chooseInitialCenters(points, k, random); assignPointsToClusters(clusters, points);  // iterate through updating the centers until we're done final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations; for (int count = 0; count < max; count++) { boolean clusteringChanged = false; List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>(); for (final Cluster<T> cluster : clusters) { final T newCenter = cluster.getCenter().centroidOf(cluster.getPoints()); if (!newCenter.equals(cluster.getCenter())) { clusteringChanged = true; } newClusters.add(new Cluster<T>(newCenter)); } if (!clusteringChanged) { return clusters; } assignPointsToClusters(newClusters, points); clusters = newClusters; } return clusters; }
[*] target: assertEquals(3, clusters.size())
[-] pred: org. junit. Assert. assertEquals ( 3, clusters. size ( ) )
************************************
************************************
[+] input: getFirstLine() { // assign variables with test data String expectedLine = "First Line";  // allocate test objects StackTrace stackTrace = new StackTrace(expectedLine, null);  // execute methods to be tested String actualLine = stackTrace.getFirstLine();  // assign result Assert."<AssertPlaceHolder>"; }
getFirstLine() { return this.firstLine; }
[*] target: assertEquals(expectedLine, actualLine)
[-] pred: org. junit. Assert. assertEquals ( expectedLine, actualLine )
************************************
************************************
[+] input: testExampleFL8Ochiai() { // Run only on target release >= 5 Assume.assumeTrue(getCompilerVersion() >= 5);  // Setup config FlacocoConfig config = new FlacocoConfig(); config.setWorkspace(workspaceDir.getRoot().getAbsolutePath()); config.setTestRunnerVerbose(true); config.setProjectPath("./examples/exampleFL8NotMaven/"); config.setSrcJavaDir(Collections.singletonList("./examples/exampleFL8NotMaven/java")); config.setSrcTestDir(Collections.singletonList("./examples/exampleFL8NotMaven/test")); config.setBinJavaDir(Collections.singletonList("./examples/exampleFL8NotMaven/bin/classes")); config.setBinTestDir(Collections.singletonList("./examples/exampleFL8NotMaven/bin/test-classes")); config.setSpectrumFormula(SpectrumFormula.OCHIAI);  SpectrumRunner runner = new SpectrumRunner(config);  FlacocoResult result = runner.run();  for (Map.Entry<Location, Suspiciousness> entry : result.getDefaultSuspiciousnessMap().entrySet()) { System.out.println(entry); }  Map<Location, Suspiciousness> susp = result.getDefaultSuspiciousnessMap(); "<AssertPlaceHolder>";  // Line executed only by the failing assertEquals(1.0, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 15)).getScore(), 0);  // Line executed by a mix of failing and passing assertEquals(0.70, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 14)).getScore(), 0.01); assertEquals(0.57, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 12)).getScore(), 0.01);  // Lines executed by all test assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 10)).getScore(), 0); assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 5)).getScore(), 0); assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 6)).getScore(), 0); }
run() { FlacocoResult result = new FlacocoResult();  // Warn if system memory is lower than 4GiB long memorySize = ((com.sun.management.OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean()) .getTotalPhysicalMemorySize(); if (memorySize < 4294967296L) { logger.warn("System memory is lower than 4GiB. " + "Caution when running spectrum-based fault localization on large projects, as coverage computation require more than the available memory"); }  CoverageMatrix coverageMatrix = computeCoverageMatrix(); result.setFailingTests(coverageMatrix.getFailingTestCases()); result.setExecutedTests(coverageMatrix.getTests().keySet());  SpectrumSuspiciousComputation ssc = new SpectrumSuspiciousComputation(config); Map<Location, Suspiciousness> defaultMapping = ssc.calculateSuspicious(coverageMatrix, this.config.getSpectrumFormula().getFormula()); result.setDefaultSuspiciousnessMap(defaultMapping);  if (config.isComputeSpoonResults()) { result = new SpoonConverter(config).convertResult(result); }  return result; }
[*] target: assertEquals(6, susp.size())
[-] pred: org. junit. Assert. assertEquals ( 6, susp. size ( ) )
************************************
************************************
[+] input: testExampleFL9Ochiai() { // Run only on target release >= 5 Assume.assumeTrue(getCompilerVersion() >= 5);  // Setup config FlacocoConfig config = new FlacocoConfig(); config.setWorkspace(workspaceDir.getRoot().getAbsolutePath()); config.setTestRunnerVerbose(true); config.setProjectPath("./examples/exampleFL9NotMavenMultiple/"); config.setSrcJavaDir(Arrays.asList("./examples/exampleFL9NotMavenMultiple/java")); config.setSrcTestDir(Arrays.asList("./examples/exampleFL9NotMavenMultiple/test2", "./examples/exampleFL9NotMavenMultiple/test1")); config.setBinJavaDir(Arrays.asList("./examples/exampleFL9NotMavenMultiple/bin/classes")); config.setBinTestDir(Arrays.asList("./examples/exampleFL9NotMavenMultiple/bin/test-classes2", "./examples/exampleFL9NotMavenMultiple/bin/test-classes1")); config.setSpectrumFormula(SpectrumFormula.OCHIAI);  SpectrumRunner runner = new SpectrumRunner(config);  FlacocoResult result = runner.run();  for (Map.Entry<Location, Suspiciousness> entry : result.getDefaultSuspiciousnessMap().entrySet()) { System.out.println(entry); }  Map<Location, Suspiciousness> susp = result.getDefaultSuspiciousnessMap(); "<AssertPlaceHolder>";  // Line executed only by the failing assertEquals(1.0, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 15)).getScore(), 0);  // Line executed by a mix of failing and passing assertEquals(0.70, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 14)).getScore(), 0.01); assertEquals(0.57, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 12)).getScore(), 0.01);  // Lines executed by all test assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 10)).getScore(), 0); assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 5)).getScore(), 0); assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 6)).getScore(), 0); }
run() { FlacocoResult result = new FlacocoResult();  // Warn if system memory is lower than 4GiB long memorySize = ((com.sun.management.OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean()) .getTotalPhysicalMemorySize(); if (memorySize < 4294967296L) { logger.warn("System memory is lower than 4GiB. " + "Caution when running spectrum-based fault localization on large projects, as coverage computation require more than the available memory"); }  CoverageMatrix coverageMatrix = computeCoverageMatrix(); result.setFailingTests(coverageMatrix.getFailingTestCases()); result.setExecutedTests(coverageMatrix.getTests().keySet());  SpectrumSuspiciousComputation ssc = new SpectrumSuspiciousComputation(config); Map<Location, Suspiciousness> defaultMapping = ssc.calculateSuspicious(coverageMatrix, this.config.getSpectrumFormula().getFormula()); result.setDefaultSuspiciousnessMap(defaultMapping);  if (config.isComputeSpoonResults()) { result = new SpoonConverter(config).convertResult(result); }  return result; }
[*] target: assertEquals(6, susp.size())
[-] pred: org. junit. Assert. assertEquals ( 6, susp. size ( ) )
************************************
************************************
[+] input: Exception { final ExecutionContext<?> context = createDefaultExecutionContext(); final TableEnvironment tableEnv = context.getTableEnvironment(); final String[] expected = new String[] { "scalarudf", "tableudf", "aggregateudf" }; final String[] actual = tableEnv.listUserDefinedFunctions(); Arrays.sort(expected); Arrays.sort(actual); "<AssertPlaceHolder>"; }
getTableEnvironment() { return tableEnv; }
[*] target: assertArrayEquals(expected, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expected, actual )
************************************
************************************
[+] input: testShowCatalog() { ShowCatalogsOperation operation = new ShowCatalogsOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_CATALOGS_RESULT, new VarCharType(false, 15))) .data(Row.of("catalog1"), Row.of("default_catalog"), Row.of("simple-catalog")) .build(); "<AssertPlaceHolder>"; }
execute() { final TableEnvironment tableEnv = context.getTableEnvironment(); final List<String> catalogs = context.wrapClassLoader(() -> Arrays.asList(tableEnv.listCatalogs())); return OperationUtil.stringListToResultSet(catalogs, ConstantNames.SHOW_CATALOGS_RESULT); }
[*] target: assertEquals(expected, resultSet)
[-] pred: org. junit. Assert. assertEquals ( expected, resultSet )
************************************
************************************
[+] input: testShowCurrentCatalog() { context.getExecutionContext().getTableEnvironment().useCatalog("simple-catalog");  ShowCurrentCatalogOperation operation = new ShowCurrentCatalogOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_CURRENT_CATALOG_RESULT, new VarCharType(false, 14))) .data(Row.of("simple-catalog")) .build(); "<AssertPlaceHolder>"; }
execute() { final TableEnvironment tableEnv = context.getTableEnvironment(); return OperationUtil.singleStringToResultSet( context.wrapClassLoader(tableEnv::getCurrentCatalog), ConstantNames.SHOW_CURRENT_CATALOG_RESULT); }
[*] target: assertEquals(expected, resultSet)
[-] pred: org. junit. Assert. assertEquals ( expected, resultSet )
************************************
************************************
[+] input: testShowCurrentDatabase() { context.getExecutionContext().getTableEnvironment().useCatalog("catalog1"); context.getExecutionContext().getTableEnvironment().useDatabase("default");  ShowCurrentDatabaseOperation operation = new ShowCurrentDatabaseOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_CURRENT_DATABASE_RESULT, new VarCharType(false, 7))) .data(Row.of("default")) .build(); "<AssertPlaceHolder>"; }
execute() { final TableEnvironment tableEnv = context.getTableEnvironment(); return OperationUtil.singleStringToResultSet( context.wrapClassLoader(tableEnv::getCurrentDatabase), ConstantNames.SHOW_CURRENT_DATABASE_RESULT); }
[*] target: assertEquals(expected, resultSet)
[-] pred: org. junit. Assert. assertEquals ( expected, resultSet )
************************************
************************************
[+] input: testShowDatabase() { context.getExecutionContext().getTableEnvironment().useCatalog("catalog1");  ShowDatabasesOperation operation = new ShowDatabasesOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_DATABASES_RESULT, new VarCharType(false, 7))) .data(Row.of("default")) .build(); "<AssertPlaceHolder>"; }
execute() { final TableEnvironment tableEnv = context.getTableEnvironment(); final List<String> databases = context.wrapClassLoader(() -> Arrays.asList(tableEnv.listDatabases())); return OperationUtil.stringListToResultSet(databases, ConstantNames.SHOW_DATABASES_RESULT); }
[*] target: assertEquals(expected, resultSet)
[-] pred: org. junit. Assert. assertEquals ( expected, resultSet )
************************************
************************************
[+] input: testShowModule() { ShowModulesOperation operation = new ShowModulesOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_MODULES_RESULT, new VarCharType(false, 8))) .data(Row.of("core"), Row.of("mymodule"), Row.of("myhive"), Row.of("myhive2")) .build(); "<AssertPlaceHolder>"; }
execute() { final TableEnvironment tableEnv = context.getTableEnvironment(); final List<String> modules = context.wrapClassLoader(() -> Arrays.asList(tableEnv.listModules())); return OperationUtil.stringListToResultSet(modules, ConstantNames.SHOW_MODULES_RESULT); }
[*] target: assertEquals(expected, resultSet)
[-] pred: org. junit. Assert. assertEquals ( expected, resultSet )
************************************
************************************
[+] input: testShowTable() { ShowTablesOperation operation = new ShowTablesOperation(context); ResultSet resultSet = operation.execute();  ResultSet expected = ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns( ColumnInfo.create(ConstantNames.SHOW_TABLES_RESULT, new VarCharType(false, 15))) .data( Row.of("TableNumber1"), Row.of("TableNumber2"), Row.of("TableSourceSink"), Row.of("TestView1"), Row.of("TestView2")) .build();  "<AssertPlaceHolder>"; }
execute() { List<Row> rows = new ArrayList<>(); int maxNameLength = 1;  final TableEnvironment tableEnv = context.getTableEnvironment(); // listTables will return all tables and views for (String table : context.wrapClassLoader(() -> Arrays.asList(tableEnv.listTables()))) { rows.add(Row.of(table)); maxNameLength = Math.max(maxNameLength, table.length()); }  return ResultSet.builder() .resultKind(ResultKind.SUCCESS_WITH_CONTENT) .columns(ColumnInfo.create(ConstantNames.SHOW_TABLES_RESULT, new VarCharType(false, maxNameLength))) .data(rows) .build(); }
[*] target: assertEquals(expected, resultSet)
[-] pred: org. junit. Assert. assertEquals ( expected, resultSet )
************************************
************************************
[+] input: getUser() { User user = userMapper.selectByUsername("admin"); Assert."<AssertPlaceHolder>"; }
selectByUsername(@Param("username") String username);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: find() { List<AlarmTypeEnum> list = jobAlarmConfigService.findByJobId(1L); Assert."<AssertPlaceHolder>"; System.out.println(list); }
findByJobId(Long jobId);
[*] target: assertNotNull(list)
[-] pred: org. junit. Assert. assertNotNull ( list )
************************************
************************************
[+] input: findByJobIdList() { List<Long> list= Lists.newArrayList(); list.add(14L); list.add(11L); list.add(3L); Map<Long ,List<AlarmTypeEnum>>  map = jobAlarmConfigService.findByJobIdList(list); Assert."<AssertPlaceHolder>"; System.out.println(map); }
findByJobIdList(List<Long> jobIdList);
[*] target: assertNotNull(map)
[-] pred: org. junit. Assert. assertNotNull ( map )
************************************
************************************
[+] input: getJobConfigById() { JobConfigDTO jobConfigDTO = jobConfigService.getJobConfigById(1L); System.out.println(jobConfigDTO); Assert."<AssertPlaceHolder>"; }
getJobConfigById(Long id);
[*] target: assertNotNull(jobConfigDTO)
[-] pred: org. junit. Assert. assertNotNull ( jobConfigDTO )
************************************
************************************
[+] input: queryJobConfig() { JobConfigParam jobConfigParam=new JobConfigParam(); jobConfigParam.setPageNum(2); PageModel<JobConfigDTO> pageModel = jobConfigService.queryJobConfig(jobConfigParam); Assert."<AssertPlaceHolder>"; }
queryJobConfig(JobConfigParam jobConfigParam);
[*] target: assertNotNull(pageModel)
[-] pred: org. junit. Assert. assertNotNull ( pageModel )
************************************
************************************
[+] input: checkLogin() { String cookieId = userService.login("admin", "123456"); Assert."<AssertPlaceHolder>"; }
login(String userName, String password);
[*] target: assertNotNull(cookieId)
[-] pred: org. junit. Assert. assertNotNull ( cookieId )
************************************
************************************
[+] input: Exception { String fun = "create temporary function function1 as 'org.apache.fink.function.function1' language java"; List<SqlCreateFunction> list = service.sqlFunctionParser(fun); Assert."<AssertPlaceHolder>"; }
sqlFunctionParser(String funSql) throws Exception { List<SqlCreateFunction> result = new LinkedList<>(); SqlNodeList nodeList = SqlUtils.parseSql(funSql); for (SqlNode sqlNode : nodeList) { if (sqlNode instanceof SqlCreateFunction) { result.add((SqlCreateFunction) sqlNode); } } return result; }
[*] target: assertEquals(list.size(), 1)
[-] pred: org. junit. Assert. assertEquals ( list. size ( ), 1 )
************************************
************************************
[+] input: Exception { SingleValueFormulaContext context = new TestSingleValueFormulaContext(null, "Hi"); ContextualFormulaFieldInfo ffi = context.lookup("value"); Assert."<AssertPlaceHolder>"; Assert.assertEquals("Value", ffi.getName()); }
getDataType() { return columnType; }
[*] target: assertEquals(null, ffi.getDataType())
[-] pred: org. junit. Assert. assertEquals ( null, ffi. getDataType() )
************************************
************************************
[+] input: IOException { String path = "TestAdvice.yml"; String content = "---\n" + "Security review status (example):\n" + "  - advice: test1\n" + "    links: []\n" + "  - advice: test2\n" + "Static code analysis status (example):\n" + "  - advice: test3\n" + "    links:\n" + "      - name: link5\n" + "        url: https://test/5\n"; Files.write(Paths.get(path), content.getBytes()); try { AdviceContentYamlStorage storage = AdviceContentYamlStorage.loadFrom(path);  List<AdviceContent> advice = storage.adviceFor( SECURITY_REVIEW_DONE_EXAMPLE, OssAdviceContext.EMPTY_ADVICE_CONTEXT);  assertEquals(2, advice.size()); for (int i = 0; i < advice.size(); i++) { assertFalse(advice.get(i).text().isEmpty()); assertTrue(advice.get(i).links().isEmpty()); }  advice = storage.adviceFor(STATIC_CODE_ANALYSIS_DONE_EXAMPLE, EMPTY_OSS_CONTEXT); assertEquals(1, advice.size()); assertFalse(advice.get(0).text().isEmpty()); assertFalse(advice.get(0).links().isEmpty());  advice = storage.adviceFor(NUMBER_OF_COMMITS_LAST_MONTH_EXAMPLE, EMPTY_OSS_CONTEXT); "<AssertPlaceHolder>"; } finally { FileUtils.forceDeleteOnExit(new File(path)); } }
adviceFor(Feature<?> feature, AdviceContext context) throws MalformedURLException {  List<AdviceContent> adviceContents = new ArrayList<>(); for (RawAdviceContent rawAdvice : featureToContent.getOrDefault(feature.name(), emptyList())) { adviceContents.add(rawAdvice.transformFor(feature, context)); }  return adviceContents; }
[*] target: assertTrue(advice.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( advice. isEmpty ( ) )
************************************
************************************
[+] input: testClear() { GitHubDataCache<String> cache = new GitHubDataCache<>();  String data = "data to be cached"; GitHubProject project = new GitHubProject(new GitHubOrganization(data), data); cache.put(project, data); assertEquals(1, cache.size()); String cached = cache.get(project).orElseThrow(RuntimeException::new); assertEquals(data, cached);  // fill out the cache for (int i = 1, cacheSize = cache.size(); cacheSize < cache.maxSize(); cacheSize++, i++) { project = new GitHubProject(String.format("org%d", i), String.format("project%d", i)); data = String.format("data%d", i); cache.put(project, data); }  assertEquals(cache.size(), cache.maxSize());  cache.clear(); "<AssertPlaceHolder>"; }
size() { return entries.size(); }
[*] target: assertEquals(0, cache.size())
[-] pred: org. junit. Assert. assertEquals ( 0, cache. size ( ) )
************************************
************************************
[+] input: IOException { HasCompanySupport provider = new HasCompanySupport(fetcher); "<AssertPlaceHolder>"; }
supportedFeature() { return SUPPORTED_BY_COMPANY; }
[*] target: assertEquals(SUPPORTED_BY_COMPANY, provider.supportedFeature())
[-] pred: org. junit. Assert. assertEquals ( SUPPORTED_BY_COMPANY, provider. supportedFeature() )
************************************
************************************
[+] input: IOException { LgtmDataProvider provider = new LgtmDataProvider(fetcher); provider = spy(provider);  CloseableHttpClient httpClient = mock(CloseableHttpClient.class); when(provider.httpClient()).thenReturn(httpClient);  CloseableHttpResponse response = mock(CloseableHttpResponse.class); when(httpClient.execute(any())).thenReturn(response);  HttpEntity entity = mock(HttpEntity.class); when(response.getEntity()).thenReturn(entity);  GitHubProject project = new GitHubProject("org", "project");  GHCheckRun checkRun = mock(GHCheckRun.class); when(checkRun.getName()).thenReturn("LGTM analysis");  PagedIterator<GHCheckRun> checkRunPagedIterator = mock(PagedIterator.class); when(checkRunPagedIterator.hasNext()).thenReturn(true, false); when(checkRunPagedIterator.next()).thenReturn(checkRun);  PagedIterable<GHCheckRun> checkRunPagedIterable = mock(PagedIterable.class); when(checkRunPagedIterable.iterator()).thenReturn(checkRunPagedIterator);  GHCommit commit = mock(GHCommit.class); when(commit.getCheckRuns()).thenReturn(checkRunPagedIterable);  GHRepository repository = mock(GHRepository.class); when(fetcher.github().getRepository(anyString())).thenReturn(repository);  PagedIterator<GHCommit> commitPagedIterator = mock(PagedIterator.class); when(commitPagedIterator.hasNext()).thenReturn(true, false); when(commitPagedIterator.next()).thenReturn(commit);  PagedIterable<GHCommit> commitPagedIterable = mock(PagedIterable.class); when(commitPagedIterable.iterator()).thenReturn(commitPagedIterator);  when(repository.listCommits()).thenReturn(commitPagedIterable);  try (InputStream content = getClass().getResourceAsStream("LgtmProjectInfoReply.json")) { when(entity.getContent()).thenReturn(content);  ValueHashSet values = new ValueHashSet(); "<AssertPlaceHolder>";  provider.set(NoUserCallback.INSTANCE); provider.update(project, values);  assertEquals(2, values.size()); assertTrue(values.has(USES_LGTM_CHECKS)); assertTrue(values.of(USES_LGTM_CHECKS).isPresent()); assertFalse(values.of(USES_LGTM_CHECKS).get().isUnknown()); assertEquals(USES_LGTM_CHECKS.value(true), values.of(USES_LGTM_CHECKS).get());  assertTrue(values.has(WORST_LGTM_GRADE)); assertTrue(values.of(WORST_LGTM_GRADE).isPresent()); assertFalse(values.of(WORST_LGTM_GRADE).get().isUnknown()); assertEquals(WORST_LGTM_GRADE.value(LgtmGrade.C), values.of(WORST_LGTM_GRADE).get()); } }
httpClient() { return HttpClients.createDefault(); }
[*] target: assertEquals(0, values.size())
[-] pred: org. junit. Assert. assertEquals ( 0, values. size ( ) )
************************************
************************************
[+] input: IOException { LgtmDataProvider provider = new LgtmDataProvider(fetcher); provider = spy(provider);  CloseableHttpClient httpClient = mock(CloseableHttpClient.class); when(provider.httpClient()).thenReturn(httpClient);  CloseableHttpResponse response = mock(CloseableHttpResponse.class); when(httpClient.execute(any())).thenReturn(response);  HttpEntity entity = mock(HttpEntity.class); when(response.getEntity()).thenReturn(entity);  GitHubProject project = new GitHubProject("org", "project");  PagedIterator<GHCheckRun> checkRunPagedIterator = mock(PagedIterator.class); when(checkRunPagedIterator.hasNext()).thenReturn(false);  PagedIterable<GHCheckRun> checkRunPagedIterable = mock(PagedIterable.class); when(checkRunPagedIterable.iterator()).thenReturn(checkRunPagedIterator);  GHCommit commit = mock(GHCommit.class); when(commit.getCheckRuns()).thenReturn(checkRunPagedIterable);  GHRepository repository = mock(GHRepository.class); when(fetcher.github().getRepository(anyString())).thenReturn(repository);  PagedIterator<GHCommit> commitPagedIterator = mock(PagedIterator.class); when(commitPagedIterator.hasNext()).thenReturn(true, false); when(commitPagedIterator.next()).thenReturn(commit);  PagedIterable<GHCommit> commitPagedIterable = mock(PagedIterable.class); when(commitPagedIterable.iterator()).thenReturn(commitPagedIterator);  when(repository.listCommits()).thenReturn(commitPagedIterable);  try (InputStream content = getClass().getResourceAsStream("LgtmProjectDoesNotExistReply.json")) {  when(entity.getContent()).thenReturn(content);  ValueHashSet values = new ValueHashSet(); "<AssertPlaceHolder>";  provider.set(NoUserCallback.INSTANCE); provider.update(project, values);  assertEquals(2, values.size()); assertTrue(values.has(USES_LGTM_CHECKS)); assertTrue(values.of(USES_LGTM_CHECKS).isPresent()); assertFalse(values.of(USES_LGTM_CHECKS).get().isUnknown()); assertEquals(USES_LGTM_CHECKS.value(false), values.of(USES_LGTM_CHECKS).get());  assertTrue(values.has(WORST_LGTM_GRADE)); assertTrue(values.of(WORST_LGTM_GRADE).isPresent()); assertTrue(values.of(WORST_LGTM_GRADE).get().isUnknown()); } }
httpClient() { return HttpClients.createDefault(); }
[*] target: assertEquals(0, values.size())
[-] pred: org. junit. Assert. assertEquals ( 0, values. size ( ) )
************************************
************************************
[+] input: IOException { final SubjectValueCache cache = new SubjectValueCache();  Map<String, Long> languagesMap = new HashMap<>(); languagesMap.put("Java", 42L); languagesMap.put("Super language", 1001L);  final GHRepository repository = mock(GHRepository.class); when(repository.listLanguages()).thenReturn(languagesMap);  final GitHubDataFetcher fetcher = mock(GitHubDataFetcher.class); when(fetcher.repositoryFor(any())).thenReturn(repository);  ProgrammingLanguages programmingLanguagesProvider = new ProgrammingLanguages(fetcher); programmingLanguagesProvider.set(cache); programmingLanguagesProvider = spy(programmingLanguagesProvider);  PackageManagement provider = new PackageManagement(fetcher); provider.set(cache); provider = spy(provider); when(provider.languagesProvider()).thenReturn(programmingLanguagesProvider);  GitHubProject project = new GitHubProject("org", "test");  Languages languages = provider.languages(project); "<AssertPlaceHolder>"; assertEquals(2, languages.size()); assertTrue(languages.get().contains(JAVA)); assertTrue(languages.get().contains(OTHER)); }
languages(GitHubProject project) throws IOException { ValueSet values = new ValueHashSet(); languagesProvider().update(project, values);  Optional<Value<Languages>> something = values.of(LANGUAGES); if (!something.isPresent()) { return Languages.empty(); }  Value<Languages> value = something.get(); return value.get(); }
[*] target: assertNotNull(languages)
[-] pred: org. junit. Assert. assertNotNull ( languages )
************************************
************************************
[+] input: IOException {  UseReuseDataProvider provider = new UseReuseDataProvider(fetcher); provider.configure(IOUtils.toInputStream( "---\n" + "repositoryExceptions: https://github.com/org/test\n", "UTF-8")); ValueSet retrievedValues = provider.fetchValuesFor(PROJECT);  Value<Boolean> usesReuseValue = retrievedValues.of(USES_REUSE) .orElseThrow(() -> new Error( format("Could not find an expected feature: %s", USES_REUSE.name()))); "<AssertPlaceHolder>"; Value<Boolean> readmeHasReuseValue = retrievedValues.of(README_HAS_REUSE_INFO) .orElseThrow(() -> new Error( format("Could not find an expected feature: %s", README_HAS_REUSE_INFO.name()))); assertTrue(readmeHasReuseValue.get()); Value<Boolean> hasReuseLicensesValue = retrievedValues.of(HAS_REUSE_LICENSES) .orElseThrow(() -> new Error( format("Could not find an expected feature: %s", HAS_REUSE_LICENSES.name()))); assertTrue(hasReuseLicensesValue.get()); Value<Boolean> isRegisteredValue = retrievedValues.of(REGISTERED_IN_REUSE) .orElseThrow(() -> new Error( format("Could not find an expected feature: %s", REGISTERED_IN_REUSE.name()))); assertTrue(isRegisteredValue.get()); Value<Boolean> isCompliantValue = retrievedValues.of(IS_REUSE_COMPLIANT) .orElseThrow(() -> new Error( format("Could not find an expected feature: %s", IS_REUSE_COMPLIANT.name()))); assertTrue(isCompliantValue.get());  }
fetchValuesFor(GitHubProject project) throws IOException { logger.info("Figuring out how the project uses REUSE ...");  // Some repositories apply other copyright annotations and are well-known exceptions. // Those ones will reported as OK by this data provider. if (this.repositoryExceptionUrls.contains(project.toString())) { return ValueHashSet.from( USES_REUSE.value(true), README_HAS_REUSE_INFO.value(true), HAS_REUSE_LICENSES.value(true), REGISTERED_IN_REUSE.value(true), IS_REUSE_COMPLIANT.value(true)); }  ValueSet values = ValueHashSet.from( useReuse(project), readmeHasReuseInfo(project), hasReuseLicenses(project)); values.update(reuseInfo(project)); return values; }
[*] target: assertTrue(usesReuseValue.get())
[-] pred: org. junit. Assert. assertTrue ( usesReuseValue. get ( ) )
************************************
************************************
[+] input: testOssSecurityRatingIsImmutable() { Rating rating = RatingRepository.INSTANCE.rating(OssSecurityRating.class); "<AssertPlaceHolder>"; ImmutabilityChecker checker = new ImmutabilityChecker(); rating.accept(checker); assertTrue(checker.allImmutable()); }
rating(Class<T> clazz) { Objects.requireNonNull(clazz, "You just gave me a null instead of class!");  Rating rating = ratings.get(clazz); if (rating == null) { throw new IllegalArgumentException( String.format("Oh no! Could not find %s", clazz.getCanonicalName())); }  return clazz.cast(rating); }
[*] target: assertNotNull(rating)
[-] pred: org. junit. Assert. assertNotNull ( rating )
************************************
************************************
[+] input: testValue() { EnumFeature<TestEnum> feature = new EnumFeature<>(TestEnum.class, "test"); EnumValue<TestEnum> value = feature.value(TestEnum.A); "<AssertPlaceHolder>"; assertSame(feature, value.feature()); assertSame(TestEnum.A, value.get()); }
value(T object) { return new EnumValue<>(this, object); }
[*] target: assertNotNull(value)
[-] pred: org. junit. Assert. assertNotNull ( value )
************************************
************************************
[+] input: testParseValid() { EnumFeature<TestEnum> feature = new EnumFeature<>(TestEnum.class, "test"); EnumValue<TestEnum> value = feature.parse("A"); "<AssertPlaceHolder>"; assertSame(feature, value.feature()); assertSame(TestEnum.A, value.get()); }
parse(String string) { return value(Enum.valueOf(enumClass, string)); }
[*] target: assertNotNull(value)
[-] pred: org. junit. Assert. assertNotNull ( value )
************************************
************************************
[+] input: testParseInvalid() { EnumFeature<TestEnum> feature = new EnumFeature<>(TestEnum.class, "test"); EnumValue<TestEnum> value = feature.parse("D"); "<AssertPlaceHolder>"; assertSame(feature, value.feature()); assertSame(TestEnum.A, value.get()); }
parse(String string) { return value(Enum.valueOf(enumClass, string)); }
[*] target: assertNotNull(value)
[-] pred: org. junit. Assert. assertNotNull ( value )
************************************
************************************
[+] input: testEqualsAndHashCode() { EnumFeature<TestEnum> one = new EnumFeature<>(TestEnum.class, "test"); assertEquals(one, one);  EnumFeature<TestEnum> two = new EnumFeature<>(TestEnum.class, "test"); assertEquals(one, two); "<AssertPlaceHolder>";  EnumFeature<TestEnum> three = new EnumFeature<>(TestEnum.class, "another"); assertNotEquals(one, three);  EnumFeature<AnotherEnum> four = new EnumFeature<>(AnotherEnum.class, "name"); assertNotEquals(one, four); }
hashCode() { return Objects.hash(super.hashCode(), enumClass); }
[*] target: assertEquals(one.hashCode(), two.hashCode())
[-] pred: org. junit. Assert. assertEquals ( one. hashCode ( ), two. hashCode ( ) )
************************************
************************************
[+] input: IOException { Set<Value<?>> values = new HashSet<>(); values.add(new IntegerValue(ExampleFeatures.NUMBER_OF_COMMITS_LAST_MONTH_EXAMPLE, 1)); Interval expectedScore = DoubleInterval.init().from(4.0).to(6.4).closed().make(); StandardTestVector vector = new StandardTestVector( values, expectedScore, SecurityLabelExample.OKAY, "test");  byte[] bytes = Yaml.toBytes(vector); assertNotNull(bytes); assertTrue(bytes.length > 0); StandardTestVector clone = Yaml.read(bytes, StandardTestVector.class); assertEquals(vector, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), values); }
[*] target: assertEquals(vector.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( vector. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: testEqualsAndHashCode() { NotApplicableLabel one = new NotApplicableLabel(); NotApplicableLabel two = new NotApplicableLabel(); assertEquals(one, one); assertTrue(one.equals(two) && two.equals(one)); "<AssertPlaceHolder>"; }
hashCode() { return 42; }
[*] target: assertEquals(one.hashCode(), two.hashCode())
[-] pred: org. junit. Assert. assertEquals ( one. hashCode(), two. hashCode() )
************************************
************************************
[+] input: equalsAndHashCode() { Score one = new TestAverageCompositeScore(); Score two = new TestAverageCompositeScore(); assertEquals(one, two); "<AssertPlaceHolder>"; assertNotEquals(null, one); assertEquals(one, one); }
hashCode() { return Objects.hash(super.hashCode(), subScores); }
[*] target: assertEquals(one.hashCode(), two.hashCode())
[-] pred: org. junit. Assert. assertEquals ( one. hashCode(), two. hashCode() )
************************************
************************************
[+] input: testEqualsAndHashCode() { Score one = new WeightedScoreImpl(); Score two = new WeightedScoreImpl(); assertEquals(one, two); "<AssertPlaceHolder>"; assertNotEquals(null, one); assertEquals(one, one); }
hashCode() { return Objects.hash(super.hashCode(), subScores, weights); }
[*] target: assertEquals(one.hashCode(), two.hashCode())
[-] pred: org. junit. Assert. assertEquals ( one. hashCode(), two. hashCode() )
************************************
************************************
[+] input: testEqualsAndHashCode() { GitHubOrganization firstOrg = new GitHubOrganization("first"); GitHubOrganization theSameOrg = new GitHubOrganization("first"); assertTrue(firstOrg.equals(theSameOrg) && theSameOrg.equals(firstOrg)); "<AssertPlaceHolder>";  GitHubOrganization anotherOrg = new GitHubOrganization("another"); assertNotEquals(anotherOrg, firstOrg); }
hashCode() { return Objects.hash(super.hashCode(), name); }
[*] target: assertEquals(firstOrg.hashCode(), theSameOrg.hashCode())
[-] pred: org. junit. Assert. assertEquals ( firstOrg. hashCode ( ), theSameOrg. hashCode ( ) )
************************************
************************************
[+] input: IOException { GitHubOrganization org = new GitHubOrganization("test"); byte[] bytes = Json.toBytes(org); assertNotNull(bytes); assertTrue(bytes.length > 0); GitHubOrganization clone = Json.read(bytes, GitHubOrganization.class); assertNotNull(clone); assertEquals(org, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), name); }
[*] target: assertEquals(org.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( org. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { GitHubOrganization apache = new GitHubOrganization("apache"); GitHubProject project = new GitHubProject(apache, "nifi"); project.set( new RatingValue( new ScoreValue(ExampleScores.SECURITY_SCORE_EXAMPLE), SecurityLabelExample.OKAY)); byte[] bytes = Json.toBytes(project); assertNotNull(bytes); assertTrue(bytes.length > 0); GitHubProject clone = Json.read(bytes, GitHubProject.class); assertNotNull(clone); assertEquals(project, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), organization, name); }
[*] target: assertEquals(project.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( project. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { ArtifactVersions versions = new ArtifactVersions( new ArtifactVersion("1.0.0", LocalDateTime.now().minusDays(30)), new ArtifactVersion("1.1.0", LocalDateTime.now().minusDays(20))); ArtifactVersions clone = Json.read(Json.toBytes(versions), ArtifactVersions.class); assertTrue(versions.equals(clone) && clone.equals(versions)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(elements); }
[*] target: assertEquals(versions.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( versions. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { ArtifactVersions versions = new ArtifactVersions( new ArtifactVersion("something", LocalDateTime.now().minusDays(30)), new ArtifactVersion("something else", LocalDateTime.now().minusDays(20))); ArtifactVersions clone = Yaml.read(Yaml.toBytes(versions), ArtifactVersions.class); assertTrue(versions.equals(clone) && clone.equals(versions)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(elements); }
[*] target: assertEquals(versions.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( versions. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { ArtifactVersion version = new ArtifactVersion("2.0.2", LocalDateTime.now()); ArtifactVersion clone = Json.read(Json.toBytes(version), ArtifactVersion.class); assertTrue(version.equals(clone) && clone.equals(version)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(version, releaseDate); }
[*] target: assertEquals(version.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( version. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { ArtifactVersion version = new ArtifactVersion("MIGHTY-1.2", LocalDateTime.now()); ArtifactVersion clone = Yaml.read(Yaml.toBytes(version), ArtifactVersion.class); assertTrue(version.equals(clone) && clone.equals(version)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(version, releaseDate); }
[*] target: assertEquals(version.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( version. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { BooleanValue value = new BooleanValue(FEATURE, false); BooleanValue clone = Yaml.read(Yaml.toBytes(value), BooleanValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), flag); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { DateValue dateValue = new DateValue(new DateFeature("test"), new Date()); byte[] bytes = Json.toBytes(dateValue); assertNotNull(bytes); assertTrue(bytes.length > 0);  DateValue clone = Json.read(bytes, DateValue.class); assertNotNull(clone); assertEquals(dateValue, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), date); }
[*] target: assertEquals(dateValue.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( dateValue. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { DoubleValue value = new DoubleValue(new DoubleFeature("test"), 10.1); byte[] bytes = Json.toBytes(value); assertNotNull(bytes); assertTrue(bytes.length > 0);  DoubleValue clone = Json.read(bytes, DoubleValue.class); assertNotNull(clone); assertEquals(value, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), number); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { EnumFeature<TestEnum> feature = new EnumFeature<>(TestEnum.class, "feature"); EnumValue<TestEnum> a = feature.value(TestEnum.A); byte[] bytes = Json.toBytes(a); assertNotNull(bytes); assertTrue(bytes.length > 0);  Object clone = Json.read(bytes, EnumValue.class); assertNotNull(clone); assertEquals(a, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), value); }
[*] target: assertEquals(a.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( a. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { IntegerValue integerValue = new IntegerValue(new PositiveIntegerFeature("test"), 10); byte[] bytes = Json.toBytes(integerValue); assertNotNull(bytes); assertTrue(bytes.length > 0);  IntegerValue clone = Json.read(bytes, IntegerValue.class); assertNotNull(clone); assertEquals(integerValue, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), number); }
[*] target: assertEquals(integerValue.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( integerValue. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: testEqualsAndHashCode() { Languages one = Languages.of(C, PYTHON); assertEquals(one, one);  Languages two = Languages.of(PYTHON, C); assertTrue(one.equals(two) && two.equals(one)); "<AssertPlaceHolder>";  Languages three = Languages.of(JAVA, C); assertNotEquals(one, three); assertNotEquals(two, three); }
hashCode() { return Objects.hash(elements); }
[*] target: assertEquals(one.hashCode(), two.hashCode())
[-] pred: org. junit. Assert. assertEquals ( one. hashCode(), two. hashCode() )
************************************
************************************
[+] input: IOException { LanguagesFeature feature = new LanguagesFeature("test"); LanguagesValue value = new LanguagesValue(feature, new Languages(Language.JAVA, Language.C)); LanguagesValue clone = Json.read(Json.toBytes(value), LanguagesValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), languages); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { LgtmGradeFeature feature = new LgtmGradeFeature("feature"); LgtmGradeValue a = feature.value(LgtmGrade.A_PLUS); byte[] bytes = Json.toBytes(a); assertNotNull(bytes); assertTrue(bytes.length > 0);  Object clone = Json.read(bytes, LgtmGradeValue.class); assertNotNull(clone); assertEquals(a, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), value); }
[*] target: assertEquals(a.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( a. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: testEqualsAndHashCode() { OwaspDependencyCheckCvssThresholdValue one = new OwaspDependencyCheckCvssThresholdValue(FEATURE, 1.23, true); assertEquals(one, one);  OwaspDependencyCheckCvssThresholdValue two = new OwaspDependencyCheckCvssThresholdValue(FEATURE, 1.23, true); assertEquals(one, two); "<AssertPlaceHolder>";  OwaspDependencyCheckCvssThresholdValue three = new OwaspDependencyCheckCvssThresholdValue(FEATURE, 2.34, true); assertNotEquals(one, three);  OwaspDependencyCheckCvssThresholdValue four = new OwaspDependencyCheckCvssThresholdValue(FEATURE, 1.23, false); assertNotEquals(one, four);  assertNotEquals(three, four); }
hashCode() { return Objects.hash(super.hashCode(), specified); }
[*] target: assertEquals(one.hashCode(), two.hashCode())
[-] pred: org. junit. Assert. assertEquals ( one. hashCode(), two. hashCode() )
************************************
************************************
[+] input: IOException { OwaspDependencyCheckCvssThresholdValue value = FEATURE.value(5.7); OwaspDependencyCheckCvssThresholdValue clone = Json.read( Json.toBytes(value), OwaspDependencyCheckCvssThresholdValue.class); assertEquals(value, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), specified); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { PackageManagersFeature feature = new PackageManagersFeature("test"); PackageManagersValue value = new PackageManagersValue( feature, new PackageManagers(PackageManager.MAVEN, PackageManager.OTHER)); PackageManagersValue clone = Json.read(Json.toBytes(value), PackageManagersValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), packageManagers); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { SecurityReview review = new SecurityReview(TEST_REVIEW_DATE, 0.0); SecurityReview clone = Yaml.read(Json.toBytes(review), SecurityReview.class); assertTrue(review.equals(clone) && clone.equals(review)); assertEquals(review.hashCode(), clone.hashCode());  review = new SecurityReview(TEST_REVIEW_DATE, null); clone = Yaml.read(Json.toBytes(review), SecurityReview.class); assertTrue(review.equals(clone) && clone.equals(review)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(date, changes); }
[*] target: assertEquals(review.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( review. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { StringFeature feature = new StringFeature("test"); StringValue value = new StringValue(feature, "2.3.3"); StringValue clone = Json.read(Json.toBytes(value), StringValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), content); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { VulnerabilitiesValue vulnerabilityValue = new VulnerabilitiesValue( VULNERABILITIES_IN_PROJECT, new Vulnerabilities( newVulnerability("https://bugtracker/1").make(), newVulnerability("https://bugtracker/2").make())); byte[] bytes = Json.toBytes(vulnerabilityValue); assertNotNull(bytes); assertTrue(bytes.length > 0); String content = new String(bytes); assertTrue(content.contains("https://bugtracker/1")); assertTrue(content.contains("https://bugtracker/2")); VulnerabilitiesValue clone = Json.read(bytes, VulnerabilitiesValue.class); assertEquals(vulnerabilityValue, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), vulnerabilities); }
[*] target: assertEquals(vulnerabilityValue.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( vulnerabilityValue. hashCode ( ), clone. hashCode() )
************************************
************************************
[+] input: IOException { Vulnerability vulnerability = createBasicVulnerability(7.1, "2.3.4", "2.4.1"); Vulnerability clone = Json.read(Json.toBytes(vulnerability), Vulnerability.class); assertEquals(vulnerability, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hashCode(id); }
[*] target: assertEquals(vulnerability.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( vulnerability. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { Vulnerability vulnerability = createBasicVulnerability(7.1, "2.3.4", "2.4.1"); Vulnerability clone = Yaml.read(Yaml.toBytes(vulnerability), Vulnerability.class); assertEquals(vulnerability, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hashCode(id); }
[*] target: assertEquals(vulnerability.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( vulnerability. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: testMakeImmutable() { ScoreWeights weights = ScoreWeights.createFor( PROJECT_ACTIVITY_SCORE_EXAMPLE, SECURITY_TESTING_SCORE_EXAMPLE); weights.makeImmutable(); "<AssertPlaceHolder>"; }
isImmutable() { for (Weight weight : values.values()) { if (!weight.isImmutable()) { return false; } } return true; }
[*] target: assertTrue(weights.isImmutable())
[-] pred: org. junit. Assert. assertTrue ( weights. isImmutable() )
************************************
************************************
[+] input: IOException { Files.write(CONFIG_PATH, RULE_IDS.getBytes()); try { RatingValue ratingValue = RATING.calculate(allRulesPassed()); assertEquals(OssRulesOfPlayLabel.PASSED, ratingValue.label()); OssRulesOfPlayRatingMarkdownFormatter formatter = new OssRulesOfPlayRatingMarkdownFormatter(CONFIG_PATH, new OssRulesOfPlayAdvisor()); String text = formatter.print(ratingValue, emptyList()); "<AssertPlaceHolder>"; assertFalse(text.isEmpty()); String lowerCaseText = text.toLowerCase(); assertTrue(lowerCaseText.contains("status")); assertTrue(lowerCaseText.contains("pass")); assertFalse(lowerCaseText.contains("fail")); assertFalse(lowerCaseText.contains("unclear")); assertFalse(lowerCaseText.contains("unknown")); assertFalse(lowerCaseText.contains("explanation")); checkRuleIds(text); } finally { FileUtils.forceDeleteOnExit(CONFIG_PATH.toFile()); } }
print(RatingValue ratingValue, List<Advice> advice) { List<FormattedRule> violations = formatted(violationsIn(ratingValue), advice); List<FormattedRule> warnings = formatted(warningsIn(ratingValue), advice); List<FormattedRule> passedRules = formatted(passedRulesIn(ratingValue), advice); List<FormattedRule> unclearRules = formatted(unclearRulesIn(ratingValue), advice);  return template .replace("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%STATUS%", formatted(ratingValue.label())) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%VIOLATED_RULES%", makeListFrom(violations, "Violated rules")) .replace("%WARNINGS%", makeListFrom(warnings, "Warnings")) .replace("%PASSED_RULES%", makeListFrom(passedRules, "Passed rules")) .replace("%UNCLEAR_RULES%", makeListFrom(unclearRules, "Unclear")) .replace("%ADVICE%", makeAdviceFrom(violations, warnings, passedRules, unclearRules)); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: IOException { Files.write(CONFIG_PATH, RULE_IDS.getBytes()); try { ValueSet values = allRulesPassed(); values.update(OssRulesOfPlayScore.RECOMMENDED_FALSE.iterator().next().value(true)); RatingValue ratingValue = RATING.calculate(values); assertEquals(OssRulesOfPlayLabel.PASSED_WITH_WARNING, ratingValue.label()); OssRulesOfPlayRatingMarkdownFormatter formatter = new OssRulesOfPlayRatingMarkdownFormatter(CONFIG_PATH, new OssRulesOfPlayAdvisor()); String text = formatter.print(ratingValue, emptyList()); "<AssertPlaceHolder>"; assertFalse(text.isEmpty()); String lowerCaseText = text.toLowerCase(); assertTrue(lowerCaseText.contains("status")); assertTrue(lowerCaseText.contains("pass")); assertTrue(lowerCaseText.contains("warning")); assertFalse(lowerCaseText.contains("fail")); assertFalse(lowerCaseText.contains("unclear")); assertFalse(lowerCaseText.contains("unknown")); checkRuleIds(text); } finally { FileUtils.forceDeleteOnExit(CONFIG_PATH.toFile()); } }
print(RatingValue ratingValue, List<Advice> advice) { List<FormattedRule> violations = formatted(violationsIn(ratingValue), advice); List<FormattedRule> warnings = formatted(warningsIn(ratingValue), advice); List<FormattedRule> passedRules = formatted(passedRulesIn(ratingValue), advice); List<FormattedRule> unclearRules = formatted(unclearRulesIn(ratingValue), advice);  return template .replace("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%STATUS%", formatted(ratingValue.label())) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%VIOLATED_RULES%", makeListFrom(violations, "Violated rules")) .replace("%WARNINGS%", makeListFrom(warnings, "Warnings")) .replace("%PASSED_RULES%", makeListFrom(passedRules, "Passed rules")) .replace("%UNCLEAR_RULES%", makeListFrom(unclearRules, "Unclear")) .replace("%ADVICE%", makeAdviceFrom(violations, warnings, passedRules, unclearRules)); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: IOException { Files.write(CONFIG_PATH, RULE_IDS.getBytes()); try { ValueSet values = allRulesPassed(); values.update(OssRulesOfPlayScore.EXPECTED_FALSE.iterator().next().value(true)); RatingValue ratingValue = RATING.calculate(values); assertEquals(OssRulesOfPlayLabel.FAILED, ratingValue.label()); OssRulesOfPlayRatingMarkdownFormatter formatter = new OssRulesOfPlayRatingMarkdownFormatter(CONFIG_PATH, new OssRulesOfPlayAdvisor()); String text = formatter.print(ratingValue, emptyList()); "<AssertPlaceHolder>"; assertFalse(text.isEmpty()); String lowerCaseText = text.toLowerCase(); assertTrue(lowerCaseText.contains("status")); assertTrue(lowerCaseText.contains("fail")); assertTrue(lowerCaseText.contains("violated")); assertFalse(lowerCaseText.contains("unclear")); assertFalse(lowerCaseText.contains("unknown")); assertFalse(lowerCaseText.contains("explanation")); checkRuleIds(text); } finally { FileUtils.forceDeleteOnExit(CONFIG_PATH.toFile()); } }
print(RatingValue ratingValue, List<Advice> advice) { List<FormattedRule> violations = formatted(violationsIn(ratingValue), advice); List<FormattedRule> warnings = formatted(warningsIn(ratingValue), advice); List<FormattedRule> passedRules = formatted(passedRulesIn(ratingValue), advice); List<FormattedRule> unclearRules = formatted(unclearRulesIn(ratingValue), advice);  return template .replace("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%STATUS%", formatted(ratingValue.label())) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%VIOLATED_RULES%", makeListFrom(violations, "Violated rules")) .replace("%WARNINGS%", makeListFrom(warnings, "Warnings")) .replace("%PASSED_RULES%", makeListFrom(passedRules, "Passed rules")) .replace("%UNCLEAR_RULES%", makeListFrom(unclearRules, "Unclear")) .replace("%ADVICE%", makeAdviceFrom(violations, warnings, passedRules, unclearRules)); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: IOException { Files.write(CONFIG_PATH, RULE_IDS.getBytes()); try { RatingValue ratingValue = RATING.calculate(allUnknown(RATING.allFeatures())); assertEquals(OssRulesOfPlayLabel.UNCLEAR, ratingValue.label()); OssRulesOfPlayRatingMarkdownFormatter formatter = new OssRulesOfPlayRatingMarkdownFormatter(CONFIG_PATH, new OssRulesOfPlayAdvisor()); String text = formatter.print(ratingValue, emptyList()); "<AssertPlaceHolder>"; assertFalse(text.isEmpty()); String lowerCaseText = text.toLowerCase(); assertTrue(lowerCaseText.contains("status")); assertTrue(lowerCaseText.contains("unclear")); assertFalse(lowerCaseText.contains("pass")); assertFalse(lowerCaseText.contains("fail")); checkRuleIds(text); } finally { FileUtils.forceDeleteOnExit(CONFIG_PATH.toFile()); } }
print(RatingValue ratingValue, List<Advice> advice) { List<FormattedRule> violations = formatted(violationsIn(ratingValue), advice); List<FormattedRule> warnings = formatted(warningsIn(ratingValue), advice); List<FormattedRule> passedRules = formatted(passedRulesIn(ratingValue), advice); List<FormattedRule> unclearRules = formatted(unclearRulesIn(ratingValue), advice);  return template .replace("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%STATUS%", formatted(ratingValue.label())) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%VIOLATED_RULES%", makeListFrom(violations, "Violated rules")) .replace("%WARNINGS%", makeListFrom(warnings, "Warnings")) .replace("%PASSED_RULES%", makeListFrom(passedRules, "Passed rules")) .replace("%UNCLEAR_RULES%", makeListFrom(unclearRules, "Unclear")) .replace("%ADVICE%", makeAdviceFrom(violations, warnings, passedRules, unclearRules)); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: testWithDefaultTemplate() { RatingValue ratingValue = RATING.calculate(TEST_VALUES); PROJECT.set(ratingValue);  OssSecurityRatingMarkdownFormatter formatter = new OssSecurityRatingMarkdownFormatter(new OssSecurityGithubAdvisor()); String text = formatter.print(PROJECT);  "<AssertPlaceHolder>"; assertFalse(text.isEmpty()); }
print(Subject subject) { if (!subject.ratingValue().isPresent()) { return StringUtils.EMPTY; }  MarkdownElement advice = markdownAdviceFor(subject); RatingValue ratingValue = subject.ratingValue().get(); ScoreValue scoreValue = ratingValue.scoreValue();  return template .replaceAll("%MAX_SCORE%", formatted(Score.MAX)) .replaceAll("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%SCORE_VALUE%", formatted(scoreValue.get())) .replace("%RATING_LABEL%", ratingValue.label().name()) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%MAIN_SCORE_NAME%", scoreValue.score().name().toLowerCase()) .replace("%MAIN_SCORE_VALUE_DETAILS%", highLevelDescriptionOf(scoreValue).make()) .replace("%MAIN_SCORE_DESCRIPTION%", scoreValue.score().description()) .replace("%MAIN_SCORE_EXPLANATION%", explanationOf(scoreValue).make()) .replace("%SUB_SCORE_DETAILS%", descriptionOfSubScoresIn(scoreValue).make()) .replace("%ADVICE%", advice.make()) .replace("%INFO_ABOUT_VULNERABILITIES%", infoAboutVulnerabilitiesIn(scoreValue).make()); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: testWithCustomTemplate() {  // Needed to ensure that decimal points are exactly as expected below... Locale.setDefault(new Locale("en", "US"));  RatingValue ratingValue = RATING.calculate(TEST_VALUES); GitHubProject project = new GitHubProject("org", "test"); project.set(ratingValue);  String template = "%RATING_LABEL%|%SCORE_VALUE%|%MAX_SCORE%|%CONFIDENCE_LABEL%" + "|%CONFIDENCE_VALUE%|%MAX_CONFIDENCE%|%MAIN_SCORE_NAME%" + "|%MAIN_SCORE_DESCRIPTION%|%MAIN_SCORE_EXPLANATION%";  OssSecurityRatingMarkdownFormatter formatter = new OssSecurityRatingMarkdownFormatter(new OssSecurityGithubAdvisor(), template); String text = formatter.print(project);  "<AssertPlaceHolder>"; assertEquals("BAD|3.4|10.0|Max|10.0|10.0|security score for open-source projects||", text); }
print(Subject subject) { if (!subject.ratingValue().isPresent()) { return StringUtils.EMPTY; }  MarkdownElement advice = markdownAdviceFor(subject); RatingValue ratingValue = subject.ratingValue().get(); ScoreValue scoreValue = ratingValue.scoreValue();  return template .replaceAll("%MAX_SCORE%", formatted(Score.MAX)) .replaceAll("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%SCORE_VALUE%", formatted(scoreValue.get())) .replace("%RATING_LABEL%", ratingValue.label().name()) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%MAIN_SCORE_NAME%", scoreValue.score().name().toLowerCase()) .replace("%MAIN_SCORE_VALUE_DETAILS%", highLevelDescriptionOf(scoreValue).make()) .replace("%MAIN_SCORE_DESCRIPTION%", scoreValue.score().description()) .replace("%MAIN_SCORE_EXPLANATION%", explanationOf(scoreValue).make()) .replace("%SUB_SCORE_DETAILS%", descriptionOfSubScoresIn(scoreValue).make()) .replace("%ADVICE%", advice.make()) .replace("%INFO_ABOUT_VULNERABILITIES%", infoAboutVulnerabilitiesIn(scoreValue).make()); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: testNoNotes() { // Arrange List<Note> notes = new ArrayList<>();  String expectedResult = "{\n" + "  "type": "FeatureCollection",\n" + "  "features": []\n" + "}";  // Act String actualResult = GeoJson.toGeoJson(notes);  // Assert "<AssertPlaceHolder>"; }
toGeoJson(List<Note> notes) { return new GsonBuilder() .setPrettyPrinting() .create() .toJson(new NoteExportModel(notes)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: testSingleNote() { // Arrange List<Note> notes = new ArrayList<>(); notes.add(new Note(1, "foo", 1.23f, 4.56f, "2021-03-01 12:34:56", new Category(1, "#ff00aa", "Bar", 1)));  String expectedResult = "{\n" + "  "type": "FeatureCollection",\n" + "  "features": [\n" + "    {\n" + "      "type": "Feature",\n" + "      "properties": {\n" + "        "name": 1,\n" + "        "description": "foo",\n" + "        "created_at": "2021-03-01 12:34:56",\n" + "        "category": {\n" + "          "id": 1,\n" + "          "name": "Bar",\n" + "          "color": "#ff00aa"\n" + "        }\n" + "      },\n" + "      "geometry": {\n" + "        "type": "Point",\n" + "        "coordinates": [\n" + "          4.559999942779541,\n" + "          1.2300000190734863\n" + "        ]\n" + "      }\n" + "    }\n" + "  ]\n" + "}";  // Act String actualResult = GeoJson.toGeoJson(notes);  // Assert "<AssertPlaceHolder>"; }
toGeoJson(List<Note> notes) { return new GsonBuilder() .setPrettyPrinting() .create() .toJson(new NoteExportModel(notes)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: testSingleNote_withLineBreak() { // Arrange List<Note> notes = new ArrayList<>(); notes.add(new Note(1, "foo\nbar", 1.23f, 4.56f, "2021-03-01 12:34:56", new Category(1, "#ff00aa", "Bar", 1)));  String expectedResult = "{\n" + "  "type": "FeatureCollection",\n" + "  "features": [\n" + "    {\n" + "      "type": "Feature",\n" + "      "properties": {\n" + "        "name": 1,\n" + "        "description": "foo\\nbar",\n" + "        "created_at": "2021-03-01 12:34:56",\n" + "        "category": {\n" + "          "id": 1,\n" + "          "name": "Bar",\n" + "          "color": "#ff00aa"\n" + "        }\n" + "      },\n" + "      "geometry": {\n" + "        "type": "Point",\n" + "        "coordinates": [\n" + "          4.559999942779541,\n" + "          1.2300000190734863\n" + "        ]\n" + "      }\n" + "    }\n" + "  ]\n" + "}";  // Act String actualResult = GeoJson.toGeoJson(notes);  // Assert "<AssertPlaceHolder>"; }
toGeoJson(List<Note> notes) { return new GsonBuilder() .setPrettyPrinting() .create() .toJson(new NoteExportModel(notes)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: testSingleNote_withQuotes() { // Arrange List<Note> notes = new ArrayList<>(); notes.add(new Note(1, ""foo"", 1.23f, 4.56f, "2021-03-01 12:34:56", new Category(1, "#ff00aa", "Bar", 1)));  String expectedResult = "{\n" + "  "type": "FeatureCollection",\n" + "  "features": [\n" + "    {\n" + "      "type": "Feature",\n" + "      "properties": {\n" + "        "name": 1,\n" + "        "description": "\\"foo\\"",\n" + "        "created_at": "2021-03-01 12:34:56",\n" + "        "category": {\n" + "          "id": 1,\n" + "          "name": "Bar",\n" + "          "color": "#ff00aa"\n" + "        }\n" + "      },\n" + "      "geometry": {\n" + "        "type": "Point",\n" + "        "coordinates": [\n" + "          4.559999942779541,\n" + "          1.2300000190734863\n" + "        ]\n" + "      }\n" + "    }\n" + "  ]\n" + "}";  // Act String actualResult = GeoJson.toGeoJson(notes);  // Assert "<AssertPlaceHolder>"; }
toGeoJson(List<Note> notes) { return new GsonBuilder() .setPrettyPrinting() .create() .toJson(new NoteExportModel(notes)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: testMultipleNotes() { // Arrange List<Note> notes = new ArrayList<>(); notes.add(new Note(1, "foo", 1.23f, 4.56f, "2021-03-01 12:34:56", new Category(1, "#abc123", "One", 1))); notes.add(new Note(2, ""bar" with quotes", 2.34f, 5.67f, "2010-12-21 01:23:45", new Category(42, "#aabbcc", "Fourty-Two", 1)));  String expectedResult = "{\n" + "  "type": "FeatureCollection",\n" + "  "features": [\n" + "    {\n" + "      "type": "Feature",\n" + "      "properties": {\n" + "        "name": 1,\n" + "        "description": "foo",\n" + "        "created_at": "2021-03-01 12:34:56",\n" + "        "category": {\n" + "          "id": 1,\n" + "          "name": "One",\n" + "          "color": "#abc123"\n" + "        }\n" + "      },\n" + "      "geometry": {\n" + "        "type": "Point",\n" + "        "coordinates": [\n" + "          4.559999942779541,\n" + "          1.2300000190734863\n" + "        ]\n" + "      }\n" + "    },\n" + "    {\n" + "      "type": "Feature",\n" + "      "properties": {\n" + "        "name": 2,\n" + "        "description": "\\"bar\\" with quotes",\n" + "        "created_at": "2010-12-21 01:23:45",\n" + "        "category": {\n" + "          "id": 42,\n" + "          "name": "Fourty-Two",\n" + "          "color": "#aabbcc"\n" + "        }\n" + "      },\n" + "      "geometry": {\n" + "        "type": "Point",\n" + "        "coordinates": [\n" + "          5.670000076293945,\n" + "          2.3399999141693115\n" + "        ]\n" + "      }\n" + "    }\n" + "  ]\n" + "}";  // Act String actualResult = GeoJson.toGeoJson(notes);  // Assert "<AssertPlaceHolder>"; }
toGeoJson(List<Note> notes) { return new GsonBuilder() .setPrettyPrinting() .create() .toJson(new NoteExportModel(notes)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: resolveTest() { CipherSuite cipherSuite = CipherSuite.resolve(0xe0, 0x13, ProtocolVersion.NTLS_1_1); Assert.assertEquals(cipherSuite, CipherSuite.NTLS_SM2_WITH_SM4_SM3);  cipherSuite = CipherSuite.resolve(0x00, 0x13, ProtocolVersion.NTLS_1_1); Assert.assertNull(cipherSuite);  cipherSuite = CipherSuite.resolve(0xe0, 0xe3, ProtocolVersion.NTLS_1_1); Assert."<AssertPlaceHolder>"; }
resolve(int id1, int id2, ProtocolVersion version) { if (version == ProtocolVersion.NTLS_1_1) { if (id1 == 0xe0) { switch (id2) { case 0x13: return NTLS_SM2_WITH_SM4_SM3; default: break; } } } return null; }
[*] target: assertNull(cipherSuite)
[-] pred: org. junit. Assert. assertNull ( cipherSuite )
************************************
************************************
[+] input: validValuesOfTest() { try { CipherSuite.validValuesOf(null); Assert.fail(); } catch (Exception ex) { Assert.assertEquals("CipherSuites cannot be null", ex.getMessage()); }  try { CipherSuite.validValuesOf(new String[] { "" }); Assert.fail(); } catch (Exception ex) { Assert.assertEquals("The specified CipherSuites array contains invalid null or empty string elements", ex.getMessage()); }  try { CipherSuite.validValuesOf(new String[] { null }); Assert.fail(); } catch (Exception ex) { Assert.assertEquals("The specified CipherSuites array contains invalid null or empty string elements", ex.getMessage()); }  try { CipherSuite.validValuesOf(new String[] { "test" }); Assert.fail(); } catch (Exception ex) { Assert.assertEquals("Unsupported CipherSuite: test", ex.getMessage()); }  List<CipherSuite> suites = CipherSuite.validValuesOf(new String[] { "ECC-SM2-WITH-SM4-SM3" }); Assert."<AssertPlaceHolder>"; }
validValuesOf(String[] names) { if (names == null) { throw new IllegalArgumentException("CipherSuites cannot be null"); }  List<CipherSuite> cipherSuites = new ArrayList<>(names.length); for (String name : names) { if (name == null || name.isEmpty()) { throw new IllegalArgumentException( "The specified CipherSuites array contains " + "invalid null or empty string elements"); }  boolean found = false;  for (CipherSuite cs : all) { if (!cs.supportedProtocols.isEmpty()) { if (cs.name.equals(name)) { cipherSuites.add(cs); found = true; break; } } else { // values() is ordered, remaining cipher suites are // not supported. break; } } if (!found) { throw new IllegalArgumentException( "Unsupported CipherSuite: "  + name); } }  return Collections.unmodifiableList(cipherSuites); }
[*] target: assertEquals(1, suites.size())
[-] pred: org. junit. Assert. assertEquals ( 1, suites. size ( ) )
************************************
************************************
[+] input: Exception { ServerHelloDone serverHelloDone = new ServerHelloDone(); byte[] bytes = serverHelloDone.getBytes(); Assert."<AssertPlaceHolder>"; }
getBytes() throws IOException { return new byte[0]; }
[*] target: assertEquals(0, bytes.length)
[-] pred: org. junit. Assert. assertEquals ( 0, bytes. length )
************************************
************************************
[+] input: Exception {  String userId = "u00001"; String password = "123456"; String keyName = "testKey";  PkeyInfoVO pkeyInfoVO = keysManagerService.createPrivateKey(userId, password, keyName) ; EncryptKeyInfo encryptKey = keysManagerService.getEncryptPrivateKeyByUserIdAndAddress(userId, pkeyInfoVO.getKeyAddress()); String privateKey = keysManagerService.decryptPrivateKey(password, encryptKey.getEncryptKey());  String msg = "test message"; String signStr = signatureService.sign(msg, privateKey); String publicKey = addressHandler.computePublicKey(Numeric.hexStringToByteArray(privateKey)); boolean checkResult = signatureService.verify(msg, signStr, publicKey);  Assert."<AssertPlaceHolder>"; }
verify(String msg, String signStr, String publicKey){ return privateKeySigner.verify(msg, signStr, publicKey); }
[*] target: assertTrue(checkResult)
[-] pred: org. junit. Assert. assertTrue ( checkResult )
************************************
************************************
[+] input: testAnyLabelEqualToWildcardLabel() { Label testLabel = new Label("Test");  WildcardLabel wildcardLabel = new WildcardLabel();  "<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) return true; if (o == null) return false; if (o.getClass() == WildcardLabel.class) return true; if (getClass() != o.getClass()) return false; Label label1 = (Label) o; return label.equals(label1.label); }
[*] target: assertTrue(testLabel.equals(wildcardLabel))
[-] pred: org. junit. Assert. assertTrue ( testLabel. equals ( wildcardLabel ) )
************************************
************************************
[+] input: testToStringEdgePatternWithLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"Does"}); EdgePattern edgePattern = new EdgePattern(null, label, null, Direction.LEFT_TO_RIGHT, 1);  String expectedResult = "(->, nil, {{Does}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringEdgePatternWithLabelConjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Does", "AreColleagues"}); EdgePattern edgePattern = new EdgePattern(null, labelSetList, null, Direction.UNDIRECTED, 1);  String expectedResult = "(-, nil, {{Does, AreColleagues}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringEdgePatternWithLabelDisjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"AreColleagues"}); addLabelSetTo(labelSetList, new String[]{"Does"}); EdgePattern edgePattern = new EdgePattern(null, labelSetList, null, Direction.LEFT_TO_RIGHT, 1);  String expectedResult = "(->, nil, {{AreColleagues}, {Does}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringEdgePatternWithProperty() { HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("in_semester"), new FixedPointNumber("2")); EdgePattern edgePattern = new EdgePattern(null, null, properties, Direction.RIGHT_TO_LEFT, 1);  String expectedResult = "(<-, nil, {}, {(in_semester: 2)}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringEdgePatternWithIdAndLabelsAndProperty() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"AreColleagues"}); addLabelSetTo(labelSetList, new String[]{"Does"});  HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("in_semester"), new FixedPointNumber("2"));  EdgePattern edgePattern = new EdgePattern(new VariableName("x"), labelSetList, properties, Direction.RIGHT_TO_LEFT, 1);  String expectedResult = "(<-, x, {{AreColleagues}, {Does}}, {(in_semester: 2)}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringEdgePatternWithQuantifier() { EdgePattern edgePattern = new EdgePattern(null, null, null, Direction.LEFT_TO_RIGHT, 1985);  String expectedResult = "(->, nil, {}, {}, (1985, 1985))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithId() { NodePattern nodePattern = new NodePattern(new VariableName("x"), null, null);  String expectedResult = "(x, {}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"Person"}); NodePattern nodePattern = new NodePattern(null, label, null);  String expectedResult = "(nil, {{Person}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithLabelConjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); NodePattern nodePattern = new NodePattern(null, labelSetList, null);  String expectedResult = "(nil, {{Person, Professor}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithLabelDisjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); addLabelSetTo(labelSetList, new String[]{"Internship"}); NodePattern nodePattern = new NodePattern(null, labelSetList, null);  String expectedResult = "(nil, {{Person, Professor}, {Internship}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithProperty() { HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); NodePattern nodePattern = new NodePattern(null, null, properties);  String expectedResult = "(nil, {}, {(name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithProperties() { HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); properties.put(new GqlIdentifier("studies"), new GqlString("Data Science")); NodePattern nodePattern = new NodePattern(null, null, properties);  String expectedResult = "(nil, {}, {(studies: "Data Science"), (name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithIdAndLabelsAndProperties() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); addLabelSetTo(labelSetList, new String[]{"Internship"});  HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); properties.put(new GqlIdentifier("studies"), new GqlString("Data Science"));  NodePattern nodePattern = new NodePattern(new VariableName("x"), labelSetList, properties);  String expectedResult = "(x, {{Person, Professor}, {Internship}}, {(studies: "Data Science"), (name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithWildCardLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"%"}); NodePattern nodePattern = new NodePattern(null, label, null);  String expectedResult = "(nil, {{%}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testEmptyPathSequence() { PathSequence pathSequence = new PathSequence(pathSequenceList); assertTrue(pathSequence.pathSequence.isEmpty()); "<AssertPlaceHolder>"; }
size() { return this.pathSequence.size(); }
[*] target: assertEquals(0, pathSequence.size())
[-] pred: org. junit. Assert. assertEquals ( 0, pathSequence. size ( ) )
************************************
************************************
[+] input: testPathSequenceLengthOne() { pathSequenceList.add(getEmptyNodePattern()); PathSequence pathSequence = new PathSequence(pathSequenceList); "<AssertPlaceHolder>"; }
size() { return this.pathSequence.size(); }
[*] target: assertEquals(1, pathSequence.size())
[-] pred: org. junit. Assert. assertEquals ( 1, pathSequence. size ( ) )
************************************
************************************
[+] input: testPathSequenceLengthThree() { pathSequenceList.add(getEmptyNodePattern()); pathSequenceList.add(getEmptyLeftToRightEdgePattern()); pathSequenceList.add(getEmptyNodePattern()); PathSequence pathSequence = new PathSequence(pathSequenceList);  "<AssertPlaceHolder>"; }
size() { return this.pathSequence.size(); }
[*] target: assertEquals(3, pathSequence.size())
[-] pred: org. junit. Assert. assertEquals ( 3, pathSequence. size ( ) )
************************************
************************************
[+] input: testDifferentSetsOfColumnNames() { String[] columnNamesLeft = new String[]{"testLeft", "testRight"}; String[] columnNamesRight = new String[]{"testRight", "testRight"};  BindingTableConjuctor bindingTableConjuctor = new BindingTableConjuctor(); "<AssertPlaceHolder>"; }
haveEqualColumnNames(String[] leftColumnNames, String[] rightColumnNames) { Arrays.sort(leftColumnNames); Arrays.sort(rightColumnNames);  return Arrays.equals(leftColumnNames, rightColumnNames); }
[*] target: assertFalse(bindingTableConjuctor.haveEqualColumnNames(columnNamesLeft, columnNamesRight))
[-] pred: org. junit. Assert. assertFalse ( bindingTableConjuctor. haveEqualColumnNames ( columnNamesLeft, columnNamesRight ) )
************************************
************************************
[+] input: testSameSetsOfColumnNames() { String[] columnNamesLeft = new String[]{"testLeft", "testRight"};  String[] columnNamesRight = new String[]{"testRight", "testLeft"};  BindingTableConjuctor bindingTableConjuctor = new BindingTableConjuctor(); "<AssertPlaceHolder>"; }
haveEqualColumnNames(String[] leftColumnNames, String[] rightColumnNames) { Arrays.sort(leftColumnNames); Arrays.sort(rightColumnNames);  return Arrays.equals(leftColumnNames, rightColumnNames); }
[*] target: assertTrue(bindingTableConjuctor.haveEqualColumnNames(columnNamesLeft, columnNamesRight))
[-] pred: org. junit. Assert. assertTrue ( bindingTableConjuctor. haveEqualColumnNames ( columnNamesLeft, columnNamesRight ) )
************************************
************************************
[+] input: InvalidEdgeFormatException { EdgeParser parser = getEdgeParser("simple_edges.json"); ArrayList<JsonEdge> actualEdges = parser.getEdges();  ArrayList<JsonEdge> expectedEdges = getExpectedSimpleEdges();  "<AssertPlaceHolder>"; }
getEdges() throws InvalidEdgeFormatException { JsonEdgeList edgeList = null;  try { edgeList = objectMapper.readValue(fileToParse, JsonEdgeList.class); } catch (JsonMappingException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (JsonEOFException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (IOException e) { e.printStackTrace(); }  assert edgeList != null; return edgeList.edges; }
[*] target: assertEquals(actualEdges, expectedEdges)
[-] pred: org. junit. Assert. assertEquals ( actualEdges, expectedEdges )
************************************
************************************
[+] input: InvalidEdgeFormatException { EdgeParser parser = getEdgeParser("complete_edges.json"); ArrayList<JsonEdge> actualEdges = parser.getEdges();  ArrayList<JsonEdge> expectedEdges = getExpectedCompleteEdges();  "<AssertPlaceHolder>"; }
getEdges() throws InvalidEdgeFormatException { JsonEdgeList edgeList = null;  try { edgeList = objectMapper.readValue(fileToParse, JsonEdgeList.class); } catch (JsonMappingException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (JsonEOFException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (IOException e) { e.printStackTrace(); }  assert edgeList != null; return edgeList.edges; }
[*] target: assertEquals(actualEdges, expectedEdges)
[-] pred: org. junit. Assert. assertEquals ( actualEdges, expectedEdges )
************************************
************************************
[+] input: InvalidEdgeFormatException { EdgeParser parser = getEdgeParser("complete_edges_without_is_directed.json"); ArrayList<JsonEdge> actualEdges = parser.getEdges();  ArrayList<JsonEdge> expectedEdges = getExpectedCompleteEdges();  "<AssertPlaceHolder>"; }
getEdges() throws InvalidEdgeFormatException { JsonEdgeList edgeList = null;  try { edgeList = objectMapper.readValue(fileToParse, JsonEdgeList.class); } catch (JsonMappingException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (JsonEOFException exception) { System.err.println("edge.json is not formatted correctly at " + fileToParse.getAbsolutePath() + "."); System.err.println(exception.getMessage()); throw new InvalidEdgeFormatException(exception.getMessage()); } catch (IOException e) { e.printStackTrace(); }  assert edgeList != null; return edgeList.edges; }
[*] target: assertEquals(actualEdges, expectedEdges)
[-] pred: org. junit. Assert. assertEquals ( actualEdges, expectedEdges )
************************************
************************************
[+] input: binaryExpressionTest() { // Create the mock data. Map<String, Object> argMaps = createBinaryFilterArgMap("firstName", "contains", "ABC");  // Invoke method under test. FilterExpressionParser expressionParser = new FilterExpressionParser(); Expression expression = expressionParser.parseFilterExpression(argMaps);  // Verify assertions. Assert."<AssertPlaceHolder>"; Assert.assertEquals("(firstName contains ABC)", expression.infix()); }
parseFilterExpression(Map filterArgs) { return createExpressionTree(filterArgs); }
[*] target: assertNotNull(expression)
[-] pred: org. junit. Assert. assertNotNull ( expression )
************************************
************************************
[+] input: compoundExpressionTest() { // Create the mock data. Map<String, Object> argMaps = createCompoundFilterArgMap();  // Invoke method under test. FilterExpressionParser expressionParser = new FilterExpressionParser(); Expression expression = expressionParser.parseFilterExpression(argMaps);  // Verify assertions. Assert."<AssertPlaceHolder>"; Assert.assertEquals("((firstName contains ABC) or (lastName equals XYZ))", expression.infix()); }
parseFilterExpression(Map filterArgs) { return createExpressionTree(filterArgs); }
[*] target: assertNotNull(expression)
[-] pred: org. junit. Assert. assertNotNull ( expression )
************************************
************************************
[+] input: getIndexActGoods() { List<ActGoodsInfoResult> activityGoodsList = activityGoodsService .getIndexGroupActGoods(1544169688415057L, "S00050001wx219007e82b660f17"); "<AssertPlaceHolder>"; }
getIndexGroupActGoods(Long wxuserId,String appmodelId);
[*] target: assertNotNull(activityGoodsList)
[-] pred: org. junit. Assert. assertNotNull ( activityGoodsList )
************************************
************************************
[+] input: getActGoodsByClass() { List<ActGoodsInfoResult> activityGoodsList = activityGoodsService .getActGoodsByClass("S00050001wx219007e82b660f17", 1L, 1544169688415057L); "<AssertPlaceHolder>"; }
getActGoodsByClass(String appmodelId,Long goodsClassId,Long wxuserId);
[*] target: assertNotNull(activityGoodsList)
[-] pred: org. junit. Assert. assertNotNull ( activityGoodsList )
************************************
************************************
[+] input: getActGoodsByActId() { List<ActGoodsInfoResult> activityGoodsList = activityGoodsService.getActGoodsByActId4Pc(10086L); "<AssertPlaceHolder>"; }
getActGoodsByActId4Pc(Long activityId);
[*] target: assertNotNull(activityGoodsList)
[-] pred: org. junit. Assert. assertNotNull ( activityGoodsList )
************************************
************************************
[+] input: IOException { String webpathStr = "projects/foo/location/earth/datasets/bar/dicomStores/" + "fee/dicomWeb/studies/abc/series/xyz/instances/123";  WebPathParser parser = new WebPathParser(); WebPathParser.DicomWebPath dicomWebPath = parser.parseDicomWebpath(webpathStr);  Assert."<AssertPlaceHolder>"; Assert.assertEquals("foo", dicomWebPath.project); Assert.assertEquals("earth", dicomWebPath.location); Assert.assertEquals("bar", dicomWebPath.dataset); Assert.assertEquals("fee", dicomWebPath.storeId); Assert.assertEquals("abc", dicomWebPath.studyId); Assert.assertEquals("xyz", dicomWebPath.seriesId); Assert.assertEquals("123", dicomWebPath.instanceId); Assert.assertEquals( "projects/foo/location/earth/datasets/bar/dicomStores/fee", dicomWebPath.dicomStorePath); }
parseDicomWebpath(String unparsedWebpath) throws IOException { String[] webPathSplit = unparsedWebpath.split("/dicomWeb/");  if (webPathSplit.length != 2) { throw new IOException("Invalid DICOM web path"); }  DicomWebPath dicomWebPath = new DicomWebPath();  dicomWebPath.dicomStorePath = webPathSplit[0]; String[] storePathElements = dicomWebPath.dicomStorePath.split("/");  if (storePathElements.length < 8) { throw new IOException("Invalid DICOM web path"); } dicomWebPath.project = storePathElements[1]; dicomWebPath.location = storePathElements[3]; dicomWebPath.dataset = storePathElements[5]; dicomWebPath.storeId = storePathElements[7];  String[] searchParameters; searchParameters = webPathSplit[1].split("/"); if (searchParameters.length < 6) { throw new IOException("Invalid DICOM web path"); } dicomWebPath.studyId = searchParameters[1]; dicomWebPath.seriesId = searchParameters[3]; dicomWebPath.instanceId = searchParameters[5];  return dicomWebPath; }
[*] target: assertNotNull(dicomWebPath)
[-] pred: org. junit. Assert. assertNotNull ( dicomWebPath )
************************************
************************************
[+] input: testExtractMessages_iPhoneSE1_with_Herald() { // iPhoneSE 1st gen w/ Herald final Data raw = Data.fromHexEncodedString("02011a020a0c11079bfd5bd672451e80d3424647af328142"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertNull(messages)
[-] pred: org. junit. Assert. assertNull ( messages )
************************************
************************************
[+] input: testExtractMessages_AppleTV() { final Data raw = Data.fromHexEncodedString("02011a020a0c0aff4c00100508141bba69"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; assertEquals("100508141BBA69", messages.get(0).hexEncodedString());  assertNotNull(BLEDeviceFilter.match(BLEDeviceFilter.compilePatterns(new String[]{"^10....04", "^10....14"}), raw)); }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertEquals(1, messages.size())
[-] pred: org. junit. Assert. assertEquals ( 1, messages. size ( ) )
************************************
************************************
[+] input: testExtractMessages_Coincidence() { final Data raw = Data.fromHexEncodedString("02011a020a0c0aff4c0010050814ff4c00"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; assertEquals("10050814FF4C00", messages.get(0).hexEncodedString());  assertNotNull(BLEDeviceFilter.match(BLEDeviceFilter.compilePatterns(new String[]{"^10....04", "^10....14"}), raw)); }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertEquals(1, messages.size())
[-] pred: org. junit. Assert. assertEquals ( 1, messages. size ( ) )
************************************
************************************
[+] input: testExtractMessages_MacbookProUnderflow() { final Data raw = Data.fromHexEncodedString("02011a0aff4c001005031c0b4c"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertNull(messages)
[-] pred: org. junit. Assert. assertNull ( messages )
************************************
************************************
[+] input: testMatch_iPhoneX_F() { final Data raw = Data.fromHexEncodedString("02011A020A0C0BFF4C001006071EA3DD89E014FF4C0001000000000000000000002000000000000000000000000000000000000000000000000000000000"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; assertEquals("1006071EA3DD89E0", messages.get(0).hexEncodedString()); assertEquals("0100000000000000000000200000000000", messages.get(1).hexEncodedString()); }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertEquals(2, messages.size())
[-] pred: org. junit. Assert. assertEquals ( 2, messages. size ( ) )
************************************
************************************
[+] input: testDeserializeMap() { Schema schema = new Schema(required(1, "map_type", Types.MapType .ofRequired(18, 19, Types.StringType.get(), Types.StringType.get()))); Map<String, String> expected = ImmutableMap.of("foo", "bar"); List<Map> data = new ArrayList<>(); data.add(expected);  Record record = TestHelpers.createCustomRecord(schema, data); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> deserialized = (List<Object>) serDe.deserialize(writable); Map result = (Map) deserialized.get(0);  "<AssertPlaceHolder>"; assertTrue(result.containsKey("foo")); assertTrue(result.containsValue("bar")); }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testDeserializeList() { Schema schema = new Schema(required(1, "list_type", Types.ListType.ofRequired(17, Types.LongType.get()))); List<Long> expected = Arrays.asList(1000L, 2000L, 3000L); List<List> data = new ArrayList<>(); data.add(expected);  Record record = TestHelpers.createCustomRecord(schema, data); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> deserialized = (List<Object>) serDe.deserialize(writable); List result = (List) deserialized.get(0);  "<AssertPlaceHolder>"; }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testDeserializePrimitives() { Schema schema = new Schema(required(1, "string_type", Types.StringType.get()), required(2, "int_type", Types.IntegerType.get()), required(3, "long_type", Types.LongType.get()), required(4, "boolean_type", Types.BooleanType.get()), required(5, "float_type", Types.FloatType.get()), required(6, "double_type", Types.DoubleType.get()), required(7, "date_type", Types.DateType.get()));  List<?> expected = Arrays.asList("foo", 12, 3000L, true, 3.01F, 3.0D, "1998-11-13");  Record record = TestHelpers.createCustomRecord(schema, expected); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> result = (List<Object>) serDe.deserialize(writable);  "<AssertPlaceHolder>"; }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testDeserializeNestedList() { Schema schema = new Schema(required(1, "map_type", Types.MapType .ofRequired(18, 19, Types.StringType.get(), Types.ListType.ofRequired(17, Types.LongType.get())))); Map<String, List> expected = ImmutableMap.of("foo", Arrays.asList(1000L, 2000L, 3000L)); List<Map> data = new ArrayList<>(); data.add(expected);  Record record = TestHelpers.createCustomRecord(schema, data); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> deserialized = (List<Object>) serDe.deserialize(writable); Map result = (Map) deserialized.get(0);  "<AssertPlaceHolder>"; assertTrue(result.containsKey("foo")); assertTrue(result.containsValue(Arrays.asList(1000L, 2000L, 3000L))); }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: extractWarehouseLocationRegularTable() { // This is the style of input expected from HiveConf String testLocation = "some/folder/database/table_a"; String testTableName = "database.table_a";  String expected = "some/folder/"; String result = TableResolverUtil.extractWarehousePath(testLocation, testTableName);  "<AssertPlaceHolder>"; }
extractWarehousePath(String location, String tableName) { String tablePath = tableName.replaceAll("\\.","/").replaceAll(SNAPSHOT_TABLE_SUFFIX, ""); return location.replaceAll(tablePath, ""); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: extractPropertyFromJobConf() { JobConf conf = new JobConf(); String key = "iceberg.catalog"; String value = "hadoop.tables";  conf.set(key, value);  String result = TableResolverUtil.extractProperty(conf, key);  "<AssertPlaceHolder>"; }
extractProperty(JobConf conf, String key) { String value = conf.get(key); if (value == null) { throw new IllegalArgumentException("Property not set in JobConf: " + key); } return value; }
[*] target: assertEquals(value, result)
[-] pred: org. junit. Assert. assertEquals ( value, result )
************************************
************************************
[+] input: testGetAttackPerProtocolCount() { String protocol = "Http"; record.setProtocol(protocol); attackRecordDAO.insert(record);  int result = attackRecordDAO.getAttackPerProtocolCount(protocol);  "<AssertPlaceHolder>";  }
getAttackPerProtocolCount(String protocol) { AttackRecordDao recordDao = this.daoSession.getAttackRecordDao();  QueryBuilder<AttackRecord> qb = recordDao.queryBuilder().where(AttackRecordDao.Properties.Protocol.eq(protocol)); int result = (int) qb.buildCount().count();  return result;  }
[*] target: assertEquals(1, result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: testGetAttackPerProtocolCountTwoArguments() { String protocol = "Http"; record.setProtocol(protocol); record.setAttack_id(1); attackRecordDAO.insert(record);  int result = attackRecordDAO.getAttackPerProtocolCount(protocol,1);  "<AssertPlaceHolder>";  }
getAttackPerProtocolCount(String protocol, long attack_id) { AttackRecordDao recordDao = this.daoSession.getAttackRecordDao();  QueryBuilder<AttackRecord> qb = recordDao.queryBuilder(); qb.where(AttackRecordDao.Properties.Protocol.eq(protocol), AttackRecordDao.Properties.Attack_id.eq(attack_id));  return (int) qb.buildCount().count();  }
[*] target: assertEquals(1, result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: testBssidSeen() { String protocol = "http"; String bssid = "dk/aau/netsec/hostage/fragment"; record.setProtocol(protocol); record.setBssid(bssid);  daoSession.insert(record);  boolean bssidSeen = attackRecordDAO.bssidSeen(protocol,bssid);  "<AssertPlaceHolder>"; }
bssidSeen(String protocol, String BSSID) { if(BSSID == null || protocol == null){ return false; } AttackRecordDao recordDao = this.daoSession.getAttackRecordDao();  QueryBuilder<AttackRecord> qb = recordDao.queryBuilder(); qb.where(AttackRecordDao.Properties.Protocol.eq(protocol),AttackRecordDao.Properties.Bssid.eq(BSSID)); List<AttackRecord> records = qb.list();  return !records.isEmpty(); }
[*] target: assertTrue(bssidSeen)
[-] pred: org. junit. Assert. assertTrue ( bssidSeen )
************************************
************************************
[+] input: testJoins() { String protocolFirst = "https"; String protocolSecond = "telnet"; AttackRecord attackRecord = new AttackRecord(); AttackRecord attackRecordSecond = new AttackRecord();  attackRecord.setAttack_id(2); attackRecord.setAttack_id(2); attackRecord.setProtocol(protocolFirst); attackRecordSecond.setAttack_id(3); attackRecordSecond.setProtocol(protocolSecond);  record.setId(1); record.setAttack_id(2); record.setRecord(attackRecord); daoSession.insert(attackRecord); daoSession.insert(attackRecordSecond); daoSession.insert(record);  ArrayList<AttackRecord> records = messageRecordDAO.joinAttacks(protocolFirst); "<AssertPlaceHolder>"; assertEquals(protocolFirst,records.get(0).getProtocol());  }
joinAttacks(String protocol){ AttackRecordDao messageRecordDao = this.daoSession.getAttackRecordDao();  QueryBuilder<AttackRecord> qb = messageRecordDao.queryBuilder(); qb.join(MessageRecord.class , MessageRecordDao.Properties.Attack_id);  ArrayList<AttackRecord> attacks = (ArrayList<AttackRecord>) qb.list();  return attacks;  }
[*] target: assertEquals(1,records.size())
[-] pred: org. junit. Assert. assertEquals ( 1, records. size ( ) )
************************************
************************************
[+] input: testJoins() { AttackRecord attackRecord = new AttackRecord();  String bssid = "dk/aau/netsec/hostage/fragment"; String protocol = "protocol"; String packet = "packet";  attackRecord.setAttack_id(2); attackRecord.setProtocol(protocol); attackRecord.setBssid(bssid); attackRecord.setTimestampLocation(9); record.setBssid(bssid); record.setTimestampLocation(9); record.setPacket(packet);  daoSession.insert(attackRecord); daoSession.insert(record);  ArrayList<NetworkRecord> records = networkRecorDAO.joinAttacks(protocol);  "<AssertPlaceHolder>"; assertEquals(bssid,records.get(0).getBssid()); assertEquals(packet,records.get(0).getPacket());  }
joinAttacks(String protocol){ NetworkRecordDao networkRecordDao = this.daoSession.getNetworkRecordDao();  QueryBuilder<NetworkRecord> qb = networkRecordDao.queryBuilder(); qb.join(AttackRecord.class ,AttackRecordDao.Properties.TimestampLocation).where(AttackRecordDao.Properties.Protocol.eq(protocol));  ArrayList<NetworkRecord> attacks = (ArrayList<NetworkRecord>) qb.list();  return attacks;  }
[*] target: assertEquals(1,records.size())
[-] pred: org. junit. Assert. assertEquals ( 1, records. size ( ) )
************************************
************************************
[+] input: testCombine() { Properties properties1 = graphFactory().createProperties(); properties1.put("name", BytesId.of("marko")); properties1.put("city", BytesId.of("Beijing"));  Properties properties2 = graphFactory().createProperties(); properties2.put("name", BytesId.of("josh")); properties2.put("age", BytesId.of("18"));  Properties expect = graphFactory().createProperties(); expect.put("name", BytesId.of("josh")); expect.put("age", BytesId.of("18")); expect.put("city", BytesId.of("Beijing"));  Properties properties = graphFactory().createProperties(); PropertiesCombiner combiner = new MergeOldPropertiesCombiner(); combiner.combine(properties1, properties2, properties); Assert."<AssertPlaceHolder>"; }
combine(Properties v1, Properties v2, Properties result) { E.checkArgumentNotNull(v1, "The combine parameter v1 can't be null"); E.checkArgumentNotNull(v2, "The combine parameter v2 can't be null"); E.checkArgumentNotNull(result, "The combine parameter result can't be null"); E.checkArgument(v1 != result && v2 != result, "The combine parameter result " + "can't same with v1 or v2");  result.clear();  Map<String, Value> v2Map = v2.get(); for (Map.Entry<String, Value> entry : v2Map.entrySet()) { result.put(entry.getKey(), entry.getValue()); } Map<String, Value> v1Map = v1.get(); for (Map.Entry<String, Value> entry : v1Map.entrySet()) { result.putIfAbsent(entry.getKey(), entry.getValue()); } }
[*] target: assertEquals(expect, properties)
[-] pred: org. junit. Assert. assertEquals ( expect, properties )
************************************
************************************
[+] input: testToString() { ContainerInfo container = new ContainerInfo(0, HOST1, 8001, 8002); String str = "ContainerInfo{"id":0,"hostname":"localhost"," + ""rpcPort":8001,"dataPort":8002}"; Assert."<AssertPlaceHolder>"; }
toString() { return JsonUtil.toJsonWithClass(this); }
[*] target: assertEquals(str, container.toString())
[-] pred: org. junit. Assert. assertEquals ( str, container. toString() )
************************************
************************************
[+] input: testNullClass() { Config config = UnitTestBase.updateWithRequiredOptions( ComputerOptions.WORKER_COMBINER_CLASS, Null.class.getName() ); Object combiner = config.createObject( ComputerOptions.WORKER_COMBINER_CLASS, false); Assert."<AssertPlaceHolder>"; }
createObject(ConfigOption<Class<?>> clazzOption, boolean requiredNotNull) { Class<?> clazz = this.get(clazzOption); if (clazz == Null.class) { if (requiredNotNull) { throw new ComputerException( "Please config required option '%s'", clazzOption.name()); } return null; } try { @SuppressWarnings("unchecked") T instance = (T) clazz.newInstance(); return instance; } catch (Exception e) { throw new ComputerException("Failed to create object for option " + "'%s', class='%s'", e, clazzOption.name(), clazz.getName()); } }
[*] target: assertNull(combiner)
[-] pred: org. junit. Assert. assertNull ( combiner )
************************************
************************************
[+] input: testToString() { PartitionStat stat = new PartitionStat(1, 4L, 3L, 2L); stat.mergeSendMessageStat(new MessageStat(5L, 6L)); stat.mergeRecvMessageStat(new MessageStat(7L, 8L)); String str = "PartitionStat{"partitionId":1,"vertexCount":4,"" + "edgeCount":3,"finishedVertexCount":2," + ""messageSendCount":5,"messageSendBytes":6," + ""messageRecvCount":7,"messageRecvBytes":8}"; Assert."<AssertPlaceHolder>"; }
toString() { return JsonUtil.toJsonWithClass(this); }
[*] target: assertEquals(str, stat.toString())
[-] pred: org. junit. Assert. assertEquals ( str, stat. toString() )
************************************
************************************
[+] input: testClear() { ListValue<IntValue> value = new ListValue<>(ValueType.INT); value.add(new IntValue(101)); value.add(new IntValue(102)); value.add(new IntValue(103)); Assert.assertEquals(3, value.size());  value.clear(); Assert."<AssertPlaceHolder>"; }
size() { return this.values.size(); }
[*] target: assertEquals(0, value.size())
[-] pred: org. junit. Assert. assertEquals ( 0, value. size() )
************************************
************************************
[+] input: testValue() { NullValue value1 = NullValue.get(); NullValue value2 = NullValue.get();  Assert.assertEquals(value1, value2); Assert.assertEquals(value1.value(), value2.value()); Assert.assertNull(value1.value()); Assert."<AssertPlaceHolder>"; }
value() { return null; }
[*] target: assertNull(value2.value())
[-] pred: org. junit. Assert. assertNull ( value2. value() )
************************************
************************************
[+] input: testEquals() { StringValue value1 = new StringValue("test"); StringValue value2 = new StringValue("test");  Assert.assertEquals(value1, value2);  DoubleValue value3 = new DoubleValue(1.1); Assert."<AssertPlaceHolder>"; }
equals(Object obj) { if (!(obj instanceof StringValue)) { return false; } return ((StringValue) obj).value.equals(this.value); }
[*] target: assertFalse(value1.equals(value3))
[-] pred: org. junit. Assert. assertFalse ( value1. equals ( value3 ) )
************************************
************************************
[+] input: testHashCode() { InputStruct inputStruct = Mockito.mock(InputStruct.class); FileInputSplit split1 = new FileInputSplit(ElemType.VERTEX, inputStruct, "/tmp/test"); FileInputSplit split2 = new FileInputSplit(ElemType.VERTEX, inputStruct, "/tmp/test"); Assert."<AssertPlaceHolder>"; }
hashCode() { return Objects.hashCode(super.hashCode(), this.type, this.path, this.struct); }
[*] target: assertEquals(split1.hashCode(), split2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( split1. hashCode(), split2. hashCode() )
************************************
************************************
[+] input: testParseConnectionID() { ConnectionId connectionId1 = ConnectionId.parseConnectionId( "127.0.0.1", 8080); ConnectionId connectionId2 = ConnectionId.parseConnectionId( "127.0.0.1", 8080); Assert."<AssertPlaceHolder>"; }
parseConnectionId(String host, int port) { return parseConnectionId(host, port, 0); }
[*] target: assertSame(connectionId1, connectionId2)
[-] pred: org. junit. Assert. assertSame ( connectionId1, connectionId2 )
************************************
************************************
[+] input: UnknownHostException { InetAddress localHost = InetAddress.getLocalHost(); String hostName = localHost.getHostName(); InetSocketAddress address = TransportUtil.resolvedSocketAddress( hostName, 8080); ConnectionId connectionId = new ConnectionId(address); ConnectionId connectionId2 = ConnectionId.parseConnectionId( hostName, 8080); Assert."<AssertPlaceHolder>"; }
parseConnectionId(String host, int port) { return parseConnectionId(host, port, 0); }
[*] target: assertEquals(connectionId, connectionId2)
[-] pred: org. junit. Assert. assertEquals ( connectionId, connectionId2 )
************************************
************************************
[+] input: testRemoteAddressWithNull() { Channel channel = null; String address = TransportUtil.remoteAddress(channel); Assert.assertNull(address);  Channel channel2 = new EmbeddedChannel(); channel2.close(); String address2 = TransportUtil.remoteAddress(channel2); Assert."<AssertPlaceHolder>"; }
remoteAddress(Channel channel) { if (channel == null || channel.remoteAddress() == null) { return null; } if (channel.remoteAddress() instanceof InetSocketAddress) { return formatAddress((InetSocketAddress) channel.remoteAddress()); } else { return channel.toString(); } }
[*] target: assertNull(address2)
[-] pred: org. junit. Assert. assertNull ( address2 )
************************************
************************************
[+] input: testRemoteConnectionIDWithNull() { Channel channel = null; ConnectionId connectionId = TransportUtil.remoteConnectionId(channel); Assert.assertNull(connectionId);  Channel channel2 = new EmbeddedChannel(); channel2.close(); ConnectionId connectionId2 = TransportUtil.remoteConnectionId(channel2); Assert."<AssertPlaceHolder>"; }
remoteConnectionId(Channel channel) { if (channel == null || channel.remoteAddress() == null) { return null; } InetSocketAddress address = (InetSocketAddress) channel.remoteAddress(); return ConnectionId.parseConnectionId(address.getHostName(), address.getPort()); }
[*] target: assertNull(connectionId2)
[-] pred: org. junit. Assert. assertNull ( connectionId2 )
************************************
************************************
[+] input: testInit() { TransportConf conf = TransportConf.wrapConfig(config); NettyClientFactory clientFactory = new NettyClientFactory(conf); clientFactory.init(); Object bootstrap = Whitebox.getInternalState(clientFactory, "bootstrap"); Assert."<AssertPlaceHolder>"; }
init() { E.checkArgument(this.bootstrap == null, "The NettyClientFactory has already been initialized"); this.connectTimeoutMs = Math.toIntExact( this.conf.clientConnectionTimeout());  this.workerGroup = NettyEventLoopUtil.createEventLoop( this.conf.ioMode(), this.conf.clientThreads(), TransportConf.CLIENT_THREAD_GROUP_NAME);  this.bootstrap = new Bootstrap(); this.bootstrap.group(this.workerGroup); this.bootstrap .channel(NettyEventLoopUtil.clientChannelClass(this.conf.ioMode()));  this.bootstrap.option(ChannelOption.ALLOCATOR, this.bufAllocator); this.bootstrap.option(ChannelOption.TCP_NODELAY, true); this.bootstrap.option(ChannelOption.SO_KEEPALIVE, this.conf.tcpKeepAlive()); this.bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, this.connectTimeoutMs);  if (this.conf.sizeReceiveBuffer() > 0) { this.bootstrap.option(ChannelOption.SO_RCVBUF, this.conf.sizeReceiveBuffer()); }  if (this.conf.sizeSendBuffer() > 0) { this.bootstrap.option(ChannelOption.SO_SNDBUF, this.conf.sizeSendBuffer()); }  // Set low water mark and high water mark for the write buffer. WriteBufferWaterMark bufferWaterMark = new WriteBufferWaterMark( this.conf.writeBufferLowMark(), this.conf.writeBufferHighMark()); this.bootstrap.option(ChannelOption.WRITE_BUFFER_WATER_MARK, bufferWaterMark);  this.bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override public void initChannel(SocketChannel channel) { NettyClientFactory.this.protocol .initializeClientPipeline(channel); } }); }
[*] target: assertNotNull(bootstrap)
[-] pred: org. junit. Assert. assertNotNull ( bootstrap )
************************************
************************************
[+] input: IOException { NettyTransportClient client = (NettyTransportClient) this.oneClient(); ConnectionId connectionId = ConnectionId.parseConnectionId(host, port); ConnectionId clientConnectionId = client.connectionId(); Assert."<AssertPlaceHolder>"; }
connectionId() { return this.connectionId; }
[*] target: assertEquals(connectionId, clientConnectionId)
[-] pred: org. junit. Assert. assertEquals ( connectionId, clientConnectionId )
************************************
************************************
[+] input: IOException { NettyTransportClient client = (NettyTransportClient) this.oneClient(); client.startSession();  Mockito.doThrow(new RuntimeException("test exception")).when(serverHandler) .handle(Mockito.any(), Mockito.anyInt(), Mockito.any());  ByteBuffer buffer = ByteBuffer.wrap(StringEncodeUtil.encode("test data")); boolean send = client.send(MessageType.MSG, 1, buffer); Assert."<AssertPlaceHolder>";  Whitebox.setInternalState(client, "timeoutFinishSession", 1000L);  Assert.assertThrows(TransportException.class, client::finishSession, e -> { Assert.assertContains("finish-response", e.getMessage()); });  Mockito.verify(serverHandler, Mockito.timeout(10_000L).times(1)) .exceptionCaught(Mockito.any(), Mockito.any()); }
send(MessageType messageType, int partition, ByteBuffer buffer) throws TransportException { if (!this.checkSendAvailable()) { return false; } this.session.sendAsync(messageType, partition, buffer); return true; }
[*] target: assertTrue(send)
[-] pred: org. junit. Assert. assertTrue ( send )
************************************
************************************
[+] input: testEquals() { PartitionStat stat1 = new PartitionStat(0, 1L, 2L, 0L); PartitionStat stat2 = new PartitionStat(1, 4L, 3L, 2L); WorkerStat workerStat1 = new WorkerStat(); workerStat1.add(stat1); workerStat1.add(stat2);  WorkerStat workerStat2 = new WorkerStat(); workerStat2.add(stat1); workerStat2.add(stat2);  WorkerStat workerStat3 = new WorkerStat();  Assert."<AssertPlaceHolder>"; Assert.assertNotEquals(workerStat1, workerStat3); Assert.assertNotEquals(workerStat1, new Object()); }
add(PartitionStat stat) { E.checkArgumentNotNull(stat, "The stat can't be null"); this.partitionStats.add(stat); }
[*] target: assertEquals(workerStat1, workerStat2)
[-] pred: org. junit. Assert. assertEquals ( workerStat1, workerStat2 )
************************************
************************************
[+] input: InterruptedException { AtomicBoolean isRun = new AtomicBoolean(false); Thread.UncaughtExceptionHandler handler = (t, e) -> { isRun.compareAndSet(false, true); }; Thread.setDefaultUncaughtExceptionHandler(handler); HugeGraphComputer.setUncaughtExceptionHandler(); Thread t = new Thread(() -> { throw new RuntimeException(); }); t.start(); t.join(); Assert."<AssertPlaceHolder>"; }
setUncaughtExceptionHandler() { Thread.UncaughtExceptionHandler handler = Thread.getDefaultUncaughtExceptionHandler(); Thread.setDefaultUncaughtExceptionHandler( new PrintExceptionHandler(handler) ); }
[*] target: assertTrue(isRun.get())
[-] pred: org. junit. Assert. assertTrue ( isRun. get ( ) )
************************************
************************************
[+] input: FileNotFoundException { Whitebox.setInternalState(this.driver, "bashPath", "conf/images/docker_push_test.sh"); Whitebox.setInternalState(this.driver, "registry", "registry.hub.docker.com"); String url = "https://github.com/apache/hugegraph-doc/raw/" + "binary-1.0/dist/computer/test.jar"; String path = "conf/images/test.jar"; downloadFileByUrl(url, path);  InputStream inputStream = new FileInputStream(path); this.driver.uploadAlgorithmJar("PageRank", inputStream);  File file = new File("/tmp/upload.txt"); try { Assert."<AssertPlaceHolder>"; } finally { FileUtils.deleteQuietly(file); } }
uploadAlgorithmJar(String algorithmName, InputStream input) { File tempFile = null; try { Path path = Files.createDirectories( Paths.get(TMP_DIR, UUID.randomUUID().toString())); tempFile = File.createTempFile("userAlgorithm", ".jar", path.toFile()); FileUtils.copyInputStreamToFile(input, tempFile);  InputStream bashStream; if (StringUtils.isBlank(this.bashPath)) { bashStream = this.getClass() .getResourceAsStream(DEFAULT_PUSH_BASH_PATH); } else { bashStream = new FileInputStream(this.bashPath); } String bashAsStr = IOHelpers.readFully(bashStream);  StringBuilder builder = new StringBuilder(); builder.append(BUILD_IMAGE_FUNC); if (StringUtils.isNotBlank(this.registry)) { builder.append(" -r ").append(this.registry); } if (StringUtils.isNotBlank(this.username)) { builder.append(" -u ").append(this.username); } if (StringUtils.isNotBlank(this.password)) { builder.append(" -p ").append(this.password); } builder.append(" -s ").append(tempFile.getAbsolutePath()); String jarFile = this.buildJarFile(this.jarFileDir, algorithmName); builder.append(" -j ").append(jarFile); String imageUrl = this.buildImageUrl(algorithmName); builder.append(" -i ").append(imageUrl); builder.append(" -f ").append(this.frameworkImageUrl); String args = builder.toString(); String[] command = {"bash", "-c", bashAsStr + "\n" + args};  Process process = Runtime.getRuntime().exec(command); int code = process.waitFor(); if (code != 0) { InputStream errorStream = process.getErrorStream(); String errorInfo = IOHelpers.readFully(errorStream); if (StringUtils.isBlank(errorInfo)) { InputStream stdoutStream = process.getInputStream(); errorInfo = IOHelpers.readFully(stdoutStream); } throw new ComputerDriverException(errorInfo); } } catch (Throwable exception) { throw new ComputerDriverException("Failed to upload algorithm Jar", exception); } finally { FileUtils.deleteQuietly(tempFile); } }
[*] target: assertTrue(file.exists())
[-] pred: org. junit. Assert. assertTrue ( file. exists ( ) )
************************************
************************************
[+] input: testSubmitJob() { Map<String, String> params = new HashMap<>(); params.put(KubeSpecOptions.WORKER_INSTANCES.name(), "10"); String jobId = this.driver.submitJob("PageRank", params); HugeGraphComputerJob computerJob = this.operation.withName(KubeUtil.crName(jobId)).get(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(computerJob.getSpec().getAlgorithmName(), "PageRank"); Assert.assertEquals(computerJob.getSpec().getJobId(), jobId); }
submitJob(String algorithmName, Map<String, String> params) { HugeGraphComputerJob computerJob = new HugeGraphComputerJob(); String jobId = KubeUtil.genJobId(algorithmName); String crName = KubeUtil.crName(jobId);  ObjectMeta meta = new ObjectMetaBuilder().withNamespace(this.namespace) .withName(crName) .build(); computerJob.setMetadata(meta);  ComputerJobSpec spec = this.computerJobSpec(this.defaultSpec, params);  Map<String, String> computerConf = this.computerConf(this.defaultConf, params); this.checkComputerConf(computerConf, spec);  spec.withAlgorithmName(algorithmName) .withJobId(jobId) .withComputerConf(computerConf);  if (this.enableInternalAlgorithm && this.internalAlgorithms.contains(algorithmName)) { spec.withImage(this.internalAlgorithmImageUrl); } else if (StringUtils.isNotBlank(spec.getRemoteJarUri())) { spec.withImage(this.frameworkImageUrl); } else { String imageUrl = this.buildImageUrl(algorithmName); String jarFileDir = this.conf.get(KubeDriverOptions.JAR_FILE_DIR); String jarFile = this.buildJarFile(jarFileDir, algorithmName); spec.withImage(imageUrl) .withJarFile(jarFile); }  computerJob.setSpec(spec);  this.operation.createOrReplace(computerJob); return jobId; }
[*] target: assertNotNull(computerJob)
[-] pred: org. junit. Assert. assertNotNull ( computerJob )
************************************
************************************
[+] input: testWatchJobAndCancel() { Map<String, String> params = new HashMap<>(); params.put(KubeSpecOptions.WORKER_INSTANCES.name(), "10"); String jobId = this.driver.submitJob("PageRank3", params);  JobObserver jobObserver = Mockito.mock(JobObserver.class);  CompletableFuture<Void> future = this.driver.waitJobAsync(jobId, params, jobObserver);  Mockito.verify(jobObserver, Mockito.timeout(5000L).atLeast(1)) .onJobStateChanged(Mockito.any(DefaultJobState.class));  future.getNow(null);  MutableBoolean watchActive = Whitebox.getInternalState(this.driver, "watchActive"); watchActive.setFalse(); this.driver.waitJobAsync(jobId, params, jobObserver);  this.driver.cancelJob(jobId, params); UnitTestBase.sleep(1000L);  CompletableFuture<Void> future2 = this.driver.waitJobAsync(jobId, params, jobObserver); Assert."<AssertPlaceHolder>"; }
waitJobAsync(String jobId, Map<String, String> params, JobObserver observer) { JobState jobState = this.jobState(jobId, params); if (jobState == null) { LOG.warn("Unable to fetch state of job '{}', it may have been " + "deleted", jobId); return null; } else { observer.onJobStateChanged(jobState); }  CompletableFuture<Void> future = null; synchronized (this.watchActive) { if (!this.watchActive.getValue()) { this.watch = this.initWatch(); this.watchActive.setTrue(); } else { future = new CompletableFuture<>(); this.waits.put(jobId, Pair.of(future, observer)); } }  return future; }
[*] target: assertNull(future2)
[-] pred: org. junit. Assert. assertNull ( future2 )
************************************
************************************
[+] input: testEstimate() { OptimizationContext optimizationContext = mock(OptimizationContext.class); when(optimizationContext.getConfiguration()).thenReturn(new Configuration());  CardinalityEstimator partialEstimator1 = new DefaultCardinalityEstimator(0.9, 1, false, cards -> cards[0] * 2); CardinalityEstimator partialEstimator2 = new DefaultCardinalityEstimator(0.8, 1, false, cards -> cards[0] * 3); CardinalityEstimator estimator = new AggregatingCardinalityEstimator( Arrays.asList(partialEstimator1, partialEstimator2) );  CardinalityEstimate inputEstimate = new CardinalityEstimate(10, 100, 0.3); CardinalityEstimate outputEstimate = estimator.estimate(optimizationContext, inputEstimate); CardinalityEstimate expectedEstimate = new CardinalityEstimate(2 * 10, 2 * 100, 0.3 * 0.9);  Assert."<AssertPlaceHolder>"; }
estimate(OptimizationContext optimizationContext, CardinalityEstimate... inputEstimates) { // Simply use the estimate with the highest correctness probability. // TODO: Check if this is a good way. There are other palpable approaches (e.g., weighted average). return this.alternativeEstimators.stream() .map(alternativeEstimator -> alternativeEstimator.estimate(optimizationContext, inputEstimates)) .sorted((estimate1, estimate2) -> Double.compare(estimate2.getCorrectnessProbability(), estimate1.getCorrectnessProbability())) .findFirst() .orElseThrow(IllegalStateException::new); }
[*] target: assertEquals(expectedEstimate, outputEstimate)
[-] pred: org. junit. Assert. assertEquals ( expectedEstimate, outputEstimate )
************************************
************************************
[+] input: testDAGShapedSubplan() { // _/-\_ //  \ / final DataSetType<String> stringDataSetType = DataSetType.createDefault(String.class); TestMapOperator<String, String> map1 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map1.setName("map1"); TestMapOperator<String, String> map2 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map2.setName("map2"); TestMapOperator<String, String> map3 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map3.setName("map3"); TestJoin<String, String, String> join1 = new TestJoin<>(stringDataSetType, stringDataSetType, stringDataSetType); join1.setName("join1"); TestMapOperator<String, String> map4 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map4.setName("map4");  map1.connectTo(0, map2, 0); map1.connectTo(0, map3, 0); map2.connectTo(0, join1, 0); map3.connectTo(0, join1, 1); join1.connectTo(0, map4, 0);  Subplan subplan = (Subplan) Subplan.wrap(map1, map4); OptimizationContext optimizationContext = new DefaultOptimizationContext(this.job, subplan); final OptimizationContext.OperatorContext subplanCtx = optimizationContext.getOperatorContext(subplan); final CardinalityEstimate inputCardinality = new CardinalityEstimate(10, 100, 0.9d); subplanCtx.setInputCardinality(0, inputCardinality); subplan.propagateInputCardinality(0, subplanCtx);  final CardinalityPusher pusher = SubplanCardinalityPusher.createFor(subplan, this.configuration); pusher.push(subplanCtx, this.configuration);  final CardinalityEstimate outputCardinality = subplanCtx.getOutputCardinality(0); final CardinalityEstimate expectedCardinality = new CardinalityEstimate(10 * 10, 100 * 100, 0.9d * 0.7d); Assert."<AssertPlaceHolder>"; }
createFor(OperatorContainer container, Configuration configuration) { final CompositeOperator compositeOperator = container.toOperator(); final InputSlot<?>[] outerInputs = compositeOperator.getAllInputs(); final List<InputSlot<?>> innerInputs = Arrays.stream(outerInputs) .flatMap(inputSlot -> container.followInput(inputSlot).stream()) .collect(Collectors.toList()); final Collection<Operator> sourceOperators = compositeOperator.isSource() ? Collections.singleton(container.getSource()) : Collections.emptySet(); final CardinalityEstimationTraversal traversal = CardinalityEstimationTraversal.createPushTraversal( innerInputs, sourceOperators, configuration);  return new SubplanCardinalityPusher(traversal, compositeOperator); }
[*] target: assertEquals(expectedCardinality, outputCardinality)
[-] pred: org. junit. Assert. assertEquals ( expectedCardinality, outputCardinality )
************************************
************************************
[+] input: shouldFailOnInvalidInput() { Collection<String> expressions = Arrays.asList( // TODO: For some reason this is not failing on my machine //"2x", "f(x,)", "~3", "", "*2", "f(3, x" ); for (String expression : expressions) { boolean isFailed = false; try { ExpressionBuilder.parse(expression); } catch (ParseException e) { isFailed = true; } finally { Assert."<AssertPlaceHolder>"; } } }
parse(String specification) throws ParseException { MathExLexer lexer = new MathExLexer(new ANTLRInputStream(specification)); lexer.removeErrorListeners(); lexer.addErrorListener(new BaseErrorListener() { @Override public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) { throw new ParseException("Syntax error.", e); } }); MathExParser parser = new MathExParser(new CommonTokenStream(lexer));  // Suppress console output on errors. Throw exceptions instead. parser.removeErrorListeners(); parser.addErrorListener(new BaseErrorListener() { @Override public void syntaxError(Recognizer<?, ?> recognizer, Object o, int i, int i1, String s, RecognitionException e) { throw new ParseException("Syntax error.", e); }  }); MathExParser.ExpressionContext expressionContext = parser.expression();  return new ExpressionBuilder().visit(expressionContext); }
[*] target: assertTrue(isFailed)
[-] pred: org. junit. Assert. assertTrue ( isFailed )
************************************
************************************
[+] input: Exception { final String namespaceName = "testCreateNamespace"; final String namespaceInfo = DEFAULT_TENANT + InlongConstants.SLASH + namespaceName; String param = GSON.toJson(policies); param = param.replaceAll("messageTtlInSeconds", "message_ttl_in_seconds") .replaceAll("retentionPolicies", "retention_policies"); final HttpHeaders headers = new HttpHeaders(); if (StringUtils.isNotEmpty(pulsarClusterInfo.getToken())) { headers.add("Authorization", "Bearer " + pulsarClusterInfo.getToken()); } final MediaType type = MediaType.parseMediaType("application/json; charset=UTF-8"); headers.setContentType(type); headers.add("Accept", MediaType.APPLICATION_JSON.toString());  PulsarUtils.createNamespace(client, pulsarCluster, DEFAULT_TENANT, namespaceName, policies); Thread.sleep(500); List<String> namespaces = PulsarUtils.getNamespaces(client, pulsarCluster, DEFAULT_TENANT); "<AssertPlaceHolder>"; }
getNamespaces(RestTemplate restTemplate, PulsarClusterInfo clusterInfo, String tenant) throws Exception { return HttpUtils.request(restTemplate, clusterInfo.getAdminUrls(QUERY_NAMESPACE_PATH + "/" + tenant), HttpMethod.GET, null, getHttpHeaders(clusterInfo.getToken()), ArrayList.class); }
[*] target: assertTrue(namespaces.contains(namespaceInfo))
[-] pred: org. junit. Assert. assertTrue ( namespaces. contains ( namespaceInfo ) )
************************************
************************************
[+] input: Exception { final String topicPath = DEFAULT_TENANT + InlongConstants.SLASH + DEFAULT_NAMESPACE + InlongConstants.SLASH + "testGetInternalStatsPartitionedTopics";  PulsarUtils.createPartitionedTopic(client, pulsarCluster, topicPath, DEFAULT_PARTITIONS_NUM); Thread.sleep(500); JsonObject stats = PulsarUtils.getInternalStatsPartitionedTopics(client, pulsarCluster, topicPath); "<AssertPlaceHolder>"; }
getInternalStatsPartitionedTopics(RestTemplate restTemplate, PulsarClusterInfo clusterInfo, String topicPath) throws Exception { return HttpUtils.request(restTemplate, clusterInfo.getAdminUrls(QUERY_PERSISTENT_PATH + "/" + topicPath + "/partitioned-internalStats"), HttpMethod.GET, null, getHttpHeaders(clusterInfo.getToken()), JsonObject.class); }
[*] target: assertNotNull(stats)
[-] pred: org. junit. Assert. assertNotNull ( stats )
************************************
************************************
[+] input: Exception { final String topicPath = DEFAULT_TENANT + InlongConstants.SLASH + DEFAULT_NAMESPACE + InlongConstants.SLASH + "testGetPartitionedTopicMetadata"; PulsarUtils.createPartitionedTopic(client, pulsarCluster, topicPath, DEFAULT_PARTITIONS_NUM); Thread.sleep(500); PulsarTopicMetadata metadata = PulsarUtils.getPartitionedTopicMetadata(client, pulsarCluster, topicPath); "<AssertPlaceHolder>"; }
getPartitionedTopicMetadata(RestTemplate restTemplate, PulsarClusterInfo clusterInfo, String topicPath) throws Exception { return HttpUtils.request(restTemplate, clusterInfo.getAdminUrls(QUERY_PERSISTENT_PATH + "/" + topicPath + "/partitions"), HttpMethod.GET, null, getHttpHeaders(clusterInfo.getToken()), PulsarTopicMetadata.class); }
[*] target: assertNotNull(metadata)
[-] pred: org. junit. Assert. assertNotNull ( metadata )
************************************
************************************
[+] input: testAddFetcher() { TopicManager inLongTopicManager = InlongTopicManagerFactory .createSingleTopicManager(clientContext, queryConsumeConfig);  TopicFetcher inLongTopicFetcher = inLongTopicManager.addTopic(inLongTopic); Assert."<AssertPlaceHolder>"; }
addTopic(InLongTopic topic) {  try { TopicFetcher result = fetchers.get(topic.getTopicKey()); if (result == null) { // create fetcher (pulsar,tube,kafka) TopicFetcher topicFetcher = createInLongTopicFetcher(topic); TopicFetcher preValue = fetchers.putIfAbsent(topic.getTopicKey(), topicFetcher); LOGGER.info("addFetcher :{}", topic.getTopicKey()); result = topicFetcher; if (preValue != null) { result = preValue; if (topicFetcher != null) { topicFetcher.close(); } LOGGER.info("addFetcher create same fetcher {}", topic); } } return result; } catch (Throwable t) { LOGGER.error("got error when add fetcher: {}", t.getMessage(), t); return null; } }
[*] target: assertNull(inLongTopicFetcher)
[-] pred: org. junit. Assert. assertNull ( inLongTopicFetcher )
************************************
************************************
[+] input: testRemoveFetcher() {  TopicFetcher topicFetcher = topicManager.removeTopic(inLongTopic, true); Assert.assertNull(topicFetcher);  ConcurrentHashMap<String, TopicFetcher> fetchers = new ConcurrentHashMap<>(); TopicFetcher inLongTopicFetcherRmMock = PowerMockito.mock(TopicFetcher.class); fetchers.put(inLongTopic.getTopicKey(), inLongTopicFetcherRmMock);  Whitebox.setInternalState(topicManager, "fetchers", fetchers);  topicFetcher = topicManager.removeTopic(inLongTopic, true); Assert."<AssertPlaceHolder>";  }
removeTopic(InLongTopic topic, boolean closeFetcher) { TopicFetcher result = fetchers.remove(topic.getTopicKey()); if (result != null && closeFetcher) { result.close(); } return result; }
[*] target: assertNotNull(topicFetcher)
[-] pred: org. junit. Assert. assertNotNull ( topicFetcher )
************************************
************************************
[+] input: testClean() { boolean clean = topicManager.clean(); Assert."<AssertPlaceHolder>"; }
clean() { String sortTaskId = context.getConfig().getSortTaskId(); try { LOGGER.info("start close {}", sortTaskId);  if (updateMetaDataWorker != null) { updateMetaDataWorker.stop(); }  closeFetcher(); closePulsarClient(); closeTubeSessionFactory(); LOGGER.info("close finished {}", sortTaskId); return true; } catch (Throwable th) { LOGGER.error("close error " + sortTaskId, th); } return false; }
[*] target: assertTrue(clean)
[-] pred: org. junit. Assert. assertTrue ( clean )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.COLLECTION_NAME, "STRING METADATA FROM 'collection_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'database_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'op_ts' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_DEBEZIUM, "BYTES METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_DEBEZIUM, "STRING METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); MongoExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.COLLECTION_NAME, MetaField.DATABASE_NAME, MetaField.OP_TS, MetaField.DATA_DEBEZIUM, MetaField.DATA_BYTES_DEBEZIUM, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'meta.database_name' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'meta.schema_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.op_ts' VIRTUAL"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'meta.op_type' VIRTUAL"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES, "BYTES METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'meta.is_ddl' VIRTUAL"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.ts' VIRTUAL"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'meta.sql_type' VIRTUAL"); formatMap.put(MetaField.ORACLE_TYPE, "MAP<STRING, STRING> METADATA FROM 'meta.oracle_type' VIRTUAL"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'meta.pk_names' VIRTUAL"); OracleExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS, MetaField.OP_TYPE, MetaField.DATA, MetaField.DATA_BYTES, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL, MetaField.IS_DDL, MetaField.TS, MetaField.SQL_TYPE, MetaField.ORACLE_TYPE, MetaField.PK_NAMES); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'meta.database_name' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'meta.schema_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.op_ts' VIRTUAL"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'meta.op_type' VIRTUAL"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_DEBEZIUM, "STRING METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES, "BYTES METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_DEBEZIUM, "BYTES METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'meta.is_ddl' VIRTUAL"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.ts' VIRTUAL"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'meta.sql_type' VIRTUAL"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'meta.pk_names' VIRTUAL"); PostgresExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS, MetaField.OP_TYPE, MetaField.DATA, MetaField.DATA_BYTES, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL, MetaField.DATA_DEBEZIUM, MetaField.DATA_BYTES_DEBEZIUM, MetaField.IS_DDL, MetaField.TS, MetaField.SQL_TYPE, MetaField.PK_NAMES); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'database_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'op_ts' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'schema_name' VIRTUAL"); SqlServerExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'value.data_canal'"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'value.data_canal'"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'value.table'"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'value.database'"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'value.type'"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'value.event-timestamp'"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'value.is-ddl'"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'value.ingestion-timestamp'"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'value.sql-type'"); formatMap.put(MetaField.MYSQL_TYPE, "MAP<STRING, STRING> METADATA FROM 'value.mysql-type'"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'value.pk-names'"); formatMap.put(MetaField.BATCH_ID, "BIGINT METADATA FROM 'value.batch-id'"); formatMap.put(MetaField.UPDATE_BEFORE, "ARRAY<MAP<STRING, STRING>> METADATA FROM 'value.update-before'"); KafkaLoadNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.OP_TYPE, MetaField.DATABASE_NAME, MetaField.SQL_TYPE, MetaField.PK_NAMES, MetaField.TS, MetaField.OP_TS, MetaField.IS_DDL, MetaField.MYSQL_TYPE, MetaField.BATCH_ID, MetaField.UPDATE_BEFORE, MetaField.DATA_CANAL, MetaField.DATA); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: Exception { EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() .build(); StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(1); env.enableCheckpointing(10000); StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env, settings); // step 1. Register custom function of json getter tableEnv.createTemporaryFunction("JSON_GETTER", JsonGetterFunction.class); // step 2. Generate test data and convert to DataStream List<Row> data = new ArrayList<>(); data.add(Row.of("{"name":"abc"}")); TypeInformation<?>[] types = { BasicTypeInfo.STRING_TYPE_INFO}; String[] names = {"content"}; RowTypeInfo typeInfo = new RowTypeInfo(types, names); DataStream<Row> dataStream = env.fromCollection(data).returns(typeInfo);  // step 3. Convert from DataStream to Table and execute the json getter function Table tempView = tableEnv.fromDataStream(dataStream).as("content"); tableEnv.createTemporaryView("temp_view", tempView);  org.apache.inlong.sort.protocol.transformation.function.JsonGetterFunction jsonGetterFunction = new org.apache.inlong.sort.protocol.transformation.function.JsonGetterFunction( new FieldInfo("content", new StringFormatInfo()), new StringConstantParam("name"));  String sqlQuery = String.format("SELECT %s as content FROM temp_view", jsonGetterFunction.format()); Table outputTable = tableEnv.sqlQuery(sqlQuery); // step 4. Get function execution result and parse it DataStream<Row> resultSet = tableEnv.toAppendStream(outputTable, Row.class); List<String> result = new ArrayList<>();  for (CloseableIterator<String> it = resultSet.map(s -> s.getField(0).toString()).executeAndCollect(); it .hasNext();) { String next = it.next(); result.add(next); }  // step 5. Whether the comparison results are as expected String expect = "abc"; Assert."<AssertPlaceHolder>"; }
format() { return String.format("%s(CAST(%s AS STRING), %s)", getName(), field.format(), key.format()); }
[*] target: assertEquals(expect, result.get(0))
[-] pred: org. junit. Assert. assertEquals ( expect, result. get ( 0 ) )
************************************
************************************
[+] input: Exception { // step 0. Initialize the execution environment EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() .build(); StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(1); env.enableCheckpointing(10000); StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env, settings); // step 1. Register custom function of REGEXP_REPLACE_FIRST tableEnv.createTemporaryFunction("REGEXP_REPLACE_FIRST", RegexpReplaceFirstFunction.class); // step 2. Generate test data and convert to DataStream List<Row> data = new ArrayList<>(); data.add(Row.of("inlong is a data integration tool and inlong has been used by many companies")); TypeInformation<?>[] types = { BasicTypeInfo.STRING_TYPE_INFO}; String[] names = {"f1"}; RowTypeInfo typeInfo = new RowTypeInfo(types, names); DataStream<Row> dataStream = env.fromCollection(data).returns(typeInfo); // step 3. Convert from DataStream to Table and execute the REGEXP_REPLACE_FIRST function Table tempView = tableEnv.fromDataStream(dataStream).as("f1"); tableEnv.createTemporaryView("temp_view", tempView); org.apache.inlong.sort.protocol.transformation.function.RegexpReplaceFirstFunction regexpReplaceFirstFunction = new org.apache.inlong.sort.protocol.transformation.function.RegexpReplaceFirstFunction( new FieldInfo("f1", new StringFormatInfo()), new StringConstantParam("inlong*"), new StringConstantParam("INLONG")); String sqlQuery = String.format("SELECT %s as f1 FROM temp_view", regexpReplaceFirstFunction.format()); Table outputTable = tableEnv.sqlQuery(sqlQuery); // step 4. Get function execution result and parse it DataStream<Row> resultSet = tableEnv.toAppendStream(outputTable, Row.class); List<String> result = new ArrayList<>(); for (CloseableIterator<String> it = resultSet.map(s -> s.getField(0).toString()).executeAndCollect(); it .hasNext();) { String next = it.next(); result.add(next); } // step 5. Whether the comparison results are as expected String expect = "INLONG is a data integration tool and inlong has been used by many companies"; Assert."<AssertPlaceHolder>"; }
format() { return String.format("%s(%s, %s, %s)", getName(), field.format(), regex.format(), replacement.format()); }
[*] target: assertEquals(expect, result.get(0))
[-] pred: org. junit. Assert. assertEquals ( expect, result. get ( 0 ) )
************************************
************************************
[+] input: testCounting() { final ThreadSafeCounter counter = new ThreadSafeCounter(); counter.inc(); assertEquals(1, counter.getCount()); counter.inc(100); assertEquals(101, counter.getCount()); counter.dec(); assertEquals(100, counter.getCount()); counter.dec(99); "<AssertPlaceHolder>"; }
getCount() { return count.get(); }
[*] target: assertEquals(1, counter.getCount())
[-] pred: org. junit. Assert. assertEquals ( 1, counter. getCount() )
************************************
************************************
[+] input: testCustomFieldsPartitioner() { SingleTableCustomFieldsPartitioner singleTableCustomFieldsPartitioner = new SingleTableCustomFieldsPartitioner();  TableSchema schema = TableSchema.builder() .field("id", DataTypes.INT()) .field("age", DataTypes.INT()) .build();  singleTableCustomFieldsPartitioner.setSchema(schema); singleTableCustomFieldsPartitioner.setPartitionKey("age");  FieldGetter getter0 = RowData.createFieldGetter(new IntType(), 0); FieldGetter getter1 = RowData.createFieldGetter(new IntType(), 1); FieldGetter[] valuefieldgetters = {getter0, getter1};  singleTableCustomFieldsPartitioner.setValueFieldGetters(valuefieldgetters);  BinaryRowData rowData1 = new BinaryRowData(2); BinaryRowWriter writer1 = new BinaryRowWriter(rowData1); BinaryRowData rowData2 = new BinaryRowData(2); BinaryRowWriter writer2 = new BinaryRowWriter(rowData2);  writer1.writeInt(0, 1); writer1.writeInt(1, 786819156);  writer2.writeInt(0, 2); writer2.writeInt(1, 786819156);  // key is null since the actual key is being calculated from deserialized json int partition1 = singleTableCustomFieldsPartitioner.partition(rowData1, null, null, null, new int[]{0, 1, 2, 3, 4});  int partition2 = singleTableCustomFieldsPartitioner.partition(rowData2, null, null, null, new int[]{0, 1, 2, 3, 4});  writer1.complete(); writer2.complete();  Assert."<AssertPlaceHolder>"; }
setValueFieldGetters(FieldGetter[] fieldGetters) { this.valueFieldGetters = fieldGetters; }
[*] target: assertEquals(partition1, partition2)
[-] pred: org. junit. Assert. assertEquals ( partition1, partition2 )
************************************
************************************
[+] input: testRowType() { InLongMsgCsvFormatDeserializer deserializer = new InLongMsgCsvFormatDeserializer.Builder(TEST_ROW_INFO).build();  TypeInformation<Row> expectedRowType = Types.ROW_NAMED( new String[]{ DEFAULT_TIME_FIELD_NAME, DEFAULT_ATTRIBUTES_FIELD_NAME, "f1", "f2", "f3", "f4", "f5", "f6" }, Types.SQL_TIMESTAMP, Types.MAP(Types.STRING, Types.STRING), Types.INT, Types.INT, Types.INT, Types.STRING, Types.STRING, Types.STRING);  "<AssertPlaceHolder>"; }
getProducedType() { return InLongMsgUtils.decorateRowTypeWithNeededHeadFields(timeFieldName, attributesFieldName, rowFormatInfo); }
[*] target: assertEquals(expectedRowType, deserializer.getProducedType())
[-] pred: org. junit. Assert. assertEquals ( expectedRowType, deserializer. getProducedType ( ) )
************************************
************************************
[+] input: testRowTypeWithHeadFields() { InLongMsgCsvFormatDeserializer deserializer = new InLongMsgCsvFormatDeserializer.Builder(TEST_ROW_INFO) .setTimeFieldName("inlongmsg_time") .setAttributesFieldName("inlongmsg_attributes") .build();  TypeInformation<Row> expectedRowType = Types.ROW_NAMED( new String[]{ "inlongmsg_time", "inlongmsg_attributes", "f1", "f2", "f3", "f4", "f5", "f6" }, Types.SQL_TIMESTAMP, Types.MAP(Types.STRING, Types.STRING), Types.INT, Types.INT, Types.INT, Types.STRING, Types.STRING, Types.STRING);  "<AssertPlaceHolder>"; }
getProducedType() { return InLongMsgUtils.decorateRowTypeWithNeededHeadFields(timeFieldName, attributesFieldName, rowFormatInfo); }
[*] target: assertEquals(expectedRowType, deserializer.getProducedType())
[-] pred: org. junit. Assert. assertEquals ( expectedRowType, deserializer. getProducedType ( ) )
************************************
************************************
[+] input: testDeSeSchema() { final CsvRowDataDeserializationSchema expectedDeSer = new CsvRowDataDeserializationSchema.Builder( testFormatInfo, testTypeInformation) .setCharset("UTF-8") .setFieldDelimiter(';') .setQuoteCharacter(''') .setEscapeCharacter('\') .setNullLiteral("n/a") .build(); final Map<String, String> options = getAllOptions(); DeserializationSchema<RowData> actualDeser = createDeserializationSchema(options); assertEquals(expectedDeSer, actualDeser);  final CsvRowDataSerializationSchema expectedSer = new CsvRowDataSerializationSchema.Builder(testFormatInfo) .setCharset("UTF-8") .setFieldDelimiter(';') .setQuoteCharacter(''') .setEscapeCharacter('\') .setNullLiteral("n/a") .build(); SerializationSchema<RowData> actualSer = createSerializationSchema(options); "<AssertPlaceHolder>"; }
createSerializationSchema( Map<String, String> properties) { DescriptorProperties descriptorProperties = getValidatedProperties(properties); RowFormatInfo rowFormatInfo = getValidatedRowFormatInfo(descriptorProperties);  return buildSerializationSchema(rowFormatInfo, descriptorProperties); }
[*] target: assertEquals(expectedSer, actualSer)
[-] pred: org. junit. Assert. assertEquals ( expectedSer, actualSer )
************************************
************************************
[+] input: testSchemaDeserializationSchema() { final JsonRowDataDeserializationSchema expectedDeser = JsonRowDataDeserializationSchema.builder(PHYSICAL_TYPE, InternalTypeInfo.of(PHYSICAL_TYPE)).build();  final DynamicTableSource actualSource = createTableSource(SCHEMA, getAllOptions()); assert actualSource instanceof TestDynamicTableFactory.DynamicTableSourceMock; TestDynamicTableFactory.DynamicTableSourceMock scanSourceMock = (TestDynamicTableFactory.DynamicTableSourceMock) actualSource;  DeserializationSchema<RowData> actualDeser = scanSourceMock.valueFormat.createRuntimeDecoder( ScanRuntimeProviderContext.INSTANCE, SCHEMA.toPhysicalRowDataType());  "<AssertPlaceHolder>"; }
createRuntimeDecoder( DynamicTableSource.Context context, DataType physicalDataType) { final RowType rowType = (RowType) physicalDataType.getLogicalType(); final TypeInformation<RowData> rowDataTypeInfo = context.createTypeInformation(physicalDataType); JsonRowDataDeserializationSchema.Builder builder = JsonRowDataDeserializationSchema.builder(rowType, rowDataTypeInfo); return builder .setFailOnMissingField(formatOptions.get(TextFormatOptions.FAIL_ON_MISSING_FIELD)) .setIgnoreParseErrors(formatOptions.get(TableFormatOptions.IGNORE_ERRORS)) .setTimestampFormat(formatOptions.get(TextFormatOptions.TIMESTAMP_FORMAT)) .setCharset(formatOptions.get(TextFormatOptions.CHARSET)) .setObjectMapperConfig(formatOptions) .build(); }
[*] target: assertEquals(expectedDeser, actualDeser)
[-] pred: org. junit. Assert. assertEquals ( expectedDeser, actualDeser )
************************************
************************************
[+] input: testSchemaSerializationSchema() { final JsonRowDataSerializationSchema expectedSer = JsonRowDataSerializationSchema.builder(PHYSICAL_TYPE).build();  final DynamicTableSink actualSink = createTableSink(SCHEMA, getAllOptions()); assert actualSink instanceof TestDynamicTableFactory.DynamicTableSinkMock; TestDynamicTableFactory.DynamicTableSinkMock sinkMock = (TestDynamicTableFactory.DynamicTableSinkMock) actualSink;  SerializationSchema<RowData> actualSer = sinkMock.valueFormat.createRuntimeEncoder( new SinkRuntimeProviderContext(false), PHYSICAL_DATA_TYPE);  "<AssertPlaceHolder>"; }
createRuntimeEncoder( DynamicTableSink.Context context, DataType physicalDataType) { RowType rowType = (RowType) physicalDataType.getLogicalType(); JsonRowDataSerializationSchema.Builder builder = JsonRowDataSerializationSchema.builder(rowType); return builder .setMapNullKeyMode(formatOptions.get(TextFormatOptions.MAP_NULL_KEY_MODE)) .setMapNullKeyLiteral(formatOptions.get(TextFormatOptions.MAP_NULL_KEY_LITERAL)) .setTimestampFormat(formatOptions.get(TextFormatOptions.TIMESTAMP_FORMAT)) .setCharset(formatOptions.get(TextFormatOptions.CHARSET)) .setIgnoreErrors(formatOptions.get(TableFormatOptions.IGNORE_ERRORS)) .setObjectMapperConfig(formatOptions) .build(); }
[*] target: assertEquals(expectedSer, actualSer)
[-] pred: org. junit. Assert. assertEquals ( expectedSer, actualSer )
************************************
************************************
[+] input: IOException { JsonRowDataSerializationSchema.Builder serBuilder = JsonRowDataSerializationSchema.builder(rowType); JsonRowDataSerializationSchema serializationSchema = serBuilder.setCharset(CHARSET.defaultValue()) .setTimestampFormat(ISO_8601) .build(); byte[] serialize = serializationSchema.serialize(testRowData);  ObjectMapper objectMapper = new ObjectMapper(); JsonNode expectedNode = objectMapper.readTree(testJson); JsonNode actualNode = objectMapper.readTree(new String(serialize)); "<AssertPlaceHolder>"; assertFalse(serializationSchema.skipCurrentRecord(testRowData)); }
build() { return new JsonRowDataSerializationSchema( rowType, timestampFormat, mapNullKeyMode, mapNullKeyLiteral, charset, objectMapper, ignoreErrors); }
[*] target: assertEquals(expectedNode, actualNode)
[-] pred: org. junit. Assert. assertEquals ( expectedNode, actualNode )
************************************
************************************
[+] input: Exception { TubeClientConfig clientConfig = mock(TubeClientConfig.class); PowerMockito.mockStatic(AddressUtils.class); PowerMockito.when(AddressUtils.getLocalAddress()).thenReturn("127.0.0.1");  when(clientConfig.getMasterInfo()).thenReturn(new MasterInfo("127.0.0.1:18080")); ConsumerConfig config = new ConsumerConfig("127.0.0.1:18080", "test"); ClientFactory clientFactory = new NettyClientFactory(); TubeBaseSessionFactory factory = new TubeBaseSessionFactory(clientFactory, clientConfig); SimplePushMessageConsumer consumer = new SimplePushMessageConsumer(factory, config); MessageFetchManager fetchManager = new MessageFetchManager(config, consumer);  Assert.assertFalse(fetchManager.isShutdown()); fetchManager.startFetchWorkers(); fetchManager.stopFetchWorkers(true); Assert."<AssertPlaceHolder>"; }
isShutdown() { return this.managerStatus.get() == 0; }
[*] target: assertTrue(fetchManager.isShutdown())
[-] pred: org. junit. Assert. assertTrue ( fetchManager. isShutdown() )
************************************
************************************
[+] input: Exception { RpcServiceFactory rpcServiceFactory = mock(RpcServiceFactory.class); when(rpcServiceFactory.getForbiddenAddrMap()).thenReturn(new ConcurrentHashMap<String, Long>()); when(rpcServiceFactory.getUnavailableBrokerMap()).thenReturn(new ConcurrentHashMap<Integer, Long>());  TubeClientConfig config = mock(TubeClientConfig.class); when(config.getSessionMaxAllowedDelayedMsgCount()).thenReturn(1000L);  DefaultBrokerRcvQltyStats stats = new DefaultBrokerRcvQltyStats(rpcServiceFactory, config); stats.startBrokerStatistic(); assertFalse(stats.isStopped());  stats.addSendStatistic(0); stats.addReceiveStatistic(0, true);  stats.statisticDltBrokerStatus();  // Test getAllowedBrokerPartitions Map<Integer, List<Partition>> brokerPartList = new HashMap<>(); List<Partition> partitions = new ArrayList<>(); partitions.add(new Partition(new BrokerInfo("0:127.0.0.1:18080"), "test_topic", 1)); brokerPartList.put(0, partitions);  List<Partition> actualPartitions = stats.getAllowedBrokerPartitions(brokerPartList); assertEquals(1, actualPartitions.size()); assertEquals(1, actualPartitions.get(0).getPartitionId());  // Unregister and stop statistic server stats.removeUnRegisteredBroker(new ArrayList<Integer>()); stats.stopBrokerStatistic(); "<AssertPlaceHolder>"; }
isStopped() { return (this.statusId.get() > 0); }
[*] target: assertTrue(stats.isStopped())
[-] pred: org. junit. Assert. assertTrue ( stats. isStopped() )
************************************
************************************
[+] input: Exception { final BrokerConfig brokerConfig = new BrokerConfig(); Path configUrl = Paths.get(Objects.requireNonNull( getClass().getClassLoader().getResource("broker_audit_prom_1.ini")).toURI()); brokerConfig.loadFromFile(configUrl.toString());  final ADConfig auditConfig = brokerConfig.getAuditConfig(); Assert.assertTrue(auditConfig.isAuditEnable()); Assert.assertEquals(auditConfig.getAuditIdProduce(), 3); Assert.assertEquals(auditConfig.getAuditIdConsume(), 4); Assert.assertEquals(auditConfig.getAuditCacheMaxRows(), 20000); Assert.assertEquals(auditConfig.getAuditCacheFilePath(), "/data/inlong/audit/test"); HashSet<String> valueSet = new HashSet<>(Arrays.asList("127.0.0.2:10081", "127.0.0.3:10081")); Assert.assertEquals(auditConfig.getAuditProxyAddrSet(), valueSet);  final PrometheusConfig promConfig = brokerConfig.getPrometheusConfig(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(promConfig.getPromHttpPort(), 9088); Assert.assertEquals(promConfig.getPromClusterName(), "Test"); }
isPromEnable() { return this.prometheusConfig.isPromEnable(); }
[*] target: assertTrue(promConfig.isPromEnable())
[-] pred: org. junit. Assert. assertTrue ( promConfig. isPromEnable ( ) )
************************************
************************************
[+] input: getBooleanParamValueTest() { boolean retValue; StringBuilder sBuffer = new StringBuilder(512); ProcessResult result = new ProcessResult(); Map<String, String> paramCntrMap = new HashMap<>(); // case 1 retValue = WebParameterUtils.getBooleanParamValue(paramCntrMap, WebFieldDef.WITHIP, true, null, sBuffer, result); Assert.assertFalse(retValue); Assert.assertFalse(result.isSuccess()); // case 2 paramCntrMap.clear(); paramCntrMap.put(WebFieldDef.WITHIP.name, "1"); retValue = WebParameterUtils.getBooleanParamValue(paramCntrMap, WebFieldDef.WITHIP, true, null, sBuffer, result); Assert.assertTrue(retValue); Assert.assertTrue(result.isSuccess()); Boolean paraDataObj = (Boolean) result.getRetData(); Assert.assertEquals(paraDataObj, Boolean.TRUE); // case 3 paramCntrMap.clear(); paramCntrMap.put(WebFieldDef.WITHIP.name, "false"); retValue = WebParameterUtils.getBooleanParamValue(paramCntrMap, WebFieldDef.WITHIP, true, null, sBuffer, result); Assert."<AssertPlaceHolder>"; Assert.assertTrue(result.isSuccess()); paraDataObj = (Boolean) result.getRetData(); Assert.assertEquals(paraDataObj, Boolean.FALSE); }
getBooleanParamValue(T paramCntr, WebFieldDef fieldDef, boolean required, Boolean defValue, StringBuilder sBuffer, ProcessResult result) { if (!getStringParamValue(paramCntr, fieldDef, required, null, sBuffer, result)) { return result.isSuccess(); } String paramValue = (String) result.getRetData(); if (paramValue == null) { result.setSuccResult(defValue); return result.isSuccess(); } if (paramValue.equalsIgnoreCase("true") || paramValue.equalsIgnoreCase("false")) { result.setSuccResult(Boolean.parseBoolean(paramValue)); } else { try { result.setSuccResult(!(Long.parseLong(paramValue) == 0)); } catch (Throwable e) { result.setSuccResult(defValue); } } return result.isSuccess(); }
[*] target: assertTrue(retValue)
[-] pred: org. junit. Assert. assertTrue ( retValue )
************************************
************************************
[+] input: getTopicPropInfoTest() { StringBuilder sBuffer = new StringBuilder(512); ProcessResult result = new ProcessResult(); Map<String, String> paramCntrMap = new HashMap<>(); // case 1 paramCntrMap.put(WebFieldDef.NUMTOPICSTORES.name, "1"); paramCntrMap.put(WebFieldDef.NUMPARTITIONS.name, "2"); paramCntrMap.put(WebFieldDef.UNFLUSHTHRESHOLD.name, "3"); paramCntrMap.put(WebFieldDef.UNFLUSHINTERVAL.name, "4"); paramCntrMap.put(WebFieldDef.UNFLUSHDATAHOLD.name, "5"); paramCntrMap.put(WebFieldDef.MCACHESIZEINMB.name, "2"); paramCntrMap.put(WebFieldDef.UNFMCACHECNTINK.name, "7"); paramCntrMap.put(WebFieldDef.UNFMCACHEINTERVAL.name, "4000"); paramCntrMap.put(WebFieldDef.ACCEPTPUBLISH.name, "true"); paramCntrMap.put(WebFieldDef.ACCEPTSUBSCRIBE.name, "false"); paramCntrMap.put(WebFieldDef.DATASTORETYPE.name, "9"); paramCntrMap.put(WebFieldDef.DATAPATH.name, "test"); paramCntrMap.put(WebFieldDef.DELETEPOLICY.name, "delete,2h"); boolean retValue = WebParameterUtils.getTopicPropInfo(paramCntrMap, null, sBuffer, result); Assert.assertTrue(retValue); Assert.assertTrue(result.isSuccess()); TopicPropGroup retEntry = (TopicPropGroup) result.getRetData(); Assert.assertEquals(retEntry.getNumTopicStores(), Integer.parseInt(paramCntrMap.get(WebFieldDef.NUMTOPICSTORES.name))); // case 2 paramCntrMap.clear(); TopicPropGroup defOpEntity = new TopicPropGroup(); defOpEntity.fillDefaultValue(); paramCntrMap.put(WebFieldDef.ACCEPTPUBLISH.name, "0"); paramCntrMap.put(WebFieldDef.NUMTOPICSTORES.name, "9"); paramCntrMap.put(WebFieldDef.UNFMCACHECNTINK.name, "100"); retValue = WebParameterUtils.getTopicPropInfo(paramCntrMap, defOpEntity, sBuffer, result); Assert."<AssertPlaceHolder>"; Assert.assertTrue(result.isSuccess()); retEntry = (TopicPropGroup) result.getRetData();  }
getTopicPropInfo(T paramCntr, TopicPropGroup defVal, StringBuilder sBuffer, ProcessResult result) { TopicPropGroup newConf = new TopicPropGroup(); // get numTopicStores parameter value if (!WebParameterUtils.getIntParamValue(paramCntr, WebFieldDef.NUMTOPICSTORES, false, (defVal == null ? TBaseConstants.META_VALUE_UNDEFINED : defVal.getNumTopicStores()), TServerConstants.TOPIC_STOREBLOCK_NUM_MIN, sBuffer, result)) { return result.isSuccess(); } newConf.setNumTopicStores((int) result.getRetData()); // get numPartitions parameter value if (!WebParameterUtils.getIntParamValue(paramCntr, WebFieldDef.NUMPARTITIONS, false, (defVal == null ? TBaseConstants.META_VALUE_UNDEFINED : defVal.getNumPartitions()), TServerConstants.TOPIC_PARTITION_NUM_MIN, sBuffer, result)) { return result.isSuccess(); } newConf.setNumPartitions((int) result.getRetData()); // get unflushThreshold parameter value if (!WebParameterUtils.getIntParamValue(paramCntr, WebFieldDef.UNFLUSHTHRESHOLD, false, (defVal == null ? TBaseConstants.META_VALUE_UNDEFINED : defVal.getUnflushThreshold()), TServerConstants.TOPIC_DSK_UNFLUSHTHRESHOLD_MIN, sBuffer, result)) { return result.isSuccess(); } newConf.setUnflushThreshold((int) result.getRetData()); // get unflushInterval parameter value if (!WebParameterUtils.getIntParamValue(paramCntr, WebFieldDef.UNFLUSHINTERVAL, false, (defVal == null ? TBaseConstants.META_VALUE_UNDEFINED : defVal.getUnflushInterval()), TServerConstants.TOPIC_DSK_UNFLUSHINTERVAL_MIN, sBuffer, result)) { return result.isSuccess(); } newConf.setUnflushInterval((int) result.getRetData()); // get unflushDataHold parameter value if (!WebParameterUtils.getIntParamValue(paramCntr, WebFieldDef.UNFLUSHDATAHOLD, false, (defVal == null ? TBaseConstants.META_VALUE_UNDEFINED : defVal.getUnflushDataHold()), TServerConstants.TOPIC_DSK_UNFLUSHDATAHOLD_MIN, sBuffer, result)) { return result.isSuccess(); } newConf.setUnflushDataHold((int) result.getRetData()); // get memCacheMsgSizeInMB parameter value if (!WebParameterUtils.getIntParamValue(paramCntr, WebFieldDef.MCACHESIZEINMB, false, (defVal == null ? TBaseConstants.META_VALUE_UNDEFINED : defVal.getMemCacheMsgSizeInMB()), TServerConstants.TOPIC_CACHESIZE_MB_MIN, TServerConstants.TOPIC_CACHESIZE_MB_MAX, sBuffer, result)) { return result.isSuccess(); } newConf.setMemCacheMsgSizeInMB((int) result.getRetData()); // get memCacheFlushIntvl parameter value if (!WebParameterUtils.getIntParamValue(paramCntr, WebFieldDef.UNFMCACHEINTERVAL, false, (defVal == null ? TBaseConstants.META_VALUE_UNDEFINED : defVal.getMemCacheFlushIntvl()), TServerConstants.TOPIC_CACHEINTVL_MIN, sBuffer, result)) { return result.isSuccess(); } newConf.setMemCacheFlushIntvl((int) result.getRetData()); // get memCacheMsgCntInK parameter value if (!WebParameterUtils.getIntParamValue(paramCntr, WebFieldDef.UNFMCACHECNTINK, false, (defVal == null ? TBaseConstants.META_VALUE_UNDEFINED : defVal.getMemCacheMsgCntInK()), TServerConstants.TOPIC_CACHECNT_INK_MIN, sBuffer, result)) { return result.isSuccess(); } newConf.setMemCacheMsgCntInK((int) result.getRetData()); // get deletePolicy parameter value if (!WebParameterUtils.getDeletePolicyParameter(paramCntr, false, (defVal == null ? null : defVal.getDeletePolicy()), sBuffer, result)) { return result.isSuccess(); } newConf.setDeletePolicy((String) result.getRetData()); // get acceptPublish parameter value if (!WebParameterUtils.getBooleanParamValue(paramCntr, WebFieldDef.ACCEPTPUBLISH, false, (defVal == null ? null : defVal.getAcceptPublish()), sBuffer, result)) { return result.isSuccess(); } newConf.setAcceptPublish((Boolean) result.getRetData()); // get acceptSubscribe parameter value if (!WebParameterUtils.getBooleanParamValue(paramCntr, WebFieldDef.ACCEPTSUBSCRIBE, false, (defVal == null ? null : defVal.getAcceptSubscribe()), sBuffer, result)) { return result.isSuccess(); } newConf.setAcceptSubscribe((Boolean) result.getRetData()); result.setSuccResult(newConf); return result.isSuccess(); }
[*] target: assertTrue(retValue)
[-] pred: org. junit. Assert. assertTrue ( retValue )
************************************
************************************
[+] input: Exception { Map<String, String> map = new HashMap<String, String>(); map.put("h1", "1");  PowerMockito.doReturn(401).when(connection).getResponseCode(); PowerMockito.doReturn(new ByteArrayOutputStream()).when(connection).getOutputStream(); PowerMockito.doReturn(new ByteArrayInputStream("{}".getBytes())).when(connection).getInputStream(); HttpClientTest response = new HttpClient("http://localhost") .path("/api") .param(map) .header(map) .timeout(100) .body(new ByteArrayInputStream(new byte[]{})) .get(HttpClientTest.class); Assert."<AssertPlaceHolder>"; }
get(Class<T> returnType) { return requestRetryTimes("GET", returnType); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: Exception { Map<String, String> map = new HashMap<String, String>(); map.put("h1", "1");  PowerMockito.doReturn(401).when(connection).getResponseCode(); PowerMockito.doReturn(new ByteArrayOutputStream()).when(connection).getOutputStream(); PowerMockito.doReturn(new ByteArrayInputStream("{}".getBytes())).when(connection).getInputStream();  InputStream inputStreamBody = Mockito.spy(new ByteArrayInputStream(new byte[]{})); Mockito.doThrow(new IOException()).when(inputStreamBody).close();  HttpClientTest response = new HttpClient("http://localhost") .path("/api") .param(map) .header(map) .timeout(100) .body(inputStreamBody) .post(HttpClientTest.class); Assert."<AssertPlaceHolder>"; }
post(Class<T> returnType) { return requestRetryTimes("POST", returnType); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: Exception { ShellHookResponse shellHookResponse = HookExecuteFactory.execute(null, null, null, jobLogger); Assert."<AssertPlaceHolder>"; }
execute(ShellHook shellHook, String uuid, String ws, IJobLogger jobLogger) { if (null == shellHook) { jobLogger.log("ERROR", "null hook!"); return null; } if (shellHook instanceof ShellCovHook) { return covHookExecutor.triggerHook(shellHook, uuid, ws, jobLogger); } else if (shellHook instanceof ShellInvalidateGitSshHook) { return invalidateGitSshHookExecutor.triggerHook(shellHook, uuid, ws, jobLogger); } else if (shellHook instanceof ShellCoverageHook) { return coverageHookExecutor.triggerHook(shellHook, uuid, ws, jobLogger); } else if (shellHook instanceof BosUploadHook) { return bosUploadHookExecutor.triggerHook(shellHook, uuid, ws, jobLogger); } jobLogger.log("ERROR", "unknown hook: " + shellHook.getClass()); return null; }
[*] target: assertNull(shellHookResponse)
[-] pred: org. junit. Assert. assertNull ( shellHookResponse )
************************************
************************************
[+] input: Exception { File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.isAbsolute()).thenReturn(true);  DirFileScanner scanner = Mockito.mock(DirFileScanner.class); PowerMockito.whenNew(DirFileScanner.class).withAnyArguments().thenReturn(scanner); Mockito.when(scanner.scan(Mockito.anyString())).thenReturn(Arrays.asList("f1"));  Artifact artifact = new Artifact(); artifact.setPatternType(PatternType.DIR);  FileUploader fileUploader = new FileUploader() { @Override public void upload(File file, String toFile) { } };  int filesCount = new JobArtifact("u1", "ws", new SaAsyncLogger("uuid", true)) .artifact(artifact) .fileUploader(fileUploader) .toDir("d1") .upload();  Assert."<AssertPlaceHolder>"; }
upload() { FileScanner scanner; String fromDir = this.ws; switch (artifact.getPatternType()) { case DIR: if (new File(artifact.getFilePattern()).isAbsolute()) { fromDir = artifact.getFilePattern(); } else { fromDir = fromDir + File.separator + artifact.getFilePattern(); } // 当路径所指的目标是单文件时，直接读取单上传文件。 if (new File(fromDir).exists() && new File(fromDir).isFile()) { String fileName = FilenameUtils.getName(FilenameUtils.normalizeNoEndSeparator(fromDir)); String toFile = uuid + "/" + toDir + "/" + fileName; jobAsyncLogger.log("INFO", "single file uploading..."); fileUploader.upload(new File(fromDir), toFile); return 1; } scanner = new DirFileScanner(artifact.getFilePattern()); break; case ANT: scanner = new AntFileScanner(artifact.getFilePattern()); break; default: throw new AgentException("Not supported file pattern type:" + artifact.getPatternType()); } List<String> files = scanner.scan(ws); if (CollectionUtils.isEmpty(files)) { return 0; } new FilesUploader(jobAsyncLogger) .fromDir(fromDir) .files(files) .toDir(uuid + "/" + toDir) .fileUploader(fileUploader).upload(); return files.size(); }
[*] target: assertEquals(1, filesCount)
[-] pred: org. junit. Assert. assertEquals ( 1, filesCount )
************************************
************************************
[+] input: Exception { File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.isAbsolute()).thenReturn(false);  DirFileScanner scanner = Mockito.mock(DirFileScanner.class); PowerMockito.whenNew(DirFileScanner.class).withAnyArguments().thenReturn(scanner); Mockito.when(scanner.scan(Mockito.anyString())).thenReturn(Arrays.asList("f1"));  Artifact artifact = new Artifact(); artifact.setPatternType(PatternType.DIR);  FileUploader fileUploader = new FileUploader() { @Override public void upload(File file, String toFile) { } };  int filesCount = new JobArtifact("u1", "ws", new SaAsyncLogger("uuid", true)) .artifact(artifact) .fileUploader(fileUploader) .toDir("d1") .upload();  Assert."<AssertPlaceHolder>"; }
upload() { FileScanner scanner; String fromDir = this.ws; switch (artifact.getPatternType()) { case DIR: if (new File(artifact.getFilePattern()).isAbsolute()) { fromDir = artifact.getFilePattern(); } else { fromDir = fromDir + File.separator + artifact.getFilePattern(); } // 当路径所指的目标是单文件时，直接读取单上传文件。 if (new File(fromDir).exists() && new File(fromDir).isFile()) { String fileName = FilenameUtils.getName(FilenameUtils.normalizeNoEndSeparator(fromDir)); String toFile = uuid + "/" + toDir + "/" + fileName; jobAsyncLogger.log("INFO", "single file uploading..."); fileUploader.upload(new File(fromDir), toFile); return 1; } scanner = new DirFileScanner(artifact.getFilePattern()); break; case ANT: scanner = new AntFileScanner(artifact.getFilePattern()); break; default: throw new AgentException("Not supported file pattern type:" + artifact.getPatternType()); } List<String> files = scanner.scan(ws); if (CollectionUtils.isEmpty(files)) { return 0; } new FilesUploader(jobAsyncLogger) .fromDir(fromDir) .files(files) .toDir(uuid + "/" + toDir) .fileUploader(fileUploader).upload(); return files.size(); }
[*] target: assertEquals(1, filesCount)
[-] pred: org. junit. Assert. assertEquals ( 1, filesCount )
************************************
************************************
[+] input: Exception {  File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.isAbsolute()).thenReturn(false); Mockito.when(file.exists()).thenReturn(true); Mockito.when(file.isFile()).thenReturn(true);  DirFileScanner scanner = Mockito.mock(DirFileScanner.class); PowerMockito.whenNew(DirFileScanner.class).withAnyArguments().thenReturn(scanner); Mockito.when(scanner.scan(Mockito.anyString())).thenReturn(Arrays.asList("f1"));  Artifact artifact = new Artifact(); artifact.setFilePattern("/sss/sss"); artifact.setPatternType(PatternType.DIR); new SaAsyncLogger("uuid", true); FileUploader fileUploader = new FileUploader() { @Override public void upload(File file, String toFile) { } };  int filesCount = new JobArtifact("u1", "ws", new SaAsyncLogger("uuid", true)) .artifact(artifact) .fileUploader(fileUploader) .toDir("d1") .upload();  Assert."<AssertPlaceHolder>"; }
upload() { FileScanner scanner; String fromDir = this.ws; switch (artifact.getPatternType()) { case DIR: if (new File(artifact.getFilePattern()).isAbsolute()) { fromDir = artifact.getFilePattern(); } else { fromDir = fromDir + File.separator + artifact.getFilePattern(); } // 当路径所指的目标是单文件时，直接读取单上传文件。 if (new File(fromDir).exists() && new File(fromDir).isFile()) { String fileName = FilenameUtils.getName(FilenameUtils.normalizeNoEndSeparator(fromDir)); String toFile = uuid + "/" + toDir + "/" + fileName; jobAsyncLogger.log("INFO", "single file uploading..."); fileUploader.upload(new File(fromDir), toFile); return 1; } scanner = new DirFileScanner(artifact.getFilePattern()); break; case ANT: scanner = new AntFileScanner(artifact.getFilePattern()); break; default: throw new AgentException("Not supported file pattern type:" + artifact.getPatternType()); } List<String> files = scanner.scan(ws); if (CollectionUtils.isEmpty(files)) { return 0; } new FilesUploader(jobAsyncLogger) .fromDir(fromDir) .files(files) .toDir(uuid + "/" + toDir) .fileUploader(fileUploader).upload(); return files.size(); }
[*] target: assertEquals(1, filesCount)
[-] pred: org. junit. Assert. assertEquals ( 1, filesCount )
************************************
************************************
[+] input: Exception { HttpDownloader downloader = Mockito.spy(new HttpDownloader()); PowerMockito.whenNew(HttpDownloader.class).withAnyArguments().thenReturn(downloader); Mockito.doNothing().when(downloader).download(); File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.exists()).thenReturn(true); Mockito.when(file.canExecute()).thenReturn(false); Mockito.when(file.renameTo(Mockito.any(File.class))).thenReturn(true); PowerMockito.mock(FileUtils.class, new DoesNothing()); boolean result = UpgraderExecutor.prepare(Context.getServerContext().getAgentUpdateInfo()); Assert."<AssertPlaceHolder>"; }
prepare(SystemCmdInfoFactory.AgentUpdateInfo updateInfo) {  log("upgrade_prepare_start"); boolean hasJar = upgradeJarOnce(updateInfo); boolean javaExecutable = setExecutable4Java(); if (!hasJar) { log("upgrade_prepare_fail_no_jar"); return false; }  if (!javaExecutable) { log("upgrade_prepare_fail_java_cannot_executable"); return false; } log("upgrade_prepare_finish"); return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { HttpDownloader downloader = Mockito.spy(new HttpDownloader()); PowerMockito.whenNew(HttpDownloader.class).withAnyArguments().thenReturn(downloader); Mockito.doNothing().when(downloader).download(); File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.exists()).thenReturn(true); Mockito.when(file.canExecute()).thenThrow(new RuntimeException()); Mockito.when(file.renameTo(Mockito.any(File.class))).thenReturn(true); PowerMockito.mock(FileUtils.class, new DoesNothing()); boolean result = UpgraderExecutor.prepare(Context.getServerContext().getAgentUpdateInfo()); Assert."<AssertPlaceHolder>";  }
prepare(SystemCmdInfoFactory.AgentUpdateInfo updateInfo) {  log("upgrade_prepare_start"); boolean hasJar = upgradeJarOnce(updateInfo); boolean javaExecutable = setExecutable4Java(); if (!hasJar) { log("upgrade_prepare_fail_no_jar"); return false; }  if (!javaExecutable) { log("upgrade_prepare_fail_java_cannot_executable"); return false; } log("upgrade_prepare_finish"); return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: Exception { PowerMockito.mockStatic(Watcher.class); String[] args = {"echo hello"}; Process process = PowerMockito.mock(Process.class); PowerMockito.mockStatic(Runtime.class); PowerMockito.when(Runtime.getRuntime().exec(args)).thenReturn(process); UpgradeStatus upgradeStatus = new UpgradeStatus(); PowerMockito.when(Watcher.watch(process)).thenReturn(upgradeStatus); UpgradeStatus result = UpgraderExecutor.executeUpgrade(args); Assert."<AssertPlaceHolder>"; }
executeUpgrade(String[] cmd) {  try { // 守护进程启动，则不自动更新；直接退出，由守护进程拉起 if (Launcher.isSuperviseRun()) { log("upgrade_execute_success_agent_run_by_supervise"); return new UpgradeStatus(true, true); } Process process = Runtime.getRuntime().exec(cmd); return Watcher.watch(process); } catch (Throwable e) { log("upgrade_execute_fail_error_" + e.getMessage() + "\n" + ExceptionUtils.getFullStackTrace(e)); return null; } }
[*] target: assertEquals(upgradeStatus, result)
[-] pred: org. junit. Assert. assertEquals ( upgradeStatus, result )
************************************
************************************
[+] input: Exception { Process process = PowerMockito.mock(Process.class); UpgradeStatus result = Watcher.watch(process); Assert."<AssertPlaceHolder>"; }
watch(Process process) {  try { boolean alive = false; for (int i = 0; i < 10; i++) { alive = isAlive(process); if (!alive) { break; } Thread.sleep(1000); }  if (alive) { log("upgrade_execute_success"); UpgradeStatus upgradeStatus = checkVersion(); return upgradeStatus; } else { log("upgrade_execute_fail_process_not_alive"); return null; } } catch (Throwable e) { log("upgrade_watch_error_" + e.getMessage() + "\n" + ExceptionUtils.getFullStackTrace(e)); } return null; }
[*] target: assertEquals(result, null)
[-] pred: org. junit. Assert. assertEquals ( result, null )
************************************
************************************
[+] input: testLongValue() { Currency instance = new Currency(1234567890123456L); long expResult = 1234567890123456L; long result = instance.longValue(); "<AssertPlaceHolder>"; }
longValue() { return embeddedValue.longValue(); }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: testCompareTo_Currency() { Currency anotherCurrency = new Currency(1234567890123456L); Currency instance = new Currency(1234567890000000L); int expResult = -1; int result = instance.compareTo(anotherCurrency); "<AssertPlaceHolder>"; }
compareTo(Currency anotherCurrency) { return embeddedValue.compareTo(anotherCurrency.getLongValue()); }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: testEquals() { Object o = new Object(); Currency instance = new Currency(1234567890123456L); boolean expResult = false; boolean result = instance.equals(o); "<AssertPlaceHolder>"; }
equals(Object o) { if (o == null) { return false; // Modified EJP 31/8/2023 } else if (o instanceof Currency && compareTo((Currency) o) == 0) { return true; } else { return false; } }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: Exception { Try<Integer> tr = Try.of(() -> 1).andFinally(() -> System.out.println("Finally")); assertTrue(tr.isSuccess());  Try.CheckedRunnable er = () -> {throw new FileNotFoundException();}; tr = Try.of(() -> 1).andFinally(er); "<AssertPlaceHolder>"; }
isFailure() {return !isSuccess();}
[*] target: assertTrue(tr.isFailure())
[-] pred: org. junit. Assert. assertTrue ( tr. isFailure() )
************************************
************************************
[+] input: Exception { Try.of(() -> 1).peek(t -> assertTrue(t.isSuccess()));  Try<Integer> tr = Try.of(() -> 1).peek(t -> {throw new NoPermissionException();}); "<AssertPlaceHolder>"; }
isFailure() {return !isSuccess();}
[*] target: assertTrue(tr.isFailure())
[-] pred: org. junit. Assert. assertTrue ( tr. isFailure() )
************************************
************************************
[+] input: keyPairWithPasswd() { try { SM2Util instance = new SM2Util(); KeyPair keyPair = instance.generatekeyPair(); String privateKeyPem = SM2Util.pemFrom(keyPair.getPrivate(), passwd); Files.write(Paths.get(encryptedprivFileName), privateKeyPem.getBytes()); PrivateKey key = SM2Util.loadPrivFromFile(encryptedprivFileName, passwd); Assert."<AssertPlaceHolder>"; Assert.assertEquals(keyEqualHint, keyPair.getPrivate(), key); } catch (Exception e) { e.printStackTrace(); Assert.fail(exceptionHappened); } }
loadPrivFromFile(String filename, String password) throws IOException, OperatorCreationException, PKCSException { return loadPriv(password, () -> { try { return new FileReader(filename); } catch (FileNotFoundException e) { throw new RuntimeException("Private key "" + filename + "" not found", e); } }); }
[*] target: assertNotNull(key)
[-] pred: org. junit. Assert. assertNotNull ( key )
************************************
************************************
[+] input: Exception { Map<String, Object> javagm = this.configMap.get("javagm"); Object testdata = javagm.get("testdata"); String privateKey = (String) ((Map<String, Object>) testdata).get("private-key");  PrivateKey privKey = SM2Util.loadPrivFromString(privateKey, ""); Assert."<AssertPlaceHolder>"; }
loadPrivFromString(String privateKey, String password) throws IOException, OperatorCreationException, PKCSException { return loadPriv(password, () -> new StringReader(privateKey)); }
[*] target: assertNotNull(privKey)
[-] pred: org. junit. Assert. assertNotNull ( privKey )
************************************
************************************
[+] input: Exception { Map<String, Object> javagm = this.configMap.get("javagm"); Object testdata = javagm.get("testdata");  String publicKey = (String) ((Map<String, Object>) testdata).get("public-key"); PublicKey pubKey = SM2Util.loadPublicFromString(publicKey); Assert."<AssertPlaceHolder>"; }
loadPublicFromString(String publicKey) throws IOException, NoSuchProviderException, NoSuchAlgorithmException, InvalidKeySpecException { return loadPublic(() -> new StringReader(publicKey)); }
[*] target: assertNotNull(pubKey)
[-] pred: org. junit. Assert. assertNotNull ( pubKey )
************************************
************************************
[+] input: Exception { Map<String, Object> javagm = this.configMap.get("javagm"); Object testdata = javagm.get("testdata");  String cert = (String) ((Map<String, Object>) testdata).get("cert"); Assert.assertNotNull(cert);  X509Certificate certificate = SM2Util.loadX509CertificateFromString(cert); Assert."<AssertPlaceHolder>"; Assert.assertEquals("SM3WITHSM2", certificate.getSigAlgName()); }
loadX509CertificateFromString(String cert) throws IOException, CertificateException, NoSuchProviderException { try (InputStream in = new ByteArrayInputStream(cert.getBytes())) { CertificateFactory cf = CertificateFactory.getInstance("X.509", BouncyCastleProvider.PROVIDER_NAME); return (X509Certificate) cf.generateCertificate(in); } }
[*] target: assertNotNull(certificate)
[-] pred: org. junit. Assert. assertNotNull ( certificate )
************************************
************************************
[+] input: Exception { Topic expectedResponse = Topic.newBuilder() .setName(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartitionConfig(Topic.PartitionConfig.newBuilder().build()) .setRetentionConfig(Topic.RetentionConfig.newBuilder().build()) .setReservationConfig(Topic.ReservationConfig.newBuilder().build()) .build(); mockAdminService.addResponse(expectedResponse);  Topic topic = Topic.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Topic actualResponse = client.updateTopic(topic, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateTopicRequest actualRequest = ((UpdateTopicRequest) actualRequests.get(0));  Assert.assertEquals(topic, actualRequest.getTopic()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateTopic(Topic topic, FieldMask updateMask) { UpdateTopicRequest request = UpdateTopicRequest.newBuilder().setTopic(topic).setUpdateMask(updateMask).build(); return updateTopic(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { Subscription expectedResponse = Subscription.newBuilder() .setName(SubscriptionName.of("[PROJECT]", "[LOCATION]", "[SUBSCRIPTION]").toString()) .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setDeliveryConfig(Subscription.DeliveryConfig.newBuilder().build()) .setExportConfig(ExportConfig.newBuilder().build()) .build(); mockAdminService.addResponse(expectedResponse);  Subscription subscription = Subscription.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Subscription actualResponse = client.updateSubscription(subscription, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateSubscriptionRequest actualRequest = ((UpdateSubscriptionRequest) actualRequests.get(0));  Assert.assertEquals(subscription, actualRequest.getSubscription()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateSubscription(Subscription subscription, FieldMask updateMask) { UpdateSubscriptionRequest request = UpdateSubscriptionRequest.newBuilder() .setSubscription(subscription) .setUpdateMask(updateMask) .build(); return updateSubscription(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { SeekSubscriptionResponse expectedResponse = SeekSubscriptionResponse.newBuilder().build(); Operation resultOperation = Operation.newBuilder() .setName("seekSubscriptionTest") .setDone(true) .setResponse(Any.pack(expectedResponse)) .build(); mockAdminService.addResponse(resultOperation);  SeekSubscriptionRequest request = SeekSubscriptionRequest.newBuilder() .setName(SubscriptionName.of("[PROJECT]", "[LOCATION]", "[SUBSCRIPTION]").toString()) .build();  SeekSubscriptionResponse actualResponse = client.seekSubscriptionAsync(request).get(); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); SeekSubscriptionRequest actualRequest = ((SeekSubscriptionRequest) actualRequests.get(0));  Assert.assertEquals(request.getName(), actualRequest.getName()); Assert.assertEquals(request.getNamedTarget(), actualRequest.getNamedTarget()); Assert.assertEquals(request.getTimeTarget(), actualRequest.getTimeTarget()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
seekSubscriptionAsync( SeekSubscriptionRequest request) { return seekSubscriptionOperationCallable().futureCall(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { Reservation expectedResponse = Reservation.newBuilder() .setName(ReservationName.of("[PROJECT]", "[LOCATION]", "[RESERVATION]").toString()) .setThroughputCapacity(-1174790353) .build(); mockAdminService.addResponse(expectedResponse);  Reservation reservation = Reservation.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Reservation actualResponse = client.updateReservation(reservation, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateReservationRequest actualRequest = ((UpdateReservationRequest) actualRequests.get(0));  Assert.assertEquals(reservation, actualRequest.getReservation()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateReservation(Reservation reservation, FieldMask updateMask) { UpdateReservationRequest request = UpdateReservationRequest.newBuilder() .setReservation(reservation) .setUpdateMask(updateMask) .build(); return updateReservation(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { CommitCursorResponse expectedResponse = CommitCursorResponse.newBuilder().build(); mockCursorService.addResponse(expectedResponse);  CommitCursorRequest request = CommitCursorRequest.newBuilder() .setSubscription("subscription341203229") .setPartition(-1799810326) .setCursor(Cursor.newBuilder().build()) .build();  CommitCursorResponse actualResponse = client.commitCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockCursorService.getRequests(); Assert.assertEquals(1, actualRequests.size()); CommitCursorRequest actualRequest = ((CommitCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getSubscription(), actualRequest.getSubscription()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getCursor(), actualRequest.getCursor()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
commitCursor(CommitCursorRequest request) { return commitCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeMessageStatsResponse expectedResponse = ComputeMessageStatsResponse.newBuilder() .setMessageCount(-1229303081) .setMessageBytes(-1229929933) .setMinimumPublishTime(Timestamp.newBuilder().build()) .setMinimumEventTime(Timestamp.newBuilder().build()) .build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeMessageStatsRequest request = ComputeMessageStatsRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .setStartCursor(Cursor.newBuilder().build()) .setEndCursor(Cursor.newBuilder().build()) .build();  ComputeMessageStatsResponse actualResponse = client.computeMessageStats(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeMessageStatsRequest actualRequest = ((ComputeMessageStatsRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getStartCursor(), actualRequest.getStartCursor()); Assert.assertEquals(request.getEndCursor(), actualRequest.getEndCursor()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeMessageStats(ComputeMessageStatsRequest request) { return computeMessageStatsCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeHeadCursorResponse expectedResponse = ComputeHeadCursorResponse.newBuilder().setHeadCursor(Cursor.newBuilder().build()).build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeHeadCursorRequest request = ComputeHeadCursorRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .build();  ComputeHeadCursorResponse actualResponse = client.computeHeadCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeHeadCursorRequest actualRequest = ((ComputeHeadCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeHeadCursor(ComputeHeadCursorRequest request) { return computeHeadCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeTimeCursorResponse expectedResponse = ComputeTimeCursorResponse.newBuilder().setCursor(Cursor.newBuilder().build()).build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeTimeCursorRequest request = ComputeTimeCursorRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .setTarget(TimeTarget.newBuilder().build()) .build();  ComputeTimeCursorResponse actualResponse = client.computeTimeCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeTimeCursorRequest actualRequest = ((ComputeTimeCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getTarget(), actualRequest.getTarget()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeTimeCursor(ComputeTimeCursorRequest request) { return computeTimeCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: regexifyShouldGenerateSameValueForFakerWithSameSeed() { long seed = 1L; String regex = "\\d";  String firstResult = new Faker(new Random(seed)).regexify(regex); String secondResult = new Faker(new Random(seed)).regexify(regex);  "<AssertPlaceHolder>"; }
regexify(String regex) { return fakeValuesService.regexify(regex); }
[*] target: assertThat(secondResult, is(firstResult))
[-] pred: org. junit. Assert. assertThat ( secondResult, is ( firstResult ) )
************************************
************************************
[+] input: test_getmainstr1() { String s = cnid.getmainstr(f); "<AssertPlaceHolder>"; System.out.println(s); }
getmainstr(Faker f) { String cn = f.regexify( "[1-6][1-3][0-2][0-9]21-[1-2]\\d{3}[0-1][0-9][0-2][0-8]-\\d{3}"); //原理：通过正则表达式生成符合条件的 id，并且排除掉不符合的id。生成不符合的则重新生成。 //正则表达式中，\d 匹配一个数字字符。等价于 [0-9]。 boolean isValid = true; for (String invalidSSNPattern : invalidCNPatterns) { if (cn.matches(invalidSSNPattern)) { isValid = false; break; } } if (!isValid) { cn = getmainstr(f); } return cn; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: test_getmainstr2() { String s = cnid.getmainstr(f); "<AssertPlaceHolder>"; System.out.println(s); }
getmainstr(Faker f) { String cn = f.regexify( "[1-6][1-3][0-2][0-9]21-[1-2]\\d{3}[0-1][0-9][0-2][0-8]-\\d{3}"); //原理：通过正则表达式生成符合条件的 id，并且排除掉不符合的id。生成不符合的则重新生成。 //正则表达式中，\d 匹配一个数字字符。等价于 [0-9]。 boolean isValid = true; for (String invalidSSNPattern : invalidCNPatterns) { if (cn.matches(invalidSSNPattern)) { isValid = false; break; } } if (!isValid) { cn = getmainstr(f); } return cn; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: cleanColumnInputNullOutputNull() {  // Arrange final String column = null;  // Act final String actual = Util.cleanColumn(column);  // Assert result Assert."<AssertPlaceHolder>"; }
cleanColumn(String column) { if (column == null) { return null; } if (column.contains("`")) { column = column.replaceAll("`", ""); }  if (column.contains("'")) { column = column.replaceAll("'", ""); }  if (column.contains(""")) { column = column.replaceAll(""", ""); }  return column; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: Exception {  // Setup mocks PowerMockito.mockStatic(StringUtils.class);  // Arrange final String datetimeStr = "1a 2b 3c"; final Method isEmptyMethod = DTUMemberMatcher.method(StringUtils.class, "isEmpty", String.class); PowerMockito.doReturn(true) .when(StringUtils.class, isEmptyMethod) .withArguments(or(isA(String.class), isNull(String.class)));  // Act final Date actual = Util.parseDate2(datetimeStr);  // Assert result Assert."<AssertPlaceHolder>"; }
parseDate2(String datetimeStr) { if (StringUtils.isEmpty(datetimeStr)) { return null; } try { datetimeStr = datetimeStr.trim(); int len = datetimeStr.length(); if (datetimeStr.contains("-") && datetimeStr.contains(":") && datetimeStr.contains(".")) { // 包含日期+时间+毫秒 // 取毫秒位数 int msLen = len - datetimeStr.indexOf(".") - 1; StringBuilder ms = new StringBuilder(); for (int i = 0; i < msLen; i++) { ms.append("S"); } String formatter = "yyyy-MM-dd HH:mm:ss." + ms;  DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDateTime dateTime = LocalDateTime.parse(datetimeStr, dateTimeFormatter); return Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains("-") && datetimeStr.contains(":")) { // 包含日期+时间 // 判断包含时间位数 int i = datetimeStr.indexOf(":"); i = datetimeStr.indexOf(":", i + 1); String formatter; if (i > -1) { formatter = "yyyy-MM-dd HH:mm:ss"; } else { formatter = "yyyy-MM-dd HH:mm"; }  DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDateTime dateTime = LocalDateTime.parse(datetimeStr, dateTimeFormatter); return Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains("-")) { // 只包含日期 String formatter = "yyyy-MM-dd"; DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDate localDate = LocalDate.parse(datetimeStr, dateTimeFormatter); return Date.from(localDate.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains(":")) { // 只包含时间 String formatter; if (datetimeStr.contains(".")) { // 包含毫秒 int msLen = len - datetimeStr.indexOf(".") - 1; StringBuilder ms = new StringBuilder(); for (int i = 0; i < msLen; i++) { ms.append("S"); } formatter = "HH:mm:ss." + ms; } else { // 判断包含时间位数 int i = datetimeStr.indexOf(":"); i = datetimeStr.indexOf(":", i + 1); if (i > -1) { formatter = "HH:mm:ss"; } else { formatter = "HH:mm"; } } DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalTime localTime = LocalTime.parse(datetimeStr, dateTimeFormatter); LocalDate localDate = LocalDate.of(1970, Month.JANUARY, 1); LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime); return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); } } catch (Throwable e) { logger.error(e.getMessage(), e); }  return null; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: Exception {  // Setup mocks PowerMockito.mockStatic(StringUtils.class);  // Arrange final String datetimeStr = "1a 2b 3c"; final Method isEmptyMethod = DTUMemberMatcher.method(StringUtils.class, "isEmpty", String.class); PowerMockito.doReturn(false) .when(StringUtils.class, isEmptyMethod) .withArguments(or(isA(String.class), isNull(String.class)));  // Act final Date actual = Util.parseDate2(datetimeStr);  // Assert result Assert."<AssertPlaceHolder>"; }
parseDate2(String datetimeStr) { if (StringUtils.isEmpty(datetimeStr)) { return null; } try { datetimeStr = datetimeStr.trim(); int len = datetimeStr.length(); if (datetimeStr.contains("-") && datetimeStr.contains(":") && datetimeStr.contains(".")) { // 包含日期+时间+毫秒 // 取毫秒位数 int msLen = len - datetimeStr.indexOf(".") - 1; StringBuilder ms = new StringBuilder(); for (int i = 0; i < msLen; i++) { ms.append("S"); } String formatter = "yyyy-MM-dd HH:mm:ss." + ms;  DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDateTime dateTime = LocalDateTime.parse(datetimeStr, dateTimeFormatter); return Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains("-") && datetimeStr.contains(":")) { // 包含日期+时间 // 判断包含时间位数 int i = datetimeStr.indexOf(":"); i = datetimeStr.indexOf(":", i + 1); String formatter; if (i > -1) { formatter = "yyyy-MM-dd HH:mm:ss"; } else { formatter = "yyyy-MM-dd HH:mm"; }  DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDateTime dateTime = LocalDateTime.parse(datetimeStr, dateTimeFormatter); return Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains("-")) { // 只包含日期 String formatter = "yyyy-MM-dd"; DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalDate localDate = LocalDate.parse(datetimeStr, dateTimeFormatter); return Date.from(localDate.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant()); } else if (datetimeStr.contains(":")) { // 只包含时间 String formatter; if (datetimeStr.contains(".")) { // 包含毫秒 int msLen = len - datetimeStr.indexOf(".") - 1; StringBuilder ms = new StringBuilder(); for (int i = 0; i < msLen; i++) { ms.append("S"); } formatter = "HH:mm:ss." + ms; } else { // 判断包含时间位数 int i = datetimeStr.indexOf(":"); i = datetimeStr.indexOf(":", i + 1); if (i > -1) { formatter = "HH:mm:ss"; } else { formatter = "HH:mm"; } } DateTimeFormatter dateTimeFormatter = dateFormatterCache.get(formatter); LocalTime localTime = LocalTime.parse(datetimeStr, dateTimeFormatter); LocalDate localDate = LocalDate.of(1970, Month.JANUARY, 1); LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime); return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); } } catch (Throwable e) { logger.error(e.getMessage(), e); }  return null; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: Exception {  // Setup mocks PowerMockito.mockStatic(StringUtils.class);  // Arrange final String datetimeStr = "a/b/c"; final Method isEmptyMethod = DTUMemberMatcher.method(StringUtils.class, "isEmpty", String.class); PowerMockito.doReturn(true) .when(StringUtils.class, isEmptyMethod) .withArguments(or(isA(String.class), isNull(String.class)));  // Act final Date actual = Util.parseDate(datetimeStr);  // Assert result Assert."<AssertPlaceHolder>"; }
parseDate(String datetimeStr) { if (StringUtils.isEmpty(datetimeStr)) { return null; } datetimeStr = datetimeStr.trim(); if (datetimeStr.contains("-")) { if (datetimeStr.contains(":")) { datetimeStr = datetimeStr.replace(" ", "T"); } } else if (datetimeStr.contains(":")) { datetimeStr = "T" + datetimeStr; }  DateTime dateTime = new DateTime(datetimeStr, dateTimeZone);  return dateTime.toDate(); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: print_json_diffInputNotNullZeroNotNullZeroNotNullOutputNotNull() {  // Arrange final LogBuffer buffer = new LogBuffer(); final long len = 0L; final String columnName = ","; final int columnIndex = 0; final String charsetName = "1a 2b 3c";  // Act final StringBuilder actual = JsonDiffConversion.print_json_diff(buffer, len, columnName, columnIndex, charsetName);  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertEquals(",", actual.toString()); }
print_json_diff(LogBuffer buffer, long len, String columnName, int columnIndex, String charsetName) { int position = buffer.position(); List<String> operation_names = new ArrayList<String>(); while (buffer.hasRemaining()) { int operation_int = buffer.getUint8(); if (operation_int >= JSON_DIFF_OPERATION_COUNT) { throw new IllegalArgumentException("reading operation type (invalid operation code)"); }  // skip path long path_length = buffer.getPackedLong(); if (path_length > len) { throw new IllegalArgumentException("skipping path"); }  // compute operation name byte[] lastP = buffer.getData(buffer.position() + (int) path_length - 1, 1); String operation_name = json_diff_operation_name(operation_int, lastP[0]); operation_names.add(operation_name);  buffer.forward((int) path_length); // skip value if (operation_int != DIFF_OPERATION_REMOVE) { long value_length = buffer.getPackedLong(); if (value_length > len) { throw new IllegalArgumentException("skipping path"); }  buffer.forward((int) value_length); } }  // Print function names in reverse order. StringBuilder builder = new StringBuilder(); for (int i = operation_names.size() - 1; i >= 0; i--) { if (i == 0 || operation_names.get(i - 1) != operation_names.get(i)) { builder.append(operation_names.get(i)).append("("); } }  // Print column id if (columnName != null) { builder.append(columnName); } else { builder.append("@").append(columnIndex); }  // In case this vector is empty (a no-op), make an early return // after printing only the column name if (operation_names.size() == 0) { return builder; }  // Print comma between column name and next function argument builder.append(", "); // Print paths and values. buffer.position(position); int diff_i = 0; while (buffer.hasRemaining()) { // Read operation int operation_int = buffer.getUint8();  // Read path length long path_length = buffer.getPackedLong(); // Print path builder.append(''').append(buffer.getFixString((int) path_length)).append(''');  if (operation_int != DIFF_OPERATION_REMOVE) { // Print comma between path and value builder.append(", "); // Read value length long value_length = buffer.getPackedLong();  Json_Value jsonValue = JsonConversion.parse_value(buffer.getUint8(), buffer, value_length - 1, charsetName); buffer.forward((int) value_length - 1); // Read value if (jsonValue.m_type == Json_enum_type.ERROR) { throw new IllegalArgumentException("parsing json value"); } StringBuilder jsonBuilder = new StringBuilder(); jsonValue.toJsonString(jsonBuilder, charsetName); builder.append(jsonBuilder); }  // Print closing parenthesis if (!buffer.hasRemaining() || operation_names.get(diff_i + 1) != operation_names.get(diff_i)) { builder.append(")"); }  if (buffer.hasRemaining()) { builder.append(", "); } diff_i++; }  return builder; }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: getChecksumAlgOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getChecksumAlg();  // Assert result Assert."<AssertPlaceHolder>"; }
getChecksumAlg() { return checksumAlg; }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: getCurrentGtidLastCommitOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtidLastCommit();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtidLastCommit() { return gtidMap.get(CURRENT_GTID_LAST_COMMIT); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getCurrentGtidOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtid();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtid() { return gtidMap.get(CURRENT_GTID_STRING); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getCurrentGtidSnOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtidSn();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtidSn() { return gtidMap.get(CURRENT_GTID_SN); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getEventLenOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getEventLen();  // Assert result Assert."<AssertPlaceHolder>"; }
getEventLen() { return eventLen; }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: getFlagsOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getFlags();  // Assert result Assert."<AssertPlaceHolder>"; }
getFlags() { return flags; }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: getGtidSetStrOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getGtidSetStr();  // Assert result Assert."<AssertPlaceHolder>"; }
getGtidSetStr() { return gtidMap.get(GTID_SET_STRING); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getLogFileNameOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getLogFileName();  // Assert result Assert."<AssertPlaceHolder>"; }
getLogFileName() { return logFileName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getServerIdOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final long actual = objectUnderTest.getServerId();  // Assert result Assert."<AssertPlaceHolder>"; }
getServerId() { return serverId; }
[*] target: assertEquals(0L, actual)
[-] pred: org. junit. Assert. assertEquals ( 0L, actual )
************************************
************************************
[+] input: getTypeOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getType();  // Assert result Assert."<AssertPlaceHolder>"; }
getType() { return type; }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: testParse() { Map<String, MysqlGTIDSet> cases = new HashMap<String, MysqlGTIDSet>(5); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 2))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3:4", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 5))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3:7-9", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4, 7, 10))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3,726757ad-4455-11e8-ae04-0242ac110003:4", buildForTest(Arrays.asList(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4), new Material("726757ad-4455-11e8-ae04-0242ac110003", 4, 5))));  for (Map.Entry<String, MysqlGTIDSet> entry : cases.entrySet()) { MysqlGTIDSet expected = entry.getValue(); MysqlGTIDSet actual = MysqlGTIDSet.parse(entry.getKey());  "<AssertPlaceHolder>"; } }
parse(String gtidData) { Map<String, UUIDSet> m;  if (gtidData == null || gtidData.length() < 1) { m = new HashMap<String, UUIDSet>(); } else { // 存在多个GTID时会有回车符 String[] uuidStrs = gtidData.replaceAll("\n", "").split(","); m = new HashMap<String, UUIDSet>(uuidStrs.length); for (int i = 0; i < uuidStrs.length; i++) { UUIDSet uuidSet = UUIDSet.parse(uuidStrs[i]); m.put(uuidSet.SID.toString(), uuidSet); } }  MysqlGTIDSet gs = new MysqlGTIDSet(); gs.sets = m;  return gs; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: getOriSchemaNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getOriSchemaName();  // Assert result Assert."<AssertPlaceHolder>"; }
getOriSchemaName() { return oriSchemaName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getOriTableNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getOriTableName();  // Assert result Assert."<AssertPlaceHolder>"; }
getOriTableName() { return oriTableName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getRenameTableResultOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final DdlResult actual = objectUnderTest.getRenameTableResult();  // Assert result Assert."<AssertPlaceHolder>"; }
getRenameTableResult() { return renameTableResult; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getSchemaNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getSchemaName();  // Assert result Assert."<AssertPlaceHolder>"; }
getSchemaName() { return schemaName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getTableNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getTableName();  // Assert result Assert."<AssertPlaceHolder>"; }
getTableName() { return tableName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getTypeOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final EventType actual = objectUnderTest.getType();  // Assert result Assert."<AssertPlaceHolder>"; }
getType() { return type; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: NoSuchAlgorithmException { byte[] seed = { 1, 2, 3, 4, 5, 6, 7, 8 }; // String str = "e3619321c1a937c46a0d8bd1dac39f93b27d4458"; // canal // passwd String str = SecurityUtil.scrambleGenPass("canal".getBytes()); byte[] client = SecurityUtil.scramble411("canal".getBytes(), seed); boolean check = SecurityUtil.scrambleServerAuth(client, SecurityUtil.hexStr2Bytes(str), seed); Assert."<AssertPlaceHolder>"; }
hexStr2Bytes(String src) { if (src == null) { return null; } int offset = 0; int length = src.length(); if (length == 0) { return new byte[0]; }  boolean odd = length << 31 == Integer.MIN_VALUE; byte[] bs = new byte[odd ? (length + 1) >> 1 : length >> 1]; for (int i = offset, limit = offset + length; i < limit; ++i) { char high, low; if (i == offset && odd) { high = '0'; low = src.charAt(i); } else { high = src.charAt(i); low = src.charAt(++i); } int b; switch (high) { case '0': b = 0; break; case '1': b = 0x10; break; case '2': b = 0x20; break; case '3': b = 0x30; break; case '4': b = 0x40; break; case '5': b = 0x50; break; case '6': b = 0x60; break; case '7': b = 0x70; break; case '8': b = 0x80; break; case '9': b = 0x90; break; case 'a': case 'A': b = 0xa0; break; case 'b': case 'B': b = 0xb0; break; case 'c': case 'C': b = 0xc0; break; case 'd': case 'D': b = 0xd0; break; case 'e': case 'E': b = 0xe0; break; case 'f': case 'F': b = 0xf0; break; default: throw new IllegalArgumentException("illegal hex-string: " + src); } switch (low) { case '0': break; case '1': b += 1; break; case '2': b += 2; break; case '3': b += 3; break; case '4': b += 4; break; case '5': b += 5; break; case '6': b += 6; break; case '7': b += 7; break; case '8': b += 8; break; case '9': b += 9; break; case 'a': case 'A': b += 10; break; case 'b': case 'B': b += 11; break; case 'c': case 'C': b += 12; break; case 'd': case 'D': b += 13; break; case 'e': case 'E': b += 14; break; case 'f': case 'F': b += 15; break; default: throw new IllegalArgumentException("illegal hex-string: " + src); } bs[(i - offset) >> 1] = (byte) b; } return bs; }
[*] target: assertTrue(check)
[-] pred: org. junit. Assert. assertTrue ( check )
************************************
************************************
[+] input: testPermutations_3_2() { int[][] ints = Scheduler.classPermutation(3, 2);  Assert."<AssertPlaceHolder>"; Assert.assertArrayEquals(new int[] {0, 0, 0}, ints[0]); Assert.assertArrayEquals(new int[] {0, 1, 0}, ints[1]); Assert.assertArrayEquals(new int[] {0, 0, 1}, ints[2]); Assert.assertArrayEquals(new int[] {0, 1, 1}, ints[3]); }
classPermutation(int num, int limit) { if (num < 1) { throw new IllegalArgumentException("Num should be at least 1: classPermutation(" + num + ", " + limit + ")"); } if (limit < 1) { throw new IllegalArgumentException("Limit should be at least 1"); }  // Base case if (num == 1) { return new int[][] { new int[] {0} }; }  int[][] oldPerms = classPermutation(num - 1, limit);  // Compute the max class in old permutations, and the number // of permutations with maxed-out classes. int oldMax = Math.min(num - 1, limit) - 1; int newMax = oldMax + 1;  int[][] newPerms = new int[oldPerms.length*(newMax+1)][]; int nIdx = 0;  // Copy all existing permutations with up to max variability for (int nm = 0; nm < newMax; nm++) { for (int[] p : oldPerms) { int m = max(p); if (m >= nm - 1) { int[] np = Arrays.copyOf(p, p.length + 1); np[p.length] = nm; newPerms[nIdx++] = np; } } }  // Copy all existing permutations with maxed out class for (int[] p : oldPerms) { int m = max(p); if (m == oldMax && m < limit - 1) { int[] np = Arrays.copyOf(p, p.length + 1); np[p.length] = newMax; newPerms[nIdx++] = np; } }  return Arrays.copyOf(newPerms, nIdx); }
[*] target: assertEquals(4, ints.length)
[-] pred: org. junit. Assert. assertEquals ( 4, ints. length )
************************************
************************************
[+] input: testRemove() { map.put(1, "a"); map.put(2, "b"); Assert.assertEquals("a", map.get(1));  Assert.assertEquals("a", map.remove(1)); Assert.assertEquals(1, map.size()); Assert.assertEquals("b", map.remove(2)); Assert.assertNull(map.remove(2)); Assert."<AssertPlaceHolder>"; }
isEmpty() { return lowestNode() != null; }
[*] target: assertTrue(map.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( map. isEmpty() )
************************************
************************************
[+] input: testTailMap() { for (int i = 0; i < 100; i++) { map.put(i, String.valueOf(i)); } SortedMap<Integer, String> tailMap = map.tailMap(21); Assert.assertEquals(79, tailMap.size()); for (int i = 21; i < 100; i++) { Assert.assertTrue(tailMap.containsKey(i)); }  SortedMap<Integer, String> tailTailMap = tailMap.tailMap(59); Assert.assertEquals(41, tailTailMap.size()); for (int i = 59; i < 100; i++) { Assert."<AssertPlaceHolder>"; }  }
containsKey(Object key) { return findClosestNode((K) key, Relation.EQ) != null; }
[*] target: assertTrue(tailTailMap.containsKey(i))
[-] pred: org. junit. Assert. assertTrue ( tailTailMap. containsKey ( i ) )
************************************
************************************
[+] input: () { OffsetBitSet b1 = new OffsetBitSet(); OffsetBitSet b2 = new OffsetBitSet();  b1.add(1); b2.add(1);  assertEquals(b1.hashCode(), b2.hashCode()); assertEquals(b1, b2);  // temporarily setting/clearing a single bit causing // the backing array to grow b2.add(420); b2.deactivate(420);  assertEquals(b1.hashCode(), b2.hashCode()); assertEquals(b1, b2);  b1.add(810); b1.deactivate(810);  assertEquals(b1.hashCode(), b2.hashCode()); assertEquals(b1, b2);  OffsetBitSet o1 = new OffsetBitSet(100, 200); OffsetBitSet o2 = new OffsetBitSet(100, 200);  o1.add(100); o2.add(100);  assertEquals(o1.hashCode(), o2.hashCode()); assertEquals(o1, o2);  o2.add(420); o2.deactivate(420);  assertEquals(o1.hashCode(), o2.hashCode()); assertEquals(o1, o2);  o1.add(810); o1.deactivate(810);  "<AssertPlaceHolder>"; assertEquals(o1, o2); }
hashCode () { final int word = (length() >>> 6) - offset; long hash = offset; for (int i = 0; i <= word; i++) { hash += bits[i]; } return (int)(hash ^ hash >>> 32); }
[*] target: assertEquals(o1.hashCode(), o2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( o1. hashCode ( ), o2. hashCode ( ) )
************************************
************************************
[+] input: () { OffsetBitSet b1 = new OffsetBitSet(); b1.add(50); b1.add(100); b1.add(150); b1.changeOffset(1000);  OffsetBitSet b2 = new OffsetBitSet(b1); assertNotSame(b1, b2); assertTrue(b1.containsAll(b2)); "<AssertPlaceHolder>"; assertEquals(b1, b2); }
containsAll (OffsetBitSet other) { if (offset == other.offset) { long[] bits = this.bits; long[] otherBits = other.bits; int otherBitsLength = otherBits.length; int bitsLength = bits.length;  for (int i = bitsLength; i < otherBitsLength; i++) { if (otherBits[i] != 0) { return false; } } for (int i = Math.min(bitsLength, otherBitsLength) - 1; i >= 0; i--) { if ((bits[i] & otherBits[i]) != otherBits[i]) { return false; } } return true; } else return ((PrimitiveCollection.OfInt)this).containsAll(other); }
[*] target: assertTrue(b2.containsAll(b1))
[-] pred: org. junit. Assert. assertTrue ( b2. containsAll ( b1 ) )
************************************
************************************
[+] input: testTimeSync() { Message message = codec.decode(createMessageContext(SimpleMqttMessage .builder() .topic("/product1/device1/time-sync") .payload(Unpooled.wrappedBuffer("{"messageId":"test"}" .getBytes())) .build())) .blockFirst();  Assert."<AssertPlaceHolder>";  Assert.assertNotNull(currentReply);  Assert.assertEquals(((MqttMessage) currentReply).getTopic(), "/product1/device1/time-sync/reply"); Assert.assertTrue(currentReply.payloadAsString().contains("timestamp"));  }
decode(@Nonnull MessageDecodeContext context) { MqttMessage message = (MqttMessage) context.getMessage(); byte[] payload = message.payloadAsBytes();  return TopicMessageCodec .decode(mapper, TopicMessageCodec.removeProductPath(message.getTopic()), payload) //如果不能直接解码，可能是其他设备功能 .switchIfEmpty(FunctionalTopicHandlers .handle(context.getDevice(), message.getTopic().split("/"), payload, mapper, reply -> doReply(context, reply))) ;  }
[*] target: assertNull(message)
[-] pred: org. junit. Assert. assertNull ( message )
************************************
************************************
[+] input: testGetDefaultParameters() { Arguments args = client.getDefaultParameters(); "<AssertPlaceHolder>"; }
getDefaultParameters() { Arguments arguments = new Arguments(); arguments.addArgument(KEY_TEST_NAME, DEFAULT_TEST_NAME); arguments.addArgument(KEY_CONNECTION_STRING, DEFAULT_CONNECTION_STRING); arguments.addArgument(KEY_LIVE_METRICS, Boolean.toString(DEFAULT_LIVE_METRICS)); arguments.addArgument(KEY_SAMPLERS_LIST, DEFAULT_SAMPLERS_LIST); arguments.addArgument(KEY_USE_REGEX_FOR_SAMPLER_LIST, Boolean.toString(DEFAULT_USE_REGEX_FOR_SAMPLER_LIST)); arguments.addArgument(KEY_LOG_RESPONSE_DATA, DEFAULT_LOG_RESPONSE_DATA.getValue()); arguments.addArgument(KEY_LOG_SAMPLE_DATA, DEFAULT_LOG_SAMPLE_DATA.getValue());  return arguments; }
[*] target: assertNotNull(args)
[-] pred: org. junit. Assert. assertNotNull ( args )
************************************
************************************
[+] input: fieldsFor1() { String klass = Class1.class.getCanonicalName(); List<FieldData> classFields = classData.fieldsFor(klass); "<AssertPlaceHolder>"; assertEquals(klass, classFields.get(0).hostClass()); assertEquals(klass, classFields.get(1).hostClass()); assertEquals(klass, classFields.get(2).hostClass()); assertEquals("[" + PREFIX + "1.f1: int, " + PREFIX + "1.f2: int, " + PREFIX + "1.f3: int]", classFields.toString()); }
fieldsFor(String klass) { List<FieldData> r = new ArrayList<>(); for (FieldData f : fields) { if (f.hostClass().equals(klass)) { r.add(f); } } return r; }
[*] target: assertEquals(3, classFields.size())
[-] pred: org. junit. Assert. assertEquals ( 3, classFields. size ( ) )
************************************
************************************
[+] input: fieldsFor2() { String klass = Class2.class.getCanonicalName(); List<FieldData> classFields = classData.fieldsFor(klass); "<AssertPlaceHolder>"; assertEquals(klass, classFields.get(0).hostClass()); assertEquals(klass, classFields.get(1).hostClass()); assertEquals(klass, classFields.get(2).hostClass()); assertEquals("[" + PREFIX + "2.f1: int, " + PREFIX + "2.f2: int, " + PREFIX + "2.f3: int]", classFields.toString()); }
fieldsFor(String klass) { List<FieldData> r = new ArrayList<>(); for (FieldData f : fields) { if (f.hostClass().equals(klass)) { r.add(f); } } return r; }
[*] target: assertEquals(3, classFields.size())
[-] pred: org. junit. Assert. assertEquals ( 3, classFields. size ( ) )
************************************
************************************
[+] input: fieldsFor3() { String klass = Class3.class.getCanonicalName(); List<FieldData> classFields = classData.fieldsFor(klass); "<AssertPlaceHolder>"; assertEquals(klass, classFields.get(0).hostClass()); assertEquals(klass, classFields.get(1).hostClass()); assertEquals(klass, classFields.get(2).hostClass()); assertEquals(klass, classFields.get(3).hostClass()); assertEquals("[" + PREFIX + "3.f1: int, " +  PREFIX + "3.f2: int, " + PREFIX + "3.f3: int, " + PREFIX + "3.f4: java.lang.Object]", classFields.toString()); }
fieldsFor(String klass) { List<FieldData> r = new ArrayList<>(); for (FieldData f : fields) { if (f.hostClass().equals(klass)) { r.add(f); } } return r; }
[*] target: assertEquals(4, classFields.size())
[-] pred: org. junit. Assert. assertEquals ( 4, classFields. size ( ) )
************************************
************************************
[+] input: testSetAndGetLongProperties() { String testKey = "testKey"; long testValue = 1; propertyTest.setLongProperty(testKey,testValue); "<AssertPlaceHolder>"; }
getLongProperty(String name) throws NumberFormatException { String sValue = properties.getProperty(name); if (sValue != null) { return Long.parseLong(sValue.trim()); } throw new NumberFormatException("Property for " + name + " is not set or not a valid long"); }
[*] target: assertEquals(testValue,propertyTest.getLongProperty(testKey))
[-] pred: org. junit. Assert. assertEquals ( testValue, propertyTest. getLongProperty( testKey ) )
************************************
************************************
[+] input: evaluateWhenExpressionVarIsUndefined() { String expression = "dummy.intValue"; Map<String, Object> vars = new HashMap<>(); ExpressionEvaluator expressionEvaluator = new JexlExpressionEvaluatorNoThreadLocal(); Object result = expressionEvaluator.evaluate( expression, vars ); "<AssertPlaceHolder>"; }
evaluate(String expression, Map<String, Object> context) { JexlContext jexlContext = new MapContext(context); try { JexlExpression jexlExpression = expressionMap.get(expression); if (jexlExpression == null) { jexlExpression = jexl.createExpression(expression); expressionMap.put(expression, jexlExpression); } return jexlExpression.evaluate(jexlContext); } catch (Exception e) { throw new EvaluationException("An error occurred when evaluating expression " + expression, e); // JxlsLogger not needed here. } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: evaluateWhenExpressionVarIsUndefined() { String expression = "dummy.intValue"; Map<String, Object> vars = new HashMap<>(); ExpressionEvaluator expressionEvaluator = new JexlExpressionEvaluator(); Object result = expressionEvaluator.evaluate( expression, vars ); "<AssertPlaceHolder>"; }
evaluate(String expression, Map<String, Object> context) { JexlContext jexlContext = new MapContext(context); try { Map<String, JexlExpression> expressionMap = expressionMapThreadLocal.get(); JexlExpression jexlExpression = expressionMap.get(expression); if (jexlExpression == null) { jexlExpression = getJexlEngine().createExpression(expression); expressionMap.put(expression, jexlExpression); } return jexlExpression.evaluate(jexlContext); } catch (Exception e) { throw new EvaluationException("An error occurred when evaluating expression " + expression, e); // JxlsLogger not needed here. } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: UnknownHostException { // Try connecting connectionStates.connecting(nodeId1, time.milliseconds(), "localhost", ClientDnsLookup.DEFAULT);  time.sleep(100);  connectionStates.authenticationFailed(nodeId1, time.milliseconds(), new AuthenticationException("No path to CA for certificate!")); time.sleep(1000); assertEquals(connectionStates.connectionState(nodeId1), ConnectionState.AUTHENTICATION_FAILED); assertTrue(connectionStates.authenticationException(nodeId1) instanceof AuthenticationException); assertFalse(connectionStates.hasReadyNodes(time.milliseconds())); assertFalse(connectionStates.canConnect(nodeId1, time.milliseconds()));  time.sleep(connectionStates.connectionDelay(nodeId1, time.milliseconds()) + 1);  assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds())); connectionStates.ready(nodeId1); "<AssertPlaceHolder>"; }
authenticationException(String id) { NodeConnectionState state = nodeState.get(id); return state != null ? state.authenticationException : null; }
[*] target: assertNull(connectionStates.authenticationException(nodeId1))
[-] pred: org. junit. Assert. assertNull ( connectionStates. authenticationException(nodeId1) )
************************************
************************************
[+] input: testConnectionDelayWithNoExponentialBackoff() { long now = time.milliseconds(); long delay = clientWithNoExponentialBackoff.connectionDelay(node, now);  "<AssertPlaceHolder>"; }
connectionDelay(Node node, long now) { return connectionStates.connectionDelay(node.idString(), now); }
[*] target: assertEquals(0, delay)
[-] pred: org. junit. Assert. assertEquals ( 0, delay )
************************************
************************************
[+] input: testConnectionDelay() { long now = time.milliseconds(); long delay = client.connectionDelay(node, now);  "<AssertPlaceHolder>"; }
connectionDelay(Node node, long now) { return connectionStates.connectionDelay(node.idString(), now); }
[*] target: assertEquals(0, delay)
[-] pred: org. junit. Assert. assertEquals ( 0, delay )
************************************
************************************
[+] input: testUnsupportedVersionsToString() { NodeApiVersions versions = new NodeApiVersions(Collections.<ApiVersion>emptyList()); StringBuilder bld = new StringBuilder(); String prefix = "("; for (ApiKeys apiKey : ApiKeys.values()) { bld.append(prefix).append(apiKey.name). append("(").append(apiKey.id).append("): UNSUPPORTED"); prefix = ", "; } bld.append(")"); "<AssertPlaceHolder>"; }
toString() { return toString(false); }
[*] target: assertEquals(bld.toString(), versions.toString())
[-] pred: org. junit. Assert. assertEquals ( bld. toString ( ), versions. toString ( ) )
************************************
************************************
[+] input: testVersionsToString() { List<ApiVersion> versionList = new ArrayList<>(); for (ApiKeys apiKey : ApiKeys.values()) { if (apiKey == ApiKeys.DELETE_TOPICS) { versionList.add(new ApiVersion(apiKey.id, (short) 10000, (short) 10001)); } else { versionList.add(new ApiVersion(apiKey)); } } NodeApiVersions versions = new NodeApiVersions(versionList); StringBuilder bld = new StringBuilder(); String prefix = "("; for (ApiKeys apiKey : ApiKeys.values()) { bld.append(prefix); if (apiKey == ApiKeys.DELETE_TOPICS) { bld.append("DeleteTopics(20): 10000 to 10001 [unusable: node too new]"); } else { bld.append(apiKey.name).append("("). append(apiKey.id).append("): "); if (apiKey.oldestVersion() == apiKey.latestVersion()) { bld.append(apiKey.oldestVersion()); } else { bld.append(apiKey.oldestVersion()). append(" to "). append(apiKey.latestVersion()); } bld.append(" [usable: ").append(apiKey.latestVersion()). append("]"); } prefix = ", "; } bld.append(")"); "<AssertPlaceHolder>"; }
toString() { return toString(false); }
[*] target: assertEquals(bld.toString(), versions.toString())
[-] pred: org. junit. Assert. assertEquals ( bld. toString ( ), versions. toString ( ) )
************************************
************************************
[+] input: Exception { client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));  int numRequests = 1000; TopicPartition tp = new TopicPartition("foo", 0); final AtomicInteger responses = new AtomicInteger(0);  for (int i = 0; i < numRequests; i++) { Map<TopicPartition, OffsetAndMetadata> offsets = singletonMap(tp, new OffsetAndMetadata(i)); coordinator.commitOffsetsAsync(offsets, new OffsetCommitCallback() { @Override public void onComplete(Map<TopicPartition, OffsetAndMetadata> offsets, Exception exception) { responses.incrementAndGet(); Throwable cause = exception.getCause(); assertTrue("Unexpected exception cause type: " + (cause == null ? null : cause.getClass()), cause instanceof DisconnectException); } }); }  coordinator.markCoordinatorUnknown(); consumerClient.pollNoWakeup(); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; }
invokeCompletedOffsetCommitCallbacks() { while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) break; completion.invoke(); } }
[*] target: assertEquals(numRequests, responses.get())
[-] pred: org. junit. Assert. assertEquals ( numRequests, responses. get ( ) )
************************************
************************************
[+] input: testCommitOffsetOnly() { subscriptions.assignFromUser(singleton(t1p));  client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);  AtomicBoolean success = new AtomicBoolean(false); coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success)); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; }
invokeCompletedOffsetCommitCallbacks() { while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) break; completion.invoke(); } }
[*] target: assertTrue(success.get())
[-] pred: org. junit. Assert. assertTrue ( success. get ( ) )
************************************
************************************
[+] input: testCommitOffsetMetadata() { subscriptions.assignFromUser(singleton(t1p));  client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);  AtomicBoolean success = new AtomicBoolean(false);  Map<TopicPartition, OffsetAndMetadata> offsets = singletonMap(t1p, new OffsetAndMetadata(100L, "hello")); coordinator.commitOffsetsAsync(offsets, callback(offsets, success)); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; }
invokeCompletedOffsetCommitCallbacks() { while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) break; completion.invoke(); } }
[*] target: assertTrue(success.get())
[-] pred: org. junit. Assert. assertTrue ( success. get ( ) )
************************************
************************************
[+] input: testCommitAfterLeaveGroup() { // enable auto-assignment subscriptions.subscribe(singleton(topic1), rebalanceListener);  joinAsFollowerAndReceiveAssignment("consumer", coordinator, singletonList(t1p));  // now switch to manual assignment client.prepareResponse(new LeaveGroupResponse(new LeaveGroupResponseData().setErrorCode(Errors.NONE.code()))); subscriptions.unsubscribe(); coordinator.maybeLeaveGroup(); subscriptions.assignFromUser(singleton(t1p));  // the client should not reuse generation/memberId from auto-subscribed generation client.prepareResponse(new MockClient.RequestMatcher() { @Override public boolean matches(AbstractRequest body) { OffsetCommitRequest commitRequest = (OffsetCommitRequest) body; return commitRequest.memberId().equals(OffsetCommitRequest.DEFAULT_MEMBER_ID) && commitRequest.generationId() == OffsetCommitRequest.DEFAULT_GENERATION_ID; } }, offsetCommitResponse(singletonMap(t1p, Errors.NONE)));  AtomicBoolean success = new AtomicBoolean(false); coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success)); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; }
invokeCompletedOffsetCommitCallbacks() { while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) break; completion.invoke(); } }
[*] target: assertTrue(success.get())
[-] pred: org. junit. Assert. assertTrue ( success. get ( ) )
************************************
************************************
[+] input: testVoidFuture() { RequestFuture<Void> future = new RequestFuture<>(); future.complete(null); assertTrue(future.isDone()); "<AssertPlaceHolder>"; }
value() { if (!succeeded()) throw new IllegalStateException("Attempt to retrieve value from future which hasn't successfully completed"); return (T) result.get(); }
[*] target: assertNull(future.value())
[-] pred: org. junit. Assert. assertNull ( future. value() )
************************************
************************************
[+] input: shouldBeginTransactions() { buildMockProducer(true); producer.initTransactions(); producer.beginTransaction(); "<AssertPlaceHolder>"; }
transactionInFlight() { return this.transactionInFlight; }
[*] target: assertTrue(producer.transactionInFlight())
[-] pred: org. junit. Assert. assertTrue ( producer. transactionInFlight() )
************************************
************************************
[+] input: shouldNotBeFlushedWithNoAutoCompleteIfBufferedRecords() { buildMockProducer(false); producer.send(record1); "<AssertPlaceHolder>"; }
flushed() { return this.completions.isEmpty(); }
[*] target: assertFalse(producer.flushed())
[-] pred: org. junit. Assert. assertFalse ( producer. flushed() )
************************************
************************************
[+] input: shouldNotBeFlushedAfterFlush() { buildMockProducer(false); producer.send(record1); producer.flush(); "<AssertPlaceHolder>"; }
flushed() { return this.completions.isEmpty(); }
[*] target: assertTrue(producer.flushed())
[-] pred: org. junit. Assert. assertTrue ( producer. flushed() )
************************************
************************************
[+] input: testChecksumNullForMagicV2() { ProducerBatch batch = new ProducerBatch(new TopicPartition("topic", 1), memoryRecordsBuilder, now); FutureRecordMetadata future = batch.tryAppend(now, null, new byte[10], Record.EMPTY_HEADERS, null, now); "<AssertPlaceHolder>"; assertNull(future.checksumOrNull()); }
tryAppend(long timestamp, byte[] key, byte[] value, Header[] headers, Callback callback, long now) { if (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) { return null; } else { Long checksum = this.recordsBuilder.append(timestamp, key, value, headers); this.maxRecordSize = Math.max(this.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(), recordsBuilder.compressionType(), key, value, headers)); this.lastAppendTime = now; FutureRecordMetadata future = new FutureRecordMetadata(this.produceFuture, this.recordCount, timestamp, checksum, key == null ? -1 : key.length, value == null ? -1 : value.length, Time.SYSTEM); // we have to keep every future returned to the users in case the batch needs to be // split to several new batches and resent. thunks.add(new Thunk(callback, future)); this.recordCount++; return future; } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testAppendedChecksumMagicV0AndV1() { for (byte magic : Arrays.asList(MAGIC_VALUE_V0, MAGIC_VALUE_V1)) { MemoryRecordsBuilder builder = MemoryRecords.builder(ByteBuffer.allocate(128), magic, CompressionType.NONE, TimestampType.CREATE_TIME, 0L); ProducerBatch batch = new ProducerBatch(new TopicPartition("topic", 1), builder, now); byte[] key = "hi".getBytes(); byte[] value = "there".getBytes();  FutureRecordMetadata future = batch.tryAppend(now, key, value, Record.EMPTY_HEADERS, null, now); "<AssertPlaceHolder>"; byte attributes = LegacyRecord.computeAttributes(magic, CompressionType.NONE, TimestampType.CREATE_TIME); long expectedChecksum = LegacyRecord.computeChecksum(magic, attributes, now, key, value); assertEquals(expectedChecksum, future.checksumOrNull().longValue()); } }
tryAppend(long timestamp, byte[] key, byte[] value, Header[] headers, Callback callback, long now) { if (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) { return null; } else { Long checksum = this.recordsBuilder.append(timestamp, key, value, headers); this.maxRecordSize = Math.max(this.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(), recordsBuilder.compressionType(), key, value, headers)); this.lastAppendTime = now; FutureRecordMetadata future = new FutureRecordMetadata(this.produceFuture, this.recordCount, timestamp, checksum, key == null ? -1 : key.length, value == null ? -1 : value.length, Time.SYSTEM); // we have to keep every future returned to the users in case the batch needs to be // split to several new batches and resent. thunks.add(new Thunk(callback, future)); this.recordCount++; return future; } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testIsSendToPartitionAllowedWithInFlightPartitionAddAfterFatalError() { final long pid = 13131L; final short epoch = 1;  doInitTransactions(pid, epoch);  transactionManager.beginTransaction(); transactionManager.maybeAddPartitionToTransaction(tp0);  // Send the AddPartitionsToTxn request and leave it in-flight sender.run(time.milliseconds()); transactionManager.transitionToFatalError(new KafkaException());  assertFalse(transactionManager.isSendToPartitionAllowed(tp0)); "<AssertPlaceHolder>"; }
hasFatalError() { return currentState == State.FATAL_ERROR; }
[*] target: assertTrue(transactionManager.hasFatalError())
[-] pred: org. junit. Assert. assertTrue ( transactionManager. hasFatalError() )
************************************
************************************
[+] input: testBootstrap() { String ipAddress = "140.211.11.105"; String hostName = "www.example.com"; Cluster cluster = Cluster.bootstrap(Arrays.asList( new InetSocketAddress(ipAddress, 9002), new InetSocketAddress(hostName, 9002) )); Set<String> expectedHosts = Utils.mkSet(ipAddress, hostName); Set<String> actualHosts = new HashSet<>(); for (Node node : cluster.nodes()) actualHosts.add(node.host()); "<AssertPlaceHolder>"; }
nodes() { return this.nodes; }
[*] target: assertEquals(expectedHosts, actualHosts)
[-] pred: org. junit. Assert. assertEquals ( expectedHosts, actualHosts )
************************************
************************************
[+] input: testToString() { String topic = "sample"; int partition = 0; Node leader = new Node(0, "localhost", 9092); Node r1 = new Node(1, "localhost", 9093); Node r2 = new Node(2, "localhost", 9094); Node[] replicas = new Node[] {leader, r1, r2}; Node[] inSyncReplicas = new Node[] {leader, r1}; Node[] offlineReplicas = new Node[] {r2}; PartitionInfo partitionInfo = new PartitionInfo(topic, partition, leader, replicas, inSyncReplicas, offlineReplicas);  String expected = String.format("Partition(topic = %s, partition = %d, leader = %s, replicas = %s, isr = %s, offlineReplicas = %s)", topic, partition, leader.idString(), "[0,1,2]", "[0,1]", "[2]"); Assert."<AssertPlaceHolder>"; }
toString() { return String.format("Partition(topic = %s, partition = %d, leader = %s, replicas = %s, isr = %s, offlineReplicas = %s)", topic, partition, leader == null ? "none" : leader.idString(), formatNodeIds(replicas), formatNodeIds(inSyncReplicas), formatNodeIds(offlineReplicas)); }
[*] target: assertEquals(expected, partitionInfo.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, partitionInfo. toString ( ) )
************************************
************************************
[+] input: toRst() { final ConfigDef def = new ConfigDef() .define("opt1", Type.STRING, "a", ValidString.in("a", "b", "c"), Importance.HIGH, "docs1") .define("opt2", Type.INT, Importance.MEDIUM, "docs2") .define("opt3", Type.LIST, Arrays.asList("a", "b"), Importance.LOW, "docs3");  final String expectedRst = "" + "``opt2``\n" + "  docs2\n" + "\n" + "  * Type: int\n" + "  * Importance: medium\n" + "\n" + "``opt1``\n" + "  docs1\n" + "\n" + "  * Type: string\n" + "  * Default: a\n" + "  * Valid Values: [a, b, c]\n" + "  * Importance: high\n" + "\n" + "``opt3``\n" + "  docs3\n" + "\n" + "  * Type: list\n" + "  * Default: a,b\n" + "  * Importance: low\n" + "\n";  "<AssertPlaceHolder>"; }
toRst() { StringBuilder b = new StringBuilder(); for (ConfigKey key : sortedConfigs()) { if (key.internalConfig) { continue; } getConfigKeyRst(key, b); b.append("\n"); } return b.toString(); }
[*] target: assertEquals(expectedRst, def.toRst())
[-] pred: org. junit. Assert. assertEquals ( expectedRst, def. toRst ( ) )
************************************
************************************
[+] input: IOException { RecordHeaders headers = new RecordHeaders(); headers.add(new RecordHeader("key", "value".getBytes())); headers.add(new RecordHeader("key1", "key1value".getBytes())); headers.add(new RecordHeader("key", "value2".getBytes())); headers.add(new RecordHeader("key2", "key2value".getBytes()));   Iterator<Header> keyHeaders = headers.headers("key").iterator(); assertHeader("key", "value", keyHeaders.next()); assertHeader("key", "value2", keyHeaders.next()); assertFalse(keyHeaders.hasNext());  keyHeaders = headers.headers("key1").iterator(); assertHeader("key1", "key1value", keyHeaders.next()); assertFalse(keyHeaders.hasNext());  keyHeaders = headers.headers("key2").iterator(); assertHeader("key2", "key2value", keyHeaders.next()); "<AssertPlaceHolder>";  }
hasNext() { return original.hasNext(); }
[*] target: assertFalse(keyHeaders.hasNext())
[-] pred: org. junit. Assert. assertFalse ( keyHeaders. hasNext ( ) )
************************************
************************************
[+] input: testSetLogAppendTimeV1() { MemoryRecords records = MemoryRecords.withRecords(RecordBatch.MAGIC_VALUE_V1, 0L, CompressionType.GZIP, TimestampType.CREATE_TIME, new SimpleRecord(1L, "a".getBytes(), "1".getBytes()), new SimpleRecord(2L, "b".getBytes(), "2".getBytes()), new SimpleRecord(3L, "c".getBytes(), "3".getBytes()));  long logAppendTime = 15L;  ByteBufferLegacyRecordBatch batch = new ByteBufferLegacyRecordBatch(records.buffer()); batch.setMaxTimestamp(TimestampType.LOG_APPEND_TIME, logAppendTime); assertEquals(TimestampType.LOG_APPEND_TIME, batch.timestampType()); assertEquals(logAppendTime, batch.maxTimestamp()); assertTrue(batch.isValid());  List<MutableRecordBatch> recordBatches = Utils.toList(records.batches().iterator()); assertEquals(1, recordBatches.size()); assertEquals(TimestampType.LOG_APPEND_TIME, recordBatches.get(0).timestampType()); assertEquals(logAppendTime, recordBatches.get(0).maxTimestamp());  for (Record record : records.records()) "<AssertPlaceHolder>"; }
timestamp() { return outerRecord().timestamp(); }
[*] target: assertEquals(logAppendTime, record.timestamp())
[-] pred: org. junit. Assert. assertEquals ( logAppendTime, record. timestamp() )
************************************
************************************
[+] input: testSerde() { int coordinatorEpoch = 79; EndTransactionMarker marker = new EndTransactionMarker(ControlRecordType.COMMIT, coordinatorEpoch); ByteBuffer buffer = marker.serializeValue(); EndTransactionMarker deserialized = EndTransactionMarker.deserializeValue(ControlRecordType.COMMIT, buffer); "<AssertPlaceHolder>"; }
coordinatorEpoch() { return coordinatorEpoch; }
[*] target: assertEquals(coordinatorEpoch, deserialized.coordinatorEpoch())
[-] pred: org. junit. Assert. assertEquals ( coordinatorEpoch, deserialized. coordinatorEpoch() )
************************************
************************************
[+] input: IOException { try (FileRecords fileRecords = FileRecords.open(tempFile())) { FileLogInputStream logInputStream = new FileLogInputStream(fileRecords, Integer.MAX_VALUE, Integer.MAX_VALUE); "<AssertPlaceHolder>"; } }
nextBatch() throws IOException { FileChannel channel = fileRecords.channel(); if (position >= end - HEADER_SIZE_UP_TO_MAGIC) return null;  logHeaderBuffer.rewind(); Utils.readFullyOrFail(channel, logHeaderBuffer, position, "log header");  logHeaderBuffer.rewind(); long offset = logHeaderBuffer.getLong(OFFSET_OFFSET); int size = logHeaderBuffer.getInt(SIZE_OFFSET);  // V0 has the smallest overhead, stricter checking is done later if (size < LegacyRecord.RECORD_OVERHEAD_V0) throw new CorruptRecordException(String.format("Found record size %d smaller than minimum record " + "overhead (%d) in file %s.", size, LegacyRecord.RECORD_OVERHEAD_V0, fileRecords.file()));  if (position > end - LOG_OVERHEAD - size) return null;  byte magic = logHeaderBuffer.get(MAGIC_OFFSET); final FileChannelRecordBatch batch;  if (magic < RecordBatch.MAGIC_VALUE_V2) batch = new LegacyFileChannelRecordBatch(offset, magic, fileRecords, position, size); else batch = new DefaultFileChannelRecordBatch(offset, magic, fileRecords, position, size);  position += batch.sizeInBytes(); return batch; }
[*] target: assertNull(logInputStream.nextBatch())
[-] pred: org. junit. Assert. assertNull ( logInputStream. nextBatch ( ) )
************************************
************************************
[+] input: IOException { try (FileRecords fileRecords = FileRecords.open(tempFile())) { FileLogInputStream logInputStream = new FileLogInputStream(fileRecords, 0, 0); "<AssertPlaceHolder>"; } }
nextBatch() throws IOException { FileChannel channel = fileRecords.channel(); if (position >= end - HEADER_SIZE_UP_TO_MAGIC) return null;  logHeaderBuffer.rewind(); Utils.readFullyOrFail(channel, logHeaderBuffer, position, "log header");  logHeaderBuffer.rewind(); long offset = logHeaderBuffer.getLong(OFFSET_OFFSET); int size = logHeaderBuffer.getInt(SIZE_OFFSET);  // V0 has the smallest overhead, stricter checking is done later if (size < LegacyRecord.RECORD_OVERHEAD_V0) throw new CorruptRecordException(String.format("Found record size %d smaller than minimum record " + "overhead (%d) in file %s.", size, LegacyRecord.RECORD_OVERHEAD_V0, fileRecords.file()));  if (position > end - LOG_OVERHEAD - size) return null;  byte magic = logHeaderBuffer.get(MAGIC_OFFSET); final FileChannelRecordBatch batch;  if (magic < RecordBatch.MAGIC_VALUE_V2) batch = new LegacyFileChannelRecordBatch(offset, magic, fileRecords, position, size); else batch = new DefaultFileChannelRecordBatch(offset, magic, fileRecords, position, size);  position += batch.sizeInBytes(); return batch; }
[*] target: assertNull(logInputStream.nextBatch())
[-] pred: org. junit. Assert. assertNull ( logInputStream. nextBatch ( ) )
************************************
************************************
[+] input: convertV2ToV1UsingMixedCreateAndLogAppendTime() { if (compressionType == CompressionType.ZSTD) { exceptionRule.expect(UnsupportedCompressionTypeException.class); exceptionRule.expectMessage("Down-conversion of zstandard-compressed batches is not supported"); }  ByteBuffer buffer = ByteBuffer.allocate(512); MemoryRecordsBuilder builder = MemoryRecords.builder(buffer, RecordBatch.MAGIC_VALUE_V2, compressionType, TimestampType.LOG_APPEND_TIME, 0L); builder.append(10L, "1".getBytes(), "a".getBytes()); builder.close();  int sizeExcludingTxnMarkers = buffer.position();  MemoryRecords.writeEndTransactionalMarker(buffer, 1L, System.currentTimeMillis(), 0, 15L, (short) 0, new EndTransactionMarker(ControlRecordType.ABORT, 0));  int position = buffer.position();  builder = MemoryRecords.builder(buffer, RecordBatch.MAGIC_VALUE_V2, compressionType, TimestampType.CREATE_TIME, 1L); builder.append(12L, "2".getBytes(), "b".getBytes()); builder.append(13L, "3".getBytes(), "c".getBytes()); builder.close();  sizeExcludingTxnMarkers += buffer.position() - position;  MemoryRecords.writeEndTransactionalMarker(buffer, 14L, System.currentTimeMillis(), 0, 1L, (short) 0, new EndTransactionMarker(ControlRecordType.COMMIT, 0));  buffer.flip();  ConvertedRecords<MemoryRecords> convertedRecords = MemoryRecords.readableRecords(buffer) .downConvert(RecordBatch.MAGIC_VALUE_V1, 0, time); MemoryRecords records = convertedRecords.records();  // Transactional markers are skipped when down converting to V1, so exclude them from size verifyRecordsProcessingStats(convertedRecords.recordConversionStats(), 3, 3, records.sizeInBytes(), sizeExcludingTxnMarkers);  List<? extends RecordBatch> batches = Utils.toList(records.batches().iterator()); if (compressionType != CompressionType.NONE) { "<AssertPlaceHolder>"; assertEquals(TimestampType.LOG_APPEND_TIME, batches.get(0).timestampType()); assertEquals(TimestampType.CREATE_TIME, batches.get(1).timestampType()); } else { assertEquals(3, batches.size()); assertEquals(TimestampType.LOG_APPEND_TIME, batches.get(0).timestampType()); assertEquals(TimestampType.CREATE_TIME, batches.get(1).timestampType()); assertEquals(TimestampType.CREATE_TIME, batches.get(2).timestampType()); }  List<Record> logRecords = Utils.toList(records.records().iterator()); assertEquals(3, logRecords.size()); assertEquals(ByteBuffer.wrap("1".getBytes()), logRecords.get(0).key()); assertEquals(ByteBuffer.wrap("2".getBytes()), logRecords.get(1).key()); assertEquals(ByteBuffer.wrap("3".getBytes()), logRecords.get(2).key()); }
close() { if (aborted) throw new IllegalStateException("Cannot close MemoryRecordsBuilder as it has already been aborted");  if (builtRecords != null) return;  validateProducerState();  closeForRecordAppends();  if (numRecords == 0L) { buffer().position(initialPosition); builtRecords = MemoryRecords.EMPTY; } else { if (magic > RecordBatch.MAGIC_VALUE_V1) this.actualCompressionRatio = (float) writeDefaultBatchHeader() / this.uncompressedRecordsSizeInBytes; else if (compressionType != CompressionType.NONE) this.actualCompressionRatio = (float) writeLegacyCompressedWrapperHeader() / this.uncompressedRecordsSizeInBytes;  ByteBuffer buffer = buffer().duplicate(); buffer.flip(); buffer.position(initialPosition); builtRecords = MemoryRecords.readableRecords(buffer.slice()); } }
[*] target: assertEquals(2, batches.size())
[-] pred: org. junit. Assert. assertEquals ( 2, batches. size ( ) )
************************************
************************************
[+] input: IOException { String dest = "1"; int numChunks = 4; int chunkSize = 32; int totalSize = numChunks * chunkSize;  Queue<Send> sends = new LinkedList<>(); ByteBuffer[] chunks = new ByteBuffer[numChunks];  for (int i = 0; i < numChunks; i++) { ByteBuffer buffer = ByteBuffer.wrap(TestUtils.randomBytes(chunkSize)); chunks[i] = buffer; sends.add(new ByteBufferSend(dest, buffer)); }  MultiRecordsSend send = new MultiRecordsSend(dest, sends); assertEquals(totalSize, send.size());  for (int i = 0; i < numChunks; i++) { assertEquals(numChunks - i, send.numResidentSends()); NonOverflowingByteBufferChannel out = new NonOverflowingByteBufferChannel(chunkSize); send.writeTo(out); out.close(); assertEquals(chunks[i], out.buffer()); }  assertEquals(0, send.numResidentSends()); "<AssertPlaceHolder>"; }
completed() { return current == null; }
[*] target: assertTrue(send.completed())
[-] pred: org. junit. Assert. assertTrue ( send. completed() )
************************************
************************************
[+] input: Exception { final MemoryRecords memoryRecords = MemoryRecords.withTransactionalRecords(0, CompressionType.NONE, 1L, (short) 1, 1, 1, simpleRecord); final ProduceRequest request = ProduceRequest.Builder.forCurrentMagic((short) -1, 10, Collections.singletonMap(new TopicPartition("topic", 1), memoryRecords)).build(); "<AssertPlaceHolder>"; }
hasTransactionalRecords() { return hasTransactionalRecords; }
[*] target: assertTrue(request.hasTransactionalRecords())
[-] pred: org. junit. Assert. assertTrue ( request. hasTransactionalRecords ( ) )
************************************
************************************
[+] input: Exception { final MemoryRecords memoryRecords = MemoryRecords.withIdempotentRecords(1, CompressionType.NONE, 1L, (short) 1, 1, 1, simpleRecord); final ProduceRequest request = ProduceRequest.Builder.forCurrentMagic((short) -1, 10, Collections.singletonMap(new TopicPartition("topic", 1), memoryRecords)).build(); "<AssertPlaceHolder>"; }
hasIdempotentRecords() { return hasIdempotentRecords; }
[*] target: assertTrue(request.hasIdempotentRecords())
[-] pred: org. junit. Assert. assertTrue ( request. hasIdempotentRecords ( ) )
************************************
************************************
[+] input: testMixedTransactionalData() { final long producerId = 15L; final short producerEpoch = 5; final int sequence = 10; final String transactionalId = "txnlId";  final MemoryRecords nonTxnRecords = MemoryRecords.withRecords(CompressionType.NONE, new SimpleRecord("foo".getBytes())); final MemoryRecords txnRecords = MemoryRecords.withTransactionalRecords(CompressionType.NONE, producerId, producerEpoch, sequence, new SimpleRecord("bar".getBytes()));  final Map<TopicPartition, MemoryRecords> recordsByPartition = new LinkedHashMap<>(); recordsByPartition.put(new TopicPartition("foo", 0), txnRecords); recordsByPartition.put(new TopicPartition("foo", 1), nonTxnRecords);  final ProduceRequest.Builder builder = ProduceRequest.Builder.forMagic(RecordVersion.current().value, (short) -1, 5000, recordsByPartition, transactionalId);  final ProduceRequest request = builder.build(); assertTrue(request.hasTransactionalRecords()); "<AssertPlaceHolder>"; }
hasIdempotentRecords() { return hasIdempotentRecords; }
[*] target: assertTrue(request.hasIdempotentRecords())
[-] pred: org. junit. Assert. assertTrue ( request. hasIdempotentRecords ( ) )
************************************
************************************
[+] input: testMixedIdempotentData() { final long producerId = 15L; final short producerEpoch = 5; final int sequence = 10;  final MemoryRecords nonTxnRecords = MemoryRecords.withRecords(CompressionType.NONE, new SimpleRecord("foo".getBytes())); final MemoryRecords txnRecords = MemoryRecords.withIdempotentRecords(CompressionType.NONE, producerId, producerEpoch, sequence, new SimpleRecord("bar".getBytes()));  final Map<TopicPartition, MemoryRecords> recordsByPartition = new LinkedHashMap<>(); recordsByPartition.put(new TopicPartition("foo", 0), txnRecords); recordsByPartition.put(new TopicPartition("foo", 1), nonTxnRecords);  final ProduceRequest.Builder builder = ProduceRequest.Builder.forMagic(RecordVersion.current().value, (short) -1, 5000, recordsByPartition, null);  final ProduceRequest request = builder.build(); assertFalse(request.hasTransactionalRecords()); "<AssertPlaceHolder>"; }
hasIdempotentRecords() { return hasIdempotentRecords; }
[*] target: assertTrue(request.hasIdempotentRecords())
[-] pred: org. junit. Assert. assertTrue ( request. hasIdempotentRecords ( ) )
************************************
************************************
[+] input: testRequestHeader() { RequestHeader header = new RequestHeader(ApiKeys.FIND_COORDINATOR, (short) 1, "", 10); ByteBuffer buffer = toBuffer(header.toStruct()); RequestHeader deserialized = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { try { short apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); Schema schema = schema(apiKey, apiVersion); buffer.rewind(); return new RequestHeader(schema.read(buffer)); } catch (InvalidRequestException e) { throw e; } catch (Throwable  ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + buffer.getShort(0), ex); } }
[*] target: assertEquals(header, deserialized)
[-] pred: org. junit. Assert. assertEquals ( header, deserialized )
************************************
************************************
[+] input: testError() { String errorCode = "errorCode"; String errorDescription = "errorDescription"; String errorUri = "errorUri"; OAuthBearerTokenCallback callback = new OAuthBearerTokenCallback(); callback.error(errorCode, errorDescription, errorUri); assertEquals(errorCode, callback.errorCode()); assertEquals(errorDescription, callback.errorDescription()); assertEquals(errorUri, callback.errorUri()); "<AssertPlaceHolder>"; }
token() { return token; }
[*] target: assertNull(callback.token())
[-] pred: org. junit. Assert. assertNull ( callback. token() )
************************************
************************************
[+] input: testToken() { OAuthBearerTokenCallback callback = new OAuthBearerTokenCallback(); callback.token(TOKEN); assertSame(TOKEN, callback.token()); assertNull(callback.errorCode()); assertNull(callback.errorDescription()); "<AssertPlaceHolder>"; }
errorUri() { return errorUri; }
[*] target: assertNull(callback.errorUri())
[-] pred: org. junit. Assert. assertNull ( callback. errorUri() )
************************************
************************************
[+] input: testError() { String errorStatus = "errorStatus"; String errorScope = "errorScope"; String errorOpenIDConfiguration = "errorOpenIDConfiguration"; OAuthBearerValidatorCallback callback = new OAuthBearerValidatorCallback(TOKEN.value()); callback.error(errorStatus, errorScope, errorOpenIDConfiguration); assertEquals(errorStatus, callback.errorStatus()); assertEquals(errorScope, callback.errorScope()); assertEquals(errorOpenIDConfiguration, callback.errorOpenIDConfiguration()); "<AssertPlaceHolder>"; }
token() { return token; }
[*] target: assertNull(callback.token())
[-] pred: org. junit. Assert. assertNull ( callback. token() )
************************************
************************************
[+] input: testToken() { OAuthBearerValidatorCallback callback = new OAuthBearerValidatorCallback(TOKEN.value()); callback.token(TOKEN); assertSame(TOKEN, callback.token()); assertNull(callback.errorStatus()); assertNull(callback.errorScope()); "<AssertPlaceHolder>"; }
errorOpenIDConfiguration() { return errorOpenIDConfiguration; }
[*] target: assertNull(callback.errorOpenIDConfiguration())
[-] pred: org. junit. Assert. assertNull ( callback. errorOpenIDConfiguration() )
************************************
************************************
[+] input: Exception { String expectedMesssage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001";  Map<String, String> extensions = new HashMap<>(); extensions.put("nineteen", "42"); OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse("123.345.567", new SaslExtensions(extensions));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (extensions.length() > 0) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(expectedMesssage, message)
[-] pred: org. junit. Assert. assertEquals ( expectedMesssage, message )
************************************
************************************
[+] input: Exception { String serverMessage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001"; OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse(serverMessage.getBytes(StandardCharsets.UTF_8));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (extensions.length() > 0) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(serverMessage, message)
[-] pred: org. junit. Assert. assertEquals ( serverMessage, message )
************************************
************************************
[+] input: fromGoodConfig() { ExpiringCredentialRefreshConfig expiringCredentialRefreshConfig = new ExpiringCredentialRefreshConfig( new ConfigDef().withClientSaslSupport().parse(Collections.emptyMap()), true); assertEquals(Double.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_WINDOW_FACTOR), Double.valueOf(expiringCredentialRefreshConfig.loginRefreshWindowFactor())); assertEquals(Double.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_WINDOW_JITTER), Double.valueOf(expiringCredentialRefreshConfig.loginRefreshWindowJitter())); assertEquals(Short.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_MIN_PERIOD_SECONDS), Short.valueOf(expiringCredentialRefreshConfig.loginRefreshMinPeriodSeconds())); assertEquals(Short.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_BUFFER_SECONDS), Short.valueOf(expiringCredentialRefreshConfig.loginRefreshBufferSeconds())); "<AssertPlaceHolder>"; }
loginRefreshReloginAllowedBeforeLogout() { return loginRefreshReloginAllowedBeforeLogout; }
[*] target: assertTrue(expiringCredentialRefreshConfig.loginRefreshReloginAllowedBeforeLogout())
[-] pred: org. junit. Assert. assertTrue ( expiringCredentialRefreshConfig. loginRefreshReloginAllowedBeforeLogout() )
************************************
************************************
[+] input: Exception { File trustStoreFile = File.createTempFile("truststore", ".jks"); Map<String, Object> serverSslConfig = TestSslUtils.createSslConfig(false, true, Mode.SERVER, trustStoreFile, "server"); SslFactory sslFactory = new SslFactory(Mode.SERVER); sslFactory.configure(serverSslConfig); //host and port are hints SSLEngine engine = sslFactory.createSslEngine("localhost", 0); "<AssertPlaceHolder>"; String[] expectedProtocols = {"TLSv1.2"}; assertArrayEquals(expectedProtocols, engine.getEnabledProtocols()); assertEquals(false, engine.getUseClientMode()); }
createSslEngine(String peerHost, int peerPort) { return createSslEngine(sslContext, peerHost, peerPort); }
[*] target: assertNotNull(engine)
[-] pred: org. junit. Assert. assertNotNull ( engine )
************************************
************************************
[+] input: testIterator() { int max = 10; List<Integer> l = new ArrayList<Integer>(); for (int i = 0; i < max; i++) l.add(i); ListIterator<Integer> iter = new ListIterator<Integer>(l); for (int i = 0; i < max; i++) { Integer value = i; assertEquals(value, iter.peek()); assertTrue(iter.hasNext()); assertEquals(value, iter.next()); } "<AssertPlaceHolder>"; }
hasNext() { switch (state) { case FAILED: throw new IllegalStateException("Iterator is in failed state"); case DONE: return false; case READY: return true; default: return maybeComputeNext(); } }
[*] target: assertFalse(iter.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iter. hasNext() )
************************************
************************************
[+] input: testReadUnsignedInt() { ByteBuffer buffer = ByteBuffer.allocate(4); long writeValue = 133444; ByteUtils.writeUnsignedInt(buffer, writeValue); buffer.flip(); long readValue = ByteUtils.readUnsignedInt(buffer); "<AssertPlaceHolder>"; }
readUnsignedInt(ByteBuffer buffer) { return buffer.getInt() & 0xffffffffL; }
[*] target: assertEquals(writeValue, readValue)
[-] pred: org. junit. Assert. assertEquals ( writeValue, readValue )
************************************
************************************
[+] input: testTimeoutOverflow() { Timer timer = time.timer(Long.MAX_VALUE); assertEquals(Long.MAX_VALUE - timer.currentTimeMs(), timer.remainingMs()); "<AssertPlaceHolder>"; }
elapsedMs() { return currentTimeMs - startMs; }
[*] target: assertEquals(0, timer.elapsedMs())
[-] pred: org. junit. Assert. assertEquals ( 0, timer. elapsedMs() )
************************************
************************************
[+] input: testTimerSleep() { Timer timer = time.timer(500); long currentTimeMs = timer.currentTimeMs();  timer.sleep(200); assertEquals(time.milliseconds(), timer.currentTimeMs()); assertEquals(currentTimeMs + 200, timer.currentTimeMs());  timer.sleep(1000); assertEquals(time.milliseconds(), timer.currentTimeMs()); assertEquals(currentTimeMs + 500, timer.currentTimeMs()); "<AssertPlaceHolder>"; }
isExpired() { return currentTimeMs >= deadlineMs; }
[*] target: assertTrue(timer.isExpired())
[-] pred: org. junit. Assert. assertTrue ( timer. isExpired() )
************************************
************************************
[+] input: testEmptyStruct() { final SchemaBuilder emptyStructSchemaBuilder = SchemaBuilder.struct(); assertEquals(0, emptyStructSchemaBuilder.fields().size()); new Struct(emptyStructSchemaBuilder);  final Schema emptyStructSchema = emptyStructSchemaBuilder.build(); "<AssertPlaceHolder>"; new Struct(emptyStructSchema); }
fields() { if (type != Type.STRUCT) throw new DataException("Cannot list fields on non-struct type"); return new ArrayList<>(fields.values()); }
[*] target: assertEquals(0, emptyStructSchema.fields().size())
[-] pred: org. junit. Assert. assertEquals ( 0, emptyStructSchema. fields ( ). size ( ) )
************************************
************************************
[+] input: testTaskClass() { replayAll();  connector.start(sinkProperties); "<AssertPlaceHolder>";  verifyAll(); }
taskClass() { return FileStreamSinkTask.class; }
[*] target: assertEquals(FileStreamSinkTask.class, connector.taskClass())
[-] pred: org. junit. Assert. assertEquals ( FileStreamSinkTask.class, connector. taskClass() )
************************************
************************************
[+] input: testSourceTasksStdin() { EasyMock.replay(ctx);  sourceProperties.remove(FileStreamSourceConnector.FILE_CONFIG); connector.start(sourceProperties); List<Map<String, String>> taskConfigs = connector.taskConfigs(1); "<AssertPlaceHolder>"; assertNull(taskConfigs.get(0).get(FileStreamSourceConnector.FILE_CONFIG));  EasyMock.verify(ctx); }
taskConfigs(int maxTasks) { ArrayList<Map<String, String>> configs = new ArrayList<>(); // Only one input stream makes sense. Map<String, String> config = new HashMap<>(); if (filename != null) config.put(FILE_CONFIG, filename); config.put(TOPIC_CONFIG, topic); config.put(TASK_BATCH_SIZE_CONFIG, String.valueOf(batchSize)); configs.add(config); return configs; }
[*] target: assertEquals(1, taskConfigs.size())
[-] pred: org. junit. Assert. assertEquals ( 1, taskConfigs. size ( ) )
************************************
************************************
[+] input: UnsupportedEncodingException { ByteBuffer reference = ByteBuffer.wrap("test-string".getBytes("UTF-8")); String msg = "{ "schema": { "type": "bytes" }, "payload": "dGVzdC1zdHJpbmc=" }"; SchemaAndValue schemaAndValue = converter.toConnectData(TOPIC, msg.getBytes()); ByteBuffer converted = ByteBuffer.wrap((byte[]) schemaAndValue.value()); "<AssertPlaceHolder>"; }
toConnectData(String topic, byte[] value) { JsonNode jsonValue;  // This handles a tombstone message if (value == null) { return SchemaAndValue.NULL; }  try { jsonValue = deserializer.deserialize(topic, value); } catch (SerializationException e) { throw new DataException("Converting byte[] to Kafka Connect data failed due to serialization error: ", e); }  if (enableSchemas && (!jsonValue.isObject() || jsonValue.size() != 2 || !jsonValue.has(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME) || !jsonValue.has(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME))) throw new DataException("JsonConverter with schemas.enable requires "schema" and "payload" fields and may not contain additional fields." + " If you are trying to deserialize plain JSON data, set schemas.enable=false in your converter configuration.");  // The deserialized data should either be an envelope object containing the schema and the payload or the schema // was stripped during serialization and we need to fill in an all-encompassing schema. if (!enableSchemas) { ObjectNode envelope = JsonNodeFactory.instance.objectNode(); envelope.set(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME, null); envelope.set(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME, jsonValue); jsonValue = envelope; }  Schema schema = asConnectSchema(jsonValue.get(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME)); return new SchemaAndValue( schema, convertToConnect(schema, jsonValue.get(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME)) ); }
[*] target: assertEquals(reference, converted)
[-] pred: org. junit. Assert. assertEquals ( reference, converted )
************************************
************************************
[+] input: nullSchemaAndNullValueToJson() { // This characterizes the production of tombstone messages when Json schemas is enabled Map<String, Boolean> props = Collections.singletonMap("schemas.enable", true); converter.configure(props, true); byte[] converted = converter.fromConnectData(TOPIC, null, null); "<AssertPlaceHolder>"; }
fromConnectData(String topic, Schema schema, Object value) { if (schema == null && value == null) { return null; }  JsonNode jsonValue = enableSchemas ? convertToJsonWithEnvelope(schema, value) : convertToJsonWithoutEnvelope(schema, value); try { return serializer.serialize(topic, jsonValue); } catch (SerializationException e) { throw new DataException("Converting Kafka Connect data to byte[] failed due to serialization error: ", e); } }
[*] target: assertNull(converted)
[-] pred: org. junit. Assert. assertNull ( converted )
************************************
************************************
[+] input: currentState() { for (State state : State.values()) { tracker.changeState(state, time.milliseconds()); "<AssertPlaceHolder>"; } }
currentState() { return lastState.get().state; }
[*] target: assertEquals(state, tracker.currentState())
[-] pred: org. junit. Assert. assertEquals ( state, tracker. currentState() )
************************************
************************************
[+] input: Exception { RuntimeException exception = new RuntimeException("Revocation error");  createTask(initialState);  expectInitializeTask(); expectPollInitialAssignment(); expectRebalanceRevocationError(exception);  PowerMock.replayAll();  workerTask.initialize(TASK_CONFIG); workerTask.initializeAndStart(); workerTask.iteration(); try { workerTask.iteration(); fail("Poll should have raised the rebalance exception"); } catch (RuntimeException e) { "<AssertPlaceHolder>"; }  PowerMock.verifyAll(); }
iteration() { final long offsetCommitIntervalMs = workerConfig.getLong(WorkerConfig.OFFSET_COMMIT_INTERVAL_MS_CONFIG);  try { long now = time.milliseconds();  // Maybe commit if (!committing && (context.isCommitRequested() || now >= nextCommit)) { commitOffsets(now, false); nextCommit += offsetCommitIntervalMs; context.clearCommitRequest(); }  final long commitTimeoutMs = commitStarted + workerConfig.getLong(WorkerConfig.OFFSET_COMMIT_TIMEOUT_MS_CONFIG);  // Check for timed out commits if (committing && now >= commitTimeoutMs) { log.warn("{} Commit of offsets timed out", this); commitFailures++; committing = false; }  // And process messages long timeoutMs = Math.max(nextCommit - now, 0); poll(timeoutMs); } catch (WakeupException we) { log.trace("{} Consumer woken up", this);  if (isStopping()) return;  if (shouldPause()) { pauseAll(); onPause(); context.requestCommit(); } else if (!pausedForRedelivery) { resumeAll(); onResume(); } } }
[*] target: assertEquals(exception, e)
[-] pred: org. junit. Assert. assertEquals ( exception, e )
************************************
************************************
[+] input: Exception { RuntimeException exception = new RuntimeException("Assignment error");  createTask(initialState);  expectInitializeTask(); expectPollInitialAssignment(); expectRebalanceAssignmentError(exception);  PowerMock.replayAll();  workerTask.initialize(TASK_CONFIG); workerTask.initializeAndStart(); workerTask.iteration(); try { workerTask.iteration(); fail("Poll should have raised the rebalance exception"); } catch (RuntimeException e) { "<AssertPlaceHolder>"; }  PowerMock.verifyAll(); }
iteration() { final long offsetCommitIntervalMs = workerConfig.getLong(WorkerConfig.OFFSET_COMMIT_INTERVAL_MS_CONFIG);  try { long now = time.milliseconds();  // Maybe commit if (!committing && (context.isCommitRequested() || now >= nextCommit)) { commitOffsets(now, false); nextCommit += offsetCommitIntervalMs; context.clearCommitRequest(); }  final long commitTimeoutMs = commitStarted + workerConfig.getLong(WorkerConfig.OFFSET_COMMIT_TIMEOUT_MS_CONFIG);  // Check for timed out commits if (committing && now >= commitTimeoutMs) { log.warn("{} Commit of offsets timed out", this); commitFailures++; committing = false; }  // And process messages long timeoutMs = Math.max(nextCommit - now, 0); poll(timeoutMs); } catch (WakeupException we) { log.trace("{} Consumer woken up", this);  if (isStopping()) return;  if (shouldPause()) { pauseAll(); onPause(); context.requestCommit(); } else if (!pausedForRedelivery) { resumeAll(); onResume(); } } }
[*] target: assertEquals(exception, e)
[-] pred: org. junit. Assert. assertEquals ( exception, e )
************************************
************************************
[+] input: shouldInstantiateAndConfigureExplicitlySetHeaderConverterWithCurrentClassLoader() { assertNotNull(props.get(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG)); HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNotNull(headerConverter); assertTrue(headerConverter instanceof TestHeaderConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config"));  headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertTrue(headerConverter instanceof TestHeaderConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config")); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { HeaderConverter plugin = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) plugin = getInstance(config, classPropertyName, HeaderConverter.class); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); Class<? extends HeaderConverter> klass; try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(delegatingLoader.headerConverters()) ); } plugin = newPlugin(klass); } if (plugin == null) { throw new ConnectException("Unable to instantiate the Converter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration:{}{}", System.lineSeparator(), converterConfig); plugin.configure(converterConfig); return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: shouldInstantiateAndConfigureConnectRestExtension() { props.put(WorkerConfig.REST_EXTENSION_CLASSES_CONFIG, TestConnectRestExtension.class.getName()); createConfig();  List<ConnectRestExtension> connectRestExtensions = plugins.newPlugins(config.getList(WorkerConfig.REST_EXTENSION_CLASSES_CONFIG), config, ConnectRestExtension.class); "<AssertPlaceHolder>"; assertEquals("One Rest Extension expected", 1, connectRestExtensions.size()); assertNotNull(connectRestExtensions.get(0)); assertTrue("Should be instance of TestConnectRestExtension", connectRestExtensions.get(0) instanceof TestConnectRestExtension); assertNotNull(((TestConnectRestExtension) connectRestExtensions.get(0)).configs); assertEquals(config.originals(), ((TestConnectRestExtension) connectRestExtensions.get(0)).configs); }
newPlugins(List<String> klassNames, AbstractConfig config, Class<T> pluginKlass) { List<T> plugins = new ArrayList<>(); if (klassNames != null) { for (String klassName : klassNames) { plugins.add(newPlugin(klassName, config, pluginKlass)); } } return plugins; }
[*] target: assertNotNull(connectRestExtensions)
[-] pred: org. junit. Assert. assertNotNull ( connectRestExtensions )
************************************
************************************
[+] input: shouldInstantiateAndConfigureDefaultHeaderConverter() { props.remove(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG); createConfig();  // Because it's not explicitly set on the supplied configuration, the logic to use the current classloader for the connector // will exit immediately, and so this method always returns null HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNull(headerConverter); // But we should always find it (or the worker's default) when using the plugins classloader ... headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertTrue(headerConverter instanceof SimpleHeaderConverter); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { HeaderConverter plugin = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) plugin = getInstance(config, classPropertyName, HeaderConverter.class); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); Class<? extends HeaderConverter> klass; try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(delegatingLoader.headerConverters()) ); } plugin = newPlugin(klass); } if (plugin == null) { throw new ConnectException("Unable to instantiate the Converter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration:{}{}", System.lineSeparator(), converterConfig); plugin.configure(converterConfig); return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: returnNullWithApiVersionMismatch() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().setNodeApiVersions(NodeApiVersions.create()); env.kafkaClient().prepareResponse(createTopicResponseWithUnsupportedVersion(newTopic)); TopicAdmin admin = new TopicAdmin(null, env.adminClient()); boolean created = admin.createTopic(newTopic); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred: org. junit. Assert. assertFalse ( created )
************************************
************************************
[+] input: returnNullWithClusterAuthorizationFailure() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(createTopicResponseWithClusterAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(null, env.adminClient()); boolean created = admin.createTopic(newTopic); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred: org. junit. Assert. assertFalse ( created )
************************************
************************************
[+] input: shouldNotCreateTopicWhenItAlreadyExists() { NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (MockAdminClient mockAdminClient = new MockAdminClient(cluster.nodes(), cluster.nodeById(0))) { TopicPartitionInfo topicPartitionInfo = new TopicPartitionInfo(0, cluster.nodeById(0), cluster.nodes(), Collections.<Node>emptyList()); mockAdminClient.addTopic(false, "myTopic", Collections.singletonList(topicPartitionInfo), null); TopicAdmin admin = new TopicAdmin(null, mockAdminClient); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(admin.createTopic(newTopic))
[-] pred: org. junit. Assert. assertFalse ( admin. createTopic ( newTopic ) )
************************************
************************************
[+] input: shouldCreateTopicWhenItDoesNotExist() { NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (MockAdminClient mockAdminClient = new MockAdminClient(cluster.nodes(), cluster.nodeById(0))) { TopicAdmin admin = new TopicAdmin(null, mockAdminClient); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertTrue(admin.createTopic(newTopic))
[-] pred: org. junit. Assert. assertTrue ( admin. createTopic ( newTopic ) )
************************************
************************************
[+] input: shouldReturnFalseWhenSuppliedNullTopicDescription() { Cluster cluster = createCluster(1); try (MockAdminClient mockAdminClient = new MockAdminClient(cluster.nodes(), cluster.nodeById(0))) { TopicAdmin admin = new TopicAdmin(null, mockAdminClient); boolean created = admin.createTopic(null); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred: org. junit. Assert. assertFalse ( created )
************************************
************************************
[+] input: updateSchemaOfNonStruct() { Object value = new Integer(1); Object updatedValue = SetSchemaMetadata.updateSchemaIn(value, Schema.INT32_SCHEMA); "<AssertPlaceHolder>"; }
updateSchemaIn(Object keyOrValue, Schema updatedSchema) { if (keyOrValue instanceof Struct) { Struct origStruct = (Struct) keyOrValue; Struct newStruct = new Struct(updatedSchema); for (Field field : updatedSchema.fields()) { // assume both schemas have exact same fields with same names and schemas ... newStruct.put(field, origStruct.get(field)); } return newStruct; } return keyOrValue; }
[*] target: assertSame(value, updatedValue)
[-] pred: org. junit. Assert. assertSame ( value, updatedValue )
************************************
************************************
[+] input: updateSchemaOfNull() { Object updatedValue = SetSchemaMetadata.updateSchemaIn(null, Schema.INT32_SCHEMA); "<AssertPlaceHolder>"; }
updateSchemaIn(Object keyOrValue, Schema updatedSchema) { if (keyOrValue instanceof Struct) { Struct origStruct = (Struct) keyOrValue; Struct newStruct = new Struct(updatedSchema); for (Field field : updatedSchema.fields()) { // assume both schemas have exact same fields with same names and schemas ... newStruct.put(field, origStruct.get(field)); } return newStruct; } return keyOrValue; }
[*] target: assertEquals(null, updatedValue)
[-] pred: org. junit. Assert. assertEquals ( null, updatedValue )
************************************
************************************
[+] input: testTimeWindowSerdeFrom() { final Windowed<Integer> timeWindowed = new Windowed<>(10, new TimeWindow(0, Long.MAX_VALUE)); final Serde<Windowed<Integer>> timeWindowedSerde = WindowedSerdes.timeWindowedSerdeFrom(Integer.class); final byte[] bytes = timeWindowedSerde.serializer().serialize(topic, timeWindowed); final Windowed<Integer> windowed = timeWindowedSerde.deserializer().deserialize(topic, bytes); Assert."<AssertPlaceHolder>"; }
timeWindowedSerdeFrom(final Class<T> type) { return new TimeWindowedSerde<>(Serdes.serdeFrom(type)); }
[*] target: assertEquals(timeWindowed, windowed)
[-] pred: org. junit. Assert. assertEquals ( timeWindowed, windowed )
************************************
************************************
[+] input: testSessionWindowedSerdeFrom() { final Windowed<Integer> sessionWindowed = new Windowed<>(10, new SessionWindow(0, 1)); final Serde<Windowed<Integer>> sessionWindowedSerde = WindowedSerdes.sessionWindowedSerdeFrom(Integer.class); final byte[] bytes = sessionWindowedSerde.serializer().serialize(topic, sessionWindowed); final Windowed<Integer> windowed = sessionWindowedSerde.deserializer().deserialize(topic, bytes); Assert."<AssertPlaceHolder>"; }
sessionWindowedSerdeFrom(final Class<T> type) { return new SessionWindowedSerde<>(Serdes.serdeFrom(type)); }
[*] target: assertEquals(sessionWindowed, windowed)
[-] pred: org. junit. Assert. assertEquals ( sessionWindowed, windowed )
************************************
************************************
[+] input: testCopartitioning() { final Random rand = new Random(); final DefaultPartitioner defaultPartitioner = new DefaultPartitioner(); final WindowedSerializer<Integer> timeWindowedSerializer = new TimeWindowedSerializer<>(intSerializer); final WindowedStreamPartitioner<Integer, String> streamPartitioner = new WindowedStreamPartitioner<>(timeWindowedSerializer);  for (int k = 0; k < 10; k++) { final Integer key = rand.nextInt(); final byte[] keyBytes = intSerializer.serialize(topicName, key);  final String value = key.toString(); final byte[] valueBytes = stringSerializer.serialize(topicName, value);  final Integer expected = defaultPartitioner.partition("topic", key, keyBytes, value, valueBytes, cluster);  for (int w = 1; w < 10; w++) { final TimeWindow window = new TimeWindow(10 * w, 20 * w);  final Windowed<Integer> windowedKey = new Windowed<>(key, window); final Integer actual = streamPartitioner.partition(topicName, windowedKey, value, infos.size());  "<AssertPlaceHolder>"; } }  defaultPartitioner.close(); }
partition(final String topic, final Windowed<K> windowedKey, final V value, final int numPartitions) { final byte[] keyBytes = serializer.serializeBaseKey(topic, windowedKey);  // hash the keyBytes to choose a partition return toPositive(Utils.murmur2(keyBytes)) % numPartitions; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { final Map<TopicPartition, Long> expected = writeCheckpoint();  stateManager.initialize(); final Map<TopicPartition, Long> offsets = stateManager.checkpointed(); "<AssertPlaceHolder>"; }
checkpointed() { return Collections.unmodifiableMap(checkpointableOffsets); }
[*] target: assertEquals(expected, offsets)
[-] pred: org. junit. Assert. assertEquals ( expected, offsets )
************************************
************************************
[+] input: IOException { final File storeDirectory1 = new File(stateDirectory.globalStateDir().getAbsolutePath() + File.separator + "rocksdb" + File.separator + storeName1); final File storeDirectory2 = new File(stateDirectory.globalStateDir().getAbsolutePath() + File.separator + "rocksdb" + File.separator + storeName2); final File storeDirectory3 = new File(stateDirectory.globalStateDir().getAbsolutePath() + File.separator + storeName3); final File storeDirectory4 = new File(stateDirectory.globalStateDir().getAbsolutePath() + File.separator + storeName4); final File testFile1 = new File(storeDirectory1.getAbsolutePath() + File.separator + "testFile"); final File testFile2 = new File(storeDirectory2.getAbsolutePath() + File.separator + "testFile"); final File testFile3 = new File(storeDirectory3.getAbsolutePath() + File.separator + "testFile"); final File testFile4 = new File(storeDirectory4.getAbsolutePath() + File.separator + "testFile");  consumer.updatePartitions(t1.topic(), Collections.singletonList(new PartitionInfo(t1.topic(), t1.partition(), null, null, null))); consumer.updatePartitions(t2.topic(), Collections.singletonList(new PartitionInfo(t2.topic(), t2.partition(), null, null, null))); consumer.updatePartitions(t3.topic(), Collections.singletonList(new PartitionInfo(t3.topic(), t3.partition(), null, null, null))); consumer.updatePartitions(t4.topic(), Collections.singletonList(new PartitionInfo(t4.topic(), t4.partition(), null, null, null))); consumer.updateBeginningOffsets(new HashMap<TopicPartition, Long>() { { put(t1, 0L); put(t2, 0L); put(t3, 0L); put(t4, 0L); } }); consumer.updateEndOffsets(new HashMap<TopicPartition, Long>() { { put(t1, 0L); put(t2, 0L); put(t3, 0L); put(t4, 0L); } });  stateManager.initialize(); stateManager.register(store1, stateRestoreCallback); stateManager.register(store2, stateRestoreCallback); stateManager.register(store3, stateRestoreCallback); stateManager.register(store4, stateRestoreCallback);  testFile1.createNewFile(); "<AssertPlaceHolder>"; testFile2.createNewFile(); assertTrue(testFile2.exists()); testFile3.createNewFile(); assertTrue(testFile3.exists()); testFile4.createNewFile(); assertTrue(testFile4.exists());  // only delete and recreate store 1 and 3 -- 2 and 4 must be untouched stateManager.reinitializeStateStoresForPartitions(asList(t1, t3), processorContext);  assertFalse(testFile1.exists()); assertTrue(testFile2.exists()); assertFalse(testFile3.exists()); assertTrue(testFile4.exists()); }
register(final StateStore store, final StateRestoreCallback stateRestoreCallback) {  if (globalStores.containsKey(store.name())) { throw new IllegalArgumentException(String.format("Global Store %s has already been registered", store.name())); }  if (!globalStoreNames.contains(store.name())) { throw new IllegalArgumentException(String.format("Trying to register store %s that is not a known global store", store.name())); }  if (stateRestoreCallback == null) { throw new IllegalArgumentException(String.format("The stateRestoreCallback provided for store %s was null", store.name())); }  log.info("Restoring state for global store {}", store.name()); final List<TopicPartition> topicPartitions = topicPartitionsForStore(store); Map<TopicPartition, Long> highWatermarks = null;  int attempts = 0; while (highWatermarks == null) { try { highWatermarks = globalConsumer.endOffsets(topicPartitions); } catch (final TimeoutException retryableException) { if (++attempts > retries) { log.error("Failed to get end offsets for topic partitions of global store {} after {} retry attempts. " + "You can increase the number of retries via configuration parameter `retries`.", store.name(), retries, retryableException); throw new StreamsException(String.format("Failed to get end offsets for topic partitions of global store %s after %d retry attempts. " + "You can increase the number of retries via configuration parameter `retries`.", store.name(), retries), retryableException); } log.debug("Failed to get end offsets for partitions {}, backing off for {} ms to retry (attempt {} of {})", topicPartitions, retryBackoffMs, attempts, retries, retryableException); Utils.sleep(retryBackoffMs); } } try { restoreState( stateRestoreCallback, topicPartitions, highWatermarks, store.name(), converterForStore(store) ); globalStores.put(store.name(), store); } finally { globalConsumer.unsubscribe(); }  }
[*] target: assertTrue(testFile1.exists())
[-] pred: org. junit. Assert. assertTrue ( testFile1. exists ( ) )
************************************
************************************
[+] input: shouldLogWhenTopicNotFoundAndNotThrowException() { LogCaptureAppender.setClassLoggerToDebug(InternalTopicManager.class); final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(); mockAdminClient.addTopic( false, topic, Collections.singletonList(new TopicPartitionInfo(0, broker1, cluster, Collections.emptyList())), null);  final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topic, Collections.emptyMap()); internalTopicConfig.setNumberOfPartitions(1);  final InternalTopicConfig internalTopicConfigII = new RepartitionTopicConfig("internal-topic", Collections.emptyMap()); internalTopicConfigII.setNumberOfPartitions(1);  final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>(); topicConfigMap.put(topic, internalTopicConfig); topicConfigMap.put("internal-topic", internalTopicConfigII);   internalTopicManager.makeReady(topicConfigMap); boolean foundExpectedMessage = false; for (final String message : appender.getMessages()) { foundExpectedMessage |= message.contains("Topic internal-topic is unknown or not found, hence not existed yet."); } "<AssertPlaceHolder>";  }
makeReady(final Map<String, InternalTopicConfig> topics) { // we will do the validation / topic-creation in a loop, until we have confirmed all topics // have existed with the expected number of partitions, or some create topic returns fatal errors.  int remainingRetries = retries; Set<String> topicsNotReady = new HashSet<>(topics.keySet());  while (!topicsNotReady.isEmpty() && remainingRetries >= 0) { topicsNotReady = validateTopics(topicsNotReady, topics);  if (topicsNotReady.size() > 0) { final Set<NewTopic> newTopics = new HashSet<>();  for (final String topicName : topicsNotReady) { final InternalTopicConfig internalTopicConfig = Utils.notNull(topics.get(topicName)); final Map<String, String> topicConfig = internalTopicConfig.getProperties(defaultTopicConfigs, windowChangeLogAdditionalRetention);  log.debug("Going to create topic {} with {} partitions and config {}.", internalTopicConfig.name(), internalTopicConfig.numberOfPartitions(), topicConfig);  newTopics.add( new NewTopic( internalTopicConfig.name(), internalTopicConfig.numberOfPartitions(), replicationFactor) .configs(topicConfig)); }  final CreateTopicsResult createTopicsResult = adminClient.createTopics(newTopics);  for (final Map.Entry<String, KafkaFuture<Void>> createTopicResult : createTopicsResult.values().entrySet()) { final String topicName = createTopicResult.getKey(); try { createTopicResult.getValue().get(); topicsNotReady.remove(topicName); } catch (final InterruptedException fatalException) { // this should not happen; if it ever happens it indicate a bug Thread.currentThread().interrupt(); log.error(INTERRUPTED_ERROR_MESSAGE, fatalException); throw new IllegalStateException(INTERRUPTED_ERROR_MESSAGE, fatalException); } catch (final ExecutionException executionException) { final Throwable cause = executionException.getCause(); if (cause instanceof TopicExistsException) { // This topic didn't exist earlier or its leader not known before; just retain it for next round of validation. log.info("Could not create topic {}. Topic is probably marked for deletion (number of partitions is unknown).\n" + "Will retry to create this topic in {} ms (to let broker finish async delete operation first).\n" + "Error message was: {}", topicName, retryBackOffMs, cause.toString()); } else { log.error("Unexpected error during topic creation for {}.\n" + "Error message was: {}", topicName, cause.toString()); throw new StreamsException(String.format("Could not create topic %s.", topicName), cause); } } } }   if (!topicsNotReady.isEmpty()) { log.info("Topics {} can not be made ready with {} retries left", topicsNotReady, retries);  try { Thread.sleep(retryBackOffMs); } catch (final InterruptedException e) { // this is okay, we just wake up early Thread.currentThread().interrupt(); }  remainingRetries--; } }  if (!topicsNotReady.isEmpty()) { final String timeoutAndRetryError = String.format("Could not create topics after %d retries. " + "This can happen if the Kafka cluster is temporary not available. " + "You can increase admin client config `retries` to be resilient against this error.", retries); log.error(timeoutAndRetryError); throw new StreamsException(timeoutAndRetryError); } }
[*] target: assertTrue(foundExpectedMessage)
[-] pred: org. junit. Assert. assertTrue ( foundExpectedMessage )
************************************
************************************
[+] input: shouldLogAWarningIfCheckpointThrowsAnIOException() { final LogCaptureAppender appender = LogCaptureAppender.createAndRegister();  final ProcessorStateManager stateMgr; try { stateMgr = new ProcessorStateManager( taskId, noPartitions, false, stateDirectory, Collections.singletonMap(persistentStore.name(), persistentStoreTopicName), changelogReader, false, logContext); } catch (final IOException e) { e.printStackTrace(); throw new AssertionError(e); } stateMgr.register(persistentStore, persistentStore.stateRestoreCallback);  stateDirectory.clean(); stateMgr.checkpoint(Collections.singletonMap(persistentStorePartition, 10L)); LogCaptureAppender.unregister(appender);  boolean foundExpectedLogMessage = false; for (final LogCaptureAppender.Event event : appender.getEvents()) { if ("WARN".equals(event.getLevel()) && event.getMessage().startsWith("process-state-manager-test Failed to write offset checkpoint file to [") && event.getMessage().endsWith(".checkpoint]") && event.getThrowableInfo().get().startsWith("java.io.FileNotFoundException: ")) {  foundExpectedLogMessage = true; break; } } "<AssertPlaceHolder>"; }
register(final StateStore store, final StateRestoreCallback stateRestoreCallback) { final String storeName = store.name(); log.debug("Registering state store {} to its state manager", storeName);  if (CHECKPOINT_FILE_NAME.equals(storeName)) { throw new IllegalArgumentException(String.format("%sIllegal store name: %s", logPrefix, CHECKPOINT_FILE_NAME)); }  if (stores.containsKey(storeName)) { throw new IllegalArgumentException(String.format("%sStore %s has already been registered.", logPrefix, storeName)); }  // check that the underlying change log topic exist or not final String topic = storeToChangelogTopic.get(storeName); if (topic == null) { stores.put(storeName, store); return; }  final TopicPartition storePartition = new TopicPartition(topic, getPartition(topic));  final RecordConverter recordConverter = converterForStore(store);  if (isStandby) { log.trace("Preparing standby replica of persistent state store {} with changelog topic {}", storeName, topic);  restoreCallbacks.put(topic, stateRestoreCallback); recordConverters.put(topic, recordConverter); } else { log.trace("Restoring state store {} from changelog topic {} at checkpoint {}", storeName, topic, checkpointableOffsets.get(storePartition));  final StateRestorer restorer = new StateRestorer( storePartition, new CompositeRestoreListener(stateRestoreCallback), checkpointableOffsets.get(storePartition), offsetLimit(storePartition), store.persistent(), storeName, recordConverter );  changelogReader.register(restorer); } changelogPartitions.add(storePartition);  stores.put(storeName, store); }
[*] target: assertTrue(foundExpectedLogMessage)
[-] pred: org. junit. Assert. assertTrue ( foundExpectedLogMessage )
************************************
************************************
[+] input: IOException { final ProcessorStateManager stateManager = new ProcessorStateManager( taskId, Collections.singleton(changelogTopicPartition), false, stateDirectory, Collections.singletonMap(storeName, changelogTopic), changelogReader, false, logContext);  final AtomicBoolean closedStore = new AtomicBoolean(false);  final MockKeyValueStore stateStore1 = new MockKeyValueStore(storeName, true) { @Override public void close() { throw new RuntimeException("KABOOM!"); } }; final MockKeyValueStore stateStore2 = new MockKeyValueStore(storeName + "2", true) { @Override public void close() { closedStore.set(true); } }; stateManager.register(stateStore1, stateStore1.stateRestoreCallback); stateManager.register(stateStore2, stateStore2.stateRestoreCallback);  try { stateManager.close(true); } catch (final ProcessorStateException expected) { /* ignode */ } Assert."<AssertPlaceHolder>"; }
close(final boolean clean) throws ProcessorStateException { ProcessorStateException firstException = null; // attempting to close the stores, just in case they // are not closed by a ProcessorNode yet if (!stores.isEmpty()) { log.debug("Closing its state manager and all the registered state stores"); for (final StateStore store : stores.values()) { log.debug("Closing storage engine {}", store.name()); try { store.close(); } catch (final Exception e) { if (firstException == null) { firstException = new ProcessorStateException(String.format("%sFailed to close state store %s", logPrefix, store.name()), e); } log.error("Failed to close state store {}: ", store.name(), e); } } stores.clear(); }  if (!clean && eosEnabled && checkpoint != null) { // delete the checkpoint file if this is an unclean close try { checkpoint.delete(); checkpoint = null; } catch (final IOException e) { throw new ProcessorStateException(String.format("%sError while deleting the checkpoint file", logPrefix), e); } }  if (firstException != null) { throw firstException; } }
[*] target: assertTrue(closedStore.get())
[-] pred: org. junit. Assert. assertTrue ( closedStore. get ( ) )
************************************
************************************
[+] input: statelessTopologyShouldNotHavePersistentStore() { final TopologyWrapper topology = new TopologyWrapper(); final ProcessorTopology processorTopology = topology.getInternalBuilder("anyAppId").build(); assertFalse(processorTopology.hasPersistentLocalStore()); "<AssertPlaceHolder>"; }
hasPersistentGlobalStore() { for (final StateStore store : globalStateStores) { if (store.persistent()) { return true; } } return false; }
[*] target: assertFalse(processorTopology.hasPersistentGlobalStore())
[-] pred: org. junit. Assert. assertFalse ( processorTopology. hasPersistentGlobalStore() )
************************************
************************************
[+] input: inMemoryStoreShouldNotResultInPersistentLocalStore() { final ProcessorTopology processorTopology = createLocalStoreTopology(Stores.inMemoryKeyValueStore("my-store")); "<AssertPlaceHolder>"; }
hasPersistentLocalStore() { for (final StateStore store : stateStores) { if (store.persistent()) { return true; } } return false; }
[*] target: assertFalse(processorTopology.hasPersistentLocalStore())
[-] pred: org. junit. Assert. assertFalse ( processorTopology. hasPersistentLocalStore() )
************************************
************************************
[+] input: inMemoryStoreShouldNotResultInPersistentGlobalStore() { final ProcessorTopology processorTopology = createGlobalStoreTopology(Stores.inMemoryKeyValueStore("my-store")); "<AssertPlaceHolder>"; }
hasPersistentGlobalStore() { for (final StateStore store : globalStateStores) { if (store.persistent()) { return true; } } return false; }
[*] target: assertFalse(processorTopology.hasPersistentGlobalStore())
[-] pred: org. junit. Assert. assertFalse ( processorTopology. hasPersistentGlobalStore() )
************************************
************************************
[+] input: shouldCreateTaskStateDirectory() { final TaskId taskId = new TaskId(0, 0); final File taskDirectory = directory.directoryForTask(taskId); "<AssertPlaceHolder>"; assertTrue(taskDirectory.isDirectory()); }
directoryForTask(final TaskId taskId) { final File taskDir = new File(stateDir, taskId.toString()); if (createStateDirectory && !taskDir.exists() && !taskDir.mkdir()) { throw new ProcessorStateException( String.format("task directory [%s] doesn't exist and couldn't be created", taskDir.getPath())); } return taskDir; }
[*] target: assertTrue(taskDirectory.exists())
[-] pred: org. junit. Assert. assertTrue ( taskDirectory. exists ( ) )
************************************
************************************
[+] input: Exception { initializeStateDirectory(false); final TaskId taskId = new TaskId(0, 0); final File taskDirectory = directory.directoryForTask(taskId); "<AssertPlaceHolder>"; }
directoryForTask(final TaskId taskId) { final File taskDir = new File(stateDir, taskId.toString()); if (createStateDirectory && !taskDir.exists() && !taskDir.mkdir()) { throw new ProcessorStateException( String.format("task directory [%s] doesn't exist and couldn't be created", taskDir.getPath())); } return taskDir; }
[*] target: assertFalse(taskDirectory.exists())
[-] pred: org. junit. Assert. assertFalse ( taskDirectory. exists ( ) )
************************************
************************************
[+] input: Exception { initializeStateDirectory(false); final File globalStateDir = directory.globalStateDir(); "<AssertPlaceHolder>"; }
globalStateDir() { final File dir = new File(stateDir, "global"); if (createStateDirectory && !dir.exists() && !dir.mkdir()) { throw new ProcessorStateException( String.format("global state directory [%s] doesn't exist and couldn't be created", dir.getPath())); } return dir; }
[*] target: assertFalse(globalStateDir.exists())
[-] pred: org. junit. Assert. assertFalse ( globalStateDir. exists ( ) )
************************************
************************************
[+] input: shouldGetAllStreamInstances() { final StreamsMetadata one = new StreamsMetadata(hostOne, Utils.mkSet(globalTable, "table-one", "table-two", "merged-table"), Utils.mkSet(topic1P0, topic2P1, topic4P0)); final StreamsMetadata two = new StreamsMetadata(hostTwo, Utils.mkSet(globalTable, "table-two", "table-one", "merged-table"), Utils.mkSet(topic2P0, topic1P1)); final StreamsMetadata three = new StreamsMetadata(hostThree, Utils.mkSet(globalTable, "table-three"), Collections.singleton(topic3P0));  final Collection<StreamsMetadata> actual = metadataState.getAllMetadata(); "<AssertPlaceHolder>"; assertTrue("expected " + actual + " to contain " + one, actual.contains(one)); assertTrue("expected " + actual + " to contain " + two, actual.contains(two)); assertTrue("expected " + actual + " to contain " + three, actual.contains(three)); }
getAllMetadata() { return allMetadata; }
[*] target: assertEquals(3, actual.size())
[-] pred: org. junit. Assert. assertEquals ( 3, actual. size ( ) )
************************************
************************************
[+] input: shouldNotCheckpointOffsetsOnCommitIfEosIsEnabled() { task = createStatefulTask(createConfig(true), true); task.initializeStateStores(); task.initializeTopology(); task.commit(); final File checkpointFile = new File( stateDirectory.directoryForTask(taskId00), ProcessorStateManager.CHECKPOINT_FILE_NAME );  "<AssertPlaceHolder>"; }
commit() { commit(true); }
[*] target: assertFalse(checkpointFile.exists())
[-] pred: org. junit. Assert. assertFalse ( checkpointFile. exists ( ) )
************************************
************************************
[+] input: shouldNotBeInitializedIfChangelogPartitionsIsNonEmpty() { final StreamTask task = createStatefulTask(createConfig(false), true);  "<AssertPlaceHolder>"; }
initializeStateStores() { log.trace("Initializing state stores"); registerStateStores();  return changelogPartitions().isEmpty(); }
[*] target: assertFalse(task.initializeStateStores())
[-] pred: org. junit. Assert. assertFalse ( task. initializeStateStores ( ) )
************************************
************************************
[+] input: shouldHaveReachedCapacityWhenAssignedTasksGreaterThanOrEqualToCapacity() { client.assign(new TaskId(0, 1), true); "<AssertPlaceHolder>"; }
reachedCapacity() { return assignedTasks.size() >= capacity; }
[*] target: assertTrue(client.reachedCapacity())
[-] pred: org. junit. Assert. assertTrue ( client. reachedCapacity() )
************************************
************************************
[+] input: shouldHaveAssignedTaskIfActiveTaskAssigned() { final TaskId tid = new TaskId(0, 2);  client.assign(tid, true); "<AssertPlaceHolder>"; }
hasAssignedTask(final TaskId taskId) { return assignedTasks.contains(taskId); }
[*] target: assertTrue(client.hasAssignedTask(tid))
[-] pred: org. junit. Assert. assertTrue ( client. hasAssignedTask ( tid ) )
************************************
************************************
[+] input: shouldHaveAssignedTaskIfStandbyTaskAssigned() { final TaskId tid = new TaskId(0, 2);  client.assign(tid, false); "<AssertPlaceHolder>"; }
hasAssignedTask(final TaskId taskId) { return assignedTasks.contains(taskId); }
[*] target: assertTrue(client.hasAssignedTask(tid))
[-] pred: org. junit. Assert. assertTrue ( client. hasAssignedTask ( tid ) )
************************************
************************************
[+] input: shouldIterateAllStoredItems() { final int items = addItemsToCache(); final KeyValueIterator<Bytes, byte[]> all = store.all(); final List<Bytes> results = new ArrayList<>(); while (all.hasNext()) { results.add(all.next().key); } "<AssertPlaceHolder>"; }
all() { validateStoreOpen(); final KeyValueIterator<Bytes, byte[]> storeIterator = new DelegatingPeekingKeyValueIterator<>(this.name(), wrapped().all()); final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator = cache.all(cacheName); return new MergedSortedCacheKeyValueBytesStoreIterator(cacheIterator, storeIterator); }
[*] target: assertEquals(items, results.size())
[-] pred: org. junit. Assert. assertEquals ( items, results. size ( ) )
************************************
************************************
[+] input: shouldIterateOverRange() { final int items = addItemsToCache(); final KeyValueIterator<Bytes, byte[]> range = store.range(bytesKey(String.valueOf(0)), bytesKey(String.valueOf(items))); final List<Bytes> results = new ArrayList<>(); while (range.hasNext()) { results.add(range.next().key); } "<AssertPlaceHolder>"; }
range(final Bytes from, final Bytes to) { validateStoreOpen(); final KeyValueIterator<Bytes, byte[]> storeIterator = wrapped().range(from, to); final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator = cache.range(cacheName, from, to); return new MergedSortedCacheKeyValueBytesStoreIterator(cacheIterator, storeIterator); }
[*] target: assertEquals(items, results.size())
[-] pred: org. junit. Assert. assertEquals ( items, results. size ( ) )
************************************
************************************
[+] input: shouldReturnEmptyItemListIfStoreDoesntExist() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(Collections.<String, StateStore>emptyMap()); final List<ReadOnlyKeyValueStore<Object, Object>> stores = provider.stores("global", QueryableStoreTypes.keyValueStore()); "<AssertPlaceHolder>"; }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { final StateStore store = globalStateStores.get(storeName); if (store == null || !queryableStoreType.accepts(store)) { return Collections.emptyList(); } if (!store.isOpen()) { throw new InvalidStateStoreException("the state store, " + storeName + ", is not open."); } return (List<T>) Collections.singletonList(store); }
[*] target: assertTrue(stores.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( stores. isEmpty ( ) )
************************************
************************************
[+] input: shouldReturnNullIfKeyIsNull() { "<AssertPlaceHolder>"; }
get(final Bytes key) { if (key == null) { return null; }  final LRUNode node = getInternal(key); if (node == null) { return null; } updateLRU(node); return node.entry; }
[*] target: assertNull(cache.get(null))
[-] pred: org. junit. Assert. assertNull ( cache. get ( null ) )
************************************
************************************
[+] input: shouldCreateWriteBatches() { final String key = "a"; final Collection<KeyValue<byte[], byte[]>> records = new ArrayList<>(); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[0])).get(), serializeValue(50L))); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[3])).get(), serializeValue(100L))); final Map<KeyValueSegment, WriteBatch> writeBatchMap = bytesStore.getWriteBatches(records); "<AssertPlaceHolder>"; for (final WriteBatch batch : writeBatchMap.values()) { assertEquals(1, batch.count()); } }
getWriteBatches(final Collection<KeyValue<byte[], byte[]>> records) { // advance stream time to the max timestamp in the batch for (final KeyValue<byte[], byte[]> record : records) { final long timestamp = keySchema.segmentTimestamp(Bytes.wrap(record.key)); observedStreamTime = Math.max(observedStreamTime, timestamp); }  final Map<KeyValueSegment, WriteBatch> writeBatchMap = new HashMap<>(); for (final KeyValue<byte[], byte[]> record : records) { final long timestamp = keySchema.segmentTimestamp(Bytes.wrap(record.key)); final long segmentId = segments.segmentId(timestamp); final KeyValueSegment segment = segments.getOrCreateSegmentIfLive(segmentId, context, observedStreamTime); if (segment != null) { // This handles the case that state store is moved to a new client and does not // have the local RocksDB instance for the segment. In this case, toggleDBForBulkLoading // will only close the database and open it again with bulk loading enabled. if (!bulkLoadSegments.contains(segment)) { segment.toggleDbForBulkLoading(true); // If the store does not exist yet, the getOrCreateSegmentIfLive will call openDB that // makes the open flag for the newly created store. // if the store does exist already, then toggleDbForBulkLoading will make sure that // the store is already open here. bulkLoadSegments = new HashSet<>(segments.allSegments()); } try { final WriteBatch batch = writeBatchMap.computeIfAbsent(segment, s -> new WriteBatch()); if (record.value == null) { batch.delete(record.key); } else { batch.put(record.key, record.value); } } catch (final RocksDBException e) { throw new ProcessorStateException("Error restoring batch to store " + this.name, e); } } } return writeBatchMap; }
[*] target: assertEquals(2, writeBatchMap.size())
[-] pred: org. junit. Assert. assertEquals ( 2, writeBatchMap. size ( ) )
************************************
************************************
[+] input: shouldRestoreToByteStore() { // 0 segments initially. assertEquals(0, bytesStore.getSegments().size()); final String key = "a"; final Collection<KeyValue<byte[], byte[]>> records = new ArrayList<>(); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[0])).get(), serializeValue(50L))); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[3])).get(), serializeValue(100L))); bytesStore.restoreAllInternal(records);  // 2 segments are created during restoration. assertEquals(2, bytesStore.getSegments().size());  // Bulk loading is enabled during recovery. for (final KeyValueSegment segment : bytesStore.getSegments()) { Assert.assertThat(segment.getOptions().level0FileNumCompactionTrigger(), equalTo(1 << 30)); }  final List<KeyValue<Windowed<String>, Long>> expected = new ArrayList<>(); expected.add(new KeyValue<>(new Windowed<>(key, windows[0]), 50L)); expected.add(new KeyValue<>(new Windowed<>(key, windows[3]), 100L));  final List<KeyValue<Windowed<String>, Long>> results = toList(bytesStore.all()); "<AssertPlaceHolder>"; }
all() { final List<KeyValueSegment> searchSpace = segments.allSegments();  return new SegmentIterator<>(searchSpace.iterator(), keySchema.hasNextCondition(null, null, 0, Long.MAX_VALUE), null, null); }
[*] target: assertEquals(expected, results)
[-] pred: org. junit. Assert. assertEquals ( expected, results )
************************************
************************************
[+] input: shouldCallRocksDbConfigSetter() { MockRocksDbConfigSetter.called = false;  rocksDBStore.openDB(context);  "<AssertPlaceHolder>"; }
openDB(final ProcessorContext context) { // initialize the default rocksdb options  final DBOptions dbOptions = new DBOptions(); final ColumnFamilyOptions columnFamilyOptions = new ColumnFamilyOptions(); userSpecifiedOptions = new RocksDBGenericOptionsToDbOptionsColumnFamilyOptionsAdapter(dbOptions, columnFamilyOptions);  final BlockBasedTableConfig tableConfig = new BlockBasedTableConfig(); tableConfig.setBlockCacheSize(BLOCK_CACHE_SIZE); tableConfig.setBlockSize(BLOCK_SIZE); tableConfig.setFilter(new BloomFilter());  userSpecifiedOptions.optimizeFiltersForHits(); userSpecifiedOptions.setTableFormatConfig(tableConfig); userSpecifiedOptions.setWriteBufferSize(WRITE_BUFFER_SIZE); userSpecifiedOptions.setCompressionType(COMPRESSION_TYPE); userSpecifiedOptions.setCompactionStyle(COMPACTION_STYLE); userSpecifiedOptions.setMaxWriteBufferNumber(MAX_WRITE_BUFFERS); userSpecifiedOptions.setCreateIfMissing(true); userSpecifiedOptions.setErrorIfExists(false); userSpecifiedOptions.setInfoLogLevel(InfoLogLevel.ERROR_LEVEL); // this is the recommended way to increase parallelism in RocksDb // note that the current implementation of setIncreaseParallelism affects the number // of compaction threads but not flush threads (the latter remains one). Also // the parallelism value needs to be at least two because of the code in // https://github.com/facebook/rocksdb/blob/62ad0a9b19f0be4cefa70b6b32876e764b7f3c11/util/options.cc#L580 // subtracts one from the value passed to determine the number of compaction threads // (this could be a bug in the RocksDB code and their devs have been contacted). userSpecifiedOptions.setIncreaseParallelism(Math.max(Runtime.getRuntime().availableProcessors(), 2));  wOptions = new WriteOptions(); wOptions.setDisableWAL(true);  fOptions = new FlushOptions(); fOptions.setWaitForFlush(true);  final Map<String, Object> configs = context.appConfigs(); final Class<RocksDBConfigSetter> configSetterClass = (Class<RocksDBConfigSetter>) configs.get(StreamsConfig.ROCKSDB_CONFIG_SETTER_CLASS_CONFIG);  if (configSetterClass != null) { final RocksDBConfigSetter configSetter = Utils.newInstance(configSetterClass); configSetter.setConfig(name, userSpecifiedOptions, configs); }  if (prepareForBulkload) { userSpecifiedOptions.prepareForBulkLoad(); }  dbDir = new File(new File(context.stateDir(), parentDir), name);  try { Files.createDirectories(dbDir.getParentFile().toPath()); Files.createDirectories(dbDir.getAbsoluteFile().toPath()); } catch (final IOException fatal) { throw new ProcessorStateException(fatal); }  openRocksDB(dbOptions, columnFamilyOptions); open = true; }
[*] target: assertTrue(MockRocksDbConfigSetter.called)
[-] pred: org. junit. Assert. assertTrue ( MockRocksDbConfigSetter.called )
************************************
************************************
[+] input: shouldFindKeyValueStores() { mockThread(true); final List<ReadOnlyKeyValueStore<String, String>> kvStores = provider.stores("kv-store", QueryableStoreTypes.keyValueStore()); "<AssertPlaceHolder>"; }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { if (streamThread.state() == StreamThread.State.DEAD) { return Collections.emptyList(); } if (!streamThread.isRunningAndNotRebalancing()) { throw new InvalidStateStoreException("Cannot get state store " + storeName + " because the stream thread is " + streamThread.state() + ", not RUNNING"); } final List<T> stores = new ArrayList<>(); for (final Task streamTask : streamThread.tasks().values()) { final StateStore store = streamTask.getStore(storeName); if (store != null && queryableStoreType.accepts(store)) { if (!store.isOpen()) { throw new InvalidStateStoreException("Cannot get state store " + storeName + " for task " + streamTask + " because the store is not open. The state store may have migrated to another instances."); } stores.add((T) store); } } return stores; }
[*] target: assertEquals(2, kvStores.size())
[-] pred: org. junit. Assert. assertEquals ( 2, kvStores. size ( ) )
************************************
************************************
[+] input: shouldReturnFalseIfNoNextKey() { final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics())); final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})); "<AssertPlaceHolder>"; }
hasNext() { if (nextEntry != null) { return true; }  while (keys.hasNext() && nextEntry == null) { internalNext(); }  return nextEntry != null; }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext() )
************************************
************************************
[+] input: shouldFlushDirtyEntriesForNamespace() { final ThreadCache cache = new ThreadCache(logContext, 100000, new MockStreamsMetrics(new Metrics())); final List<byte[]> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace1, new ThreadCache.DirtyEntryFlushListener() { @Override public void apply(final List<ThreadCache.DirtyEntry> dirty) { for (final ThreadCache.DirtyEntry dirtyEntry : dirty) { received.add(dirtyEntry.key().get()); } } }); final List<byte[]> expected = Arrays.asList(new byte[]{0}, new byte[]{1}, new byte[]{2}); for (final byte[] bytes : expected) { cache.put(namespace1, Bytes.wrap(bytes), dirtyEntry(bytes)); } cache.put(namespace2, Bytes.wrap(new byte[]{4}), dirtyEntry(new byte[]{4}));  cache.flush(namespace1); "<AssertPlaceHolder>"; }
flush(final String namespace) { numFlushes++;  final NamedCache cache = getCache(namespace); if (cache == null) { return; } cache.flush();  if (log.isTraceEnabled()) { log.trace("Cache stats on flush: #puts={}, #gets={}, #evicts={}, #flushes={}", puts(), gets(), evicts(), flushes()); } }
[*] target: assertEquals(expected, received)
[-] pred: org. junit. Assert. assertEquals ( expected, received )
************************************
************************************
[+] input: shouldNotForwardCleanEntryOnEviction() { final ThreadCache cache = new ThreadCache(logContext, 0, new MockStreamsMetrics(new Metrics())); final List<ThreadCache.DirtyEntry> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace, new ThreadCache.DirtyEntryFlushListener() { @Override public void apply(final List<ThreadCache.DirtyEntry> dirty) { received.addAll(dirty); } }); cache.put(namespace, Bytes.wrap(new byte[]{1}), cleanEntry(new byte[]{0})); "<AssertPlaceHolder>"; }
size() { long size = 0; for (final NamedCache cache : caches.values()) { size += cache.size(); if (isOverflowing(size)) { return Long.MAX_VALUE; } } return size; }
[*] target: assertEquals(0, received.size())
[-] pred: org. junit. Assert. assertEquals ( 0, received. size ( ) )
************************************
************************************
[+] input: shouldParseSingleKeyValuePairString() { final Map<String, String> expectedSinglePairMap = new HashMap<>(); expectedSinglePairMap.put("foo", "bar"); final String singleValueString = "foo=bar"; final Map<String, String> parsedMap = SystemTestUtil.parseConfigs(singleValueString); "<AssertPlaceHolder>"; }
parseConfigs(final String formattedConfigs) { Objects.requireNonNull(formattedConfigs, "Formatted config String can't be null");  if (formattedConfigs.indexOf('=') == -1) { throw new IllegalStateException(String.format("Provided string [ %s ] does not have expected key-value separator of '='", formattedConfigs)); }  final String[] parts = formattedConfigs.split(","); final Map<String, String> configs = new HashMap<>(); for (final String part : parts) { final String[] keyValue = part.split("="); if (keyValue.length > 2) { throw new IllegalStateException( String.format("Provided string [ %s ] does not have expected key-value pair separator of ','", formattedConfigs)); } configs.put(keyValue[KEY], keyValue[VALUE]); } return configs; }
[*] target: assertEquals(expectedSinglePairMap, parsedMap)
[-] pred: org. junit. Assert. assertEquals ( expectedSinglePairMap, parsedMap )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) { CoordinatorClient coordinatorClient = cluster.coordinatorClient();  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); coordinatorClient.createTask(new CreateTaskRequest("foo", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("foo").taskState(new TaskPending(fooSpec)).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("foo")); "<AssertPlaceHolder>";   time.sleep(2); new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskRunning(fooSpec, 2, new TextNode("active"))). workerState(new WorkerRunning("foo", fooSpec, 2, new TextNode("active"))). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); time.sleep(550); // coordinator heartbeat sees that the agent is back up, re-schedules the task but the agent expires it new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). workerState(new WorkerDone("foo", fooSpec, 552, 552, null, "worker expired")). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); // coordinator heartbeat sees that the agent is back up but does not re-schedule the task as it is DONE new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). // no worker states build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02")); } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); time.sleep(552);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); NoOpTaskSpec updatedSpec = new NoOpTaskSpec(552, 500); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskRunning(updatedSpec, 552, new TextNode("receiving")) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1000, 500); time.sleep(999);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskPending(fooSpec) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: testMaterializeTopicsWithNoPartitions() { Map<String, List<TopicPartition>> materializedTopics = consumeBenchSpec(Arrays.asList("topic[1-3]", "secondTopic")).materializeTopics(); Map<String, List<TopicPartition>> expected = new HashMap<>(); expected.put("topic1", new ArrayList<>()); expected.put("topic2", new ArrayList<>()); expected.put("topic3", new ArrayList<>()); expected.put("secondTopic", new ArrayList<>());  "<AssertPlaceHolder>"; }
materializeTopics() { Map<String, List<TopicPartition>> partitionsByTopics = new HashMap<>();  for (String rawTopicName : this.activeTopics) { Set<String> expandedNames = expandTopicName(rawTopicName); if (!expandedNames.iterator().next().matches(VALID_EXPANDED_TOPIC_NAME_PATTERN)) throw new IllegalArgumentException(String.format("Expanded topic name %s is invalid", rawTopicName));  for (String topicName : expandedNames) { TopicPartition partition = null; if (topicName.contains(":")) { String[] topicAndPartition = topicName.split(":"); topicName = topicAndPartition[0]; partition = new TopicPartition(topicName, Integer.parseInt(topicAndPartition[1])); } if (!partitionsByTopics.containsKey(topicName)) { partitionsByTopics.put(topicName, new ArrayList<>()); } if (partition != null) { partitionsByTopics.get(topicName).add(partition); } } }  return partitionsByTopics; }
[*] target: assertEquals(expected, materializedTopics)
[-] pred: org. junit. Assert. assertEquals ( expected, materializedTopics )
************************************
************************************
[+] input: testMaterializeTopicsWithSomePartitions() { Map<String, List<TopicPartition>> materializedTopics = consumeBenchSpec(Arrays.asList("topic[1-3]:[1-5]", "secondTopic", "thirdTopic:1")).materializeTopics(); Map<String, List<TopicPartition>> expected = new HashMap<>(); expected.put("topic1", IntStream.range(1, 6).asLongStream().mapToObj(i -> new TopicPartition("topic1", (int) i)).collect(Collectors.toList())); expected.put("topic2", IntStream.range(1, 6).asLongStream().mapToObj(i -> new TopicPartition("topic2", (int) i)).collect(Collectors.toList())); expected.put("topic3", IntStream.range(1, 6).asLongStream().mapToObj(i -> new TopicPartition("topic3", (int) i)).collect(Collectors.toList())); expected.put("secondTopic", new ArrayList<>()); expected.put("thirdTopic", Collections.singletonList(new TopicPartition("thirdTopic", 1)));  "<AssertPlaceHolder>"; }
materializeTopics() { Map<String, List<TopicPartition>> partitionsByTopics = new HashMap<>();  for (String rawTopicName : this.activeTopics) { Set<String> expandedNames = expandTopicName(rawTopicName); if (!expandedNames.iterator().next().matches(VALID_EXPANDED_TOPIC_NAME_PATTERN)) throw new IllegalArgumentException(String.format("Expanded topic name %s is invalid", rawTopicName));  for (String topicName : expandedNames) { TopicPartition partition = null; if (topicName.contains(":")) { String[] topicAndPartition = topicName.split(":"); topicName = topicAndPartition[0]; partition = new TopicPartition(topicName, Integer.parseInt(topicAndPartition[1])); } if (!partitionsByTopics.containsKey(topicName)) { partitionsByTopics.put(topicName, new ArrayList<>()); } if (partition != null) { partitionsByTopics.get(topicName).add(partition); } } }  return partitionsByTopics; }
[*] target: assertEquals(expected, materializedTopics)
[-] pred: org. junit. Assert. assertEquals ( expected, materializedTopics )
************************************
************************************
[+] input: testGetDistributedId() { String distributedId = distributedIdManager.getDistributedId(); Assert."<AssertPlaceHolder>"; }
getDistributedId();
[*] target: assertNotNull(distributedId)
[-] pred: org. junit. Assert. assertNotNull ( distributedId )
************************************
************************************
[+] input: IOException { JKongAdmin admin = new JKongAdmin(adminUrl); boolean contains = admin .containsTarget("ba4ccac7-8d9c-4d05-b282-e0e113c29852", "192.168.0.120:8800"); Assert."<AssertPlaceHolder>"; System.out.println(contains); }
containsTarget(String upstreamNameOrId, String target) throws IOException { TargetPageResp pageResp = listTargets(upstreamNameOrId, null);  if (pageResp.getData().size() == 0) { return false; }  for (TargetResp resp : pageResp.getData()) { if (resp.getTarget().equals(target)) { return true; } }  return false; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
************************************
[+] input: testValueOfNull() { // test：when passValue is null ParamTracking paramTracking1 = ParamTracking.build( "param", "source", ScopeTypeEnum.REQUEST, null, String.class, "converter" );  FieldSerializeTracking fieldSerializeTracking1 = new FieldSerializeTracking(); String serializedValue1 = fieldSerializeTracking1.valueSerialize(paramTracking1); Assert."<AssertPlaceHolder>"; }
valueSerialize(FieldTracking fieldTracking) { Object passValue = fieldTracking.getPassValue(); if (passValue == null) { return null; }  String v; if (passValue instanceof String) { v = (String) passValue; } else { v = JSON.toJSONString(passValue, SerializerFeature.DisableCircularReferenceDetect); } if (GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT == -1 || (v.length() <= GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT)) { return v; } else { try { return v.substring(0, GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT); } catch (Exception e) { LOGGER.error("build ParamTracking error! tracking: {}", fieldTracking, e); } } return null; }
[*] target: assertNull(serializedValue1)
[-] pred: org. junit. Assert. assertNull ( serializedValue1 )
************************************
************************************
[+] input: testSendMessage_toUser_success() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToUserUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  List<String> weComIds = ImmutableList.of("user1", "user2"); String msg = "test msg"; boolean result = weComSender.sendMessageToUsers(weComIds, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToUsers(List<String> weComUserIds, String msg) { if (CollectionUtils.isEmpty(weComUserIds)) { log.warn("Prepare to send messages to weCom users, but `weComUserIds` is empty"); return false; }  String token = getToken(); String url = String.format(sendToUserUrl, token); WeComToUserMessage weComToUserMessage = WeComToUserMessage.from(StringUtils.join(weComUserIds, "|"), agentid, msg); log.debug("ready to send message: {} to wecom users: {}", msg, weComToUserMessage.getTouser()); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToUserMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom users: {} failed.", msg, weComToUserMessage.getTouser()); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testSendMessage_toUser_weComIdsIsEmpty() { List<String> weComIds = ImmutableList.of(); String msg = "test msg"; boolean result = weComSender.sendMessageToUsers(weComIds, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToUsers(List<String> weComUserIds, String msg) { if (CollectionUtils.isEmpty(weComUserIds)) { log.warn("Prepare to send messages to weCom users, but `weComUserIds` is empty"); return false; }  String token = getToken(); String url = String.format(sendToUserUrl, token); WeComToUserMessage weComToUserMessage = WeComToUserMessage.from(StringUtils.join(weComUserIds, "|"), agentid, msg); log.debug("ready to send message: {} to wecom users: {}", msg, weComToUserMessage.getTouser()); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToUserMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom users: {} failed.", msg, weComToUserMessage.getTouser()); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testSendMessage_toUser_failed() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToUserUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(1, "invalid token"); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  List<String> weComIds = ImmutableList.of("user1", "user2"); String msg = "test msg"; boolean result = weComSender.sendMessageToUsers(weComIds, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToUsers(List<String> weComUserIds, String msg) { if (CollectionUtils.isEmpty(weComUserIds)) { log.warn("Prepare to send messages to weCom users, but `weComUserIds` is empty"); return false; }  String token = getToken(); String url = String.format(sendToUserUrl, token); WeComToUserMessage weComToUserMessage = WeComToUserMessage.from(StringUtils.join(weComUserIds, "|"), agentid, msg); log.debug("ready to send message: {} to wecom users: {}", msg, weComToUserMessage.getTouser()); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToUserMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom users: {} failed.", msg, weComToUserMessage.getTouser()); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testSendMessage_toChat_success() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToChatUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  String chatid = "1"; String msg = "test msg"; boolean result = weComSender.sendMessageToChat(chatid, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToChat(String chatid, String msg) { if (StringUtils.isBlank(chatid)) { log.warn("Prepare to send messages to weCom chat, but `chatid` is empty"); return false; }  String token = getToken(); String url = String.format(sendToChatUrl, token); WeComToChatMessage weComToChatMessage = WeComToChatMessage.from(chatid, msg); log.debug("ready to send message: {} to wecom chat: {}", msg, chatid); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToChatMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom chat: {} failed.", msg, chatid); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testSendMessage_toChat_weComIdsIsEmpty() { String chatid = null; String msg = "test msg"; boolean result = weComSender.sendMessageToChat(chatid, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToChat(String chatid, String msg) { if (StringUtils.isBlank(chatid)) { log.warn("Prepare to send messages to weCom chat, but `chatid` is empty"); return false; }  String token = getToken(); String url = String.format(sendToChatUrl, token); WeComToChatMessage weComToChatMessage = WeComToChatMessage.from(chatid, msg); log.debug("ready to send message: {} to wecom chat: {}", msg, chatid); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToChatMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom chat: {} failed.", msg, chatid); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testSendMessage_toChat_failed() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToChatUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(1, "invalid token"); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  String chatid = "1"; String msg = "test msg"; boolean result = weComSender.sendMessageToChat(chatid, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToChat(String chatid, String msg) { if (StringUtils.isBlank(chatid)) { log.warn("Prepare to send messages to weCom chat, but `chatid` is empty"); return false; }  String token = getToken(); String url = String.format(sendToChatUrl, token); WeComToChatMessage weComToChatMessage = WeComToChatMessage.from(chatid, msg); log.debug("ready to send message: {} to wecom chat: {}", msg, chatid); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToChatMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom chat: {} failed.", msg, chatid); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testGetTaskRunDetail() { TaskRun taskRun = prepareData(); TaskRunVO existedRun = taskRunService.getTaskRunDetail(taskRun.getId()).get(); "<AssertPlaceHolder>"; assertNotNull(existedRun.getTask()); }
getTaskRunDetail(Long taskRunId) { Optional<TaskRun> taskRun = taskRunDao.fetchTaskRunById(taskRunId); return taskRun.map(this::convertToVO); }
[*] target: assertNotNull(existedRun)
[-] pred: org. junit. Assert. assertNotNull ( existedRun )
************************************
************************************
[+] input: rerunTaskRun_whenLatestAttemptIsFinished_shouldSubmitNewAttemptToExecutor() { // 1. Prepare TaskRun taskRunFailed = prepareTaskRunAndTaskAttempt(TaskRunStatus.FAILED); mockExecutorOnSubmit();  // 2. Process boolean rerunSuccessfully = taskRunService.rerunTaskRun(taskRunFailed.getId());  // 3. Validate "<AssertPlaceHolder>"; }
rerunTaskRun(Long taskRunId) { // 1. Preconditions check Preconditions.checkArgument(Objects.nonNull(taskRunId), "Argument `taskRunId` should not be null"); Optional<TaskRun> taskRunOptional = taskRunDao.fetchTaskRunById(taskRunId); logger.info("Trying to re-run taskrun instance with id = {}.", taskRunId); if (!taskRunOptional.isPresent()) { logger.warn("Cannot rerun taskrun instance with id = {}. Reason: task run does not exists.", taskRunId); return false; } TaskRun taskRun = taskRunOptional.get(); return scheduler.rerun(taskRun);   }
[*] target: assertTrue(rerunSuccessfully)
[-] pred: org. junit. Assert. assertTrue ( rerunSuccessfully )
************************************
************************************
[+] input: rerunTaskRun_whenTaskRunDoesNotExist_shouldProduceNoEffect() { // 1. Prepare mockExecutorOnSubmit();  // 2. Process boolean rerunSuccessfully = taskRunService.rerunTaskRun(1234567L);  // 3. Validate "<AssertPlaceHolder>"; }
rerunTaskRun(Long taskRunId) { // 1. Preconditions check Preconditions.checkArgument(Objects.nonNull(taskRunId), "Argument `taskRunId` should not be null"); Optional<TaskRun> taskRunOptional = taskRunDao.fetchTaskRunById(taskRunId); logger.info("Trying to re-run taskrun instance with id = {}.", taskRunId); if (!taskRunOptional.isPresent()) { logger.warn("Cannot rerun taskrun instance with id = {}. Reason: task run does not exists.", taskRunId); return false; } TaskRun taskRun = taskRunOptional.get(); return scheduler.rerun(taskRun);   }
[*] target: assertFalse(rerunSuccessfully)
[-] pred: org. junit. Assert. assertFalse ( rerunSuccessfully )
************************************
************************************
[+] input: getAppShortcutInfo_dontAllowMissing_validComponent() { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = mLauncherApps.getActivityList(null, mLoaderCursor.user) .get(0).getComponentName(); ShortcutInfo info = mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), false /* allowMissingTarget */, true); "<AssertPlaceHolder>"; assertTrue(Utilities.isLauncherAppTarget(info.intent)); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { if (user == null) { Log.d(TAG, "Null user found in getShortcutInfo"); return null; }  ComponentName componentName = intent.getComponent(); if (componentName == null) { Log.d(TAG, "Missing component found in getShortcutInfo"); return null; }  Intent newIntent = new Intent(Intent.ACTION_MAIN, null); newIntent.addCategory(Intent.CATEGORY_LAUNCHER); newIntent.setComponent(componentName); LauncherActivityInfo lai = LauncherAppsCompat.getInstance(mContext) .resolveActivity(newIntent, user); if ((lai == null) && !allowMissingTarget) { Log.d(TAG, "Missing activity found in getShortcutInfo: " + componentName); return null; }  final ShortcutInfo info = new ShortcutInfo(); info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION; info.user = user; info.intent = newIntent;  mIconCache.getTitleAndIcon(info, lai, useLowResIcon); if (mIconCache.isDefaultIcon(info.iconBitmap, user)) { loadIcon(info); }  if (lai != null) { AppInfo.updateRuntimeFlagsForActivityTarget(info, lai); }  // from the db if (TextUtils.isEmpty(info.title)) { info.title = getTitle(); }  // fall back to the class name of the activity if (info.title == null) { info.title = componentName.getClassName(); }  info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user); return info; }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: getAppShortcutInfo_allowMissing_invalidComponent() { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = new ComponentName(mContext.getPackageName(), "dummy-do"); ShortcutInfo info = mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), true  /* allowMissingTarget */, true); "<AssertPlaceHolder>"; assertTrue(Utilities.isLauncherAppTarget(info.intent)); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { if (user == null) { Log.d(TAG, "Null user found in getShortcutInfo"); return null; }  ComponentName componentName = intent.getComponent(); if (componentName == null) { Log.d(TAG, "Missing component found in getShortcutInfo"); return null; }  Intent newIntent = new Intent(Intent.ACTION_MAIN, null); newIntent.addCategory(Intent.CATEGORY_LAUNCHER); newIntent.setComponent(componentName); LauncherActivityInfo lai = LauncherAppsCompat.getInstance(mContext) .resolveActivity(newIntent, user); if ((lai == null) && !allowMissingTarget) { Log.d(TAG, "Missing activity found in getShortcutInfo: " + componentName); return null; }  final ShortcutInfo info = new ShortcutInfo(); info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION; info.user = user; info.intent = newIntent;  mIconCache.getTitleAndIcon(info, lai, useLowResIcon); if (mIconCache.isDefaultIcon(info.iconBitmap, user)) { loadIcon(info); }  if (lai != null) { AppInfo.updateRuntimeFlagsForActivityTarget(info, lai); }  // from the db if (TextUtils.isEmpty(info.title)) { info.title = getTitle(); }  // fall back to the class name of the activity if (info.title == null) { info.title = componentName.getClassName(); }  info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user); return info; }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: testMoveFromBottomRightToBottomLeft() { int[][] map = transpose(new int[][] { {-1, 0, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1}, {100, 1, -1, -1, -1, -1}, }); int i = FocusLogic.handleKeyEvent(KeyEvent.KEYCODE_DPAD_RIGHT, map, 100, 1, 2, false); "<AssertPlaceHolder>"; }
handleKeyEvent(int keyCode, int [][] map, int iconIdx, int pageIndex, int pageCount, boolean isRtl) {  int cntX = map == null ? -1 : map.length; int cntY = map == null ? -1 : map[0].length;  if (DEBUG) { Log.v(TAG, String.format( "handleKeyEvent START: cntX=%d, cntY=%d, iconIdx=%d, pageIdx=%d, pageCnt=%d", cntX, cntY, iconIdx, pageIndex, pageCount)); }  int newIndex = NOOP; switch (keyCode) { case KeyEvent.KEYCODE_DPAD_LEFT: newIndex = handleDpadHorizontal(iconIdx, cntX, cntY, map, -1 /*increment*/, isRtl); if (!isRtl && newIndex == NOOP && pageIndex > 0) { newIndex = PREVIOUS_PAGE_RIGHT_COLUMN; } else if (isRtl && newIndex == NOOP && pageIndex < pageCount - 1) { newIndex = NEXT_PAGE_RIGHT_COLUMN; } break; case KeyEvent.KEYCODE_DPAD_RIGHT: newIndex = handleDpadHorizontal(iconIdx, cntX, cntY, map, 1 /*increment*/, isRtl); if (!isRtl && newIndex == NOOP && pageIndex < pageCount - 1) { newIndex = NEXT_PAGE_LEFT_COLUMN; } else if (isRtl && newIndex == NOOP && pageIndex > 0) { newIndex = PREVIOUS_PAGE_LEFT_COLUMN; } break; case KeyEvent.KEYCODE_DPAD_DOWN: newIndex = handleDpadVertical(iconIdx, cntX, cntY, map, 1  /*increment*/); break; case KeyEvent.KEYCODE_DPAD_UP: newIndex = handleDpadVertical(iconIdx, cntX, cntY, map, -1  /*increment*/); break; case KeyEvent.KEYCODE_MOVE_HOME: newIndex = handleMoveHome(); break; case KeyEvent.KEYCODE_MOVE_END: newIndex = handleMoveEnd(); break; case KeyEvent.KEYCODE_PAGE_DOWN: newIndex = handlePageDown(pageIndex, pageCount); break; case KeyEvent.KEYCODE_PAGE_UP: newIndex = handlePageUp(pageIndex); break; default: break; }  if (DEBUG) { Log.v(TAG, String.format("handleKeyEvent FINISH: index [%d -> %s]", iconIdx, getStringIndex(newIndex))); } return newIndex; }
[*] target: assertEquals(1, i)
[-] pred: org. junit. Assert. assertEquals ( 1, i )
************************************
************************************
[+] input: shouldTestIfContainsElementsFromAnotherList() { testInstance.add(0); testInstance.add(1);  MyList newList = new DefaultMyList(); newList.add(1); newList.add(0);  "<AssertPlaceHolder>"; }
containsAll(MyList c) { Object[] array = c.toArray(); for (int i = 0; i < array.length; i++) { if (!contains(array[i])) { return false; }; } return true; }
[*] target: assertTrue(testInstance.containsAll(newList))
[-] pred: org. junit. Assert. assertTrue ( testInstance. containsAll( newList ) )
************************************
************************************
[+] input: getAccessVerifier() { DoubleJWT jwt = new DoubleJWT("secret", 1000, 2000); "<AssertPlaceHolder>"; }
getAccessVerifier() { return accessVerifier; }
[*] target: assertNotNull(jwt.getAccessVerifier())
[-] pred: org. junit. Assert. assertNotNull ( jwt. getAccessVerifier() )
************************************
************************************
[+] input: getRefreshVerifier() { DoubleJWT jwt = new DoubleJWT("secret", 1000, 2000); "<AssertPlaceHolder>"; }
getRefreshVerifier() { return refreshVerifier; }
[*] target: assertNotNull(jwt.getRefreshVerifier())
[-] pred: org. junit. Assert. assertNotNull ( jwt. getRefreshVerifier ( ) )
************************************
************************************
[+] input: getBuilder() { DoubleJWT jwt = new DoubleJWT("secret", 1000, 2000); "<AssertPlaceHolder>"; }
getBuilder() { return builder; }
[*] target: assertNotNull(jwt.getBuilder())
[-] pred: org. junit. Assert. assertNotNull ( jwt. getBuilder() )
************************************
************************************
[+] input: generateToken() { SingleJWT jwt = new SingleJWT("secret", 1000); String token = jwt.generateToken("test", 1, "test", 1000); "<AssertPlaceHolder>"; log.info(token); }
generateToken(String tokenType, long identity, String scope, long expire) { Date expireDate = DateUtil.getDurationDate(expire); return builder .withClaim("type", tokenType) .withClaim("identity", identity) .withClaim("scope", scope) .withExpiresAt(expireDate) .sign(algorithm); }
[*] target: assertNotNull(token)
[-] pred: org. junit. Assert. assertNotNull ( token )
************************************
************************************
[+] input: getVerifier() { Algorithm algorithm = Algorithm.HMAC256("secret"); SingleJWT jwt = new SingleJWT(algorithm, 1000); "<AssertPlaceHolder>"; }
getVerifier() { return verifier; }
[*] target: assertNotNull(jwt.getVerifier())
[-] pred: org. junit. Assert. assertNotNull ( jwt. getVerifier() )
************************************
************************************
[+] input: getBuilder() { Algorithm algorithm = Algorithm.HMAC256("secret"); SingleJWT jwt = new SingleJWT(algorithm, 1000); "<AssertPlaceHolder>"; }
getBuilder() { return builder; }
[*] target: assertNotNull(jwt.getBuilder())
[-] pred: org. junit. Assert. assertNotNull ( jwt. getBuilder() )
************************************
************************************
[+] input: SemanticException { SubstringDomain assume1 = domainB.assume(YSubstringOfX, null, null, null); SubstringDomain assume2 = domainB.assume(XEndsWithY, null, null, null); SubstringDomain assume3 = domainB.assume(XStartsWithY, null, null, null);  "<AssertPlaceHolder>"; assertEquals(assume1, assume3); assertTrue(assume1.getState(x).contains(y)); assertTrue(assume1.getState(x).contains(w)); assertTrue(assume1.getState(x).contains(z)); assertTrue(assume1.getState(y).contains(z)); }
assume( ValueExpression expression, ProgramPoint src, ProgramPoint dest, SemanticOracle oracle) throws SemanticException {  /* * Assume only binary expressions */ if (expression instanceof BinaryExpression) {  BinaryExpression binaryExpression = (BinaryExpression) expression; BinaryOperator binaryOperator = binaryExpression.getOperator();  SymbolicExpression left = binaryExpression.getLeft(); SymbolicExpression right = binaryExpression.getRight();  /* * The string type is unique and can be retrieved from the type * system. */ Type strType; if (src != null) // Correct: get the string type from the program // point strType = src.getProgram().getTypes().getStringType(); else // Used in tests where src is null, get the string type from // the expression strType = left.getStaticType();  if (binaryOperator instanceof StringContains || binaryOperator instanceof StringStartsWith || binaryOperator instanceof StringEndsWith) {  /* * Evaluate only if the left operand is an identidier */  if (!(left instanceof Identifier)) return this;  if (!(right instanceof ValueExpression)) throw new SemanticException("instanceof right");  Set<SymbolicExpression> extracted = extrPlus((ValueExpression) right, src, oracle, strType); SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.add(extracted, (Identifier) left); result = result.closure(); return result.clear();  } else if (binaryOperator instanceof StringEquals) {  // case both operands are identifiers if ((left instanceof Identifier) && (right instanceof Identifier)) { SubstringDomain result = mk(lattice, mkNewFunction(function, false)); result = result.add(left, (Identifier) right); result = result.add(right, (Identifier) left); result = result.closure(); return result.clear(); } // case where only one is an identifier else if ((left instanceof Identifier) || (right instanceof Identifier)) { if (right instanceof Identifier) { // make left the identifier SymbolicExpression temp = left; left = right; right = temp; }  if (!(right instanceof ValueExpression)) throw new SemanticException("instanceof right != ValueExpression.class");  Set<SymbolicExpression> add = extrPlus((ValueExpression) right, src, oracle, strType);  SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.add(add, (Identifier) left); result = result.closure(); return result.clear();  } } else if (binaryOperator instanceof LogicalOr || binaryOperator instanceof LogicalAnd) {  if (!(left instanceof ValueExpression) || !(right instanceof ValueExpression)) throw new SemanticException( "!(left instanceof ValueExpression) || !(right instanceof ValueExpression)");  ValueExpression rightValueExpression = (ValueExpression) right; ValueExpression leftValueExpression = (ValueExpression) left; SubstringDomain leftDomain = assume(leftValueExpression, src, dest, oracle); SubstringDomain rightDomain = assume(rightValueExpression, src, dest, oracle);  if (binaryOperator instanceof LogicalOr) { return leftDomain.lub(rightDomain).clear(); } else { return leftDomain.glb(rightDomain).clear(); } }  }  return this; }
[*] target: assertEquals(assume1, assume2)
[-] pred: org. junit. Assert. assertEquals ( assume1, assume2 )
************************************
************************************
[+] input: SemanticException { ValueExpression abcd = new Constant(StringType.INSTANCE, "abcd", SyntheticLocation.INSTANCE); ValueExpression ab = new Constant(StringType.INSTANCE, "ab", SyntheticLocation.INSTANCE); ValueExpression cd = new Constant(StringType.INSTANCE, "cd", SyntheticLocation.INSTANCE); ValueExpression ABConcatCD = new BinaryExpression(StringType.INSTANCE, ab, cd, StringConcat.INSTANCE, SyntheticLocation.INSTANCE);  SubstringDomain empty = new SubstringDomain(); SubstringDomain assigned1 = empty.assign(x, abcd, null, null); SubstringDomain assigned2 = empty.assign(x, ABConcatCD, null, null);  "<AssertPlaceHolder>"; }
assign( Identifier id, ValueExpression expression, ProgramPoint pp, SemanticOracle oracle) throws SemanticException {  /* * If the assigned expression is not dynamically typed as a string (or * untyped) return this. */ if (oracle != null && pp != null && oracle.getRuntimeTypesOf(expression, pp, oracle).stream() .allMatch(t -> !t.isStringType() && !t.isUntyped())) return this;  /* * The string type is unique and can be retrieved from the type system. */ Type strType; if (pp != null) // Correct: get the string type from the program point strType = pp.getProgram().getTypes().getStringType(); else // Used in tests where pp is null, get the string type from the // expression strType = expression.getStaticType();  Set<SymbolicExpression> expressions = extrPlus(expression, pp, oracle, strType); SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.remove(expressions, id); result = result.add(expressions, id); result = result.interasg(id, expression); result = result.closure(id); return result.clear(); }
[*] target: assertEquals(assigned1, assigned2)
[-] pred: org. junit. Assert. assertEquals ( assigned1, assigned2 )
************************************
************************************
[+] input: SemanticException { List<Brick> bricksList = new ArrayList<>(); List<Brick> bricksList1 = new ArrayList<>();  Set<String> treeSet = new TreeSet<>(); treeSet.add("mo"); treeSet.add("de");  Brick brick = new Brick(1, 4, treeSet);  Set<String> treeSet1 = new TreeSet<>(); treeSet1.add("mo"); treeSet1.add("de"); treeSet1.add("re");  Brick brick1 = new Brick(0, 5, treeSet1);  Set<String> treeSet2 = new TreeSet<>(); treeSet2.add("ge"); treeSet2.add("ze");  Brick brick2 = new Brick(1, 3, treeSet2);  Set<String> treeSet3 = new TreeSet<>(); treeSet3.add("ge"); treeSet3.add("ze"); treeSet3.add("le");  Brick brick3 = new Brick(1, 4, treeSet3);  bricksList.add(brick); bricksList.add(brick2);  bricksList1.add(brick1); bricksList1.add(brick3);  Bricks bricks = new Bricks(bricksList); Bricks bricks1 = new Bricks(bricksList1);  "<AssertPlaceHolder>"; }
lessOrEqualAux( Bricks other) throws SemanticException { List<Brick> thisPaddedList = this.bricks; List<Brick> otherPaddedList = other.bricks;  if (this.bricks.size() < other.bricks.size()) thisPaddedList = this.padList(other); else if (other.bricks.size() < this.bricks.size()) otherPaddedList = other.padList(this);  for (int i = 0; i < thisPaddedList.size(); ++i) { Brick first = thisPaddedList.get(i); Brick second = otherPaddedList.get(i); if (!first.lessOrEqual(second)) return false; }  return true; }
[*] target: assertTrue(bricks.lessOrEqualAux(bricks1))
[-] pred: org. junit. Assert. assertTrue ( bricks. lessOrEqualAux ( bricks1 ) )
************************************
************************************
[+] input: SemanticException { Set<String> hashSet = new HashSet<>(); hashSet.add("mo"); hashSet.add("de");  Brick brick = new Brick(1, 2, hashSet);  Set<String> hashSet1 = new HashSet<>(); hashSet1.add("mo"); hashSet1.add("de"); hashSet1.add("re");  Brick brick1 = new Brick(0, 3, hashSet1);  "<AssertPlaceHolder>"; }
lessOrEqualAux( Brick other) throws SemanticException { if (this.getMin().lt(other.getMin())) return false; if (this.getMax().gt(other.getMax())) return false;  if (other.strings == null) return true; if (strings == null) return false; if (this.strings.size() > other.strings.size()) return false; return other.strings.containsAll(this.strings); }
[*] target: assertTrue(brick.lessOrEqualAux(brick1))
[-] pred: org. junit. Assert. assertTrue ( brick. lessOrEqualAux ( brick1 ) )
************************************
************************************
[+] input: testFetchingExecutorForValidCommand() { final CommandExecutor commandExecutor = factory.getCommandExecutor(new Command("leave 1")); "<AssertPlaceHolder>"; assertTrue(commandExecutor instanceof LeaveCommandExecutor); }
getCommandExecutor(final Command command) { final CommandExecutor commandExecutor = commands.get(command.getCommandName()); if (commandExecutor == null) { throw new InvalidCommandException(); } return commandExecutor; }
[*] target: assertNotNull(commandExecutor)
[-] pred: org. junit. Assert. assertNotNull ( commandExecutor )
************************************
************************************
[+] input: testGetSlotsForAParticularCarColorWhenNoCarMatches() { final Map<Integer, Slot> allSlots = new HashMap<>(); final Slot slot1 = new Slot(1); slot1.assignCar(new Car("test-car-no1", "blue")); final Slot slot2 = new Slot(2); final Slot slot3 = new Slot(3); slot3.assignCar(new Car("test-car-no2", "red"));  allSlots.put(1, slot1); allSlots.put(2, slot2); allSlots.put(3, slot3);  when(parkingLot.getSlots()).thenReturn(allSlots); when(parkingLot.getCapacity()).thenReturn(10);  final List<Slot> slots = parkingLotService.getSlotsForColor("white"); "<AssertPlaceHolder>"; }
getSlotsForColor(final String color) { final List<Slot> occupiedSlots = getOccupiedSlots(); return occupiedSlots.stream() .filter(slot -> slot.getParkedCar().getColor().equals(color)) .collect(Collectors.toList()); }
[*] target: assertEquals(0, slots.size())
[-] pred: org. junit. Assert. assertEquals ( 0, slots. size ( ) )
************************************
************************************
[+] input: InterruptedException { Path file = Paths.get(getTestLog("utf8.log"));  byte[] data = Files.readAllBytes(file);  int nonLatinCharOffset = -1; for (int i = 0; i < data.length; i++) { if (data[i] < 0) { assert data[i + 1] < 0; nonLatinCharOffset = i; break; } }  assert nonLatinCharOffset >= 0;  Log log = getLogService().openLog(file, new SimpleLogFormat(StandardCharsets.UTF_8));  Pair<String, Integer> pair = log.loadContent(0, nonLatinCharOffset + 1).get();  int dataLen = pair.getSecond();  "<AssertPlaceHolder>"; assertEquals(new String(Arrays.copyOf(data, dataLen), StandardCharsets.UTF_8), pair.getFirst()); }
loadContent(long offset, int length) { CompletableFuture<Pair<String, Integer>> res = new CompletableFuture<>();  executor.submit(() -> { try { if (!accessManager.isFileVisible(file)) { res.completeExceptionally(new SecurityException(accessManager.errorMessage(file))); return; }  if (length > ParserConfig.MAX_LINE_LENGTH) throw new IllegalStateException();  try (RandomAccessFile input = new RandomAccessFile(file.toFile(), "r")) { input.seek(offset);  byte[] data = new byte[length]; input.readFully(data);  res.complete(Utils.decode(data, encoding)); } } catch (Throwable e) { res.completeExceptionally(e); } });  return res; }
[*] target: assertEquals(nonLatinCharOffset, dataLen)
[-] pred: org. junit. Assert. assertEquals ( nonLatinCharOffset, dataLen )
************************************
************************************
[+] input: testZeroByteSequenceToIntegerConversion() {  // given final List<Byte> packet = new ArrayList<>( asList( (byte) 0x00, (byte) 0x00, (byte) 0x10 ) );  // when final int result = converter.consume(packet);  // then "<AssertPlaceHolder>"; }
consume(@NonNull List<Byte> packet) { final int mostSigBits = packet.remove(0); final int leastSigBits = packet.remove(0);  return (mostSigBits & 0xff) * 0x100 + (leastSigBits & 0xff); }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 0, result )
************************************
************************************
[+] input: testRunningAverageWithNoHistoryCalculation() {  // given final ITimeProvider.TestTimeProvider timeProvider = new ITimeProvider.TestTimeProvider();  final RssiFilter filter = new RunningAverageRssiFilter.Builder() .addTimeProvider(timeProvider) .build();  // when final Byte average = filter.getFilteredValue();  // then "<AssertPlaceHolder>"; }
getFilteredValue() { if (readings.isEmpty()) { return null; }  int rssiSum = 0;  for (Reading reading : readings) { rssiSum += reading.rssi; }  return (byte) (rssiSum / readings.size()); }
[*] target: assertNull(average)
[-] pred: org. junit. Assert. assertNull ( average )
************************************
************************************
[+] input: InterruptedException { for (int i = 0; i < (Integer.MAX_VALUE - 50); i+=10) { byte[] bytes = ConverterUtil.numberToByte(i); long l = ConverterUtil.byteToNumber(bytes); Assert."<AssertPlaceHolder>"; }  }
byteToNumber(byte[] p) { if(p.length > 8){ throw new MagicByteException("invalid bytes, byte data too large, can't convert to long, try byteToBigInteger!"); } long res = 0; for (byte b : p) { res <<= 8; res |= (b & 0xFF); } return res; }
[*] target: assertEquals(i, l)
[-] pred: org. junit. Assert. assertEquals ( i, l )
************************************
************************************
[+] input: InterruptedException { for (int i = 0; i < (Integer.MAX_VALUE - 500); i+=100) { BigInteger s = BigInteger.valueOf(i);  byte[] bytes = ConverterUtil.bigIntegerToByte(s); BigInteger l = ConverterUtil.byteToBigInteger(bytes); Assert."<AssertPlaceHolder>"; }  }
byteToBigInteger(byte[] bytes) { BigInteger res = BigInteger.valueOf(0); for (byte b : bytes) { res = res.shiftLeft(8); res = res.or(BigInteger.valueOf(b & 0xff)); } return res; }
[*] target: assertEquals(s, l)
[-] pred: org. junit. Assert. assertEquals ( s, l )
************************************
************************************
[+] input: Exception { var out = new BytesOut(null, 100); out.flush(); "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertEquals(0, out.toByteArray().length)
[-] pred: org. junit. Assert. assertEquals ( 0, out. toByteArray ( ). length )
************************************
************************************
[+] input: Exception { var bout = new ByteArrayOutputStream(); var out = new BytesOut(bout, 8); out.flush();  byte[] b1 = "hello".getBytes("UTF-8"); out.write(b1, 0, b1.length);  byte[] b2 = "world".getBytes("UTF-8"); out.write(b2, 0, b2.length);  byte[] b3 = "hello, world!!!".getBytes("UTF-8"); out.write(b3, 0, b3.length);  out.flush(); byte[] result = bout.toByteArray(); byte[] expect = "helloworldhello, world!!!".getBytes("UTF-8"); "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertArrayEquals(expect, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, result )
************************************
************************************
[+] input: Exception { var bout = new ByteArrayOutputStream(); var out = new BytesOut(bout, 15);  out.writeLong(Long.MAX_VALUE); out.writeLong(Long.MIN_VALUE);  out.flush(); byte[] result = bout.toByteArray(); byte[] expect = {127, -1, -1, -1, -1, -1, -1, -1, -128, 0, 0, 0, 0, 0, 0, 0}; "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertArrayEquals(expect, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, result )
************************************
************************************
[+] input: Exception { var bout = new ByteArrayOutputStream(); var out = new BytesOut(bout, 8);  var str = "hello\u1000"; out.writeUTF(str);  out.flush(); byte[] result = bout.toByteArray();  var bout2 = new ByteArrayOutputStream(); var dout = new DataOutputStream(bout2); dout.writeUTF(str); byte[] expect = bout2.toByteArray(); "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertArrayEquals(expect, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, result )
************************************
************************************
[+] input: testSelectById() { try (SqlSession sqlSession = getSqlSession()) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class);  User user = userMapper.getById(1L); Assert.assertNotNull(user); Assert.assertEquals("张无忌", user.getUsername()); Assert.assertNull(user.getSex());  user.setId(999L); Assert.assertEquals(1, userMapper.insert(user));  int count = userMapper.deleteById(user); Assert."<AssertPlaceHolder>"; sqlSession.rollback(); } }
deleteById(User user);
[*] target: assertEquals(1, count)
[-] pred: org. junit. Assert. assertEquals ( 1, count )
************************************
************************************
[+] input: Exception { assertTrue(sManager.getDataFlowHistory().isEmpty()); startEmitter(); DataFlowID flowID = sManager.createDataFlow(new DataRequest[]{ new DataRequest(EmitterModuleFactory.INSTANCE_URN,"send this data") }); //Wait until sink receives this data while(sSink.getData().length < 1) { Thread.sleep(500); } sManager.cancel(flowID); EmitterModule module = (EmitterModule) ModuleBase.getInstance( EmitterModuleFactory.INSTANCE_URN); DataEmitterSupport support = module.getLastTask().getSupport(); "<AssertPlaceHolder>"; int numData = sSink.getData().length; support.send(new Object()); //verify that the sink doesn't get it. assertEquals(numData, sSink.getData().length); //verify nothing happens if you try to emit error, its silently ignored support.dataEmitError(TestMessages.BAD_DATA, true); module.clear(); }
cancel(ModuleURN inStopRequester) throws DataFlowException { SLF4JLoggerProxy.debug(this, "Stopping flow {} requested by {}",  //$NON-NLS-1$ getFlowID(), inStopRequester ); //Only allow one thread to carry out cancellation at a time. synchronized (this) { if(mCancelling) { throw new DataFlowException(new I18NBoundMessage1P( Messages.DATA_FLOW_ALREADY_CANCELING, getFlowID().toString())); } else { mCancelling = true; } } // Go through each of the requests and cancel the requests // from first to last for(AbstractDataCoupler coupler: mCouplers) { coupler.cancelRequest(); } mStopRequesterURN = inStopRequester; mStopped = new Date(); }
[*] target: assertNotNull(support)
[-] pred: org. junit. Assert. assertNotNull ( support )
************************************
************************************
[+] input: IOException { String testStr = " (( defun test () "hi there"))"; Sexp parsedExpression = SexpFactory.parse(new StringReader(testStr)); Sexp sexp1 = SexpFactory.newNonAtomicSexp(); sexp1.add(SexpFactory.newAtomicSexp("defun")); sexp1.add(SexpFactory.newAtomicSexp("test")); sexp1.add(SexpFactory.newNonAtomicSexp()); sexp1.add(SexpFactory.newAtomicSexp(""hi there"")); Sexp expectedExpression = SexpFactory.newNonAtomicSexp(); expectedExpression.add(sexp1); Assert."<AssertPlaceHolder>"; }
add(Sexp item);
[*] target: assertEquals(expectedExpression, parsedExpression)
[-] pred: org. junit. Assert. assertEquals ( expectedExpression, parsedExpression )
************************************
************************************
[+] input: IOException { String testStr = "( defun test () "hi there")"; Sexp parsedExpression = SexpFactory.parse(testStr); Sexp expectedExpression = SexpFactory.newNonAtomicSexp(); expectedExpression.add(SexpFactory.newAtomicSexp("defun")); expectedExpression.add(SexpFactory.newAtomicSexp("test")); expectedExpression.add(SexpFactory.newNonAtomicSexp()); expectedExpression.add(SexpFactory.newAtomicSexp(""hi there"")); Assert."<AssertPlaceHolder>"; }
add(Sexp item);
[*] target: assertEquals(expectedExpression, parsedExpression)
[-] pred: org. junit. Assert. assertEquals ( expectedExpression, parsedExpression )
************************************
************************************
[+] input: testEquals() { RoleDTO roleDTO = new RoleDTO(1L, "USER"); RoleDTO roleDTO2 = new RoleDTO(1L, "USER");  assertTrue(roleDTO.equals(roleDTO)); assertFalse(roleDTO.equals("WRONG")); "<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) return true; if (!(o instanceof RoleDTO)) return false; return id != null && id.equals(((RoleDTO) o).getId()); }
[*] target: assertTrue(roleDTO.equals(roleDTO2))
[-] pred: org. junit. Assert. assertTrue ( roleDTO. equals ( roleDTO2 ) )
************************************
************************************
[+] input: given_existing_roleId_when_getRoleById_return_Role() { Long roleId = 99L; Role role = new Role(roleId, "TEST ROLE");  given(roleRepository.findById(roleId)).willReturn(Optional.of(role));  Role returnRole = roleService.getRoleById(roleId);  "<AssertPlaceHolder>"; assertEquals(role.getId(), returnRole.getId()); }
getRoleById(Long id) { if (id == null) { throw new InvalidRoleIdentifierException("Id role cannot be null"); } Optional<Role> roleOpt = roleRepository.findById(id); if (roleOpt.isPresent()) { return roleOpt.get(); } throw new RoleNotFoundException(String.format("Role not found for Id = %s", id)); }
[*] target: assertNotNull(returnRole)
[-] pred: org. junit. Assert. assertNotNull ( returnRole )
************************************
************************************
[+] input: given_valid_not_used_name_when_createRole_returnRole() { Long genId = 123L; Role roleData = new Role(genId, "TEST");  when(roleRepository.save(any(Role.class))).thenReturn(new Role(genId, roleData.getRole()));  Role role = roleService.createRole("TEST");  "<AssertPlaceHolder>"; assertEquals(genId, role.getId()); assertEquals("TEST", role.getRole()); }
createRole(String roleStr) { validateRoleName(roleStr);  // check roleStr not in use if (roleRepository.findByRole(roleStr).isPresent()) { String errMsg = String.format("The role %s already exists", roleStr); log.error(errMsg); throw new RoleInUseException(errMsg); }  Role role = new Role(); role.setRole(roleStr);  role = roleRepository.save(role); log.info(String.format("Role %s %s has been created.", role.getId(), role.getRole()));  return role; }
[*] target: assertNotNull(role)
[-] pred: org. junit. Assert. assertNotNull ( role )
************************************
************************************
[+] input: given_existing_role_and_existing_already_associated_permission_throw_InvalidPermissionDataException() { Role role = new Role(1L, "TEST"); role.getPermissions().add(new Permission(1L, "PERMISSION_ONE"));  given(roleRepository.findById(1L)).willReturn(Optional.of(role));  Permission permission = new Permission(1L, "PERMISSION_ONE");  given(permissionRepository.findByPermission("PERMISSION_ONE")).willReturn(Optional.of(permission));  Role roleUpdated = roleService.addPermissionOnRole(1L, "PERMISSION_ONE");  "<AssertPlaceHolder>"; // role data assertEquals(Long.valueOf(1L), roleUpdated.getId()); assertEquals("TEST", roleUpdated.getRole());  // permissions assertEquals(1L, roleUpdated.getPermissions().size()); }
addPermissionOnRole(Long roleId, String permissionKey) { validatePermissionKey(permissionKey);  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); } Role role = roleOpt.get();  // check if exists the permission key Permission permission;  Optional<Permission> permissionOpt = permissionRepository.findByPermission(permissionKey); if (permissionOpt.isPresent()) { // the permission exists permission = permissionOpt.get(); } else { // if the permission doesn't exists: create one permission = new Permission(); permission.setPermission(permissionKey);  permission = permissionRepository.save(permission); }  // check if this role contains already the given permission if (role.getPermissions().contains(permission)) { throw new InvalidPermissionDataException(String.format("The permission %s has been already" + " associated on the role %s", permission.getPermission(), role.getRole() )); }  role.getPermissions().add(permission); roleRepository.save(role);  log.info(String.format("Added permission %s on role id = %s", permissionKey, roleId)); return roleRepository.findById(roleId).get(); }
[*] target: assertNotNull(roleUpdated)
[-] pred: org. junit. Assert. assertNotNull ( roleUpdated )
************************************
************************************
[+] input: given_existing_role_existing_permission_not_used_when_removePermissionOnRole_return_Role() { Role role = new Role(1L, "TEST"); given(roleRepository.findById(1L)).willReturn(Optional.of(role));  Permission permission = new Permission(); permission.setId(1L); permission.setPermission("PERMISSION");  given(permissionRepository.findByPermission("PERMISSION")).willReturn(Optional.of(permission));  Role roleUpdated = roleService.removePermissionOnRole(1L, "PERMISSION");  "<AssertPlaceHolder>"; // role data assertEquals(Long.valueOf(1L), roleUpdated.getId()); assertEquals("TEST", roleUpdated.getRole());  // permissions assertEquals(0L, roleUpdated.getPermissions().size()); }
removePermissionOnRole(Long roleId, String permissionKey) { validatePermissionKey(permissionKey);  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); } Role role = roleOpt.get();  // check permission Optional<Permission> permissionOpt = permissionRepository.findByPermission(permissionKey); if (!permissionOpt.isPresent()) { throw new PermissionNotFoundException(String.format("Permission not found with Id = %s on role %s", permissionKey, roleId)); }  Permission permission = permissionOpt.get();  role.getPermissions().remove(permission); roleRepository.save(role);  log.info(String.format("Removed permission %s from role id = %s", permissionKey, roleId)); return roleRepository.findById(roleId).get(); }
[*] target: assertNotNull(roleUpdated)
[-] pred: org. junit. Assert. assertNotNull ( roleUpdated )
************************************
************************************
[+] input: given_existing_role_existing_permission_in_used_when_removePermissionOnRole_return_Role() { Role role = new Role(1L, "TEST"); given(roleRepository.findById(1L)).willReturn(Optional.of(role));  Permission permission = new Permission(); permission.setId(1L); permission.setPermission("PERMISSION");  given(permissionRepository.findByPermission("PERMISSION")).willReturn(Optional.of(permission));  Role roleUpdated = roleService.removePermissionOnRole(1L, "PERMISSION");  "<AssertPlaceHolder>"; // role data assertEquals(Long.valueOf(1L), roleUpdated.getId()); assertEquals("TEST", roleUpdated.getRole());  // permissions assertEquals(0L, roleUpdated.getPermissions().size()); }
removePermissionOnRole(Long roleId, String permissionKey) { validatePermissionKey(permissionKey);  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); } Role role = roleOpt.get();  // check permission Optional<Permission> permissionOpt = permissionRepository.findByPermission(permissionKey); if (!permissionOpt.isPresent()) { throw new PermissionNotFoundException(String.format("Permission not found with Id = %s on role %s", permissionKey, roleId)); }  Permission permission = permissionOpt.get();  role.getPermissions().remove(permission); roleRepository.save(role);  log.info(String.format("Removed permission %s from role id = %s", permissionKey, roleId)); return roleRepository.findById(roleId).get(); }
[*] target: assertNotNull(roleUpdated)
[-] pred: org. junit. Assert. assertNotNull ( roleUpdated )
************************************
************************************
[+] input: given_existing_user_when_getUserById_returnUser() { Long userId = 1L;  User user = getUserTestData(userId, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findById(userId)).willReturn(Optional.of(user));  User userRet = userService.getUserById(userId);  "<AssertPlaceHolder>"; assertEquals(userId, userRet.getId()); assertEquals("andrea", userRet.getUsername()); assertEquals("Andrea", userRet.getName()); assertEquals("Giassi", userRet.getSurname()); assertEquals("andrea.test@gmail.com", userRet.getContact().getEmail()); assertEquals("+3531122334455", userRet.getContact().getPhone()); }
getUserById(Long id) { if (id == null) { throw new InvalidUserIdentifierException("User Id cannot be null"); } Optional<User> userOpt = userRepository.findById(id); if (userOpt.isPresent()) { return userOpt.get(); } throw new UserNotFoundException(String.format("User not found for Id = %s", id)); }
[*] target: assertNotNull(userRet)
[-] pred: org. junit. Assert. assertNotNull ( userRet )
************************************
************************************
[+] input: given_existing_username_when_getUserByUsername_return_user() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findByUsername("andrea")).willReturn(userDataForTest);  User user = userService.getUserByUsername("andrea");  "<AssertPlaceHolder>"; assertEquals(Long.valueOf(1L), user.getId()); assertEquals("andrea", user.getUsername()); assertEquals("Andrea", user.getName()); assertEquals("Giassi", user.getSurname()); assertEquals("andrea.test@gmail.com", user.getContact().getEmail()); assertEquals("+3531122334455", user.getContact().getPhone()); }
getUserByUsername(String username) { if (username == null) { throw new InvalidUsernameException("username cannot be null"); } return userRepository.findByUsername(username); }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_existing_email_when_getUserByEmail_return_user() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findByEmail("andrea.test@gmail.com")).willReturn(userDataForTest);  User user = userService.getUserByEmail("andrea.test@gmail.com");  "<AssertPlaceHolder>"; assertEquals(Long.valueOf(1L), user.getId()); assertEquals("andrea", user.getUsername()); assertEquals("Andrea", user.getName()); assertEquals("Giassi", user.getSurname()); assertEquals("andrea.test@gmail.com", user.getContact().getEmail()); assertEquals("+3531122334455", user.getContact().getPhone()); }
getUserByEmail(String email) { if (email == null) { throw new InvalidEmailException("email cannot be null"); } return userRepository.findByEmail(email); }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_valid_login_when_login_return_User() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findByUsername("andrea")).willReturn(userDataForTest);  User user = userService.login("andrea", UserTestHelper.TEST_PASSWORD_DECRYPTED);  "<AssertPlaceHolder>"; assertEquals("andrea", user.getUsername()); }
login(String username, String password) { if ((Strings.isNullOrEmpty(username)) || (Strings.isNullOrEmpty(password))) { throw new InvalidLoginException("Username or Password cannot be null or empty"); }  User user = getUserByUsername(username); if (user == null) { // invalid username throw new InvalidLoginException("Invalid username or password"); }  log.info(String.format("Login request from %s", username));  // check the password if (EncryptionService.isPasswordValid(password, user.getPassword(), salt)) { // check if the user is enabled if (!user.isEnabled()) { // not enabled throw new InvalidLoginException("User is not enabled"); }  // update the last login timestamp user.setLoginDt(LocalDateTime.now()); userRepository.save(user);  log.info(String.format("Valid login for %s", username)); } else { throw new InvalidLoginException("Invalid username or password"); } return user; }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_validUserAndRoleIds_when_addRole_returnUser() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findById(1L)).willReturn(Optional.of(userDataForTest));  Role roleAdmin = new Role(Role.ADMINISTRATOR, "Administrator");  given(roleRepository.findById(2L)).willReturn(Optional.of(roleAdmin));  User user = userService.addRole(1L, 2L);  "<AssertPlaceHolder>";  // check the new added role Set<Role> roleSet = user.getRoles();  assertNotNull(roleSet); assertEquals(2, roleSet.size()); assertTrue(roleSet.contains(roleAdmin)); }
addRole(Long id, Long roleId) { // check user Optional<User> userOpt = userRepository.findById(id); if (!userOpt.isPresent()) { throw new UserNotFoundException(String.format("User not found with Id = %s", id)); } User user = userOpt.get();  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); }  Role role = roleOpt.get();  user.getRoles().add(role); user.setUpdatedDt(LocalDateTime.now());  userRepository.save(user); log.info(String.format("Added role %s on user id = %s", role.getRole(), user.getId()));  return user; }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_validUserAndRoleIds_when_removeRole_returnUser() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  Role roleAdmin = new Role(Role.ADMINISTRATOR, "Administrator"); userDataForTest.getRoles().add(roleAdmin);  given(userRepository.findById(1L)).willReturn(Optional.of(userDataForTest)); given(roleRepository.findById(2L)).willReturn(Optional.of(roleAdmin));  User user = userService.removeRole(1L, 2L);  "<AssertPlaceHolder>";  // check the remove role Set<Role> roleSet = user.getRoles();  assertNotNull(roleSet); assertEquals(1, roleSet.size()); assertTrue(!roleSet.contains(roleAdmin)); }
removeRole(Long id, Long roleId) { // check user Optional<User> userOpt = userRepository.findById(id); if (!userOpt.isPresent()) { throw new UserNotFoundException(String.format("User not found with Id = %s", id)); } User user = userOpt.get();  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); }  Role role = roleOpt.get();  user.getRoles().remove(role); user.setUpdatedDt(LocalDateTime.now());  userRepository.save(user); log.info(String.format("Removed role %s on user id = %s", role.getRole(), user.getId()));  return user; }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: testFindByUsername() { String username = "administrator"; User user = userRepository.findByUsername(username); "<AssertPlaceHolder>"; }
findByUsername(String username);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: mergeReduceFile() { CommonFile.mergeReduceOutFiles(Collections.singletonList(MR_EXPECT_REDUCE)); String expect = FileUtil.readFile(MR_EXPECT_OUT); String act = FileUtil.readFile(CommonFile.MR_MERGE_OUT); Assert."<AssertPlaceHolder>"; }
mergeReduceOutFiles(List<String> reduceFiles) { Map<String, String> kvs = new HashMap<>(); reduceFiles.forEach(reduceFile -> { Stream<String> stream = FileUtil.stream(reduceFile); if (stream == null) { return; } stream.forEach(s -> { KeyValue keyValue = JSON.parseObject(s.getBytes(StandardCharsets.UTF_8), KeyValue.class); kvs.put(keyValue.getKey(), keyValue.getValue()); } ); }); List<String> keys = new ArrayList<>(kvs.keySet()); keys.sort(String::compareTo); keys.forEach(key -> { FileUtil.append(MR_MERGE_OUT, key + ": " + kvs.get(key)); }); LogUtil.log("ok to merge all files"); }
[*] target: assertEquals(expect, act)
[-] pred: org. junit. Assert. assertEquals ( expect, act )
************************************
************************************
[+] input: initModel() { boolean res = activityActivityTestRule.getActivity().initModel(); Log.d("EnhancementTest", "res:" + res); "<AssertPlaceHolder>"; }
initModel() { enhancement = new com.sensifai.enhancement.tflite.Enhancement(true); return enhancement.init(this, ENHANCEMENT_TFLITE_MODEL_NAME, Device.GPU, 1); }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: testSaveToString() { FileConfiguration config = getConfig();  for (Map.Entry<String, Object> entry : getTestValues().entrySet()) { config.set(entry.getKey(), entry.getValue()); }  String result = config.saveToString(); String expected = getTestValuesString();  "<AssertPlaceHolder>"; }
saveToString();  /** * Loads this {@link FileConfiguration}
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testSaveToStringWithHeader() { FileConfiguration config = getConfig(); config.options().header(getTestHeaderInput());  for (Map.Entry<String, Object> entry : getTestValues().entrySet()) { config.set(entry.getKey(), entry.getValue()); }  String result = config.saveToString(); String expected = getTestHeaderResult() + "\n" + getTestValuesString();  "<AssertPlaceHolder>"; }
saveToString();  /** * Loads this {@link FileConfiguration}
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testSaveToStringWithIndent() { YamlConfiguration config = getConfig(); config.options().indent(9);  config.set("section.key", 1);  String result = config.saveToString(); String expected = "section:\n         key: 1\n";  "<AssertPlaceHolder>"; }
saveToString() { yamlOptions.setIndent(options().indent()); yamlOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK); yamlOptions.setAllowUnicode(SYSTEM_UTF); yamlRepresenter.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);  String header = buildHeader(); String dump = yaml.dump(getValues(false));  if (dump.equals(BLANK_CONFIG)) { dump = ""; }  return header + dump; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: TestPlugin() { Conversable conversable = new FakeConversable(); ConversationContext context = new ConversationContext(null, conversable, new HashMap<Object, Object>()); "<AssertPlaceHolder>"; }
getPlugin() { return plugin; }
[*] target: assertEquals(null, context.getPlugin())
[-] pred: org. junit. Assert. assertEquals ( null, context. getPlugin() )
************************************
************************************
[+] input: testInvalidateDoesNothing() { Object o = new Object(); subject = new FixedMetadataValue(plugin, o); subject.invalidate(); "<AssertPlaceHolder>"; }
value() { return internalValue; }
[*] target: assertSame(o, subject.value())
[-] pred: org. junit. Assert. assertSame ( o, subject. value() )
************************************
************************************
[+] input: testLazyString() { String value = "TEN"; subject = makeSimpleCallable(value);  "<AssertPlaceHolder>"; }
value() { eval(); Object value = internalValue.get(); if (value == ACTUALLY_NULL) { return null; } return value; }
[*] target: assertEquals(value, subject.value())
[-] pred: org. junit. Assert. assertEquals ( value, subject. value() )
************************************
************************************
[+] input: testLazyBoolean() { boolean value = false; subject = makeSimpleCallable(value);  "<AssertPlaceHolder>"; }
value() { eval(); Object value = internalValue.get(); if (value == ACTUALLY_NULL) { return null; } return value; }
[*] target: assertEquals(value, subject.value())
[-] pred: org. junit. Assert. assertEquals ( value, subject. value() )
************************************
************************************
[+] input: Exception { ComponentName cn = new ComponentName(getContext(), TEST_ACTIVITY); initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), false  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: Exception { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = new ComponentName(mContext.getPackageName(), "placeholder-do"); WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), true  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: duplicateEntries() { IntSet set = new IntSet(); set.add(2); set.add(2); "<AssertPlaceHolder>"; }
size() { return mArray.size(); }
[*] target: assertEquals(1, set.size())
[-] pred: org. junit. Assert. assertEquals ( 1, set. size() )
************************************
************************************
[+] input: UnsupportedEncodingException { BigDecimal decimal = new BigDecimal("1234567890123456789012345678901234567890.1234567809"); byte[] bytes = SerializeUtils.bigDecimal2Bytes(decimal); BigDecimal decimal1 = SerializeUtils.bytes2BigDecimal(bytes); "<AssertPlaceHolder>"; }
bytes2BigDecimal(byte[] bytes) throws UnsupportedEncodingException { String val = new String(bytes, "UTF-8"); return new BigDecimal(val); }
[*] target: assertEquals(decimal,decimal1)
[-] pred: org. junit. Assert. assertEquals ( decimal, decimal1 )
************************************
************************************
[+] input: backupAccountToKeyStoreTest() { //Create password accounts Chain chain = new Chain(); chain.setConfig(new ConfigBean(chainId, assetId)); List<Account> accountList = accountService.createAccount(chain, 1, password); String address = accountList.get(0).getAddress().getBase58(); //Test not specifying backup path String pathDir = ""; //Backup accountkeystore  backup account keyStore String path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); assertNotNull(path);  //Test specified nonwindowsBackup path pathDir = "test1/back/up"; //Backup accountkeystore  backup account keyStore path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); assertNotNull(path);  //Test specifiedwindowsBackup path pathDir = "D:\\workspace\\github\\nuls_2.0\\test2\\back\\up"; //Create an unencrypted account for test accountList = accountService.createAccount(chain, 1, null); address = accountList.get(0).getAddress().getBase58(); //Backup accountkeystore  backup account keyStore path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); "<AssertPlaceHolder>";  }
backupAccountToKeyStore(String path, int chainId, String address, String password);
[*] target: assertNotNull(path)
[-] pred: org. junit. Assert. assertNotNull ( path )
************************************
************************************
[+] input: getAccountTest() { //create account List<Account> accountList = accountService.createAccount(chain, 1, password); //query account Account account = accountService.getAccount(chainId, accountList.get(0).getAddress().getBase58()); "<AssertPlaceHolder>"; assertEquals(accountList.get(0).getAddress().getBase58(), account.getAddress().getBase58()); }
getAccount(int chainId, String address);
[*] target: assertNotNull(account)
[-] pred: org. junit. Assert. assertNotNull ( account )
************************************
************************************
[+] input: setRemarkTest() { try { String remark = "test remark"; String errorRemark = "test error remark test error remark test error remark test error remarktest"; //Create password accounts List<Account> accountList = accountService.createAccount(chain, 1, password); //Set the correct remarks for the account boolean result = accountService.setRemark(chainId, accountList.get(0).getAddress().getBase58(), remark); Account account = accountService.getAccount(chainId, accountList.get(0).getAddress().getBase58()); assertTrue(result); assertEquals(remark, account.getRemark()); //Set the correct remarks for the account result = accountService.setRemark(chainId, accountList.get(0).getAddress().getBase58(), ""); assertTrue(result); //Set incorrect remarks for the account >60 bytes result = accountService.setRemark(chainId, accountList.get(0).getAddress().getBase58(), errorRemark); "<AssertPlaceHolder>"; } catch (NulsRuntimeException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } }
setRemark(int chainId, String address, String remark);
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: Exception { // create account Alias alias = AliasStorageServiceTest.createAlias(); boolean result = aliasService.aliasTxCommit(chainId,alias); "<AssertPlaceHolder>"; Account account = accountService.getAccount(chainId, AddressTool.getStringAddressByBytes(alias.getAddress())); assertNotNull(account); assertEquals(account.getAlias(),alias.getAlias()); }
aliasTxCommit(int chainId, Alias alias) throws NulsException;
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { List<AccountPO> accountPOs = new ArrayList<>(); int count = 10; String password = "a2678"; for (int i = 0; i < count; i++) { //create account Account account = AccountTool.createAccount(chainId); if (StringUtils.isNotBlank(password)) { account.encrypt(password); } AccountPO po = new AccountPO(account); accountPOs.add(po); } //Batch Save Account Data boolean result = accountStorageService.saveAccountList(accountPOs); "<AssertPlaceHolder>"; assertEquals(accountPOs.size(), count); for (AccountPO account : accountPOs) { System.out.println(account.getAddress()); } }
saveAccountList(List<AccountPO> accountPOList);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { Account account = AccountTool.createAccount(chainId); boolean result = accountStorageService.saveAccount(new AccountPO(account)); "<AssertPlaceHolder>"; }
saveAccount(AccountPO account);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { Account account = AccountTool.createAccount(chainId); accountStorageService.saveAccount(new AccountPO(account)); AccountPO accountPo = accountStorageService.getAccount(account.getAddress().getAddressBytes()); "<AssertPlaceHolder>"; assertEquals(account.getAddress().getBase58(), accountPo.getAddress()); }
getAccount(byte[] address);
[*] target: assertNotNull(accountPo)
[-] pred: org. junit. Assert. assertNotNull ( accountPo )
************************************
************************************
[+] input: Exception { Alias alias1 = createAlias(); boolean result = aliasStorageService.saveAlias(chainId,alias1); assertTrue(result); Alias alias2 = createAlias(); result = aliasStorageService.saveAlias(chainId,alias2); "<AssertPlaceHolder>"; }
saveAlias(int chainId, Alias alias);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { int start = 1; int count = 10; List<Block> blocks = new ArrayList<>();  GenesisBlock genesisBlock = GenesisBlock.getInstance(0, 0); blocks.add(genesisBlock);  Block preBlock = genesisBlock; do{ Block block = BlockGenerator.generate(preBlock); blocks.add(block); preBlock = block; start++; } while (start < count);  for (int i = 0; i < blocks.size()-1; i++) { NulsHash prehash = blocks.get(i).getHeader().getHash(); NulsHash hash = blocks.get(i+1).getHeader().getPreHash(); Assert."<AssertPlaceHolder>"; } }
generate(Block latestBlock) throws Exception { return generate(latestBlock, 1, "1"); }
[*] target: assertEquals(prehash, hash)
[-] pred: org. junit. Assert. assertEquals ( prehash, hash )
************************************
************************************
[+] input: Exception { List<TransactionConfirmedPO> list = new ArrayList<>(); for (int i = 0; i < 5; i++) { Transaction tx = TestConstant.getTransaction2(); tx.setRemark(StringUtils.bytes("tx remark" + i)); list.add(new TransactionConfirmedPO(tx, 1, (byte)1)); } boolean result = confirmedTxStorageService.saveTxList(chainId, list); Assert."<AssertPlaceHolder>"; }
saveTxList(int chainId, List<TransactionConfirmedPO> txList);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { Transaction tx = TestConstant.getTransaction2(); boolean result = unconfirmedTxStorageService.putTx(chainId, tx); Assert."<AssertPlaceHolder>"; }
putTx(int chainId, Transaction tx);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: pruneGeorgianNames01() { // Georgian / Georgia final Locale bookLocale = new Locale("ka", "GE");  final AuthorDao authorDao = serviceLocator.getAuthorDao();  final List<Author> authorList = new ArrayList<>(); Author author;  // https://en.wikipedia.org/wiki/Alexander_Abasheli author = Author.from("ალექსანდრე აბაშელი"); authorDao.fixId(context, author, bookLocale); authorList.add(author);  // https://en.wikipedia.org/wiki/Irakli_Abashidze author = Author.from("ირაკლი აბაშიძე"); authorDao.fixId(context, author, bookLocale); authorList.add(author);  // https://en.wikipedia.org/wiki/Alexander_Amilakhvari author = Author.from("ალექსანდრე ამილახვარი"); authorDao.fixId(context, author, bookLocale); authorList.add(author);  final boolean modified = authorDao.pruneList(context, authorList, item -> bookLocale); "<AssertPlaceHolder>"; }
from(@NonNull final String name) { String uName = StringCoder.unEscape(name);  // First step, check for a bracket section. String bracketSection = null; final Matcher brackets = PATTERN_BRACKETS.matcher(uName); if (brackets.find()) { // Grab the full string before the brackets for further decoding as the name String group = brackets.group(1); if (group != null) { uName = group.strip(); } // If we did find a brackets parts, preserve it for later concatenation. if (brackets.groupCount() > 1) { group = brackets.group(2); if (group != null) { group = group.strip(); if (!group.isEmpty()) { bracketSection = group; } } } // If there is another piece of text after the brackets parts if (brackets.groupCount() > 2) { group = brackets.group(3); if (group != null) { group = group.strip(); if (!group.isEmpty()) { if (uName.isEmpty() && bracketSection != null && group.startsWith(", ")) { // assume it's the format "(blah), name" and decode // BACKWARDS compatible: return new Author(bracketSection, group.substring(2)); } else { // this is far to complicated to make sense... // Just concat with the name part uName += " " + group; } } } } }  // check for commas final List<String> tmp = StringList.newInstance().decode(uName, ',', true); if (tmp.size() > 1) { final Matcher suffixMatcher = FAMILY_NAME_SUFFIX_PATTERN.matcher(tmp.get(1)); if (suffixMatcher.find()) { // GivenNames FamilyName, suffix // concatenate without the comma. Further processing will take care of the suffix. uName = tmp.get(0) + ' ' + tmp.get(1); } else { // FamilyName, GivenNames // no suffix, assume the names are already formatted. return createWithOptionalBrackets(tmp.get(0), tmp.get(1), bracketSection); } }  final String[] names = uName.split(" "); // two easy cases switch (names.length) { case 1: return createWithOptionalBrackets(names[0], "", bracketSection); case 2: return createWithOptionalBrackets(names[1], names[0], bracketSection); default: break; }  // we have 3 or more parts, check the family name for suffixes and prefixes final StringBuilder buildFamilyName = new StringBuilder(); // the position to check, start at the end. int pos = names.length - 1;  final Matcher suffixMatcher = FAMILY_NAME_SUFFIX_PATTERN.matcher(names[pos]); if (suffixMatcher.find()) { // suffix and the element before it are part of the last name. buildFamilyName.append(names[pos - 1]).append(' ').append(names[pos]); pos -= 2; } else { // no suffix. buildFamilyName.append(names[pos]); pos--; }  // the last name could also have a prefix final Matcher middleNameMatcher = FAMILY_NAME_PREFIX_PATTERN.matcher(names[pos]); if (middleNameMatcher.find()) { // insert it at the front of the family name buildFamilyName.insert(0, names[pos] + ' '); pos--; }  // everything else are considered given names final StringBuilder buildGivenNames = new StringBuilder(); for (int i = 0; i <= pos; i++) { buildGivenNames.append(names[i]).append(' '); }   return createWithOptionalBrackets(buildFamilyName.toString(), buildGivenNames.toString(), bracketSection); }
[*] target: assertFalse(modified)
[-] pred: org. junit. Assert. assertFalse ( modified )
************************************
************************************
[+] input: dumpSites() { final Context context = ServiceLocator.getInstance().getAppContext();  for (final Site.Type type : Site.Type.values()) { final List<Site> sites = type.getSites(); Log.d(TAG, "\n------------------------------------------\n\n" + type);  for (final Site site : sites) { final EngineId engineId = site.getEngineId(); final SearchEngineConfig config = engineId.getConfig(); assertNotNull(config); final SearchEngine searchEngine = engineId.createSearchEngine(context); "<AssertPlaceHolder>";  Log.d(TAG, "\n" + config + "\n\n" + site + "\n\n" + searchEngine); } } }
createSearchEngine(@NonNull final Context context) { try { final Constructor<? extends SearchEngine> c = clazz.getConstructor(Context.class, SearchEngineConfig.class); return c.newInstance(context.getApplicationContext(), config);  } catch (@NonNull final NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) { throw new IllegalStateException( clazz + " must implement SearchEngine(Context, SearchEngineConfig)", e); } }
[*] target: assertNotNull(searchEngine)
[-] pred: org. junit. Assert. assertNotNull ( searchEngine )
************************************
************************************
[+] input: testParseJson() { String json = "[\n" + "{\n" + ""id": "Source__TableSourceScan(table=[[default_catalog__default_database__nexmark]]__fi.numRecordsOutPerSecond",\n" + ""min": 5003.2,\n" + ""max": 5003.2,\n" + ""avg": 5003.2,\n" + ""sum": 10006.3\n" + "}\n" + "]";  TpsMetric tps = TpsMetric.fromJson(json); TpsMetric expected = new TpsMetric( "Source__TableSourceScan(table=[[default_catalog__default_database__nexmark]]__fi.numRecordsOutPerSecond", 5003.2, 5003.2, 5003.2, 10006.3); "<AssertPlaceHolder>"; }
fromJson(String json) { try { JsonNode jsonNode = NexmarkUtils.MAPPER.readTree(json); return NexmarkUtils.MAPPER.convertValue(jsonNode.get(0), TpsMetric.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } }
[*] target: assertEquals(expected, tps)
[-] pred: org. junit. Assert. assertEquals ( expected, tps )
************************************
************************************
[+] input: authorize() { Mockito.when(session.principal()).thenReturn(customPrincipal); Mockito.when(customPrincipal.getOauthBearerTokenJwt()).thenReturn(jwt);  Set<String> set = new HashSet<>(); set.add("urn:kafka:topic:test:write");  Mockito.when(jwt.scope()).thenReturn(set); Mockito.when(resource.name()).thenReturn("test"); Mockito.when(resource.resourceType()).thenReturn(ResourceType.fromString("topic")); Mockito.when(operation.toJava()).thenReturn(AclOperation.fromString("write")); boolean result = customAuthorizer.authorize(session, operation, resource);  "<AssertPlaceHolder>"; }
authorize(Session session, Operation operation, Resource resource) { try { log.info("Starting Authorization."); // log.info("Session Info: {}", session.toString()); log.info("Operation request Info: {}", operation.toString()); log.info("Resource request Info: {}", resource.toString()); if (!(session.principal() instanceof CustomPrincipal)) { log.error("Session Principal is not using the proper class. Should be instance of CustomPrincipal."); return false; }  CustomPrincipal principal = (CustomPrincipal) session.principal(); if (principal.getOauthBearerTokenJwt() == null) { log.error("Custom Principal does not contain token information."); return false; }  OAuthBearerTokenJwt jwt = principal.getOauthBearerTokenJwt(); if (jwt.scope() == null || jwt.scope().isEmpty()) { log.error("No scopes provided in JWT. Unable to Authorize."); return false; }  java.util.Set<String> scopes = jwt.scope(); List<OAuthScope> scopeInfo = parseScopes(scopes); String operationStr = operation.toJava().toString(); return checkAuthorization(scopeInfo, resource, operationStr); } catch (Exception e) { log.error("Error in authorization. ", e); } return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: checkAuthorization() { List<OAuthScope> list = new ArrayList<>(); OAuthScope scope = new OAuthScope(); scope.setOperation("Write"); scope.setResourceName("test"); scope.setResourceType("topic"); list.add(scope);  Resource resource = new Resource(ResourceType.fromString("Topic"), "TEST");  CustomAuthorizer authorizer = new CustomAuthorizer();  boolean result = authorizer.checkAuthorization(list, resource, "write");  "<AssertPlaceHolder>";  }
checkAuthorization(List<OAuthScope> scopeInfo, Resource resource, String operation) { for (int i = 0; i < scopeInfo.size(); i++) { OAuthScope scope = scopeInfo.get(i); String lowerCaseOperation = operation.toLowerCase(); String lowerCaseResourceName = resource.name().toLowerCase(); String lowerCaseCaseResourceType = resource.resourceType().toString().toLowerCase();  boolean operationVal = scope.getOperation().toLowerCase().equals(lowerCaseOperation); boolean nameVal = scope.getResourceName().toLowerCase().equals(lowerCaseResourceName); boolean typeVal = scope.getResourceType().toLowerCase().equals(lowerCaseCaseResourceType);  if (operationVal && nameVal && typeVal) { log.info("Successfully Authorized."); return true; } } log.info("Not Authorized to operate on the given resource."); return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { //		Map<String, String > map = new HashMap<>(); //		map.put("getBooleanEnvironmentVariable", null); //		setEnv(map); //		Boolean output = EnvironmentVariablesUtil.getBooleanEnvironmentVariable("getBooleanEnvironmentVariable", Boolean.valueOf("true")); //		"<AssertPlaceHolder>"; //	}
getBooleanEnvironmentVariable(String envName, Boolean defaultValue) { Boolean result; String env = System.getenv(envName); if (env == null) { result = defaultValue; } else { result = Boolean.valueOf(env); } return result; }
[*] target: assertTrue(output)
[-] pred: org. junit. Assert. assertTrue ( output )
************************************
************************************
[+] input: testOK() { CheckResult result = CheckResult.OK; Assert.assertFalse(result.isError()); Assert."<AssertPlaceHolder>"; }
getMessage() { return message; }
[*] target: assertNull(result.getMessage())
[-] pred: org. junit. Assert. assertNull ( result. getMessage() )
************************************
************************************
[+] input: testServicesEmpty() { Collection<Service> services = collector.services(); Assert."<AssertPlaceHolder>"; }
services() { return Collections.unmodifiableMap(services).values(); }
[*] target: assertEquals(0, services.size())
[-] pred: org. junit. Assert. assertEquals ( 0, services. size ( ) )
************************************
************************************
[+] input: testNoteToMessagerVerbose() { ProcessorLogger logger = new ProcessorLogger(messager, optionsVerbose); messager.reset(); logger.note(LogLocation.MESSAGER, "message"); List<Message> messages = messager.messages(); Assert."<AssertPlaceHolder>"; Assert.assertEquals("message", messages.get(0).msg); Assert.assertEquals(Kind.NOTE, messages.get(0).kind); }
note(LogLocation location, String message) { if (location == null) { throw new NullPointerException("location"); } if (message == null) { throw new NullPointerException("message"); }  if (options.verbose() && location.toMessager()) { messager.printMessage(Kind.NOTE, message); }  if (options.logging() && location.toLogFile()) { logContent.append(message).append("\n"); } }
[*] target: assertEquals(1, messages.size())
[-] pred: org. junit. Assert. assertEquals ( 1, messages. size ( ) )
************************************
************************************
[+] input: Exception { File file = File.createTempFile("test", ".log"); try { FileFilter filter = ServiceFileFilter.INSTANCE; Assert."<AssertPlaceHolder>"; } finally { file.delete(); } }
accept(File file) { if (!file.isFile()) { return false; }  return !file.getName().toLowerCase().endsWith(".log"); }
[*] target: assertFalse(filter.accept(file))
[-] pred: org. junit. Assert. assertFalse ( filter. accept( file ) )
************************************
************************************
[+] input: Exception { File file = File.createTempFile("test", ".tmp"); try { FileFilter filter = ServiceFileFilter.INSTANCE; Assert."<AssertPlaceHolder>"; } finally { file.delete(); } }
accept(File file) { if (!file.isFile()) { return false; }  return !file.getName().toLowerCase().endsWith(".log"); }
[*] target: assertTrue(filter.accept(file))
[-] pred: org. junit. Assert. assertTrue ( filter. accept( file ) )
************************************
************************************
[+] input: when_timeout_a_vote_than_it_has_a_timeout_signature() { Vote vote = mock(Vote.class); Vote voteWithTimeout = mock(Vote.class); when(vote.getView()).thenReturn(View.of(1)); when(vote.getEpoch()).thenReturn(1L); when(vote.withTimeoutSignature(any())).thenReturn(voteWithTimeout); when(vote.isTimeout()).thenReturn(false);  Builder builder = mock(Builder.class); when(builder.lastVote(any())).thenReturn(builder); when(builder.build()).thenReturn(this.safetyState); when(safetyState.toBuilder()).thenReturn(builder);  Vote resultVote = safetyRules.timeoutVote(vote); verify(vote, times(1)).withTimeoutSignature(any()); "<AssertPlaceHolder>"; }
timeoutVote(Vote vote) { if (vote.isTimeout()) { // vote is already timed out return vote; }  final VoteTimeout voteTimeout = VoteTimeout.of(vote); final HashCode voteTimeoutHash = hasher.hash(voteTimeout);  final ECDSASignature timeoutSignature = this.signer.sign(voteTimeoutHash); final Vote timeoutVote = vote.withTimeoutSignature(timeoutSignature);  this.state = this.state.toBuilder().lastVote(timeoutVote).build(); this.persistentSafetyStateStore.commitState(this.state);  return timeoutVote; }
[*] target: assertEquals(voteWithTimeout, resultVote)
[-] pred: org. junit. Assert. assertEquals ( voteWithTimeout, resultVote )
************************************
************************************
[+] input: if_validator_data_missing_then_retrieved_via_radix_engine() { var self = BFTNode.random(); var radixEngine = TypedMocks.cmock(new TypeLiteral<RadixEngine<LedgerAndBFTProof>>() {}); var systemInfo = new InMemorySystemInfo(null, null, self, radixEngine); var validatorBFTData = Optional.of(new ValidatorBFTDataEvent(self.getKey(), 10, 1));  when(radixEngine.read(any())).thenReturn(validatorBFTData);  var result = systemInfo.getValidatorBFTData(); var expected = Optional.of(new ValidatorBFTDataEvent(self.getKey(), 10, 1));  "<AssertPlaceHolder>"; }
getValidatorBFTData() { if (!missedProposals.isMarked()) { // There were no relevant events yet missedProposals.set(getProposalStats(), true); }  return missedProposals.getReference(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: if_validator_data_present_then_radix_engine_is_not_invoked() { var self = BFTNode.random(); var radixEngine = TypedMocks.cmock(new TypeLiteral<RadixEngine<LedgerAndBFTProof>>() {}); var systemInfo = new InMemorySystemInfo(null, null, self, radixEngine);  systemInfo.ledgerUpdateEventProcessor().process(createLedgerUpdate(self));  var result = systemInfo.getValidatorBFTData(); var expected = Optional.of(new ValidatorBFTDataEvent(self.getKey(), 10, 1));  "<AssertPlaceHolder>";  verifyNoInteractions(radixEngine); }
getValidatorBFTData() { if (!missedProposals.isMarked()) { // There were no relevant events yet missedProposals.set(getProposalStats(), true); }  return missedProposals.getReference(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: verify_that_tobytearray_returns_same_as_passed_in_constructor() { byte[] bytes = Bytes.fromHexString("dead000000000000000000000000beef"); EUID euid = new EUID(bytes); "<AssertPlaceHolder>"; }
toByteArray() { return value.toByteArray(); }
[*] target: assertArrayEquals(bytes, euid.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( bytes, euid. toByteArray ( ) )
************************************
************************************
[+] input: testSecondIsNull() { Pair<String, String> p = Pair.of(null, null); assertTrue(p.secondIsNull()); "<AssertPlaceHolder>"; }
secondNonNull() { return this.second != null; }
[*] target: assertFalse(p.secondNonNull())
[-] pred: org. junit. Assert. assertFalse ( p. secondNonNull() )
************************************
************************************
[+] input: test() { Map<String, String> map = new HashMap<String, String>(); map.put("vvv", "aaa@0.0.1"); map.put("array", "aaa@0.0.1,bbb@0.0.2-SNAPSHOT,ccc@0.0.0");  String string = FeatureCodec.DEFAULT_COMMANDLINE_CODEC.toString(map);  Map<String, String> map2 = FeatureCodec.DEFAULT_COMMANDLINE_CODEC.toMap(string);  Assert."<AssertPlaceHolder>";  System.err.println(string); System.err.println(map2);  }
toMap(final String featureString) {  final Map<String, String> map = new HashMap<String, String>();  if (isBlank(featureString)) { return map; }  for (String kv : escapeSplit(featureString, kvSegmentSeparator)) {  if (isBlank(kv)) { // 过滤掉为空的字符串片段 continue; }  final String[] ar = escapeSplit(kv, kvSeparator); if (ar.length != 2) { // 过滤掉不符合K:V单目的情况 continue; }  final String k = ar[0]; final String v = ar[1]; if (!isBlank(k) && !isBlank(v)) { map.put(escapeDecode(k), escapeDecode(v)); }  }  return map; }
[*] target: assertEquals(map, map2)
[-] pred: org. junit. Assert. assertEquals ( map, map2 )
************************************
************************************
[+] input: InactiveSensorException { sensor = new TempSensor("TEST"); String testString = "TempSensor{name='TEST', alias='test', address='28-456A123654xxx', sensorOffset=2, gpio=null, lastReadTime=null, lastTempRead=0}"; "<AssertPlaceHolder>"; }
toString() { return "TempSensor{" + "name='" + name + ''' + ", alias='" + alias + ''' + ", address='" + address + ''' + ", sensorOffset=" + sensorOffset + ", lastReadTime=" + lastReadTime + ", lastTempRead=" + lastTempRead + '}'; }
[*] target: assertEquals(testString,sensor.toString())
[-] pred: org. junit. Assert. assertEquals ( testString, sensor. toString ( ) )
************************************
************************************
[+] input: shouldReturnNullForInvalidUrl() { PatientIdentifierType actualIdentifierType = dao.getPatientIdentifierTypeByUrl("invalidUrl"); "<AssertPlaceHolder>"; }
getPatientIdentifierTypeByUrl(String url) { return (PatientIdentifierType) sessionFactory.getCurrentSession().createCriteria(FhirPatientIdentifierSystem.class) .add(eq("url", url)).setProjection(Projections.property("patientIdentifierType")).uniqueResult(); }
[*] target: assertNull(actualIdentifierType)
[-] pred: org. junit. Assert. assertNull ( actualIdentifierType )
************************************
************************************
[+] input: shouldReturnNullForNullUrl() { PatientIdentifierType actualIdentifierType = dao.getPatientIdentifierTypeByUrl(null); "<AssertPlaceHolder>"; }
getPatientIdentifierTypeByUrl(String url) { return (PatientIdentifierType) sessionFactory.getCurrentSession().createCriteria(FhirPatientIdentifierSystem.class) .add(eq("url", url)).setProjection(Projections.property("patientIdentifierType")).uniqueResult(); }
[*] target: assertNull(actualIdentifierType)
[-] pred: org. junit. Assert. assertNull ( actualIdentifierType )
************************************
************************************
[+] input: testgetBoolean() { boolean result = store.getBoolean("testKeyboolean", true); "<AssertPlaceHolder>"; }
getBoolean(String key, boolean defaultValue) { return getBoolean(key, defaultValue, null, new ItemConstraintBoolean()); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testMessageCountValidity() { int cutBackCount = CAPACITY / 2; testBuffer.setCutBackCount(cutBackCount); // Fill the buffer to its capacity. for (int i = 1; i <= CAPACITY; i++) { testBuffer.addNotification(new UserNotification("message text", UserNotification.Level.INFORMATIONAL)); assertEquals(i, testBuffer.getMessageCount()); List<UserNotification> messages = testBuffer.getNotifications(); assertEquals(i, messages.size()); } // Add one more message to exceed the capacity. testBuffer.addNotification(new UserNotification("message text", UserNotification.Level.INFORMATIONAL)); assertEquals(cutBackCount, testBuffer.getMessageCount()); List<UserNotification> messages = testBuffer.getNotifications(); "<AssertPlaceHolder>"; }
getNotifications() { LOG.debug("method entry"); return new LinkedList<>(notifications); }
[*] target: assertEquals(cutBackCount, messages.size())
[-] pred: org. junit. Assert. assertEquals ( cutBackCount, messages. size ( ) )
************************************
************************************
[+] input: shouldReturnObjectsByClassAndPattern() { Point point1 = new Point("Point-00001"); pool.addObject(point1); Point point2 = new Point("Point-00002"); pool.addObject(point2); Path path1 = new Path("Point-00003", point1.getReference(), point2.getReference()); pool.addObject(path1);  Set<Point> points = pool.getObjects(Point.class, Pattern.compile("Point.*"));  assertEquals(2, points.size()); assertTrue(points.contains(point1)); "<AssertPlaceHolder>"; }
contains(String objectName) { requireNonNull(objectName, "objectName");  return objectsByName.containsKey(objectName); }
[*] target: assertTrue(points.contains(point2))
[-] pred: org. junit. Assert. assertTrue ( points. contains ( point2 ) )
************************************
************************************
[+] input: shouldReturnObjectsByClass() { Point point1 = new Point("Point-00001"); pool.addObject(point1); Point point2 = new Point("Point-00002"); pool.addObject(point2); Path path1 = new Path("Path-00001", point1.getReference(), point2.getReference()); pool.addObject(path1);  Set<Point> points = pool.getObjects(Point.class);  assertEquals(2, points.size()); assertTrue(points.contains(point1)); "<AssertPlaceHolder>"; }
contains(String objectName) { requireNonNull(objectName, "objectName");  return objectsByName.containsKey(objectName); }
[*] target: assertTrue(points.contains(point2))
[-] pred: org. junit. Assert. assertTrue ( points. contains ( point2 ) )
************************************
************************************
[+] input: shouldReturnObjectsByPattern() { Point point1 = new Point("Point-00001"); pool.addObject(point1); Point point2 = new Point("Point-00002"); pool.addObject(point2); Point point3 = new Point("Punkt-00003"); pool.addObject(point3);  Set<Point> points = pool.getObjects(Point.class, Pattern.compile("Point.*"));  assertEquals(2, points.size()); assertTrue(points.contains(point1)); "<AssertPlaceHolder>"; }
contains(String objectName) { requireNonNull(objectName, "objectName");  return objectsByName.containsKey(objectName); }
[*] target: assertTrue(points.contains(point2))
[-] pred: org. junit. Assert. assertTrue ( points. contains ( point2 ) )
************************************
************************************
[+] input: shouldFilterNoTransportOrders() { Set<TransportOrderSelectionFilter> filters = new HashSet<>(Arrays.asList(new RefuseAllFilter(), new FilterIfTransportOrderNameContainsTransport(), new FilterIfTransportOrderNameContainsOrder())); transportOrderSelectionFilter = new CompositeTransportOrderSelectionFilter(filters);  long remainingTransportOrders = transportOrders.stream() .filter(order -> transportOrderSelectionFilter.apply(order).isEmpty()) .count();  "<AssertPlaceHolder>"; }
apply(TransportOrder order) { return filters.stream() .flatMap(filter -> filter.apply(order).stream()) .collect(Collectors.toList()); }
[*] target: assertEquals(0, remainingTransportOrders)
[-] pred: org. junit. Assert. assertEquals ( 0, remainingTransportOrders )
************************************
************************************
[+] input: shouldMergeDriveOrders() { DriveOrder orderA = createDriveOrder(10, "A", "B", "C", "D", "E", "F", "G"); DriveOrder orderB = createDriveOrder(10, "D", "H", "I", "J");  when(router.getCosts(any(Vehicle.class), any(Point.class), any(Point.class))).thenReturn(20L);  Route expected = createDriveOrder(20, "A", "B", "C", "D", "H", "I", "J").getRoute(); Route actual = rerouteUtil.mergeDriveOrders(orderA, orderB, new Vehicle("Vehicle")).getRoute();  "<AssertPlaceHolder>"; }
mergeDriveOrders(DriveOrder orderA, DriveOrder orderB, Vehicle vehicle) { // Merge the drive order routes Route mergedRoute = mergeRoutes(vehicle, orderA.getRoute(), orderB.getRoute());  DriveOrder mergedOrder = new DriveOrder(orderA.getDestination()) .withState(orderA.getState()) .withTransportOrder(orderA.getTransportOrder()) .withRoute(mergedRoute);  return mergedOrder; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldReturnFutureSteps() { List<DriveOrder> driveOrders = Arrays.asList(createDriveOrder(10, "A", "B", "C"), createDriveOrder(20, "C", "D", "E", "F", "G", "H"), createDriveOrder(20, "H", "I", "J", "K", "L")); TransportOrder transportOrder = new TransportOrder("TransportOrder", driveOrders) .withCurrentDriveOrderIndex(1); Vehicle vehicle = new Vehicle("Vehicle") .withTransportOrder(transportOrder.getReference());  VehicleController controller = mock(VehicleController.class); when(transportOrderService.fetchObject(TransportOrder.class, transportOrder.getReference())) .thenReturn(transportOrder); when(vehicleControllerPool.getVehicleController(vehicle.getName())).thenReturn(controller); when(controller.getCommandsSent()).thenReturn(commandsSentToVehicle(driveOrders));  List<String> expected = Arrays.asList("H", "I", "J", "K", "L"); List<String> actual = rerouteUtil.getFutureSteps(vehicle).stream() .map(step -> step.getDestinationPoint().getName()) .collect(Collectors.toList());  "<AssertPlaceHolder>"; }
getFutureSteps(Vehicle vehicle) { TCSObjectReference<TransportOrder> orderRef = vehicle.getTransportOrder(); if (orderRef == null) { LOG.debug("Vehicle {} isn't processing any order. Can't determine future steps.", vehicle.getName()); return new ArrayList<>(); }  TransportOrder order = transportOrderService.fetchObject(TransportOrder.class, orderRef); VehicleController controller = vehicleControllerPool.getVehicleController(vehicle.getName());  // Get the steps for the drive order the vehicle is currently processing // The transport order's drive orders and their routes can't be null at this point List<Step> currentSteps = order.getCurrentDriveOrder().getRoute().getSteps();  // If movement commands have been sent to the comm adapter, trim the current steps by these. // Movement commands may have not been sent to the comm adapter yet, i.e. if needed resources // are already allocated by another vehicle. if (!controller.getCommandsSent().isEmpty()) { List<MovementCommand> commandsSent = new ArrayList<>(controller.getCommandsSent()); MovementCommand lastCommandSent = commandsSent.get(commandsSent.size() - 1);  // Trim the current steps / Get the steps that haven't been sent to the comm adapter yet currentSteps = currentSteps.subList( currentSteps.indexOf(lastCommandSent.getStep()) + 1, currentSteps.size()); }  List<Step> futureSteps = new ArrayList<>(); futureSteps.addAll(currentSteps);  // Add the steps from all future drive orders order.getFutureDriveOrders().stream() .map(driveOrder -> driveOrder.getRoute()) .map(route -> route.getSteps()) .forEach(steps -> futureSteps.addAll(steps));  return futureSteps; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: returnsEmptyAllParkingPositionsOccupied() { Point point1 = new Point("vehicle's current position"); Point point2 = new Point("parking position occupied by another vehicle") .withType(Point.Type.PARK_POSITION) .withOccupyingVehicle(new Vehicle("another vehicle").getReference()); Point point3 = new Point("parking position occupied by yet another vehicle") .withType(Point.Type.PARK_POSITION) .withOccupyingVehicle(new Vehicle("yet another vehicle").getReference()); Vehicle vehicle = new Vehicle("vehicle") .withCurrentPosition(point1.getReference());  when(router.getTargetedPoints()).thenReturn(new HashSet<>()); when(plantModelService.fetchObjects(eq(Point.class), any())).thenReturn(setOf(point2, point3)); when(plantModelService.expandResources(Collections.singleton(point2.getReference()))) .thenReturn(Collections.singleton(point2)); when(plantModelService.expandResources(Collections.singleton(point3.getReference()))) .thenReturn(Collections.singleton(point3));  Set<Point> result = supplier.findUsableParkingPositions(vehicle); "<AssertPlaceHolder>"; }
findUsableParkingPositions(Vehicle vehicle) { // Find out which points are destination points of the current routes of // all vehicles, and keep them. (Multiple lookups ahead.) Set<Point> targetedPoints = getRouter().getTargetedPoints();  return fetchAllParkingPositions().stream() .filter(point -> isPointUnoccupiedFor(point, vehicle, targetedPoints)) .collect(Collectors.toSet()); }
[*] target: assertTrue(result.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( result. isEmpty ( ) )
************************************
************************************
[+] input: findExistingRechargePosition() { Point currentVehiclePoint = new Point("Current vehicle point") .withType(Point.Type.HALT_POSITION); Vehicle vehicle = new Vehicle("Some vehicle") .withRechargeOperation("Do some recharging") .withCurrentPosition(currentVehiclePoint.getReference());  Point locationAccessPoint = new Point("Location access point") .withType(Point.Type.HALT_POSITION);  LocationType rechargeLocType = new LocationType("Recharge location type") .withAllowedOperations(Collections.singletonList(vehicle.getRechargeOperation())); Location location = new Location("Recharge location", rechargeLocType.getReference());  Location.Link link = new Location.Link(location.getReference(), locationAccessPoint.getReference()); location = location.withAttachedLinks(new HashSet<>(Arrays.asList(link)));  locationAccessPoint = locationAccessPoint.withAttachedLinks(new HashSet<>(Arrays.asList(link)));  when(plantModelService.fetchObjects(Location.class)) .thenReturn(Collections.singleton(location)); when(plantModelService.fetchObject(LocationType.class, rechargeLocType.getReference())) .thenReturn(rechargeLocType); when(plantModelService.fetchObject(Point.class, currentVehiclePoint.getReference())) .thenReturn(currentVehiclePoint); when(plantModelService.fetchObject(Point.class, locationAccessPoint.getReference())) .thenReturn(locationAccessPoint);  rechargePosSupplier.initialize();  List<Destination> result = rechargePosSupplier.findRechargeSequence(vehicle); "<AssertPlaceHolder>"; assertThat(result, is(not(empty()))); }
findRechargeSequence(Vehicle vehicle) { requireNonNull(vehicle, "vehicle");  if (vehicle.getCurrentPosition() == null) { return new ArrayList<>(); }  Map<Location, Set<Point>> rechargeLocations = findLocationsForOperation(vehicle.getRechargeOperation(), vehicle, router.getTargetedPoints());  String assignedRechargeLocationName = vehicle.getProperty(PROPKEY_ASSIGNED_RECHARGE_LOCATION); if (assignedRechargeLocationName != null) { Location location = pickLocationWithName(assignedRechargeLocationName, rechargeLocations.keySet()); if (location == null) { return new ArrayList<>(); } // XXX Strictly, we should check whether there is a viable route to the location. return Arrays.asList(createDestination(location, vehicle.getRechargeOperation())); }  String preferredRechargeLocationName = vehicle.getProperty(PROPKEY_PREFERRED_RECHARGE_LOCATION); if (assignedRechargeLocationName != null) { Location location = pickLocationWithName(preferredRechargeLocationName, rechargeLocations.keySet()); if (location != null) { // XXX Strictly, we should check whether there is a viable route to the location. return Arrays.asList(createDestination(location, vehicle.getRechargeOperation())); } }  Location bestLocation = findCheapestLocation(rechargeLocations, vehicle); if (bestLocation != null) { return Arrays.asList(createDestination(bestLocation, vehicle.getRechargeOperation())); }  return new ArrayList<>(); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: shouldIgnoreTransportOrderWithUnlockedLocation() { Collection<String> result = filter.apply(transportOrderWithoutLockedLocation()); "<AssertPlaceHolder>"; }
apply(TransportOrder order) { return !lockedLocations(order) ? new ArrayList<>() : Arrays.asList(getClass().getName()); }
[*] target: assertTrue(result.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( result. isEmpty ( ) )
************************************
************************************
[+] input: shouldIgnoreTransportOrderWithPointDestination() { Collection<String> result = filter.apply(transportOrderWithPointDestination()); "<AssertPlaceHolder>"; }
apply(TransportOrder order) { return !lockedLocations(order) ? new ArrayList<>() : Arrays.asList(getClass().getName()); }
[*] target: assertTrue(result.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( result. isEmpty ( ) )
************************************
************************************
[+] input: returnEmptyRouteIfDestinationIsSource() { List<Step> steps = pointRouter.getRouteSteps(pointA, pointA); "<AssertPlaceHolder>"; assertThat(steps, is(empty())); }
getRouteSteps(Point srcPoint, Point destPoint) { requireNonNull(srcPoint, "srcPoint"); requireNonNull(destPoint, "destPoint");  long timeBefore = System.currentTimeMillis(); if (Objects.equals(srcPoint.getName(), destPoint.getName())) { return new ArrayList<>(); }  GraphPath<String, ModelEdge> graphPath = algo.getPath(srcPoint.getName(), destPoint.getName()); if (graphPath == null) { return null; }  List<Route.Step> result = translateToSteps(graphPath);  LOG.debug("Looking up route from {} to {} took {} milliseconds.", srcPoint.getName(), destPoint.getName(), System.currentTimeMillis() - timeBefore);  return result; }
[*] target: assertNotNull(steps)
[-] pred: org. junit. Assert. assertNotNull ( steps )
************************************
************************************
[+] input: returnGraphPathStepsForExistingRoute() { List<Step> steps = pointRouter.getRouteSteps(pointA, pointC); "<AssertPlaceHolder>"; assertThat(steps, is(not(empty()))); }
getRouteSteps(Point srcPoint, Point destPoint) { requireNonNull(srcPoint, "srcPoint"); requireNonNull(destPoint, "destPoint");  long timeBefore = System.currentTimeMillis(); if (Objects.equals(srcPoint.getName(), destPoint.getName())) { return new ArrayList<>(); }  GraphPath<String, ModelEdge> graphPath = algo.getPath(srcPoint.getName(), destPoint.getName()); if (graphPath == null) { return null; }  List<Route.Step> result = translateToSteps(graphPath);  LOG.debug("Looking up route from {} to {} took {} milliseconds.", srcPoint.getName(), destPoint.getName(), System.currentTimeMillis() - timeBefore);  return result; }
[*] target: assertNotNull(steps)
[-] pred: org. junit. Assert. assertNotNull ( steps )
************************************
************************************
[+] input: testCreateWithConfigurationSucceeds() { MetricConfiguration configuration = MetricConfiguration.builder() .setProjectId(aProjectId) .setCredentials(aFakeCredential) .build(); MetricExporter exporter = GoogleCloudMetricExporter.createWithConfiguration(configuration); "<AssertPlaceHolder>"; }
createWithConfiguration(MetricConfiguration configuration) { return new GoogleCloudMetricExporter(configuration); }
[*] target: assertNotNull(exporter)
[-] pred: org. junit. Assert. assertNotNull ( exporter )
************************************
************************************
[+] input: IOException { try (MockedStatic<MetricServiceClient> mockedServiceClientClass = mockStatic(MetricServiceClient.class)) { MetricServiceSettings.Builder builder = MetricServiceSettings.newBuilder(); builder .setCredentialsProvider(FixedCredentialsProvider.create(aFakeCredential)) .setEndpoint(MetricConfiguration.DEFAULT_METRIC_SERVICE_ENDPOINT) .createMetricDescriptorSettings() .setSimpleTimeoutNoRetries( Duration.ofMillis(MetricConfiguration.DEFAULT_DEADLINE.toMillis())); MetricServiceSettings serviceSettings = builder.build();  MetricConfiguration configuration = MetricConfiguration.builder() .setProjectId(aProjectId) .setMetricServiceEndpoint("https://fake-endpoint") .setInsecureEndpoint(true) .setCredentials(null) .setMetricServiceSettings(serviceSettings) .setDescriptorStrategy(MetricDescriptorStrategy.SEND_ONCE) .build(); assertNotNull(configuration.getMetricServiceSettings());  // Mock the static method to create a MetricServiceClient to return a mocked object mockedServiceClientClass .when(() -> MetricServiceClient.create(eq(configuration.getMetricServiceSettings()))) .thenReturn(mockMetricServiceClient);  MetricExporter exporter = InternalMetricExporter.createWithConfiguration(configuration); "<AssertPlaceHolder>";  // verify that the MetricServiceClient used in the exporter was created using the // MetricServiceSettings provided in configuration mockedServiceClientClass.verify( times(1), () -> MetricServiceClient.create(eq(configuration.getMetricServiceSettings())));  // verify that export operation on the resulting exporter can still be called CompletableResultCode result = exporter.export(ImmutableList.of(aMetricData, aHistogram)); assertTrue(result.isSuccess());  // verify that the CreateTimeseries call was invoked on the client generated from the supplied // MetricServiceSettings object verify(mockMetricServiceClient, times(1)) .createTimeSeries(projectNameArgCaptor.capture(), timeSeriesArgCaptor.capture()); } }
createWithConfiguration(MetricConfiguration configuration) { return new GoogleCloudMetricExporter(configuration); }
[*] target: assertNotNull(exporter)
[-] pred: org. junit. Assert. assertNotNull ( exporter )
************************************
************************************
[+] input: verifyExporterWorksWithDefaultConfiguration() { try (MockedStatic<ServiceOptions> mockedServiceOptions = Mockito.mockStatic(ServiceOptions.class); MockedStatic<MetricServiceClient> mockedMetricServiceClient = Mockito.mockStatic(MetricServiceClient.class); MockedStatic<GoogleCredentials> mockedGoogleCredentials = Mockito.mockStatic(GoogleCredentials.class)) { mockedServiceOptions.when(ServiceOptions::getDefaultProjectId).thenReturn(PROJECT_ID); mockedMetricServiceClient .when(() -> MetricServiceClient.create(Mockito.any(MetricServiceSettings.class))) .thenReturn(this.mockMetricServiceClient); mockedGoogleCredentials .when(GoogleCredentials::getApplicationDefault) .thenReturn(Mockito.mock(GoogleCredentials.class));  MetricExporter metricExporter = GoogleCloudMetricExporter.createWithDefaultConfiguration(); "<AssertPlaceHolder>"; generateOpenTelemetryUsingGoogleCloudMetricExporter(metricExporter); simulateExport(metricExporter);  mockedMetricServiceClient.verify( Mockito.times(1), () -> MetricServiceClient.create((MetricServiceSettings) Mockito.any())); mockedServiceOptions.verify(Mockito.times(1), ServiceOptions::getDefaultProjectId); Mockito.verify(this.mockMetricServiceClient) .createTimeSeries((ProjectName) Mockito.any(), Mockito.anyList()); } finally { GlobalOpenTelemetry.resetForTest(); } }
createWithDefaultConfiguration() { return new GoogleCloudMetricExporter(MetricConfiguration.builder().build()); }
[*] target: assertNotNull(metricExporter)
[-] pred: org. junit. Assert. assertNotNull ( metricExporter )
************************************
************************************
[+] input: testSetAllConfigurationFieldsSucceeds() { Predicate<AttributeKey<?>> allowAllPredicate = attributeKey -> true; MonitoredResourceDescription customMRMapping = new MonitoredResourceDescription("custom_mr", Set.of("instance_id", "foo_bar", "host_id"));  MetricConfiguration configuration = MetricConfiguration.builder() .setProjectId(PROJECT_ID) .setCredentials(FAKE_CREDENTIALS) .setResourceAttributesFilter(allowAllPredicate) .setMonitoredResourceDescription(customMRMapping) .setUseServiceTimeSeries(true) .build();  assertEquals(FAKE_CREDENTIALS, configuration.getCredentials()); assertEquals(PROJECT_ID, configuration.getProjectId()); assertEquals(allowAllPredicate, configuration.getResourceAttributesFilter()); assertEquals(customMRMapping, configuration.getMonitoredResourceDescription()); "<AssertPlaceHolder>"; }
getUseServiceTimeSeries();  /** * Returns the custom {@link MonitoredResourceDescription}
[*] target: assertTrue(configuration.getUseServiceTimeSeries())
[-] pred: org. junit. Assert. assertTrue ( configuration. getUseServiceTimeSeries ( ) )
************************************
************************************
[+] input: testMapMetricWithWierdAttributeNameSucceeds() { String type = DEFAULT_PREFIX + "/" + anInstrumentationLibraryInfo.getName(); Attributes attributes = io.opentelemetry.api.common.Attributes.of(stringKey("test.bad"), "value"); Metric expectedMetric = Metric.newBuilder().setType(type).putLabels("test_bad", "value").build(); Metric actualMetric = MetricTranslator.mapMetric(attributes, type); "<AssertPlaceHolder>"; }
mapMetric(Attributes attributes, String type) { Metric.Builder metricBuilder = Metric.newBuilder().setType(type); attributes.forEach( (key, value) -> metricBuilder.putLabels(cleanAttributeKey(key.getKey()), value.toString())); return metricBuilder.build(); }
[*] target: assertEquals(expectedMetric, actualMetric)
[-] pred: org. junit. Assert. assertEquals ( expectedMetric, actualMetric )
************************************
************************************
[+] input: testMapMetricDescriptorWithInvalidMetricKindReturnsNull() { String name = "Metric Name"; String description = "Metric Description"; String unit = "ns"; MetricData metricData = ImmutableMetricData.createDoubleSummary( aGceResource, anInstrumentationLibraryInfo, name, description, unit, ImmutableSummaryData.create(ImmutableList.of(aDoubleSummaryPoint)));  MetricDescriptor actualDescriptor = MetricTranslator.mapMetricDescriptor( DEFAULT_PREFIX, metricData, aLongPoint, Attributes.empty()); "<AssertPlaceHolder>"; }
mapMetricDescriptor( String prefix, MetricData metric, io.opentelemetry.sdk.metrics.data.PointData metricPoint, Attributes extraLabels) { MetricDescriptor.Builder builder = MetricDescriptor.newBuilder() .setDisplayName(metric.getName()) .setDescription(metric.getDescription()) .setType(mapMetricType(metric.getName(), prefix)) .setUnit(metric.getUnit()); // add extra labels if any extraLabels.forEach((key, value) -> builder.addLabels(mapAttribute(key, prefix))); metricPoint .getAttributes() .forEach((key, value) -> builder.addLabels(mapAttribute(key, prefix)));  MetricDataType metricType = metric.getType(); switch (metricType) { case LONG_GAUGE: builder.setMetricKind(MetricDescriptor.MetricKind.GAUGE); builder.setValueType(MetricDescriptor.ValueType.INT64); return builder.build(); case DOUBLE_GAUGE: builder.setMetricKind(MetricDescriptor.MetricKind.GAUGE); builder.setValueType(MetricDescriptor.ValueType.DOUBLE); return builder.build(); case LONG_SUM: builder.setValueType(MetricDescriptor.ValueType.INT64); return fillSumType(metric.getLongSumData(), builder); case DOUBLE_SUM: builder.setValueType(MetricDescriptor.ValueType.DOUBLE); return fillSumType(metric.getDoubleSumData(), builder); case HISTOGRAM: return fillHistogramType(metric.getHistogramData(), builder); default: logger.error( "Metric type {} not supported. Only gauge and cumulative types are supported.", metricType); } return null; }
[*] target: assertNull(actualDescriptor)
[-] pred: org. junit. Assert. assertNull ( actualDescriptor )
************************************
************************************
[+] input: testMapConstantLabelWithStringValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(stringKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.STRING).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel )
************************************
************************************
[+] input: testMapConstantLabelWithBooleanValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(booleanKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.BOOL).build(); assertEquals(expectedLabel, actualLabel);  LabelDescriptor actualLabel2 = MetricTranslator.mapAttribute(booleanKey("label1"), CUSTOM_PREFIX); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel2)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel2 )
************************************
************************************
[+] input: testMapConstantLabelWithLongValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(longKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.INT64).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel )
************************************
************************************
[+] input: testMapLabelWithPeriodInNameSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(longKey("label.test"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label_test").setValueType(ValueType.INT64).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel )
************************************
************************************
[+] input: test_AFFILIATIONS_UPDATE() { // Test AFFILIATIONS_UPDATE Set<ScopePathType> combined = ScopePathType.AFFILIATIONS_UPDATE.combined(); "<AssertPlaceHolder>"; assertTrue(combined.contains(ScopePathType.AFFILIATIONS_UPDATE)); assertTrue(combined.contains(ScopePathType.READ_PUBLIC)); }
combined() { return combined; }
[*] target: assertEquals(2, combined.size())
[-] pred: org. junit. Assert. assertEquals ( 2, combined. size ( ) )
************************************
************************************
[+] input: testGetStepAndSectionIdentifier1() { Element procedureEl = TestUtils.stringToXom( "<PROCEDURE>" + "<NN-EXAMPLE>Example</NN-EXAMPLE>" + "<CD>3</CD>" + "<COLON>:</COLON>" + "<NN-METHOD>Step</NN-METHOD>" + "<CD>2</CD>" + "</PROCEDURE>"); SectionAndStepIdentifier sectionAndStepIdentifier = parser.getSectionAndStepIdentifier(procedureEl); "<AssertPlaceHolder>"; assertEquals("3", sectionAndStepIdentifier.getSectionIdentifier()); assertEquals("2", sectionAndStepIdentifier.getStepIdentifier()); }
getSectionAndStepIdentifier(Element procedureEl) { List<Element> stepIdentifiers = XomUtils.getDescendantElementsWithTagNames(procedureEl, new String[]{NN_IDENTIFIER, CD, CD_ALPHANUM}); if (stepIdentifiers.size() == 1){ Element stepIdentifier = stepIdentifiers.get(0); if (isSectionIdentifier(stepIdentifier)){ return new SectionAndStepIdentifier(stepIdentifier.getValue(), null); } else{ String sectionIdentifier = getSectionIdentifier(experimentalSection.getProcedureElement()); return new SectionAndStepIdentifier(sectionIdentifier, stepIdentifier.getValue()); } } if (stepIdentifiers.size() == 2){ boolean firstIsSectionIdentifier = isSectionIdentifier(stepIdentifiers.get(0)); boolean secondIsSectionIdentifier = isSectionIdentifier(stepIdentifiers.get(1)); if (firstIsSectionIdentifier && !secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(0).getValue(), stepIdentifiers.get(1).getValue()); } if (!firstIsSectionIdentifier && secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(1).getValue(), stepIdentifiers.get(0).getValue()); } if (!firstIsSectionIdentifier && !secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(0).getValue(), stepIdentifiers.get(1).getValue()); } //both being section identifiers is not intentionally not interpretable } return null; }
[*] target: assertNotNull(sectionAndStepIdentifier)
[-] pred: org. junit. Assert. assertNotNull ( sectionAndStepIdentifier )
************************************
************************************
[+] input: testGetStepAndSectionIdentifier2() { Element procedureEl = TestUtils.stringToXom( "<PROCEDURE>" + "<NN-EXAMPLE>Example</NN-EXAMPLE>" + "<CD>3</CD>" + "</PROCEDURE>"); SectionAndStepIdentifier sectionAndStepIdentifier = parser.getSectionAndStepIdentifier(procedureEl); "<AssertPlaceHolder>"; assertEquals("3", sectionAndStepIdentifier.getSectionIdentifier()); assertEquals(null, sectionAndStepIdentifier.getStepIdentifier()); }
getSectionAndStepIdentifier(Element procedureEl) { List<Element> stepIdentifiers = XomUtils.getDescendantElementsWithTagNames(procedureEl, new String[]{NN_IDENTIFIER, CD, CD_ALPHANUM}); if (stepIdentifiers.size() == 1){ Element stepIdentifier = stepIdentifiers.get(0); if (isSectionIdentifier(stepIdentifier)){ return new SectionAndStepIdentifier(stepIdentifier.getValue(), null); } else{ String sectionIdentifier = getSectionIdentifier(experimentalSection.getProcedureElement()); return new SectionAndStepIdentifier(sectionIdentifier, stepIdentifier.getValue()); } } if (stepIdentifiers.size() == 2){ boolean firstIsSectionIdentifier = isSectionIdentifier(stepIdentifiers.get(0)); boolean secondIsSectionIdentifier = isSectionIdentifier(stepIdentifiers.get(1)); if (firstIsSectionIdentifier && !secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(0).getValue(), stepIdentifiers.get(1).getValue()); } if (!firstIsSectionIdentifier && secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(1).getValue(), stepIdentifiers.get(0).getValue()); } if (!firstIsSectionIdentifier && !secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(0).getValue(), stepIdentifiers.get(1).getValue()); } //both being section identifiers is not intentionally not interpretable } return null; }
[*] target: assertNotNull(sectionAndStepIdentifier)
[-] pred: org. junit. Assert. assertNotNull ( sectionAndStepIdentifier )
************************************
************************************
[+] input: IOException { ExperimentalSectionsCreator sectionCreator = new ExperimentalSectionsCreator(new ArrayList<Element>()); Document taggedDoc = Utils.buildXmlFromString("<Document><Sentence><NounPhrase><UNNAMEDMOLECULE><REFERENCETOCOMPOUND></REFERENCETOCOMPOUND></UNNAMEDMOLECULE><MOLECULE></MOLECULE></NounPhrase><STOP>.</STOP></Sentence></Document>"); Element heading = sectionCreator.findAndDetachHiddenHeadingContent(taggedDoc); "<AssertPlaceHolder>"; assertEquals(2, heading.getChildElements().size()); assertEquals(0, taggedDoc.getRootElement().getFirstChildElement("Sentence").getChildElements().size()); }
findAndDetachHiddenHeadingContent(Document taggedDoc) { Element firstSentence = taggedDoc.getRootElement().getFirstChildElement(SENTENCE_Container); Element heading = null; if (firstSentence != null){ List<Element> elementsToConsider = expandActionPhrases(firstSentence.getChildElements()); if (elementsToConsider.size() >= 1){ Element firstPhrase =elementsToConsider.get(0); if (firstPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(firstPhrase)){ if (elementsToConsider.size() >= 2){ Element secondPhrase = elementsToConsider.get(1); if (isPeriodOrSemiColonOrColon(secondPhrase)){ heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); detachElementAndEmptySentenceAndActionPhraseParents(secondPhrase); heading.appendChild(firstPhrase); heading.appendChild(secondPhrase); if(elementsToConsider.size() >= 4){ Element thirdPhrase = elementsToConsider.get(2); Element fourthPhrase = elementsToConsider.get(3); if (thirdPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(thirdPhrase) && isPeriodOrSemiColonOrColon(fourthPhrase)){ detachElementAndEmptySentenceAndActionPhraseParents(thirdPhrase); detachElementAndEmptySentenceAndActionPhraseParents(fourthPhrase); heading.appendChild(thirdPhrase); heading.appendChild(fourthPhrase); } } } } else{//a sentence which is just a heading e.g. "3)" heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); heading.appendChild(firstPhrase); } } } } return heading; }
[*] target: assertNotNull(heading)
[-] pred: org. junit. Assert. assertNotNull ( heading )
************************************
************************************
[+] input: IOException { ExperimentalSectionsCreator sectionCreator = new ExperimentalSectionsCreator(new ArrayList<Element>()); Document taggedDoc = Utils.buildXmlFromString("<Document><Sentence><NounPhrase><MOLECULE></MOLECULE></NounPhrase><COLON>:</COLON></Sentence></Document>"); Element heading = sectionCreator.findAndDetachHiddenHeadingContent(taggedDoc); "<AssertPlaceHolder>"; assertEquals(2, heading.getChildElements().size()); assertEquals(0, taggedDoc.getRootElement().getFirstChildElement("Sentence").getChildElements().size()); }
findAndDetachHiddenHeadingContent(Document taggedDoc) { Element firstSentence = taggedDoc.getRootElement().getFirstChildElement(SENTENCE_Container); Element heading = null; if (firstSentence != null){ List<Element> elementsToConsider = expandActionPhrases(firstSentence.getChildElements()); if (elementsToConsider.size() >= 1){ Element firstPhrase =elementsToConsider.get(0); if (firstPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(firstPhrase)){ if (elementsToConsider.size() >= 2){ Element secondPhrase = elementsToConsider.get(1); if (isPeriodOrSemiColonOrColon(secondPhrase)){ heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); detachElementAndEmptySentenceAndActionPhraseParents(secondPhrase); heading.appendChild(firstPhrase); heading.appendChild(secondPhrase); if(elementsToConsider.size() >= 4){ Element thirdPhrase = elementsToConsider.get(2); Element fourthPhrase = elementsToConsider.get(3); if (thirdPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(thirdPhrase) && isPeriodOrSemiColonOrColon(fourthPhrase)){ detachElementAndEmptySentenceAndActionPhraseParents(thirdPhrase); detachElementAndEmptySentenceAndActionPhraseParents(fourthPhrase); heading.appendChild(thirdPhrase); heading.appendChild(fourthPhrase); } } } } else{//a sentence which is just a heading e.g. "3)" heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); heading.appendChild(firstPhrase); } } } } return heading; }
[*] target: assertNotNull(heading)
[-] pred: org. junit. Assert. assertNotNull ( heading )
************************************
************************************
[+] input: IOException { ExperimentalSectionsCreator sectionCreator = new ExperimentalSectionsCreator(new ArrayList<Element>()); Document taggedDoc = Utils.buildXmlFromString("<Document><Sentence><NounPhrase><UNNAMEDMOLECULE><NN-CHEMENTITY>Reagent</NN-CHEMENTITY><REFERENCETOCOMPOUND><CD>7</CD></REFERENCETOCOMPOUND></UNNAMEDMOLECULE><CC>and</CC><MOLECULE><OSCARCM><OSCAR-CM>dichloromethane</OSCAR-CM></OSCARCM></MOLECULE></NounPhrase></Sentence></Document>"); Element heading = sectionCreator.findAndDetachHiddenHeadingContent(taggedDoc); "<AssertPlaceHolder>"; }
findAndDetachHiddenHeadingContent(Document taggedDoc) { Element firstSentence = taggedDoc.getRootElement().getFirstChildElement(SENTENCE_Container); Element heading = null; if (firstSentence != null){ List<Element> elementsToConsider = expandActionPhrases(firstSentence.getChildElements()); if (elementsToConsider.size() >= 1){ Element firstPhrase =elementsToConsider.get(0); if (firstPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(firstPhrase)){ if (elementsToConsider.size() >= 2){ Element secondPhrase = elementsToConsider.get(1); if (isPeriodOrSemiColonOrColon(secondPhrase)){ heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); detachElementAndEmptySentenceAndActionPhraseParents(secondPhrase); heading.appendChild(firstPhrase); heading.appendChild(secondPhrase); if(elementsToConsider.size() >= 4){ Element thirdPhrase = elementsToConsider.get(2); Element fourthPhrase = elementsToConsider.get(3); if (thirdPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(thirdPhrase) && isPeriodOrSemiColonOrColon(fourthPhrase)){ detachElementAndEmptySentenceAndActionPhraseParents(thirdPhrase); detachElementAndEmptySentenceAndActionPhraseParents(fourthPhrase); heading.appendChild(thirdPhrase); heading.appendChild(fourthPhrase); } } } } else{//a sentence which is just a heading e.g. "3)" heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); heading.appendChild(firstPhrase); } } } } return heading; }
[*] target: assertNull(heading)
[-] pred: org. junit. Assert. assertNull ( heading )
************************************
************************************
[+] input: IOException { ExperimentalSectionsCreator sectionCreator = new ExperimentalSectionsCreator(new ArrayList<Element>()); Document taggedDoc = Utils.buildXmlFromString("<Document><Sentence><NounPhrase><PROCEDURE></PROCEDURE></NounPhrase><COLON>:</COLON><NounPhrase><MOLECULE></MOLECULE></NounPhrase><STOP>.</STOP></Sentence></Document>"); Element heading = sectionCreator.findAndDetachHiddenHeadingContent(taggedDoc); "<AssertPlaceHolder>"; assertEquals(4, heading.getChildElements().size()); assertEquals(0, taggedDoc.getRootElement().getFirstChildElement("Sentence").getChildElements().size()); }
findAndDetachHiddenHeadingContent(Document taggedDoc) { Element firstSentence = taggedDoc.getRootElement().getFirstChildElement(SENTENCE_Container); Element heading = null; if (firstSentence != null){ List<Element> elementsToConsider = expandActionPhrases(firstSentence.getChildElements()); if (elementsToConsider.size() >= 1){ Element firstPhrase =elementsToConsider.get(0); if (firstPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(firstPhrase)){ if (elementsToConsider.size() >= 2){ Element secondPhrase = elementsToConsider.get(1); if (isPeriodOrSemiColonOrColon(secondPhrase)){ heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); detachElementAndEmptySentenceAndActionPhraseParents(secondPhrase); heading.appendChild(firstPhrase); heading.appendChild(secondPhrase); if(elementsToConsider.size() >= 4){ Element thirdPhrase = elementsToConsider.get(2); Element fourthPhrase = elementsToConsider.get(3); if (thirdPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(thirdPhrase) && isPeriodOrSemiColonOrColon(fourthPhrase)){ detachElementAndEmptySentenceAndActionPhraseParents(thirdPhrase); detachElementAndEmptySentenceAndActionPhraseParents(fourthPhrase); heading.appendChild(thirdPhrase); heading.appendChild(fourthPhrase); } } } } else{//a sentence which is just a heading e.g. "3)" heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); heading.appendChild(firstPhrase); } } } } return heading; }
[*] target: assertNotNull(heading)
[-] pred: org. junit. Assert. assertNotNull ( heading )
************************************
************************************
[+] input: IOException { ExperimentalSectionsCreator sectionCreator = new ExperimentalSectionsCreator(new ArrayList<Element>()); Document taggedDoc = Utils.buildXmlFromString("<Document><Sentence><NounPhrase><PROCEDURE><NN-EXAMPLE>Example</NN-EXAMPLE><CD>3</CD></PROCEDURE></NounPhrase><STOP>.</STOP></Sentence><Sentence><NounPhrase></NounPhrase><STOP></STOP></Sentence></Document>"); Element heading = sectionCreator.findAndDetachHiddenHeadingContent(taggedDoc); "<AssertPlaceHolder>"; assertEquals(2, heading.getChildElements().size()); assertEquals(0, taggedDoc.getRootElement().getFirstChildElement("Sentence").getChildElements().size()); assertEquals(2, taggedDoc.getRootElement().getChildElements("Sentence").size()); }
findAndDetachHiddenHeadingContent(Document taggedDoc) { Element firstSentence = taggedDoc.getRootElement().getFirstChildElement(SENTENCE_Container); Element heading = null; if (firstSentence != null){ List<Element> elementsToConsider = expandActionPhrases(firstSentence.getChildElements()); if (elementsToConsider.size() >= 1){ Element firstPhrase =elementsToConsider.get(0); if (firstPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(firstPhrase)){ if (elementsToConsider.size() >= 2){ Element secondPhrase = elementsToConsider.get(1); if (isPeriodOrSemiColonOrColon(secondPhrase)){ heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); detachElementAndEmptySentenceAndActionPhraseParents(secondPhrase); heading.appendChild(firstPhrase); heading.appendChild(secondPhrase); if(elementsToConsider.size() >= 4){ Element thirdPhrase = elementsToConsider.get(2); Element fourthPhrase = elementsToConsider.get(3); if (thirdPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(thirdPhrase) && isPeriodOrSemiColonOrColon(fourthPhrase)){ detachElementAndEmptySentenceAndActionPhraseParents(thirdPhrase); detachElementAndEmptySentenceAndActionPhraseParents(fourthPhrase); heading.appendChild(thirdPhrase); heading.appendChild(fourthPhrase); } } } } else{//a sentence which is just a heading e.g. "3)" heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); heading.appendChild(firstPhrase); } } } } return heading; }
[*] target: assertNotNull(heading)
[-] pred: org. junit. Assert. assertNotNull ( heading )
************************************
************************************
[+] input: IOException { String binaryFile = "laptop.bin"; Laptop laptop1 = new Generator().NewLaptop();  Serializer serializer = new Serializer(); serializer.WriteBinaryFile(laptop1, binaryFile);  Laptop laptop2 = serializer.ReadBinaryFile(binaryFile); Assert."<AssertPlaceHolder>"; }
ReadBinaryFile(String filename) throws IOException { FileInputStream inStream = new FileInputStream(filename); Laptop laptop = Laptop.parseFrom(inStream); inStream.close(); return laptop; }
[*] target: assertEquals(laptop1, laptop2)
[-] pred: org. junit. Assert. assertEquals ( laptop1, laptop2 )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test1234"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeAll(null, createSchemaSql, false, false, false); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("plugin_test1"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeOneUpdate(null, createSchemaSql); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test123"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeAll(null, createSchemaSql, false, false, false); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test123"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(CREATE_SCHEMA, schema); this.executeOneUpdate(null, createSchemaSql); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: testGetById() { try (SqlSession sqlSession = getSqlSession()) { RoleBaseMapper roleMapper = sqlSession.getMapper(RoleBaseMapper.class); Role role = roleMapper.getById(1L); Assert.assertNotNull(role); Assert.assertEquals("男主角", role.getName());  role = roleMapper.getById(2L); Assert.assertNotNull(role);  role = roleMapper.getById(3L); Assert."<AssertPlaceHolder>"; } }
getById(ID id);
[*] target: assertNotNull(role)
[-] pred: org. junit. Assert. assertNotNull ( role )
************************************
************************************
[+] input: testGetById() { try (SqlSession sqlSession = getSqlSession()) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.getById(1L); Assert."<AssertPlaceHolder>"; Assert.assertEquals("张无忌", user.getUsername()); Assert.assertEquals("男", user.getSex()); Assert.assertEquals("明教", user.getAddress().get(0)); Assert.assertEquals("教主", user.getAddress().get(1)); } }
getById(Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: ExpressionException { graalJsExpressionHandler.evaluateExpression("var list;", pugModel); Object list = pugModel.get("list"); "<AssertPlaceHolder>"; }
public Object evaluateExpression(String expression, PugModel model) throws ExpressionException { Context context = contextThreadLocal.get(); Map<String,Value> cache = cacheThreadLocal.get(); //        context.enter(); try{ saveLocalVariableName(expression, model); Value jsContextBindings = context.getBindings("js"); for (Map.Entry<String, Object> objectEntry : model.entrySet()) { String key = objectEntry.getKey(); if(!PugModel.LOCAL_VARS.equals(key)) { jsContextBindings.putMember(key, objectEntry.getValue()); } }  Source js; Value eval = cache.get(expression); if(eval==null){ if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } eval = context.parse(js); cache.put(expression,eval); } eval = eval.execute(); Set<String> memberKeys = jsContextBindings.getMemberKeys(); for (String memberKey : memberKeys) { if (model.knowsKey(memberKey)){ if (!memberKey.startsWith(PUG4J_MODEL_PREFIX)) { Value member = jsContextBindings.getMember(memberKey); model.put(memberKey, member.as(Object.class)); try { jsContextBindings.removeMember(memberKey); }catch(UnsupportedOperationException e){ //                            e.printStackTrace(); jsContextBindings.putMember(memberKey, null); } } } } return eval.as(Object.class); } catch (Exception ex){ if(ex.getMessage()!=null && ex.getMessage().startsWith("ReferenceError:")){ return null; } throw new ExpressionException(expression, ex); }finally { //            context.leave(); } }  @Override public String evaluateStringExpression(String expression, PugModel model) throws ExpressionException { Object result = evaluateExpression(expression, model); return result == null ? "" : result.toString(); }  @Override public void assertExpression(String expression) throws ExpressionException { Context context = contextThreadLocal.get(); Source js; if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } try { Value parse = context.eval(js); }catch(PolyglotException e){ if(e.getMessage().startsWith("SyntaxError:")){ throw new ExpressionException(e.getMessage()); } } }  @Override public void setCache(boolean cache) {  }  @Override public void clearCache() {  } public Context getContext(){ return contextThreadLocal.get(); } }
[*] target: assertNull(list)
[-] pred: org. junit. Assert. assertNull ( list )
************************************
************************************
[+] input: ExpressionException { graalJsExpressionHandler.evaluateExpression("var what = true", pugModel); boolean what = (boolean) pugModel.get("what"); "<AssertPlaceHolder>"; }
public Object evaluateExpression(String expression, PugModel model) throws ExpressionException { Context context = contextThreadLocal.get(); Map<String,Value> cache = cacheThreadLocal.get(); //        context.enter(); try{ saveLocalVariableName(expression, model); Value jsContextBindings = context.getBindings("js"); for (Map.Entry<String, Object> objectEntry : model.entrySet()) { String key = objectEntry.getKey(); if(!PugModel.LOCAL_VARS.equals(key)) { jsContextBindings.putMember(key, objectEntry.getValue()); } }  Source js; Value eval = cache.get(expression); if(eval==null){ if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } eval = context.parse(js); cache.put(expression,eval); } eval = eval.execute(); Set<String> memberKeys = jsContextBindings.getMemberKeys(); for (String memberKey : memberKeys) { if (model.knowsKey(memberKey)){ if (!memberKey.startsWith(PUG4J_MODEL_PREFIX)) { Value member = jsContextBindings.getMember(memberKey); model.put(memberKey, member.as(Object.class)); try { jsContextBindings.removeMember(memberKey); }catch(UnsupportedOperationException e){ //                            e.printStackTrace(); jsContextBindings.putMember(memberKey, null); } } } } return eval.as(Object.class); } catch (Exception ex){ if(ex.getMessage()!=null && ex.getMessage().startsWith("ReferenceError:")){ return null; } throw new ExpressionException(expression, ex); }finally { //            context.leave(); } }  @Override public String evaluateStringExpression(String expression, PugModel model) throws ExpressionException { Object result = evaluateExpression(expression, model); return result == null ? "" : result.toString(); }  @Override public void assertExpression(String expression) throws ExpressionException { Context context = contextThreadLocal.get(); Source js; if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } try { Value parse = context.eval(js); }catch(PolyglotException e){ if(e.getMessage().startsWith("SyntaxError:")){ throw new ExpressionException(e.getMessage()); } } }  @Override public void setCache(boolean cache) {  }  @Override public void clearCache() {  } public Context getContext(){ return contextThreadLocal.get(); } }
[*] target: assertTrue(what)
[-] pred: org. junit. Assert. assertTrue ( what )
************************************
************************************
[+] input: Exception {  Boolean aBoolean = jexlExpressionHandler.evaluateBooleanExpression("1<5", pugModel); "<AssertPlaceHolder>"; }
evaluateBooleanExpression(String expression, PugModel model) throws ExpressionException { return BooleanUtil.convert(evaluateExpression(expression, model)); }
[*] target: assertTrue(aBoolean)
[-] pred: org. junit. Assert. assertTrue ( aBoolean )
************************************
************************************
[+] input: URISyntaxException { PugConfiguration config = new PugConfiguration(); config.setTemplateLoader(new FileTemplateLoader(TestFileHelper.getRootResourcePath() + "/parser/", "jade")); PugTemplate template = config.getTemplate("assignment"); "<AssertPlaceHolder>"; }
getTemplate(String name) throws IOException, PugException { if (caching) { long lastModified = templateLoader.getLastModified(name); PugTemplate template = cache.get(getKeyValue(name, lastModified)); if (template != null) { return template; }  String key = getCachedKey(name, lastModified); synchronized (key) { PugTemplate newTemplate = createTemplate(name); cache.put(key, newTemplate); return newTemplate; } }  return createTemplate(name); }
[*] target: assertNotNull(template)
[-] pred: org. junit. Assert. assertNotNull ( template )
************************************
************************************
[+] input: IOException { Reader reader = new StringReader("Hello #{foo}!"); ReaderTemplateLoader templateLoader = new ReaderTemplateLoader(reader, "template");  Reader readerResult = templateLoader.getReader("template");  "<AssertPlaceHolder>"; }
getReader(String name) throws IOException { checkName(name); return reader; }
[*] target: assertEquals(reader, readerResult)
[-] pred: org. junit. Assert. assertEquals ( reader, readerResult )
************************************
************************************
[+] input: emptyListShouldNotFail() { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(new ArrayList<>(), null, null, null); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now); } }
[*] target: assertNull(theException)
[-] pred: org. junit. Assert. assertNull ( theException )
************************************
************************************
[+] input: Exception { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(null, null, null, null); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now); } }
[*] target: assertNull(theException)
[-] pred: org. junit. Assert. assertNull ( theException )
************************************
************************************
[+] input: failedConsensusMessage() { ConsensusEventMessage msg1 = new ConsensusEventMessage(); "<AssertPlaceHolder>"; }
getConsensusMessage() { ConsensusEvent event = consensusMessageInternal(); if (event == null) { throw new IllegalStateException("No consensus message."); } return event; }
[*] target: assertNotNull(msg1.getConsensusMessage())
[-] pred: org. junit. Assert. assertNotNull ( msg1. getConsensusMessage ( ) )
************************************
************************************
[+] input: test_atom_content_transformation_to_byte_array_and_back() { LedgerHeader ledgerHeader = LedgerHeader.genesis(HashUtils.zero256(), null); VerifiedLedgerHeaderAndProof proof = new VerifiedLedgerHeaderAndProof( new BFTHeader(View.of(1), HashUtils.random256(), ledgerHeader), new BFTHeader(View.of(1), HashUtils.random256(), ledgerHeader), 1L, HashUtils.random256(), ledgerHeader, new TimestampedECDSASignatures() ); StoredCommittedCommand committedCommand = new StoredCommittedCommand( new Command(new byte[] {0, 1, 2, 3}), proof );  byte[] serializedCommand = commandToBinaryConverter.toLedgerEntryContent(committedCommand); StoredCommittedCommand deserializedCommand = commandToBinaryConverter.toCommand(serializedCommand); "<AssertPlaceHolder>"; }
toCommand(byte[] ledgerEntryContent) { try { return serializer.fromDson(ledgerEntryContent, StoredCommittedCommand.class); } catch (DeserializeException e) { throw new IllegalStateException("Deserialization of Command failed", e); } }
[*] target: assertEquals(committedCommand, deserializedCommand)
[-] pred: org. junit. Assert. assertEquals ( committedCommand, deserializedCommand )
************************************
************************************
[+] input: testFindTransportWithSelectionHiPriority() { byte[] dummyMessage = new byte[0];  TransportInfo dummyTransport = TransportInfo.of("DUMMY", StaticTransportMetadata.empty()); TransportInfo udpTransport = TransportInfo.of(UDPConstants.NAME, StaticTransportMetadata.empty());  List<TransportInfo> transports = ImmutableList.of(dummyTransport, udpTransport);  Peer peer1 = mock(Peer.class); doAnswer(invocation -> transports.stream()).when(peer1).supportedTransports(); doAnswer( invocation -> "DUMMY".equals(invocation.getArgument(0)) || UDPConstants.NAME.equals(invocation.getArgument(0)) ).when(peer1).supportsTransport(any()); @SuppressWarnings("resource") Transport found = transportManager.findTransport(peer1, dummyMessage); "<AssertPlaceHolder>"; assertEquals("DUMMY", found.name()); }
findTransport(Peer peer, byte[] bytes) { if (peer != null) { // Could probably do something a bit more efficient here with caching and such // once the list of transports supported gets reasonably long.  // Check in priority order for first capable matching transport return this.transports.stream() .filter(t -> peer.supportsTransport(t.name())) .filter(t -> t.canHandle(bytes)) .findFirst() .orElse(this.defaultTransport); } return this.defaultTransport; }
[*] target: assertNotNull(found)
[-] pred: org. junit. Assert. assertNotNull ( found )
************************************
************************************
[+] input: testFindTransportWithSelectionLowPriority() { byte[] dummyMessage = new byte[0];  TransportInfo udpTransport = TransportInfo.of(UDPConstants.NAME, StaticTransportMetadata.empty());  List<TransportInfo> transports = ImmutableList.of(udpTransport);  Peer peer1 = mock(Peer.class); doAnswer(invocation -> transports.stream()).when(peer1).supportedTransports(); doAnswer(invocation -> UDPConstants.NAME.equals(invocation.getArgument(0))).when(peer1).supportsTransport(any()); @SuppressWarnings("resource") Transport found = transportManager.findTransport(peer1, dummyMessage); "<AssertPlaceHolder>"; assertEquals("UDP", found.name()); }
findTransport(Peer peer, byte[] bytes) { if (peer != null) { // Could probably do something a bit more efficient here with caching and such // once the list of transports supported gets reasonably long.  // Check in priority order for first capable matching transport return this.transports.stream() .filter(t -> peer.supportsTransport(t.name())) .filter(t -> t.canHandle(bytes)) .findFirst() .orElse(this.defaultTransport); } return this.defaultTransport; }
[*] target: assertNotNull(found)
[-] pred: org. junit. Assert. assertNotNull ( found )
************************************
************************************
[+] input: testComplete() { SendResult complete = SendResult.complete();  assertThat(complete.toString(), containsString("Complete")); "<AssertPlaceHolder>"; }
isComplete() { return this.throwable == null; }
[*] target: assertTrue(complete.isComplete())
[-] pred: org. junit. Assert. assertTrue ( complete. isComplete() )
************************************
************************************
[+] input: testFailure() { SendResult complete = SendResult.failure(new IOException());  assertThat(complete.toString(), containsString(IOException.class.getName())); "<AssertPlaceHolder>"; }
isComplete() { return this.throwable == null; }
[*] target: assertFalse(complete.isComplete())
[-] pred: org. junit. Assert. assertFalse ( complete. isComplete() )
************************************
************************************
[+] input: IOException { UDPConfiguration config = mock(UDPConfiguration.class); when(config.networkAddress(any())).thenReturn(NettyUDPTransportImpl.DEFAULT_HOST); when(config.networkPort(anyInt())).thenReturn(NettyUDPTransportImpl.DEFAULT_PORT);  TransportMetadata localMetadata = StaticTransportMetadata.empty(); UDPTransportControlFactory controlFactory = mock(UDPTransportControlFactory.class); UDPTransportOutboundConnectionFactory connectionFactory = mock(UDPTransportOutboundConnectionFactory.class); NatHandler natHandler = mock(NatHandler.class);  try (NettyUDPTransportImpl testInstance = new NettyUDPTransportImpl(config, localMetadata, controlFactory, connectionFactory, natHandler)) { // Always null until started "<AssertPlaceHolder>"; } }
control() { return control; }
[*] target: assertNull(testInstance.control())
[-] pred: org. junit. Assert. assertNull ( testInstance. control() )
************************************
************************************
[+] input: testGetSelf() { when(this.serialization.toJsonObject(any(), any())).thenReturn(new JSONObject()); JSONObject json = this.services.getSelf();  "<AssertPlaceHolder>"; assertTrue(json.has("system"));  verify(this.serialization, times(1)).toJsonObject(this.localSystem, Output.WIRE); }
getSelf() { JSONObject self = new JSONObject(); self.put("system", serialization.toJsonObject(localSystem, Output.WIRE)); return self; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: testGetPeerNotPresent() { when(this.addressBook.peer(any(EUID.class))).thenReturn(Optional.empty()); JSONObject json = this.services.getPeer("0123456789abcdef0123456789abcdef");  "<AssertPlaceHolder>"; assertTrue(json.isEmpty());  verify(this.addressBook, times(1)).peer(any(EUID.class)); }
getPeer(String id) { try { EUID euid = EUID.valueOf(id); if (euid.equals(EUID.fromHash(this.localPeerHash))) { return serialization.toJsonObject(this.localPeer, Output.API); } return this.addressBook.peer(euid) .map(peer -> serialization.toJsonObject(peer, Output.API)) .orElseGet(JSONObject::new); } catch (IllegalArgumentException ex) { // Ignore, return empty object } return new JSONObject(); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: ExecutionException { Context ctx = ContextAdapter.adapt(studioContext); List<Callable<String>> callables = new ArrayList<>(); for (int i = 0; i < 20; i++) { String val = "" + i; callables.add(() -> val); } List<String> result = ctx.call(callables); List<String> expected = IntStream.range(0, 20).mapToObj(i -> "" + i).collect(Collectors.toList()); TestCase."<AssertPlaceHolder>"; }
call(List<Callable<T>> list) throws ExecutionException { // ensure that NPE is thrown instead of IllegalArgumentException by ConcurrencyContext#call if (list == null) { throw new NullPointerException("callables must not be null"); } // check for null tasks for (Callable<T> callable : list) { if (callable == null) { throw new NullPointerException("callables must not contain null"); } } try { return studioContext.call(list); } catch (ExecutionStoppedException e) { throw new ExecutionAbortedException("Execution was aborted", e); } catch (ExecutionException e) { if (e.getCause() instanceof ExecutionAbortedException) { throw (ExecutionAbortedException) e.getCause(); } throw e; } }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: acceptingNullInputs() { final ConnectionConfiguration accept = new ConnectionConfigurationBuilder("accept nulls", CONFIGURATION_TYPE_TEST) .withDescription(null) .withTags(null) .withValueProviders(null) .withKeys(null) .build(); "<AssertPlaceHolder>"; }
build() { ConnectionConfiguration configuration = object; object = null; return configuration; }
[*] target: assertNotNull(accept)
[-] pred: org. junit. Assert. assertNotNull ( accept )
************************************
************************************
[+] input: testInjectValuesSuccessful() { MacroValueProviderHandler handler = MacroValueProviderHandler.getInstance(); ValueProvider provider = handler.createNewProvider("provider", PREFIX); Operator operator = getOperatorWithMacros(); Map<String, String> result = handler.injectValues(provider, REQUESTED, operator, null);  Map<String, String> expected = new HashMap<>(); expected.put("first", "first"); expected.put("second", "other");  // Test equals "<AssertPlaceHolder>"; }
injectValues(ValueProvider vp, Map<String, String> injectables, Operator operator, ConnectionInformation connection) { if (!isValid(vp, operator) || injectables == null || injectables.isEmpty()) { return Collections.emptyMap(); }  String prefix = getPrefix(vp); Map<String, String> result = new LinkedHashMap<>(); for (Entry<String, String> entry : injectables.entrySet()) { String fullKey = entry.getKey(); String needed = entry.getValue(); String value = null; String key = prefix + needed; try { value = operator.getProcess().getMacroHandler().getMacro(key, operator); } catch (Exception e) { // this can only happen with detached operators LogService.log(LogService.getRoot(), Level.WARNING, e, "com.rapidminer.connection.valueprovider.handler.MacroValueProviderHandler.retrieval_failed", key, vp.getName()); } if (value != null) { result.put(fullKey, value); } else { LogService.getRoot().log(Level.WARNING, "com.rapidminer.connection.valueprovider.handler.MacroValueProviderHandler.macro_not_found", key); } }  return result; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: createNoRowsTest() { ExampleTable table = new ColumnarExampleTable(Arrays.asList(ExampleTestTools.attributeInt()));  assertEquals(1, table.getAttributeCount()); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(0, table.size())
[-] pred: org. junit. Assert. assertEquals ( 0, table. size() )
************************************
************************************
[+] input: createNoRowsTwoAttributesRemoveTest() { ExampleTable table = new ColumnarExampleTable( Arrays.asList(ExampleTestTools.attributeInt(), ExampleTestTools.attributeReal())); table.removeAttribute(1);  assertEquals(1, table.getAttributeCount()); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(0, table.size())
[-] pred: org. junit. Assert. assertEquals ( 0, table. size() )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnParameterPrecondition precondition = new ColumnParameterPrecondition(generateDummyInputPort(errors), handler, "some_parameter"); final ExampleSetMetaData emd = FromTableMetaDataConverter.convert(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); precondition.check(emd); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd == null) { return; } String columnName = getName(); if (columnName != null) { // checking if attribute with name and type exists MetaDataInfo containsRelation = tmd.contains(columnName); if (containsRelation == MetaDataInfo.YES) { checkExistingColumn(tmd, columnName); } else if (containsRelation == MetaDataInfo.UNKNOWN) { createError(Severity.WARNING, "missing_attribute", columnName); } else { createError(Severity.ERROR, "missing_attribute", columnName); } } makeAdditionalChecks(tmd);  }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key"), "nominal"); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameter(ParameterHandler handler, String... parameterKeys) { return new ParameterColumnNameProvider(handler, parameterKeys); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key")); final ExampleSetMetaData emd = FromTableMetaDataConverter.convert(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); precondition.check(emd); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { // checking column names checkColumnNames(requiredNames, tmd);  // checking provider names if (requiredNameProvider != null) { checkColumnNames(requiredNameProvider.getRequiredColumnNames(), tmd); } makeAdditionalChecks(tmd); } }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key"), ColumnType.REAL); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameter(ParameterHandler handler, String... parameterKeys) { return new ParameterColumnNameProvider(handler, parameterKeys); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.isParameterSet(anyString())).thenReturn(true); when(handler.getParameterList(anyString())).thenReturn(Collections.singletonList(new String[]{"bla","real"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key", 1), ColumnType.REAL); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("nominal"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key"), Column.Category.CATEGORICAL); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameter(ParameterHandler handler, String... parameterKeys) { return new ParameterColumnNameProvider(handler, parameterKeys); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.isParameterSet(anyString())).thenReturn(true); when(handler.getParameterList(anyString())).thenReturn(Arrays.asList(new String[]{"bla","real"}, new String[]{"bla","int"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key",1), Column.Category.NUMERIC); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterList(anyString())).thenReturn(Arrays.asList(new String[]{"bla","real"}, new String[]{"bla","int"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key",1), Column.Category.OBJECT); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: testBooleanBoth() { final DictionaryInfo dictionaryInfo = new BooleanDictionaryInfo("bla", "blup"); assertEquals(new HashSet<>(Arrays.asList("bla", "blup")), dictionaryInfo.getValueSet()); assertEquals(MetaDataInfo.YES, dictionaryInfo.hasNegative()); assertEquals(MetaDataInfo.YES, dictionaryInfo.hasPositive()); assertTrue(dictionaryInfo.getNegativeValue().isPresent()); assertTrue(dictionaryInfo.getPositiveValue().isPresent()); assertEquals("bla",dictionaryInfo.getPositiveValue().get()); assertEquals("blup",dictionaryInfo.getNegativeValue().get()); "<AssertPlaceHolder>"; }
isBoolean() { return false; }
[*] target: assertTrue(dictionaryInfo.isBoolean())
[-] pred: org. junit. Assert. assertTrue ( dictionaryInfo. isBoolean() )
************************************
************************************
[+] input: testBooleanPositive() { final DictionaryInfo dictionaryInfo = new BooleanDictionaryInfo("bla", null); assertEquals(new HashSet<>(Collections.singletonList("bla")), dictionaryInfo.getValueSet()); assertEquals(MetaDataInfo.NO, dictionaryInfo.hasNegative()); assertEquals(MetaDataInfo.YES, dictionaryInfo.hasPositive()); assertFalse(dictionaryInfo.getNegativeValue().isPresent()); assertTrue(dictionaryInfo.getPositiveValue().isPresent()); assertEquals("bla",dictionaryInfo.getPositiveValue().get()); "<AssertPlaceHolder>"; }
isBoolean() { return false; }
[*] target: assertTrue(dictionaryInfo.isBoolean())
[-] pred: org. junit. Assert. assertTrue ( dictionaryInfo. isBoolean() )
************************************
************************************
[+] input: testBooleanNegative() { final DictionaryInfo dictionaryInfo = new BooleanDictionaryInfo(null, "blup"); assertEquals(new HashSet<>(Collections.singletonList("blup")), dictionaryInfo.getValueSet()); assertEquals(MetaDataInfo.YES, dictionaryInfo.hasNegative()); assertEquals(MetaDataInfo.NO, dictionaryInfo.hasPositive()); assertTrue(dictionaryInfo.getNegativeValue().isPresent()); assertFalse(dictionaryInfo.getPositiveValue().isPresent()); assertEquals("blup",dictionaryInfo.getNegativeValue().get()); "<AssertPlaceHolder>"; }
isBoolean() { return false; }
[*] target: assertTrue(dictionaryInfo.isBoolean())
[-] pred: org. junit. Assert. assertTrue ( dictionaryInfo. isBoolean() )
************************************
************************************
[+] input: testOther() { final TablePassThroughRule tablePassThroughRule = new TablePassThroughRule(generateDummyInputPort(), generateDummyOutputPort(), SetRelation.SUBSET); final PredictionModelMetaData modelMetaData = new PredictionModelMetaData(PredictionModel.class); final MetaData result = tablePassThroughRule.modifyMetaData(modelMetaData); "<AssertPlaceHolder>"; }
modifyMetaData(MetaData metaData) { TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { if (relation != null && relation != SetRelation.EQUAL) { TableMetaDataBuilder builder = new TableMetaDataBuilder(tmd); builder.mergeColumnSetRelation(relation); tmd = builder.build(); } try { return modifyTableMetaData(tmd); } catch (UndefinedParameterError e) { //ignore return tmd; } } else { return metaData; } }
[*] target: assertSame(modelMetaData, result)
[-] pred: org. junit. Assert. assertSame ( modelMetaData, result )
************************************
************************************
[+] input: testNullOptional() { List<MetaDataError> errors = new ArrayList<>(); final TablePrecondition tablePrecondition = new TablePrecondition(generateDummyInputPort(errors)); tablePrecondition.setOptional(true); tablePrecondition.check(null); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final InputPort inputPort = getInputPort(); if (metaData == null) { if (!optional) { // on purpose using ExampleSet for consistent display inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, null)); } } else { TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { checkColumnNames(tmd); checkTypes(tmd); checkRoles(inputPort, tmd); try { makeAdditionalChecks(tmd); } catch (UndefinedParameterError e) { //ignore } } else { inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, metaData.getObjectClass())); } } }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: testExampleSetMD() { List<MetaDataError> errors = new ArrayList<>(); final TablePrecondition tablePrecondition = new TablePrecondition(generateDummyInputPort(errors)); tablePrecondition.check(new ExampleSetMetaData()); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final InputPort inputPort = getInputPort(); if (metaData == null) { if (!optional) { // on purpose using ExampleSet for consistent display inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, null)); } } else { TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { checkColumnNames(tmd); checkTypes(tmd); checkRoles(inputPort, tmd); try { makeAdditionalChecks(tmd); } catch (UndefinedParameterError e) { //ignore } } else { inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, metaData.getObjectClass())); } } }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: columnErrorsSameName() { columnMetaData.get(1).setName("att1"); final AtomicBoolean wasCalled = new AtomicBoolean(); Observer<Set<Integer>> observer = new Observer<Set<Integer>>() {  @Override public void update(Observable<Set<Integer>> observable, Set<Integer> arg) { assertTrue(arg.contains(1)); assertTrue(arg.contains(0)); wasCalled.set(true); } }; validator.addObserver(observer, false); validator.validate(1); for (int i = 0; i < 4; i++) { assertEquals(i == 0 || i == 1, validator.isDuplicateNameColumn(i)); assertFalse(validator.isDuplicateRoleColumn(i)); } List<ColumnError> errors = validator.getColumnErrors(); "<AssertPlaceHolder>"; List<Integer> intList = new ArrayList<>(2); intList.add(0); intList.add(1); assertEquals(intList, errors.get(0).getAffectedColumns()); assertTrue(wasCalled.get()); }
getColumnErrors() { return columnErrorList; }
[*] target: assertEquals(1, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 1, errors. size ( ) )
************************************
************************************
[+] input: columnErrorsSameRole() { columnMetaData.get(0).setRole("label"); columnMetaData.get(1).setRole("label"); validator.validate(0); final AtomicBoolean wasCalled = new AtomicBoolean(); Observer<Set<Integer>> observer = new Observer<Set<Integer>>() {  @Override public void update(Observable<Set<Integer>> observable, Set<Integer> arg) { assertTrue(arg.contains(1)); assertTrue(arg.contains(0)); wasCalled.set(true); } }; validator.addObserver(observer, false); validator.validate(1); for (int i = 0; i < 4; i++) { assertEquals(i == 0 || i == 1, validator.isDuplicateRoleColumn(i)); assertFalse(validator.isDuplicateNameColumn(i)); } List<ColumnError> errors = validator.getColumnErrors(); "<AssertPlaceHolder>"; List<Integer> intList = new ArrayList<>(2); intList.add(0); intList.add(1); assertEquals(intList, errors.get(0).getAffectedColumns()); assertTrue(wasCalled.get()); }
getColumnErrors() { return columnErrorList; }
[*] target: assertEquals(1, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 1, errors. size ( ) )
************************************
************************************
[+] input: noUpdatedIndicesForParsingErrors() { final AtomicBoolean wasCalled = new AtomicBoolean(); Observer<Set<Integer>> observer = new Observer<Set<Integer>>() {  @Override public void update(Observable<Set<Integer>> observable, Set<Integer> arg) { assertTrue(arg == null); wasCalled.set(true); } }; validator.addObserver(observer, false); validator.setParsingErrors(parsingErrors); "<AssertPlaceHolder>"; }
setParsingErrors(List<ParsingError> parsingErrors) { this.parsingErrorList = parsingErrors; for (ParsingError error : parsingErrors) { parsingErrorAffectedColumns.add(error.getColumn()); } fireUpdate(); }
[*] target: assertTrue(wasCalled.get())
[-] pred: org. junit. Assert. assertTrue ( wasCalled. get ( ) )
************************************
************************************
[+] input: noUpdateForNotDuplicatedNameChange() { final AtomicBoolean wasCalled = new AtomicBoolean(); Observer<Set<Integer>> observer = new Observer<Set<Integer>>() {  @Override public void update(Observable<Set<Integer>> observable, Set<Integer> arg) { wasCalled.set(true); } }; validator.addObserver(observer, false); columnMetaData.get(1).setName("att"); validator.validate(1); "<AssertPlaceHolder>"; }
validate(int columnIndex) { updateColumnMaps(columnIndex); checkForDuplicates(); checkEmptySelection(columnIndex); checkIfUpdate(columnIndex); }
[*] target: assertFalse(wasCalled.get())
[-] pred: org. junit. Assert. assertFalse ( wasCalled. get ( ) )
************************************
************************************
[+] input: RepositoryException { JwtClaim jwtClaim = jwtReader.readClaim(null); Assert."<AssertPlaceHolder>"; }
readClaim(RemoteRepository source) throws RepositoryException, IOException { try { JwtWrapper wrapper = loadJwtWrapper(source); if (wrapper == null) { return null; } //Split the token into header, payload and signature String[] token = wrapper.getIdToken().split(JWT_SEPARATOR_REGEX); //Verify the structure of the Token if (token.length == JWT_STRUCTURE.length) { //Extract the payload String base64Body = token[JWT_PAYLOAD]; //Base64 Decode byte[] jsonBody = Base64.getDecoder().decode(base64Body); //Read the decoded JSON return mapper.readValue(jsonBody, JwtClaim.class); } else { throw new RepositoryException("Invalid response from TokenService."); } } catch (IllegalArgumentException | JsonMappingException e) { throw new RepositoryException("Invalid response from TokenService.", e); } }
[*] target: assertNull(jwtClaim)
[-] pred: org. junit. Assert. assertNull ( jwtClaim )
************************************
************************************
[+] input: RepositoryException { RemoteRepository repository = Mockito.mock(RemoteRepository.class); HttpURLConnection connection = Mockito.mock(HttpURLConnection.class); Mockito.when(repository.getHTTPConnection(INTERNAL_JAXREST_TOKENSERVICE, true)).thenReturn(connection); InputStream inputStream = new ByteArrayInputStream("".getBytes()); Mockito.when(connection.getInputStream()).thenReturn(inputStream); JwtClaim jwtClaim = jwtReader.readClaim(repository); Assert."<AssertPlaceHolder>"; }
readClaim(RemoteRepository source) throws RepositoryException, IOException { try { JwtWrapper wrapper = loadJwtWrapper(source); if (wrapper == null) { return null; } //Split the token into header, payload and signature String[] token = wrapper.getIdToken().split(JWT_SEPARATOR_REGEX); //Verify the structure of the Token if (token.length == JWT_STRUCTURE.length) { //Extract the payload String base64Body = token[JWT_PAYLOAD]; //Base64 Decode byte[] jsonBody = Base64.getDecoder().decode(base64Body); //Read the decoded JSON return mapper.readValue(jsonBody, JwtClaim.class); } else { throw new RepositoryException("Invalid response from TokenService."); } } catch (IllegalArgumentException | JsonMappingException e) { throw new RepositoryException("Invalid response from TokenService.", e); } }
[*] target: assertNull(jwtClaim)
[-] pred: org. junit. Assert. assertNull ( jwtClaim )
************************************
************************************
[+] input: checkNull() { final List<MigrationManager.MigrationStep> necessaryMigrationSteps = MigrationManager.getNecessaryMigrationSteps(null, null); Assert."<AssertPlaceHolder>"; Assert.assertTrue(necessaryMigrationSteps.isEmpty()); }
getNecessaryMigrationSteps(VersionNumber fromVersion, VersionNumber toVersion) { if (fromVersion == null || toVersion == null) { return Collections.emptyList(); } return steps.stream().filter(migrationStep -> (migrationStep.getFromVersion() == null || fromVersion.isAtLeast(migrationStep.getFromVersion())) && migrationStep.getToVersion().isAtMost(toVersion) && migrationStep.getToVersion().isAbove(fromVersion)).collect(Collectors.toList()); }
[*] target: assertNotNull(necessaryMigrationSteps)
[-] pred: org. junit. Assert. assertNotNull ( necessaryMigrationSteps )
************************************
************************************
[+] input: shouldNotFindInvalidCountryCode() { CountryCode cc = OnfidoSdkModule.findCountryCodeByAlpha2("12"); "<AssertPlaceHolder>"; }
findCountryCodeByAlpha2(String countryCodeString) { CountryCode countryCode = null; // We'll use a loop to find the value, because streams are not supported in Java 7. for (CountryCode cc : CountryCode.values()) { if (cc.name().equals(countryCodeString)) { countryCode = cc; } } return countryCode; }
[*] target: assertNull(cc)
[-] pred: org. junit. Assert. assertNull ( cc )
************************************
************************************
[+] input: shouldHaveLivenessWithRecordAudioParameters() { // Arrange final ReadableMap flowStepsMock = mock(ReadableMap.class); when(flowStepsMock.hasKey("welcome")).thenReturn(false); when(flowStepsMock.getBoolean("captureDocument")).thenReturn(false); when(flowStepsMock.hasKey("captureFace")).thenReturn(true);  ReadableMap livenessMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(livenessMock.getString("sdkToken")).thenReturn(sdkToken); String captureFaceType = "MOTION";  when(livenessMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  when(flowStepsMock.getMap("captureFace")).thenAnswer( (Answer<ReadableMap>) invocation -> { final ReadableMap flowStepsMock1 = mock(ReadableMap.class);  when(flowStepsMock1.getBoolean("recordAudio")).thenReturn(true); when(flowStepsMock1.hasKey("recordAudio")).thenReturn(true); when(flowStepsMock1.hasKey("type")).thenReturn(true); when(flowStepsMock1.getString("type")).thenReturn(captureFaceType); when(flowStepsMock1.hasKey("options")).thenReturn(true); return flowStepsMock1; });  Activity currentActivityMock = mock(Activity.class); OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(livenessMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); "<AssertPlaceHolder>"; assertNotNull(createdConfig.getFlowSteps()); assertNotNull(createdConfig.getFlowSteps().get(0)); FlowStep videoCaptureFlowStep = createdConfig.getFlowSteps().get(0); assertEquals(videoCaptureFlowStep.getAction(), FlowAction.ACTIVE_VIDEO_CAPTURE); assertNotNull(videoCaptureFlowStep.getOptions()); MotionCaptureVariantOptions options = (MotionCaptureVariantOptions) videoCaptureFlowStep.getOptions(); assertNotNull(options); assertNotNull(options.getAudioEnabled()); assertTrue(options.getAudioEnabled());  }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(createdConfig)
[-] pred: org. junit. Assert. assertNotNull ( createdConfig )
************************************
************************************
[+] input: shouldIncludeWelcomeScreenWhenConfiguredTo_singleFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", true, "captureDocument", mock(ReadableMap.class) ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps();  "<AssertPlaceHolder>"; assertEquals(FlowStep.WELCOME, resultingFlowSteps.get(0)); assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(1)); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: shouldIncludeWelcomeScreenWhenConfiguredTo_withAllowedDocumentTypesFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  JavaOnlyMap map = JavaOnlyMap.of( "allowedDocumentTypes", JavaOnlyArray.of("NATIONAL_IDENTITY_CARD", "PASSPORT") ); final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", true, "captureDocument", map ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps();  "<AssertPlaceHolder>"; assertEquals(FlowStep.WELCOME, resultingFlowSteps.get(0)); assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(1)); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: shouldHideWelcomeScreenWhenConfiguredTo_singleFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", false, "captureDocument", mock(ReadableMap.class) ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps();  "<AssertPlaceHolder>"; assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(0)); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: shouldHideWelcomeScreenWhenConfiguredTo_withAllowedDocumentTypesFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  JavaOnlyMap map = JavaOnlyMap.of( "allowedDocumentTypes", JavaOnlyArray.of("NATIONAL_IDENTITY_CARD", "PASSPORT") ); final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", false, "captureDocument", map ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps();  "<AssertPlaceHolder>"; assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(0)); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: shouldIncludeFlowStepsInTheRightOrder_singleFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", true, "proofOfAddress", true, "captureDocument", mock(ReadableMap.class), "captureFace", mock(ReadableMap.class) ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps(); "<AssertPlaceHolder>";  // Expected flow steps order: welcome - doc capture - POA - face capture  assertEquals(FlowStep.WELCOME, resultingFlowSteps.get(0)); assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(1)); assertEquals(FlowStep.PROOF_OF_ADDRESS, resultingFlowSteps.get(2));  FlowStep faceCaptureStep = resultingFlowSteps.get(3); assertEquals(FlowAction.CAPTURE_FACE, faceCaptureStep.getAction()); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: shouldIncludeFlowStepsInTheRightOrder_withAllowedDocumentTypesFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  JavaOnlyMap map = JavaOnlyMap.of( "allowedDocumentTypes", JavaOnlyArray.of("NATIONAL_IDENTITY_CARD", "PASSPORT") ); final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", true, "proofOfAddress", true, "captureDocument", map, "captureFace", mock(ReadableMap.class) ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps(); "<AssertPlaceHolder>";  // Expected flow steps order: welcome - doc capture - POA - face capture  assertEquals(FlowStep.WELCOME, resultingFlowSteps.get(0)); assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(1)); assertEquals(FlowStep.PROOF_OF_ADDRESS, resultingFlowSteps.get(2));  FlowStep faceCaptureStep = resultingFlowSteps.get(3); assertEquals(FlowAction.CAPTURE_FACE, faceCaptureStep.getAction()); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: InvocationTargetException { Field f = RestrictionBypass.getDeclaredField(this.getClass(), "testField1"); "<AssertPlaceHolder>"; assertSame(f.get(this), testField1); }
getDeclaredField(Class obj, String name) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) { return NativeReflectionBypass.getDeclaredField(obj, name); } else { Method getDeclaredField = Class.class.getMethod("getDeclaredField", String.class); return (Field) getDeclaredField.invoke(obj, name); } }
[*] target: assertNotNull(f)
[-] pred: org. junit. Assert. assertNotNull ( f )
************************************
************************************
[+] input: InvocationTargetException { Field f = RestrictionBypass.getDeclaredField(this.getClass(), "testField2"); "<AssertPlaceHolder>"; assertSame(f.get(this), testField2); }
getDeclaredField(Class obj, String name) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) { return NativeReflectionBypass.getDeclaredField(obj, name); } else { Method getDeclaredField = Class.class.getMethod("getDeclaredField", String.class); return (Field) getDeclaredField.invoke(obj, name); } }
[*] target: assertNotNull(f)
[-] pred: org. junit. Assert. assertNotNull ( f )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = userService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserError() { mockServerReturnObject(USER_MIKE, 0, ERROR_CODE); User user = userService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserAsync() { mockServerReturnObject(USER_MIKE); CompletableFuture<User> userCompletableFuture = userService.getUserAsync(Long100); "<AssertPlaceHolder>"; User user; try { user = userCompletableFuture.get(); } catch (Exception e) { throw new IllegalStateException("userCompletableFuture get error"); } assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserAsync(@Query("id") Long id);
[*] target: assertNotNull(userCompletableFuture)
[-] pred: org. junit. Assert. assertNotNull ( userCompletableFuture )
************************************
************************************
[+] input: getUserReturnResponse() { mockServerReturnObject(USER_MIKE); Response<User> userReturnResponse = userService.getUserReturnResponse(Long100); "<AssertPlaceHolder>"; assertEquals(SUCCESS_CODE, userReturnResponse.code()); User user = userReturnResponse.body(); assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserReturnResponse(@Query("id") Long id);
[*] target: assertNotNull(userReturnResponse)
[-] pred: org. junit. Assert. assertNotNull ( userReturnResponse )
************************************
************************************
[+] input: getUserReturnCall() { mockServerReturnObject(USER_MIKE); Call<User> userReturnCall = userService.getUserReturnCall(Long100); "<AssertPlaceHolder>"; try { Response<User> userResponse = userReturnCall.execute(); assertEquals(SUCCESS_CODE, userResponse.code()); User user = userResponse.body(); assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); } catch (IOException e) { throw new IllegalStateException("userReturnCall execute error"); } }
getUserReturnCall(@Query("id") Long id);
[*] target: assertNotNull(userReturnCall)
[-] pred: org. junit. Assert. assertNotNull ( userReturnCall )
************************************
************************************
[+] input: isMale() { mockServerReturnString(true); Boolean male = userService.isMale(Long100); "<AssertPlaceHolder>"; }
isMale(@Query("id") Long id);
[*] target: assertTrue(male)
[-] pred: org. junit. Assert. assertTrue ( male )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = chooserOkHttpUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = logUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = metaAnnotationUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserReturnSingleForRx2() { mockServerReturnObject(USER_MIKE); Single<User> userReturnSingle = rxJava2UserService.getUserReturnSingleForRx2(Long100); User user = userReturnSingle.blockingGet(); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserReturnSingleForRx2(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserReturnSingleForRx3() { mockServerReturnObject(USER_MIKE); Single<User> userReturnSingle = rxJava3UserService.getUserReturnSingleForRx3(Long100); User user = userReturnSingle.blockingGet(); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserReturnSingleForRx3(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE, 0, ERROR_CODE); mockServerReturnObject(USER_MIKE, 0, ERROR_CODE); mockServerReturnObject(USER_MIKE, 0, SUCCESS_CODE); User user = globalRetryUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE, 0, ERROR_CODE); mockServerReturnObject(USER_MIKE, 0, ERROR_CODE); mockServerReturnObject(USER_MIKE, 0, SUCCESS_CODE); User user = retryUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: distribution() {  SLD.Distribution<Object> actual = SLD.extractDistributions(graph)[0];  SLD.Distribution<Object> expected = new DistributionBuilder(""). access("ws://localhost:4567/access/colours", false) .format(Format.STRING) .license(License.CC) .protocol(Protocol.WebSocket) .security(Security.SSL) .publisher(SLD.extractPublisher(g)) .buildSource(g);   //        expected.describe().stream().forEach(triple -> { //            assertTrue(actual.describe().contains(triple)); //        }); // //        actual.describe().stream().forEach(triple -> { //            assertTrue(expected.describe().contains(triple)); // //        });   SLD.WebDataStream<Object> expectedWebStream = expected.getWebStream(); SLD.WebDataStream<Object> actualWebStream = actual.getWebStream();  "<AssertPlaceHolder>"; }
getWebStream(); }   public interface WebStream<E> extends Describable, Named {  SLD.Publisher publisher();  WebDataStream<E> serve();  }
[*] target: assertEquals(expectedWebStream, actualWebStream)
[-] pred: org. junit. Assert. assertEquals ( expectedWebStream, actualWebStream )
************************************
************************************
[+] input: ProcessedVariable_parsing_exceptions() { try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", ""); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "1-"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "-3"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "10-2"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "10/"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "/2"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "-1"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "-1,-2"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } try { ProcessedVariable ProcessedVariable = new ProcessedVariable("Test", "-1/-2"); ProcessedVariable.parse(); fail(); }catch (ParsingException e) { } "<AssertPlaceHolder>"; }
parse() { this.values = NumberParser.parse(this.model.value); }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: testLoadUserBySAML() { // given NameID mockNameID = mock(NameID.class); when(mockNameID.getValue()).thenReturn(USER_NAME);  SAMLCredential credentialsMock = mock(SAMLCredential.class); when(credentialsMock.getNameID()).thenReturn(mockNameID);  // when Object actual = userDetailsService.loadUserBySAML(credentialsMock);  // / then "<AssertPlaceHolder>"; assertTrue(actual instanceof User);  User user = (User) actual; assertEquals(USER_NAME, user.getUsername()); assertEquals(USER_PASSWORD, user.getPassword()); assertTrue(user.isEnabled()); assertTrue(user.isAccountNonExpired()); assertTrue(user.isCredentialsNonExpired()); assertTrue(user.isAccountNonLocked()); assertEquals(1, user.getAuthorities().size());  List<GrantedAuthority> authorities = new ArrayList<>(user.getAuthorities()); Object authority = authorities.get(0);  assertTrue(authority instanceof SimpleGrantedAuthority); assertEquals(USER_ROLE, ((SimpleGrantedAuthority) authority).getAuthority()); }
loadUserBySAML(SAMLCredential credential) {  // The method is supposed to identify local account of user referenced by // data in the SAML assertion and return UserDetails object describing the user.  String userID = credential.getNameID().getValue();  LOG.info("{} is logged in", userID); List<GrantedAuthority> authorities = new ArrayList<>(); GrantedAuthority authority = new SimpleGrantedAuthority("ROLE_USER"); authorities.add(authority);  // In a real scenario, this implementation has to locate user in a arbitrary // dataStore based on information present in the SAMLCredential and // returns such a date in a form of application specific UserDetails object. return new User(userID, "<abc123>", true, true, true, true, authorities); }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: Exception { ExceptionalSupplier<String, IOException> task = createMock(new Clazz<ExceptionalSupplier<String, IOException>>() { });  IOException thrown = new IOException(); expect(task.get()).andThrow(thrown);  control.replay();  try { backoffHelper.doUntilResult(task); fail("Expected exception to be bubbled"); } catch (IOException e) { "<AssertPlaceHolder>"; }  control.verify(); }
doUntilResult(ExceptionalSupplier<T, E> task) throws InterruptedException, BackoffStoppedException, E { T result = task.get(); // give an immediate try return (result != null) ? result : retryWork(task); }
[*] target: assertSame(thrown, e)
[-] pred: org. junit. Assert. assertSame ( thrown, e )
************************************
************************************
[+] input: Exception { ExceptionalSupplier<Boolean, RuntimeException> task = createMock(new Clazz<ExceptionalSupplier<Boolean, RuntimeException>>() { });  IllegalArgumentException thrown = new IllegalArgumentException(); expect(task.get()).andThrow(thrown);  control.replay();  try { backoffHelper.doUntilSuccess(task); fail("Expected exception to be bubbled"); } catch (IllegalArgumentException e) { "<AssertPlaceHolder>"; }  control.verify(); }
doUntilSuccess(final ExceptionalSupplier<Boolean, E> task) throws InterruptedException, BackoffStoppedException, E { doUntilResult(() -> { Boolean result = task.get(); return Boolean.TRUE.equals(result) ? result : null; }); }
[*] target: assertSame(thrown, e)
[-] pred: org. junit. Assert. assertSame ( thrown, e )
************************************
************************************
[+] input: CodingException { ScheduledTask original = TaskTestUtil.makeTask("id", TaskTestUtil.JOB).newBuilder();  byte[] deflated = ThriftBinaryCodec.deflateNonNull(original);  ScheduledTask inflated = ThriftBinaryCodec.inflateNonNull(ScheduledTask.class, deflated);  "<AssertPlaceHolder>"; }
inflateNonNull(Class<T> clazz, byte[] buffer) throws CodingException {  requireNonNull(clazz); requireNonNull(buffer);  T tBase = newInstance(clazz); TTransport transport = new TIOStreamTransport( new InflaterInputStream(new ByteArrayInputStream(buffer))); try { TProtocol protocol = PROTOCOL_FACTORY.getProtocol(transport); tBase.read(protocol); return tBase; } catch (TException e) { throw new CodingException("Failed to deserialize: " + e, e); } finally { transport.close(); } }
[*] target: assertEquals(original, inflated)
[-] pred: org. junit. Assert. assertEquals ( original, inflated )
************************************
************************************
[+] input: testHashCodeAndEquals() { List<CrontabEntry> entries = ImmutableList.of( CrontabEntry.parse("* * * * *"), CrontabEntry.parse("0-59 * * * *"), CrontabEntry.parse("0-57,58,59 * * * *"), CrontabEntry.parse("* 23,1,2,4,0-22 * * *"), CrontabEntry.parse("1-50,0,51-59 * * * sun-sat"));  for (CrontabEntry lhs : entries) { for (CrontabEntry rhs : entries) { "<AssertPlaceHolder>"; } }  assertEquals(1, ImmutableSet.copyOf(entries).size()); }
parse(String schedule) throws IllegalArgumentException { return new Parser(schedule).get(); }
[*] target: assertEquals(lhs, rhs)
[-] pred: org. junit. Assert. assertEquals ( lhs, rhs )
************************************
************************************
[+] input: testWildcards() { CrontabEntry wildcardMinuteEntry = CrontabEntry.parse("* 1 1 1 *"); assertEquals("*", wildcardMinuteEntry.getMinuteAsString()); assertTrue(wildcardMinuteEntry.hasWildcardMinute()); assertFalse(wildcardMinuteEntry.hasWildcardHour()); assertFalse(wildcardMinuteEntry.hasWildcardDayOfMonth()); assertFalse(wildcardMinuteEntry.hasWildcardMonth()); assertTrue(wildcardMinuteEntry.hasWildcardDayOfWeek());  CrontabEntry wildcardHourEntry = CrontabEntry.parse("1 * 1 1 *"); assertEquals("*", wildcardHourEntry.getHourAsString()); assertFalse(wildcardHourEntry.hasWildcardMinute()); assertTrue(wildcardHourEntry.hasWildcardHour()); assertFalse(wildcardHourEntry.hasWildcardDayOfMonth()); assertFalse(wildcardHourEntry.hasWildcardMonth()); assertTrue(wildcardHourEntry.hasWildcardDayOfWeek());  CrontabEntry wildcardDayOfMonth = CrontabEntry.parse("1 1 * 1 *"); assertEquals("*", wildcardDayOfMonth.getDayOfMonthAsString()); assertFalse(wildcardDayOfMonth.hasWildcardMinute()); assertFalse(wildcardDayOfMonth.hasWildcardHour()); assertTrue(wildcardDayOfMonth.hasWildcardDayOfMonth()); assertFalse(wildcardDayOfMonth.hasWildcardMonth()); assertTrue(wildcardDayOfMonth.hasWildcardDayOfWeek());  CrontabEntry wildcardMonth = CrontabEntry.parse("1 1 1 * *"); assertEquals("*", wildcardMonth.getMonthAsString()); assertFalse(wildcardMonth.hasWildcardMinute()); assertFalse(wildcardMonth.hasWildcardHour()); assertFalse(wildcardMonth.hasWildcardDayOfMonth()); assertTrue(wildcardMonth.hasWildcardMonth()); assertTrue(wildcardMonth.hasWildcardDayOfWeek());  CrontabEntry wildcardDayOfWeek = CrontabEntry.parse("1 1 1 1 *"); assertEquals("*", wildcardDayOfWeek.getDayOfWeekAsString()); assertFalse(wildcardDayOfWeek.hasWildcardMinute()); assertFalse(wildcardDayOfWeek.hasWildcardHour()); assertFalse(wildcardDayOfWeek.hasWildcardDayOfMonth()); assertFalse(wildcardDayOfWeek.hasWildcardMonth()); "<AssertPlaceHolder>"; }
hasWildcardDayOfWeek() { return getDayOfWeek().encloses(DAY_OF_WEEK); }
[*] target: assertTrue(wildcardDayOfWeek.hasWildcardDayOfWeek())
[-] pred: org. junit. Assert. assertTrue ( wildcardDayOfWeek. hasWildcardDayOfWeek ( ) )
************************************
************************************
[+] input: IOException { String minimal = "{"serviceEndpoint":{"host":"foo","port":1000},"status":"ALIVE"}"; ServiceInstance actual = Encoding.decode(minimal.getBytes(Charsets.UTF_8)); ServiceInstance expected = new ServiceInstance(new Endpoint("foo", 1000), ImmutableMap.of()); "<AssertPlaceHolder>"; }
decode(byte[] data) throws JsonSyntaxException { ServiceInstance instance = GSON.fromJson(new String(data, Charsets.UTF_8), ServiceInstance.class); assertRequiredField("serviceInstance", instance); assertRequiredField("serviceEndpoint", instance.getServiceEndpoint()); assertRequiredFields(instance.getServiceEndpoint()); if (instance.getAdditionalEndpoints() != null) { instance.getAdditionalEndpoints().values().forEach(Encoding::assertRequiredFields); }  return instance; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testAggregate() { expectGetAttributes( "a1", attribute("host", "a1"), attribute("rack", "a"), attribute("pdu", "p1")); expectGetAttributes( "b1", attribute("host", "b1"), attribute("rack", "b"), attribute("pdu", "p1", "p2")) .times(2); expectGetAttributes( "b2", attribute("host", "b2"), attribute("rack", "b"), attribute("pdu", "p1", "p2")); expectGetAttributes( "c1", attribute("host", "c1"), attribute("rack", "c"), attribute("pdu", "p2"), attribute("ssd", "true"));  control.replay();  Multiset<Pair<String, String>> expected = ImmutableMultiset.<Pair<String, String>>builder() .add(Pair.of("rack", "a")) .addCopies(Pair.of("rack", "b"), 3) .add(Pair.of("rack", "c")) .add(Pair.of("host", "a1")) .addCopies(Pair.of("host", "b1"), 2) .add(Pair.of("host", "b2")) .add(Pair.of("host", "c1")) .addCopies(Pair.of("pdu", "p1"), 4) .addCopies(Pair.of("pdu", "p2"), 4) .add(Pair.of("ssd", "true")) .build(); AttributeAggregate aggregate = aggregate( task("1", "a1"), task("2", "b1"), task("3", "b1"), task("4", "b2"), task("5", "c1")); "<AssertPlaceHolder>"; for (Multiset.Entry<Pair<String, String>> entry : expected.entrySet()) { Pair<String, String> element = entry.getElement(); assertAggregate(aggregate, element.getFirst(), element.getSecond(), entry.getCount()); } assertAggregate(aggregate, "host", "c2", 0L); assertAggregate(aggregate, "hostc", "2", 0L); }
getAggregates() { return aggregate.get(); }
[*] target: assertEquals(expected, aggregate.getAggregates())
[-] pred: org. junit. Assert. assertEquals ( expected, aggregate. getAggregates ( ) )
************************************
************************************
[+] input: testUpdateAttributeAggregate() { expectGetAttributes( "a1", attribute("host", "a1"), attribute("rack", "a"), attribute("pdu", "p1"));  control.replay();  Multiset<Pair<String, String>> expected = ImmutableMultiset.<Pair<String, String>>builder() .add(Pair.of("rack", "a")) .add(Pair.of("host", "a1")) .add(Pair.of("pdu", "p1")) .build();  AttributeAggregate aggregate = aggregate(task("1", "a1")); assertEquals(expected, aggregate.getAggregates());  aggregate.updateAttributeAggregate(IHostAttributes.build(new HostAttributes() .setHost("a2") .setAttributes(ImmutableSet.of(attribute("host", "a2"), attribute("rack", "b")))));  expected = ImmutableMultiset.<Pair<String, String>>builder() .addAll(expected) .add(Pair.of("rack", "b")) .add(Pair.of("host", "a2")) .build();  "<AssertPlaceHolder>"; }
getAggregates() { return aggregate.get(); }
[*] target: assertEquals(expected, aggregate.getAggregates())
[-] pred: org. junit. Assert. assertEquals ( expected, aggregate. getAggregates ( ) )
************************************
************************************
[+] input: IOException { // Making a task that is not in PENDING state. IJobKey jobKey = IJobKey.build(new JobKey("role", "test", "nonPendingJob")); IScheduledTask task = TestUtils.makeTask(jobKey, "task0", 0, ScheduleStatus.ASSIGNED, 10, 10, 10);  PubsubEvent.TaskStateChange taskStateChange = PubsubEvent.TaskStateChange.transition( task, ScheduleStatus.INIT);  pendingTaskGroups.taskChangedState(taskStateChange); expectLastCall();  // Recording the return value of pendingTaskGroups.getGroups(). List<TaskGroup> taskGroupList = new ArrayList<>(); expect(pendingTaskGroups.getGroups()).andReturn(taskGroupList).anyTimes();  replay(pendingTaskGroups);  // Testing. pendingTaskGroups.taskChangedState(taskStateChange); PendingTasks pendingTasks = new PendingTasks(pendingTaskGroups, nearestFit); JsonNode mimicResponseNoPendingTaskJson = new ObjectMapper().createArrayNode(); JsonNode actualResponseJson = new ObjectMapper().valueToTree( pendingTasks.getOffers().getEntity()); "<AssertPlaceHolder>"; }
getOffers() throws IOException { Map<TaskGroupKey, List<String>> taskGroupReasonMap = nearestFit.getPendingReasons(taskGroups.getGroups());  ObjectMapper mapper = new ObjectMapper(); ArrayNode jsonNode = mapper.createArrayNode();  // Add the attribute "reason" to each serialized taskgroup for (TaskGroup group : taskGroups.getGroups()) { ObjectNode pendingTask = (ObjectNode) mapper.valueToTree(group);  pendingTask.put("reason", taskGroupReasonMap.get(group.getKey()).toString()); jsonNode.add(pendingTask); } return Response.ok(jsonNode).build(); }
[*] target: assertEquals(mimicResponseNoPendingTaskJson, actualResponseJson)
[-] pred: org. junit. Assert. assertEquals ( mimicResponseNoPendingTaskJson, actualResponseJson )
************************************
************************************
[+] input: Exception { Snapshot snapshot = makeSnapshot(); expect(delegate.from(anyObject())).andReturn(snapshot).times(3);  control.replay();  triggerSnapshot(snapshot); assertBackupCount(0); clock.advance(Amount.of(INTERVAL.as(Time.MILLISECONDS) - 1, Time.MILLISECONDS)); triggerSnapshot(snapshot); assertBackupCount(0); clock.advance(Amount.of(1L, Time.MILLISECONDS)); triggerSnapshot(snapshot); assertBackupCount(1); assertEquals(1, storageBackup.getSuccesses().get());  @Nullable File[] files = config.getDir().listFiles(); "<AssertPlaceHolder>";  Snapshot restored = ThriftBinaryCodec.decode(Snapshot.class, Files.toByteArray(files[0])); assertEquals(snapshot, restored); }
getDir() { return dir; }
[*] target: assertNotNull(files)
[-] pred: org. junit. Assert. assertNotNull ( files )
************************************
************************************
[+] input: testObjectOverrides() { control.replay();  JobDiff a = new JobDiff( ImmutableMap.of(0, makeTask("job", "echo")), ImmutableSet.of(0), ImmutableMap.of()); JobDiff b = new JobDiff( ImmutableMap.of(0, makeTask("job", "echo")), ImmutableSet.of(0), ImmutableMap.of()); JobDiff c = new JobDiff( ImmutableMap.of(0, makeTask("job", "echo1")), ImmutableSet.of(0), ImmutableMap.of()); JobDiff d = new JobDiff( ImmutableMap.of(0, makeTask("job", "echo")), ImmutableSet.of(1), ImmutableMap.of()); assertEquals(a, b); assertEquals(ImmutableSet.of(a), ImmutableSet.of(a, b)); assertNotEquals(a, c); assertNotEquals(a, "a string"); assertNotEquals(a, d); "<AssertPlaceHolder>"; }
toString() { return MoreObjects.toStringHelper(this) .add("replacedInstances", getReplacedInstances()) .add("replacementInstances", getReplacementInstances()) .add("unchangedInstances", getUnchangedInstances()) .toString(); }
[*] target: assertEquals(a.toString(), b.toString())
[-] pred: org. junit. Assert. assertEquals ( a. toString ( ), b. toString ( ) )
************************************
************************************
[+] input: builderShouldSetValues() { User user = new User("ziltoid"); AuthenticationInfo authInfo = helper.createAuthenticationInfo("unit-test", user);  "<AssertPlaceHolder>"; assertEquals("ziltoid", authInfo.getPrincipals().getPrimaryPrincipal()); assertThat(authInfo.getPrincipals().getRealmNames(), hasItem("unit-test")); assertEquals(user, authInfo.getPrincipals().oneByType(User.class)); }
createAuthenticationInfo(String realm, User user) { SimplePrincipalCollection collection = new SimplePrincipalCollection();  collection.add(user.getId(), realm); collection.add(user, realm);  return new SimpleAuthenticationInfo(collection, user.getPassword()); }
[*] target: assertNotNull(authInfo)
[-] pred: org. junit. Assert. assertNotNull ( authInfo )
************************************
************************************
[+] input: testGetHeaderWithNullAsDefaultValue() { HttpServletRequest request = mock(HttpServletRequest.class);  String value = HttpUtil.getHeader(request, "Test", null); "<AssertPlaceHolder>"; }
getHeader(HttpServletRequest request, String header, String defaultValue) { String value = request.getHeader(header); if (value == null) { value = defaultValue; } return value; }
[*] target: assertNull(value)
[-] pred: org. junit. Assert. assertNull ( value )
************************************
************************************
[+] input: GitAPIException { Repository repository = RepositoryTestData.createHeartOfGold("git"); create(repository, "develop");  boolean result = modifier.ensure(repository, "develop");  "<AssertPlaceHolder>"; }
ensure(Repository repository, String newHead)  { try (org.eclipse.jgit.lib.Repository gitRepository = open(repository)) { String currentHead = resolve(gitRepository); if (!Objects.equals(currentHead, newHead)) { return modify(gitRepository, newHead); } } catch (IOException ex) { LOG.warn("failed to change head of repository", ex); } return false; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: IOException { // without default branch, the repository head should be used FileObject root = createCommand().getBrowserResult(new BrowseCommandRequest()).getFile(); assertNotNull(root);  Collection<FileObject> foList = root.getChildren(); "<AssertPlaceHolder>"; assertFalse(foList.isEmpty());  assertThat(foList) .extracting("name") .containsExactly("c", "a.txt", "b.txt", "f.txt"); }
getChildren() { if (!sorted) { sort(children, entry -> entry.type != TreeType.FILE, TreeEntry::getNameString); sorted = true; } return children; }
[*] target: assertNotNull(foList)
[-] pred: org. junit. Assert. assertNotNull ( foList )
************************************
************************************
[+] input: IOException { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(2, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); line = result.getLine(1); assertEquals(2, line.getLineNumber()); assertEquals("2baab8e80280ef05a9aa76c49c76feca2872afb7", line.getRevision()); checkDate(line.getWhen()); assertEquals("line for blame", line.getCode()); assertEquals("added new line for blame", line.getDescription()); assertEquals("Zaphod Beeblebrox", line.getAuthor().getName()); assertEquals("zaphod.beeblebrox@hitchhiker.com", line.getAuthor().getMail()); }
getBlameResult(BlameCommandRequest request) throws IOException { if (logger.isDebugEnabled()) { logger.debug("get blame result for {}", request); }  AnnotateCommand cmd = AnnotateCommand.on(open());  cmd.rev(HgUtil.getRevision(request.getRevision()));  List<BlameLine> blameLines = Lists.newArrayList(); List<AnnotateLine> lines = cmd.execute(request.getPath()); int counter = 0;  for (AnnotateLine line : lines) { blameLines.add(convert(line, ++counter)); }  return new BlameResult(blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt"); request.setRevision("a9bacaf1b7fa0cebfca71fed4e59ed69a6319427");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(1, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); }
getBlameResult(BlameCommandRequest request) throws IOException { if (logger.isDebugEnabled()) { logger.debug("get blame result for {}", request); }  AnnotateCommand cmd = AnnotateCommand.on(open());  cmd.rev(HgUtil.getRevision(request.getRevision()));  List<BlameLine> blameLines = Lists.newArrayList(); List<AnnotateLine> lines = cmd.execute(request.getPath()); int counter = 0;  for (AnnotateLine line : lines) { blameLines.add(convert(line, ++counter)); }  return new BlameResult(blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BrowseCommandRequest request = new BrowseCommandRequest();  request.setPath("c");  BrowserResult result = new HgBrowseCommand(cmdContext).getBrowserResult(request);  "<AssertPlaceHolder>";  FileObject c = result.getFile(); assertEquals("c", c.getName()); Collection<FileObject> foList = c.getChildren();  assertThat(foList) .extracting("name") .containsExactly("d.txt", "e.txt");  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(2, foList.size());  FileObject d = null; FileObject e = null;  for (FileObject f : foList) { if ("d.txt".equals(f.getName())) { d = f; } else if ("e.txt".equals(f.getName())) { e = f; } }  assertNotNull(d); assertFalse(d.isDirectory()); assertEquals("d.txt", d.getName()); assertEquals("c/d.txt", d.getPath()); assertEquals("added file d and e in folder c", d.getDescription().get()); assertTrue(d.getLength().getAsLong() > 0); checkDate(d.getCommitDate().getAsLong()); assertNotNull(e); assertFalse(e.isDirectory()); assertEquals("e.txt", e.getName()); assertEquals("c/e.txt", e.getPath()); assertEquals("added file d and e in folder c", e.getDescription().get()); assertTrue(e.getLength().getAsLong() > 0); checkDate(e.getCommitDate().getAsLong()); }
getBrowserResult(BrowseCommandRequest request) throws IOException { HgFileviewCommand cmd = HgFileviewCommand.on(open());  String revision = MoreObjects.firstNonNull(request.getRevision(), "tip"); Changeset c = LogCommand.on(getContext().open()).rev(revision).limit(1).single();  if (c != null) { cmd.rev(c.getNode()); }  if (!Strings.isNullOrEmpty(request.getPath())) { cmd.path(request.getPath()); }  if (request.isDisableLastCommit()) { cmd.disableLastCommit(); }  if (request.isRecursive()) { cmd.recursive(); }  if (request.isDisableSubRepositoryDetection()) { cmd.disableSubRepositoryDetection(); }  cmd.setLimit(request.getLimit()); cmd.setOffset(request.getOffset());  FileObject file = cmd.execute() .orElseThrow(() -> notFound(entity("File", request.getPath()).in("Revision", revision).in(getRepository()))); return new BrowserResult(c == null? "tip": c.getNode(), revision, file); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BrowseCommandRequest request = new BrowseCommandRequest();  request.setRecursive(true);  BrowserResult result = new HgBrowseCommand(cmdContext).getBrowserResult(request);  "<AssertPlaceHolder>";  FileObject root = result.getFile(); Collection<FileObject> foList = root.getChildren();  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(4, foList.size());  FileObject c = getFileObject(foList, "c"); assertTrue(c.isDirectory()); assertEquals(2, c.getChildren().size()); }
getBrowserResult(BrowseCommandRequest request) throws IOException { HgFileviewCommand cmd = HgFileviewCommand.on(open());  String revision = MoreObjects.firstNonNull(request.getRevision(), "tip"); Changeset c = LogCommand.on(getContext().open()).rev(revision).limit(1).single();  if (c != null) { cmd.rev(c.getNode()); }  if (!Strings.isNullOrEmpty(request.getPath())) { cmd.path(request.getPath()); }  if (request.isDisableLastCommit()) { cmd.disableLastCommit(); }  if (request.isRecursive()) { cmd.recursive(); }  if (request.isDisableSubRepositoryDetection()) { cmd.disableSubRepositoryDetection(); }  cmd.setLimit(request.getLimit()); cmd.setOffset(request.getOffset());  FileObject file = cmd.execute() .orElseThrow(() -> notFound(entity("File", request.getPath()).in("Revision", revision).in(getRepository()))); return new BrowserResult(c == null? "tip": c.getNode(), revision, file); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { writeNewFile(outgoing, outgoingDirectory, "a.txt", "Content of file a.txt"); writeNewFile(outgoing, outgoingDirectory, "b.txt", "Content of file b.txt");  Changeset c1 = commit(outgoing, "added a and b");  writeNewFile(outgoing, outgoingDirectory, "c.txt", "Content of file c.txt"); writeNewFile(outgoing, outgoingDirectory, "d.txt", "Content of file d.txt");  Changeset c2 = commit(outgoing, "added c and d");  HgIncomingCommand cmd = createIncomingCommand(); IncomingCommandRequest request = new IncomingCommandRequest();  request.setRemoteRepository(outgoingRepository);  ChangesetPagingResult cpr = cmd.getIncomingChangesets(request);  "<AssertPlaceHolder>"; assertEquals(2, cpr.getTotal()); assertChangesetsEqual(c1, cpr.getChangesets().get(0)); assertChangesetsEqual(c2, cpr.getChangesets().get(1)); }
getIncomingChangesets(IncomingCommandRequest request) { File remoteRepository = handler.getDirectory(request.getRemoteRepository().getId());  org.javahg.Repository repository = open();  // TODO implement paging  List<Changeset> changesets;  try {  changesets = on(repository).execute(remoteRepository.getAbsolutePath());  } catch (ExecutionException ex) { if (ex.getCommand().getReturnCode() == NO_INCOMING_CHANGESETS) { changesets = Collections.emptyList(); } else { throw new InternalRepositoryException(getRepository(), "could not execute incoming command", ex); } }  return new ChangesetPagingResult(changesets.size(), changesets); }
[*] target: assertNotNull(cpr)
[-] pred: org. junit. Assert. assertNotNull ( cpr )
************************************
************************************
[+] input: IOException { HgLogCommand command = createCommand(); String revision = "a9bacaf1b7fa0cebfca71fed4e59ed69a6319427"; Changeset c = command.getChangeset(revision, null);  "<AssertPlaceHolder>"; assertEquals(revision, c.getId()); assertEquals("added a and b files", c.getDescription()); checkDate(c.getDate()); assertEquals("Douglas Adams", c.getAuthor().getName()); assertEquals("douglas.adams@hitchhiker.com", c.getAuthor().getMail()); assertEquals("added a and b files", c.getDescription()); ModificationsCommand modificationsCommand = new HgModificationsCommand(cmdContext); Modifications modifications = modificationsCommand.getModifications(revision);  assertNotNull(modifications); assertTrue("modified list should be empty", modifications.getModified().isEmpty()); assertTrue("removed list should be empty", modifications.getRemoved().isEmpty()); assertFalse("added list should not be empty", modifications.getAdded().isEmpty()); assertEquals(2, modifications.getAdded().size()); assertThat(modifications.getAdded()) .extracting("path") .containsExactly("a.txt", "b.txt"); }
getChangeset(String id, LogCommandRequest request) { org.javahg.Repository repository = open(); HgLogChangesetCommand cmd = on(repository);  return cmd.rev(id).single(); }
[*] target: assertNotNull(c)
[-] pred: org. junit. Assert. assertNotNull ( c )
************************************
************************************
[+] input: IOException { writeNewFile(outgoing, outgoingDirectory, "a.txt", "Content of file a.txt"); writeNewFile(outgoing, outgoingDirectory, "b.txt", "Content of file b.txt");  Changeset c1 = commit(outgoing, "added a and b");  writeNewFile(outgoing, outgoingDirectory, "c.txt", "Content of file c.txt"); writeNewFile(outgoing, outgoingDirectory, "d.txt", "Content of file d.txt");  Changeset c2 = commit(outgoing, "added c and d");  HgOutgoingCommand cmd = createOutgoingCommand(); OutgoingCommandRequest request = new OutgoingCommandRequest();  request.setRemoteRepository(incomingRepository);  ChangesetPagingResult cpr = cmd.getOutgoingChangesets(request);  "<AssertPlaceHolder>"; assertEquals(2, cpr.getTotal()); assertChangesetsEqual(c1, cpr.getChangesets().get(0)); assertChangesetsEqual(c2, cpr.getChangesets().get(1)); }
getOutgoingChangesets( OutgoingCommandRequest request) { File remoteRepository = handler.getDirectory(request.getRemoteRepository().getId());  org.javahg.Repository repository = open();  // TODO implement paging  List<Changeset> changesets;  try { changesets = on(repository).execute(remoteRepository.getAbsolutePath()); } catch (ExecutionException ex) { if (ex.getCommand().getReturnCode() == NO_OUTGOING_CHANGESETS) { changesets = Collections.emptyList(); } else { throw new InternalRepositoryException(getRepository(), "could not execute outgoing command", ex); } }  return new ChangesetPagingResult(changesets.size(), changesets); }
[*] target: assertNotNull(cpr)
[-] pred: org. junit. Assert. assertNotNull ( cpr )
************************************
************************************
[+] input: testDoGetAuthenticationInfo() { User user = UserTestData.createTrillian();  user.setPassword(new Sha1Hash("secret").toHex()); when(userDAO.get("tricia")).thenReturn(user);  AuthenticationToken token = new UsernamePasswordToken("tricia", "secret"); AuthenticationInfo authInfo = realm.doGetAuthenticationInfo(token);  "<AssertPlaceHolder>"; assertEquals("tricia", authInfo.getPrincipals().getPrimaryPrincipal()); }
doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { Preconditions.checkArgument(token instanceof UsernamePasswordToken, "unsupported token"); return returnOnHexCredentials(helper.getAuthenticationInfo(token)); }
[*] target: assertNotNull(authInfo)
[-] pred: org. junit. Assert. assertNotNull ( authInfo )
************************************
************************************
[+] input: testGetBlameResultWithRevision() { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt"); request.setRevision("3");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(1, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); }
getBlameResult(BlameCommandRequest request) { String path = request.getPath(); String revision = request.getRevision(); List<BlameLine> blameLines = Lists.newArrayList(); SVNRevision endRevision = null;  if (Util.isNotEmpty(revision)) { endRevision = SVNRevision.create(Long.parseLong(revision)); } else { endRevision = SVNRevision.HEAD; }  try { SVNURL svnurl = SVNURL.fromFile(new File(context.getDirectory(), path)); SVNRepository svnRepository = SVNRepositoryFactory.create(context.createUrl()); ISVNAuthenticationManager svnManager = svnRepository.getAuthenticationManager(); SVNLogClient svnLogClient = new SVNLogClient(svnManager, null);  svnLogClient.doAnnotate(svnurl, SVNRevision.UNDEFINED, SVNRevision.create(1l), endRevision, new SvnBlameHandler(svnRepository, path, blameLines)); } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not create blame result", ex); }  return new BlameResult(blameLines.size(), blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testBrowse() { BrowserResult result = createCommand().getBrowserResult(new BrowseCommandRequest());  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("c", "a.txt");  Iterator<FileObject> iterator = foList.iterator(); FileObject c = iterator.next(); FileObject a = iterator.next();  assertFalse(a.isDirectory()); assertEquals("a.txt", a.getName()); assertEquals("a.txt", a.getPath()); assertEquals("added line for blame test", a.getDescription().get()); assertTrue(a.getLength().getAsLong() > 0); checkDate(a.getCommitDate().getAsLong()); assertTrue(c.isDirectory()); assertEquals("c", c.getName()); assertEquals("c", c.getPath()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testBrowseSubDirectory() { BrowseCommandRequest request = new BrowseCommandRequest();  request.setPath("c");  BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("d.txt", "e.txt");  Iterator<FileObject> iterator = foList.iterator(); FileObject d = iterator.next(); FileObject e = iterator.next();  assertNotNull(d); assertFalse(d.isDirectory()); assertEquals("d.txt", d.getName()); assertEquals("c/d.txt", d.getPath()); assertEquals("added d and e in folder c", d.getDescription().get()); assertTrue(d.getLength().getAsLong() > 0); checkDate(d.getCommitDate().getAsLong()); assertNotNull(e); assertFalse(e.isDirectory()); assertEquals("e.txt", e.getName()); assertEquals("c/e.txt", e.getPath()); assertEquals("added d and e in folder c", e.getDescription().get()); assertTrue(e.getLength().getAsLong() > 0); checkDate(e.getCommitDate().getAsLong()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDisableLastCommit() { BrowseCommandRequest request = new BrowseCommandRequest();  request.setDisableLastCommit(true);  BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList1 = result.getFile().getChildren();  assertNotNull(foList1); assertFalse(foList1.isEmpty()); assertEquals(2, foList1.size());  Collection<FileObject> foList = foList1;  FileObject a = getFileObject(foList, "a.txt");  assertFalse(a.getDescription().isPresent()); assertFalse(a.getCommitDate().isPresent()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testRecursive() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setRecursive(true); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(2, foList.size());  FileObject c = getFileObject(foList, "c"); assertEquals("c", c.getName()); assertTrue(c.isDirectory()); assertEquals(2, c.getChildren().size()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testLimit() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setLimit(1); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("c", "a.txt"); assertThat(result.getFile().isTruncated()).isTrue(); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testOffset() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setOffset(1); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).isEmpty(); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: shouldNotAddSubRepositoryIfNotSetInProperties() { BrowserResult browserResult = new SvnBrowseCommand(createContext()).getBrowserResult(new BrowseCommandRequest());  boolean containsSubRepository = browserResult.getFile().getChildren() .stream() .anyMatch(c -> c.getSubRepository() != null);  "<AssertPlaceHolder>"; }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertFalse(containsSubRepository)
[-] pred: org. junit. Assert. assertFalse ( containsSubRepository )
************************************
************************************
[+] input: SVNException { String externalLink = "https://scm-manager.org/svn-repo"; SvnContext svnContext = setProp("svn:externals", "external -r1 " + externalLink);  BrowserResult browserResult = new SvnBrowseCommand(svnContext).getBrowserResult(new BrowseCommandRequest());  boolean containsSubRepository = browserResult.getFile().getChildren() .stream() .anyMatch(c -> c.getSubRepository().getRepositoryUrl().equals(externalLink));  "<AssertPlaceHolder>"; }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertTrue(containsSubRepository)
[-] pred: org. junit. Assert. assertTrue ( containsSubRepository )
************************************
************************************
[+] input: shouldNotReturnChangesetWithIdZero() { ChangesetPagingResult result = createCommand().getChangesets(new LogCommandRequest()); boolean found = StreamSupport.stream(result.spliterator(), false).anyMatch(c -> "0".equals(c.getId())); "<AssertPlaceHolder>"; }
getChangesets(LogCommandRequest request) { if (LOG.isDebugEnabled()) { LOG.debug("fetch changesets for {}", request); }  ChangesetPagingResult changesets; int start = request.getPagingStart(); int limit = request.getPagingLimit(); long startRevision = parseRevision(request.getStartChangeset(), repository); long endRevision = parseRevision(request.getEndChangeset(), repository); String[] pathArray = null;  if (!Strings.isNullOrEmpty(request.getPath())) { pathArray = new String[]{request.getPath()}; }  try { SVNRepository repo = open();  if ((startRevision > 0) || (pathArray != null)) { changesets = getChangesets(repo, startRevision, endRevision, start, limit, pathArray); } else { changesets = getChangesets(repo, start, limit); } } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not open repository", ex); }  return changesets; }
[*] target: assertFalse(found)
[-] pred: org. junit. Assert. assertFalse ( found )
************************************
************************************
[+] input: testGetCommit() { Changeset c = createCommand().getChangeset("3", null);  "<AssertPlaceHolder>"; assertEquals("3", c.getId()); assertEquals("remove b and modified a", c.getDescription()); checkDate(c.getDate()); assertEquals("perfect", c.getAuthor().getName()); assertNull("douglas.adams@hitchhiker.com", c.getAuthor().getMail()); SvnModificationsCommand modificationsCommand = new SvnModificationsCommand(createContext()); Modifications modifications = modificationsCommand.getModifications("3");  assertNotNull(modifications); assertEquals(1, modifications.getModified().size()); assertEquals(1, modifications.getRemoved().size()); assertTrue("added list should be empty", modifications.getAdded().isEmpty()); assertEquals("a.txt", modifications.getModified().get(0).getPath()); assertEquals("b.txt", modifications.getRemoved().get(0).getPath()); }
getChangeset(String revision, LogCommandRequest request) { Changeset changeset = null;  if (LOG.isDebugEnabled()) { LOG.debug("fetch changeset {}", revision); }  try { long revisioNumber = parseRevision(revision, repository); Preconditions.checkArgument(revisioNumber > 0, "revision must be greater than zero: %d", revisioNumber); SVNRepository repo = open(); Collection<SVNLogEntry> entries = repo.log(null, null, revisioNumber, revisioNumber, true, true);  if (Util.isNotEmpty(entries)) { changeset = SvnUtil.createChangeset(entries.iterator().next()); } } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not open repository", ex); }  return changeset; }
[*] target: assertNotNull(c)
[-] pred: org. junit. Assert. assertNotNull ( c )
************************************
************************************
[+] input: Exception { mockContentFromResource("Dockerfile");  Response response = contentResource.get(NAMESPACE, REPO_NAME, REV, "Dockerfile", null, null); "<AssertPlaceHolder>";  assertEquals("Dockerfile", response.getHeaderString("X-Programming-Language")); assertEquals("text/plain", response.getHeaderString("Content-Type")); }
get( @PathParam("namespace") String namespace, @PathParam("name") String name, @PathParam("revision") String revision, @PathParam("path") String path, @QueryParam("start") Integer start, @QueryParam("end") Integer end) { StreamingOutput stream = createStreamingOutput(namespace, name, revision, path, start, end); try (RepositoryService repositoryService = serviceFactory.create(new NamespaceAndName(namespace, name))) { Response.ResponseBuilder responseBuilder = Response.ok(stream); return createContentHeader(namespace, name, revision, path, repositoryService, responseBuilder); } catch (NotFoundException e) { LOG.debug(e.getMessage()); return Response.status(Status.NOT_FOUND).build(); } }
[*] target: assertEquals(200, response.getStatus())
[-] pred: org. junit. Assert. assertEquals ( 200, response. getStatus ( ) )
************************************
************************************
[+] input: shouldMapGroups() { PageResult<Group> pageResult = mockPageResult("nobodies", "bosses"); CollectionDto collectionDto = mapper.map(1, 2, pageResult); List<HalRepresentation> groups = collectionDto.getEmbedded().getItemsBy("groups"); "<AssertPlaceHolder>"; assertEquals("nobodies", ((GroupDto) groups.get(0)).getName()); assertEquals("bosses", ((GroupDto) groups.get(1)).getName()); }
map(int pageNumber, int pageSize, PageResult<Group> pageResult) { return map(pageNumber, pageSize, pageResult, this.createSelfLink(), this.createCreateLink()); }
[*] target: assertEquals(2, groups.size())
[-] pred: org. junit. Assert. assertEquals ( 2, groups. size ( ) )
************************************
************************************
[+] input: shouldMapUsers() { PageResult<User> pageResult = mockPageResult("Hannes", "Wurst"); CollectionDto collectionDto = mapper.map(0, 2, pageResult); List<HalRepresentation> users = collectionDto.getEmbedded().getItemsBy("users"); "<AssertPlaceHolder>"; assertEquals("Hannes", ((UserDto) users.get(0)).getName()); assertEquals("Wurst", ((UserDto) users.get(1)).getName()); }
map(int pageNumber, int pageSize, PageResult<User> pageResult) { return map(pageNumber, pageSize, pageResult, this.createSelfLink(), this.createCreateLink()); }
[*] target: assertEquals(2, users.size())
[-] pred: org. junit. Assert. assertEquals ( 2, users. size ( ) )
************************************
************************************
[+] input: httpOnlyShouldBeEnabledIfXsrfProtectionIsDisabled() { configuration.setEnabledXsrfProtection(false);  Cookie cookie = authenticate();  "<AssertPlaceHolder>"; }
isHttpOnly(){ // set http only flag only xsrf protection is disabled, // because we have to extract the xsrf key with javascript in the wui return !configuration.isEnabledXsrfProtection(); }
[*] target: assertTrue(cookie.isHttpOnly())
[-] pred: org. junit. Assert. assertTrue ( cookie. isHttpOnly() )
************************************
************************************
[+] input: Exception { ActivityRuleConfig config = new ActivityRuleConfig(); config.setActivityId(1L); config.setConfigKey("city"); config.setConfigValue("1,2,3");  ActivityRule activityRule = ActivityRuleRegistrar.parseRule(config); Assert."<AssertPlaceHolder>"; }
parseRule(ActivityRuleConfig config) { String configKey = config.getConfigKey();  try { ActivityRule activityRule = ruleClassMap.get(configKey).newInstance(); activityRule.decode(config); return activityRule; } catch (Exception e) { throw new CustomException(BizStatusCode.ACTIVITY_RULE_CONFIG_ERROR, configKey); } }
[*] target: assertNotNull(activityRule)
[-] pred: org. junit. Assert. assertNotNull ( activityRule )
************************************
************************************
[+] input: Exception { ActivityRuleConfig config = new ActivityRuleConfig(); config.setActivityId(1L); config.setConfigKey("abc"); config.setConfigValue("1,2,3");  ActivityRule activityRule = ActivityRuleRegistrar.parseRule(config); Assert."<AssertPlaceHolder>"; }
parseRule(ActivityRuleConfig config) { String configKey = config.getConfigKey();  try { ActivityRule activityRule = ruleClassMap.get(configKey).newInstance(); activityRule.decode(config); return activityRule; } catch (Exception e) { throw new CustomException(BizStatusCode.ACTIVITY_RULE_CONFIG_ERROR, configKey); } }
[*] target: assertNotNull(activityRule)
[-] pred: org. junit. Assert. assertNotNull ( activityRule )
************************************
************************************
[+] input: configTest() { SensitiveWordBs wordBs = SensitiveWordBs.newInstance() .wordDeny(WordDenys.defaults()) .wordAllow(WordAllows.defaults()) .init();  final String text = "五星红旗迎风飘扬，毛主席的画像屹立在天安门前。"; Assert."<AssertPlaceHolder>"; }
contains(final String target) { return sensitiveWord.contains(target, context); }
[*] target: assertTrue(wordBs.contains(text))
[-] pred: org. junit. Assert. assertTrue ( wordBs. contains( text ) )
************************************
************************************
[+] input: testHealthyAndDead() { System.setProperty(DashboardConfig.CONFIG_UNHEALTHY_MACHINE_MILLIS, "60000"); System.setProperty(DashboardConfig.CONFIG_AUTO_REMOVE_MACHINE_MILLIS, "600000"); DashboardConfig.clearCache(); MachineInfo machineInfo = new MachineInfo(); machineInfo.setHeartbeatVersion(1); machineInfo.setLastHeartbeat(System.currentTimeMillis() - 10000); assertTrue(machineInfo.isHealthy()); assertFalse(machineInfo.isDead());  machineInfo.setLastHeartbeat(System.currentTimeMillis() - 100000); assertFalse(machineInfo.isHealthy()); assertFalse(machineInfo.isDead());  machineInfo.setLastHeartbeat(System.currentTimeMillis() - 1000000); assertFalse(machineInfo.isHealthy()); "<AssertPlaceHolder>"; }
isDead() { if (DashboardConfig.getAutoRemoveMachineMillis() > 0) { long delta = System.currentTimeMillis() - lastHeartbeat; return delta > DashboardConfig.getAutoRemoveMachineMillis(); } return false; }
[*] target: assertTrue(machineInfo.isDead())
[-] pred: org. junit. Assert. assertTrue ( machineInfo. isDead() )
************************************
************************************
[+] input: test_isStartWithHttpOrHttps() { boolean start = ShortUrlManager.isStartWithHttpOrHttps("http://www.yefan813.github.io"); Assert."<AssertPlaceHolder>"; }
isStartWithHttpOrHttps(String url) { String regex = "^((https|http)?://)"; Pattern p = Pattern.compile(regex); Matcher matcher = p.matcher(url); return matcher.find(); }
[*] target: assertTrue(start)
[-] pred: org. junit. Assert. assertTrue ( start )
************************************
************************************
[+] input: reachingMaxSize() { for (long i = 1; i <= counterMetadata.getThreshold(); i++) { alertCounter.update(new AlertContext(i, new Object[]{"secret", i})); Assert.assertEquals(1, alertCounter.getOldest().longValue()); Assert.assertEquals(i, alertCounter.getSize()); }  alertCounter.update(new AlertContext(8, new Object[]{"secret", 1001})); Assert.assertEquals(2, alertCounter.getOldest().longValue()); Assert.assertEquals(counterMetadata.getThreshold(), alertCounter.getSize()); var fieldsToSend = alertCounter.getCorrelatedAlerts(fieldNames); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1000, fieldsToSend.size()); var variableSet = new HashSet<Long>(); for (var stringObjectMap : fieldsToSend) { Assert.assertEquals(2, stringObjectMap.size()); Assert.assertTrue(stringObjectMap.get("constant") instanceof String); Assert.assertTrue(stringObjectMap.get("variable") instanceof Number); Assert.assertEquals("secret", stringObjectMap.get("constant")); variableSet.add(((Number) stringObjectMap.get("variable")).longValue()); } Assert.assertEquals(1000, variableSet.size()); }
isEmpty() { return alertContextHeap.isEmpty(); }
[*] target: assertFalse(fieldsToSend.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( fieldsToSend. isEmpty() )
************************************
************************************
[+] input: cleaningCounterComplete() { alertCounter.update(new AlertContext(1, new Object[]{"secret", 1})); Assert.assertEquals(1, alertCounter.getOldest().longValue()); Assert.assertEquals(1, alertCounter.getSize()); Assert.assertFalse(alertCounter.isEmpty());  alertCounter.clean(2); Assert.assertNull(alertCounter.getOldest()); Assert.assertEquals(0, alertCounter.getSize()); Assert."<AssertPlaceHolder>"; }
isEmpty() { return alertContextHeap.isEmpty(); }
[*] target: assertTrue(alertCounter.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( alertCounter. isEmpty() )
************************************
************************************
[+] input: cleaningCounterVeryOld() { alertCounter.update(new AlertContext(1, new Object[]{"secret", 1})); alertCounter.clean(1002); Assert.assertNull(alertCounter.getOldest()); Assert.assertEquals(0, alertCounter.getSize()); Assert."<AssertPlaceHolder>"; }
isEmpty() { return alertContextHeap.isEmpty(); }
[*] target: assertTrue(alertCounter.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( alertCounter. isEmpty() )
************************************
************************************
[+] input: canModifyEventCompositeOrOk() { compositeMatcher = CompositeMatcher.builder() .isNegated(true) .matchers(matchers) .matcherType(MatcherType.COMPOSITE_OR) .build(); verify(matcher1, times(1)).canModifyEvent(); verify(matcher2, times(1)).canModifyEvent(); Assert."<AssertPlaceHolder>"; }
canModifyEvent() { return canModifyEvent; }
[*] target: assertFalse(compositeMatcher.canModifyEvent())
[-] pred: org. junit. Assert. assertFalse ( compositeMatcher. canModifyEvent() )
************************************
************************************
[+] input: ruleCanModifyEventOk() { when(matcher.canModifyEvent()).thenReturn(true);  rule = Rule.builder() .matchers(List.of(matcher)) .name(name) .version(version) .tags(constants) .protections(protections) .build();  Assert."<AssertPlaceHolder>"; }
canModifyEvent() { return flags.contains(RuleFlags.CAN_MODIFY_EVENT); }
[*] target: assertTrue(rule.canModifyEvent())
[-] pred: org. junit. Assert. assertTrue ( rule. canModifyEvent ( ) )
************************************
************************************
[+] input: builderOneMatcherAndMultipleNegatedMatchers() { var nonNegatedMatcher = Mockito.mock(Matcher.class); when(nonNegatedMatcher.isNegated()).thenReturn(false); when(matcher.isNegated()).thenReturn(true); rule = Rule.builder() .matchers(List.of(matcher, matcher, nonNegatedMatcher, matcher, matcher)) .name(name) .version(version) .tags(constants) .protections(protections) .build(); Assert."<AssertPlaceHolder>"; }
builder() {  return new Builder<>() { @Override protected Rule buildInternally() { prepareBuild(); return new Rule(this); } }; }
[*] target: assertNotNull(rule)
[-] pred: org. junit. Assert. assertNotNull ( rule )
************************************
************************************
[+] input: IOException { AlertingEngineBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof AlertMessages); Assert.assertTrue(values.get(1) instanceof ExceptionMessages);  AlertMessages alerts = (AlertMessages)values.get(0); Assert.assertEquals(1, alerts.size()); Assert.assertTrue(alerts.get(0).isVisibleAlert()); Assert.assertEquals("siembol_alert_generic_v1", alerts.get(0).getFullRuleName()); Assert.assertEquals(Optional.empty(), alerts.get(0).getCorrelationKey()); Assert.assertEquals(100, alerts.get(0).getMaxDayMatches()); Assert.assertEquals(30, alerts.get(0).getMaxHourMatches());  Map<String, Object> parsed = JSON_READER.readValue(alerts.get(0).getAlertJson()); Assert.assertEquals("siembol_alert_generic_v1", parsed.get(AlertingFields.FULL_RULE_NAME.getAlertingName())); Assert.assertEquals(100, parsed.get(AlertingFields.MAX_PER_DAY_FIELD.getAlertingName())); Assert.assertEquals(30, parsed.get(AlertingFields.MAX_PER_HOUR_FIELD.getAlertingName())); Assert.assertEquals("secret", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("secret", parsed.get("sensor")); Assert.assertEquals(1, parsed.get("dummy_field_int")); Assert.assertEquals(false, parsed.get("dummy_field_boolean")); verify(collector, times(1)).ack(eq(tuple)); }
execute(Tuple tuple) { AlertingEngine currentEngine = AlertingEngine.get(); String event = tuple.getStringByField(TupleFieldNames.EVENT.toString()); AlertingResult ret = currentEngine.evaluate(event);  if (ret.getStatusCode() == AlertingResult.StatusCode.OK && ret.getAttributes().getEvaluationResult() == EvaluationResult.NO_MATCH && ret.getAttributes().getExceptionEvents() == null) { LOG.debug(ACK_NO_MATCH_LOG, event); collector.ack(tuple); return; }  AlertMessages matches = new AlertMessages(); ExceptionMessages exceptions = new ExceptionMessages();  if (ret.getStatusCode() != AlertingResult.StatusCode.OK) { exceptions.add(String.format(EXCEPTION_MSG_FORMAT, ret.getAttributes().getException(), event)); }  if (ret.getAttributes().getExceptionEvents() != null) { ret.getAttributes().getExceptionEvents() .forEach( x -> { try { exceptions.add(JSON_WRITER.writeValueAsString(x)); } catch (JsonProcessingException e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  if (ret.getAttributes().getOutputEvents() != null) { ret.getAttributes().getOutputEvents() .forEach( x -> { try { matches.add(new AlertMessage(currentEngine.getAlertingEngineType(), x, JSON_WRITER.writeValueAsString(x))); } catch (Exception e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  collector.emit(tuple, new Values(matches, exceptions)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: IOException { when(zooKeeperConnector.getData()).thenReturn(Collections.singletonList(rulesForCorrelation)); AlertingEngineBolt.prepare(null, null, collector);  AlertingEngineBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof AlertMessages); Assert.assertTrue(values.get(1) instanceof ExceptionMessages);  AlertMessages alerts = (AlertMessages)values.get(0); Assert.assertEquals(1, alerts.size()); Assert.assertTrue(alerts.get(0).isCorrelationAlert()); Assert.assertFalse(alerts.get(0).isVisibleAlert());  Assert.assertEquals("siembol_alert_generic_v1", alerts.get(0).getFullRuleName()); Assert.assertTrue(alerts.get(0).getCorrelationKey().isPresent()); Assert.assertEquals("1", alerts.get(0).getCorrelationKey().get()); Assert.assertEquals(100, alerts.get(0).getMaxDayMatches()); Assert.assertEquals(30, alerts.get(0).getMaxHourMatches());  Map<String, Object> parsed = JSON_READER.readValue(alerts.get(0).getAlertJson()); Assert.assertEquals("siembol_alert_generic_v1", parsed.get(AlertingFields.FULL_RULE_NAME.getAlertingName())); Assert.assertEquals(100, parsed.get(AlertingFields.MAX_PER_DAY_FIELD.getAlertingName())); Assert.assertEquals(30, parsed.get(AlertingFields.MAX_PER_HOUR_FIELD.getAlertingName())); Assert.assertEquals("secret", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("secret", parsed.get("sensor")); Assert.assertEquals(1, parsed.get("dummy_field_int")); Assert.assertEquals(false, parsed.get("dummy_field_boolean")); verify(collector, times(1)).ack(eq(tuple)); }
execute(Tuple tuple) { AlertingEngine currentEngine = AlertingEngine.get(); String event = tuple.getStringByField(TupleFieldNames.EVENT.toString()); AlertingResult ret = currentEngine.evaluate(event);  if (ret.getStatusCode() == AlertingResult.StatusCode.OK && ret.getAttributes().getEvaluationResult() == EvaluationResult.NO_MATCH && ret.getAttributes().getExceptionEvents() == null) { LOG.debug(ACK_NO_MATCH_LOG, event); collector.ack(tuple); return; }  AlertMessages matches = new AlertMessages(); ExceptionMessages exceptions = new ExceptionMessages();  if (ret.getStatusCode() != AlertingResult.StatusCode.OK) { exceptions.add(String.format(EXCEPTION_MSG_FORMAT, ret.getAttributes().getException(), event)); }  if (ret.getAttributes().getExceptionEvents() != null) { ret.getAttributes().getExceptionEvents() .forEach( x -> { try { exceptions.add(JSON_WRITER.writeValueAsString(x)); } catch (JsonProcessingException e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  if (ret.getAttributes().getOutputEvents() != null) { ret.getAttributes().getOutputEvents() .forEach( x -> { try { matches.add(new AlertMessage(currentEngine.getAlertingEngineType(), x, JSON_WRITER.writeValueAsString(x))); } catch (Exception e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  collector.emit(tuple, new Values(matches, exceptions)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: testException() { when(tuple.getStringByField(eq(TupleFieldNames.EVENT.toString()))) .thenReturn("INVALID");  AlertingEngineBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); verify(collector, times(1)).ack(eq(tuple)); Assert."<AssertPlaceHolder>"; Assert.assertTrue(values.get(0) instanceof AlertMessages); Assert.assertTrue(values.get(1) instanceof ExceptionMessages); Assert.assertTrue(((AlertMessages)values.get(0)).isEmpty()); Assert.assertEquals(1, ((ExceptionMessages)values.get(1)).size()); Assert.assertTrue(((ExceptionMessages)values.get(1)).get(0).contains("JsonParseException")); }
execute(Tuple tuple) { AlertingEngine currentEngine = AlertingEngine.get(); String event = tuple.getStringByField(TupleFieldNames.EVENT.toString()); AlertingResult ret = currentEngine.evaluate(event);  if (ret.getStatusCode() == AlertingResult.StatusCode.OK && ret.getAttributes().getEvaluationResult() == EvaluationResult.NO_MATCH && ret.getAttributes().getExceptionEvents() == null) { LOG.debug(ACK_NO_MATCH_LOG, event); collector.ack(tuple); return; }  AlertMessages matches = new AlertMessages(); ExceptionMessages exceptions = new ExceptionMessages();  if (ret.getStatusCode() != AlertingResult.StatusCode.OK) { exceptions.add(String.format(EXCEPTION_MSG_FORMAT, ret.getAttributes().getException(), event)); }  if (ret.getAttributes().getExceptionEvents() != null) { ret.getAttributes().getExceptionEvents() .forEach( x -> { try { exceptions.add(JSON_WRITER.writeValueAsString(x)); } catch (JsonProcessingException e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  if (ret.getAttributes().getOutputEvents() != null) { ret.getAttributes().getOutputEvents() .forEach( x -> { try { matches.add(new AlertMessage(currentEngine.getAlertingEngineType(), x, JSON_WRITER.writeValueAsString(x))); } catch (Exception e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  collector.emit(tuple, new Values(matches, exceptions)); collector.ack(tuple); }
[*] target: assertEquals(2, values.size())
[-] pred: org. junit. Assert. assertEquals ( 2, values. size ( ) )
************************************
************************************
[+] input: Exception { AlertMessage alert = new AlertMessage(AlertingEngineType.SIEMBOL_ALERTS, alertMap, AlertMessageStr); AlertMessages.add(alert); writerBolt.execute(tuple); List<String> outputAlert = kafkaRule.helper().consumeStrings("alerts", 1) .get(10, TimeUnit.SECONDS); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, outputAlert.size()); Assert.assertEquals(AlertMessageStr.trim(), outputAlert.get(0).trim()); Assert.assertEquals(1, metricsTestRegistrarFactory.getCounterValue(SiembolMetrics.ALERTING_ENGINE_MATCHES.getMetricName())); Assert.assertEquals(1, metricsTestRegistrarFactory .getCounterValue(SiembolMetrics.ALERTING_RULE_MATCHES.getMetricName("alert1"))); }
execute(Tuple tuple) { Object matchesObject = tuple.getValueByField(TupleFieldNames.ALERTING_MATCHES.toString()); if (!(matchesObject instanceof AlertMessages)) { LOG.error(WRONG_ALERTS_FIELD_MESSAGE); throw new IllegalStateException(WRONG_ALERTS_FIELD_MESSAGE); } AlertMessages matches = (AlertMessages)matchesObject;  Object exceptionsObject = tuple.getValueByField(TupleFieldNames.ALERTING_EXCEPTIONS.toString()); if (!(exceptionsObject instanceof ExceptionMessages)) { LOG.error(WRONG_EXCEPTION_FIELD_MESSAGE); throw new IllegalStateException(WRONG_EXCEPTION_FIELD_MESSAGE); } ExceptionMessages exceptions = (ExceptionMessages)exceptionsObject;  var messages = new ArrayList<KafkaWriterMessage>(); var counters = new ArrayList<String>(); exceptions.forEach(x -> counters.add(SiembolMetrics.ALERTING_ENGINE_ERROR_MATCHES.getMetricName()));  for (var match : matches) { AlertingResult matchesInfo = ruleProtection.incrementRuleMatches(match.getFullRuleName()); int hourlyMatches = matchesInfo.getAttributes().getHourlyMatches(); int dailyMatches = matchesInfo.getAttributes().getDailyMatches(); int hourlyMatchesDiffWithMax = hourlyMatches - match.getMaxHourMatches().intValue(); int dailyMatchesDiffWithMax = dailyMatches - match.getMaxDayMatches().intValue();  if (hourlyMatchesDiffWithMax > 0 || dailyMatchesDiffWithMax > 0) { String msg = String.format(RULE_PROTECTION_ERROR_MESSAGE, match.getFullRuleName(), hourlyMatches, dailyMatches, match.getAlertJson()); LOG.debug(msg);  if ((hourlyMatchesDiffWithMax > 0  && isPowerOfTwo(hourlyMatchesDiffWithMax)) || (dailyMatchesDiffWithMax > 0 && isPowerOfTwo(dailyMatchesDiffWithMax))) { //NOTE: sending message about an alert filtered by rule protection is sampled exponentially exceptions.add(msg); }  counters.add(SiembolMetrics.ALERTING_ENGINE_RULE_PROTECTION.getMetricName()); counters.add(SiembolMetrics.ALERTING_RULE_PROTECTION.getMetricName(match.getRuleName())); continue; }  if (match.isVisibleAlert()) { LOG.debug(SEND_MSG_LOG, match.getAlertJson(), outputTopic); messages.add(new KafkaWriterMessage(outputTopic, match.getAlertJson())); counters.add(SiembolMetrics.ALERTING_ENGINE_MATCHES.getMetricName()); counters.add(SiembolMetrics.ALERTING_RULE_MATCHES.getMetricName(match.getRuleName())); }  if (match.isCorrelationAlert()) { if (match.getCorrelationKey().isEmpty()) { String errorMsg = String.format(MISSING_CORRELATION_KEY_MSG, match.getAlertJson()); LOG.error(errorMsg); throw new IllegalStateException(errorMsg); }  LOG.debug(SEND_MSG_LOG, match.getAlertJson(), correlationTopic); messages.add(new KafkaWriterMessage(correlationTopic, match.getCorrelationKey().get(), match.getAlertJson())); counters.add(SiembolMetrics.ALERTING_ENGINE_CORRELATION_MATCHES.getMetricName()); counters.add(SiembolMetrics.ALERTING_RULE_CORRELATION_MATCHES.getMetricName(match.getRuleName())); } }  for (var exception : exceptions) { String errorMsgToSend = getErrorMessageToSend(exception); LOG.debug(SEND_MSG_LOG, errorMsgToSend, errorTopic); messages.add(new KafkaWriterMessage(errorTopic, errorMsgToSend)); }  var anchor = new KafkaWriterAnchor(tuple); super.writeMessages(messages, counters, anchor); }
[*] target: assertNotNull(outputAlert)
[-] pred: org. junit. Assert. assertNotNull ( outputAlert )
************************************
************************************
[+] input: Exception { exceptionMessages.add("dummy"); writerBolt.execute(tuple); List<String> outputExceptions = kafkaRule.helper().consumeStrings("errors", 1) .get(10, TimeUnit.SECONDS);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, outputExceptions.size()); Map<String, Object> parsedException = JSON_MAP_READER.readValue(outputExceptions.get(0)); Assert.assertEquals("siembol_alerts", parsedException.get("failed_sensor_type")); Assert.assertEquals("alerting_error", parsedException.get("error_type")); Assert.assertEquals("error", parsedException.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("dummy", parsedException.get("message")); Assert.assertEquals(1, metricsTestRegistrarFactory .getCounterValue(SiembolMetrics.ALERTING_ENGINE_ERROR_MATCHES.getMetricName()));  }
execute(Tuple tuple) { Object matchesObject = tuple.getValueByField(TupleFieldNames.ALERTING_MATCHES.toString()); if (!(matchesObject instanceof AlertMessages)) { LOG.error(WRONG_ALERTS_FIELD_MESSAGE); throw new IllegalStateException(WRONG_ALERTS_FIELD_MESSAGE); } AlertMessages matches = (AlertMessages)matchesObject;  Object exceptionsObject = tuple.getValueByField(TupleFieldNames.ALERTING_EXCEPTIONS.toString()); if (!(exceptionsObject instanceof ExceptionMessages)) { LOG.error(WRONG_EXCEPTION_FIELD_MESSAGE); throw new IllegalStateException(WRONG_EXCEPTION_FIELD_MESSAGE); } ExceptionMessages exceptions = (ExceptionMessages)exceptionsObject;  var messages = new ArrayList<KafkaWriterMessage>(); var counters = new ArrayList<String>(); exceptions.forEach(x -> counters.add(SiembolMetrics.ALERTING_ENGINE_ERROR_MATCHES.getMetricName()));  for (var match : matches) { AlertingResult matchesInfo = ruleProtection.incrementRuleMatches(match.getFullRuleName()); int hourlyMatches = matchesInfo.getAttributes().getHourlyMatches(); int dailyMatches = matchesInfo.getAttributes().getDailyMatches(); int hourlyMatchesDiffWithMax = hourlyMatches - match.getMaxHourMatches().intValue(); int dailyMatchesDiffWithMax = dailyMatches - match.getMaxDayMatches().intValue();  if (hourlyMatchesDiffWithMax > 0 || dailyMatchesDiffWithMax > 0) { String msg = String.format(RULE_PROTECTION_ERROR_MESSAGE, match.getFullRuleName(), hourlyMatches, dailyMatches, match.getAlertJson()); LOG.debug(msg);  if ((hourlyMatchesDiffWithMax > 0  && isPowerOfTwo(hourlyMatchesDiffWithMax)) || (dailyMatchesDiffWithMax > 0 && isPowerOfTwo(dailyMatchesDiffWithMax))) { //NOTE: sending message about an alert filtered by rule protection is sampled exponentially exceptions.add(msg); }  counters.add(SiembolMetrics.ALERTING_ENGINE_RULE_PROTECTION.getMetricName()); counters.add(SiembolMetrics.ALERTING_RULE_PROTECTION.getMetricName(match.getRuleName())); continue; }  if (match.isVisibleAlert()) { LOG.debug(SEND_MSG_LOG, match.getAlertJson(), outputTopic); messages.add(new KafkaWriterMessage(outputTopic, match.getAlertJson())); counters.add(SiembolMetrics.ALERTING_ENGINE_MATCHES.getMetricName()); counters.add(SiembolMetrics.ALERTING_RULE_MATCHES.getMetricName(match.getRuleName())); }  if (match.isCorrelationAlert()) { if (match.getCorrelationKey().isEmpty()) { String errorMsg = String.format(MISSING_CORRELATION_KEY_MSG, match.getAlertJson()); LOG.error(errorMsg); throw new IllegalStateException(errorMsg); }  LOG.debug(SEND_MSG_LOG, match.getAlertJson(), correlationTopic); messages.add(new KafkaWriterMessage(correlationTopic, match.getCorrelationKey().get(), match.getAlertJson())); counters.add(SiembolMetrics.ALERTING_ENGINE_CORRELATION_MATCHES.getMetricName()); counters.add(SiembolMetrics.ALERTING_RULE_CORRELATION_MATCHES.getMetricName(match.getRuleName())); } }  for (var exception : exceptions) { String errorMsgToSend = getErrorMessageToSend(exception); LOG.debug(SEND_MSG_LOG, errorMsgToSend, errorTopic); messages.add(new KafkaWriterMessage(errorTopic, errorMsgToSend)); }  var anchor = new KafkaWriterAnchor(tuple); super.writeMessages(messages, counters, anchor); }
[*] target: assertNotNull(outputExceptions)
[-] pred: org. junit. Assert. assertNotNull ( outputExceptions )
************************************
************************************
[+] input: IOException { Optional<String> patched = ConfigEditorUtils.patchJsonSchema(rulesSchema, FORM_ATTRIBUTES_READER.readValue(layoutConfig)); Assert."<AssertPlaceHolder>"; Map<String, Object> schema = JSON_OBJECT_READER.readValue(patched.get()); Assert.assertNotNull(schema); }
patchJsonSchema(String rulesSchema, Map<String, JsonNode> formAttributes) { final DocumentContext context = JsonPath.parse(rulesSchema); Set<String> layoutKeys = formAttributes.keySet();  for (String key : layoutKeys) { try { JsonNode current = context.read(key); if (current.isArray()) { //NOTE: json array path return an array of object that should contain an unique object if (current.size() != 1) { LOG.error("Can not find a unique json array path: {} in schema: {}", key, rulesSchema); return Optional.empty(); } current = current.get(0); } if (!current.isObject()) { LOG.error("Path: {} in schema is not an Object, the value: {}", key, current); return Optional.empty(); }  if (!formAttributes.get(key).isObject()) { LOG.error("Layout config for path: {} is not an Object: {}", key, formAttributes.get(key).toString()); return Optional.empty(); }  final ObjectNode currentObjectNode = (ObjectNode)current; formAttributes.get(key).fieldNames().forEachRemaining( fieldName -> currentObjectNode.set(fieldName, formAttributes.get(key).get(fieldName))); } catch (Exception e) { LOG.error("Problem to find a key: {} in schema: {}", key, rulesSchema); return Optional.empty(); } }  String uiSchema = context.jsonString(); uiSchema = uiSchema.replaceAll(INDEX_REPLACE_REGEX, INDEX_REPLACEMENT); return Optional.of(uiSchema); }
[*] target: assertTrue(patched.isPresent())
[-] pred: org. junit. Assert. assertTrue ( patched. isPresent ( ) )
************************************
************************************
[+] input: IOException { Optional<String> patched = ConfigEditorUtils.patchJsonSchema(rulesSchema, FORM_ATTRIBUTES_READER.readValue("{}")); Assert."<AssertPlaceHolder>"; Map<String, Object> schema = JSON_OBJECT_READER.readValue(patched.get()); Assert.assertNotNull(schema); }
patchJsonSchema(String rulesSchema, Map<String, JsonNode> formAttributes) { final DocumentContext context = JsonPath.parse(rulesSchema); Set<String> layoutKeys = formAttributes.keySet();  for (String key : layoutKeys) { try { JsonNode current = context.read(key); if (current.isArray()) { //NOTE: json array path return an array of object that should contain an unique object if (current.size() != 1) { LOG.error("Can not find a unique json array path: {} in schema: {}", key, rulesSchema); return Optional.empty(); } current = current.get(0); } if (!current.isObject()) { LOG.error("Path: {} in schema is not an Object, the value: {}", key, current); return Optional.empty(); }  if (!formAttributes.get(key).isObject()) { LOG.error("Layout config for path: {} is not an Object: {}", key, formAttributes.get(key).toString()); return Optional.empty(); }  final ObjectNode currentObjectNode = (ObjectNode)current; formAttributes.get(key).fieldNames().forEachRemaining( fieldName -> currentObjectNode.set(fieldName, formAttributes.get(key).get(fieldName))); } catch (Exception e) { LOG.error("Problem to find a key: {} in schema: {}", key, rulesSchema); return Optional.empty(); } }  String uiSchema = context.jsonString(); uiSchema = uiSchema.replaceAll(INDEX_REPLACE_REGEX, INDEX_REPLACEMENT); return Optional.of(uiSchema); }
[*] target: assertTrue(patched.isPresent())
[-] pred: org. junit. Assert. assertTrue ( patched. isPresent ( ) )
************************************
************************************
[+] input: IOException { when(testCases.updateConfigItem(eq(user), eq("DUMMY"))).thenReturn(genericResult); ConfigEditorResult ret = configStore.updateTestCase(user, "DUMMY"); verify(testCases).updateConfigItem(user, "DUMMY"); Assert."<AssertPlaceHolder>"; }
updateTestCase(UserInfo user, String testCase) { if (testCases == null) { return ConfigEditorResult.fromMessage(ERROR, TEST_CASES_UNSUPPORTED_MSG); }  Callable<ConfigEditorResult> command = () -> testCases.updateConfigItem(user, testCase); return executeStoreCommand(command, storeExecutorService); }
[*] target: assertEquals(genericResult, ret)
[-] pred: org. junit. Assert. assertEquals (genericResult, ret )
************************************
************************************
[+] input: JsonProcessingException { detection = SIGMA_DETECTION_READER.readValue(sigmaDetectionExampleEmptyValues); searchesMap = detection.getSearchesMap(); Assert.assertNotNull(detection);  builder = new SigmaSearch.Builder(SigmaSearch.SearchType.MAP, "iptables"); searchesMap.get("iptables") .fieldNames() .forEachRemaining(x -> builder.addMapEntry(x, searchesMap.get("iptables").get(x))); search = builder.build(); List<MatcherDto> matchers = search.getSiembolMatchers(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(MatcherTypeDto.REGEX_MATCH, matchers.get(0).getType()); Assert.assertTrue(matchers.get(0).getNegated()); Assert.assertEquals("Image", matchers.get(0).getField()); Assert.assertEquals(".*", matchers.get(0).getData());  Assert.assertEquals(MatcherTypeDto.REGEX_MATCH, matchers.get(1).getType()); Assert.assertFalse(matchers.get(1).getNegated()); Assert.assertEquals("test", matchers.get(1).getField()); Assert.assertEquals("^$", matchers.get(1).getData()); }
getSiembolMatchers() { return siembolMatchers; }
[*] target: assertEquals(2, matchers.size())
[-] pred: org. junit. Assert. assertEquals ( 2, matchers. size ( ) )
************************************
************************************
[+] input: Exception { var currentResult = alertingSparkTestingProvider.submitJob(arg); String body = argumentBodyCaptor.getValue(); Assert."<AssertPlaceHolder>"; var reader = new ObjectMapper().readerFor(new TypeReference<Map<String, Object>>() { }); Map<String, Object> bodyMap = reader.readValue(body); Assert.assertEquals(1, bodyMap.get("dummy_int")); Assert.assertEquals("dummy", bodyMap.get("dummy_str")); Assert.assertEquals("siembol_alerting_tester", bodyMap.get("name")); Assert.assertEquals("uk.co.gresearch.siembol.spark.AlertingSpark", bodyMap.get("className")); Assert.assertTrue(bodyMap.get("args") instanceof List); var args = (List)bodyMap.get("args"); Assert.assertEquals(1, args.size()); Assert.assertEquals("arg1", args.get(0)); Assert.assertEquals(result, currentResult); }
submitJob(String argument) throws Exception { var currentAttributes = new HashMap<>(sparkAttributes); currentAttributes.put(ARGS_NAME_ATTRIBUTE, List.of(argument)); String body = ATTRIBUTES_WRITER.writeValueAsString(currentAttributes); return httpProvider.post(BATCHES_API, body); }
[*] target: assertNotNull(body)
[-] pred: org. junit. Assert. assertNotNull ( body )
************************************
************************************
[+] input: Exception { ConfigSchemaService service = EnrichmentSchemaService .createEnrichmentsSchemaService(new ConfigEditorUiLayout()); Assert."<AssertPlaceHolder>"; }
createEnrichmentsSchemaService(ConfigEditorUiLayout uiLayout) throws Exception { LOG.info("Initialising enrichment config schema service"); ConfigSchemaServiceContext context = new ConfigSchemaServiceContext(); EnrichmentCompiler compiler = EnrichmentCompilerImpl.createEnrichmentCompiler(); String rulesSchema = compiler.getSchema().getAttributes().getRulesSchema(); String testSchema = compiler.getTestSpecificationSchema().getAttributes().getTestSchema();  Optional<String> rulesSchemaUi = ConfigEditorUtils.patchJsonSchema(rulesSchema, uiLayout.getConfigLayout()); Optional<String> testSchemaUi = ConfigEditorUtils.patchJsonSchema(testSchema, uiLayout.getTestLayout()); SiembolJsonSchemaValidator adminConfigValidator = new SiembolJsonSchemaValidator( StormEnrichmentAttributesDto.class); Optional<String> adminConfigSchemaUi = ConfigEditorUtils.patchJsonSchema( adminConfigValidator.getJsonSchema().getAttributes().getJsonSchema(), uiLayout.getAdminConfigLayout());  if (!rulesSchemaUi.isPresent() || !testSchemaUi.isPresent() || !adminConfigSchemaUi.isPresent()) { LOG.error(INIT_ERROR); throw new IllegalArgumentException(INIT_ERROR); }  context.setConfigSchema(rulesSchemaUi.get()); context.setTestSchema(testSchemaUi.get()); context.setAdminConfigSchema(adminConfigSchemaUi.get()); context.setAdminConfigValidator(adminConfigValidator); var defaultConfigTester = new EnrichmentConfigTester( new SiembolJsonSchemaValidator(EnrichmentTestingSpecificationDto.class), testSchemaUi.get(), compiler); context.setConfigTesters(List.of(defaultConfigTester)); LOG.info("Initialising enrichment config schema service completed"); return new EnrichmentSchemaService(compiler, context); }
[*] target: assertNotNull(service)
[-] pred: org. junit. Assert. assertNotNull ( service )
************************************
************************************
[+] input: IOException { when(httpProvider.post(any(), any())).thenReturn(null); boolean response = stormProvider.killTopology("topology"); Assert."<AssertPlaceHolder>"; }
killTopology(String id) { LOG.info("Stopping topology: {}", id); String url = String.format(StormApplicationPaths.KILL_TOPOLOGY.getName(), id, killWaitSeconds); try { StormResponseDto response = post(url, ""); if (response != null && response.getStatus() != null) return response.getStatus().equals(STORM_RESPONSE_SUCCESS); } catch (IllegalArgumentException | IOException e){ LOG.error("Exception killing storm topology: ", e); } return false; }
[*] target: assertFalse(response)
[-] pred: org. junit. Assert. assertFalse ( response )
************************************
************************************
[+] input: IOException { when(httpProvider.post(any(), any())).thenReturn("{"status": "failed"}"); boolean response = stormProvider.killTopology("topology"); Assert."<AssertPlaceHolder>"; }
killTopology(String id) { LOG.info("Stopping topology: {}", id); String url = String.format(StormApplicationPaths.KILL_TOPOLOGY.getName(), id, killWaitSeconds); try { StormResponseDto response = post(url, ""); if (response != null && response.getStatus() != null) return response.getStatus().equals(STORM_RESPONSE_SUCCESS); } catch (IllegalArgumentException | IOException e){ LOG.error("Exception killing storm topology: ", e); } return false; }
[*] target: assertFalse(response)
[-] pred: org. junit. Assert. assertFalse ( response )
************************************
************************************
[+] input: IOException { when(httpProvider.post(any(), any())).thenReturn("{"status": "success"}"); boolean response = stormProvider.killTopology("topology"); Assert."<AssertPlaceHolder>"; }
killTopology(String id) { LOG.info("Stopping topology: {}", id); String url = String.format(StormApplicationPaths.KILL_TOPOLOGY.getName(), id, killWaitSeconds); try { StormResponseDto response = post(url, ""); if (response != null && response.getStatus() != null) return response.getStatus().equals(STORM_RESPONSE_SUCCESS); } catch (IllegalArgumentException | IOException e){ LOG.error("Exception killing storm topology: ", e); } return false; }
[*] target: assertTrue(response)
[-] pred: org. junit. Assert. assertTrue ( response )
************************************
************************************
[+] input: IOException { String enriched = EnrichmentEvaluatorLibrary.mergeEnrichments(simpleEvent, enrichments, Optional.empty()); Assert."<AssertPlaceHolder>"; Map<String, Object> map = JSON_MAP_READER.readValue(enriched); Assert.assertEquals(5, map.size()); Assert.assertEquals(1, map.get("timestamp")); Assert.assertEquals(true, map.get("dummy_bool")); Assert.assertEquals("test", map.get("dummy_str")); Assert.assertEquals("b", map.get("a")); Assert.assertEquals("d", map.get("c")); }
mergeEnrichments(String event, List<Pair<String, String>> enrichments, Optional<String> timestampField) throws IOException { ObjectNode node = (ObjectNode)OBJECT_MAPPER.readTree(event); enrichments.forEach(x -> node.put(x.getKey(), x.getValue())); if (timestampField.isPresent()) { node.put(timestampField.get(), System.currentTimeMillis()); } return node.toString(); }
[*] target: assertNotNull(enriched)
[-] pred: org. junit. Assert. assertNotNull ( enriched )
************************************
************************************
[+] input: IOException { String enriched = EnrichmentEvaluatorLibrary.mergeEnrichments(simpleEvent, enrichments, Optional.of("enrichment_timestamp")); Assert."<AssertPlaceHolder>"; Map<String, Object> map = JSON_MAP_READER.readValue(enriched); Assert.assertEquals(6, map.size()); Assert.assertEquals(1, map.get("timestamp")); Assert.assertEquals(true, map.get("dummy_bool")); Assert.assertEquals("test", map.get("dummy_str")); Assert.assertEquals("b", map.get("a")); Assert.assertEquals("d", map.get("c")); Assert.assertTrue(map.get("enrichment_timestamp") instanceof Number); }
mergeEnrichments(String event, List<Pair<String, String>> enrichments, Optional<String> timestampField) throws IOException { ObjectNode node = (ObjectNode)OBJECT_MAPPER.readTree(event); enrichments.forEach(x -> node.put(x.getKey(), x.getValue())); if (timestampField.isPresent()) { node.put(timestampField.get(), System.currentTimeMillis()); } return node.toString(); }
[*] target: assertNotNull(enriched)
[-] pred: org. junit. Assert. assertNotNull ( enriched )
************************************
************************************
[+] input: IOException { enrichments.clear(); String enriched = EnrichmentEvaluatorLibrary.mergeEnrichments(simpleEvent, enrichments, Optional.empty()); Assert."<AssertPlaceHolder>"; Map<String, Object> map = JSON_MAP_READER.readValue(enriched); Assert.assertEquals(4, map.size()); Assert.assertEquals(1, map.get("timestamp")); Assert.assertEquals(true, map.get("dummy_bool")); Assert.assertEquals("test", map.get("dummy_str")); Assert.assertEquals("conflict", map.get("a")); }
mergeEnrichments(String event, List<Pair<String, String>> enrichments, Optional<String> timestampField) throws IOException { ObjectNode node = (ObjectNode)OBJECT_MAPPER.readTree(event); enrichments.forEach(x -> node.put(x.getKey(), x.getValue())); if (timestampField.isPresent()) { node.put(timestampField.get(), System.currentTimeMillis()); } return node.toString(); }
[*] target: assertNotNull(enriched)
[-] pred: org. junit. Assert. assertNotNull ( enriched )
************************************
************************************
[+] input: testMatchRule() { enrichmentEvaluatorBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(3, values.size()); Assert.assertTrue(values.get(0) instanceof String); Assert.assertTrue(values.get(1) instanceof EnrichmentCommands); Assert.assertTrue(values.get(2) instanceof EnrichmentExceptions); Assert.assertEquals(event, values.get(0)); EnrichmentCommands commands = (EnrichmentCommands)values.get(1); Assert.assertEquals(1, commands.size()); Assert.assertEquals("tmp_string", commands.get(0).getKey()); Assert.assertEquals("tmp_string", commands.get(0).getKey()); Assert.assertEquals(1, commands.get(0).getTags().size()); Assert.assertEquals(1, commands.get(0).getEnrichmentFields().size()); Assert.assertTrue(((EnrichmentExceptions)values.get(2)).isEmpty()); }
execute(Tuple tuple) { EnrichmentEvaluator currentEvaluator = enrichmentEvaluator.get(); String event = tuple.getStringByField(EnrichmentTuples.EVENT.toString()); EnrichmentCommands commands = new EnrichmentCommands(); EnrichmentExceptions exceptions = new EnrichmentExceptions();  try { EnrichmentResult ret = currentEvaluator.evaluate(event); if (ret.getStatusCode() == OK) { if (ret.getAttributes().getEnrichmentCommands() != null) { commands.addAll(ret.getAttributes().getEnrichmentCommands()); } } else { if (ret.getAttributes().getMessage() != null) { exceptions.add(ret.getAttributes().getMessage()); } } } catch (Exception e) { LOG.error(EXCEPTION_RULE_EVALUATION, ExceptionUtils.getStackTrace(e)); exceptions.add(ErrorMessage.createErrorMessage(e, ErrorType.ENRICHMENT_ERROR).toString()); }  collector.emit(tuple, new Values(event, commands, exceptions)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: testExceptionRule() { when(tuple.getStringByField(eq(EnrichmentTuples.EVENT.toString()))).thenReturn("INVALID"); enrichmentEvaluatorBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(3, values.size()); Assert.assertTrue(values.get(0) instanceof String); Assert.assertTrue(values.get(1) instanceof EnrichmentCommands); Assert.assertTrue(values.get(2) instanceof EnrichmentExceptions); Assert.assertTrue(((EnrichmentCommands)values.get(1)).isEmpty()); Assert.assertFalse(((EnrichmentExceptions)values.get(2)).isEmpty()); Assert.assertEquals(1, ((EnrichmentExceptions)values.get(2)).size()); Assert.assertTrue(((EnrichmentExceptions)values.get(2)).get(0).contains("JsonParseException")); }
execute(Tuple tuple) { EnrichmentEvaluator currentEvaluator = enrichmentEvaluator.get(); String event = tuple.getStringByField(EnrichmentTuples.EVENT.toString()); EnrichmentCommands commands = new EnrichmentCommands(); EnrichmentExceptions exceptions = new EnrichmentExceptions();  try { EnrichmentResult ret = currentEvaluator.evaluate(event); if (ret.getStatusCode() == OK) { if (ret.getAttributes().getEnrichmentCommands() != null) { commands.addAll(ret.getAttributes().getEnrichmentCommands()); } } else { if (ret.getAttributes().getMessage() != null) { exceptions.add(ret.getAttributes().getMessage()); } } } catch (Exception e) { LOG.error(EXCEPTION_RULE_EVALUATION, ExceptionUtils.getStackTrace(e)); exceptions.add(ErrorMessage.createErrorMessage(e, ErrorType.ENRICHMENT_ERROR).toString()); }  collector.emit(tuple, new Values(event, commands, exceptions)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: testNonEmptyExceptionsEmptyEnrichments() { exceptions.add("dummy1"); exceptions.add("dummy2"); mergerBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0);  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counterValues = (SiembolMetricsCounters)values.get(1); Assert.assertEquals(1, counterValues.size()); Assert.assertEquals("test_counter", counterValues.get(0));   Assert.assertEquals(outputTopic, messages.get(0).getTopic()); Assert.assertFalse(messages.get(0).getMessage().isEmpty());  Assert.assertEquals(errorTopic, messages.get(1).getTopic()); Assert.assertEquals("dummy1", messages.get(1).getMessage());  Assert.assertEquals(errorTopic, messages.get(2).getTopic()); Assert.assertEquals("dummy2", messages.get(2).getMessage()); }
execute(Tuple tuple) { Object enrichmentsObj = tuple.getValueByField(EnrichmentTuples.ENRICHMENTS.toString()); if (!(enrichmentsObj instanceof EnrichmentPairs)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentPairs enrichments = (EnrichmentPairs)enrichmentsObj;  String event = tuple.getStringByField(EnrichmentTuples.EVENT.toString());  Object exceptionsObj = tuple.getValueByField(EnrichmentTuples.EXCEPTIONS.toString()); if (!(exceptionsObj instanceof EnrichmentExceptions)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentExceptions exceptions = (EnrichmentExceptions)exceptionsObj;  Object countersObj = tuple.getValueByField(EnrichmentTuples.COUNTERS.toString()); if (!(countersObj instanceof SiembolMetricsCounters)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); }  var counters = new SiembolMetricsCounters(); counters.addAll((SiembolMetricsCounters)countersObj);  try { event = EnrichmentEvaluatorLibrary.mergeEnrichments(event, enrichments, Optional.of(SiembolMessageFields.ENRICHING_TIME.toString())); } catch (Exception e) { LOG.error(MERGING_ERROR, event, enrichments); exceptions.add(ErrorMessage.createErrorMessage(e, ErrorType.ENRICHMENT_ERROR).toString()); }  LOG.debug(EVENT_INFO_LOG, event); KafkaWriterMessages messages = new KafkaWriterMessages(); messages.add(new KafkaWriterMessage(outputTopic, event)); exceptions.forEach(x -> messages.add(new KafkaWriterMessage(errorTopic, x))); collector.emit(tuple, new Values(messages, counters)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: testEmptyExceptionsNonEmptyEnrichments() { exceptions.add("dummy1"); exceptions.add("dummy2"); enrichments.add(Pair.of("test", "enrichment")); mergerBolt.execute(tuple);  Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0);  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counterValues = (SiembolMetricsCounters)values.get(1); Assert.assertEquals(1, counterValues.size()); Assert.assertEquals("test_counter", counterValues.get(0));  Assert.assertEquals(outputTopic, messages.get(0).getTopic());  Assert.assertEquals(errorTopic, messages.get(1).getTopic()); Assert.assertEquals("dummy1", messages.get(1).getMessage());  Assert.assertEquals(errorTopic, messages.get(2).getTopic()); Assert.assertEquals("dummy2", messages.get(2).getMessage()); }
execute(Tuple tuple) { Object enrichmentsObj = tuple.getValueByField(EnrichmentTuples.ENRICHMENTS.toString()); if (!(enrichmentsObj instanceof EnrichmentPairs)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentPairs enrichments = (EnrichmentPairs)enrichmentsObj;  String event = tuple.getStringByField(EnrichmentTuples.EVENT.toString());  Object exceptionsObj = tuple.getValueByField(EnrichmentTuples.EXCEPTIONS.toString()); if (!(exceptionsObj instanceof EnrichmentExceptions)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentExceptions exceptions = (EnrichmentExceptions)exceptionsObj;  Object countersObj = tuple.getValueByField(EnrichmentTuples.COUNTERS.toString()); if (!(countersObj instanceof SiembolMetricsCounters)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); }  var counters = new SiembolMetricsCounters(); counters.addAll((SiembolMetricsCounters)countersObj);  try { event = EnrichmentEvaluatorLibrary.mergeEnrichments(event, enrichments, Optional.of(SiembolMessageFields.ENRICHING_TIME.toString())); } catch (Exception e) { LOG.error(MERGING_ERROR, event, enrichments); exceptions.add(ErrorMessage.createErrorMessage(e, ErrorType.ENRICHMENT_ERROR).toString()); }  LOG.debug(EVENT_INFO_LOG, event); KafkaWriterMessages messages = new KafkaWriterMessages(); messages.add(new KafkaWriterMessage(outputTopic, event)); exceptions.forEach(x -> messages.add(new KafkaWriterMessage(errorTopic, x))); collector.emit(tuple, new Values(messages, counters)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: testExceptionsNonEmptyEnrichments() { enrichments.add(Pair.of("test", "enrichment")); mergerBolt.execute(tuple);  Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0);  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counterValues = (SiembolMetricsCounters)values.get(1); Assert.assertEquals(1, counterValues.size()); Assert.assertEquals("test_counter", counterValues.get(0));  Assert.assertEquals(outputTopic, messages.get(0).getTopic()); Assert.assertTrue(messages.get(0).getMessage().contains(""test":"enrichment"")); }
execute(Tuple tuple) { Object enrichmentsObj = tuple.getValueByField(EnrichmentTuples.ENRICHMENTS.toString()); if (!(enrichmentsObj instanceof EnrichmentPairs)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentPairs enrichments = (EnrichmentPairs)enrichmentsObj;  String event = tuple.getStringByField(EnrichmentTuples.EVENT.toString());  Object exceptionsObj = tuple.getValueByField(EnrichmentTuples.EXCEPTIONS.toString()); if (!(exceptionsObj instanceof EnrichmentExceptions)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentExceptions exceptions = (EnrichmentExceptions)exceptionsObj;  Object countersObj = tuple.getValueByField(EnrichmentTuples.COUNTERS.toString()); if (!(countersObj instanceof SiembolMetricsCounters)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); }  var counters = new SiembolMetricsCounters(); counters.addAll((SiembolMetricsCounters)countersObj);  try { event = EnrichmentEvaluatorLibrary.mergeEnrichments(event, enrichments, Optional.of(SiembolMessageFields.ENRICHING_TIME.toString())); } catch (Exception e) { LOG.error(MERGING_ERROR, event, enrichments); exceptions.add(ErrorMessage.createErrorMessage(e, ErrorType.ENRICHMENT_ERROR).toString()); }  LOG.debug(EVENT_INFO_LOG, event); KafkaWriterMessages messages = new KafkaWriterMessages(); messages.add(new KafkaWriterMessage(outputTopic, event)); exceptions.forEach(x -> messages.add(new KafkaWriterMessage(errorTopic, x))); collector.emit(tuple, new Values(messages, counters)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: testEmptyExceptionsEmptyCommands() { memoryTableBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(4, values.size()); Assert.assertTrue(values.get(0) instanceof String); Assert.assertTrue(values.get(1) instanceof EnrichmentPairs); Assert.assertTrue(values.get(2) instanceof EnrichmentExceptions); Assert.assertTrue(values.get(3) instanceof SiembolMetricsCounters); Assert.assertEquals(event, values.get(0)); Assert.assertTrue(((EnrichmentPairs)values.get(1)).isEmpty()); Assert.assertTrue(((EnrichmentExceptions)values.get(2)).isEmpty()); Assert.assertTrue(((SiembolMetricsCounters)values.get(3)).isEmpty()); var counters = (SiembolMetricsCounters)values.get(3); Assert.assertTrue(counters.isEmpty()); }
execute(Tuple tuple) { String event = tuple.getStringByField(EnrichmentTuples.EVENT.toString());  Object commandsObj = tuple.getValueByField(EnrichmentTuples.COMMANDS.toString()); if (!(commandsObj instanceof EnrichmentCommands)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentCommands commands = (EnrichmentCommands)commandsObj;  Object exceptionsObj = tuple.getValueByField(EnrichmentTuples.EXCEPTIONS.toString()); if (!(exceptionsObj instanceof EnrichmentExceptions)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentExceptions exceptions = (EnrichmentExceptions)exceptionsObj;  EnrichmentPairs enrichments = new EnrichmentPairs(); SiembolMetricsCounters counters = new SiembolMetricsCounters();  for (EnrichmentCommand command : commands) { var tablePair = enrichmentTables.get(command.getTableName()); if (tablePair == null) { continue; }  Optional<List<Pair<String, String>>> result = tablePair.getRight().getValues(command); if (result.isPresent()) { enrichments.addAll(result.get()); counters.add(SiembolMetrics.ENRICHMENT_RULE_APPLIED.getMetricName(command.getRuleName())); counters.add(SiembolMetrics.ENRICHMENT_TABLE_APPLIED.getMetricName(command.getTableName())); } } collector.emit(tuple, new Values(event, enrichments, exceptions, counters)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: testEmptyExceptionsCommandNoTable() { EnrichmentCommand command = new EnrichmentCommand(); commands.add(command); command.setTableName("invalid"); command.setRuleName("test_rule"); memoryTableBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(4, values.size()); Assert.assertTrue(values.get(0) instanceof String); Assert.assertTrue(values.get(1) instanceof EnrichmentPairs); Assert.assertTrue(values.get(2) instanceof EnrichmentExceptions); Assert.assertTrue(values.get(3) instanceof SiembolMetricsCounters); Assert.assertEquals(event, values.get(0)); Assert.assertTrue(((EnrichmentPairs)values.get(1)).isEmpty()); Assert.assertTrue(((EnrichmentExceptions)values.get(2)).isEmpty()); var counters = (SiembolMetricsCounters)values.get(3); Assert.assertTrue(counters.isEmpty()); }
execute(Tuple tuple) { String event = tuple.getStringByField(EnrichmentTuples.EVENT.toString());  Object commandsObj = tuple.getValueByField(EnrichmentTuples.COMMANDS.toString()); if (!(commandsObj instanceof EnrichmentCommands)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentCommands commands = (EnrichmentCommands)commandsObj;  Object exceptionsObj = tuple.getValueByField(EnrichmentTuples.EXCEPTIONS.toString()); if (!(exceptionsObj instanceof EnrichmentExceptions)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentExceptions exceptions = (EnrichmentExceptions)exceptionsObj;  EnrichmentPairs enrichments = new EnrichmentPairs(); SiembolMetricsCounters counters = new SiembolMetricsCounters();  for (EnrichmentCommand command : commands) { var tablePair = enrichmentTables.get(command.getTableName()); if (tablePair == null) { continue; }  Optional<List<Pair<String, String>>> result = tablePair.getRight().getValues(command); if (result.isPresent()) { enrichments.addAll(result.get()); counters.add(SiembolMetrics.ENRICHMENT_RULE_APPLIED.getMetricName(command.getRuleName())); counters.add(SiembolMetrics.ENRICHMENT_TABLE_APPLIED.getMetricName(command.getTableName())); } } collector.emit(tuple, new Values(event, enrichments, exceptions, counters)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: Exception { SerializableSiembolParser original = new SerializableSiembolParser(simpleGenericParser);  List<Map<String, Object>> parsedOriginal = original.parse(message.getBytes()); byte[] blob = SerializationUtils.serialize(original); Assert.assertTrue(blob.length > 0); SerializableSiembolParser clone = SerializationUtils.clone(original); List<Map<String, Object>> parsedClone = clone.parse(message.getBytes());  Assert."<AssertPlaceHolder>"; Assert.assertEquals(1553712722732L, parsedClone.get(0).get("timestamp")); }
parse(byte[] message) { return parser.parse(message); }
[*] target: assertEquals(parsedOriginal, parsedClone)
[-] pred: org. junit. Assert. assertEquals ( parsedOriginal, parsedClone )
************************************
************************************
[+] input: testWrongColumns() { CSVExtractor extractor = CSVExtractor.builder() .columnNames(null) .extractorFlags(extractorFlags) .name(name) .field(field) .build();  Map<String, Object> out = extractor.extract(simpleNoQuotes.trim()); Assert."<AssertPlaceHolder>"; }
build() { if (this.columnNamesList == null || this.columnNamesList.isEmpty()) { throw new IllegalArgumentException("Empty column names"); } for (ColumnNames columnNames : columnNamesList) { if (!checkNames(columnNames.getColumnNames(), skippingColumnName)) { throw new IllegalArgumentException("Wrong column names"); } }  return new CSVExtractor(this); }
[*] target: assertNull(out)
[-] pred: org. junit. Assert. assertNull ( out )
************************************
************************************
[+] input: testWrongColumns2() { CSVExtractor extractor = CSVExtractor.builder() .extractorFlags(extractorFlags) .name(name) .field(field) .build();  Map<String, Object> out = extractor.extract(simpleNoQuotes.trim()); Assert."<AssertPlaceHolder>"; }
build() { if (this.columnNamesList == null || this.columnNamesList.isEmpty()) { throw new IllegalArgumentException("Empty column names"); } for (ColumnNames columnNames : columnNamesList) { if (!checkNames(columnNames.getColumnNames(), skippingColumnName)) { throw new IllegalArgumentException("Wrong column names"); } }  return new CSVExtractor(this); }
[*] target: assertNull(out)
[-] pred: org. junit. Assert. assertNull ( out )
************************************
************************************
[+] input: testNoOutputField() { RegexSelectExtractor extractor = RegexSelectExtractor.builder() .patterns(patterns) .outputField(null) .defaultValue("default_topic") .extractorFlags(extractorFlags) .name(name) .field(field) .build(); Map<String, Object> out = extractor.extract(simpleMessage.trim()); Assert."<AssertPlaceHolder>"; }
build() { if (this.outputField == null || patterns == null) { throw new IllegalArgumentException(MISSING_ARGUMENTS); } return new RegexSelectExtractor(this); }
[*] target: assertNull(out)
[-] pred: org. junit. Assert. assertNull ( out )
************************************
************************************
[+] input: IOException { parsingApplicationBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0); Assert.assertEquals(1, messages.size()); Assert.assertEquals("output", messages.get(0).getTopic());  Map<String, Object> parsed = JSON_READER.readValue(messages.get(0).getMessage()); Assert.assertEquals("RAW_LOG", parsed.get(SiembolMessageFields.ORIGINAL.toString())); Assert.assertEquals("single", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertNull(parsed.get("metadata_is_metadata"));  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counters = (SiembolMetricsCounters)values.get(1); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_APP_PARSED_MESSAGES.getMetricName())); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_SOURCE_TYPE_PARSED_MESSAGES .getMetricName("single"))); Assert.assertEquals(1, metricsTestRegistrarFactory.getCounterValue(SiembolMetrics.PARSING_CONFIGS_UPDATE.getMetricName())); }
execute(Tuple tuple) { ParsingApplicationParser currentParser = parsingApplicationParser.get();  String source = tuple.getStringByField(ParsingApplicationTuples.SOURCE.toString()); String metadata = tuple.getStringByField(ParsingApplicationTuples.METADATA.toString()); Object logObj = tuple.getValueByField(ParsingApplicationTuples.LOG.toString()); if (!(logObj instanceof byte[])) { throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLE); }  byte[] log = (byte[]) logObj; ArrayList<ParsingApplicationResult> results = currentParser.parse(source, metadata, log);  var kafkaWriterMessages = new KafkaWriterMessages(); var counters = new SiembolMetricsCounters(); for (var result : results) { if (result.getResultFlags().contains(ParsingApplicationResult.ResultFlag.FILTERED)) { metricsRegistrar.registerCounter( SiembolMetrics.PARSING_SOURCE_TYPE_FILTERED_MESSAGES.getMetricName(result.getSourceType())) .increment(); metricsRegistrar.registerCounter(SiembolMetrics.PARSING_APP_FILTERED_MESSAGES.getMetricName()) .increment(); } else { result.getMessages().forEach(x -> { kafkaWriterMessages.add(new KafkaWriterMessage(result.getTopic(), x)); addCounters(counters, result.getResultFlags(), result.getSourceType()); }); } }  if (!kafkaWriterMessages.isEmpty()) { collector.emit(tuple, new Values(kafkaWriterMessages, counters)); }  collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: Exception { parsingAttributes.setApplicationParserSpecification(simpleSingleApplicationParser.replace( ""parse_metadata" : false", ""parse_metadata" : true" )); parsingApplicationBolt = new ParsingApplicationBolt(attributes, parsingAttributes, zooKeeperConnectorFactory, metricsTestRegistrarFactory); parsingApplicationBolt.prepare(null, null, collector);  when(tuple.getStringByField(eq(ParsingApplicationTuples.METADATA.toString()))).thenReturn("INVALID"); parsingApplicationBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0); Assert.assertEquals(1, messages.size()); Assert.assertEquals("error", messages.get(0).getTopic());  Map<String, Object> parsed = JSON_READER.readValue(messages.get(0).getMessage()); Assert.assertEquals("RAW_LOG", parsed.get("raw_message")); Assert.assertEquals("error", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("parser_error", parsed.get("error_type"));  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counters = (SiembolMetricsCounters)values.get(1); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_APP_ERROR_MESSAGES.getMetricName())); }
execute(Tuple tuple) { ParsingApplicationParser currentParser = parsingApplicationParser.get();  String source = tuple.getStringByField(ParsingApplicationTuples.SOURCE.toString()); String metadata = tuple.getStringByField(ParsingApplicationTuples.METADATA.toString()); Object logObj = tuple.getValueByField(ParsingApplicationTuples.LOG.toString()); if (!(logObj instanceof byte[])) { throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLE); }  byte[] log = (byte[]) logObj; ArrayList<ParsingApplicationResult> results = currentParser.parse(source, metadata, log);  var kafkaWriterMessages = new KafkaWriterMessages(); var counters = new SiembolMetricsCounters(); for (var result : results) { if (result.getResultFlags().contains(ParsingApplicationResult.ResultFlag.FILTERED)) { metricsRegistrar.registerCounter( SiembolMetrics.PARSING_SOURCE_TYPE_FILTERED_MESSAGES.getMetricName(result.getSourceType())) .increment(); metricsRegistrar.registerCounter(SiembolMetrics.PARSING_APP_FILTERED_MESSAGES.getMetricName()) .increment(); } else { result.getMessages().forEach(x -> { kafkaWriterMessages.add(new KafkaWriterMessage(result.getTopic(), x)); addCounters(counters, result.getResultFlags(), result.getSourceType()); }); } }  if (!kafkaWriterMessages.isEmpty()) { collector.emit(tuple, new Values(kafkaWriterMessages, counters)); }  collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: Exception { parsingAttributes.setApplicationParserSpecification(simpleSingleApplicationParser.replace( ""parse_metadata" : false", ""parse_metadata" : true" ));  parsingApplicationBolt = new ParsingApplicationBolt(attributes, parsingAttributes, zooKeeperConnectorFactory, metricsTestRegistrarFactory); parsingApplicationBolt.prepare(null, null, collector); parsingApplicationBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0); Assert.assertEquals(1, messages.size()); Assert.assertEquals("output", messages.get(0).getTopic());  Map<String, Object> parsed = JSON_READER.readValue(messages.get(0).getMessage()); Assert.assertEquals("RAW_LOG", parsed.get(SiembolMessageFields.ORIGINAL.toString())); Assert.assertEquals("single", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals(true, parsed.get("metadata_is_metadata"));  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counters = (SiembolMetricsCounters)values.get(1); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_APP_PARSED_MESSAGES.getMetricName())); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_SOURCE_TYPE_PARSED_MESSAGES .getMetricName("single"))); }
execute(Tuple tuple) { ParsingApplicationParser currentParser = parsingApplicationParser.get();  String source = tuple.getStringByField(ParsingApplicationTuples.SOURCE.toString()); String metadata = tuple.getStringByField(ParsingApplicationTuples.METADATA.toString()); Object logObj = tuple.getValueByField(ParsingApplicationTuples.LOG.toString()); if (!(logObj instanceof byte[])) { throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLE); }  byte[] log = (byte[]) logObj; ArrayList<ParsingApplicationResult> results = currentParser.parse(source, metadata, log);  var kafkaWriterMessages = new KafkaWriterMessages(); var counters = new SiembolMetricsCounters(); for (var result : results) { if (result.getResultFlags().contains(ParsingApplicationResult.ResultFlag.FILTERED)) { metricsRegistrar.registerCounter( SiembolMetrics.PARSING_SOURCE_TYPE_FILTERED_MESSAGES.getMetricName(result.getSourceType())) .increment(); metricsRegistrar.registerCounter(SiembolMetrics.PARSING_APP_FILTERED_MESSAGES.getMetricName()) .increment(); } else { result.getMessages().forEach(x -> { kafkaWriterMessages.add(new KafkaWriterMessage(result.getTopic(), x)); addCounters(counters, result.getResultFlags(), result.getSourceType()); }); } }  if (!kafkaWriterMessages.isEmpty()) { collector.emit(tuple, new Values(kafkaWriterMessages, counters)); }  collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: Exception { Assert.assertEquals(1, metricsTestRegistrarFactory.getCounterValue(SiembolMetrics.PARSING_CONFIGS_UPDATE.getMetricName()));  zooKeeperConnectorFactory.getZooKeeperConnector(parsersPath).setData("INVALID");  Assert.assertEquals(1, metricsTestRegistrarFactory.getCounterValue(SiembolMetrics.PARSING_CONFIGS_UPDATE.getMetricName())); Assert.assertEquals(1, metricsTestRegistrarFactory .getCounterValue(SiembolMetrics.PARSING_CONFIGS_ERROR_UPDATE.getMetricName()));  parsingApplicationBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0); Assert.assertEquals(1, messages.size()); Assert.assertEquals("output", messages.get(0).getTopic());  Map<String, Object> parsed = JSON_READER.readValue(messages.get(0).getMessage()); Assert.assertEquals("RAW_LOG", parsed.get(SiembolMessageFields.ORIGINAL.toString())); Assert.assertEquals("single", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertNull(parsed.get("metadata_is_metadata"));  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counters = (SiembolMetricsCounters)values.get(1); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_APP_PARSED_MESSAGES.getMetricName())); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_SOURCE_TYPE_PARSED_MESSAGES .getMetricName("single"))); }
execute(Tuple tuple) { ParsingApplicationParser currentParser = parsingApplicationParser.get();  String source = tuple.getStringByField(ParsingApplicationTuples.SOURCE.toString()); String metadata = tuple.getStringByField(ParsingApplicationTuples.METADATA.toString()); Object logObj = tuple.getValueByField(ParsingApplicationTuples.LOG.toString()); if (!(logObj instanceof byte[])) { throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLE); }  byte[] log = (byte[]) logObj; ArrayList<ParsingApplicationResult> results = currentParser.parse(source, metadata, log);  var kafkaWriterMessages = new KafkaWriterMessages(); var counters = new SiembolMetricsCounters(); for (var result : results) { if (result.getResultFlags().contains(ParsingApplicationResult.ResultFlag.FILTERED)) { metricsRegistrar.registerCounter( SiembolMetrics.PARSING_SOURCE_TYPE_FILTERED_MESSAGES.getMetricName(result.getSourceType())) .increment(); metricsRegistrar.registerCounter(SiembolMetrics.PARSING_APP_FILTERED_MESSAGES.getMetricName()) .increment(); } else { result.getMessages().forEach(x -> { kafkaWriterMessages.add(new KafkaWriterMessage(result.getTopic(), x)); addCounters(counters, result.getResultFlags(), result.getSourceType()); }); } }  if (!kafkaWriterMessages.isEmpty()) { collector.emit(tuple, new Values(kafkaWriterMessages, counters)); }  collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: Exception {    ProcessSimulation processSimulation = new ProcessSimulation(smartEngine);  //3. 部署流程定义 RepositoryCommandService repositoryCommandService = smartEngine .getRepositoryCommandService(); ProcessDefinition processDefinition = repositoryCommandService .deploy("simple-process-simulation.bpmn.xml").getFirstProcessDefinition(); assertEquals(14, processDefinition.getBaseElementList().size());  //List<Activity> activitieList = null;  List<Activity> activitieList = processSimulation.simulateOutcomingActivities(processDefinition.getId(), processDefinition.getVersion(), "receiveTask0", null); Assert.assertNotNull(activitieList); assertEquals(1, activitieList.size()); assertEquals("receiveTask1", activitieList.get(0).getId());  //activitieList =  processSimulation.simulateOutcomingActivities("processSimulation","1.0.0","receiveTask1", // null); //Assert.assertNotNull(activitieList); //Assert.assertEquals(0,activitieList.size());  Map<String, Object> simulationContext = new HashMap<String, Object>(2); simulationContext.put("route", "a"); activitieList = processSimulation.simulateOutcomingActivities("Process_1", "1.0.0", "receiveTask1", simulationContext); Assert.assertNotNull(activitieList); assertEquals(1, activitieList.size()); assertEquals("receiveTask_a", activitieList.get(0).getId());  simulationContext = new HashMap<String, Object>(2); simulationContext.put("route", "b"); activitieList = processSimulation.simulateOutcomingActivities("Process_1", "1.0.0", "receiveTask1", simulationContext); Assert."<AssertPlaceHolder>"; assertEquals(1, activitieList.size()); assertEquals("receiveTask_b", activitieList.get(0).getId());  }
simulateOutcomingActivities(String processDefinitionId, String processDefinitionVersion, String currentActivityId, Map<String, Object> simulationContext) {  PvmProcessDefinition pvmProcessDefinition = smartEngine.getProcessEngineConfiguration() .getAnnotationScanner().getExtensionPoint(ExtensionConstant.SERVICE, ProcessDefinitionContainer.class).getPvmProcessDefinition(processDefinitionId, processDefinitionVersion);  PvmActivity currentPvmActivity = pvmProcessDefinition.getActivities().get(currentActivityId);  if (null == currentPvmActivity) { String exceptionMessage = String.format( "No PvmActivity found for processDefinitionId :%BehaviorUtil,processDefinitionVersion :%BehaviorUtil," + "currentActivityId :%BehaviorUtil", processDefinitionId, processDefinitionVersion, currentActivityId); throw new EngineException(exceptionMessage);  } List<Activity> resultList = new ArrayList<Activity>();  simulation(currentPvmActivity, simulationContext, resultList);  return resultList; }
[*] target: assertNotNull(activitieList)
[-] pred: org. junit. Assert. assertNotNull ( activitieList )
************************************
************************************
[+] input: testFindOne() { dao.insert(entity);  ActivityInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ActivityInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>";   }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  DeploymentInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testUpdate() { dao.insert(entity);  entity.setProcessDefinitionContent("abc_content");  dao.update( entity);  DeploymentInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>";   Assert.assertTrue("abc_content".equals(result.getProcessDefinitionContent())); }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testFindOne() { dao.insert(entity);  ExecutionInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ExecutionInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testUpdate() { dao.insert(entity);  entity.setActive(true);  dao.update(entity);  ExecutionInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; Assert.assertTrue(entity.isActive());  }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ProcessInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  // 返回删除行数,去掉findAll 接口 dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert.assertNull(result);  result = dao.findOneForUpdate(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOneForUpdate(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testFindOne() { dao.insert(entity);  TaskInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.getClaimTime()); Assert.assertEquals("comment",result.getComment()); Assert.assertEquals("extension",result.getExtension()); }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  TaskInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testUpdate() { dao.insert(entity);  TaskInstanceEntity result = dao.findOne(entity.getId());  Assert.assertEquals("title", result.getTitle());   entity.setClaimUserId("assign_id_new"); Date claimTime = new Date();  entity.setClaimTime(new Date(claimTime.getTime())); Date endTime = new Date(claimTime.getTime() + 1000000); entity.setCompleteTime(endTime); entity.setPriority(333444); entity.setComment("new_comment"); entity.setExtension("new_extension"); entity.setTitle("new_title"); dao.update(entity);  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals("assign_id_new", entity.getClaimUserId()); Assert.assertEquals(claimTime, entity.getClaimTime()); Assert.assertEquals(endTime, entity.getCompleteTime()); Assert.assertEquals(333444, entity.getPriority().intValue()); Assert.assertEquals("new_comment", result.getComment()); Assert.assertEquals("new_extension", result.getExtension()); Assert.assertEquals("new_title", result.getTitle());  }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testQuery() { dao.insert(entity); TaskInstanceQueryParam param = new TaskInstanceQueryParam(); param.setExtension("extension1"); List<TaskInstanceEntity> result = dao.findTaskList(param);  Assert.assertNotNull(result); Assert.assertTrue(result.size() == 0);  param = new TaskInstanceQueryParam(); param.setExtension("extension"); param.setTitle("title"); param.setTag("tag"); param.setComment("comment"); param.setPriority(333); param.setClaimUserId("assign_id");  result = dao.findTaskList(param);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(result.size() == 1); Assert.assertTrue(  result.get(0).getExtension().equals("extension")); }
findTaskList(TaskInstanceQueryParam taskInstanceQueryParam);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: elements_removeAll() { final Music musicA = new Music( 0, "title1", "artist1", "album1", "https://www.test.com/test1.mp3", "https://www.test.com/test1.png", 60_000, System.currentTimeMillis());  final Music musicB = new Music( 0, "title2", "artist2", "album2", "https://www.test.com/test2.mp3", "https://www.test.com/test2.png", 60_000, System.currentTimeMillis());  MusicList musicList = mMusicStore.createCustomMusicList(TEST_MUSIC_LIST); musicList.getMusicElements().add(musicA); musicList.getMusicElements().add(musicB);  List<Music> musics = new ArrayList<>(); musics.add(musicA); musics.add(musicA); musics.add(musicB); musics.add(musicB);  musicList.getMusicElements().removeAll(musics);  "<AssertPlaceHolder>"; }
getSize() { return musicListEntity.size; }
[*] target: assertEquals(0, musicList.getSize())
[-] pred: org. junit. Assert. assertEquals ( 0, musicList. getSize() )
************************************
************************************
[+] input: createCustomMusicList() { final String name = "TestMusicList";  MusicList musicList = mMusicStore.createCustomMusicList(name);  assertEquals(name, musicList.getName());  boolean exception = false; try { mMusicStore.createCustomMusicList(MusicStore.MUSIC_LIST_FAVORITE); } catch (IllegalArgumentException e) { exception = true; }  "<AssertPlaceHolder>"; }
createCustomMusicList(@NonNull String name) throws IllegalArgumentException { Preconditions.checkNotNull(name); Preconditions.checkArgument(!name.isEmpty(), "name must not empty"); checkThread();  if (isBuiltInName(name)) { throw new IllegalArgumentException("Illegal music list name, conflicts with built-in name."); }  name = trimName(name);  if (isMusicListExists(name)) { MusicList musicList = getCustomMusicList(name); assert musicList != null; return musicList; }  mAllCustomMusicListName.add(name); MusicListEntity entity = new MusicListEntity(0, name, 0, MusicList.SortOrder.BY_ADD_TIME, new byte[0]); mMusicListEntityBox.put(entity); return new MusicList(entity); }
[*] target: assertTrue(exception)
[-] pred: org. junit. Assert. assertTrue ( exception )
************************************
************************************
[+] input: getLocalMusicList() { MusicList localMusicList = mMusicStore.getLocalMusicList(); "<AssertPlaceHolder>"; }
getLocalMusicList() { checkThread(); return getBuiltInMusicList(MUSIC_LIST_LOCAL_MUSIC); }
[*] target: assertNotNull(localMusicList)
[-] pred: org. junit. Assert. assertNotNull ( localMusicList )
************************************
************************************
[+] input: getFavoriteMusicList() { MusicList favoriteMusicList = mMusicStore.getFavoriteMusicList(); "<AssertPlaceHolder>"; }
getFavoriteMusicList() { checkThread(); return getBuiltInMusicList(MUSIC_LIST_FAVORITE); }
[*] target: assertNotNull(favoriteMusicList)
[-] pred: org. junit. Assert. assertNotNull ( favoriteMusicList )
************************************
************************************
[+] input: getCustomMusicList() { final String name = "TestMusicList";  mMusicStore.createCustomMusicList(name); MusicList musicList = mMusicStore.getCustomMusicList(name);  "<AssertPlaceHolder>"; assertEquals(name, musicList.getName()); }
getCustomMusicList(@NonNull String name) { Preconditions.checkNotNull(name); checkThread();  if (isBuiltInName(name)) { return null; }  MusicListEntity entity = mMusicListEntityBox.query() .equal(MusicListEntity_.name, name, QueryBuilder.StringOrder.CASE_SENSITIVE) .build() .findUnique();  if (entity == null) { return null; }  return new MusicList(entity); }
[*] target: assertNotNull(musicList)
[-] pred: org. junit. Assert. assertNotNull ( musicList )
************************************
************************************
[+] input: deleteMusicList() { final String name = "TestMusicList"; mMusicStore.createCustomMusicList(name);  MusicList musicList = mMusicStore.getCustomMusicList(name);  assertNotNull(musicList);  mMusicStore.deleteMusicList(musicList); musicList = mMusicStore.getCustomMusicList(name);  "<AssertPlaceHolder>"; }
getCustomMusicList(@NonNull String name) { Preconditions.checkNotNull(name); checkThread();  if (isBuiltInName(name)) { return null; }  MusicListEntity entity = mMusicListEntityBox.query() .equal(MusicListEntity_.name, name, QueryBuilder.StringOrder.CASE_SENSITIVE) .build() .findUnique();  if (entity == null) { return null; }  return new MusicList(entity); }
[*] target: assertNull(musicList)
[-] pred: org. junit. Assert. assertNull ( musicList )
************************************
************************************
[+] input: deleteMusicList_name() { final String name = "TestMusicList"; mMusicStore.createCustomMusicList(name);  MusicList musicList = mMusicStore.getCustomMusicList(name);  assertNotNull(musicList);  mMusicStore.deleteMusicList(name); musicList = mMusicStore.getCustomMusicList(name);  "<AssertPlaceHolder>"; }
getCustomMusicList(@NonNull String name) { Preconditions.checkNotNull(name); checkThread();  if (isBuiltInName(name)) { return null; }  MusicListEntity entity = mMusicListEntityBox.query() .equal(MusicListEntity_.name, name, QueryBuilder.StringOrder.CASE_SENSITIVE) .build() .findUnique();  if (entity == null) { return null; }  return new MusicList(entity); }
[*] target: assertNull(musicList)
[-] pred: org. junit. Assert. assertNull ( musicList )
************************************
************************************
[+] input: getMusic() { final Music music1 = new Music( 0, "title1", "artist1", "album1", "https://www.test.com/test1.mp3", "https://www.test.com/test1.png", 60_000, System.currentTimeMillis());  mMusicStore.putMusic(music1);  Music music2 = mMusicStore.getMusic(music1.getId());  "<AssertPlaceHolder>"; }
getMusic(long id) { checkThread(); return mMusicBox.get(id); }
[*] target: assertEquals(music1, music2)
[-] pred: org. junit. Assert. assertEquals ( music1, music2 )
************************************
************************************
[+] input: copyConstructorTest() { PlayerState source = new PlayerState(); source.setPlayProgress(1000); source.setPlayProgressUpdateTime(SystemClock.elapsedRealtime()); source.setMusicItem(new MusicItem()); source.setPlayPosition(15); source.setPlayMode(PlayMode.LOOP); source.setPlaybackState(PlaybackState.ERROR); source.setPreparing(false); source.setPrepared(true); source.setAudioSessionId(12); source.setBufferedProgress(100); source.setStalled(true); source.setErrorCode(ErrorCode.PLAYER_ERROR); source.setErrorMessage("player error"); source.setSleepTimerStarted(true); source.setSleepTimerTime(60_000); source.setSleepTimerStartTime(System.currentTimeMillis()); source.setTimeoutAction(SleepTimer.TimeoutAction.STOP);  PlayerState copy = new PlayerState(source);  "<AssertPlaceHolder>"; }
setTimeoutAction(@NonNull SleepTimer.TimeoutAction action) { Preconditions.checkNotNull(timeoutAction); this.timeoutAction = action; }
[*] target: assertEquals(source, copy)
[-] pred: org. junit. Assert. assertEquals ( source, copy )
************************************
************************************
[+] input: defaultConstructorTest() { MusicItem musicItem = new MusicItem();  assertNotNull(musicItem.getMusicId()); assertNotNull(musicItem.getTitle()); assertNotNull(musicItem.getArtist()); assertNotNull(musicItem.getAlbum()); assertNotNull(musicItem.getUri()); assertNotNull(musicItem.getIconUri()); assertEquals(0, musicItem.getDuration()); "<AssertPlaceHolder>"; }
isForbidSeek() { return forbidSeek; }
[*] target: assertFalse(musicItem.isForbidSeek())
[-] pred: org. junit. Assert. assertFalse ( musicItem. isForbidSeek ( ) )
************************************
************************************
[+] input: getName() { final String name = "test_name";  Playlist playlist = new Playlist.Builder() .setName(name) .build();  "<AssertPlaceHolder>"; }
getName() { return mName; }
[*] target: assertEquals(name, playlist.getName())
[-] pred: org. junit. Assert. assertEquals ( name, playlist. getName() )
************************************
************************************
[+] input: isEmpty() { assertFalse(mPlaylist.isEmpty());  Playlist playlist = new Playlist.Builder() .build();  "<AssertPlaceHolder>"; }
isEmpty() { return mMusicItems.isEmpty(); }
[*] target: assertTrue(playlist.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( playlist. isEmpty() )
************************************
************************************
[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier(); try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL();  Properties p = new Properties(); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder( p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph(); Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv"); expected.add("test.json"); expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, null, null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier();   //		System.out.println("test/".matches("[^t]*"));   try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL();  Properties p = new Properties(); p.setProperty(ZipTriplifier.MATCHES.toString(), ".*(?<!\\.json)"); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder(p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph();  Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv");  expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, null, null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier(); try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL(); Properties p = new Properties(); p.setProperty(IRIArgument.BLANK_NODES.toString(), "false"); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder( p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph(); //			ModelFactory.createModelForGraph(dg.getDefaultGraph()).write(System.out, "TTL");  Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv"); expected.add("test.json"); expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, NodeFactory.createURI(Path.of(url.toURI()).toUri() + "#"), null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ScriptException { LarkyScriptEngineFactory factory = new LarkyScriptEngineFactory(); LarkyScriptEngine engine = (LarkyScriptEngine) factory.getScriptEngine(); String script = "print("Hello World!!!")"; LarkyCompiledScript instance = (LarkyCompiledScript) engine.compile(script);  Object expResult = "Larky ScriptEngine"; Object result = instance.getEngine().getFactory().getEngineName(); "<AssertPlaceHolder>"; }
getEngine() { return engine; }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: Exception { LarkyScriptEngineFactory factory = new LarkyScriptEngineFactory(); LarkyScriptEngine engine = (LarkyScriptEngine) factory.getScriptEngine(); ScriptContext context = new SimpleScriptContext(); StringWriter writer = new StringWriter(); StringWriter errorWriter = new StringWriter(); context.setWriter(writer); context.setErrorWriter(errorWriter);  context.setAttribute("message", "Hello World!!!!!", ScriptContext.ENGINE_SCOPE); engine.setContext(context); String script = "print(message)"; LarkyCompiledScript instance = (LarkyCompiledScript) engine.compile(script); Object expResult = "Hello World!!!!!"; instance.eval(context); Object result = writer.toString().trim(); "<AssertPlaceHolder>"; writer.close(); errorWriter.close(); }
eval(ScriptContext context) throws LarkyEvaluationScriptException { ParsedStarFile result; Bindings globalBindings = context.getBindings(ScriptContext.GLOBAL_SCOPE); Bindings engineBindings = context.getBindings(ScriptContext.ENGINE_SCOPE);  try (Reader reader = context.getReader()) { final StarFile script = InMemMapBackedStarFile.createStarFile(DEFAULT_SCRIPT_NAME, CharStreams.toString(reader)); final DefaultLarkyInterpreter larkyInterpreter = new DefaultLarkyInterpreter(LARKY_MODE, globalBindings, engineBindings); result = larkyInterpreter.evaluate(script, context.getWriter()); } catch (IOException | StarlarkEvalWrapper.Exc.RuntimeEvalException | Starlark.UncheckedEvalException | EvalException e) { throw LarkyEvaluationScriptException.of(e); } setBindingsValue(globalBindings, engineBindings, result.getGlobals()); return result; }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: toBytes() { StarlarkBytes big = null; try (Mutability mu = Mutability.create("test")) { StarlarkThread thread = new StarlarkThread(mu, StarlarkSemantics.DEFAULT); big = CryptoMathModule.INSTANCE.toBytes(StarlarkInt.of(0x1122334455667788L), StarlarkInt.of(0), "big", false, thread); } catch (EvalException e) { fail(e.getMessageWithStack()); } "<AssertPlaceHolder>"; int[] unsignedBytes = big.getUnsignedBytes(); assertArrayEquals(unsignedBytes, new int[]{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88});  }
toBytes(StarlarkInt integer, StarlarkInt byteCount, String byteorder, boolean signed, StarlarkThread thread) throws EvalException { // if we're trying to pack a very big integer.. BigInteger value = integer.toBigInteger(); byte[] bytes; int nbytes = byteCount.toInt("toBytes()"); boolean minimizeLeadingZeroPads = false; if (nbytes == 0) { minimizeLeadingZeroPads = true; nbytes = NumOpsUtils.bytesToPackValueToPrimitive(value); } try { if (MAX_LONG.compareTo(value) > 0) { bytes = NumOpsUtils.longlong2byte( value.longValueExact(), nbytes, isBigEndian(byteorder), signed); } else { bytes = NumOpsUtils.bigint2byte( value, nbytes, isBigEndian(byteorder), signed); } } catch (IllegalArgumentException ex) { throw new EvalException( String.format("ValueError or OverflowError: %s", ex.getMessage()), ex.fillInStackTrace()); }  //System.out.printf("bytes.length: %d, nbytes: %s, array: %s %n", bytes.length, nbytes, Arrays.toString(bytes)); if (minimizeLeadingZeroPads) { bytes = ByteArrayUtil.lstrip(bytes, new byte[]{0x00}); } return StarlarkBytes.of(thread.mutability(), bytes); //    return StarlarkBytes.builder(thread).setSequence(bytes).build(); }
[*] target: assertNotNull(big)
[-] pred: org. junit. Assert. assertNotNull ( big )
************************************
************************************
[+] input: NoSuchAlgorithmException { byte[] expected = new byte[]{0x4b, (byte) 0xa4, (byte) 0xac, 0x39, 0x25, (byte) 0xc0, (byte) 0xe8, (byte) 0xd7, (byte) 0xf0, (byte) 0xcd, (byte) 0xb6, (byte) 0xbb, 0x16, (byte) 0x84, (byte) 0xa5, 0x6f}; byte[] key = BCryptKDF.bcrypt_pbkdf("pass\u0000word".getBytes(), "sa\u0000lt".getBytes(), expected.length, 4); "<AssertPlaceHolder>"; }
bcrypt_pbkdf(byte[] pass, byte[] salt, int keylen, int rounds) throws NoSuchAlgorithmException { byte[] sha2salt; byte[] out = new byte[BCRYPT_HASHSIZE]; byte[] tmpout; byte[] countsalt = new byte[4]; int i, j, amt; int count; byte[] key = new byte[keylen]; int origkeylen = keylen;  if (rounds < 1) throw new IllegalArgumentException("Not enough rounds.");  if (pass.length == 0 || salt.length == 0 || keylen == 0 || keylen > (out.length * out.length)) throw new IllegalArgumentException("Invalid pass, salt or key.");  int stride = (keylen + out.length - 1) / out.length; amt = (keylen + stride - 1) / stride;  /* collapse password */ MessageDigest ctx = MessageDigest.getInstance("SHA-512"); ctx.update(pass); byte[] sha2pass = ctx.digest();  /* generate key, sizeof(out) at a time */ for (count = 1; keylen > 0; count++) { countsalt[0] = (byte) ((count >> 24) & 0xff); countsalt[1] = (byte) ((count >> 16) & 0xff); countsalt[2] = (byte) ((count >> 8) & 0xff); countsalt[3] = (byte) (count & 0xff);  /* first round, salt is salt */ ctx.reset(); ctx.update(salt); ctx.update(countsalt); sha2salt = ctx.digest();  tmpout = bcrypt_hash(sha2pass, sha2salt); System.arraycopy(tmpout, 0, out, 0, out.length);  for (i = 1; i < rounds; i++) { /* subsequent rounds, salt is previous output */ ctx.reset(); ctx.update(tmpout); sha2salt = ctx.digest(); tmpout = bcrypt_hash(sha2pass, sha2salt); for (j = 0; j < out.length; j++) out[j] ^= tmpout[j]; }  /* * pbkdf2 deviation: output the key material non-linearly. */ amt = Math.min(amt, keylen); for (i = 0; i < amt; i++) { int dest = i * stride + (count - 1); if (dest >= origkeylen) break; key[dest] = out[i]; } keylen -= i; }  return key; }
[*] target: assertArrayEquals(expected, key)
[-] pred: org. junit. Assert. assertArrayEquals ( expected, key )
************************************
************************************
[+] input: optionsForNoAttendees() { MeetingRequest request = new MeetingRequest(NO_ATTENDEES, DURATION_1_HOUR);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: noOptionsForTooLongOfARequest() { // The duration should be longer than a day. This means there should be no options. int duration = TimeRange.WHOLE_DAY.duration() + 1; MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), duration);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList();  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: eventSplitsRestriction() { // The event should split the day into two options (before and after the event). Collection<Event> events = Arrays.asList(new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: everyAttendeeIsConsidered() { // Have each person have different events. We should see two options because each person has // split the restricted times. // // Events  :       |--A--|     |--B--| // Day     : |-----------------------------| // Options : |--1--|     |--2--|     |--3--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0800AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0800AM, false), TimeRange.fromStartEnd(TIME_0830AM, TIME_0900AM, false), TimeRange.fromStartEnd(TIME_0930AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: overlappingEvents() { // Have an event for each person, but have their events overlap. We should only see two options. // // Events  :       |--A--| //                     |--B--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_60_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_60_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_1000AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: nestedEvents() { // Have an event for each person, but have one person's event fully contain another's event. We // should see two options. // // Events  :       |----A----| //                   |--B--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_90_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_1000AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: doubleBookedPeople() { // Have one person, but have them registered to attend two events at the same time. // // Events  :       |----A----| //                     |--A--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_60_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_0930AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: justEnoughRoom() { // Have one person, but make it so that there is just enough room at one point in the day to // have the meeting. // // Events  : |--A--|     |----A----| // Day     : |---------------------| // Options :       |-----|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartDuration(TIME_0830AM, DURATION_30_MINUTES));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ignoresPeopleNotAttending() { // Add an event, but make the only attendee someone different from the person looking to book // a meeting. This event should not affect the booking. Collection<Event> events = Arrays.asList(new Event("Event 1", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A))); MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: noConflicts() { MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: notEnoughRoom() { // Have one person, but make it so that there is not enough room at any point in the day to // have the meeting. // // Events  : |--A-----| |-----A----| // Day     : |---------------------| // Options :  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_60_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList();  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: CantAddOptionalAttendeeWhoIsAlsoMandatory() { MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_1_HOUR); request.addOptionalAttendee(PERSON_A);  int actual = request.getOptionalAttendees().size(); int expected = 0; Assert."<AssertPlaceHolder>"; }
getOptionalAttendees() { return Collections.unmodifiableCollection(optional_attendees); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testNormalizeValidPhoneNumber() { { String inputPhoneNumber = "+1 650-555-1234"; String expectedNormalizedPhoneNumber = "+16505551234"; String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); assertEquals(expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber); } { String inputPhoneNumber = "+640223334444"; String expectedNormalizedPhoneNumber = "+64223334444"; String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); "<AssertPlaceHolder>"; } }
normalizeIfPhoneNumber(String phoneNumber) { if (phoneNumber == null) { return null; }  PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();  try { // Attempt to parse the phone number with default region code "ZZ" (unknown // region) Phonenumber.PhoneNumber parsedPhoneNumber = phoneNumberUtil.parse(phoneNumber.trim(), "ZZ");  // Format the parsed phone number according to E.164 standard phoneNumber = phoneNumberUtil.format(parsedPhoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164); } catch (NumberParseException e) { // Parsing failed, use the original trimmed phone number phoneNumber = phoneNumber.trim(); }  return phoneNumber; }
[*] target: assertEquals(expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber)
[-] pred: org. junit. Assert. assertEquals ( expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber )
************************************
************************************
[+] input: testNormalizeInvalidPhoneNumber() { String inputPhoneNumber = "  johndoe@gmail.com  "; String expectedTrimmedPhoneNumber = inputPhoneNumber.trim(); String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); "<AssertPlaceHolder>"; }
normalizeIfPhoneNumber(String phoneNumber) { if (phoneNumber == null) { return null; }  PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();  try { // Attempt to parse the phone number with default region code "ZZ" (unknown // region) Phonenumber.PhoneNumber parsedPhoneNumber = phoneNumberUtil.parse(phoneNumber.trim(), "ZZ");  // Format the parsed phone number according to E.164 standard phoneNumber = phoneNumberUtil.format(parsedPhoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164); } catch (NumberParseException e) { // Parsing failed, use the original trimmed phone number phoneNumber = phoneNumber.trim(); }  return phoneNumber; }
[*] target: assertEquals(expectedTrimmedPhoneNumber, actualNormalizedPhoneNumber)
[-] pred: org. junit. Assert. assertEquals ( expectedTrimmedPhoneNumber, actualNormalizedPhoneNumber )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // format for Firebase SCrypt hashes stored in supertokens. // $f_scrypt$passwordHash$salt$m=memory$r=rounds$s=saltSeparator  String passwordHash = "passwordHash"; String salt = "salt"; int memory = 14; int rounds = 8; String saltSeparator = "Bw==";  // when password hash is in the regular format { String validPasswordHash = "$" + ParsedFirebaseSCryptResponse.FIREBASE_SCRYPT_PREFIX + "$" + passwordHash + "$" + salt + "$" + "m=" + memory + "$" + "r=" + rounds + "$" + "s=" + saltSeparator;  ParsedFirebaseSCryptResponse response = ParsedFirebaseSCryptResponse.fromHashString(validPasswordHash); assertNotNull(response);  assertEquals(passwordHash, response.passwordHash); assertEquals(salt, response.salt); assertEquals(memory, response.memCost); assertEquals(saltSeparator, response.saltSeparator); }  // with memory, rounds and saltSeparator switched around { String validPasswordHash = "$" + ParsedFirebaseSCryptResponse.FIREBASE_SCRYPT_PREFIX + "$" + passwordHash + "$" + salt + "$" + "s=" + saltSeparator + "$" + "m=" + memory + "$" + "r=" + rounds;  ParsedFirebaseSCryptResponse response = ParsedFirebaseSCryptResponse.fromHashString(validPasswordHash); "<AssertPlaceHolder>";  assertEquals(passwordHash, response.passwordHash); assertEquals(salt, response.salt); assertEquals(memory, response.memCost); assertEquals(saltSeparator, response.saltSeparator); }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
fromHashString(String hash) { try { String[] separatedPasswordHash = hash.split(FIREBASE_SCRYPT_SEPARATOR);  // check that stored password hash contains 7 fields and after splitting, the first field is empty and the // second field has the firebase scrypt prefix if (!(separatedPasswordHash.length == 7 && separatedPasswordHash[0].equals("") && separatedPasswordHash[1].equals(FIREBASE_SCRYPT_PREFIX))) { return null; }  String passwordHash = separatedPasswordHash[2]; String salt = separatedPasswordHash[3]; String saltSeparator = null; Integer memCost = null; Integer rounds = null;  for (int i = 4; i < separatedPasswordHash.length; i++) { if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_MEM_COST_SEPARATOR)) { memCost = Integer.parseInt(separatedPasswordHash[i].split(FIREBASE_SCRYPT_MEM_COST_SEPARATOR)[1]); continue; } if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_ROUNDS_SEPARATOR)) { rounds = Integer.parseInt(separatedPasswordHash[i].split(FIREBASE_SCRYPT_ROUNDS_SEPARATOR)[1]); continue; } if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_SALT_SEPARATOR)) { saltSeparator = separatedPasswordHash[i].split(FIREBASE_SCRYPT_SALT_SEPARATOR)[1]; } }  if (passwordHash == null || salt == null || saltSeparator == null || memCost == null || rounds == null) { return null; } return new ParsedFirebaseSCryptResponse(passwordHash, salt, saltSeparator, rounds, memCost); } catch (Throwable e) { return null; } }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: IOException { String[] args = {"../"};  Utils.setValueInConfig("access_token_validity", "-1"); TestingProcessManager.TestingProcess process = TestingProcessManager.start(args, false); FeatureFlagTestContent.getInstance(process.getProcess()) .setKeyValue(FeatureFlagTestContent.ENABLED_FEATURES, new EE_FEATURES[]{EE_FEATURES.MULTI_TENANCY}); process.startProcess();  ProcessState.EventAndException e = process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.INIT_FAILURE); "<AssertPlaceHolder>"; assertEquals(e.exception.getCause().getMessage(), "'access_token_validity' must be between 1 and 86400000 seconds inclusive. The config file can be " + "found here: " + getConfigFileLocation(process.getProcess()));  assertNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.LOADING_ALL_TENANT_CONFIG, 1000));  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getInstance(Start start) { return (Config) start.getResourceDistributor() .getResource(RESOURCE_KEY); }
[*] target: assertNotNull(e)
[-] pred: org. junit. Assert. assertNotNull ( e )
************************************
************************************
[+] input: Exception { { TestInput input = new TestInput("value"); io.supertokens.utils.Utils.PubPriKey rsa = io.supertokens.utils.Utils.generateNewPubPriKey(); String token = JWT.createAndSignLegacyAccessToken(new Gson().toJsonTree(input), rsa.privateKey, AccessToken.VERSION.V1); TestInput output = new Gson().fromJson( JWT.verifyJWTAndGetPayload(JWT.preParseJWTInfo(token), rsa.publicKey).payload, TestInput.class); assertEquals(input, output); }  { TestInput input = new TestInput("value"); io.supertokens.utils.Utils.PubPriKey rsa = io.supertokens.utils.Utils.generateNewPubPriKey(); String token = JWT.createAndSignLegacyAccessToken(new Gson().toJsonTree(input), rsa.privateKey, AccessToken.VERSION.V2); TestInput output = new Gson().fromJson( JWT.verifyJWTAndGetPayload(JWT.preParseJWTInfo(token), rsa.publicKey).payload, TestInput.class); "<AssertPlaceHolder>"; } }
preParseJWTInfo(String jwt) throws JWTException { initHeader(); String[] splittedInput = jwt.split("\\."); if (splittedInput.length != 3) { throw new JWTException("Invalid JWT"); }  if (splittedInput[0].equals(JWT.HEADERv1)) { return new JWTPreParseInfo(splittedInput, AccessToken.VERSION.V1, null); }  if (splittedInput[0].equals(JWT.HEADERv2)) { return new JWTPreParseInfo(splittedInput, AccessToken.VERSION.V2, null); }  JsonObject parsedHeader = new JsonParser().parse(Utils.convertFromBase64(splittedInput[0])).getAsJsonObject();  if (parsedHeader.get("typ") == null) { throw new JWTException("JWT header missing - typ"); } JsonPrimitive typ = parsedHeader.get("typ").getAsJsonPrimitive(); if (!typ.isString() || !typ.getAsString().equals("JWT")) { throw new JWTException("JWT header mismatch - typ"); }  if (parsedHeader.get("alg") == null) { throw new JWTException("JWT header missing - alg"); } JsonPrimitive alg = parsedHeader.get("alg").getAsJsonPrimitive(); if (!alg.isString() || !alg.getAsString().equals("RS256")) { throw new JWTException("JWT header mismatch - alg"); }  JsonElement versionElement = parsedHeader.get("version"); // We default to using the latest access token version here for JWTs not created by the session recipe String versionString = AccessToken.getVersionStringFromAccessTokenVersion(AccessToken.getLatestVersion());  if (versionElement != null) { JsonPrimitive version = versionElement.getAsJsonPrimitive(); if (!version.isString() || version.getAsString().equals("1") || version.getAsString().equals("2")) { throw new JWTException("JWT header mismatch - version"); }  versionString = version.getAsString(); }  JsonPrimitive kid = parsedHeader.get("kid").getAsJsonPrimitive(); if (parsedHeader.get("kid") == null) { throw new JWTException("JWT header missing - kid"); } if (!kid.isString()) { throw new JWTException("JWT header mismatch - kid"); } return new JWTPreParseInfo(splittedInput, AccessToken.getVersionFromString(versionString), kid.getAsString()); }
[*] target: assertEquals(input, output)
[-] pred: org. junit. Assert. assertEquals ( input, output )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create a user AuthRecipeUserInfo userInfo = EmailPassword.signUp(process.main, "test@example.com", "testPassword");  String externalUserId = "external-test";  UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), externalUserId, null, false);  { // duplicate exception with both supertokensUserId and externalUserId Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), externalUserId, null, false); } catch (Exception e) { error = e; }  assertNotNull(error); assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertTrue(usersIdMappingExistsError.doesExternalUserIdExist); assertTrue(usersIdMappingExistsError.doesSuperTokensUserIdExist); }  { // duplicate exception with superTokensUserId Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), "newExternalId", null, false); } catch (Exception e) { error = e; }  assertNotNull(error); assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertFalse(usersIdMappingExistsError.doesExternalUserIdExist); assertTrue(usersIdMappingExistsError.doesSuperTokensUserIdExist);  }  { // duplicate exception with externalUserId  AuthRecipeUserInfo newUser = EmailPassword.signUp(process.main, "test2@example.com", "testPass123"); Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, newUser.getSupertokensUserId(), externalUserId, null, false); } catch (Exception e) { error = e; }  "<AssertPlaceHolder>"; assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertTrue(usersIdMappingExistsError.doesExternalUserIdExist); assertFalse(usersIdMappingExistsError.doesSuperTokensUserIdExist);  }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  ArrayList<String> nonAuthRecipesWhichDontNeedUserIdMapping = new ArrayList<>( List.of("io.supertokens.pluginInterface.jwt.JWTRecipeStorage", ActiveUsersStorage.class.getName())); Reflections reflections = new Reflections("io.supertokens.pluginInterface"); Set<Class<? extends NonAuthRecipeStorage>> classes = reflections.getSubTypesOf(NonAuthRecipeStorage.class); List<String> names = classes.stream().map(Class::getCanonicalName).collect(Collectors.toList()); List<String> classNames = new ArrayList<>(); for (String name : names) { if (!name.contains("SQLStorage")) { classNames.add(name); } } String externalId = "externalId"; for (String className : classNames) { // Create a User AuthRecipeUserInfo user = EmailPassword.signUp(process.main, "test@example.com", "testPass123");  // create a mapping with the user UserIdMapping.createUserIdMapping(process.main, user.getSupertokensUserId(), externalId, null, false);  // create entry in nonAuth table with externalId StorageLayer.getStorage(process.main) .addInfoToNonAuthRecipesBasedOnUserId(TenantIdentifier.BASE_TENANT, className, externalId);  // try to delete UserIdMapping String errorMessage = null; try { UserIdMapping.deleteUserIdMapping(process.main, user.getSupertokensUserId(), UserIdType.SUPERTOKENS, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } if (!nonAuthRecipesWhichDontNeedUserIdMapping.contains(className)) { "<AssertPlaceHolder>"; assertTrue(errorMessage.contains("UserId is already in use")); } // delete user data AuthRecipe.deleteUser(process.main, user.getSupertokensUserId()); }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
deleteUserIdMapping(Main main, String userId, UserIdType userIdType, boolean force) throws StorageQueryException, ServletException { Storage storage = StorageLayer.getStorage(main); return deleteUserIdMapping( new AppIdentifier(null, null), storage, userId, userIdType, force); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create an EmailPassword User AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123"); // create a mapping for the EmailPassword User UserIdMapping.createUserIdMapping(process.main, user_1.getSupertokensUserId(), "externalId", null, false);  // create some metadata for the user JsonObject data = new JsonObject(); data.addProperty("test", "testData"); UserMetadata.updateUserMetadata(process.main, "externalId", data);  // Create another User AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@example.com", "testPass123");  // try and map user_2 to user_1s superTokensUserId String errorMessage = null; try { UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } "<AssertPlaceHolder>"; assertEquals("Cannot create a userId mapping where the externalId is also a SuperTokens userID", errorMessage);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create user 1 AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123");  // create user 2 AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@example.com", "testPass123");  // create a mapping between User_1 and User_2 with force UserIdMapping.createUserIdMapping(process.main, user_1.getSupertokensUserId(), user_2.getSupertokensUserId(), null, true);  // try and create a mapping between User_2 and User_1 without force String errorMessage = null; try { UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } "<AssertPlaceHolder>"; assertEquals("Cannot create a userId mapping where the externalId is also a SuperTokens userID", errorMessage);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create User_1 and User_2 AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123"); AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@exmaple.com", "testPass123");  // create a mapping between User_2 and User_1 with force UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, true);  // check that mapping exists { io.supertokens.pluginInterface.useridmapping.UserIdMapping mapping = UserIdMapping .getUserIdMapping(process.main, user_2.getSupertokensUserId(), UserIdType.SUPERTOKENS); assertNotNull(mapping); assertEquals(mapping.superTokensUserId, user_2.getSupertokensUserId()); assertEquals(mapping.externalUserId, user_1.getSupertokensUserId()); }  // delete mapping with User_1s Id and UserIdType set to ANY, it should delete the mapping assertTrue( UserIdMapping.deleteUserIdMapping(process.main, user_1.getSupertokensUserId(), UserIdType.ANY, false));  // check that mapping is deleted { io.supertokens.pluginInterface.useridmapping.UserIdMapping mapping = UserIdMapping .getUserIdMapping(process.main, user_2.getSupertokensUserId(), UserIdType.SUPERTOKENS); "<AssertPlaceHolder>"; }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserIdMapping( Main main, String userId, UserIdType userIdType) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserIdMapping(new AppIdentifier(null, null), storage, userId, userIdType); }
[*] target: assertNull(mapping)
[-] pred: org. junit. Assert. assertNull ( mapping )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create User_1 and User_2 AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123"); AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@exmaple.com", "testPass123");  // create a mapping between User_2 and User_1 with force UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, true);  // check that mapping exists { io.supertokens.pluginInterface.useridmapping.UserIdMapping mapping = UserIdMapping .getUserIdMapping(process.main, user_2.getSupertokensUserId(), UserIdType.SUPERTOKENS); assertNotNull(mapping); assertEquals(mapping.superTokensUserId, user_2.getSupertokensUserId()); assertEquals(mapping.externalUserId, user_1.getSupertokensUserId()); }  // delete mapping with User_1s Id and UserIdType set to ANY, it should delete the mapping assertTrue( UserIdMapping.deleteUserIdMapping(process.main, user_1.getSupertokensUserId(), UserIdType.SUPERTOKENS, false));  // check that mapping is deleted { io.supertokens.pluginInterface.useridmapping.UserIdMapping mapping = UserIdMapping .getUserIdMapping(process.main, user_2.getSupertokensUserId(), UserIdType.SUPERTOKENS); "<AssertPlaceHolder>"; }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserIdMapping( Main main, String userId, UserIdType userIdType) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserIdMapping(new AppIdentifier(null, null), storage, userId, userIdType); }
[*] target: assertNull(mapping)
[-] pred: org. junit. Assert. assertNull ( mapping )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  String userId = "userId"; JsonObject metadata = UserMetadata.getUserMetadata(process.getProcess(), userId);  "<AssertPlaceHolder>"; assertEquals(metadata.entrySet().size(), 0);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserMetadata(Main main, @Nonnull String userId) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserMetadata(new AppIdentifier(null, null), storage, userId); }
[*] target: assertNotNull(metadata)
[-] pred: org. junit. Assert. assertNotNull ( metadata )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  String userId = "userId"; JsonObject update = new JsonObject(); update.addProperty("test", "123"); update.add("testNull", JsonNull.INSTANCE); JsonObject updateResult = UserMetadata.updateUserMetadata(process.getProcess(), userId, update);  JsonObject newMetadata = UserMetadata.getUserMetadata(process.getProcess(), userId);  "<AssertPlaceHolder>"; assertEquals(1, updateResult.entrySet().size()); assertEquals("123", updateResult.get("test").getAsString()); assert (!updateResult.has("testNull"));  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserMetadata(Main main, @Nonnull String userId) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserMetadata(new AppIdentifier(null, null), storage, userId); }
[*] target: assertEquals(updateResult, newMetadata)
[-] pred: org. junit. Assert. assertEquals ( updateResult, newMetadata )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  String userId = "userId";  JsonObject originalMetadata = new JsonObject(); JsonObject subObject = new JsonObject(); subObject.addProperty("subsub", "123"); originalMetadata.add("testUpdate", subObject); originalMetadata.addProperty("unmodified", "123"); originalMetadata.addProperty("cleared", 123);  // First we create the original UserMetadata.updateUserMetadata(process.getProcess(), userId, originalMetadata);  JsonObject update = new JsonObject(); JsonObject updateSubObject = new JsonObject(); updateSubObject.addProperty("subsubupdate", "subnew!"); update.add("testUpdate", updateSubObject); update.addProperty("testNew", "new!"); update.add("cleared", JsonNull.INSTANCE);  JsonObject updateResult = UserMetadata.updateUserMetadata(process.getProcess(), userId, update);  JsonObject newMetadata = UserMetadata.getUserMetadata(process.getProcess(), userId);  "<AssertPlaceHolder>";  // We removed what we set to null assert (!newMetadata.has("cleared"));  // The old metadata is left intact assertEquals("123", newMetadata.get("unmodified").getAsString());  JsonObject newSubObj = newMetadata.getAsJsonObject("testUpdate"); // The up assertEquals(1, newSubObj.entrySet().size()); assertEquals("subnew!", newSubObj.get("subsubupdate").getAsString());  assert (newMetadata.has("testNew")); assertEquals("new!", newMetadata.get("testNew").getAsString());  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserMetadata(Main main, @Nonnull String userId) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserMetadata(new AppIdentifier(null, null), storage, userId); }
[*] target: assertEquals(updateResult, newMetadata)
[-] pred: org. junit. Assert. assertEquals ( updateResult, newMetadata )
************************************
************************************
[+] input: givenClientSessionDetails_whenGetSessionInfo_thenReturnExpectedResult() { UUID sessionId = UUID.randomUUID(); String clientId = "clientId"; MqttConnectMsg msg = getMqttConnectMsg(sessionId, clientId); SessionInfo actualSessionInfo = connectService.getSessionInfo(msg, sessionId, clientId, ClientType.DEVICE, 0, BrokerConstants.LOCAL_ADR);  SessionInfo expectedSessionInfo = ClientSessionInfoFactory.getSessionInfo( sessionId, false, SERVICE_ID, getClientInfo(clientId), getConnectionInfo(1000, actualSessionInfo.getConnectionInfo().getConnectedAt()), 0);  Assert."<AssertPlaceHolder>"; }
getSessionInfo(MqttConnectMsg msg, UUID sessionId, String clientId, ClientType clientType, int sessionExpiryInterval, byte[] clientIpAdr) { return ClientSessionInfoFactory.getSessionInfo( sessionId, msg.isCleanStart(), serviceInfoProvider.getServiceId(), new ClientInfo(clientId, clientType, clientIpAdr), ClientSessionInfoFactory.getConnectionInfo(msg.getKeepAliveTimeSeconds()), sessionExpiryInterval); }
[*] target: assertEquals(expectedSessionInfo, actualSessionInfo)
[-] pred: org. junit. Assert. assertEquals ( expectedSessionInfo, actualSessionInfo )
************************************
************************************
[+] input: givenConnectPacketForMqtt3Client_whenGetReceiveMaxValue_thenGetExpectedValue() { connectService.setMqtt3xReceiveMax(10);  MqttConnectMsg mqttConnectMsg = getMqttConnectMsg(UUID.randomUUID(), "testClient"); int receiveMaxValue = connectService.getReceiveMaxValue(mqttConnectMsg, ctx); Assert."<AssertPlaceHolder>"; }
getReceiveMaxValue(MqttConnectMsg msg, ClientSessionCtx ctx) { return MqttVersion.MQTT_5 == ctx.getMqttVersion() ? MqttPropertiesUtil.getReceiveMaxValue(msg.getProperties()) : mqtt3xReceiveMax; }
[*] target: assertEquals(10, receiveMaxValue)
[-] pred: org. junit. Assert. assertEquals ( 10, receiveMaxValue )
************************************
************************************
[+] input: givenConnectPacketWithReceiveMaxForMqtt5Client_whenGetReceiveMaxValue_thenGetExpectedValue() { when(ctx.getMqttVersion()).thenReturn(MqttVersion.MQTT_5); connectService.setMqtt3xReceiveMax(10);  MqttProperties properties = new MqttProperties(); properties.add(new MqttProperties.IntegerProperty(MqttProperties.MqttPropertyType.RECEIVE_MAXIMUM.value(), 20)); MqttConnectMsg mqttConnectMsg = getMqttConnectMsg(UUID.randomUUID(), "testClient", null, properties);  int receiveMaxValue = connectService.getReceiveMaxValue(mqttConnectMsg, ctx); Assert."<AssertPlaceHolder>"; }
getReceiveMaxValue(MqttConnectMsg msg, ClientSessionCtx ctx) { return MqttVersion.MQTT_5 == ctx.getMqttVersion() ? MqttPropertiesUtil.getReceiveMaxValue(msg.getProperties()) : mqtt3xReceiveMax; }
[*] target: assertEquals(20, receiveMaxValue)
[-] pred: org. junit. Assert. assertEquals ( 20, receiveMaxValue )
************************************
************************************
[+] input: givenSuccessReasonCode_whenCheckIfReasonCodeFailure_thenReturnFalse() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.SUCCESS)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenFailureReasonCode_whenCheckIfReasonCodeFailure_thenReturnTrue() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenOtherFailureReasonCode_whenCheckIfReasonCodeFailure_thenReturnTrue() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.PAYLOAD_FORMAT_INVALID)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenRetainedMsgSetAndTotalMsgsLimitEnabled_whenApplyRateLimitsWithNoTokensLeft_thenReturnEmptyResult() { when(rateLimitService.isTotalMsgsLimitEnabled()).thenReturn(true); when(rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(anyLong())).thenReturn(0L);  Set<RetainedMsg> retainedMsgs = mqttSubscribeHandler.applyRateLimits(Set.of( newRetainedMsg("msg1", 1), newRetainedMsg("msg2", 2) ));  "<AssertPlaceHolder>"; }
newRetainedMsg(RetainedMsg retainedMsg, int minQoSValue) { return new RetainedMsg( retainedMsg.getTopic(), retainedMsg.getPayload(), minQoSValue, retainedMsg.getProperties(), retainedMsg.getCreatedTime() ); }
[*] target: assertTrue(retainedMsgs.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( retainedMsgs. isEmpty ( ) )
************************************
************************************
[+] input: testCollectUniqueSharedSubscriptions() { List<String> topics = List.of( "test/topic", "my/home/+/bedroom", "home/#", "$share/g1/test/my/#", "$share/g1/test/my/topic", "$share/g2/test/my/topic");  Set<TopicSharedSubscription> sharedSubscriptions = mqttUnsubscribeHandler.collectUniqueSharedSubscriptions(topics);  "<AssertPlaceHolder>"; assertEquals(Set.of( new TopicSharedSubscription("test/my/#", "g1"), new TopicSharedSubscription("test/my/topic", "g1"), new TopicSharedSubscription("test/my/topic", "g2") ), sharedSubscriptions); }
collectUniqueSharedSubscriptions(List<String> topics) { return topics .stream() .filter(NettyMqttConverter::isSharedTopic) .map(topic -> new TopicSharedSubscription( NettyMqttConverter.getTopicName(topic), NettyMqttConverter.getShareName(topic))) .collect(Collectors.toSet()); }
[*] target: assertEquals(3, sharedSubscriptions.size())
[-] pred: org. junit. Assert. assertEquals ( 3, sharedSubscriptions. size ( ) )
************************************
************************************
[+] input: givenNoDelayedMessages_whenProcessDelayedMsg_thenRemoveClientFromDelayedProcessing() { publishedInFlightCtx.getPublishedInFlightMsgCounter().set(5);  boolean result = publishedInFlightCtx.processMsg(1);  verify(flowControlService, times(1)).removeFromMap("test");  "<AssertPlaceHolder>"; }
processMsg(long ttlMs) { lock.lock(); try { if (!allowedToSendMsg()) { if (log.isDebugEnabled()) { log.debug("[{}] Still reaching clientReceiveMax... Waiting for more ack messages", clientId); } return false; }  while (true) { MqttPubMsgWithCreatedTime head = delayedMsgQueue.poll(); if (head == null) { if (log.isDebugEnabled()) { log.debug("[{}] Delayed queue is empty!", clientId); } flowControlService.removeFromMap(clientId); return false; } delayedMsgCounter.decrementAndGet(); if (head.getCreatedTime() + ttlMs < System.currentTimeMillis()) { if (log.isDebugEnabled()) { log.debug("[{}] Msg expired in delayed queue {}", clientId, head); } continue; }  addPublishedInFlightMsg(head.getMqttPublishMessage()); sendDelayedMsg(head.getMqttPublishMessage()); break; } return true; } finally { lock.unlock(); } }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenMqttPropertiesWithPayloadFormatIndicatorAndContentType_whenGetMqttPropsProtoBuilder_thenGetExpectedResult() { MqttProperties properties = new MqttProperties(); properties.add(new MqttProperties.IntegerProperty(BrokerConstants.PAYLOAD_FORMAT_INDICATOR_PROP_ID, 1)); properties.add(new MqttProperties.StringProperty(BrokerConstants.CONTENT_TYPE_PROP_ID, "test"));  QueueProtos.MqttPropertiesProto.Builder mqttPropsProtoBuilder = ProtoConverter.getMqttPropsProtoBuilder(properties);  "<AssertPlaceHolder>"; QueueProtos.MqttPropertiesProto proto = mqttPropsProtoBuilder.build(); assertEquals("test", proto.getContentType()); assertEquals(1, proto.getPayloadFormatIndicator()); }
getMqttPropsProtoBuilder(MqttProperties properties) { Integer payloadFormatIndicator = getPayloadFormatIndicatorFromMqttProperties(properties); String contentType = getContentTypeFromMqttProperties(properties); String responseTopic = MqttPropertiesUtil.getResponseTopicValue(properties); byte[] correlationData = MqttPropertiesUtil.getCorrelationDataValue(properties); if (payloadFormatIndicator != null || contentType != null || responseTopic != null || correlationData != null) { QueueProtos.MqttPropertiesProto.Builder mqttPropertiesBuilder = QueueProtos.MqttPropertiesProto.newBuilder(); if (payloadFormatIndicator != null) { mqttPropertiesBuilder.setPayloadFormatIndicator(payloadFormatIndicator); } if (contentType != null) { mqttPropertiesBuilder.setContentType(contentType); } if (responseTopic != null) { mqttPropertiesBuilder.setResponseTopic(responseTopic); } if (correlationData != null) { mqttPropertiesBuilder.setCorrelationData(ByteString.copyFrom(correlationData)); } return mqttPropertiesBuilder; } return null; }
[*] target: assertNotNull(mqttPropsProtoBuilder)
[-] pred: org. junit. Assert. assertNotNull ( mqttPropsProtoBuilder )
************************************
************************************
[+] input: givenMqttPropertiesWithResponseTopicAndCorrelationData_whenGetMqttPropsProtoBuilder_thenGetExpectedResult() { MqttProperties properties = new MqttProperties(); properties.add(new MqttProperties.BinaryProperty(BrokerConstants.CORRELATION_DATA_PROP_ID, "test".getBytes(StandardCharsets.UTF_8))); properties.add(new MqttProperties.StringProperty(BrokerConstants.RESPONSE_TOPIC_PROP_ID, "test/"));  QueueProtos.MqttPropertiesProto.Builder mqttPropsProtoBuilder = ProtoConverter.getMqttPropsProtoBuilder(properties);  "<AssertPlaceHolder>"; QueueProtos.MqttPropertiesProto proto = mqttPropsProtoBuilder.build(); assertEquals("test/", proto.getResponseTopic()); assertEquals("test", proto.getCorrelationData().toString(StandardCharsets.UTF_8)); }
getMqttPropsProtoBuilder(MqttProperties properties) { Integer payloadFormatIndicator = getPayloadFormatIndicatorFromMqttProperties(properties); String contentType = getContentTypeFromMqttProperties(properties); String responseTopic = MqttPropertiesUtil.getResponseTopicValue(properties); byte[] correlationData = MqttPropertiesUtil.getCorrelationDataValue(properties); if (payloadFormatIndicator != null || contentType != null || responseTopic != null || correlationData != null) { QueueProtos.MqttPropertiesProto.Builder mqttPropertiesBuilder = QueueProtos.MqttPropertiesProto.newBuilder(); if (payloadFormatIndicator != null) { mqttPropertiesBuilder.setPayloadFormatIndicator(payloadFormatIndicator); } if (contentType != null) { mqttPropertiesBuilder.setContentType(contentType); } if (responseTopic != null) { mqttPropertiesBuilder.setResponseTopic(responseTopic); } if (correlationData != null) { mqttPropertiesBuilder.setCorrelationData(ByteString.copyFrom(correlationData)); } return mqttPropertiesBuilder; } return null; }
[*] target: assertNotNull(mqttPropsProtoBuilder)
[-] pred: org. junit. Assert. assertNotNull ( mqttPropsProtoBuilder )
************************************
************************************
[+] input: givenMqttPropertiesWithPayloadFormatIndicatorAndNoContentType_whenGetMqttPropsProtoBuilder_thenGetExpectedResult() { MqttProperties properties = new MqttProperties(); properties.add(new MqttProperties.IntegerProperty(BrokerConstants.PAYLOAD_FORMAT_INDICATOR_PROP_ID, 1));  QueueProtos.MqttPropertiesProto.Builder mqttPropsProtoBuilder = ProtoConverter.getMqttPropsProtoBuilder(properties);  "<AssertPlaceHolder>"; QueueProtos.MqttPropertiesProto proto = mqttPropsProtoBuilder.build(); assertFalse(proto.hasContentType()); assertEquals(1, proto.getPayloadFormatIndicator()); }
getMqttPropsProtoBuilder(MqttProperties properties) { Integer payloadFormatIndicator = getPayloadFormatIndicatorFromMqttProperties(properties); String contentType = getContentTypeFromMqttProperties(properties); String responseTopic = MqttPropertiesUtil.getResponseTopicValue(properties); byte[] correlationData = MqttPropertiesUtil.getCorrelationDataValue(properties); if (payloadFormatIndicator != null || contentType != null || responseTopic != null || correlationData != null) { QueueProtos.MqttPropertiesProto.Builder mqttPropertiesBuilder = QueueProtos.MqttPropertiesProto.newBuilder(); if (payloadFormatIndicator != null) { mqttPropertiesBuilder.setPayloadFormatIndicator(payloadFormatIndicator); } if (contentType != null) { mqttPropertiesBuilder.setContentType(contentType); } if (responseTopic != null) { mqttPropertiesBuilder.setResponseTopic(responseTopic); } if (correlationData != null) { mqttPropertiesBuilder.setCorrelationData(ByteString.copyFrom(correlationData)); } return mqttPropertiesBuilder; } return null; }
[*] target: assertNotNull(mqttPropsProtoBuilder)
[-] pred: org. junit. Assert. assertNotNull ( mqttPropsProtoBuilder )
************************************
************************************
[+] input: givenMqttPropertiesWithNoPayloadFormatIndicatorAndNoContentType_whenGetMqttPropsProtoBuilder_thenGetExpectedResult() { QueueProtos.MqttPropertiesProto.Builder mqttPropsProtoBuilder = ProtoConverter.getMqttPropsProtoBuilder(new MqttProperties()); "<AssertPlaceHolder>"; }
getMqttPropsProtoBuilder(MqttProperties properties) { Integer payloadFormatIndicator = getPayloadFormatIndicatorFromMqttProperties(properties); String contentType = getContentTypeFromMqttProperties(properties); String responseTopic = MqttPropertiesUtil.getResponseTopicValue(properties); byte[] correlationData = MqttPropertiesUtil.getCorrelationDataValue(properties); if (payloadFormatIndicator != null || contentType != null || responseTopic != null || correlationData != null) { QueueProtos.MqttPropertiesProto.Builder mqttPropertiesBuilder = QueueProtos.MqttPropertiesProto.newBuilder(); if (payloadFormatIndicator != null) { mqttPropertiesBuilder.setPayloadFormatIndicator(payloadFormatIndicator); } if (contentType != null) { mqttPropertiesBuilder.setContentType(contentType); } if (responseTopic != null) { mqttPropertiesBuilder.setResponseTopic(responseTopic); } if (correlationData != null) { mqttPropertiesBuilder.setCorrelationData(ByteString.copyFrom(correlationData)); } return mqttPropertiesBuilder; } return null; }
[*] target: assertNull(mqttPropsProtoBuilder)
[-] pred: org. junit. Assert. assertNull ( mqttPropsProtoBuilder )
************************************
************************************
[+] input: testDevicePersistedMsgsBucketConfiguration() { DevicePersistedMsgsRateLimitsConfiguration config = new DevicePersistedMsgsRateLimitsConfiguration(); config.setEnabled(true); config.setConfig("100:60,200:120");  BucketConfiguration bucketConfig = config.devicePersistedMsgsBucketConfiguration();  "<AssertPlaceHolder>"; assertEquals(2, bucketConfig.getBandwidths().length);  Bandwidth bw1 = bucketConfig.getBandwidths()[0]; assertEquals(100, bw1.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(60), bw1.getRefillPeriodNanos());  Bandwidth bw2 = bucketConfig.getBandwidths()[1]; assertEquals(200, bw2.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(120), bw2.getRefillPeriodNanos()); }
devicePersistedMsgsBucketConfiguration() { return getBucketConfiguration(); }
[*] target: assertNotNull(bucketConfig)
[-] pred: org. junit. Assert. assertNotNull ( bucketConfig )
************************************
************************************
[+] input: testTotalMsgsBucketConfiguration() { TotalMsgsRateLimitsConfiguration config = new TotalMsgsRateLimitsConfiguration(); config.setEnabled(true); config.setConfig("100:60,200:120");  BucketConfiguration bucketConfig = config.totalMsgsBucketConfiguration();  "<AssertPlaceHolder>"; assertEquals(2, bucketConfig.getBandwidths().length);  Bandwidth bw1 = bucketConfig.getBandwidths()[0]; assertEquals(100, bw1.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(60), bw1.getRefillPeriodNanos());  Bandwidth bw2 = bucketConfig.getBandwidths()[1]; assertEquals(200, bw2.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(120), bw2.getRefillPeriodNanos()); }
totalMsgsBucketConfiguration() { return getBucketConfiguration(); }
[*] target: assertNotNull(bucketConfig)
[-] pred: org. junit. Assert. assertNotNull ( bucketConfig )
************************************
************************************
[+] input: testTryConsumeDevicePersistedMsg() { // Set up bucket proxy Bandwidth limit = Bandwidth.builder().capacity(10).refillGreedy(10, Duration.ofMinutes(1)).build(); BucketConfiguration bucketConfig = BucketConfiguration.builder().addLimit(limit).build(); when(jedisBasedProxyManager.getProxy(anyString(), any())).thenReturn(bucketProxy); rateLimitRedisCacheService = new RateLimitRedisCacheServiceImpl(redisTemplate, jedisBasedProxyManager, bucketConfig, null); setCachePrefixAndInit();  when(bucketProxy.tryConsume(1)).thenReturn(true);  boolean result = rateLimitRedisCacheService.tryConsumeDevicePersistedMsg();  "<AssertPlaceHolder>"; verify(bucketProxy, times(1)).tryConsume(1); }
tryConsumeDevicePersistedMsg() { return devicePersistedMsgsBucketProxy.tryConsume(1); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testTryConsumeTotalMsg() { // Set up bucket proxy Bandwidth limit = Bandwidth.builder().capacity(10).refillGreedy(10, Duration.ofMinutes(1)).build(); BucketConfiguration bucketConfig = BucketConfiguration.builder().addLimit(limit).build(); when(jedisBasedProxyManager.getProxy(anyString(), any())).thenReturn(bucketProxy); rateLimitRedisCacheService = new RateLimitRedisCacheServiceImpl(redisTemplate, jedisBasedProxyManager, null, bucketConfig); setCachePrefixAndInit();  when(bucketProxy.tryConsume(1)).thenReturn(true);  boolean result = rateLimitRedisCacheService.tryConsumeTotalMsg();  "<AssertPlaceHolder>"; verify(bucketProxy, times(1)).tryConsume(1); }
tryConsumeTotalMsg() { return totalMsgsBucketProxy.tryConsume(1); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenIncomingRateLimitsDisabled_whenCheckIncomingLimits_thenSuccess() { when(incomingRateLimitsConfiguration.isEnabled()).thenReturn(false);  boolean result = rateLimitService.checkIncomingLimits(CLIENT_ID, UUID.randomUUID(), null); Assert."<AssertPlaceHolder>"; }
checkIncomingLimits(String clientId, UUID sessionId, MqttMessage msg) { if (!incomingRateLimitsConfiguration.isEnabled()) { return true; } TbRateLimits rateLimits = incomingPublishClientLimits.computeIfAbsent(clientId, id -> new TbRateLimits(incomingRateLimitsConfiguration.getClientConfig())); if (!rateLimits.tryConsume()) { if (log.isTraceEnabled()) { log.trace("[{}][{}] Client level incoming PUBLISH rate limit detected: {}", clientId, sessionId, msg); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenOutgoingRateLimitsDisabled_whenCheckOutgoingLimits_thenSuccess() { when(outgoingRateLimitsConfiguration.isEnabled()).thenReturn(false);  boolean result = rateLimitService.checkOutgoingLimits(CLIENT_ID, null); Assert."<AssertPlaceHolder>"; }
checkOutgoingLimits(String clientId, QueueProtos.PublishMsgProto msg) { if (!outgoingRateLimitsConfiguration.isEnabled()) { return true; } if (msg.getQos() != 0) { return true; } TbRateLimits rateLimits = outgoingPublishClientLimits.computeIfAbsent(clientId, id -> new TbRateLimits(outgoingRateLimitsConfiguration.getClientConfig())); if (!rateLimits.tryConsume()) { if (log.isTraceEnabled()) { log.trace("[{}] Client level outgoing PUBLISH rate limit detected: {}", clientId, msg); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenNoSessionsLimit_whenCheckSessionsLimit_thenSuccess() { rateLimitService.setSessionsLimit(0);  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenSessionsLimitReached_whenCheckSessionsLimit_thenFailure() { rateLimitService.setSessionsLimit(1); when(rateLimitCacheService.incrementSessionCount()).thenReturn(2L);  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenSessionsLimitNotReached_whenCheckSessionsLimit_thenSuccess() { rateLimitService.setSessionsLimit(5); when(rateLimitCacheService.incrementSessionCount()).thenReturn(2L);  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenSessionsLimitReached_whenCheckSessionsLimitForExistingClient_thenSuccess() { rateLimitService.setSessionsLimit(1); when(rateLimitCacheService.incrementSessionCount()).thenReturn(2L); when(clientSessionService.getClientSessionInfo(CLIENT_ID)).thenReturn(ClientSessionInfo.builder().build());  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenNoApplicationClientsLimit_whenCheckApplicationClientsLimit_thenSuccess() { rateLimitService.setApplicationClientsLimit(0);  SessionInfo sessionInfo = SessionInfo.builder().build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenApplicationClientsLimitAndNotPersistentAppClient_whenCheckApplicationClientsLimit_thenSuccess() { rateLimitService.setApplicationClientsLimit(1);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).build()).cleanStart(true).build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenApplicationClientsLimitReached_whenCheckApplicationClientsLimit_thenFailure() { rateLimitService.setApplicationClientsLimit(1); when(rateLimitCacheService.incrementApplicationClientsCount()).thenReturn(2L);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).clientId(CLIENT_ID).build()).cleanStart(false).build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenApplicationClientsLimitNotReached_whenCheckApplicationClientsLimit_thenSuccess() { rateLimitService.setApplicationClientsLimit(5); when(rateLimitCacheService.incrementApplicationClientsCount()).thenReturn(2L);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).clientId(CLIENT_ID).build()).cleanStart(false).build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenApplicationClientsLimitReached_whenCheckApplicationClientsLimitForExistingClient_thenSuccess() { rateLimitService.setApplicationClientsLimit(1); when(rateLimitCacheService.incrementApplicationClientsCount()).thenReturn(2L);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).clientId(CLIENT_ID).build()).cleanStart(false).build(); ClientSessionInfo clientSessionInfo = ClientSessionInfo.builder().type(ClientType.APPLICATION).cleanStart(false).build(); when(clientSessionService.getClientSessionInfo(CLIENT_ID)).thenReturn(clientSessionInfo);  boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenDevicePersistedMsgsRateLimitsDisabled_whenCheckDevicePersistedMsgsLimit_thenSuccess() { when(devicePersistedMsgsRateLimitsConfiguration.isEnabled()).thenReturn(false);  boolean result = rateLimitService.checkDevicePersistedMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkDevicePersistedMsgsLimit() { if (!devicePersistedMsgsRateLimitsConfiguration.isEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeDevicePersistedMsg()) { if (log.isTraceEnabled()) { log.trace("Device persisted messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenDevicePersistedMsgsRateLimitsEnabled_whenRateLimitNotReached_thenSuccess() { when(devicePersistedMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeDevicePersistedMsg()).thenReturn(true);  boolean result = rateLimitService.checkDevicePersistedMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkDevicePersistedMsgsLimit() { if (!devicePersistedMsgsRateLimitsConfiguration.isEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeDevicePersistedMsg()) { if (log.isTraceEnabled()) { log.trace("Device persisted messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenDevicePersistedMsgsRateLimitsEnabled_whenRateLimitReached_thenFailure() { when(devicePersistedMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeDevicePersistedMsg()).thenReturn(false);  boolean result = rateLimitService.checkDevicePersistedMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkDevicePersistedMsgsLimit() { if (!devicePersistedMsgsRateLimitsConfiguration.isEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeDevicePersistedMsg()) { if (log.isTraceEnabled()) { log.trace("Device persisted messages rate limit detected!"); } return false; } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenTotalMsgsRateLimitsDisabled_whenCheckTotalMsgsLimit_thenSuccess() { when(totalMsgsRateLimitsConfiguration.isEnabled()).thenReturn(false);  boolean result = rateLimitService.checkTotalMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkTotalMsgsLimit() { if (!isTotalMsgsLimitEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeTotalMsg()) { if (log.isTraceEnabled()) { log.trace("Total incoming and outgoing messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenTotalMsgsRateLimitsEnabled_whenRateLimitNotReached_thenSuccess() { when(totalMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeTotalMsg()).thenReturn(true);  boolean result = rateLimitService.checkTotalMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkTotalMsgsLimit() { if (!isTotalMsgsLimitEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeTotalMsg()) { if (log.isTraceEnabled()) { log.trace("Total incoming and outgoing messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenTotalMsgsRateLimitsEnabled_whenRateLimitReached_thenFailure() { when(totalMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeTotalMsg()).thenReturn(false);  boolean result = rateLimitService.checkTotalMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkTotalMsgsLimit() { if (!isTotalMsgsLimitEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeTotalMsg()) { if (log.isTraceEnabled()) { log.trace("Total incoming and outgoing messages rate limit detected!"); } return false; } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: loadPersistedMsgCtxTest() { ApplicationSessionCtx applicationSessionCtx = buildApplicationSessionCtx(); when(sessionCtxService.findApplicationSessionCtx(CLIENT_ID)).thenReturn(Optional.of(applicationSessionCtx));  ApplicationPersistedMsgCtx actual = applicationPersistedMsgCtxService.loadPersistedMsgCtx(CLIENT_ID); ApplicationPersistedMsgCtx expected = new ApplicationPersistedMsgCtx(getPendingMsgIdsMap(), getPendingMsgIdsMap()); Assert."<AssertPlaceHolder>"; }
loadPersistedMsgCtx(String clientId) { if (log.isTraceEnabled()) { log.trace("[{}] Loading persisted messages context.", clientId); } ApplicationSessionCtx applicationSessionCtx = findApplicationSessionCtx(clientId); if (applicationSessionCtx == null) { return new ApplicationPersistedMsgCtx(Collections.emptyMap(), Collections.emptyMap()); } Map<Long, Integer> publishMsgIds = getPendingMsgsFromApplicationCtx(applicationSessionCtx.getPublishMsgInfos()); Map<Long, Integer> pubRelMsgIds = getPendingMsgsFromApplicationCtx(applicationSessionCtx.getPubRelMsgInfos()); return new ApplicationPersistedMsgCtx(publishMsgIds, pubRelMsgIds); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testDeleteNonExistingTopic() { retainMsgTrie.put("1/2", "test"); retainMsgTrie.delete("1/3"); List<String> result = retainMsgTrie.get("1/2"); Assert."<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, result.size())
[-] pred: org. junit. Assert. assertEquals ( 1, result. size ( ) )
************************************
************************************
[+] input: givenClientContextAndAllowPublishToTopic_whenValidateClientAccess_thenSuccess() { when(authorizationRuleService.isPubAuthorized(any(), any(), any())).thenReturn(true); boolean result = publishMsgValidationService.validateClientAccess(ctx, "clientId", "topic/1"); Assert."<AssertPlaceHolder>"; }
validateClientAccess(ClientSessionCtx ctx, String clientId, String topic) { boolean isClientAuthorized = authorizationRuleService.isPubAuthorized(clientId, topic, ctx.getAuthRulePatterns()); if (!isClientAuthorized) { log.warn("[{}][{}][{}] Client is not authorized to publish to the topic {}", clientId, ctx.getSessionId(), ctx.getAuthRulePatterns(), topic); } return isClientAuthorized; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenClientContextAndNotAllowPublishToTopic_whenValidateClientAccess_thenFailure() { when(authorizationRuleService.isPubAuthorized(any(), any(), any())).thenReturn(false); boolean result = publishMsgValidationService.validateClientAccess(ctx, "clientId", "topic/1"); Assert."<AssertPlaceHolder>"; }
validateClientAccess(ClientSessionCtx ctx, String clientId, String topic) { boolean isClientAuthorized = authorizationRuleService.isPubAuthorized(clientId, topic, ctx.getAuthRulePatterns()); if (!isClientAuthorized) { log.warn("[{}][{}][{}] Client is not authorized to publish to the topic {}", clientId, ctx.getSessionId(), ctx.getAuthRulePatterns(), topic); } return isClientAuthorized; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testApplyTotalMsgsRateLimits_whenTotalMsgsLimitDisabled() { when(rateLimitService.isTotalMsgsLimitEnabled()).thenReturn(false);  List<ValueWithTopicFilter<ClientSubscription>> list = List.of( newValueWithTopicFilter("c1", 0, "t1"), newValueWithTopicFilter("c2", 1, "t2"), newValueWithTopicFilter("c3", 2, "t3") ); List<ValueWithTopicFilter<ClientSubscription>> result = msgDispatcherService.applyTotalMsgsRateLimits(list);  "<AssertPlaceHolder>"; }
applyTotalMsgsRateLimits(List<ValueWithTopicFilter<ClientSubscription>> clientSubscriptions) { if (rateLimitService.isTotalMsgsLimitEnabled() && clientSubscriptions.size() > 1) { int availableTokens = (int) rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(clientSubscriptions.size()); if (availableTokens == 0) { log.debug("No available tokens left for total msgs bucket"); return Collections.emptyList(); } if (log.isDebugEnabled() && availableTokens < clientSubscriptions.size()) { log.debug("Hitting total messages rate limits on subscriptions processing. Skipping {} messages", clientSubscriptions.size() - availableTokens); } return clientSubscriptions.subList(0, availableTokens); } return clientSubscriptions; }
[*] target: assertEquals(list, result)
[-] pred: org. junit. Assert. assertEquals ( list, result )
************************************
************************************
[+] input: testApplyTotalMsgsRateLimits_whenTotalMsgsLimitEnabledAndLimitNotUsed() { when(rateLimitService.isTotalMsgsLimitEnabled()).thenReturn(true); when(rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(eq(3L))).thenReturn(3L);  List<ValueWithTopicFilter<ClientSubscription>> list = List.of( newValueWithTopicFilter("c1", 0, "t1"), newValueWithTopicFilter("c2", 1, "t2"), newValueWithTopicFilter("c3", 2, "t3") ); List<ValueWithTopicFilter<ClientSubscription>> result = msgDispatcherService.applyTotalMsgsRateLimits(list);  "<AssertPlaceHolder>"; }
applyTotalMsgsRateLimits(List<ValueWithTopicFilter<ClientSubscription>> clientSubscriptions) { if (rateLimitService.isTotalMsgsLimitEnabled() && clientSubscriptions.size() > 1) { int availableTokens = (int) rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(clientSubscriptions.size()); if (availableTokens == 0) { log.debug("No available tokens left for total msgs bucket"); return Collections.emptyList(); } if (log.isDebugEnabled() && availableTokens < clientSubscriptions.size()) { log.debug("Hitting total messages rate limits on subscriptions processing. Skipping {} messages", clientSubscriptions.size() - availableTokens); } return clientSubscriptions.subList(0, availableTokens); } return clientSubscriptions; }
[*] target: assertEquals(list, result)
[-] pred: org. junit. Assert. assertEquals ( list, result )
************************************
************************************
[+] input: testGetSubscriptionWithHigherQos() { Subscription subscription1 = new Subscription("test/+", 1, null); Subscription subscription2 = new Subscription("#", 0, null);  Subscription result = msgDispatcherService.getSubscriptionWithHigherQos(subscription1, subscription2);  "<AssertPlaceHolder>"; }
getSubscriptionWithHigherQos(Subscription first, Subscription second) { return first.getQos() > second.getQos() ? first : second; }
[*] target: assertEquals(result, subscription1)
[-] pred: org. junit. Assert. assertEquals ( result, subscription1 )
************************************
************************************
[+] input: testConvertToSharedSubscriptionList() { Set<Subscription> subscriptions = Set.of( newSubscription(0, "group1"), newSubscription(1, "group1"), newSubscription(2, "group2"), newSubscription(0, "group2"), newSubscription(1, "group3"), newSubscription(2, "group3") ); List<SharedSubscription> sharedSubscriptionList = msgDispatcherService.toSharedSubscriptionList(subscriptions); "<AssertPlaceHolder>"; sharedSubscriptionList.forEach(sharedSubscription -> assertEquals(2, sharedSubscription.getSubscriptions().size())); }
toSharedSubscriptionList(Set<Subscription> sharedSubscriptions) { return sharedSubscriptions.stream() .collect(Collectors.groupingBy(subscription -> new TopicSharedSubscription(subscription.getTopicFilter(), subscription.getShareName(), subscription.getQos()))) .entrySet().stream() .map(entry -> new SharedSubscription(entry.getKey(), entry.getValue())) .collect(Collectors.toList()); }
[*] target: assertEquals(3, sharedSubscriptionList.size())
[-] pred: org. junit. Assert. assertEquals ( 3, sharedSubscriptionList. size ( ) )
************************************
************************************
[+] input: givenPubMsgAndSubscriptionWithSameQosAndFalseRetainAsPublish_whenProcessUpdatePublishMsg_thenReturnSameMsg() { Subscription subscription = new Subscription("test/topic", 1, ClientSessionInfo.builder().build()); QueueProtos.PublishMsgProto beforePublishMsgProto = QueueProtos.PublishMsgProto.newBuilder().setQos(1).setRetain(false).build();  QueueProtos.PublishMsgProto afterPublishMsgProto = downLinkProxy.updatePublishMsg(subscription, beforePublishMsgProto);  Assert."<AssertPlaceHolder>"; }
updatePublishMsg(Subscription subscription, PublishMsgProto publishMsgProto) { var minQos = Math.min(subscription.getQos(), publishMsgProto.getQos()); var retain = subscription.getOptions().isRetain(publishMsgProto.getRetain());  if (minQos != publishMsgProto.getQos() || retain != publishMsgProto.getRetain()) { return publishMsgProto.toBuilder() .setQos(minQos) .setRetain(retain) .build(); } else { return publishMsgProto; } }
[*] target: assertEquals(beforePublishMsgProto, afterPublishMsgProto)
[-] pred: org. junit. Assert. assertEquals ( beforePublishMsgProto, afterPublishMsgProto )
************************************
************************************
[+] input: givenPubMsgAndSubscriptionWithSameQosAndRetainAsPublish_whenProcessUpdatePublishMsg_thenReturnSameMsg() { Subscription subscription = new Subscription( "test/topic", 2, ClientSessionInfo.builder().build(), null, new SubscriptionOptions( false, true, SubscriptionOptions.RetainHandlingPolicy.SEND_AT_SUBSCRIBE));  QueueProtos.PublishMsgProto beforePublishMsgProto = QueueProtos.PublishMsgProto.newBuilder().setQos(2).setRetain(true).build();  QueueProtos.PublishMsgProto afterPublishMsgProto = downLinkProxy.updatePublishMsg(subscription, beforePublishMsgProto);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, afterPublishMsgProto.getQos()); Assert.assertTrue(afterPublishMsgProto.getRetain()); }
updatePublishMsg(Subscription subscription, PublishMsgProto publishMsgProto) { var minQos = Math.min(subscription.getQos(), publishMsgProto.getQos()); var retain = subscription.getOptions().isRetain(publishMsgProto.getRetain());  if (minQos != publishMsgProto.getQos() || retain != publishMsgProto.getRetain()) { return publishMsgProto.toBuilder() .setQos(minQos) .setRetain(retain) .build(); } else { return publishMsgProto; } }
[*] target: assertEquals(beforePublishMsgProto, afterPublishMsgProto)
[-] pred: org. junit. Assert. assertEquals ( beforePublishMsgProto, afterPublishMsgProto )
************************************
************************************
[+] input: givenSameClient_whenCheckIsAnyOtherDeviceClientConnected_thenFalse() { when(clientSessionInfo1.isConnected()).thenReturn(true); when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_1, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertFalse(anyDeviceClientConnected)
[-] pred: org. junit. Assert. assertFalse ( anyDeviceClientConnected )
************************************
************************************
[+] input: givenDisconnectedClients_whenCheckIsAnyOtherDeviceClientConnected_thenFalse() { when(clientSessionInfo1.isConnected()).thenReturn(false); when(clientSessionInfo2.isConnected()).thenReturn(false);  when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1); when(clientSessionInfo2.getClientId()).thenReturn(CLIENT_ID_2);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") )); sharedSubscriptionCache.put(CLIENT_ID_2, List.of( new TopicSubscription("something", 2, "g1") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_3, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertFalse(anyDeviceClientConnected)
[-] pred: org. junit. Assert. assertFalse ( anyDeviceClientConnected )
************************************
************************************
[+] input: givenConnectedClient_whenCheckIsAnyOtherDeviceClientConnected_thenTrue() { when(clientSessionInfo1.isConnected()).thenReturn(true); when(clientSessionInfo2.isConnected()).thenReturn(false);  when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1); when(clientSessionInfo2.getClientId()).thenReturn(CLIENT_ID_2);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") )); sharedSubscriptionCache.put(CLIENT_ID_2, List.of( new TopicSubscription("something", 2, "g1") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_3, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertTrue(anyDeviceClientConnected)
[-] pred: org. junit. Assert. assertTrue ( anyDeviceClientConnected )
************************************
************************************
[+] input: givenPubMsgWithoutTopicAlias_whenGetTopicNameByAlias_thenNoTopicReturned() { topicAliasCtx = new TopicAliasCtx(true, 5);  MqttProperties properties = new MqttProperties(); PublishMsg publishMsg = PublishMsg.builder().properties(properties).build(); String topicNameByAlias = topicAliasCtx.getTopicNameByAlias(publishMsg);  Assert."<AssertPlaceHolder>"; }
getTopicNameByAlias(PublishMsg publishMsg) { if (enabled) { var receivedTopicName = publishMsg.getTopicName(); var topicAliasProperty = MqttPropertiesUtil.getTopicAliasProperty(publishMsg.getProperties()); if (topicAliasProperty != null) { int topicAlias = topicAliasProperty.value(); validateTopicAlias(topicAlias);  if (receivedTopicName.isEmpty()) { var topicName = getTopicByAlias(topicAlias); if (topicName == null) { throw new MqttException(UNKNOWN_TOPIC_ALIAS_MSG); } else { return topicName; } } else { saveMapping(topicAlias, receivedTopicName); return receivedTopicName; } } } return null; }
[*] target: assertNull(topicNameByAlias)
[-] pred: org. junit. Assert. assertNull ( topicNameByAlias )
************************************
************************************
[+] input: givenPubMsgWithSmallTopic_whenCreatePublishMsgUsingTopicAlias_thenReturnSamePubMsg() { topicAliasCtx = new TopicAliasCtx(true, 5, new ConcurrentHashMap<>(Map.of(1, "topic123")), null);  PublishMsg publishMsg = PublishMsg .builder() .topicName("topic/1") .properties(new MqttProperties()) .build();  PublishMsg publishMsgUsingTopicAlias = topicAliasCtx.createPublishMsgUsingTopicAlias(publishMsg, minTopicNameLengthForAliasReplacement);  Assert."<AssertPlaceHolder>"; }
createPublishMsgUsingTopicAlias(PublishMsg publishMsg, int minTopicNameLengthForAliasReplacement) { if (enabled) { String topicName = publishMsg.getTopicName(); if (topicName.length() > minTopicNameLengthForAliasReplacement) { MqttProperties properties = publishMsg.getProperties();  Integer topicAlias = serverMappings.get(topicName); if (topicAlias == null) { int nextTopicAlias = getNextTopicAlias(topicName); if (nextTopicAlias == 0) { return publishMsg; } MqttPropertiesUtil.addTopicAliasToProps(properties, nextTopicAlias); return getPublishMsg(publishMsg, topicName, properties); } MqttPropertiesUtil.addTopicAliasToProps(properties, topicAlias); return getPublishMsg(publishMsg, BrokerConstants.EMPTY_STR, properties); } } return publishMsg; }
[*] target: assertEquals(publishMsg, publishMsgUsingTopicAlias)
[-] pred: org. junit. Assert. assertEquals ( publishMsg, publishMsgUsingTopicAlias )
************************************
************************************
[+] input: givenPubMsgWithTopicAndMaxAllowedAliases_whenCreatePublishMsgUsingTopicAlias_thenReturnSamePubMsg() { topicAliasCtx = new TopicAliasCtx(true, 1, new ConcurrentHashMap<>(), new ConcurrentHashMap<>(Map.of("topic123", 1)));  PublishMsg publishMsg = PublishMsg .builder() .topicName("topic/qwerty") .properties(new MqttProperties()) .build();  PublishMsg publishMsgUsingTopicAlias = topicAliasCtx.createPublishMsgUsingTopicAlias(publishMsg, minTopicNameLengthForAliasReplacement);  Assert."<AssertPlaceHolder>"; }
createPublishMsgUsingTopicAlias(PublishMsg publishMsg, int minTopicNameLengthForAliasReplacement) { if (enabled) { String topicName = publishMsg.getTopicName(); if (topicName.length() > minTopicNameLengthForAliasReplacement) { MqttProperties properties = publishMsg.getProperties();  Integer topicAlias = serverMappings.get(topicName); if (topicAlias == null) { int nextTopicAlias = getNextTopicAlias(topicName); if (nextTopicAlias == 0) { return publishMsg; } MqttPropertiesUtil.addTopicAliasToProps(properties, nextTopicAlias); return getPublishMsg(publishMsg, topicName, properties); } MqttPropertiesUtil.addTopicAliasToProps(properties, topicAlias); return getPublishMsg(publishMsg, BrokerConstants.EMPTY_STR, properties); } } return publishMsg; }
[*] target: assertEquals(publishMsg, publishMsgUsingTopicAlias)
[-] pred: org. junit. Assert. assertEquals ( publishMsg, publishMsgUsingTopicAlias )
************************************
************************************
[+] input: givenMaxAliasesReached_whenGetNextTopicAlias_thenDoNotReturnNewAlias() { topicAliasCtx = new TopicAliasCtx(true, 2, new ConcurrentHashMap<>(Map.of(1, "1", 2, "2")), new ConcurrentHashMap<>());  int topicAlias = topicAliasCtx.getNextTopicAlias("test/topic/1"); Assert."<AssertPlaceHolder>"; }
getNextTopicAlias(String topicName) { if (isMoreTopicAliasAvailable()) { int lastTopicAlias = serverMappings.size(); int nextTopicAlias = lastTopicAlias + 1; serverMappings.put(topicName, nextTopicAlias); return nextTopicAlias; } return 0; }
[*] target: assertEquals(0, topicAlias)
[-] pred: org. junit. Assert. assertEquals ( 0, topicAlias )
************************************
************************************
[+] input: givenMaxAliasesNotReached_whenGetNextTopicAlias_thenReturnNewAlias() { topicAliasCtx = new TopicAliasCtx(true, 2, new ConcurrentHashMap<>(), new ConcurrentHashMap<>(Map.of("1", 1)));  int topicAlias = topicAliasCtx.getNextTopicAlias("test/topic/1"); Assert."<AssertPlaceHolder>"; }
getNextTopicAlias(String topicName) { if (isMoreTopicAliasAvailable()) { int lastTopicAlias = serverMappings.size(); int nextTopicAlias = lastTopicAlias + 1; serverMappings.put(topicName, nextTopicAlias); return nextTopicAlias; } return 0; }
[*] target: assertEquals(2, topicAlias)
[-] pred: org. junit. Assert. assertEquals ( 2, topicAlias )
************************************
************************************
[+] input: testCleanUpBySize() { int maxPersistedMessages = 10;  deviceMsgCleanUpDao.cleanUpBySize(maxPersistedMessages);  List<DevicePublishMsgEntity> remainingMessages = deviceMsgRepository.findAll(); Assert."<AssertPlaceHolder>";  for (int i = 0; i < maxPersistedMessages; i++) { Assert.assertEquals(i + 10, remainingMessages.get(i).getSerialNumber().intValue()); } }
cleanUpBySize(int maxPersistedMessages) { if (maxPersistedMessages <= 0) { log.error("Only positive numbers are allowed."); return; } log.trace("Cleaning up device publish messages to match max size {}.", maxPersistedMessages);  Page<DeviceSessionCtxEntity> deviceSessionCtxEntities; int pageCounter = 0; do { deviceSessionCtxEntities = deviceSessionCtxRepository.findAll(PageRequest.of(pageCounter++, sessionCtxPageSize)); for (DeviceSessionCtxEntity deviceSessionCtxEntity : deviceSessionCtxEntities) { String clientId = deviceSessionCtxEntity.getClientId(); DevicePublishMsgEntity earliestPersistedMsg = deviceMsgRepository.findEntityByClientIdAfterOffset(clientId, maxPersistedMessages - 1); if (earliestPersistedMsg == null) { log.trace("[{}] No messages to clean up.", clientId); } else { log.trace("[{}] Clearing messages with serial number less than {}.", clientId, earliestPersistedMsg.getSerialNumber()); int removed = deviceMsgRepository.removeAllByClientIdAndSerialNumberLessThan(clientId, earliestPersistedMsg.getSerialNumber()); log.debug("[{}] Removed {} messages.", clientId, removed); } } } while (!deviceSessionCtxEntities.isLast());  }
[*] target: assertEquals(maxPersistedMessages, remainingMessages.size())
[-] pred: org. junit. Assert. assertEquals ( maxPersistedMessages, remainingMessages. size ( ) )
************************************
************************************
[+] input: Exception { String entityId = RandomStringUtils.randomAlphabetic(20);  saveEntries(entityId, TS - 2); saveEntries(entityId, TS - 1); saveEntries(entityId, TS);  List<TsKvEntry> entries = tsService.findLatest(entityId, Collections.singleton(LONG_KEY)).get(MAX_TIMEOUT, TimeUnit.SECONDS); Assert."<AssertPlaceHolder>"; Assert.assertEquals(toTsEntry(TS, longKvEntry), entries.get(0)); }
findLatest(String entityId, Collection<String> keys);
[*] target: assertEquals(1, entries.size())
[-] pred: org. junit. Assert. assertEquals ( 1, entries. size ( ) )
************************************
************************************
[+] input: Exception { String entityId = RandomStringUtils.randomAlphabetic(20); saveEntries(entityId, TS - 1L); for (long i = TS; i <= TS + 100L; i += 10L) { saveEntries(entityId, i); } saveEntries(entityId, TS + 100L + 1L);  List<ReadTsKvQuery> queries = List.of(new BaseReadTsKvQuery(LONG_KEY, TS, TS + 100, 100, 1, Aggregation.COUNT, DESC_ORDER));  List<TsKvEntry> entries = tsService.findAll(entityId, queries).get(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(toTsEntry(TS + 50, new LongDataEntry(LONG_KEY, 10L)), entries.get(0)); }
findAll(String entityId, List<ReadTsKvQuery> queries);
[*] target: assertEquals(1, entries.size())
[-] pred: org. junit. Assert. assertEquals ( 1, entries. size ( ) )
************************************
************************************
[+] input: testFindUserById() { User user = userService.findUserByEmail("sysadmin@thingsboard.org"); Assert.assertNotNull(user); User foundUser = userService.findUserById(user.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(user, foundUser); }
findUserById(UUID userId);
[*] target: assertNotNull(foundUser)
[-] pred: org. junit. Assert. assertNotNull ( foundUser )
************************************
************************************
[+] input: testFindUserCredentials() { User user = userService.findUserByEmail("sysadmin@thingsboard.org"); Assert.assertNotNull(user); UserCredentials userCredentials = userService.findUserCredentialsByUserId(user.getId()); Assert."<AssertPlaceHolder>"; }
findUserCredentialsByUserId(UUID userId);
[*] target: assertNotNull(userCredentials)
[-] pred: org. junit. Assert. assertNotNull ( userCredentials )
************************************
************************************
[+] input: testDeleteUser() { User user = new User(); user.setAuthority(Authority.SYS_ADMIN); user.setEmail("admin2@thingsboard.org"); User savedUser = userService.saveUser(user); Assert.assertNotNull(savedUser); Assert.assertNotNull(savedUser.getId());  User foundUser = userService.findUserById(savedUser.getId()); Assert.assertNotNull(foundUser);  UserCredentials userCredentials = userService.findUserCredentialsByUserId(foundUser.getId()); Assert.assertNotNull(userCredentials);  userService.deleteUser(foundUser.getId());  userCredentials = userService.findUserCredentialsByUserId(foundUser.getId()); foundUser = userService.findUserById(foundUser.getId()); Assert."<AssertPlaceHolder>"; Assert.assertNull(userCredentials); }
findUserById(UUID userId);
[*] target: assertNull(foundUser)
[-] pred: org. junit. Assert. assertNull ( foundUser )
************************************
************************************
[+] input: givenNoWebSocketConnection_whenFindWebSocketConnectionByName_thenNothingFound() { WebSocketConnection webSocketConnectionByName = webSocketConnectionService.findWebSocketConnectionByName(savedUser.getId(), "absent"); Assert."<AssertPlaceHolder>"; }
findWebSocketConnectionByName(UUID userId, String name) { if (log.isTraceEnabled()) { log.trace("[{}] Executing findWebSocketConnectionByName [{}]", userId, name); } return webSocketConnectionDao.findByUserIdAndName(userId, name); }
[*] target: assertNull(webSocketConnectionByName)
[-] pred: org. junit. Assert. assertNull ( webSocketConnectionByName )
************************************
************************************
[+] input: testEquals() { final MutableSensorRegistry sensorRegistry1 = this.getSensorRegistry(); final MutableSensorRegistry sensorRegistry2 = this.getSensorRegistry(); assertFalse(sensorRegistry1 == sensorRegistry2); assertTrue(sensorRegistry1.equals(sensorRegistry2)); "<AssertPlaceHolder>"; }
equals(final Object obj) { if (obj == this) { return true; } if (obj instanceof SensorRegistry) { final SensorRegistry other = (SensorRegistry) obj; return Objects.equals(this.getTopLevelSensor(), other.getTopLevelSensor()); } return false; }
[*] target: assertTrue(sensorRegistry2.equals(sensorRegistry1))
[-] pred: org. junit. Assert. assertTrue ( sensorRegistry2. equals ( sensorRegistry1 ) )
************************************
************************************
[+] input: testEqualsWithDifferentNames() { final MutableSensorRegistry sensorRegistry1 = this.getSensorRegistry(); final MutableSensorRegistry sensorRegistry2 = this.getSensorRegistryWithDifferentNames(); assertFalse(sensorRegistry1 == sensorRegistry2); assertTrue(sensorRegistry1.equals(sensorRegistry2)); "<AssertPlaceHolder>"; }
equals(final Object obj) { if (obj == this) { return true; } if (obj instanceof SensorRegistry) { final SensorRegistry other = (SensorRegistry) obj; return Objects.equals(this.getTopLevelSensor(), other.getTopLevelSensor()); } return false; }
[*] target: assertTrue(sensorRegistry2.equals(sensorRegistry1))
[-] pred: org. junit. Assert. assertTrue ( sensorRegistry2. equals ( sensorRegistry1 ) )
************************************
************************************
[+] input: testNotEquals() { final MutableSensorRegistry sensorRegistry1 = this.getSensorRegistry(); final MutableSensorRegistry sensorRegistry2 = this.getOtherSensorRegistry(); assertFalse(sensorRegistry1 == sensorRegistry2); assertFalse(sensorRegistry1.equals(sensorRegistry2)); "<AssertPlaceHolder>"; }
equals(final Object obj) { if (obj == this) { return true; } if (obj instanceof SensorRegistry) { final SensorRegistry other = (SensorRegistry) obj; return Objects.equals(this.getTopLevelSensor(), other.getTopLevelSensor()); } return false; }
[*] target: assertFalse(sensorRegistry2.equals(sensorRegistry1))
[-] pred: org. junit. Assert. assertFalse ( sensorRegistry2. equals ( sensorRegistry1 ) )
************************************
************************************
[+] input: BadMessageException { // Assume that we are Bob = the responder createSessions();  Assert.assertNotNull(this.responderDHSession.getPeerRatchet2DH()); Assert.assertNotNull(this.responderDHSession.getPeerRatchet4DH());  // Store the responder session, including the 2DH ratchet store.storeDHSession(this.responderDHSession);  // There should still be a 2DH ratchet at this point DHSession retrievedSession = store.getDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), this.responderDHSession.getId(), taskCodec); Assert.assertNotNull(retrievedSession); Assert.assertNotNull(retrievedSession.getPeerRatchet2DH());  // Discard the 2DH ratchet (assume Bob has received a 4DH message from Alice) this.responderDHSession.discardPeerRatchet2DH(); Assert.assertNull(this.responderDHSession.getPeerRatchet2DH());  // Store the responder session again without the 2DH ratchet store.storeDHSession(this.responderDHSession);  // Ensure that the 2DH ratchet is really gone retrievedSession = store.getDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), this.responderDHSession.getId(), taskCodec); Assert."<AssertPlaceHolder>"; Assert.assertNull(retrievedSession.getPeerRatchet2DH()); }
getDHSession(String myIdentity, String peerIdentity, @Nullable DHSessionId sessionId, @NonNull ActiveTaskCodec handle) throws DHSessionStoreException { String selection = COLUMN_MY_IDENTITY + "=? and " + COLUMN_PEER_IDENTITY + "=?";  if (sessionId != null) { selection += " and " + COLUMN_SESSION_ID + "=x'" + Utils.byteArrayToHexString(sessionId.get()) + "'"; }  try (Cursor cursor = this.getReadableDatabase().query( SESSION_TABLE, new String[]{ COLUMN_SESSION_ID, COLUMN_MY_IDENTITY, COLUMN_PEER_IDENTITY, COLUMN_MY_CURRENT_VERSION_4_DH, COLUMN_LAST_OUTGOING_MESSAGE_TIMESTAMP, COLUMN_MY_EPHEMERAL_PRIVATE_KEY, COLUMN_MY_EPHEMERAL_PUBLIC_KEY, COLUMN_MY_CURRENT_CHAIN_KEY_2_DH, COLUMN_MY_COUNTER_2_DH, COLUMN_MY_CURRENT_CHAIN_KEY_4_DH, COLUMN_MY_COUNTER_4_DH, COLUMN_PEER_CURRENT_VERSION_4_DH, COLUMN_PEER_CURRENT_CHAIN_KEY_2_DH, COLUMN_PEER_COUNTER_2_DH, COLUMN_PEER_CURRENT_CHAIN_KEY_4_DH, COLUMN_PEER_COUNTER_4_DH }, selection, new String[] { myIdentity, peerIdentity }, null, null, null )) {  if (cursor != null) { if (cursor.moveToFirst()) { return dhSessionFromCursor(cursor, handle); } }  return null; } catch (SQLException e) { throw new DHSessionStoreException("Cannot load session", e); } }
[*] target: assertNotNull(retrievedSession)
[-] pred: org. junit. Assert. assertNotNull ( retrievedSession )
************************************
************************************
[+] input: runAsyncTest() { SystemUpdateToVersion65 update = new SystemUpdateToVersion65(this.databaseServiceMock, this.sqLiteDatabaseMock);  Assert."<AssertPlaceHolder>"; }
runAsync() { return true; }
[*] target: assertTrue(update.runAsync())
[-] pred: org. junit. Assert. assertTrue ( update. runAsync() )
************************************
************************************
[+] input: testGetThreemaSafeEncryptionKeyNull() { final ThreemaSafeService service = getService();  when(preferenceServiceMock.getThreemaSafeMasterKey()).thenReturn(null); final byte[] encryptionKey1 = service.getThreemaSafeEncryptionKey(); Assert.assertNull(encryptionKey1);  when(preferenceServiceMock.getThreemaSafeMasterKey()).thenReturn(new byte[0]); final byte[] encryptionKey2 = service.getThreemaSafeEncryptionKey(); Assert."<AssertPlaceHolder>"; }
getThreemaSafeEncryptionKey();  byte[] getThreemaSafeMasterKey();  ThreemaSafeServerTestResponse testServer(ThreemaSafeServerInfo serverInfo) throws ThreemaException;  /** * Schedules the Threema Safe backup to run periodically. There is an initial delay of one * period, therefore the backup is not run immediately after calling this. This does not replace * existing periodic Threema Safe backup work. Therefore the periodic execution cycle is not * affected by this method. However, if the schedule period changes, this call cancels the * currently scheduled upload and schedules a new upload with the new schedule period and again * an initial delay. * * Periodic Threema Safe backups are only uploaded if they are different than the last * successful backup. * * @return {@code true}
[*] target: assertNull(encryptionKey2)
[-] pred: org. junit. Assert. assertNull ( encryptionKey2 )
************************************
************************************
[+] input: parseWithRel() { final String candidate = "candidate:373990095 1 udp 41885439 5.148.189.205 63293 typ relay raddr 1.2.3.4 rport 5432"; final IceCandidateParser.CandidateData result = IceCandidateParser.parse(candidate); "<AssertPlaceHolder>"; assertEquals("1.2.3.4", result.relAddr); assertEquals(Integer.valueOf(5432), result.relPort); }
parse(@NonNull String candidateString) { final Matcher matcher = CANDIDATE_ATTRIBUTE.matcher(candidateString); if (!matcher.matches()) { return null; }  // Unfortunately the Regex module shipped with Android does not support // named capture groups, therefore we need to stick with the brittle and hacky // numbered capture group approach. Fortunately there are tests.  // Extract extensions final String extensionsString = matcher.group(12); final Map<String, String> extensions = new HashMap<>(); if (extensionsString != null) { String key = null; for (String segment : extensionsString.trim().split(" ")) { if (key == null) { key = segment; } else { extensions.put(key, segment); key = null; } } }  // Extract rest of data, return data POJO return new CandidateData( matcher.group(1), Integer.parseInt(matcher.group(2)), matcher.group(3), extensions.get("tcptype"), Integer.parseInt(matcher.group(4)), matcher.group(5), Integer.parseInt(matcher.group(6)), matcher.group(7), matcher.group(9), matcher.group(11) == null ? null : Integer.parseInt(matcher.group(11)), extensions ); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: parseWithRelAddr() { final String candidate = "candidate:373990095 1 udp 41885439 5.148.189.205 63293 typ relay raddr ::1"; final IceCandidateParser.CandidateData result = IceCandidateParser.parse(candidate); "<AssertPlaceHolder>"; assertEquals("::1", result.relAddr); assertEquals(null, result.relPort); }
parse(@NonNull String candidateString) { final Matcher matcher = CANDIDATE_ATTRIBUTE.matcher(candidateString); if (!matcher.matches()) { return null; }  // Unfortunately the Regex module shipped with Android does not support // named capture groups, therefore we need to stick with the brittle and hacky // numbered capture group approach. Fortunately there are tests.  // Extract extensions final String extensionsString = matcher.group(12); final Map<String, String> extensions = new HashMap<>(); if (extensionsString != null) { String key = null; for (String segment : extensionsString.trim().split(" ")) { if (key == null) { key = segment; } else { extensions.put(key, segment); key = null; } } }  // Extract rest of data, return data POJO return new CandidateData( matcher.group(1), Integer.parseInt(matcher.group(2)), matcher.group(3), extensions.get("tcptype"), Integer.parseInt(matcher.group(4)), matcher.group(5), Integer.parseInt(matcher.group(6)), matcher.group(7), matcher.group(9), matcher.group(11) == null ? null : Integer.parseInt(matcher.group(11)), extensions ); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: parseTcp() { final String candidate = "candidate:1876313031 1 tcp 1518222591 ::1 58170 typ host tcptype passive generation 0 ufrag xTeg network-id 2"; final IceCandidateParser.CandidateData result = IceCandidateParser.parse(candidate); "<AssertPlaceHolder>"; assertEquals("tcp", result.transport); assertEquals("passive", result.tcptype); assertEquals(new HashMap<String, String>() {{ put("generation", "0"); put("ufrag", "xTeg"); put("network-id", "2"); put("tcptype", "passive"); }}, result.extensions); }
parse(@NonNull String candidateString) { final Matcher matcher = CANDIDATE_ATTRIBUTE.matcher(candidateString); if (!matcher.matches()) { return null; }  // Unfortunately the Regex module shipped with Android does not support // named capture groups, therefore we need to stick with the brittle and hacky // numbered capture group approach. Fortunately there are tests.  // Extract extensions final String extensionsString = matcher.group(12); final Map<String, String> extensions = new HashMap<>(); if (extensionsString != null) { String key = null; for (String segment : extensionsString.trim().split(" ")) { if (key == null) { key = segment; } else { extensions.put(key, segment); key = null; } } }  // Extract rest of data, return data POJO return new CandidateData( matcher.group(1), Integer.parseInt(matcher.group(2)), matcher.group(3), extensions.get("tcptype"), Integer.parseInt(matcher.group(4)), matcher.group(5), Integer.parseInt(matcher.group(6)), matcher.group(7), matcher.group(9), matcher.group(11) == null ? null : Integer.parseInt(matcher.group(11)), extensions ); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: parseFull() { final String candidate = "candidate:842163049 1 udp 1686052607 1.2.3.4 46154 typ srflx raddr 10.0.0.17 rport 46154 generation 0 ufrag EEtu network-id 3 network-cost 10"; final IceCandidateParser.CandidateData result = IceCandidateParser.parse(candidate); "<AssertPlaceHolder>"; assertEquals("842163049", result.foundation); assertEquals(1, result.componentId); assertEquals("udp", result.transport); assertNull("udp", result.tcptype); assertEquals(1686052607, result.priority); assertEquals("1.2.3.4", result.connectionAddress); assertEquals(46154, result.port); assertEquals("srflx", result.candType); assertEquals("10.0.0.17", result.relAddr); assertEquals(Integer.valueOf(46154), result.relPort); assertEquals(new HashMap<String, String>() {{ put("generation", "0"); put("ufrag", "EEtu"); put("network-id", "3"); put("network-cost", "10"); }}, result.extensions); }
parse(@NonNull String candidateString) { final Matcher matcher = CANDIDATE_ATTRIBUTE.matcher(candidateString); if (!matcher.matches()) { return null; }  // Unfortunately the Regex module shipped with Android does not support // named capture groups, therefore we need to stick with the brittle and hacky // numbered capture group approach. Fortunately there are tests.  // Extract extensions final String extensionsString = matcher.group(12); final Map<String, String> extensions = new HashMap<>(); if (extensionsString != null) { String key = null; for (String segment : extensionsString.trim().split(" ")) { if (key == null) { key = segment; } else { extensions.put(key, segment); key = null; } } }  // Extract rest of data, return data POJO return new CandidateData( matcher.group(1), Integer.parseInt(matcher.group(2)), matcher.group(3), extensions.get("tcptype"), Integer.parseInt(matcher.group(4)), matcher.group(5), Integer.parseInt(matcher.group(6)), matcher.group(7), matcher.group(9), matcher.group(11) == null ? null : Integer.parseInt(matcher.group(11)), extensions ); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: getAllReceivers_message_without_affected_receivers() { ContactMessageReceiver contactMessageReceiver = createContactMessageReceiver();  // Message receiver without affected receivers List<MessageReceiver> allReceivers = MessageUtil.getAllReceivers(contactMessageReceiver); "<AssertPlaceHolder>"; assertEquals(contactMessageReceiver, allReceivers.get(0)); }
getAllReceivers(final MessageReceiver messageReceiver) {  ArrayList<MessageReceiver> allReceivers = new ArrayList<>(); allReceivers.add(messageReceiver);  List<MessageReceiver> affectedReceivers = messageReceiver.getAffectedMessageReceivers(); if (affectedReceivers != null && affectedReceivers.size() > 0) { allReceivers.addAll(Functional.filter(affectedReceivers, new IPredicateNonNull<>() { @Override public boolean apply(@NonNull MessageReceiver type) { return !type.isEqual(messageReceiver); } })); } return allReceivers; }
[*] target: assertEquals(1, allReceivers.size())
[-] pred: org. junit. Assert. assertEquals ( 1, allReceivers. size ( ) )
************************************
************************************
[+] input: Exception { String base64QrCodeContent = "BTkCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkIjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIxM3EzcTNxM3EzcTNxM3EzcTNxM3EzcTNxM3EzcTNxM3BNJzYWx0eXJ0Yy5leGFtcGxlLm9yZw==";  QRCodeParser service = new QRCodeParserImpl(); QRCodeParser.Result result = service.parse(Base64.decode(base64QrCodeContent)); "<AssertPlaceHolder>"; assertEquals("saltyrtc.example.org", result.saltyRtcHost); assertEquals(1234, result.saltyRtcPort); assertEquals(true, result.isPermanent); assertTrue(Arrays.equals(result.authToken, new byte[]{ 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35 })); assertTrue(Arrays.equals(result.key, new byte[]{ 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66 })); assertTrue(Arrays.equals(result.serverKey, new byte[] { 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55 })); }
parse(@Nullable byte[] payload) throws InvalidQrCodeException {  if(payload == null) { throw new InvalidQrCodeException("invalid payload string"); }  int fixedLength = PROTOCOL_VERSION_LENGTH + OPTIONS_LENGTH + KEY_LENGTH + AUTH_TOKEN_LENGTH + SERVER_KEY_LENGTH + SALTY_RTC_PORT_LENGTH ;  if(payload.length < fixedLength+1) { throw new InvalidQrCodeException("invalid payload length"); }  try { ByteArrayInputStream bis = new ByteArrayInputStream(payload);  byte[] protocolVersionBytes = new byte[PROTOCOL_VERSION_LENGTH]; bis.read(protocolVersionBytes);  int protocolVersion = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(protocolVersionBytes).getShort());  byte[] options = new byte[OPTIONS_LENGTH]; bis.read(options);  boolean isSelfHosted = (options[0] & 0x01) != 0; boolean isPermanent = (options[0] & 0x02) != 0;  byte[] key = new byte[KEY_LENGTH]; bis.read(key);  byte[] authToken = new byte[AUTH_TOKEN_LENGTH]; bis.read(authToken);  // Note: Server public key may consist of only 0 bytes if not defined in Threema Web byte[] serverKey = null; byte[] serverKeyTemporary = new byte[SERVER_KEY_LENGTH]; bis.read(serverKeyTemporary); for (byte b : serverKeyTemporary) { if (b != 0) { serverKey = serverKeyTemporary; break; } }  byte[] portBytes = new byte[SALTY_RTC_PORT_LENGTH]; bis.read(portBytes); int port = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(portBytes).getShort());  String host = new String(payload, fixedLength, payload.length - fixedLength);  return new Result( protocolVersion, isSelfHosted, isPermanent, key, authToken, serverKey, port, host); } catch (IOException x) { throw new InvalidQrCodeException("Invalid Threema Web QR code contents"); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { String base64QrCodeContent = "BTkCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkIjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABNJzYWx0eXJ0Yy5leGFtcGxlLm9yZw==";  QRCodeParser service = new QRCodeParserImpl(); QRCodeParser.Result result = service.parse(Base64.decode(base64QrCodeContent)); "<AssertPlaceHolder>"; assertEquals("saltyrtc.example.org", result.saltyRtcHost); assertEquals(1234, result.saltyRtcPort); assertEquals(true, result.isPermanent); assertTrue(Arrays.equals(result.authToken, new byte[]{ 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35 })); assertTrue(Arrays.equals(result.key, new byte[]{ 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66 }));  //no server key assertNull(result.serverKey); }
parse(@Nullable byte[] payload) throws InvalidQrCodeException {  if(payload == null) { throw new InvalidQrCodeException("invalid payload string"); }  int fixedLength = PROTOCOL_VERSION_LENGTH + OPTIONS_LENGTH + KEY_LENGTH + AUTH_TOKEN_LENGTH + SERVER_KEY_LENGTH + SALTY_RTC_PORT_LENGTH ;  if(payload.length < fixedLength+1) { throw new InvalidQrCodeException("invalid payload length"); }  try { ByteArrayInputStream bis = new ByteArrayInputStream(payload);  byte[] protocolVersionBytes = new byte[PROTOCOL_VERSION_LENGTH]; bis.read(protocolVersionBytes);  int protocolVersion = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(protocolVersionBytes).getShort());  byte[] options = new byte[OPTIONS_LENGTH]; bis.read(options);  boolean isSelfHosted = (options[0] & 0x01) != 0; boolean isPermanent = (options[0] & 0x02) != 0;  byte[] key = new byte[KEY_LENGTH]; bis.read(key);  byte[] authToken = new byte[AUTH_TOKEN_LENGTH]; bis.read(authToken);  // Note: Server public key may consist of only 0 bytes if not defined in Threema Web byte[] serverKey = null; byte[] serverKeyTemporary = new byte[SERVER_KEY_LENGTH]; bis.read(serverKeyTemporary); for (byte b : serverKeyTemporary) { if (b != 0) { serverKey = serverKeyTemporary; break; } }  byte[] portBytes = new byte[SALTY_RTC_PORT_LENGTH]; bis.read(portBytes); int port = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(portBytes).getShort());  String host = new String(payload, fixedLength, payload.length - fixedLength);  return new Result( protocolVersion, isSelfHosted, isPermanent, key, authToken, serverKey, port, host); } catch (IOException x) { throw new InvalidQrCodeException("Invalid Threema Web QR code contents"); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testConvertList() { doCallRealMethod().when(factory).convertList(any(Cursor.class));  Cursor cursorMock = mock(Cursor.class); BallotModel ballotModelMock1 = mock(BallotModel.class); BallotModel ballotModelMock2 = mock(BallotModel.class); BallotModel ballotModelMock3 = mock(BallotModel.class);   // Loop three times when(cursorMock.moveToNext()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false); when(factory.convert(cursorMock)).thenReturn(ballotModelMock1).thenReturn(ballotModelMock2).thenReturn(ballotModelMock3); List<BallotModel> result = factory.convertList(cursorMock);  verify(factory, times(3)).convert(cursorMock);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(ballotModelMock1, result.get(0)); Assert.assertEquals(ballotModelMock2, result.get(1)); Assert.assertEquals(ballotModelMock3, result.get(2)); }
convert(Cursor cursor) { if(cursor != null && cursor.getPosition() >= 0) { final BallotModel c = new BallotModel();  //convert default new CursorHelper(cursor, this.getColumnIndexCache()).current(new CursorHelper.Callback() { @Override public boolean next(CursorHelper cursorHelper) { c .setId(cursorHelper.getInt(BallotModel.COLUMN_ID)) .setApiBallotId(cursorHelper.getString(BallotModel.COLUMN_API_BALLOT_ID)) .setCreatorIdentity(cursorHelper.getString(BallotModel.COLUMN_CREATOR_IDENTITY)) .setName(cursorHelper.getString(BallotModel.COLUMN_NAME)) .setCreatedAt(cursorHelper.getDate(BallotModel.COLUMN_CREATED_AT)) .setModifiedAt(cursorHelper.getDate(BallotModel.COLUMN_MODIFIED_AT)) .setLastViewedAt(cursorHelper.getDate(BallotModel.COLUMN_LAST_VIEWED_AT));  String stateString = cursorHelper.getString(BallotModel.COLUMN_STATE); if (!TestUtil.empty(stateString)) { c.setState(BallotModel.State.valueOf(stateString)); } String assessment = cursorHelper.getString(BallotModel.COLUMN_ASSESSMENT); if (!TestUtil.empty(assessment)) { c.setAssessment(BallotModel.Assessment.valueOf(assessment)); }  String type = cursorHelper.getString(BallotModel.COLUMN_TYPE); if (!TestUtil.empty(type)) { c.setType(BallotModel.Type.valueOf(type)); }  String choiceType = cursorHelper.getString(BallotModel.COLUMN_CHOICE_TYPE); if (!TestUtil.empty(choiceType)) { c.setChoiceType(BallotModel.ChoiceType.valueOf(choiceType)); }  String displayType = cursorHelper.getString(BallotModel.COLUMN_DISPLAY_TYPE); if (!TestUtil.empty(displayType)) { c.setDisplayType(BallotModel.DisplayType.valueOf(displayType)); }  return false; } });  return c; }  return null; }
[*] target: assertEquals(3, result.size())
[-] pred: org. junit. Assert. assertEquals ( 3, result. size ( ) )
************************************
************************************
[+] input: testUnsignedLongToBigInteger() { final BigInteger bigInteger = new BigInteger("18446744073709551610"); final long unsignedLong = bigInteger.longValue(); Assert.assertTrue(unsignedLong < 0); final BigInteger bigInteger2 = UnsignedHelper.unsignedLongToBigInteger(unsignedLong); Assert."<AssertPlaceHolder>"; }
unsignedLongToBigInteger(long val) { if (val >= 0L) { return BigInteger.valueOf(val); } else { int upper = (int) (val >>> 32); int lower = (int) val; return (BigInteger.valueOf(Integer.toUnsignedLong(upper))).shiftLeft(32). add(BigInteger.valueOf(Integer.toUnsignedLong(lower))); } }
[*] target: assertEquals(bigInteger, bigInteger2)
[-] pred: org. junit. Assert. assertEquals ( bigInteger, bigInteger2 )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"support":"the-support-url"}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertEquals("the-support-url", result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject .put("username", "u") .put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"logo":{"dark": "the-dark-logo"}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertEquals("the-dark-logo", result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"logo":{"light": "the-light-logo"}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertEquals("the-light-logo", result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn( new PostJsonResult( "{"contacts":[" + "{"id":"id1","pk":"AQ=="}," + "{"id":"id2","pk":"Aq==","first":"id2-firstname"}," + "{"id":"id3","pk":"Aw==","last":"id3-lastname"}," + "{"id":"id4","pk":"BA==","first": "id4-firstname", "last":"id4-lastname"}" + "]}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(4, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size());  // Verify contacts Assert.assertEquals("id1", result.workContacts.get(0).threemaId); Assert.assertArrayEquals(new byte[]{0x01}, result.workContacts.get(0).publicKey); Assert.assertNull(result.workContacts.get(0).firstName); Assert.assertNull(result.workContacts.get(0).lastName);  Assert.assertEquals("id2", result.workContacts.get(1).threemaId); Assert.assertArrayEquals(new byte[]{0x02}, result.workContacts.get(1).publicKey); Assert.assertEquals("id2-firstname", result.workContacts.get(1).firstName); Assert.assertNull(result.workContacts.get(1).lastName);  Assert.assertEquals("id3", result.workContacts.get(2).threemaId); Assert.assertArrayEquals(new byte[]{0x03}, result.workContacts.get(2).publicKey); Assert.assertNull(result.workContacts.get(2).firstName); Assert.assertEquals("id3-lastname", result.workContacts.get(2).lastName);  Assert.assertEquals("id4", result.workContacts.get(3).threemaId); Assert.assertArrayEquals(new byte[]{0x04}, result.workContacts.get(3).publicKey); Assert.assertEquals("id4-firstname", result.workContacts.get(3).firstName); Assert.assertEquals("id4-lastname", result.workContacts.get(3).lastName); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"mdm":{" + ""override": true," + ""params":{" + ""param-string": "string-param"," + ""param-bool": true," + ""param-int": 123" + "}}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertTrue(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(3, result.mdm.parameters.size());  Assert.assertTrue(result.mdm.parameters.containsKey("param-string")); Assert.assertEquals("string-param", result.mdm.parameters.get("param-string")); Assert.assertTrue(result.mdm.parameters.containsKey("param-bool")); Assert.assertEquals(true, result.mdm.parameters.get("param-bool")); Assert.assertTrue(result.mdm.parameters.containsKey("param-int")); Assert.assertEquals(123, result.mdm.parameters.get("param-int")); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  when(connector.fetchIdentity(eq("ERIC4911"))).thenCallRealMethod(); when(connector.doGet(eq("https://server.url/identity/ERIC4911"))) .thenReturn("{" + ""identity": "ERIC4911"," + ""publicKey": "aGVsbG8="," + ""featureLevel": 3," + ""featureMask": 15," + ""state": 1," + ""type": 2" + "}"); APIConnector.FetchIdentityResult result = connector.fetchIdentity("ERIC4911"); Assert."<AssertPlaceHolder>"; Assert.assertEquals("ERIC4911", result.identity); Assert.assertEquals(15, result.featureMask); Assert.assertEquals(1, result.state); Assert.assertEquals(2, result.type); }
fetchIdentity(String identity) throws ThreemaException, NetworkException, HttpConnectionException { try { String responseStr = doGet(getServerUrl() + "identity/" + identity); JSONObject jsonResponse = new JSONObject(responseStr);  FetchIdentityResult result = new FetchIdentityResult(); result.publicKey = Base64.decode(jsonResponse.getString("publicKey")); result.featureLevel = jsonResponse.optInt("featureLevel"); result.featureMask = jsonResponse.optInt("featureMask"); result.identity = jsonResponse.getString("identity"); result.state = jsonResponse.optInt("state"); result.type = jsonResponse.optInt("type"); return result; } catch (JSONException | IOException e) { throw new NetworkException(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock(); final IdentityStoreInterface identityStore = getIdentityStoreInterfaceMock();  when(identityStore.getIdentity()).thenReturn("FOOBAR12"); when(identityStore.calcSharedSecret(any())).thenReturn(new byte[32]); System.out.println(identityStore.getIdentity()); when(connector.obtainTurnServers(eq(identityStore), eq("voip"))).thenCallRealMethod(); when(connector.postJson(eq("https://server.url/identity/turn_cred"), ArgumentMatchers.any())) .thenReturn("{" + ""token": "/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="," + ""tokenRespKeyPub": "dummy"" + "}") .thenReturn("{" + ""success": true," + ""turnUrls": ["turn:foo", "turn:bar"]," + ""turnUrlsDualStack": ["turn:ds-foo", "turn:ds-bar"]," + ""turnUsername": "s00perturnuser"," + ""turnPassword": "t0psecret"," + ""expiration": 86400" + "}");  APIConnector.TurnServerInfo result = connector.obtainTurnServers(identityStore, "voip"); Assert."<AssertPlaceHolder>"; Assert.assertArrayEquals(new String[] {"turn:foo", "turn:bar"}, result.turnUrls); Assert.assertArrayEquals(new String[] {"turn:ds-foo", "turn:ds-bar"}, result.turnUrlsDualStack); Assert.assertEquals("s00perturnuser", result.turnUsername); Assert.assertEquals("t0psecret", result.turnPassword);  Date expectedExpirationDate = new Date(new Date().getTime() + 86400*1000); Assert.assertTrue(Math.abs(expectedExpirationDate.getTime() - result.expirationDate.getTime()) < 10000); }
obtainTurnServers(IdentityStoreInterface identityStore, String type) throws Exception { if (identityStore == null || identityStore.getIdentity() == null || identityStore.getIdentity().isEmpty()) { return null; }  String url = getServerUrl() + "identity/turn_cred";  // Phase 1: send identity and type JSONObject request = new JSONObject(); request.put("identity", identityStore.getIdentity()); request.put("type", type);  logger.debug("Obtain TURN servers phase 1: sending to server: {}", request); JSONObject p1Result = new JSONObject(this.postJson(url, request)); logger.debug("Obtain TURN servers phase 1: response from server: {}", p1Result);  makeTokenResponse(p1Result, request, identityStore);  // Phase 2: send token response logger.debug("Obtain TURN servers phase 2: sending to server: {}", request); JSONObject p2Result = new JSONObject(this.postJson(url, request)); logger.debug("Obtain TURN servers phase 2: response from server: {}", p2Result);  if (!p2Result.getBoolean("success")) { throw new ThreemaException(p2Result.getString("error")); }  String[] turnUrls = jsonArrayToStringArray(p2Result.getJSONArray("turnUrls")); String[] turnUrlsDualStack = jsonArrayToStringArray(p2Result.getJSONArray("turnUrlsDualStack")); String turnUsername = p2Result.getString("turnUsername"); String turnPassword = p2Result.getString("turnPassword"); int expiration = p2Result.getInt("expiration"); Date expirationDate = new Date(new Date().getTime() + expiration * 1000L);  return new TurnServerInfo(turnUrls, turnUrlsDualStack, turnUsername, turnPassword, expirationDate); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"org":{" + ""name": "monkeybusiness"" + "}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertEquals("monkeybusiness", result.organization.name);  }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertNull(result.organization.name);  }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{" + "directory:{" + "enabled: true," + "cat: {" + ""c1": "Category 1"," + ""c2": "Category 2"," + ""c3": "Category 3"" + "}}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertNull(result.organization.name); Assert.assertTrue(result.directory.enabled); Assert.assertNotNull(result.directory.categories); Assert.assertEquals(3, result.directory.categories.size());  boolean c1 = false; boolean c2 = false; boolean c3 = false;  for(WorkDirectoryCategory c: result.directory.categories) { switch (c.id) { case "c1": Assert.assertFalse("c1 already found", c1); c1 = true; Assert.assertEquals("Category 1", c.name); break; case "c2": Assert.assertFalse("c1 already found", c2); c2 = true; Assert.assertEquals("Category 2", c.name); break; case "c3": Assert.assertFalse("c1 already found", c3); c3 = true; Assert.assertEquals("Category 3", c.name); break; default: Assert.fail("Invalid category " + c.id); } } }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); final IdentityStoreInterface identityStore = getIdentityStoreInterfaceMock(); when(identityStore.getIdentity()).thenReturn("IDENTITY"); JSONObject requiredObject = new JSONObject(); requiredObject .put("username", "u") .put("password", "eric") .put("identity", "IDENTITY") .put("query", "Query String") .put("categories", (new JSONArray()).put("c100")) .put("sort", (new JSONObject()) .put("asc", true) .put("by", "firstName")) .put("page", 1);  when(connector.fetchWorkDirectory(any(), any(), any(), any())).thenCallRealMethod(); when(connector.postJson( eq("https://api-work.threema.ch/directory"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn( "{\n" + "   "contacts": [\n" + "      {\n" + "         "id": "ECHOECHO",\n" + "         "pk": "base64",\n" + "         "first": "Hans",\n" + "         "last": "Nötig",\n" + "         "csi": "CSI_NR",\n" + "         "org": { "name": "Name der Firma/Organisation" },\n" + "         "cat": [\n" + "            "catId1",\n" + "            "catId2"\n" + "         ]\n" + "      }\n" + "   ],\n" + "   "paging": {\n" + "      "size": 10,\n" + "      "total": 8923,\n" + "      "next": 2,\n" + "      "prev": 0\n" + "   }\n" + "}" );  WorkDirectoryFilter filter = new WorkDirectoryFilter(); filter.addCategory(new WorkDirectoryCategory("c100", "Category 100")); filter.query("Query String"); filter.page(1); WorkDirectory result = connector.fetchWorkDirectory("u", "eric", identityStore, filter);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, result.workContacts.size()); Assert.assertEquals("ECHOECHO", result.workContacts.get(0).threemaId); Assert.assertEquals("Hans", result.workContacts.get(0).firstName); Assert.assertEquals("Nötig", result.workContacts.get(0).lastName); Assert.assertEquals("CSI_NR", result.workContacts.get(0).csi); Assert.assertEquals("Name der Firma/Organisation", result.workContacts.get(0).organization.name); Assert.assertEquals(2, result.workContacts.get(0).categoryIds.size()); Assert.assertEquals("catId1", result.workContacts.get(0).categoryIds.get(0)); Assert.assertEquals("catId2", result.workContacts.get(0).categoryIds.get(1)); Assert.assertEquals(10, result.pageSize); Assert.assertEquals(8923, result.totalRecord); Assert.assertEquals(2, result.nextFilter.getPage()); Assert.assertEquals(filter.getQuery(), result.nextFilter.getQuery()); Assert.assertEquals(filter.getCategories(), result.nextFilter.getCategories()); Assert.assertEquals(0, result.previousFilter.getPage()); Assert.assertEquals(filter.getQuery(), result.previousFilter.getQuery()); Assert.assertEquals(filter.getCategories(), result.previousFilter.getCategories()); }
fetchWorkDirectory( @NonNull String username, @NonNull String password, @NonNull IdentityStoreInterface identityStore, @NonNull WorkDirectoryFilter filter ) throws Exception { JSONObject request = new JSONObject(); request.put("username", username); request.put("password", password); request.put("identity", identityStore.getIdentity()); request.put("query", filter.getQuery());  // Filter category if (filter.getCategories() != null && filter.getCategories().size() > 0) { JSONArray jsonCategories = new JSONArray(); for (WorkDirectoryCategory category: filter.getCategories()) { jsonCategories.put(category.id); } request.put("categories", jsonCategories); }  // Sorting JSONObject jsonSort = new JSONObject();  jsonSort.put("asc", filter.isSortAscending()); //noinspection SwitchStatementWithTooFewBranches switch (filter.getSortBy()) { case WorkDirectoryFilter.SORT_BY_LAST_NAME: jsonSort.put("by", "lastName"); break; default: jsonSort.put("by", "firstName"); break; }  request.put("sort", jsonSort);  // Paging request.put("page", filter.getPage());  String data = this.postJson(getWorkServerUrl() + "directory", request);  // Verify request if (data == null || data.length() == 0) { return null; }  JSONObject jsonResponse = new JSONObject(data);  if (jsonResponse.has("contacts") && !jsonResponse.isNull("contacts")) {  // Verify content JSONArray contacts = jsonResponse.getJSONArray("contacts");  int total = contacts.length(); int pageSize = total; WorkDirectoryFilter filterNext = null; WorkDirectoryFilter filterPrevious = null;  if (jsonResponse.has("paging") && !jsonResponse.isNull("paging")) { JSONObject paging = jsonResponse.getJSONObject("paging");  pageSize = paging.optInt("size", pageSize); total = paging.optInt("total", total); if (paging.has("next")) { // Next filter filterNext = filter.copy() .page(jsonResponse.optInt("next", filter.getPage() + 1)); } if (paging.has("prev")) { // Next filter filterPrevious = filter.copy() .page(jsonResponse.optInt("prev", filter.getPage() - 1)); } }  WorkDirectory workDirectory = new WorkDirectory( total, pageSize, filter, filterNext, filterPrevious );  for (int n = 0; n < contacts.length(); n++) { JSONObject contact = contacts.getJSONObject(n);  //validate fields if (contact.has("id") && contact.has("pk")) { WorkDirectoryContact directoryContact = new WorkDirectoryContact( contact.getString("id"), Base64.decode(contact.getString("pk")), contact.has("first") ? (contact.isNull("first") ? null : contact.optString("first")) : null, contact.has("last") ? (contact.isNull("last") ? null : contact.optString("last")) : null, contact.has("csi") ? (contact.isNull("csi") ? null : contact.optString("csi")) : null );  if (!contact.isNull("org")) { JSONObject jsonResponseOrganization = contact.optJSONObject("org");  if (jsonResponseOrganization != null && !jsonResponseOrganization.isNull("name")) { directoryContact.organization.name = jsonResponseOrganization.optString("name"); } }  JSONArray categoryArray = contact.optJSONArray("cat"); if (categoryArray != null) { for (int cN = 0; cN < categoryArray.length(); cN++) { directoryContact.categoryIds.add(categoryArray.getString(cN)); } }  workDirectory.workContacts.add(directoryContact); } }  return workDirectory; }  // Invalid request return null;  }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: JSONException { final JSONObject o = new JSONObject(); final FeatureList list = FeatureList.parse(o); Assert."<AssertPlaceHolder>"; }
isEmpty() { return this.features.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty ( ) )
************************************
************************************
[+] input: testLabelTreeKeyRegressionShare_sharedNodesShouldBeEqual() { int depth = 20; int from = 2000; int to = 3000; IPRF aesni = PRFFactory.getDefaultPRF(); TreeKeyRegression reg = (TreeKeyRegression) TreeKeyRegressionFactory.getNewDefaultTESTKeyRegression(aesni, depth); LabelTreeKeyRegression reg2 = new LabelTreeKeyRegression(aesni, depth, new byte[16]); ArrayList<SeedNode> nodes = reg.revealSeeds(from, to); List<SeedNode> nodes2 = reg2.constrainNodes(from, to + 1);  for (SeedNode tn : nodes2) { boolean ok = false; for (SeedNode sn : nodes) { if (Arrays.equals(sn.getSeed(), tn.getSeed())) { ok = true; break; } } "<AssertPlaceHolder>"; } }
revealSeeds(long from, long to) { assert isOwner; ArrayList<SeedNode> seedNodes = new ArrayList<SeedNode>(); if (from > to || rootSeed == null) throw new RuntimeException(String.format("%d is not smaller than %d", from, to)); for (int d = depth; d >= 0; d--) { for (int i = 0; i < kFactor - 1; i++) { if (from == to) { TreeKeyRegressionNode node = reveal(d, from); if (!seedNodes.contains(node)) seedNodes.add(node); } if (from % kFactor != 0) { TreeKeyRegressionNode node = reveal(d, from); if (!seedNodes.contains(node)) seedNodes.add(node); from++; } if (to % kFactor != kFactor - 1) { TreeKeyRegressionNode node = reveal(d, to); if (!seedNodes.contains(node)) seedNodes.add(node); to--; } if (from > to) { break; } } if (from > to) { break; } from /= kFactor; to /= kFactor; } sortNodeArray(seedNodes); return seedNodes; }
[*] target: assertTrue(ok)
[-] pred: org. junit. Assert. assertTrue ( ok )
************************************
************************************
[+] input: DecodingException { AlfenSignatureVerifier verifier = new AlfenSignatureVerifier(); AlfenReader reader = new AlfenReader(); AlfenSignature signature = reader.parseString(ALFEN_TEST_STRING); String publicKey = signature.getPublicKey();  boolean result = verifier.verify(EncodingType.base32Decode(publicKey), signature.getSignature(), signature.getDataset()); Assert."<AssertPlaceHolder>"; }
verify(byte[] publicKey, byte[] signature, byte[] payloadData) throws ValidationException { ECDSASigner signer = new ECDSASigner(); X9ECParameters ecParameters = SECNamedCurves.getByName(ELLIPTIC_CURVE_ALGORITHM); ECCurve curve = ecParameters.getCurve();  //create the public key paramters for init of the signing lib ECDomainParameters ecDomainParameters = new ECDomainParameters(curve, ecParameters.getG(), ecParameters.getN(), ecParameters.getH(), ecParameters.getSeed()); ECPublicKeyParameters publicKeyParsed; try { publicKeyParsed = new ECPublicKeyParameters(curve.decodePoint(publicKey), ecDomainParameters); } catch (IllegalArgumentException e) { LOGGER.error("Invalid point given for public key", e); //is thrown if point is not valid e.g. not on curve throw new ValidationException("Invalid public key point given", "error.invalid.public.key"); }  if (signature.length != SIGNATURE_LENGTH) { throw new ValidationException("Invalid length of signature given", "error.invalid.signature.length"); } //verify the signature divided in two coordinates, r and s BigInteger signatureR = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 0, 24)); BigInteger signatureS = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 24, 24));  byte[] hashedData = Utils.hashSHA256(payloadData);  signer.init(false, publicKeyParsed); boolean verify = signer.verifySignature(hashedData, signatureR, signatureS); VerificationLogger.log("ALFEN", ELLIPTIC_CURVE_ALGORITHM, publicKey, hashedData, signature, verify); return verify;  }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: DecodingException { AlfenSignatureVerifier verifier = new AlfenSignatureVerifier(); AlfenReader reader = new AlfenReader(); AlfenSignature signature = reader.parseString(ALFEN_TEST_STRING_2); boolean result = verifier.verify(EncodingType.base32Decode(signature.getPublicKey()), signature.getSignature(), signature.getDataset()); Assert."<AssertPlaceHolder>"; }
verify(byte[] publicKey, byte[] signature, byte[] payloadData) throws ValidationException { ECDSASigner signer = new ECDSASigner(); X9ECParameters ecParameters = SECNamedCurves.getByName(ELLIPTIC_CURVE_ALGORITHM); ECCurve curve = ecParameters.getCurve();  //create the public key paramters for init of the signing lib ECDomainParameters ecDomainParameters = new ECDomainParameters(curve, ecParameters.getG(), ecParameters.getN(), ecParameters.getH(), ecParameters.getSeed()); ECPublicKeyParameters publicKeyParsed; try { publicKeyParsed = new ECPublicKeyParameters(curve.decodePoint(publicKey), ecDomainParameters); } catch (IllegalArgumentException e) { LOGGER.error("Invalid point given for public key", e); //is thrown if point is not valid e.g. not on curve throw new ValidationException("Invalid public key point given", "error.invalid.public.key"); }  if (signature.length != SIGNATURE_LENGTH) { throw new ValidationException("Invalid length of signature given", "error.invalid.signature.length"); } //verify the signature divided in two coordinates, r and s BigInteger signatureR = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 0, 24)); BigInteger signatureS = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 24, 24));  byte[] hashedData = Utils.hashSHA256(payloadData);  signer.init(false, publicKeyParsed); boolean verify = signer.verifySignature(hashedData, signatureR, signatureS); VerificationLogger.log("ALFEN", ELLIPTIC_CURVE_ALGORITHM, publicKey, hashedData, signature, verify); return verify;  }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: DecodingException { AlfenSignatureVerifier verifier = new AlfenSignatureVerifier(); AlfenReader reader = new AlfenReader(); AlfenSignature signature = reader.parseString(ALFEN_TEST_STRING_3); boolean result = verifier.verify(EncodingType.base32Decode(signature.getPublicKey()), signature.getSignature(), signature.getDataset()); Assert."<AssertPlaceHolder>"; }
verify(byte[] publicKey, byte[] signature, byte[] payloadData) throws ValidationException { ECDSASigner signer = new ECDSASigner(); X9ECParameters ecParameters = SECNamedCurves.getByName(ELLIPTIC_CURVE_ALGORITHM); ECCurve curve = ecParameters.getCurve();  //create the public key paramters for init of the signing lib ECDomainParameters ecDomainParameters = new ECDomainParameters(curve, ecParameters.getG(), ecParameters.getN(), ecParameters.getH(), ecParameters.getSeed()); ECPublicKeyParameters publicKeyParsed; try { publicKeyParsed = new ECPublicKeyParameters(curve.decodePoint(publicKey), ecDomainParameters); } catch (IllegalArgumentException e) { LOGGER.error("Invalid point given for public key", e); //is thrown if point is not valid e.g. not on curve throw new ValidationException("Invalid public key point given", "error.invalid.public.key"); }  if (signature.length != SIGNATURE_LENGTH) { throw new ValidationException("Invalid length of signature given", "error.invalid.signature.length"); } //verify the signature divided in two coordinates, r and s BigInteger signatureR = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 0, 24)); BigInteger signatureS = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 24, 24));  byte[] hashedData = Utils.hashSHA256(payloadData);  signer.init(false, publicKeyParsed); boolean verify = signer.verifySignature(hashedData, signatureR, signatureS); VerificationLogger.log("ALFEN", ELLIPTIC_CURVE_ALGORITHM, publicKey, hashedData, signature, verify); return verify;  }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testTimestampParsing() { Reading reading = new Reading(); reading.setTM("2018-07-24T13:22:04,000+0200 S"); OffsetDateTime timestamp = reading.getTimestamp(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2018, timestamp.getYear()); Assert.assertEquals(7, timestamp.getMonthValue()); Assert.assertEquals(24, timestamp.getDayOfMonth()); Assert.assertEquals(13, timestamp.getHour()); Assert.assertEquals(22, timestamp.getMinute()); Assert.assertEquals(4, timestamp.getSecond()); Assert.assertEquals(0, timestamp.getNano()); Assert.assertEquals(2 * 60 * 60, timestamp.getOffset().getTotalSeconds()); }
getTimestamp() { if (TM == null) { return null; } String[] splitted = TM.split(" "); if (splitted.length < 2) { return null; } try { DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss,SSSZ"); return OffsetDateTime.parse(splitted[0], formatter); } catch (DateTimeParseException e) { return null; } }
[*] target: assertNotNull(timestamp)
[-] pred: org. junit. Assert. assertNotNull ( timestamp )
************************************
************************************
[+] input: testTimestampWrongFormatNull() { Reading reading = new Reading(); reading.setTM("2018-07-24T13:22:04,000+0200S"); Assert."<AssertPlaceHolder>"; }
getTimeSynchronicity() { if (TM == null) { return null; } String[] splitted = TM.split(" "); if (splitted.length < 2) { return null; } return splitted[1]; }
[*] target: assertNull(reading.getTimeSynchronicity())
[-] pred: org. junit. Assert. assertNull ( reading. getTimeSynchronicity ( ) )
************************************
************************************
[+] input: testTimestampSynchronicityNull() { Reading reading = new Reading(); Assert."<AssertPlaceHolder>"; }
getTimeSynchronicity() { if (TM == null) { return null; } String[] splitted = TM.split(" "); if (splitted.length < 2) { return null; } return splitted[1]; }
[*] target: assertNull(reading.getTimeSynchronicity())
[-] pred: org. junit. Assert. assertNull ( reading. getTimeSynchronicity() )
************************************
************************************
[+] input: DecodingException { SMLReader smlReader = new SMLReader(); SMLSignature signature = smlReader.parsePayloadData(EncodingType.BASE64.decode(SML_DATA_FULL_NEW)); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(signature.getProvidedSignature()); Assert.assertEquals(2918, signature.getMeterPositionAsLong()); Assert.assertEquals("09 01 45 4D 48 00 00 7A C6 62", Utils.toFormattedHex(signature.getServerId())); Assert.assertEquals(65, new BigInteger(Utils.reverseByteOrder(signature.getPagination())).intValue()); Assert.assertEquals(340285, new BigInteger(Utils.reverseByteOrder(signature.getSecondsIndex())).intValue()); Assert.assertEquals(10, new BigInteger(signature.getBytesLog()).intValue()); Assert.assertEquals(8, new BigInteger(new byte[]{signature.getStatus()}).intValue());  LocalDateTime dateTime = LocalDateTime.of(2018, Month.AUGUST, 28, 18, 57, 37); OffsetDateTime offsetDateTime = OffsetDateTime.of(dateTime, ZoneOffset.of("+02:00")); Assert.assertEquals(offsetDateTime, signature.getTimestampAsDate());   }
parsePayloadData(byte[] smlData) throws ValidationException { try { final SMLSignature smlSignature = parseRawSMLBytes(smlData); if (smlSignature == null) { throw new SMLValidationException("Could not read sml data incomplete data", "error.sml.incomplete"); } // will throw an sml validation exception if check fails smlSignature.isDataComplete();  if (smlSignature.getUnit() != 30) { throw new SMLValidationException("Invalid unit present in sml data", "error.sml.invalid.unit"); } return smlSignature; } catch (final IOException e) { throw new SMLValidationException("Could not read sml data, invalid format", e); }  }
[*] target: assertNotNull(signature)
[-] pred: org. junit. Assert. assertNotNull ( signature )
************************************
************************************
[+] input: DecodingException { SMLReader smlReader = new SMLReader(); SMLSignature signature = smlReader.parsePayloadData(EncodingType.BASE64.decode(SML_DATA_TECHNAGON)); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(signature.getProvidedSignature()); Assert.assertEquals(46201, signature.getMeterPositionAsLong()); Assert.assertEquals("09 01 45 4D 48 00 00 7F 92 03", Utils.toFormattedHex(signature.getServerId())); Assert.assertEquals(14, new BigInteger(Utils.reverseByteOrder(signature.getPagination())).intValue()); Assert.assertEquals(83696, new BigInteger(Utils.reverseByteOrder(signature.getSecondsIndex())).intValue()); Assert.assertEquals(59, new BigInteger(signature.getBytesLog()).intValue()); Assert.assertEquals(8, new BigInteger(new byte[]{signature.getStatus()}).intValue());  LocalDateTime dateTime = LocalDateTime.of(2017, Month.NOVEMBER, 23, 15, 13, 07); OffsetDateTime offsetDateTime = OffsetDateTime.of(dateTime, ZoneOffset.of("+00:00")); Assert.assertEquals(offsetDateTime, signature.getTimestampAsDate());   }
parsePayloadData(byte[] smlData) throws ValidationException { try { final SMLSignature smlSignature = parseRawSMLBytes(smlData); if (smlSignature == null) { throw new SMLValidationException("Could not read sml data incomplete data", "error.sml.incomplete"); } // will throw an sml validation exception if check fails smlSignature.isDataComplete();  if (smlSignature.getUnit() != 30) { throw new SMLValidationException("Invalid unit present in sml data", "error.sml.invalid.unit"); } return smlSignature; } catch (final IOException e) { throw new SMLValidationException("Could not read sml data, invalid format", e); }  }
[*] target: assertNotNull(signature)
[-] pred: org. junit. Assert. assertNotNull ( signature )
************************************
************************************
[+] input: ValidationException { URL url = this.getClass().getResource("/xml/test_mennekes_full.xml"); File testfile = new File(url.getFile()); String testData = TestUtils.readFile(testfile); XMLReader xmlReader = new XMLReader(); Billing billing = xmlReader.readFromString(testData);  Assert."<AssertPlaceHolder>"; Customer customer = billing.getCustomer();  Assert.assertNotNull(customer); Assert.assertEquals(11, customer.getCustomerId()); Assert.assertEquals("ptb ptb", customer.getName1()); Assert.assertEquals("Bundesallee 100", customer.getStreet()); Assert.assertEquals("Braunschweig", customer.getTown());   Supplier supplier = billing.getSupplier(); Assert.assertNotNull(supplier); Assert.assertEquals("57399", supplier.getZipCode()); Assert.assertEquals("MENNEKES Elektrotechnik GmbH & Co. KG", supplier.getName1()); Assert.assertEquals("Aloys-Mennekes-Straße 1", supplier.getStreet()); Assert.assertEquals("+49 27 23 / 41 - 1", supplier.getPhone()); Assert.assertEquals("+49 27 23 / 41 - 214", supplier.getFax()); Assert.assertEquals("Kirchhundem", supplier.getTown()); Assert.assertEquals("info@MENNEKES.de", supplier.getMailAddress()); Assert.assertEquals("test", supplier.getMailSubject()); Assert.assertEquals("test", supplier.getMailBody()); Assert.assertEquals("https://www.chargeupyourday.com/", supplier.getWebAddress()); Assert.assertEquals("https://www.chargeupyourday.com/", supplier.getWebAddressLinkText());   Assert.assertNotNull(billing.getBillingPeriods()); Assert.assertEquals(1, billing.getBillingPeriods().size()); BillingPeriod period = billing.getBillingPeriods().get(0);  Assert.assertEquals("RE2017-01", period.getBillingNo()); Assert.assertEquals("1.8.0", period.getObisCode());  Assert.assertEquals("Lieferung Strom", period.getTitle());  LocalDateTime dateTimePeriodStart = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 22, 14); OffsetDateTime periodStart = OffsetDateTime.of(dateTimePeriodStart, ZoneOffset.of("+02:00")); Assert.assertEquals(periodStart, period.getBegin());  LocalDateTime dateTimePeriodEnd = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 26, 45); OffsetDateTime periodEnd = OffsetDateTime.of(dateTimePeriodEnd, ZoneOffset.of("+02:00")); Assert.assertEquals(periodEnd, period.getEnd());  Assert.assertEquals(1, period.getChargingProcesses().size()); ChargingProcess chargingProcess = period.getChargingProcesses().get(0); Assert.assertEquals("0901454D4800005BAE2F", chargingProcess.getServerId()); Assert.assertEquals("6DACB9C5466A25B3EB9F6466B53457C84A27448B01A64A278C0A28DAC95F2B45DF39B79918A9A4D2E3551F3FE925D09D", chargingProcess.getPublicKey()); Assert.assertEquals("DE*PWC*E00003*005", chargingProcess.getMeteringPoint());  SiteAddress siteAddress = chargingProcess.getSiteAddress(); Assert.assertNotNull(siteAddress); Assert.assertEquals("38116", siteAddress.getZipCode()); Assert.assertEquals("Bundesallee 100", siteAddress.getStreet()); Assert.assertEquals("Braunschweig", siteAddress.getTown());  Assert.assertEquals("874AD0FE", chargingProcess.getCustomerIdent());  LocalDateTime dateTimeCustomerIdent = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 22, 10); OffsetDateTime customerIdentTime = OffsetDateTime.of(dateTimeCustomerIdent, ZoneOffset.of("+02:00")); Assert.assertEquals(customerIdentTime, chargingProcess.getTimestampCustomerIdent());  Measurement measurementStart = chargingProcess.getMeasurementStart(); Assert.assertNotNull(measurementStart);  LocalDateTime measurementStartDT = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 22, 10); OffsetDateTime measurementStartTime = OffsetDateTime.of(measurementStartDT, ZoneOffset.of("+02:00")); Assert.assertEquals(measurementStartTime, measurementStart.getTimestampCustomerIdent());  LocalDateTime measurementStartDTTs = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 22, 14); OffsetDateTime measurementStartTimeTs = OffsetDateTime.of(measurementStartDTTs, ZoneOffset.of("+02:00")); Assert.assertEquals(measurementStartTimeTs, measurementStart.getTimestamp());  Assert.assertEquals("55CB60BB5E8AC580516F6A3DA5D6BB0365FD9DC04D50BE53B79FD95A2A92D749C36839B0A507E63A48E0A956A6FEFDB5", measurementStart.getSignature()); Assert.assertEquals(new Long(8), measurementStart.getEventCounter()); Assert.assertEquals(new Integer(65800), measurementStart.getMeterStatus()); Assert.assertEquals(new Long(519116), measurementStart.getValue()); Assert.assertEquals(-1, measurementStart.getScaler()); Assert.assertEquals(25, measurementStart.getPagination()); Assert.assertEquals(74650, measurementStart.getSecondIndex());   Measurement measurementEnd = chargingProcess.getMeasurementEnd(); Assert.assertNotNull(measurementEnd);  Assert.assertNull(measurementEnd.getTimestampCustomerIdent());  LocalDateTime measurementEndDTTs = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 26, 45); OffsetDateTime measurementEndTimeTs = OffsetDateTime.of(measurementEndDTTs, ZoneOffset.of("+02:00")); Assert.assertEquals(measurementEndTimeTs, measurementEnd.getTimestamp());  Assert.assertEquals("6574B62680B76639C2EF03CDEA34CCAC5633F3C7E08E5C251463F0DFED38B35A9675126DDA8F4B0CAB017B1A42C5EBDC", measurementEnd.getSignature()); Assert.assertEquals(new Long(8), measurementEnd.getEventCounter()); Assert.assertEquals(new Integer(65800), measurementEnd.getMeterStatus()); Assert.assertEquals(new Long(520535), measurementEnd.getValue()); Assert.assertEquals(-1, measurementEnd.getScaler()); Assert.assertEquals(26, measurementEnd.getPagination()); Assert.assertEquals(74921, measurementEnd.getSecondIndex());   }
readFromString(String xml) throws ValidationException { final StringReader reader = new StringReader(enforceXMLStartingString(xml)); try { return (Billing) unmarshaller.unmarshal(reader); } catch (final JAXBException e) { LOGGER.error("JAXB error on loading mennekes file", e); throw new ValidationException("Could not read mennekes xml data"); } }
[*] target: assertNotNull(billing)
[-] pred: org. junit. Assert. assertNotNull ( billing )
************************************
************************************
[+] input: test_read_public_key() { final SignatureOnlyVerificationParser parser = new SignatureOnlyVerificationParser(); final String s = parser.parsePublicKey(TestUtils.TEST_SIG_ONLY); Assert."<AssertPlaceHolder>"; }
parsePublicKey(String data) { try { final SignedMeterValue signedMeterValue = smlReader.readFromString(Utils.unescapeXML(data)); return signedMeterValue.getPublicKey() != null ? signedMeterValue.getPublicKey().getCleanedValue() : null; } catch (final ValidationException e) { return null; } }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: InterruptedException {  long second = Instant.parse("2021-12-31T23:59:59.000Z").getEpochSecond(); long leapSecond = second - 1; // simulate a leap second long times[] = { second, leapSecond };  Clock clock = new Clock() { private int i;  @Override public long millis() { return times[i++ % times.length] * 1000; }  @Override public ZoneId getZone() { return null; }  @Override public Clock withZone(ZoneId zone) { return null; }  @Override public Instant instant() { return null; } };  // a function that forces the clock to restart to ZERO IntFunction<byte[]> randomFunction = x -> new byte[x];  TsidFactory factory = TsidFactory.builder().withClock(clock).withRandomFunction(randomFunction).build();  long ms1 = factory.create().getUnixMilliseconds(); // second long ms2 = factory.create().getUnixMilliseconds(); // leap second  "<AssertPlaceHolder>"; // LEAP SECOND! DON'T MOVE BACKWARDS! }
create() { lock.lock(); try { final long _time = getTime() << RANDOM_BITS; final long _node = (long) this.node << this.counterBits; final long _counter = (long) this.counter & this.counterMask;  return new Tsid(_time | _node | _counter); } finally { lock.unlock(); } }
[*] target: assertEquals(ms1, ms2)
[-] pred: org. junit. Assert. assertEquals ( ms1, ms2 )
************************************
************************************
[+] input: testToString() { for (int i = 0; i < LOOP_MAX; i++) { final long number = ThreadLocalRandom.current().nextLong(); final String string0 = toString(number); final String string1 = Tsid.from(number).toString(); "<AssertPlaceHolder>"; } }
toString() { return toString(ALPHABET_UPPERCASE); }
[*] target: assertEquals(string0, string1)
[-] pred: org. junit. Assert. assertEquals ( string0, string1 )
************************************
************************************
[+] input: testGetTime() { for (int i = 0; i < LOOP_MAX; i++) { final long number = ThreadLocalRandom.current().nextLong(); Tsid tsid = Tsid.from(number);  long time0 = number >>> RANDOM_BITS; long time1 = tsid.getTime();  "<AssertPlaceHolder>"; } }
getTime() { return this.number >>> RANDOM_BITS; }
[*] target: assertEquals(time0, time1)
[-] pred: org. junit. Assert. assertEquals ( time0, time1 )
************************************
************************************
[+] input: testGetRandom() { for (int i = 0; i < LOOP_MAX; i++) { final long number = ThreadLocalRandom.current().nextLong(); Tsid tsid = Tsid.from(number);  long random0 = number << TIME_BITS >>> TIME_BITS; long random1 = tsid.getRandom();  "<AssertPlaceHolder>"; } }
getRandom() { return this.number & RANDOM_MASK; }
[*] target: assertEquals(random0, random1)
[-] pred: org. junit. Assert. assertEquals ( random0, random1 )
************************************
************************************
[+] input: checkOutgoingAccess() { FlowElement exclusiveGateway= EntityBuilder.buildExclusiveGateway(); FlowElement outgoningSequence = EntityBuilder.buildSequenceFlow2(); FlowElement outgoningSequence1 = EntityBuilder.buildSequenceFlow3(); Map<String, FlowElement> map = new HashMap<>(); map.put(exclusiveGateway.getKey(), exclusiveGateway); map.put(outgoningSequence.getKey(), outgoningSequence); map.put(outgoningSequence1.getKey(), outgoningSequence1); boolean access = false; try { exclusiveGatewayValidator.checkOutgoing(map, exclusiveGateway); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { List<String> outgoing = flowElement.getOutgoing();  if (CollectionUtils.isEmpty(outgoing)) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_LACK_OUTGOING); }  List<String> outgoingList = flowElement.getOutgoing(); int defaultConditionCount = 0;  for (String outgoingKey : outgoingList) { FlowElement outgoingSequenceFlow = FlowModelUtil.getFlowElement(flowElementMap, outgoingKey);  String condition = FlowModelUtil.getConditionFromSequenceFlow(outgoingSequenceFlow); boolean isDefaultCondition = FlowModelUtil.isDefaultCondition(outgoingSequenceFlow);  if (StringUtils.isBlank(condition) && !isDefaultCondition) { throwElementValidatorException(flowElement, ErrorEnum.EMPTY_SEQUENCE_OUTGOING); } if (isDefaultCondition) { defaultConditionCount++; } }  if (defaultConditionCount > 1) { throwElementValidatorException(flowElement, ErrorEnum.TOO_MANY_DEFAULT_SEQUENCE); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: checkEmptyOutgoing() { FlowElement exclusiveGateway= EntityBuilder.buildExclusiveGateway(); FlowElement outgoningSequence = EntityBuilder.buildSequenceFlow2(); Map<String, Object> properties = new HashMap<>(); properties.put("defaultConditions", "false"); properties.put("conditionsequenceflow", ""); outgoningSequence.setProperties(properties); FlowElement outgoningSequence1 = EntityBuilder.buildSequenceFlow3(); Map<String, FlowElement> map = new HashMap<>(); map.put(exclusiveGateway.getKey(), exclusiveGateway); map.put(outgoningSequence.getKey(), outgoningSequence); map.put(outgoningSequence1.getKey(), outgoningSequence1); boolean access = false; try { exclusiveGatewayValidator.checkOutgoing(map, exclusiveGateway); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { List<String> outgoing = flowElement.getOutgoing();  if (CollectionUtils.isEmpty(outgoing)) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_LACK_OUTGOING); }  List<String> outgoingList = flowElement.getOutgoing(); int defaultConditionCount = 0;  for (String outgoingKey : outgoingList) { FlowElement outgoingSequenceFlow = FlowModelUtil.getFlowElement(flowElementMap, outgoingKey);  String condition = FlowModelUtil.getConditionFromSequenceFlow(outgoingSequenceFlow); boolean isDefaultCondition = FlowModelUtil.isDefaultCondition(outgoingSequenceFlow);  if (StringUtils.isBlank(condition) && !isDefaultCondition) { throwElementValidatorException(flowElement, ErrorEnum.EMPTY_SEQUENCE_OUTGOING); } if (isDefaultCondition) { defaultConditionCount++; } }  if (defaultConditionCount > 1) { throwElementValidatorException(flowElement, ErrorEnum.TOO_MANY_DEFAULT_SEQUENCE); } }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: checkTooManySequenceOutgoig() { FlowElement exclusiveGateway= EntityBuilder.buildExclusiveGateway(); FlowElement outgoningSequence = EntityBuilder.buildSequenceFlow2(); Map<String, Object> properties = new HashMap<>(); properties.put("defaultConditions", "true"); properties.put("conditionsequenceflow", ""); outgoningSequence.setProperties(properties); FlowElement outgoningSequence1 = EntityBuilder.buildSequenceFlow3(); Map<String, Object> properties1 = new HashMap<>(); properties.put("defaultConditions", "true"); properties.put("conditionsequenceflow", ""); outgoningSequence1.setProperties(properties); Map<String, FlowElement> map = new HashMap<>(); map.put(exclusiveGateway.getKey(), exclusiveGateway); map.put(outgoningSequence.getKey(), outgoningSequence); map.put(outgoningSequence1.getKey(), outgoningSequence1); boolean access = false; try { exclusiveGatewayValidator.checkOutgoing(map, exclusiveGateway); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { List<String> outgoing = flowElement.getOutgoing();  if (CollectionUtils.isEmpty(outgoing)) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_LACK_OUTGOING); }  List<String> outgoingList = flowElement.getOutgoing(); int defaultConditionCount = 0;  for (String outgoingKey : outgoingList) { FlowElement outgoingSequenceFlow = FlowModelUtil.getFlowElement(flowElementMap, outgoingKey);  String condition = FlowModelUtil.getConditionFromSequenceFlow(outgoingSequenceFlow); boolean isDefaultCondition = FlowModelUtil.isDefaultCondition(outgoingSequenceFlow);  if (StringUtils.isBlank(condition) && !isDefaultCondition) { throwElementValidatorException(flowElement, ErrorEnum.EMPTY_SEQUENCE_OUTGOING); } if (isDefaultCondition) { defaultConditionCount++; } }  if (defaultConditionCount > 1) { throwElementValidatorException(flowElement, ErrorEnum.TOO_MANY_DEFAULT_SEQUENCE); } }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: validateElementKeyNotUnique() { List<FlowElement> flowElementsList = EntityBuilder.buildFlowElementList(); SequenceFlow sequenceFlow1 = new SequenceFlow(); sequenceFlow1.setKey("sequenceFlow1"); sequenceFlow1.setType(FlowElementType.SEQUENCE_FLOW); List<String> sfIncomings = new ArrayList<>(); sfIncomings.add("startEvent1"); sequenceFlow1.setIncoming(sfIncomings); List<String> sfOutgoings = new ArrayList<>(); sfOutgoings.add("userTask1"); sequenceFlow1.setOutgoing(sfOutgoings); flowElementsList.add(sequenceFlow1); FlowModel flowModel = new FlowModel(); flowModel.setFlowElementList(flowElementsList); boolean access = false; try { flowModelValidator.validate(flowModel); access = true; Assert."<AssertPlaceHolder>"; } catch (ProcessException e) { LOGGER.error("", e); Assert.assertFalse(access); } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
validate(FlowModel flowModel) throws ProcessException, DefinitionException { this.validate(flowModel, null); }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: validateStartEventNotOne() { List<FlowElement> flowElementsList = EntityBuilder.buildFlowElementList();  StartEvent startEvent = new StartEvent(); startEvent.setKey("startEvent2"); startEvent.setType(FlowElementType.START_EVENT); List<String> seOutgoings = new ArrayList<>(); seOutgoings.add("sequenceFlow1"); startEvent.setOutgoing(seOutgoings); flowElementsList.add(startEvent); FlowModel flowModel = new FlowModel(); flowModel.setFlowElementList(flowElementsList); boolean access = false; try { flowModelValidator.validate(flowModel); access = true; Assert."<AssertPlaceHolder>"; } catch (ProcessException e) { LOGGER.error("", e); Assert.assertFalse(access); } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
validate(FlowModel flowModel) throws ProcessException, DefinitionException { this.validate(flowModel, null); }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: validateAccess() { String modelStr = EntityBuilder.buildModelStringAccess(); boolean access = false; try { modelValidator.validate(modelStr); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } catch (ProcessException e) { LOGGER.error("", e); Assert.assertTrue(access); }   }
validate(String flowModelStr) throws DefinitionException, ProcessException { this.validate(flowModelStr, null); }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: validateEmptyModel() { String modelStr = null; boolean access = false; try { modelValidator.validate(modelStr); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } catch (ProcessException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
validate(String flowModelStr) throws DefinitionException, ProcessException { this.validate(flowModelStr, null); }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: checkIncomingAccess() { FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkIncoming(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkIncoming(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkIncoming(flowElementMap, flowElement);  List<String> incomingList = flowElement.getIncoming(); if (incomingList.size() >1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_INCOMING); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: checkTooMuchIncoming() { FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); List<String> sfIncomings = new ArrayList<>(); sfIncomings.add("userTask2"); sfIncomings.add("userTask1"); sequenceFlow.setIncoming(sfIncomings); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkIncoming(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
checkIncoming(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkIncoming(flowElementMap, flowElement);  List<String> incomingList = flowElement.getIncoming(); if (incomingList.size() >1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_INCOMING); } }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: checkOutgoingAccess() {  FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkOutgoing(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkOutgoing(flowElementMap, flowElement);  List<String> outgoingList = flowElement.getOutgoing(); if (outgoingList.size() > 1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_OUTGOING); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: checkWithoutOutgoing() {  FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); sequenceFlow.setOutgoing(null); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkOutgoing(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkOutgoing(flowElementMap, flowElement);  List<String> outgoingList = flowElement.getOutgoing(); if (outgoingList.size() > 1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_OUTGOING); } }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: regexPreprocessorTest() { RegexPreprocessor rpp = new RegexPreprocessor("^.*(fakebook\\.com.*)/$", "$1"); String test = "https://www.fakebook.com/personOne/"; String res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "www.fakebook.com/personOne/"; res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "fakebook.com/personOne/"; res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "personOne/"; res = "personOne/"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "insertedWithoutAppliedRegex"; res = "insertedWithoutAppliedRegex"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = ""; res = ""; Assert."<AssertPlaceHolder>"; }
applyProcessor(String value) { return value.replaceAll(match, replace); }
[*] target: assertEquals(res, rpp.applyProcessor(test))
[-] pred: org. junit. Assert. assertEquals ( res, rpp. applyProcessor( test ) )
************************************
************************************
[+] input: testToString() { for (int i = 0; i < DEFAULT_LOOP_MAX; i++) { UUID uuid0 = UUID.randomUUID(); String string0 = toString(uuid0); String string1 = Ulid.from(uuid0).toString(); // <- test Ulid.toString() "<AssertPlaceHolder>"; } }
toString() { return toString(ALPHABET_UPPERCASE); }
[*] target: assertEquals(string0, string1)
[-] pred: org. junit. Assert. assertEquals ( string0, string1 )
************************************
************************************
[+] input: testDifference() { VariableSet diffAB = VariableSet.difference(fA, fB);  // everything in the difference must be in A assertTrue(fA.containsAll(diffAB));  // nothing in B might be in the difference for (String name : fB.getNames()) { for (Type type : fB.getTypes(name)) { assertFalse(diffAB.contains(name, type)); } }  VariableSet diffBA = VariableSet.difference(fB, fA);  // everything in the difference must be in B assertTrue(fB.containsAll(diffBA));  // nothing in A might be in the difference for (String name : fA.getNames()) { for (Type type : fA.getTypes(name)) { "<AssertPlaceHolder>"; } } }
contains(String name, Type type) { return fEntries.containsKey(name) && fEntries.get(name).contains(type); }
[*] target: assertFalse(diffBA.contains(name, type))
[-] pred: org. junit. Assert. assertFalse ( diffBA. contains ( name, type ) )
************************************
************************************
[+] input: testPolymorphicDifference2() { VariableSet pDiff2 = VariableSet.polymorphicDifference2(fA, fB);  // everything in pDiff2 must be in A assertTrue(fA.containsAll(pDiff2));  // the normal difference is a subset of the second polymorphic difference // (it removes everything a normal difference would + possibly some more) // we want to take a look everything that gets only removed by the // second polymorphic difference  VariableSet diff = VariableSet.difference(fA, fB); VariableSet pDiffExcl = VariableSet.difference(diff, pDiff2);  // for each element in pDiffExcl the following must hold: // - element of A // - not element of B // - B has a variable with that name // - one of its types must be a subtype of the current elements type for (String name : pDiffExcl.getNames()) { for (Type type : pDiffExcl.getTypes(name)) { assertTrue(fA.contains(name, type)); assertFalse(fB.contains(name, type)); assertTrue(fB.contains(name)); boolean containsSubType = false; for (Type otherType : fB.getTypes(name)) { if (otherType.conformsTo(type)) { containsSubType = true; break; } } "<AssertPlaceHolder>"; } } }
getTypes(String name) { return fEntries.get(name); }
[*] target: assertTrue(containsSubType)
[-] pred: org. junit. Assert. assertTrue ( containsSubType )
************************************
************************************
[+] input: testECKey() { ECKey key = new ECKey(); assertTrue(key.isPubKeyCanonical()); "<AssertPlaceHolder>"; assertNotNull(key.getPrivKeyBytes()); logger.info(Hex.toHexString(key.getPrivKeyBytes()) + " :Generated privkey"); logger.info(Hex.toHexString(key.getPubKey()) + " :Generated pubkey"); }
getPubKey() { return pub.getEncoded(/* compressed */ false); }
[*] target: assertNotNull(key.getPubKey())
[-] pred: org. junit. Assert. assertNotNull ( key. getPubKey() )
************************************
************************************
[+] input: dumpActiveNodesTest() { Node node1 = new Node(new byte[64], "128.0.0.1", 18888, 18888); Node node2 = new Node(new byte[64], "128.0.0.2", 18888, 18888); Node node3 = new Node(new byte[64], "128.0.0.3", 18888, 18888); NodeHandler nodeHandler1 = nodeManager.getNodeHandler(node1); NodeHandler nodeHandler2 = nodeManager.getNodeHandler(node2); NodeHandler nodeHandler3 = nodeManager.getNodeHandler(node3); nodeHandler1.changeState(NodeHandler.State.ALIVE); nodeHandler2.changeState(NodeHandler.State.ACTIVE); nodeHandler3.changeState(NodeHandler.State.NONACTIVE); int activeNodes = nodeManager.dumpActiveNodes().size(); Assert."<AssertPlaceHolder>"; }
dumpActiveNodes() { List<NodeHandler> handlers = new ArrayList<>(); for (NodeHandler handler : this.nodeHandlerMap.values()) { if (isNodeAlive(handler)) { handlers.add(handler); } } return handlers; }
[*] target: assertEquals(2, activeNodes)
[-] pred: org. junit. Assert. assertEquals ( 2, activeNodes )
************************************
************************************
[+] input: Exception { byte[] bytes = new byte[64]; bytes[0] = 15; Node nearNode = new Node(bytes, "127.0.0.19", 18888, 18888); bytes[0] = 70; Node farNode = new Node(bytes, "127.0.0.20", 18888, 18888); nodeTable.addNode(nearNode); nodeTable.addNode(farNode); for (int i = 0; i < KademliaOptions.BUCKET_SIZE - 1; i++) { //To control totally 17 nodes, however closest's capacity is 16 nodeTable.addNode(new Node(ids.get(i), ips[i], 18888, 18888)); TimeUnit.MILLISECONDS.sleep(10); } Assert.assertTrue(nodeTable.getBucketsCount() > 1); //3 buckets, nearnode's distance is 252, far's is 255, others' are 253 List<Node> closest = nodeTable.getClosestNodes(homeNode.getId()); Assert."<AssertPlaceHolder>"; //the farest node should be excluded }
contains(Node n) { NodeEntry e = new NodeEntry(node.getId(), n); for (NodeBucket b : buckets) { if (b.getNodes().contains(e)) { return true; } } return false; }
[*] target: assertTrue(closest.contains(nearNode))
[-] pred: org. junit. Assert. assertTrue ( closest. contains ( nearNode ) )
************************************
************************************
[+] input: InterruptedException { Node node1 = Node.instanceOf("127.0.0.1:10001"); NodeEntry ne1 = new NodeEntry(node1); Thread.sleep(1); Node node2 = Node.instanceOf("127.0.0.1:10002"); NodeEntry ne2 = new NodeEntry(node2); TimeComparator tc = new TimeComparator(); int result = tc.compare(ne1, ne2); Assert."<AssertPlaceHolder>";  }
compare(NodeEntry e1, NodeEntry e2) { long t1 = e1.getModified(); long t2 = e2.getModified();  if (t1 < t2) { return 1; } else if (t1 > t2) { return -1; } else { return 0; } }
[*] target: assertEquals(1, result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: pushBlockInvalidSignature() { // invalid witness address cause invalid signature String invalidWitness = "bcab94c3e0c9214fb4ac7ff9d7d5a937d1f40031f"; blockCapsule2.setWitness(invalidWitness); try { dbManager.pushBlock(blockCapsule2); Assert."<AssertPlaceHolder>"; } catch (BadBlockException e) { Assert.assertEquals("The signature is not validated", e.getMessage()); } catch (Exception e) { Assert.assertFalse(e instanceof Exception); } }
pushBlock(final BlockCapsule block) throws ValidateSignatureException, ContractValidateException, ContractExeException, UnLinkedBlockException, ValidateScheduleException, AccountResourceInsufficientException, TaposException, TooBigTransactionException, TooBigTransactionResultException, DupTransactionException, TransactionExpirationException, BadNumberBlockException, BadBlockException, NonCommonBlockException, ReceiptCheckErrException, VMIllegalException, ZksnarkException, P2pVersionException, EventBloomException { long start = System.currentTimeMillis(); try (PendingManager pm = new PendingManager(this)) {  if (!block.generatedByMyself) { if (!block.validateSignature(chainBaseManager.getDynamicPropertiesStore(), chainBaseManager.getAccountStore())) { logger.warn("The signature is not validated."); throw new BadBlockException("The signature is not validated"); }  if (!block.calcMerkleRoot().equals(block.getMerkleRoot())) { logger.warn( "The merkle root doesn't match, Calc result is " + block.calcMerkleRoot() + " , the headers is " + block.getMerkleRoot()); throw new BadBlockException("The merkle hash is not validated"); }  consensus.receiveBlock(block); }  if (block.getTransactions().stream().filter(tran -> isShieldedTransaction(tran.getInstance())) .count() > SHIELDED_TRANS_IN_BLOCK_COUNTS) { throw new BadBlockException( "shielded transaction count > " + SHIELDED_TRANS_IN_BLOCK_COUNTS); }  BlockCapsule newBlock; try { newBlock = this.khaosDb.push(block); } catch (UnLinkedBlockException e) { logger.error( "latestBlockHeaderHash:{}, latestBlockHeaderNumber:{}, latestSolidifiedBlockNum:{}", getDynamicPropertiesStore().getLatestBlockHeaderHash(), getDynamicPropertiesStore().getLatestBlockHeaderNumber(), getDynamicPropertiesStore().getLatestSolidifiedBlockNum()); throw e; }  // DB don't need lower block if (getDynamicPropertiesStore().getLatestBlockHeaderHash() == null) { if (newBlock.getNum() != 0) { return; } } else { if (newBlock.getNum() <= getDynamicPropertiesStore().getLatestBlockHeaderNumber()) { return; }  // switch fork if (!newBlock .getParentHash() .equals(getDynamicPropertiesStore().getLatestBlockHeaderHash())) { logger.warn( "switch fork! new head num = {}, block id = {}", newBlock.getNum(), newBlock.getBlockId());  logger.warn( "******** before switchFork ******* push block: " + block.toString() + ", new block:" + newBlock.toString() + ", dynamic head num: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderNumber() + ", dynamic head hash: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderHash() + ", dynamic head timestamp: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderTimestamp() + ", khaosDb head: " + khaosDb.getHead() + ", khaosDb miniStore size: " + khaosDb.getMiniStore().size() + ", khaosDb unlinkMiniStore size: " + khaosDb.getMiniUnlinkedStore().size());  switchFork(newBlock); logger.info(SAVE_BLOCK + newBlock);  logger.warn( "******** after switchFork ******* push block: " + block.toString() + ", new block:" + newBlock.toString() + ", dynamic head num: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderNumber() + ", dynamic head hash: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderHash() + ", dynamic head timestamp: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderTimestamp() + ", khaosDb head: " + khaosDb.getHead() + ", khaosDb miniStore size: " + khaosDb.getMiniStore().size() + ", khaosDb unlinkMiniStore size: " + khaosDb.getMiniUnlinkedStore().size());  return; } try (ISession tmpSession = revokingStore.buildSession()) {  applyBlock(newBlock); tmpSession.commit(); // if event subscribe is enabled, post solidity trigger to queue postSolidityTrigger(getDynamicPropertiesStore().getLatestSolidifiedBlockNum()); // if event subscribe is enabled, post block trigger to queue postBlockTrigger(newBlock); } catch (Throwable throwable) { logger.error(throwable.getMessage(), throwable); khaosDb.removeBlk(block.getBlockId()); throw throwable; } } logger.info(SAVE_BLOCK + newBlock); } //clear ownerAddressSet if (CollectionUtils.isNotEmpty(ownerAddressSet)) { Set<String> result = new HashSet<>(); for (TransactionCapsule transactionCapsule : rePushTransactions) { filterOwnerAddress(transactionCapsule, result); } for (TransactionCapsule transactionCapsule : pushTransactionQueue) { filterOwnerAddress(transactionCapsule, result); } ownerAddressSet.clear(); ownerAddressSet.addAll(result); }  MetricsUtil.meterMark(MetricsKey.BLOCKCHAIN_BLOCK_PROCESS_TIME, System.currentTimeMillis() - start);  logger.info("pushBlock block number:{}, cost/txs:{}/{}", block.getNum(), System.currentTimeMillis() - start, block.getTransactions().size()); }
[*] target: assertTrue(false)
[-] pred: org. junit. Assert. assertTrue ( false )
************************************
************************************
[+] input: pushBlockInvalidMerkelRoot() { Transaction trx = Transaction.newBuilder().build(); TransactionCapsule moreTrans = new TransactionCapsule(trx); blockCapsule2.addTransaction(moreTrans);  // add one more transaction will change merkroot blockCapsule2.sign(ByteArray.fromHexString(Args.getLocalWitnesses() .getPrivateKey())); try { dbManager.pushBlock(blockCapsule2); Assert."<AssertPlaceHolder>"; } catch (BadBlockException e) { Assert.assertTrue(e instanceof BadBlockException); Assert.assertEquals("The merkle hash is not validated", e.getMessage()); } catch (Exception e) { Assert.assertFalse(e instanceof Exception); } }
pushBlock(final BlockCapsule block) throws ValidateSignatureException, ContractValidateException, ContractExeException, UnLinkedBlockException, ValidateScheduleException, AccountResourceInsufficientException, TaposException, TooBigTransactionException, TooBigTransactionResultException, DupTransactionException, TransactionExpirationException, BadNumberBlockException, BadBlockException, NonCommonBlockException, ReceiptCheckErrException, VMIllegalException, ZksnarkException, P2pVersionException, EventBloomException { long start = System.currentTimeMillis(); try (PendingManager pm = new PendingManager(this)) {  if (!block.generatedByMyself) { if (!block.validateSignature(chainBaseManager.getDynamicPropertiesStore(), chainBaseManager.getAccountStore())) { logger.warn("The signature is not validated."); throw new BadBlockException("The signature is not validated"); }  if (!block.calcMerkleRoot().equals(block.getMerkleRoot())) { logger.warn( "The merkle root doesn't match, Calc result is " + block.calcMerkleRoot() + " , the headers is " + block.getMerkleRoot()); throw new BadBlockException("The merkle hash is not validated"); }  consensus.receiveBlock(block); }  if (block.getTransactions().stream().filter(tran -> isShieldedTransaction(tran.getInstance())) .count() > SHIELDED_TRANS_IN_BLOCK_COUNTS) { throw new BadBlockException( "shielded transaction count > " + SHIELDED_TRANS_IN_BLOCK_COUNTS); }  BlockCapsule newBlock; try { newBlock = this.khaosDb.push(block); } catch (UnLinkedBlockException e) { logger.error( "latestBlockHeaderHash:{}, latestBlockHeaderNumber:{}, latestSolidifiedBlockNum:{}", getDynamicPropertiesStore().getLatestBlockHeaderHash(), getDynamicPropertiesStore().getLatestBlockHeaderNumber(), getDynamicPropertiesStore().getLatestSolidifiedBlockNum()); throw e; }  // DB don't need lower block if (getDynamicPropertiesStore().getLatestBlockHeaderHash() == null) { if (newBlock.getNum() != 0) { return; } } else { if (newBlock.getNum() <= getDynamicPropertiesStore().getLatestBlockHeaderNumber()) { return; }  // switch fork if (!newBlock .getParentHash() .equals(getDynamicPropertiesStore().getLatestBlockHeaderHash())) { logger.warn( "switch fork! new head num = {}, block id = {}", newBlock.getNum(), newBlock.getBlockId());  logger.warn( "******** before switchFork ******* push block: " + block.toString() + ", new block:" + newBlock.toString() + ", dynamic head num: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderNumber() + ", dynamic head hash: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderHash() + ", dynamic head timestamp: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderTimestamp() + ", khaosDb head: " + khaosDb.getHead() + ", khaosDb miniStore size: " + khaosDb.getMiniStore().size() + ", khaosDb unlinkMiniStore size: " + khaosDb.getMiniUnlinkedStore().size());  switchFork(newBlock); logger.info(SAVE_BLOCK + newBlock);  logger.warn( "******** after switchFork ******* push block: " + block.toString() + ", new block:" + newBlock.toString() + ", dynamic head num: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderNumber() + ", dynamic head hash: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderHash() + ", dynamic head timestamp: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderTimestamp() + ", khaosDb head: " + khaosDb.getHead() + ", khaosDb miniStore size: " + khaosDb.getMiniStore().size() + ", khaosDb unlinkMiniStore size: " + khaosDb.getMiniUnlinkedStore().size());  return; } try (ISession tmpSession = revokingStore.buildSession()) {  applyBlock(newBlock); tmpSession.commit(); // if event subscribe is enabled, post solidity trigger to queue postSolidityTrigger(getDynamicPropertiesStore().getLatestSolidifiedBlockNum()); // if event subscribe is enabled, post block trigger to queue postBlockTrigger(newBlock); } catch (Throwable throwable) { logger.error(throwable.getMessage(), throwable); khaosDb.removeBlk(block.getBlockId()); throw throwable; } } logger.info(SAVE_BLOCK + newBlock); } //clear ownerAddressSet if (CollectionUtils.isNotEmpty(ownerAddressSet)) { Set<String> result = new HashSet<>(); for (TransactionCapsule transactionCapsule : rePushTransactions) { filterOwnerAddress(transactionCapsule, result); } for (TransactionCapsule transactionCapsule : pushTransactionQueue) { filterOwnerAddress(transactionCapsule, result); } ownerAddressSet.clear(); ownerAddressSet.addAll(result); }  MetricsUtil.meterMark(MetricsKey.BLOCKCHAIN_BLOCK_PROCESS_TIME, System.currentTimeMillis() - start);  logger.info("pushBlock block number:{}, cost/txs:{}/{}", block.getNum(), System.currentTimeMillis() - start, block.getTransactions().size()); }
[*] target: assertTrue(false)
[-] pred: org. junit. Assert. assertTrue ( false )
************************************
************************************
[+] input: test() { Set<Long> set = new HashSet<>(); for (ProposalUtil.ProposalType proposalType : ProposalUtil.ProposalType.values()) { Assert.assertTrue(set.add(proposalType.getCode())); }  Proposal proposal = Proposal.newBuilder().putParameters(1, 1).build(); ProposalCapsule proposalCapsule = new ProposalCapsule(proposal); boolean result = ProposalService.process(manager, proposalCapsule); Assert.assertTrue(result); // proposal = Proposal.newBuilder().putParameters(1000, 1).build(); proposalCapsule = new ProposalCapsule(proposal); result = ProposalService.process(manager, proposalCapsule); Assert.assertFalse(result); // for (ProposalUtil.ProposalType proposalType : ProposalUtil.ProposalType.values()) { if (proposalType == ProposalUtil.ProposalType.WITNESS_123_PAY_PER_BLOCK) { proposal = Proposal.newBuilder().putParameters(proposalType.getCode(), 16160).build(); } else { proposal = Proposal.newBuilder().putParameters(proposalType.getCode(), 1).build(); } proposalCapsule = new ProposalCapsule(proposal); result = ProposalService.process(manager, proposalCapsule); Assert."<AssertPlaceHolder>"; } }
process(Manager manager, ProposalCapsule proposalCapsule) { Map<Long, Long> map = proposalCapsule.getInstance().getParametersMap(); Map<Long, String> mapString = proposalCapsule.getInstance().getStringParametersMap(); boolean find = true; for (Map.Entry<Long, Long> entry : map.entrySet()) { ProposalType proposalType = ProposalType.getEnumOrNull(entry.getKey()); if (proposalType == null) { find = false; continue; } switch (proposalType) { case MAINTENANCE_TIME_INTERVAL: { manager.getDynamicPropertiesStore().saveMaintenanceTimeInterval(entry.getValue()); break; } case ACCOUNT_UPGRADE_COST: { manager.getDynamicPropertiesStore().saveAccountUpgradeCost(entry.getValue()); break; } case CREATE_ACCOUNT_FEE: { manager.getDynamicPropertiesStore().saveCreateAccountFee(entry.getValue()); break; } case TRANSACTION_FEE: { manager.getDynamicPropertiesStore().saveTransactionFee(entry.getValue()); break; } case ASSET_ISSUE_FEE: { manager.getDynamicPropertiesStore().saveAssetIssueFee(entry.getValue()); break; } case WITNESS_PAY_PER_BLOCK: { manager.getDynamicPropertiesStore().saveWitnessPayPerBlock(entry.getValue()); break; } case WITNESS_STANDBY_ALLOWANCE: { manager.getDynamicPropertiesStore().saveWitnessStandbyAllowance(entry.getValue()); break; } case CREATE_NEW_ACCOUNT_FEE_IN_SYSTEM_CONTRACT: { manager.getDynamicPropertiesStore() .saveCreateNewAccountFeeInSystemContract(entry.getValue()); break; } case CREATE_NEW_ACCOUNT_PHOTON_RATE: { manager.getDynamicPropertiesStore().saveCreateNewAccountPhotonRate(entry.getValue()); break; } case ALLOW_CREATION_OF_CONTRACTS: { manager.getDynamicPropertiesStore().saveAllowCreationOfContracts(entry.getValue()); break; } case REMOVE_THE_POWER_OF_THE_GR: { if (manager.getDynamicPropertiesStore().getRemoveThePowerOfTheGr() == 0) { manager.getDynamicPropertiesStore().saveRemoveThePowerOfTheGr(entry.getValue()); } break; } case ENTROPY_FEE: { manager.getDynamicPropertiesStore().saveEntropyFee(entry.getValue()); break; } case EXCHANGE_CREATE_FEE: { manager.getDynamicPropertiesStore().saveExchangeCreateFee(entry.getValue()); break; } case MAX_CPU_TIME_OF_ONE_TX: { manager.getDynamicPropertiesStore().saveMaxCpuTimeOfOneTx(entry.getValue()); break; } case ALLOW_UPDATE_ACCOUNT_NAME: { manager.getDynamicPropertiesStore().saveAllowUpdateAccountName(entry.getValue()); break; } case ALLOW_SAME_TOKEN_NAME: { manager.getDynamicPropertiesStore().saveAllowSameTokenName(entry.getValue()); break; } case ALLOW_DELEGATE_RESOURCE: { manager.getDynamicPropertiesStore().saveAllowDelegateResource(entry.getValue()); break; } case TOTAL_ENTROPY_LIMIT: { manager.getDynamicPropertiesStore().saveTotalEntropyLimit(entry.getValue()); break; } case ALLOW_VVM_TRANSFER_VRC10: { manager.getDynamicPropertiesStore().saveAllowVvmTransferVrc10(entry.getValue()); break; } case TOTAL_CURRENT_ENTROPY_LIMIT: { manager.getDynamicPropertiesStore().saveTotalEntropyLimit2(entry.getValue()); break; } case ALLOW_MULTI_SIGN: { if (manager.getDynamicPropertiesStore().getAllowMultiSign() == 0) { manager.getDynamicPropertiesStore().saveAllowMultiSign(entry.getValue()); } break; } case ALLOW_ADAPTIVE_ENTROPY: { if (manager.getDynamicPropertiesStore().getAllowAdaptiveEntropy() == 0) { manager.getDynamicPropertiesStore().saveAllowAdaptiveEntropy(entry.getValue());  //24 * 60 * 2 . one minute,1/2 total limit. manager.getDynamicPropertiesStore().saveAdaptiveResourceLimitTargetRatio(2880); manager.getDynamicPropertiesStore().saveTotalEntropyTargetLimit( manager.getDynamicPropertiesStore().getTotalEntropyLimit() / 2880); manager.getDynamicPropertiesStore().saveAdaptiveResourceLimitMultiplier(50); } break; } case UPDATE_ACCOUNT_PERMISSION_FEE: { manager.getDynamicPropertiesStore().saveUpdateAccountPermissionFee(entry.getValue()); break; } case MULTI_SIGN_FEE: { manager.getDynamicPropertiesStore().saveMultiSignFee(entry.getValue()); break; } case ALLOW_PROTO_FILTER_NUM: { manager.getDynamicPropertiesStore().saveAllowProtoFilterNum(entry.getValue()); break; } case ALLOW_ACCOUNT_STATE_ROOT: { manager.getDynamicPropertiesStore().saveAllowAccountStateRoot(entry.getValue()); break; } case ALLOW_VVM_CONSTANTINOPLE: { manager.getDynamicPropertiesStore().saveAllowVvmConstantinople(entry.getValue()); manager.getDynamicPropertiesStore().addSystemContractAndSetPermission(48); break; } case ALLOW_VVM_SOLIDITY_059: { manager.getDynamicPropertiesStore().saveAllowVvmSolidity059(entry.getValue()); break; } case ADAPTIVE_RESOURCE_LIMIT_TARGET_RATIO: { long ratio = 24 * 60 * entry.getValue(); manager.getDynamicPropertiesStore().saveAdaptiveResourceLimitTargetRatio(ratio); manager.getDynamicPropertiesStore().saveTotalEntropyTargetLimit( manager.getDynamicPropertiesStore().getTotalEntropyLimit() / ratio); break; } case ADAPTIVE_RESOURCE_LIMIT_MULTIPLIER: { manager.getDynamicPropertiesStore().saveAdaptiveResourceLimitMultiplier(entry.getValue()); break; } case ALLOW_CHANGE_DELEGATION: { manager.getDynamicPropertiesStore().saveChangeDelegation(entry.getValue()); manager.getDynamicPropertiesStore().addSystemContractAndSetPermission(49); break; } case WITNESS_123_PAY_PER_BLOCK: { manager.getDynamicPropertiesStore().saveWitness123PayPerBlock(entry.getValue()); break; } case FORBID_TRANSFER_TO_CONTRACT: { manager.getDynamicPropertiesStore().saveForbidTransferToContract(entry.getValue()); break; } case ALLOW_PBFT: { manager.getDynamicPropertiesStore().saveAllowPBFT(entry.getValue()); break; } case ALLOW_VVM_ISTANBUL: { manager.getDynamicPropertiesStore().saveAllowVvmIstanbul(entry.getValue()); break; } case ALLOW_SHIELDED_VRC20_TRANSACTION: { manager.getDynamicPropertiesStore().saveAllowShieldedVRC20Transaction(entry.getValue()); break; } case ALLOW_MARKET_TRANSACTION: { if (manager.getDynamicPropertiesStore().getAllowMarketTransaction() == 0) { manager.getDynamicPropertiesStore().saveAllowMarketTransaction(entry.getValue()); manager.getDynamicPropertiesStore().addSystemContractAndSetPermission(52); manager.getDynamicPropertiesStore().addSystemContractAndSetPermission(53); } break; } case MARKET_SELL_FEE: { manager.getDynamicPropertiesStore().saveMarketSellFee(entry.getValue()); break; } case MARKET_CANCEL_FEE: { manager.getDynamicPropertiesStore().saveMarketCancelFee(entry.getValue()); break; } case MAX_FEE_LIMIT: { manager.getDynamicPropertiesStore().saveMaxFeeLimit(entry.getValue()); break; } case ALLOW_TRANSACTION_FEE_POOL: { manager.getDynamicPropertiesStore().saveAllowTransactionFeePool(entry.getValue()); break; } case ALLOW_BLACKHOLE_OPTIMIZATION: { manager.getDynamicPropertiesStore().saveAllowBlackHoleOptimization(entry.getValue()); break; } case ECONOMY_CYCLE: { manager.getDynamicPropertiesStore().saveEconomyCycle(entry.getValue()); break; } case SPREAD_MINT_PAY_PER_BLOCK: { manager.getDynamicPropertiesStore().saveSpreadMintPayPerBlock(entry.getValue()); break; } case ALLOW_SPREAD_MINT_LEVEL_PROP: { manager.getDynamicPropertiesStore().saveAllowSpreadMintLevelProp(entry.getValue()); break; } case PLEDGE_RATE_THRESHOLD: { manager.getDynamicPropertiesStore().savePledgeRateThreshold(entry.getValue()); break; } case SPREAD_FREEZE_PERIOD_LIMIT: { manager.getDynamicPropertiesStore().saveSpreadFreezePeriodLimit(entry.getValue()); break; } case ALLOW_ETHEREUM_COMPATIBLE_TRANSACTION: { manager.getDynamicPropertiesStore().saveAllowEthereumCompatibleTransaction(entry.getValue()); break; } case ALLOW_MODIFY_SPREAD_MINT_PARENT: { manager.getDynamicPropertiesStore().saveAllowModifySpreadMintParent(entry.getValue()); break; } case TOTAL_PHOTON_LIMIT: { manager.getDynamicPropertiesStore().saveTotalPhotonLimit(entry.getValue()); break; } case SPECIAL_FREEZE_PERIOD_LIMIT: { manager.getDynamicPropertiesStore().saveSpecialFreezePeriodLimit(entry.getValue()); break; } case FVGUARANTEE_FREEZE_PERIOD_LIMIT: { manager.getDynamicPropertiesStore().saveFvGuaranteeFreezePeriodLimit(entry.getValue()); break; } case ALLOW_UNFREEZE_SPREAD_OR_FVGUARANTEE_CLEAR_VOTE: { manager.getDynamicPropertiesStore().saveAllowUnfreezeSpreadOrFvGuaranteeClearVote(entry.getValue()); break; } case ALLOW_WITHDRAW_TRANSACTION_INFO_SEPARATE_AMOUNT: { manager.getDynamicPropertiesStore().saveAllowWithdrawTransactionInfoSeparateAmount(entry.getValue()); break; } case ALLOW_SPREAD_MINT_PARTICIPATE_PLEDGE_RATE: { manager.getDynamicPropertiesStore().saveAllowSpreadMintParticipatePledgeRate(entry.getValue()); break; } case SM_BURN_OPTIMIZATION: { manager.getDynamicPropertiesStore().saveSMBurnOptimization(entry.getValue()); break; } case ALLOW_VP_FREEZE_STAGE_WEIGHT: { manager.getDynamicPropertiesStore().saveAllowVPFreezeStageWeight(entry.getValue()); break; } case REFREEZE_CONSIDERATION_PERIOD: { manager.getDynamicPropertiesStore().saveRefreezeConsiderationPeriod(entry.getValue()); break; } case SPREAD_REFREEZE_CONSIDERATION_PERIOD: { manager.getDynamicPropertiesStore().saveSpreadRefreezeConsiderationPeriod(entry.getValue()); break; } case ALLOW_ETHEREUM_COMPATIBLE_TRANSACTION_NATIVE_STEP1: { manager.getDynamicPropertiesStore().saveAllowEthereumCompatibleTransactionNativeStep1(entry.getValue()); break; } case MODIFY_SPREAD_MINT_PARENT_FEE: { manager.getDynamicPropertiesStore().saveModifySpreadMintParentFee(entry.getValue()); break; } case SEPARATE_PROPOSAL_STRING_PARAMETERS: { manager.getDynamicPropertiesStore().saveSeparateProposalStringParameters(entry.getValue()); break; } case ALLOW_FREEZE_ACCOUNT: { manager.getDynamicPropertiesStore().saveAllowFreezeAccount(entry.getValue()); break; } case ALLOW_UNFREEZE_FRAGMENTATION: { manager.getDynamicPropertiesStore().saveAllowUnfreezeFragmentation(entry.getValue()); break; } case ALLOW_OPTIMIZED_RETURN_VALUE_OF_CHAIN_ID: { manager.getDynamicPropertiesStore().saveAllowOptimizedReturnValueOfChainId(entry.getValue()); break; } case ALLOW_UNFREEZE_FRAGMENTATION_VOTE_WEIGHT: { manager.getDynamicPropertiesStore().saveAllowUnfreezeFragmentationVoteWeight(entry.getValue()); break; } default: find = false; break; } }  for (Map.Entry<Long, String> entry : mapString.entrySet()) { ProposalType proposalType = ProposalType.getEnumOrNull(entry.getKey()); find = true; if (proposalType == null) { find = false; continue; } switch (proposalType) { case SPREAD_MINT_LEVEL_PROP: { manager.getDynamicPropertiesStore().saveSpreadMintLevelProp(entry.getValue()); break; } case INFLATION_RATE: { long lowInflationRate = Long.parseLong(entry.getValue().split(",")[0]); long highInflationRate = Long.parseLong(entry.getValue().split(",")[1]); manager.getDynamicPropertiesStore().saveLowInflationRate(lowInflationRate); manager.getDynamicPropertiesStore().saveHighInflationRate(highInflationRate); break; } case VP_FREEZE_STAGE_WEIGHT: { manager.getDynamicPropertiesStore().saveVPFreezeStageWeight(entry.getValue()); break; } case FREEZE_ACCOUNT_OWNER: { String owner_account = entry.getValue(); if (owner_account.length() == 34) { owner_account = Util.getHexAddress(owner_account); } manager.getDynamicPropertiesStore().saveFreezeAccountOwner(owner_account); break; } case FREEZE_ACCOUNT_LIST: { String[] values = entry.getValue().split(";"); saveFreezeAccountList(values[0], values[1], manager); break; } default: find = false; break; } }  return find; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testCall() { try (Store<Void> store = Store.withoutData(); Engine engine = store.engine(); Module module = new Module(engine, WAT_BYTES_ADD); Instance instance = new Instance(store, module, Collections.emptyList())) { try (Func func = instance.getFunc(store, "add").get()) { Val[] results = func.call(store, Val.fromI32(1), Val.fromI32(2)); "<AssertPlaceHolder>"; assertEquals(Val.fromI32(3), results[0]); } } }
call(Caller<T> caller, Val[] params, Val[] results); }  private static final Val[] EMPTY_VALS = new Val[0]; static final FuncRegistry registry = new FuncRegistry();  @Getter(AccessLevel.PACKAGE) private final long innerPtr;  public <T> Func(Store<T> store, FuncType fnType, Handler<T> func) { this(create(store, fnType, func)); }
[*] target: assertEquals(1, results.length)
[-] pred: org. junit. Assert. assertEquals ( 1, results. length )
************************************
************************************
[+] input: testDefaultValues() { Humidity humidity = new SimpleHumidity(); assertEquals(Humidity.UNKNOWN, humidity.getValue()); "<AssertPlaceHolder>"; }
getText() { return this.text; }
[*] target: assertNull(humidity.getText())
[-] pred: org. junit. Assert. assertNull ( humidity. getText() )
************************************
************************************
[+] input: JSONException { OpenWeatherMapSource source = new OpenWeatherMapSource(context); Location location = new SimpleLocation("lat=54.96&lon=73.38", true); JSONObject json = source.queryCurrentWeather(location); "<AssertPlaceHolder>"; assertEquals("Omsk", json.getString("name")); }
queryCurrentWeather(Location location) throws WeatherException { String url = getWeatherUrl(location); return queryJSON(url); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: JSONException { OpenWeatherMapSource source = new OpenWeatherMapSource(context); Location location = new SimpleLocation("q=omsk", false); JSONObject json = source.queryCurrentWeather(location); "<AssertPlaceHolder>"; assertEquals("Omsk", json.getString("name")); }
queryCurrentWeather(Location location) throws WeatherException { String url = getWeatherUrl(location); return queryJSON(url); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: WeatherException { WeatherSource source = new OpenWeatherMapSource(context); Location location = new NameOpenWeatherMapLocation("55.0,73.4"); Weather weather = source.query(location); "<AssertPlaceHolder>"; assertTrue(weather instanceof OpenWeatherMapWeather); assertFalse(weather.isEmpty()); assertEquals("Omsk", weather.getLocation().getText()); assertEquals(8, weather.getConditions().size()); }
query(Location location) throws WeatherException { if (location == null) { throw new WeatherException("null location"); }  if (!location.isGeo()) {    // if the location contains geo coordinates, skipping this test hack try { if (location.getText().startsWith("-")) { return new TestWeather(Integer.parseInt(location.getText())); } if (location.getText().startsWith("+")) { return new TestWeather(Integer.parseInt(location.getText().substring(1))); } } catch (NumberFormatException nfe) { // ignore and continue } }  OpenWeatherMapWeather weather = new OpenWeatherMapWeather(this.context);  weather.parseCurrentWeather(queryCurrentWeather(location)); if (weather.isEmpty()) { return weather; } if (weather.getLocation().isGeo()) {    // extracts geo coord from the weather and do onecall with lat/lon weather.parseOneCallResult(queryOneCallForecast(weather.getLocation())); } return weather; }
[*] target: assertNotNull(weather)
[-] pred: org. junit. Assert. assertNotNull ( weather )
************************************
************************************
[+] input: WeatherException { JSONTokener parser = new JSONTokener("{ "cod": "404"}"); OpenWeatherMapWeather weather = new OpenWeatherMapWeather(context, (JSONObject)parser.nextValue()); //        assertNotNull(weather); //        "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertTrue(weather.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( weather. isEmpty() )
************************************
************************************
[+] input: testNotNullLocation() { OpenWeatherMapWeather weather = new OpenWeatherMapWeather(context); assertNotNull(weather.getLocation()); "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertTrue(weather.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( weather. isEmpty() )
************************************
************************************
[+] input: Exception { OpenWeatherMapWeather weather = WeatherUtils.createIncompleteOpenWeather(context); assertNotNull(weather); "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertFalse(weather.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( weather. isEmpty() )
************************************
************************************
[+] input: Exception { OpenWeatherMapWeather weather = WeatherUtils.createIncompleteOpenWeather(context); Location location = weather.getLocation(); assertNotNull(location); "<AssertPlaceHolder>"; assertEquals("Omsk", location.getText()); // geo coordinates are taken from the response assertTrue(location.isGeo()); assertEquals("lat=55.0&lon=73.4", location.getQuery()); }
isEmpty() { return this.empty; }
[*] target: assertFalse(location.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( location. isEmpty() )
************************************
************************************
[+] input: test2() { List<MahjongTileDef> mahjongInHand = List.of( MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._4_TIAO, MahjongTileDef._6_TIAO, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._4_BING, MahjongTileDef._4_BING, MahjongTileDef._4_BING, MahjongTileDef._5_BING, MahjongTileDef._5_BING );  boolean canHu = HuFormula.test( mahjongInHand, MahjongTileDef._5_TIAO );  Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: test3() { List<MahjongTileDef> mahjongInHand = List.of( MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._5_WAN, MahjongTileDef._1_TIAO, MahjongTileDef._2_TIAO, MahjongTileDef._3_TIAO, MahjongTileDef._4_TIAO, MahjongTileDef._5_TIAO, MahjongTileDef._6_TIAO, MahjongTileDef._7_TIAO );  boolean canHu = HuFormula.test( mahjongInHand, MahjongTileDef._1_TIAO );  Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: test4() { List<MahjongTileDef> mahjongInHand = Arrays.asList( MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._2_WAN, MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._5_WAN, MahjongTileDef._6_WAN, MahjongTileDef._7_WAN, MahjongTileDef._8_WAN, MahjongTileDef._9_WAN, MahjongTileDef._9_WAN, MahjongTileDef._9_WAN );  // 测试是否可以胡牌 boolean canHu = HuFormula.test(mahjongInHand, MahjongTileDef._5_WAN); Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: test5() { List<MahjongTileDef> mahjongInHand = Arrays.asList( MahjongTileDef._2_WAN, MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._6_TIAO, MahjongTileDef._7_TIAO, MahjongTileDef._1_BING, MahjongTileDef._2_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._4_BING, MahjongTileDef._5_BING, MahjongTileDef._6_BING );  // 测试是否可以胡牌 boolean canHu = HuFormula.test(mahjongInHand, MahjongTileDef._5_TIAO); Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: Exception { TestBundle testBundle = new TestBundle(); Image image; try { testBundle.setFile("icons/test.png", TestUtils.createImagePNG(1, 1)); testBundle.install(); // work with Bundle { BundleResourceProvider provider = BundleResourceProvider.get(testBundle.getId()); // get Image image = provider.getImage("icons/test.png"); "<AssertPlaceHolder>"; assertFalse(image.isDisposed()); } } finally { testBundle.dispose(); } // wait for events waitEventLoop(0); // Bundle uninstalled, so Image is now disposed assertTrue(image.isDisposed()); }
getImage(String path) { path = normalizePath(path); Image image = m_pathToImage.get(path); if (image == null) { ImageDescriptor imageDescriptor = getImageDescriptor(path); image = imageDescriptor.createImage(); m_pathToImage.put(path, image); } return image; }
[*] target: assertNotNull(image)
[-] pred: org. junit. Assert. assertNotNull ( image )
************************************
************************************
[+] input: Exception { assertTrue(EnvironmentUtils.isTestingTime()); { // switch development time EnvironmentUtils.setTestingTime(false); try { assertFalse(EnvironmentUtils.isTestingTime()); } finally { EnvironmentUtils.setTestingTime(true); } } "<AssertPlaceHolder>"; }
isTestingTime() { return "true".equals(System.getProperty(WBP_TESTING_TIME)); }
[*] target: assertTrue(EnvironmentUtils.isTestingTime())
[-] pred: org. junit. Assert. assertTrue ( EnvironmentUtils. isTestingTime ( ) )
************************************
************************************
[+] input: Exception { ObjectInfo parent = new TestObjectInfo("parent"); ObjectInfo child = new TestObjectInfo("child"); // "child" never was in "parent", so is not deleted assertFalse(child.isDeleted()); // build hierarchy parent.addChild(child); // "child" is in "parent", so again is not deleted assertFalse(child.isDeleted()); // delete parent.removeChild(child); "<AssertPlaceHolder>"; }
isDeleted() { return m_parent != null && !m_parent.m_children.contains(this); }
[*] target: assertTrue(child.isDeleted())
[-] pred: org. junit. Assert. assertTrue ( child. isDeleted() )
************************************
************************************
[+] input: Exception { final AtomicInteger saveCount = new AtomicInteger(); final ObjectInfo object = new TestObjectInfo() { @Override protected void saveEdit() throws Exception { saveCount.getAndIncrement(); } }; // final AtomicBoolean wasFired = new AtomicBoolean(); object.addBroadcastListener(new ObjectEventListener() { @Override public void endEdit_aboutToRefresh() throws Exception { wasFired.set(true); // perform inner edit operation object.startEdit(); try { } finally { object.endEdit(); } } }); // do edit operation object.startEdit(); try { } finally { object.endEdit(); } // verify, only one saveEdit() should be done "<AssertPlaceHolder>"; assertEquals(1, saveCount.get()); }
saveEdit() throws Exception { }
[*] target: assertTrue(wasFired.get())
[-] pred: org. junit. Assert. assertTrue ( wasFired. get ( ) )
************************************
************************************
[+] input: Exception { configureProject(); ContainerInfo panel = parseContainer( "public class Test extends JPanel {", "  public Test() {", "    JButton button = new JButton();", "    MyPanel myPanel = new MyPanel(button, true);", "    add(myPanel);", "  }", "}"); ContainerInfo myPanel = (ContainerInfo) panel.getChildrenComponents().get(0); ComponentInfo button = myPanel.getChildrenComponents().get(0); // do delete "<AssertPlaceHolder>"; button.delete(); // check source assertEditor( "public class Test extends JPanel {", "  public Test() {", "    MyPanel myPanel = new MyPanel(true);", "    add(myPanel);", "  }", "}"); // check constructor properties for "myPanel" { Property constructorProperty = myPanel.getPropertyByTitle("Constructor"); GenericProperty valueProperty = (GenericProperty) getPropertyByTitle(getSubProperties(constructorProperty), "value"); // check accessors { List<ExpressionAccessor> accessors = getGenericPropertyAccessors(valueProperty); assertEquals(1, accessors.size()); assertInstanceOf(ConstructorAccessor.class, accessors.get(0)); } // check value assertSame(Boolean.TRUE, valueProperty.getValue()); // set new value valueProperty.setValue(Boolean.FALSE); assertEditor( "public class Test extends JPanel {", "  public Test() {", "    MyPanel myPanel = new MyPanel(false);", "    add(myPanel);", "  }", "}"); } }
canDelete() { // no need for check if we going to delete parent if (m_javaInfo.getParentJava().isDeleting()) { return true; } // prepare new binding - without this JavaInfo arguments DesignerMethodBinding newBinding; { ConstructorCreationSupport creationSupport = getConstructorCreationSupport(); newBinding = m_editor.getBindingContext().get(creationSupport.getBinding()); List<Expression> arguments = DomGenerics.arguments(getCreation()); for (int i = arguments.size() - 1; i >= 0; i--) { Expression argument = arguments.get(i); if (m_javaInfo.isRepresentedBy(argument)) { newBinding.removeParameterType(i); } } } // we can delete association only if there is alternative constructor, without child return m_javaInfo.getParentJava().getDescription().getConstructor(newBinding) != null; }
[*] target: assertTrue(button.canDelete())
[-] pred: org. junit. Assert. assertTrue ( button. canDelete ( ) )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); RootAssociation association = (RootAssociation) panel.getAssociation(); assertSame(panel, association.getJavaInfo()); assertTrue(association.canDelete()); // try to remove() "<AssertPlaceHolder>"; assertSame(association, panel.getAssociation()); }
remove() throws Exception { return false; }
[*] target: assertFalse(association.remove())
[-] pred: org. junit. Assert. assertFalse ( association. remove ( ) )
************************************
************************************
[+] input: Exception { UnknownAssociation association = new UnknownAssociation(); "<AssertPlaceHolder>"; assertNull(association.getStatement()); }
canDelete() { return false; }
[*] target: assertFalse(association.canDelete())
[-] pred: org. junit. Assert. assertFalse ( association. canDelete() )
************************************
************************************
[+] input: Exception { prepare_separateMethodAndParent(); ContainerInfo panel = parseContainer( "class Test extends MyDialog {", "  Test() {", "    JPanel bar = new JPanel();", "    add(bar);", "    //", "    addButton(bar);", "  }", "}"); assertHierarchy( "{this: test.MyDialog} {this} {/add(bar)/ /addButton(bar)/}", "  {new: javax.swing.JPanel} {local-unique: bar} {/new JPanel()/ /add(bar)/ /addButton(bar)/}", "    {implicit-layout: java.awt.FlowLayout} {implicit-layout} {}", "    {implicit-factory} {empty} {/addButton(bar)/}"); ContainerInfo bar = (ContainerInfo) panel.getChildrenComponents().get(0); ComponentInfo button = bar.getChildrenComponents().get(0); ImplicitFactoryCreationSupport creationSupport = (ImplicitFactoryCreationSupport) button.getCreationSupport(); // check MethodDescription { MethodDescription description = creationSupport.getDescription(); assertNotNull(description); assertEquals("addButton({java.awt.Container,parent})", description.toString()); } // no copy/paste (at least now we don't support this) { IClipboardCreationSupport clipboard = creationSupport.getClipboard(); "<AssertPlaceHolder>"; } }
getClipboard() throws Exception { // support copy/paste only when target/parent are same if (!m_javaInfo.getParentJava().isRepresentedBy(m_invocation.getExpression())) { return null; } // OK, simple case final String signature = m_signature; final String source = getClipboardSource(); return new IClipboardCreationSupport() { private static final long serialVersionUID = 0L;  @Override public CreationSupport create(JavaInfo rootObject) throws Exception { return new ImplicitFactoryCreationSupport(null, signature, source); } }; }
[*] target: assertNull(clipboard)
[-] pred: org. junit. Assert. assertNull ( clipboard )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "class Test extends JPanel {", "  Test() {", "    addKeyListener(new KeyAdapter() {", "      public void keyPressed(KeyEvent e) {", "        System.out.println('keyPressed!');", "      }", "      public void keyReleased(KeyEvent e) {", "        System.out.println('keyReleased!');", "      }", "    });", "  }", "}"); EventsProperty eventsProperty = (EventsProperty) panel.getPropertyByTitle("Events"); assertNotNull(eventsProperty); assertTrue(eventsProperty.isModified()); assertEquals("[key]", getPropertyText(eventsProperty)); // check listeners Property keyProperty; { Property[] listenerProperties = getSubProperties(eventsProperty); assertEquals(13, listenerProperties.length); // no listener for "focus" { Property focusProperty = getPropertyByTitle(listenerProperties, "focus"); assertNotNull(focusProperty); assertFalse(focusProperty.isModified()); assertEquals("[]", getPropertyText(focusProperty)); } // check "key" listener property keyProperty = getPropertyByTitle(listenerProperties, "key"); assertNotNull(keyProperty); "<AssertPlaceHolder>"; assertEquals("[pressed, released]", getPropertyText(keyProperty)); } // check listener methods { Property[] methodProperties = getSubProperties(keyProperty); assertEquals(3, methodProperties.length); assertEquals("pressed", methodProperties[0].getTitle()); assertEquals("released", methodProperties[1].getTitle()); assertEquals("typed", methodProperties[2].getTitle()); } }
isModified() throws Exception { // check if there are listeners Property[] properties = getSubProperties(); for (Property property : properties) { if (property.isModified()) { return true; } } // not modified return false; }
[*] target: assertTrue(keyProperty.isModified())
[-] pred: org. junit. Assert. assertTrue ( keyProperty. isModified() )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "class Test extends JPanel {", "  Test() {", "    KeyListener listener = new KeyAdapter() {", "      public void keyPressed(KeyEvent e) {", "      }", "    };", "    addKeyListener(listener);", "  }", "}"); Property keyPressedProperty = getEventsListenerMethod(panel, "key", "pressed"); assertNotNull(keyPressedProperty); "<AssertPlaceHolder>"; }
isModified() throws Exception { // check if there are listeners Property[] properties = getSubProperties(); for (Property property : properties) { if (property.isModified()) { return true; } } // not modified return false; }
[*] target: assertTrue(keyPressedProperty.isModified())
[-] pred: org. junit. Assert. assertTrue ( keyPressedProperty. isModified() )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyButton.java", getTestSource( "public class MyButton extends JButton {", "  public MyButton(String text, FocusListener listener) {", "  }", "}")); setFileContentSrc( "test/MyButton.wbp-component.xml", getSourceDQ( "<?xml version='1.0' encoding='UTF-8'?>", "<component xmlns='http://www.eclipse.org/wb/WBPComponent'>", "  <constructors>", "    <constructor>", "      <parameter type='java.lang.String'/>", "      <parameter type='java.awt.event.FocusListener'>", "        <tag name='events: add listener method' value='addFocusListener(java.awt.event.FocusListener)'/>", "      </parameter>", "    </constructor>", "  </constructors>", "</component>")); waitForAutoBuild(); // ContainerInfo panel = parseContainer( "public class Test extends JPanel {", "  public Test() {", "    MyButton button = new MyButton('text', new FocusAdapter() {", "      public void focusGained(FocusEvent e) {}", "    });", "    add(button);", "  }", "}"); ComponentInfo button = panel.getChildrenComponents().get(0); // Property focusGainedProperty = getEventsListenerMethod(button, "focus", "gained"); assertNotNull(focusGainedProperty); "<AssertPlaceHolder>"; }
isModified() throws Exception { // check if there are listeners Property[] properties = getSubProperties(); for (Property property : properties) { if (property.isModified()) { return true; } } // not modified return false; }
[*] target: assertTrue(focusGainedProperty.isModified())
[-] pred: org. junit. Assert. assertTrue ( focusGainedProperty. isModified() )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "class Test extends JPanel {", "  Test() {", "    addKeyListener(new KeyAdapter() {", "      public void keyReleased(KeyEvent e) {", "      }", "    });", "  }", "}"); DesignPageSite.Helper.setSite(panel, DesignPageSite.EMPTY); // prepare properties Property keyPressedProperty = getEventsListenerMethod(panel, "key", "pressed"); Property keyReleasedProperty = getEventsListenerMethod(panel, "key", "released"); assertNull(getPropertyText(keyPressedProperty)); assertEquals("line 8", getPropertyText(keyReleasedProperty)); // prepare context menu IMenuManager manager; { manager = getDesignerMenuManager(); panel.getBroadcastObject().addContextMenu(null, panel, manager); } // check action for existing "keyReleased" event { IAction keyReleasedAction = findChildAction(manager, "keyReleased -> line 8"); "<AssertPlaceHolder>"; assertSame( EventsPropertyUtils.LISTENER_METHOD_IMAGE_DESCRIPTOR, keyReleasedAction.getImageDescriptor()); // run, no change expected String expectedSource = m_lastEditor.getSource(); keyReleasedAction.run(); assertEditor(expectedSource, m_lastEditor); } // add new handler using action { IMenuManager manager2 = findChildMenuManager(manager, "Add event handler"); manager2 = findChildMenuManager(manager2, "key"); assertSame(EventsPropertyUtils.EXISTING_CLASS_IMAGE, ((MenuManagerEx) manager2).getImage()); // IAction keyPressedAction = findChildAction(manager2, "keyPressed"); assertNotNull(keyPressedAction); // run, new handler should be added keyPressedAction.run(); assertEditor( "class Test extends JPanel {", "  Test() {", "    addKeyListener(new KeyAdapter() {", "      public void keyReleased(KeyEvent e) {", "      }", "      @Override", "      public void keyPressed(KeyEvent e) {", "      }", "    });", "  }", "}"); } // check for images { IMenuManager manager2 = findChildMenuManager(manager, "Add event handler"); assertSame( EventsPropertyUtils.LISTENER_INTERFACE_IMAGE, ((MenuManagerEx) findChildMenuManager(manager2, "ancestor")).getImage()); } }
addContextMenu(List<? extends ObjectInfo> objects, ObjectInfo object, IMenuManager manager) throws Exception { if (object == m_javaInfo) { contributeActions(manager, ModelMessages.EventsProperty_menuManagerName); } }
[*] target: assertNotNull(keyReleasedAction)
[-] pred: org. junit. Assert. assertNotNull ( keyReleasedAction )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); final GenericProperty enabledProperty = (GenericProperty) panel.getPropertyByTitle("enabled"); final AtomicBoolean wasFired = new AtomicBoolean(); // add listener panel.addBroadcastListener(new JavaEventListener() { @Override public void propertyValueWasSet(GenericPropertyImpl property) throws Exception { if (property == enabledProperty) { wasFired.set(true); } } }); // set value for "enabled" to "false" wasFired.set(false); enabledProperty.setValue(false); assertTrue(wasFired.get()); assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); // set value for "enabled" to "true" wasFired.set(false); enabledProperty.setValue(true); "<AssertPlaceHolder>"; assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); // set value for "enabled" to "false" wasFired.set(false); enabledProperty.setExpression("false", Property.UNKNOWN_VALUE); assertTrue(wasFired.get()); assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); }
setValue(Object value) throws Exception;  //////////////////////////////////////////////////////////////////////////// // // Editor // //////////////////////////////////////////////////////////////////////////// /** * @return the {@link PropertyEditor}
[*] target: assertTrue(wasFired.get())
[-] pred: org. junit. Assert. assertTrue ( wasFired. get ( ) )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyPanel.java", getTestSource( "// filler filler filler filler filler", "// filler filler filler filler filler", "public class MyPanel extends JPanel {", "  public int foo;", "}")); waitForAutoBuild(); // parse // parse ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("foo"); FieldAccessor accessor = (FieldAccessor) getGenericPropertyAccessors(property).get(0); // check that IAccessibleExpressionAccessor is available // note, that we don't check it, I just don't know how to do this more easy than perform full check // but we expect that it should be from IAccessibleExpressionAccessor.Utils.forField() IAccessibleExpressionAccessor accessibleAccessor = accessor.getAdapter(IAccessibleExpressionAccessor.class); "<AssertPlaceHolder>"; assertNotNull(ReflectionUtils.getFieldByName(accessibleAccessor.getClass(), "val$field")); }
getAdapter(Class<T> adapter) { if (adapter == IAccessibleExpressionAccessor.class) { return adapter.cast(m_accessibleAccessor); } if (adapter == IExposableExpressionAccessor.class) { return adapter.cast(m_exposableAccessor); } if (adapter == PropertyTooltipProvider.class) { return adapter.cast(m_tooltipProvider); } // other return super.getAdapter(adapter); }
[*] target: assertNotNull(accessibleAccessor)
[-] pred: org. junit. Assert. assertNotNull ( accessibleAccessor )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("enabled"); SetterAccessor accessor = (SetterAccessor) getGenericPropertyAccessors(property).get(0); // check Method getter = accessor.getGetter(); "<AssertPlaceHolder>"; assertEquals("isEnabled", getter.getName()); }
getGetter() { return m_getter; }
[*] target: assertNotNull(getter)
[-] pred: org. junit. Assert. assertNotNull ( getter )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("enabled"); SetterAccessor accessor = (SetterAccessor) getGenericPropertyAccessors(property).get(0); // check that IAccessibleExpressionAccessor is available // note, that we don't check it, I just don't know how to do this more easy than perform full check // but we expect that it should be from IAccessibleExpressionAccessor.Utils.forMethod() IAccessibleExpressionAccessor accessibleAccessor = accessor.getAdapter(IAccessibleExpressionAccessor.class); "<AssertPlaceHolder>"; assertNotNull(ReflectionUtils.getFieldByName(accessibleAccessor.getClass(), "val$method")); }
getAdapter(Class<T> adapter) { if (adapter == IAccessibleExpressionAccessor.class) { return adapter.cast(m_accessibleAccessor); } if (adapter == IExposableExpressionAccessor.class) { return adapter.cast(m_exposableAccessor); } if (adapter == PropertyTooltipProvider.class) { return adapter.cast(m_tooltipProvider); } // other return super.getAdapter(adapter); }
[*] target: assertNotNull(accessibleAccessor)
[-] pred: org. junit. Assert. assertNotNull ( accessibleAccessor )
************************************
************************************
[+] input: Exception { prepareBooleanPanel(); ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "    setFoo(true);", "  }", "}"); panel.refresh(); // prepare property Property property = panel.getPropertyByTitle("foo"); BooleanObjectPropertyEditor editor = (BooleanObjectPropertyEditor) property.getEditor(); // true -> false boolean activated = editor.activate(null, property, null); "<AssertPlaceHolder>"; assertEditor( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "    setFoo(false);", "  }", "}"); }
activate(PropertyTable propertyTable, Property property, Point location) throws Exception { // check that user clicked on image if (location == null || location.x < m_trueImage.getBounds().width + 2) { invertValue(property); } // don't activate return false; }
[*] target: assertFalse(activated)
[-] pred: org. junit. Assert. assertFalse ( activated )
************************************
************************************
[+] input: Exception { prepareBooleanPanel(); ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "    setFoo(true);", "  }", "}"); panel.refresh(); // prepare property Property property = panel.getPropertyByTitle("foo"); BooleanPropertyEditor editor = (BooleanPropertyEditor) property.getEditor(); // true -> false boolean activated = editor.activate(null, property, null); "<AssertPlaceHolder>"; assertEditor( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "    setFoo(false);", "  }", "}"); }
activate(PropertyTable propertyTable, Property property, Point location) throws Exception { // check that user clicked on image if (location == null || location.x < m_trueImage.getBounds().width + 2) { invertValue(property); } // don't activate return false; }
[*] target: assertFalse(activated)
[-] pred: org. junit. Assert. assertFalse ( activated )
************************************
************************************
[+] input: Exception { LocaleInfo localeInfo = new LocaleInfo(new Locale("it")); IFile[] files = new IFile[]{ getFileSrc("test", "messages.properties"), getFileSrc("test", "messages_it.properties"),}; BundleInfo bundle = BundleInfo.createBundle( StandardPropertiesAccessor.INSTANCE, "test.messages", localeInfo, files); assertNotNull(bundle); assertEquals("test.messages", bundle.getBundleName()); assertSame(files[1], bundle.getFile()); assertSame(localeInfo, bundle.getLocale()); "<AssertPlaceHolder>"; }
isExternallyChanged() { return m_file.getModificationStamp() != m_propertiesStamp; }
[*] target: assertFalse(bundle.isExternallyChanged())
[-] pred: org. junit. Assert. assertFalse ( bundle. isExternallyChanged() )
************************************
************************************
[+] input: Exception { IFile file = getFileSrc("test/messages.properties"); // prepare file in UTF-8 with Russian characters String key = "key"; String value = "" + (char) 0x410 + (char) 0x411 + (char) 0x412; String newValue = "" + (char) 0x430 + (char) 0x431 + (char) 0x432; { String content = key + "=" + value; setFileContent(file, content.getBytes("UTF-8")); file.setCharset("UTF-8", null); } // use BundleInfo, session #1 // check for initial value { BundleInfo bundle = BundleInfo.createBundle( StandardPropertiesAccessor.INSTANCE, "test.messages", LocaleInfo.DEFAULT, new IFile[]{file}); assertNotNull(bundle); assertEquals(value, bundle.getValue(key)); // set new value bundle.setValue(key, newValue); bundle.save(""); assertEquals("UTF-8", file.getCharset()); } // use BundleInfo, session #2 // check for new value { BundleInfo bundle = BundleInfo.createBundle( StandardPropertiesAccessor.INSTANCE, "test.messages", LocaleInfo.DEFAULT, new IFile[]{file}); assertNotNull(bundle); "<AssertPlaceHolder>"; } }
getValue(String key) throws Exception { return getProperties().get(key); }
[*] target: assertEquals(newValue, bundle.getValue(key))
[-] pred: org. junit. Assert. assertEquals ( newValue, bundle. getValue( key ) )
************************************
************************************
[+] input: Exception { NlsTestUtils.create_EclipseOld_Accessor(this, false); setFileContentSrc( "test/messages.properties", getSourceDQ("frame.title=My JFrame", "frame.name=My name")); waitForAutoBuild(); // ContainerInfo frame = parseContainer( "class Test extends JFrame {", "  Test() {", "    setTitle(Messages.getString('frame.title')); //$NON-NLS-1$", "    setName(Messages.getString('frame.name')); //$NON-NLS-1$", "  }", "}"); // prepare NLS NlsSupport support = NlsSupport.get(frame); EditableSupport editableSupport = (EditableSupport) support.getEditable(); // prepare editable source IEditableSource editableSource; { List<IEditableSource> editableSources = editableSupport.getEditableSources(); "<AssertPlaceHolder>"; editableSource = editableSources.get(0); } // check keys assertStringSet(editableSource.getKeys(), new String[]{"frame.title", "frame.name"}); // rename - two times editableSource.renameKey("frame.name", "frame.name2"); editableSource.renameKey("frame.title", "frame.title2"); editableSource.renameKey("frame.title2", "frame.title3"); // apply commands support.applyEditable(editableSupport); // check assertStringSet(editableSource.getKeys(), new String[]{"frame.title3", "frame.name2"}); { String newProperties = getFileContentSrc("test/messages.properties"); // assertFalse(newProperties.contains("frame.name=My name")); assertTrue(newProperties.contains("frame.name2=My name")); // assertFalse(newProperties.contains("frame.title=My JFrame")); assertFalse(newProperties.contains("frame.title2=My JFrame")); assertTrue(newProperties.contains("frame.title3=My JFrame")); } assertEditor( "class Test extends JFrame {", "  Test() {", "    setTitle(Messages.getString('frame.title3')); //$NON-NLS-1$", "    setName(Messages.getString('frame.name2')); //$NON-NLS-1$", "  }", "}"); }
getEditableSources() { List<IEditableSource> editableSources = new ArrayList<>(); // add existing and new sources editableSources.addAll(m_sourceToEditable.values()); editableSources.addAll(m_newEditableSources); // if we have "real" editable sources, return them if (!editableSources.isEmpty()) { return editableSources; } // return "possible" editable sources return getPossibleEditableSources(); }
[*] target: assertEquals(1, editableSources.size())
[-] pred: org. junit. Assert. assertEquals ( 1, editableSources. size ( ) )
************************************
************************************
[+] input: Exception { NlsTestUtils.create_EclipseOld_Accessor(this, false); setFileContentSrc( "test/messages.properties", getSourceDQ("frame.title=My JFrame", "frame.name=My name")); waitForAutoBuild(); // ContainerInfo frame = parseContainer( "class Test extends JFrame {", "  Test() {", "    setTitle(Messages.getString('frame.title')); //$NON-NLS-1$", "    setName(Messages.getString('frame.name')); //$NON-NLS-1$", "  }", "}"); // prepare NLS NlsSupport support = NlsSupport.get(frame); EditableSupport editableSupport = (EditableSupport) support.getEditable(); // prepare editable source IEditableSource editableSource; { List<IEditableSource> editableSources = editableSupport.getEditableSources(); "<AssertPlaceHolder>"; editableSource = editableSources.get(0); } // check keys assertStringSet(editableSource.getKeys(), new String[]{"frame.title", "frame.name"}); // internalize editableSource.internalizeKey("frame.title"); editableSource.internalizeKey("frame.name"); // apply commands support.applyEditable(editableSupport); // check assertStringSet(editableSource.getKeys(), new String[]{}); { String newProperties = getFileContentSrc("test/messages.properties"); assertFalse(newProperties.contains("frame.name=My name")); assertFalse(newProperties.contains("frame.title=My JFrame")); } assertEditor( "class Test extends JFrame {", "  Test() {", "    setTitle('My JFrame');", "    setName('My name');", "  }", "}"); }
getEditableSources() { List<IEditableSource> editableSources = new ArrayList<>(); // add existing and new sources editableSources.addAll(m_sourceToEditable.values()); editableSources.addAll(m_newEditableSources); // if we have "real" editable sources, return them if (!editableSources.isEmpty()) { return editableSources; } // return "possible" editable sources return getPossibleEditableSources(); }
[*] target: assertEquals(1, editableSources.size())
[-] pred: org. junit. Assert. assertEquals ( 1, editableSources. size ( ) )
************************************
************************************
[+] input: Exception { m_testProject.addPlugin("org.eclipse.osgi"); NlsTestUtils.create_EclipseModern_AccessorAndProperties(); String[] lines = { "class Test extends JFrame {", "  Test() {", "    setTitle(Messages.frame_title);", "  }", "}"}; ContainerInfo frame = parseContainer(lines); String frameSource = m_lastEditor.getSource(); // prepare NLS NlsSupport support = NlsSupport.get(frame); EditableSupport editableSupport = (EditableSupport) support.getEditable(); // prepare editable source IEditableSource editableSource; { List<IEditableSource> editableSources = editableSupport.getEditableSources(); "<AssertPlaceHolder>"; editableSource = editableSources.get(0); } // add key editableSource.addKey("newKey", "newValue"); Assertions.assertThat(editableSource.getKeys()).contains("newKey"); { LocaleInfo[] locales = editableSource.getLocales(); Assertions.assertThat(locales).hasSize(2); assertEquals("newValue", editableSource.getValue(locales[0], "newKey")); assertEquals("newValue", editableSource.getValue(locales[1], "newKey")); } // apply commands support.applyEditable(editableSupport); assertEditor(frameSource, m_lastEditor); // checks { String accessor = getFileContentSrc("test/Messages.java"); Assertions.assertThat(accessor).contains("public static String newKey;"); } { String newProperties = getFileContentSrc("test/messages.properties"); Assertions.assertThat(newProperties).contains("newKey=newValue"); } { String newProperties = getFileContentSrc("test/messages_it.properties"); Assertions.assertThat(newProperties).contains("newKey=newValue"); } }
getEditableSources() { List<IEditableSource> editableSources = new ArrayList<>(); // add existing and new sources editableSources.addAll(m_sourceToEditable.values()); editableSources.addAll(m_newEditableSources); // if we have "real" editable sources, return them if (!editableSources.isEmpty()) { return editableSources; } // return "possible" editable sources return getPossibleEditableSources(); }
[*] target: assertEquals(1, editableSources.size())
[-] pred: org. junit. Assert. assertEquals ( 1, editableSources. size ( ) )
************************************
************************************
[+] input: Exception { CategoryInfo category = new CategoryInfo(); assertFalse(category.isOpen()); category.setOpen(true); "<AssertPlaceHolder>"; }
isOpen() { return m_open; }
[*] target: assertTrue(category.isOpen())
[-] pred: org. junit. Assert. assertTrue ( category. isOpen() )
************************************
************************************
[+] input: Exception { addPaletteExtension(new String[]{"<category id='id_1' name='name 1' description='description 1'/>"}); PaletteInfo palette = loadPalette(); // check category CategoryInfo category = palette.getCategory("id_1"); assertEquals("id_1", category.getId()); assertEquals("name 1", category.getName()); assertEquals("description 1", category.getDescription()); assertTrue(category.isVisible()); assertTrue(category.isOpen()); "<AssertPlaceHolder>"; }
isOptional() { return m_optional; }
[*] target: assertFalse(category.isOptional())
[-] pred: org. junit. Assert. assertFalse ( category. isOptional() )
************************************
************************************
[+] input: Exception { ChooseComponentEntryInfo entry = new ChooseComponentEntryInfo(); "<AssertPlaceHolder>"; assertNotNull(entry.getName()); assertNotNull(entry.getDescription()); }
getIcon() { return ICON; }
[*] target: assertNotNull(entry.getIcon())
[-] pred: org. junit. Assert. assertNotNull ( entry. getIcon() )
************************************
************************************
[+] input: Exception { addPaletteExtension(new String[]{ "<category id='category_1' name='category 1'>", "  <entry id='system.chooseComponent' class='" + ChooseComponentEntryInfo.class.getName() + "'/>", "</category>"}); JavaInfo panel = parseEmptyPanel(); final PaletteManager manager = new PaletteManager(panel, TOOLKIT_ID); manager.reloadPalette(); // set palette site IPaletteSite.Helper.setSite(panel, new IPaletteSite.Empty() { @Override public Shell getShell() { return DesignerPlugin.getShell(); } }); // prepare entry final ChooseComponentEntryInfo entry; { PaletteInfo palette = manager.getPalette(); CategoryInfo category = palette.getCategory("category_1"); entry = (ChooseComponentEntryInfo) category.getEntries().get(0); } // initialize assertTrue(entry.initialize(null, panel)); // create tool CreationTool creationTool; { final CreationTool[] tools = new CreationTool[1]; new UiContext().executeAndCheck(new UIRunnable() { @Override public void run(UiContext context) throws Exception { tools[0] = (CreationTool) entry.createTool(); } }, new UIRunnable() { @Override public void run(UiContext context) throws Exception { context.useShell("Open type"); context.clickButton("Cancel"); } }); creationTool = tools[0]; } // check tool "<AssertPlaceHolder>"; }
createTool() throws Exception { Shell parentShell = IPaletteSite.Helper.getSite(m_rootJavaInfo).getShell(); String componentClassName = JdtUiUtils.selectTypeName(parentShell, m_javaProject); if (componentClassName != null) { ComponentEntryInfo componentEntry = new ComponentEntryInfo(); // configure component entry { componentEntry.setId("custom_" + System.currentTimeMillis()); componentEntry.setName(CodeUtils.getShortClass(componentClassName)); componentEntry.setDescription(MessageFormat.format( Messages.ChooseComponentEntryInfo_newComponentDescription, componentClassName)); componentEntry.setComponentClassName(componentClassName); } // always add addChosenComponent(componentEntry); // try to initialize if (componentEntry.initialize(m_editPartViewer, m_rootJavaInfo)) { return componentEntry.createTool(); } else { boolean shouldReparse = MessageDialog.openQuestion( DesignerPlugin.getShell(), Messages.ChooseComponentEntryInfo_unableToLoadTest, MessageFormat.format( Messages.ChooseComponentEntryInfo_unableToLoadMessage, componentClassName)); if (shouldReparse) { IDesignPageSite.Helper.getSite(m_rootJavaInfo).reparse(); } } } return null; }
[*] target: assertNull(creationTool)
[-] pred: org. junit. Assert. assertNull ( creationTool )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyAbstractButton.java", getTestSource( "// filler filler filler filler filler", "// filler filler filler filler filler", "public abstract class MyAbstractButton extends JButton {", "}")); waitForAutoBuild(); // prepare palette addPaletteExtension(new String[]{ "<category id='category_1' name='category 1'>", "  <component class='test.MyAbstractButton'/>", "</category>"}); PaletteInfo palette = loadPalette(); // prepare component final CategoryInfo category = palette.getCategory("category_1"); final ComponentEntryInfo componentEntry = (ComponentEntryInfo) category.getEntries().get(0); // set palette site IPaletteSite.Helper.setSite(m_lastParseInfo, new IPaletteSite.Empty() { @Override public Shell getShell() { return DesignerPlugin.getShell(); } }); // do initialize assertTrue(componentEntry.initialize(null, m_lastParseInfo)); // create tool new UiContext().executeAndCheck(new UIRunnable() { @Override public void run(UiContext context) throws Exception { CreationTool creationTool = (CreationTool) componentEntry.createTool(); "<AssertPlaceHolder>"; } }, new UIRunnable() { @Override public void run(UiContext context) throws Exception { context.useShell("Error"); context.clickButton("OK"); } }); }
createTool() throws Exception { if (!ensureDescriptions()) { return null; } if (ReflectionUtils.isAbstract(m_class) && !m_creation.hasTrueTag("createAnonymous")) { Shell parentShell = IPaletteSite.Helper.getSite(m_rootJavaInfo).getShell(); UiUtils.openError( parentShell, Messages.ComponentEntryInfo_abstractTitle, Messages.ComponentEntryInfo_abstractMessage); return null; } // prepare generics final Map<String, String> genericArguments = getTypeArguments(); if (genericArguments == null) { return null; } // prepare factory ICreationFactory factory = new ICreationFactory() { private JavaInfo m_javaInfo;  @Override public void activate() throws Exception { CreationSupport creationSupport = new ConstructorCreationSupport(m_creationId, true); m_javaInfo = JavaInfoUtils.createJavaInfo(m_editor, m_description, creationSupport); m_javaInfo.putTemplateArguments(genericArguments); m_javaInfo = JavaInfoUtils.getWrapped(m_javaInfo); m_javaInfo.putArbitraryValue(JavaInfo.FLAG_MANUAL_COMPONENT, Boolean.TRUE); }  @Override public Object getNewObject() { return m_javaInfo; } }; // return tool ensureLibraries(); return new CreationTool(factory); }
[*] target: assertNull(creationTool)
[-] pred: org. junit. Assert. assertNull ( creationTool )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyAbstractButton.java", getTestSource( "// filler filler filler filler filler", "// filler filler filler filler filler", "public abstract class MyAbstractButton extends JButton {", "}")); setFileContentSrc( "test/MyAbstractButton.wbp-component.xml", getSourceDQ( "<?xml version='1.0' encoding='UTF-8'?>", "<component xmlns='http://www.eclipse.org/wb/WBPComponent'>", "  <creation>", "    <source><![CDATA[new test.MyAbstractButton(){}]]></source>", "    <tag name='createAnonymous' value='true'/>", "  </creation>", "</component>")); waitForAutoBuild(); // prepare palette addPaletteExtension(new String[]{ "<category id='category_1' name='category 1'>", "  <component class='test.MyAbstractButton'/>", "</category>"}); PaletteInfo palette = loadPalette(); // prepare component final CategoryInfo category = palette.getCategory("category_1"); final ComponentEntryInfo componentEntry = (ComponentEntryInfo) category.getEntries().get(0); // set palette site IPaletteSite.Helper.setSite(m_lastParseInfo, new IPaletteSite.Empty() { @Override public Shell getShell() { return DesignerPlugin.getShell(); } }); // do initialize assertTrue(componentEntry.initialize(null, m_lastParseInfo)); // create tool CreationTool creationTool = (CreationTool) componentEntry.createTool(); "<AssertPlaceHolder>"; }
createTool() throws Exception { if (!ensureDescriptions()) { return null; } if (ReflectionUtils.isAbstract(m_class) && !m_creation.hasTrueTag("createAnonymous")) { Shell parentShell = IPaletteSite.Helper.getSite(m_rootJavaInfo).getShell(); UiUtils.openError( parentShell, Messages.ComponentEntryInfo_abstractTitle, Messages.ComponentEntryInfo_abstractMessage); return null; } // prepare generics final Map<String, String> genericArguments = getTypeArguments(); if (genericArguments == null) { return null; } // prepare factory ICreationFactory factory = new ICreationFactory() { private JavaInfo m_javaInfo;  @Override public void activate() throws Exception { CreationSupport creationSupport = new ConstructorCreationSupport(m_creationId, true); m_javaInfo = JavaInfoUtils.createJavaInfo(m_editor, m_description, creationSupport); m_javaInfo.putTemplateArguments(genericArguments); m_javaInfo = JavaInfoUtils.getWrapped(m_javaInfo); m_javaInfo.putArbitraryValue(JavaInfo.FLAG_MANUAL_COMPONENT, Boolean.TRUE); }  @Override public Object getNewObject() { return m_javaInfo; } }; // return tool ensureLibraries(); return new CreationTool(factory); }
[*] target: assertNotNull(creationTool)
[-] pred: org. junit. Assert. assertNotNull ( creationTool )
************************************
************************************
[+] input: Exception { addPaletteExtension(new String[]{ "<category id='category_1' name='category 1'>", "  <component class='no.such.Class'/>", "</category>"}); PaletteInfo palette = loadPalette(); // prepare component CategoryInfo category = palette.getCategory("category_1"); ComponentEntryInfo componentEntry = (ComponentEntryInfo) category.getEntries().get(0); // do initialize m_lastParseInfo.putArbitraryValue(ComponentEntryInfo.KEY_SIMULATE_PRESENTATION, true); assertTrue(componentEntry.initialize(null, m_lastParseInfo)); // create tool Assertions.assertThat(m_lastState.getWarnings()).hasSize(0); CreationTool creationTool = (CreationTool) componentEntry.createTool(); "<AssertPlaceHolder>"; Assertions.assertThat(m_lastState.getWarnings()).hasSize(1); }
createTool() throws Exception { if (!ensureDescriptions()) { return null; } if (ReflectionUtils.isAbstract(m_class) && !m_creation.hasTrueTag("createAnonymous")) { Shell parentShell = IPaletteSite.Helper.getSite(m_rootJavaInfo).getShell(); UiUtils.openError( parentShell, Messages.ComponentEntryInfo_abstractTitle, Messages.ComponentEntryInfo_abstractMessage); return null; } // prepare generics final Map<String, String> genericArguments = getTypeArguments(); if (genericArguments == null) { return null; } // prepare factory ICreationFactory factory = new ICreationFactory() { private JavaInfo m_javaInfo;  @Override public void activate() throws Exception { CreationSupport creationSupport = new ConstructorCreationSupport(m_creationId, true); m_javaInfo = JavaInfoUtils.createJavaInfo(m_editor, m_description, creationSupport); m_javaInfo.putTemplateArguments(genericArguments); m_javaInfo = JavaInfoUtils.getWrapped(m_javaInfo); m_javaInfo.putArbitraryValue(JavaInfo.FLAG_MANUAL_COMPONENT, Boolean.TRUE); }  @Override public Object getNewObject() { return m_javaInfo; } }; // return tool ensureLibraries(); return new CreationTool(factory); }
[*] target: assertNull(creationTool)
[-] pred: org. junit. Assert. assertNull ( creationTool )
************************************
************************************
[+] input: Exception { // some other class { Throwable e = new NoClassDefFoundError("not/designer/Class"); assertFalse(isIncompleteProductException(e)); } // Designer { Throwable e = new NoClassDefFoundError("org/eclipse/wb/Foo"); assertTrue(isIncompleteProductException(e)); // even wrapped e = new Error(e); assertTrue(isIncompleteProductException(e)); } // JDT { Throwable e = new NoClassDefFoundError("org/eclipse/jdt/core/dom/AnonymousTypeDeclaration2"); assertTrue(isIncompleteProductException(e)); // even wrapped e = new Error(e); "<AssertPlaceHolder>"; } }
isIncompleteProductException(Throwable e) { if (e instanceof NoSuchMethodError) { return e.getMessage().startsWith("org.eclipse.wb."); } if (e instanceof NoClassDefFoundError) { String message = e.getMessage(); return message.startsWith("org/eclipse/wb/") || message.startsWith("org/eclipse/jdt/"); } return false; }
[*] target: assertTrue(isIncompleteProductException(e))
[-] pred: org. junit. Assert. assertTrue ( isIncompleteProductException( e) )
************************************
************************************
[+] input: Exception { TestBundle testBundle = new TestBundle(); try { testBundle.addExtension(POINT_ID, "<testObject icon='res/path/test.png'/>"); testBundle.setFile("res/path/test.png", TestUtils.createImagePNG(2, 3)); testBundle.install(); // work with Bundle { IConfigurationElement element = ExternalFactoriesHelper.getElements(POINT_ID, "testObject").get(0); ImageDescriptor descriptor = ExternalFactoriesHelper.getImageDescriptor(element, "icon"); "<AssertPlaceHolder>"; // validate Image image = descriptor.createImage(); try { assertEquals(2, image.getBounds().width); assertEquals(3, image.getBounds().height); } finally { image.dispose(); } } } finally { testBundle.dispose(); } }
getImageDescriptor(IConfigurationElement element, String attribute) { String path = element.getAttribute(attribute); if (path != null) { Bundle bundle = getExtensionBundle(element); BundleResourceProvider resourceProvider = BundleResourceProvider.get(bundle); return resourceProvider.getImageDescriptor(path); } return null; }
[*] target: assertNotNull(descriptor)
[-] pred: org. junit. Assert. assertNotNull ( descriptor )
************************************
************************************
[+] input: Exception { // prepare objects List<Object> objects; { objects = new ArrayList<>(); objects.add("123"); objects.add(555); } // prepare selection provider ISelectionProvider selectionProvider; { final ISelection selection = new StructuredSelection(objects); selectionProvider = new ISelectionProvider() { @Override public ISelection getSelection() { return selection; }  @Override public void setSelection(ISelection _selection) { }  @Override public void removeSelectionChangedListener(ISelectionChangedListener listener) { }  @Override public void addSelectionChangedListener(ISelectionChangedListener listener) { } }; } // get iterable Iterable<Object> iterable = GenericsUtils.iterableSelection(selectionProvider); // iterate { // prepare iterator Iterator<Object> iterator = iterable.iterator(); // first element assertTrue(iterator.hasNext()); assertSame(objects.get(0), iterator.next()); // second element assertTrue(iterator.hasNext()); assertSame(objects.get(1), iterator.next()); // not more elements "<AssertPlaceHolder>"; } }
hasNext() { return iterator.hasNext(); }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext() )
************************************
************************************
[+] input: Exception { CompilationUnit compilationUnit = createASTCompilationUnit( "test", "Test.java", getSourceDQ( "// filler filler filler filler filler", "// filler filler filler filler filler", "// filler filler filler filler filler", "package test;", "public class Test {", "}")); // no exception compilationUnit.accept(new AstVisitorEx() { @Override public void preVisitEx(ASTNode node) throws Exception { } }); // exception final Exception expected = new Exception("pre"); try { compilationUnit.accept(new AstVisitorEx() { @Override public void preVisitEx(ASTNode node) throws Exception { throw expected; } }); fail(); } catch (Throwable e) { "<AssertPlaceHolder>"; } }
preVisitEx(ASTNode node) throws Exception { }
[*] target: assertSame(expected, e)
[-] pred: org. junit. Assert. assertSame ( expected, e )
************************************
************************************
[+] input: Exception { CompilationUnit compilationUnit = createASTCompilationUnit( "test", "Test.java", getSourceDQ( "// filler filler filler filler filler", "// filler filler filler filler filler", "// filler filler filler filler filler", "package test;", "public class Test {", "}")); // no exception compilationUnit.accept(new AstVisitorEx() { @Override public void postVisitEx(ASTNode node) throws Exception { } }); // exception final Exception expected = new Exception("post"); try { compilationUnit.accept(new AstVisitorEx() { @Override public void postVisitEx(ASTNode node) throws Exception { throw expected; } }); fail(); } catch (Throwable e) { "<AssertPlaceHolder>"; } }
postVisitEx(ASTNode node) throws Exception { }
[*] target: assertSame(expected, e)
[-] pred: org. junit. Assert. assertSame ( expected, e )
************************************
************************************
[+] input: Exception { CompilationUnit compilationUnit = createASTCompilationUnit( "test", "Test.java", getSourceDQ( "// filler filler filler filler filler", "// filler filler filler filler filler", "// filler filler filler filler filler", "package test;", "public class Test {", "  java.lang.Object o = null;", "}")); // no exception compilationUnit.accept(new AstVisitorEx() { @Override public boolean visitEx(QualifiedName node) throws Exception { return true; } }); // exception final Exception expected = new Exception("visit"); try { compilationUnit.accept(new AstVisitorEx() { @Override public boolean visitEx(QualifiedName node) throws Exception { throw expected; } }); fail(); } catch (Throwable e) { "<AssertPlaceHolder>"; } }
visitEx(QualifiedName node) throws Exception { return true; }
[*] target: assertSame(expected, e)
[-] pred: org. junit. Assert. assertSame ( expected, e )
************************************
************************************
[+] input: Exception { final Exception exception = new Exception(); try { ExecutionUtils.runObject(() -> { throw exception; }); } catch (Throwable e) { "<AssertPlaceHolder>"; } }
runObject(Callable<T> runnable) { try { return runnable.call(); } catch (Throwable e) { throw ReflectionUtils.propagate(e); } }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: Exception { final AtomicBoolean refreshed = new AtomicBoolean(); final TestObjectInfo object = new TestObjectInfo() { @Override protected void refresh_finish() throws Exception { refreshed.set(true); } }; // do refresh ExecutionUtils.refresh(object); "<AssertPlaceHolder>"; }
refresh(ObjectInfo objectInfo) { run(objectInfo, new RunnableEx() { @Override public void run() throws Exception { // do nothing, we need just refresh } }); }
[*] target: assertTrue(refreshed.get())
[-] pred: org. junit. Assert. assertTrue ( refreshed. get ( ) )
************************************
************************************
[+] input: Exception { Map<String, String> options = ProjectUtils.getOptions(m_testProject.getJavaProject()); "<AssertPlaceHolder>"; // check one option assertEquals("error", options.get("org.eclipse.jdt.core.incompleteClasspath")); }
getOptions(IJavaProject project) { return project.getOptions(true); }
[*] target: assertNotNull(options)
[-] pred: org. junit. Assert. assertNotNull ( options )
************************************
************************************
[+] input: Exception { IPath workspacePath = new Path("/noSuchProject/andNoFolder"); IPath osPath = ProjectUtils.getOSPath(workspacePath); "<AssertPlaceHolder>"; }
getOSPath(IPath path) { IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot(); IResource resource = workspaceRoot.findMember(path); return resource != null ? resource.getLocation() : null; }
[*] target: assertNull(osPath)
[-] pred: org. junit. Assert. assertNull ( osPath )
************************************
************************************
[+] input: Exception { scope.setIncludesBinaries(true); scope.setIncludesClasspaths(true); assertTrue(scope.includesBinaries()); "<AssertPlaceHolder>"; }
includesClasspaths() { return m_hierarchyScope.includesClasspaths(); }
[*] target: assertTrue(scope.includesClasspaths())
[-] pred: org. junit. Assert. assertTrue ( scope. includesClasspaths() )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); panel.refresh(); // initial "active" assertSame(panel, GlobalState.getActiveObject()); // use "live" manager { ComponentInfo button = createJButton(); Component component = button.getComponent(); "<AssertPlaceHolder>"; } // "active" is not changed assertSame(panel, GlobalState.getActiveObject()); }
getComponent() { return ((SwingLiveCacheEntry) getCachedEntry()).getComponent(); }
[*] target: assertNotNull(component)
[-] pred: org. junit. Assert. assertNotNull ( component )
************************************
************************************
[+] input: Exception { // create image descriptor Object imageDescriptor = ReflectionUtils.invokeMethod( ManagerClass, "getImageDescriptor(java.lang.Class,java.lang.String)", ManagerClass, "/javax/swing/plaf/basic/icons/JavaCup16.png"); // check create "<AssertPlaceHolder>"; }
getImageDescriptor(Class<?> clazz, String path) { return ImageDescriptor.createFromFile(clazz, path); }
[*] target: assertNotNull(imageDescriptor)
[-] pred: org. junit. Assert. assertNotNull ( imageDescriptor )
************************************
************************************
[+] input: Exception { Object imageDescriptor = null; Object image = ReflectionUtils.invokeMethod( ManagerClass, "getImage(org.eclipse.jface.resource.ImageDescriptor)", imageDescriptor); "<AssertPlaceHolder>"; }
getImage(ImageDescriptor descriptor) { if (descriptor == null) { return null; } Image image = m_descriptorImageMap.get(descriptor); if (image == null) { image = descriptor.createImage(); m_descriptorImageMap.put(descriptor, image); } return image; }
[*] target: assertNull(image)
[-] pred: org. junit. Assert. assertNull ( image )
************************************
************************************
[+] input: Exception { Class<?> SWTClass = m_lastLoader.loadClass("org.eclipse.swt.SWT"); ColorInfo info = ColorSupport.createInfo(ReflectionUtils.getFieldByName(SWTClass, "COLOR_RED")); // check create "<AssertPlaceHolder>"; // check color name assertEquals("COLOR_RED", info.m_name); // check special data assertEquals("org.eclipse.swt.SWT.COLOR_RED", info.getData()); // check RGB assertNotNull(info.m_rgb); assertEquals(255, info.m_rgb.red); assertEquals(0, info.m_rgb.green); assertEquals(0, info.m_rgb.blue); }
createInfo(String name, Object color) throws Exception { return new ColorInfo(name, getRed(color), getGreen(color), getBlue(color)); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: Exception { Object shell = ContainerSupport.createShell(); Image rcpImage = ImageDescriptor.createFromFile(Object.class, "/javax/swing/plaf/basic/icons/JavaCup16.png") .createImage(); try { assertNull(ReflectionUtils.invokeMethod(shell, "getImage()")); // ContainerSupport.setShellImage(shell, rcpImage); // check newly set image { Object image = ReflectionUtils.invokeMethod(shell, "getImage()"); // exists... "<AssertPlaceHolder>"; // ..and has same size { Object bounds = ReflectionUtils.invokeMethod(image, "getBounds()"); assertEquals(rcpImage.getBounds().width, ReflectionUtils.getFieldInt(bounds, "width")); assertEquals(rcpImage.getBounds().height, ReflectionUtils.getFieldInt(bounds, "height")); } } } finally { rcpImage.dispose(); ControlSupport.dispose(shell); } }
setShellImage(Object shell, Image swtImage) throws Exception { Object image = SWT_TO_TOOLKIT_IMAGES.get(swtImage); if (image == null) { image = ToolkitSupport.createToolkitImage(swtImage); SWT_TO_TOOLKIT_IMAGES.put(swtImage, image); } ReflectionUtils.invokeMethod(shell, "setImage(org.eclipse.swt.graphics.Image)", image); }
[*] target: assertNotNull(image)
[-] pred: org. junit. Assert. assertNotNull ( image )
************************************
************************************
[+] input: Exception { Object button = getButton(); Object toDisplayPoint = ReflectionUtils.invokeMethod(button, "toDisplay(int,int)", 5, 5); Point toDisplayPointTest = ControlSupport.toDisplay(button, 5, 5); "<AssertPlaceHolder>"; assertEquals(ReflectionUtils.getFieldInt(toDisplayPoint, "x"), toDisplayPointTest.x); assertEquals(ReflectionUtils.getFieldInt(toDisplayPoint, "y"), toDisplayPointTest.y); }
toDisplay(Object control, int x, int y) throws Exception { Object location = ReflectionUtils.invokeMethod(control, "toDisplay(int,int)", x, y); return PointSupport.getPoint(location); }
[*] target: assertNotNull(toDisplayPointTest)
[-] pred: org. junit. Assert. assertNotNull ( toDisplayPointTest )
************************************
************************************
[+] input: Exception { Object button = getButton(); Object preferredSize = ControlSupport.computeSize_DEFAULT(button); Dimension preferredSizeTest = ControlSupport.getPreferredSize(button); "<AssertPlaceHolder>"; assertEquals(ReflectionUtils.getFieldInt(preferredSize, "x"), preferredSizeTest.width); assertEquals(ReflectionUtils.getFieldInt(preferredSize, "y"), preferredSizeTest.height); }
getPreferredSize(Object control) throws Exception { Object size = ReflectionUtils.invokeMethod( control, "computeSize(int,int)", SwtSupport.DEFAULT, SwtSupport.DEFAULT); Point pointSize = PointSupport.getPoint(size); return new Dimension(pointSize.x, pointSize.y); }
[*] target: assertNotNull(preferredSizeTest)
[-] pred: org. junit. Assert. assertNotNull ( preferredSizeTest )
************************************
************************************
[+] input: Exception { disposeLastModel(); CompositeInfo shellInfo = (CompositeInfo) parseSource( "test", "Test2.java", getTestSource( "public class Test2 extends Shell {", "  public Test2() {", "    setLayout(new RowLayout());", "    Button button = new Button(this, SWT.NONE);", "    button.setLayoutData(new RowData(100, 50));", "  }", "}")); shellInfo.refresh(); ControlInfo buttonInfo = shellInfo.getChildrenControls().get(0); Object button = buttonInfo.getObject(); // call getLayoutData() Object layoutData = ControlSupport.getLayoutData(button); "<AssertPlaceHolder>"; assertEquals("org.eclipse.swt.layout.RowData", layoutData.getClass().getName()); }
getLayoutData(Object control) { return ReflectionUtils.invokeMethodEx(control, "getLayoutData()"); }
[*] target: assertNotNull(layoutData)
[-] pred: org. junit. Assert. assertNotNull ( layoutData )
************************************
************************************
[+] input: Exception { Figure testFigure = new Figure(); // // check tooltip for new Figure assertNull(testFigure.getToolTipText()); // // check set tooltip testFigure.setToolTipText("JLabel("123")"); assertEquals("JLabel("123")", testFigure.getToolTipText()); // // check set other tooltip testFigure.setToolTipText("new Button()"); assertEquals("new Button()", testFigure.getToolTipText()); // // check set 'null' tooltip testFigure.setToolTipText(null); "<AssertPlaceHolder>"; }
getToolTipText() { return m_toolTipText; }
[*] target: assertNull(testFigure.getToolTipText())
[-] pred: org. junit. Assert. assertNull ( testFigure. getToolTipText() )
************************************
************************************
[+] input: Exception { LineBorder border = new LineBorder(); // check init state properties for new border assertNull(border.getColor()); "<AssertPlaceHolder>"; assertEquals(new Insets(1), border.getInsets(null)); }
getWidth() { return m_width; }
[*] target: assertEquals(1, border.getWidth())
[-] pred: org. junit. Assert. assertEquals ( 1, border. getWidth() )
************************************
************************************
[+] input: Exception { LineBorder border = new LineBorder(3); // check init state properties for border constructor(int) assertNull(border.getColor()); "<AssertPlaceHolder>"; assertEquals(new Insets(3), border.getInsets(null)); }
getWidth() { return m_width; }
[*] target: assertEquals(3, border.getWidth())
[-] pred: org. junit. Assert. assertEquals ( 3, border. getWidth() )
************************************
************************************
[+] input: Exception { LineBorder border = new LineBorder(red); // check init state properties for border constructor(Color) assertSame(red, border.getColor()); "<AssertPlaceHolder>"; assertEquals(new Insets(1), border.getInsets(null)); }
getWidth() { return m_width; }
[*] target: assertEquals(1, border.getWidth())
[-] pred: org. junit. Assert. assertEquals ( 1, border. getWidth() )
************************************
************************************
[+] input: Exception { // check reset state during addPoint() m_polyline.addPoint(new Point(10, 20)); // m_expectedLogger.log("invalidate"); m_expectedLogger.log("repaint(10, 20, 1, 1)"); m_actualLogger.assertEquals(m_expectedLogger); // // check reset state during addPoint() m_polyline.addPoint(new Point(-90, 0)); // m_expectedLogger.log("invalidate"); m_expectedLogger.log("repaint(-90, 0, 101, 21)"); m_actualLogger.assertEquals(m_expectedLogger); // // check reset state during addPoint() m_polyline.addPoint(new Point(120, -70)); // m_expectedLogger.log("invalidate"); m_expectedLogger.log("repaint(-90, -70, 211, 91)"); m_actualLogger.assertEquals(m_expectedLogger); // // check add null point and not reset state try { m_polyline.addPoint(null); fail(); } catch (NullPointerException e) { m_actualLogger.assertEmpty(); } // // check work getPoint(int) PointList list = m_polyline.getPoints(); "<AssertPlaceHolder>"; assertEquals(3, list.size()); assertEquals(new Point(10, 20), list.getPoint(0)); assertEquals(new Point(-90, 0), list.getPoint(1)); assertEquals(new Point(120, -70), list.getPoint(2)); }
getPoints() { return m_points; }
[*] target: assertNotNull(list)
[-] pred: org. junit. Assert. assertNotNull ( list )
************************************
************************************
[+] input: Exception { KeyPair keyPair = Keys.createSecp256k1KeyPair(); PrivateKey privateKey = keyPair.getPrivateKey(); PublicKey publicKey = keyPair.getPublicKey();  "<AssertPlaceHolder>"; assertNotNull(publicKey);  assertEquals(privateKey.getEncoded().length, (32)); assertEquals(publicKey.getEncoded().length, (64)); }
createSecp256k1KeyPair() throws NoSuchProviderException, NoSuchAlgorithmException, InvalidAlgorithmParameterException { return createSecp256k1KeyPair(SecureRandomProvider.publicSecureRandom()); }
[*] target: assertNotNull(privateKey)
[-] pred: org. junit. Assert. assertNotNull ( privateKey )
************************************
************************************
[+] input: testIp() { ChannelManager channelManager = new ChannelManager(kernel); InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1", 1001); "<AssertPlaceHolder>"; }
isAcceptable(InetSocketAddress address) { //对于进来的连接，只判断ip，不判断port if (!addressSet.isEmpty()) { for (InetSocketAddress inetSocketAddress : addressSet) { // 不连接自己 if (!isSelfAddress(address)&&inetSocketAddress.getAddress().equals(address.getAddress())) { return true; } } } return false; }
[*] target: assertTrue(channelManager.isAcceptable(inetSocketAddress))
[-] pred: org. junit. Assert. assertTrue ( channelManager. isAcceptable( inetSocketAddress ) )
************************************
************************************
[+] input: testShouldProduceTheSameMnemonic() { final String expected = "clinic excuse minimum until indoor flower fun concert inquiry letter audit patrol"; final String actual = MnemonicUtils.generateMnemonic(MnemonicUtils.generateEntropy(expected)); "<AssertPlaceHolder>"; }
generateEntropy(String mnemonic) { final BitSet bits = new BitSet(); final int size = mnemonicToBits(mnemonic, bits); if (size == 0) { throw new IllegalArgumentException("Empty mnemonic"); }  final int ent = 32 * size / 33; if (ent % 8 != 0) { throw new IllegalArgumentException("Wrong mnemonic size"); } final byte[] entropy = new byte[ent / 8]; for (int i = 0; i < entropy.length; i++) { entropy[i] = readByte(bits, i); } validateEntropy(entropy);  final byte expectedChecksum = calculateChecksum(entropy); final byte actualChecksum = readByte(bits, entropy.length); if (expectedChecksum != actualChecksum) { throw new IllegalArgumentException("Wrong checksum"); }  return entropy; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: isCacheableContent() { final Cache cache = new Cache(); final Map<String, String> headers = new HashMap<>(); final WebResponse response = new WebResponseMock(null, headers);  assertFalse(cache.isCacheableContent(response));  headers.put(LAST_MODIFIED, "Sun, 15 Jul 2007 20:46:27 GMT"); assertTrue(cache.isCacheableContent(response));  headers.put(LAST_MODIFIED, formatDate(DateUtils.addMinutes(new Date(), -5))); assertTrue(cache.isCacheableContent(response));  headers.put(LAST_MODIFIED, formatDate(new Date())); assertFalse(cache.isCacheableContent(response));  headers.put(LAST_MODIFIED, formatDate(DateUtils.addMinutes(new Date(), 10))); assertFalse(cache.isCacheableContent(response));  headers.put(EXPIRES, formatDate(DateUtils.addMinutes(new Date(), 5))); assertFalse(cache.isCacheableContent(response));  headers.put(EXPIRES, formatDate(DateUtils.addHours(new Date(), 1))); assertTrue(cache.isCacheableContent(response));  headers.remove(LAST_MODIFIED); assertTrue(cache.isCacheableContent(response));  headers.put(EXPIRES, "0"); assertFalse(cache.isCacheableContent(response));  headers.put(EXPIRES, "-1"); assertFalse(cache.isCacheableContent(response));  headers.put(CACHE_CONTROL, "no-store"); "<AssertPlaceHolder>"; }
isCacheableContent(final WebResponse response) { if (HeaderUtils.containsNoStore(response)) { return false; }  final long now = getCurrentTimestamp(); return isWithinCacheWindow(response, now, now); }
[*] target: assertFalse(cache.isCacheableContent(response))
[-] pred: org. junit. Assert. assertFalse ( cache. isCacheableContent ( response ) )
************************************
************************************
[+] input: Exception { final List<NameValuePair> emptyList = Collections.emptyList(); final WebResponseData webResponseData = new WebResponseData( ArrayUtils.EMPTY_BYTE_ARRAY, HttpClientConverter.NOT_FOUND, "not found", emptyList); final WebResponse webResponse = new WebResponse(webResponseData, URL_FIRST, HttpMethod.GET, 10); final FailingHttpStatusCodeException e = new FailingHttpStatusCodeException(webResponse);  assertEquals(webResponse, e.getResponse()); assertEquals(webResponse.getStatusMessage(), e.getStatusMessage()); "<AssertPlaceHolder>"; assertTrue("message doesn't contain failing url", e.getMessage().indexOf(URL_FIRST.toExternalForm()) > -1); }
getStatusCode() { return response_.getStatusCode(); }
[*] target: assertEquals(webResponse.getStatusCode(), e.getStatusCode())
[-] pred: org. junit. Assert. assertEquals ( webResponse. getStatusCode ( ), e. getStatusCode ( ) )
************************************
************************************
[+] input: Exception { final String html = "<html><head>\n" + "  <script src='script.js'></script>\n" + "</head>\n" + "<body>\n" + "</body>\n" + "</html>";  final WebClient webClient = getWebClient();  final List<String> collectedIncorrectness = new ArrayList<>(); final IncorrectnessListener listener = new IncorrectnessListener() { @Override public void notify(final String message, final Object origin) { collectedIncorrectness.add(message); } }; webClient.setIncorrectnessListener(listener);  final MockWebConnection webConnection = new MockWebConnection(); webClient.setWebConnection(webConnection); webConnection.setResponse(URL_FIRST, html); webConnection.setDefaultResponse("alert('Hello');", "application/x-javascript"); webClient.getPage(URL_FIRST);  final String[] expectedIncorrectness = { "Obsolete content type encountered: 'application/x-javascript' for " + "remotely loaded JavaScript element at 'http://localhost:22222/script.js'." }; "<AssertPlaceHolder>"; }
notify(String message, Object origin);
[*] target: assertEquals(expectedIncorrectness, collectedIncorrectness)
[-] pred: org. junit. Assert. assertEquals ( expectedIncorrectness, collectedIncorrectness )
************************************
************************************
[+] input: isInNet() { final boolean isInNet = ProxyAutoConfig.isInNet("www.1234abcd.abc", "172.16.0.0", "255.240.0.0"); "<AssertPlaceHolder>"; }
isInNet(final String host, final String pattern, final String mask) { final String dnsResolve = dnsResolve(host); if (null == dnsResolve) { return false; }  final SubnetUtils subnetUtils = new SubnetUtils(pattern, mask); return subnetUtils.getInfo().isInRange(dnsResolve); }
[*] target: assertFalse(isInNet)
[-] pred: org. junit. Assert. assertFalse ( isInNet )
************************************
************************************
[+] input: isInNetRange() { final boolean isInNet = ProxyAutoConfig.isInNet("172.22.0.7", "172.16.0.0", "255.240.0.0"); "<AssertPlaceHolder>"; }
isInNet(final String host, final String pattern, final String mask) { final String dnsResolve = dnsResolve(host); if (null == dnsResolve) { return false; }  final SubnetUtils subnetUtils = new SubnetUtils(pattern, mask); return subnetUtils.getInfo().isInRange(dnsResolve); }
[*] target: assertTrue(isInNet)
[-] pred: org. junit. Assert. assertTrue ( isInNet )
************************************
************************************
[+] input: Exception { final WebClient client = getWebClient(); final WebWindow window = client.openWindow(null, "TestingWindow"); "<AssertPlaceHolder>"; }
openWindow(final URL url, final String windowName) { WebAssert.notNull("windowName", windowName); return openWindow(url, windowName, getCurrentWindow()); }
[*] target: assertNotNull(window)
[-] pred: org. junit. Assert. assertNotNull ( window )
************************************
************************************
[+] input: Exception { final WebClient client = getWebClient(); final WebWindow window = client.openWindow(UrlUtils.URL_ABOUT_BLANK, "TestingWindow"); "<AssertPlaceHolder>"; }
openWindow(final URL url, final String windowName) { WebAssert.notNull("windowName", windowName); return openWindow(url, windowName, getCurrentWindow()); }
[*] target: assertNotNull(window)
[-] pred: org. junit. Assert. assertNotNull ( window )
************************************
************************************
[+] input: Exception { final WebClient client = getWebClient();  final MockWebConnection conn = new MockWebConnection(); final String html = "<html><body onload='document.getElementById("f").src="frame.html";'>\n" + "<iframe id='f'></iframe></body></html>"; conn.setResponse(URL_FIRST, html); final URL frameUrl = new URL(URL_FIRST, "frame.html"); conn.setResponse(frameUrl, "<html><body></body></html>"); conn.setResponse(URL_SECOND, "<html><body></body></html>"); client.setWebConnection(conn);  client.getPage(URL_FIRST); assertEquals(2, client.getWebWindows().size()); assertEquals(frameUrl, client.getCurrentWindow().getEnclosedPage().getUrl());  // loading a new page should be done in the top window client.getPage(URL_SECOND); assertTrue(client.getCurrentWindow() instanceof TopLevelWindow); "<AssertPlaceHolder>"; }
getWebWindows() { return Collections.unmodifiableList(new ArrayList<>(windows_)); }
[*] target: assertEquals(1, client.getWebWindows().size())
[-] pred: org. junit. Assert. assertEquals ( 1, client. getWebWindows ( ). size ( ) )
************************************
************************************
[+] input: Exception { final URL url1 = new URL("http://htmlunit.sf.net/foo.html"); final URL url2 = new URL("https://htmlunit.sf.net/foo.html");  WebRequest request = new WebRequest(new URL("http://htmlunit.sf.net:80/foo.html")); assertEquals(url1, request.getUrl());  request = new WebRequest(new URL("https://htmlunit.sf.net:443/foo.html")); "<AssertPlaceHolder>"; }
getUrl() { return UrlUtils.toUrlSafe(url_); }
[*] target: assertEquals(url2, request.getUrl())
[-] pred: org. junit. Assert. assertEquals ( url2, request. getUrl ( ) )
************************************
************************************
[+] input: Exception { final URL url1 = new URL("http://htmlunit.sf.net:8080/foo.html"); final URL url2 = new URL("https://htmlunit.sf.net:8443/foo.html");  WebRequest request = new WebRequest(new URL("http://htmlunit.sf.net:8080/foo.html")); assertEquals(url1, request.getUrl());  request = new WebRequest(new URL("https://htmlunit.sf.net:8443/foo.html")); "<AssertPlaceHolder>"; }
getUrl() { return UrlUtils.toUrlSafe(url_); }
[*] target: assertEquals(url2, request.getUrl())
[-] pred: org. junit. Assert. assertEquals ( url2, request. getUrl ( ) )
************************************
************************************
[+] input: Exception { final String internationalized = "\u0645\u0635\u0631"; final URL url = new URL("http://" + internationalized + ".com/" + internationalized); final WebRequest request = new WebRequest(url); final URL expected = new URL("http://xn--wgbh1c.com/" + internationalized); "<AssertPlaceHolder>"; }
getUrl() { return UrlUtils.toUrlSafe(url_); }
[*] target: assertEquals(expected, request.getUrl())
[-] pred: org. junit. Assert. assertEquals ( expected, request. getUrl ( ) )
************************************
************************************
[+] input: Exception { final WebRequest request = new WebRequest(new URL("http://localhost/test")); request.setHttpMethod(HttpMethod.POST); request.setEncodingType(FormEncodingType.MULTIPART);  final List<NameValuePair> requestParams = new ArrayList<>(); requestParams.add(new NameValuePair("test", null)); requestParams.add(new KeyDataPair("file", null, null, null, StandardCharsets.UTF_8)); request.setRequestParameters(requestParams);  final List<NameValuePair> expectedResults = new ArrayList<>(); expectedResults.add(new NameValuePair("test", "")); // the constructor of the KeyDataPair already creates normalized object // where the value is set to empty string if the passed file is null. expectedResults.add(new KeyDataPair("file", null, null, null, StandardCharsets.UTF_8));  final List<NameValuePair> normalizedParams = request.getParameters(); "<AssertPlaceHolder>";  // check that the value of the KeyDataPair is really normalized to empty string assertEquals("", normalizedParams.get(1).getValue()); }
getParameters() { // developer note: // this has to be in sync with // org.htmlunit.HttpWebConnection.makeHttpMethod(WebRequest, HttpClientBuilder)  if (HttpMethod.POST != getHttpMethod() && HttpMethod.PUT != getHttpMethod() && HttpMethod.PATCH != getHttpMethod()) {  if (!getRequestParameters().isEmpty()) { return normalize(getRequestParameters()); }  return normalize(HttpClientConverter.parseUrlQuery(getUrl().getQuery(), getCharset()));  }  if (getEncodingType() == FormEncodingType.URL_ENCODED && HttpMethod.POST == getHttpMethod()) { if (getRequestBody() == null) { return normalize(getRequestParameters()); }  return normalize(HttpClientConverter.parseUrlQuery(getRequestBody(), getCharset())); }  if (getEncodingType() == FormEncodingType.TEXT_PLAIN  && HttpMethod.POST == getHttpMethod()) { if (getRequestBody() == null) { return normalize(getRequestParameters()); }  return Collections.emptyList(); }  if (FormEncodingType.MULTIPART == getEncodingType()) { return normalize(getRequestParameters()); }  // for instance a PUT or PATCH request return Collections.emptyList(); }
[*] target: assertEquals(expectedResults, normalizedParams)
[-] pred: org. junit. Assert. assertEquals ( expectedResults, normalizedParams )
************************************
************************************
[+] input: Exception { final String html = "<html><head>\n" + "<style>\n" + "#d2:hover { display: none; }\n" + "#d3:hover { visibility: hidden; }\n" + "</style>\n" + "<div id='d1'>hello</div>\n" + "<div id='d2'>world</div>\n" + "<div id='d3'>again</div>\n" + "<div id='d4' style='display: none' >important</div>\n" + "</body></html>";  final HtmlPage page = loadPage(html); assertTrue(page.getElementById("d1").isDisplayed());  HtmlElement elem = page.getHtmlElementById("d2"); assertTrue(elem.isDisplayed()); elem.mouseOver(); assertFalse(elem.isDisplayed()); elem.mouseOut(); assertTrue(elem.isDisplayed());  elem = page.getHtmlElementById("d3"); assertTrue(elem.isDisplayed()); elem.mouseOver(); assertFalse(elem.isDisplayed()); elem.mouseOut(); "<AssertPlaceHolder>"; }
isDisplayed() { if (!mayBeDisplayed()) { return false; }  final Page page = getPage(); final WebWindow window = page.getEnclosingWindow(); final WebClient webClient = window.getWebClient(); if (webClient.getOptions().isCssEnabled()) { // display: iterate top to bottom, because if a parent is display:none, // there's nothing that a child can do to override it final List<Node> ancestors = getAncestors(); final ArrayList<ComputedCssStyleDeclaration> styles = new ArrayList<>(ancestors.size());  for (final Node node : ancestors) { if (node instanceof HtmlElement) { final HtmlElement elem = (HtmlElement) node; if (elem.isHidden()) { return false; }  if (elem instanceof HtmlDialog) { if (!((HtmlDialog) elem).isOpen()) { return false; } } else { final ComputedCssStyleDeclaration style = window.getComputedStyle(elem, null); if (DisplayStyle.NONE.value().equals(style.getDisplay())) { return false; } styles.add(style); } } }  // visibility: iterate bottom to top, because children can override // the visibility used by parent nodes for (int i = styles.size() - 1; i >= 0; i--) { final ComputedCssStyleDeclaration style = styles.get(i); final String visibility = style.getStyleAttribute(StyleAttributes.Definition.VISIBILITY, true); if (visibility.length() > 5) { if ("visible".equals(visibility)) { return true; } if ("hidden".equals(visibility) || "collapse".equals(visibility)) { return false; } } } } return true; }
[*] target: assertTrue(elem.isDisplayed())
[-] pred: org. junit. Assert. assertTrue ( elem. isDisplayed ( ) )
************************************
************************************
[+] input: Exception { final String html = "<html><head>\n" + "<style>\n" + "#d1:hover { display: none; }\n" + "#d2:hover { visibility: hidden; }\n" + "</style>\n" + "<div id='d1'><div id='d1-1'>hello</div></div>\n" + "<div id='d2'><div id='d2-1'>world</div></div>\n" + "</body></html>";  final HtmlPage page = loadPage(html); HtmlElement elem = page.getHtmlElementById("d1"); assertTrue(elem.isDisplayed()); page.getHtmlElementById("d1-1").mouseOver(); assertFalse(elem.isDisplayed()); page.getHtmlElementById("d1-1").mouseOut(); assertTrue(elem.isDisplayed());  elem = page.getHtmlElementById("d2"); assertTrue(elem.isDisplayed()); page.getHtmlElementById("d2-1").mouseOver(); assertFalse(elem.isDisplayed()); page.getHtmlElementById("d2-1").mouseOut(); "<AssertPlaceHolder>"; }
isDisplayed() { if (!mayBeDisplayed()) { return false; }  final Page page = getPage(); final WebWindow window = page.getEnclosingWindow(); final WebClient webClient = window.getWebClient(); if (webClient.getOptions().isCssEnabled()) { // display: iterate top to bottom, because if a parent is display:none, // there's nothing that a child can do to override it final List<Node> ancestors = getAncestors(); final ArrayList<ComputedCssStyleDeclaration> styles = new ArrayList<>(ancestors.size());  for (final Node node : ancestors) { if (node instanceof HtmlElement) { final HtmlElement elem = (HtmlElement) node; if (elem.isHidden()) { return false; }  if (elem instanceof HtmlDialog) { if (!((HtmlDialog) elem).isOpen()) { return false; } } else { final ComputedCssStyleDeclaration style = window.getComputedStyle(elem, null); if (DisplayStyle.NONE.value().equals(style.getDisplay())) { return false; } styles.add(style); } } }  // visibility: iterate bottom to top, because children can override // the visibility used by parent nodes for (int i = styles.size() - 1; i >= 0; i--) { final ComputedCssStyleDeclaration style = styles.get(i); final String visibility = style.getStyleAttribute(StyleAttributes.Definition.VISIBILITY, true); if (visibility.length() > 5) { if ("visible".equals(visibility)) { return true; } if ("hidden".equals(visibility) || "collapse".equals(visibility)) { return false; } } } } return true; }
[*] target: assertTrue(elem.isDisplayed())
[-] pred: org. junit. Assert. assertTrue ( elem. isDisplayed ( ) )
************************************
************************************
[+] input: Exception { final String html = "<html><head><title>foo</title><script>\n" + "  function test() {\n" + "    var div = document.getElementById('myDiv');\n" + "    div.appendChild(document.createElement('a'));\n" + "    var text = document.createTextNode('123456');\n" + "    div.appendChild(text);\n" + "    div.appendChild(document.createElement('hr'));\n" + "    alert(div.childNodes.length);\n" + "    text.splitText(3);\n" + "    alert(div.childNodes.length);\n" + "    alert(div.childNodes.item(2).nodeValue);\n" + "  }\n" + "</script></head><body onload='test()'>\n" + "  <div id='myDiv'></div>\n" + "</body></html>"; final String[] expectedAlerts = {"3", "4", "456"}; final List<String> collectedAlerts = new ArrayList<>(); loadPage(html, collectedAlerts); "<AssertPlaceHolder>"; }
splitText(final int offset) { if (offset < 0 || offset > getLength()) { throw new IllegalArgumentException("offset: " + offset + " data.length: " + getLength()); }  // split text into two separate nodes final DomText newText = createSplitTextNode(offset); setData(getData().substring(0, offset));  // insert new text node if (getParentNode() != null) { getParentNode().insertBefore(newText, getNextSibling()); } return newText; }
[*] target: assertEquals(expectedAlerts, collectedAlerts)
[-] pred: org. junit. Assert. assertEquals ( expectedAlerts, collectedAlerts )
************************************
************************************
[+] input: Exception { final String html = "<html><head><title>foo</title></head><body>\n" + "<form id='form1' method='post'>\n" + "  <input type='text' name='textfield' value='*'/>\n" + "  <input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(html); final MockWebConnection webConnection = getMockConnection(page);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSubmitInput button = form.getInputByName("button"); button.click();  final List<NameValuePair> expectedParameters = Arrays.asList(new NameValuePair[]{ new NameValuePair("textfield", "*"), new NameValuePair("button", "foo") }); final List<NameValuePair> collectedParameters = webConnection.getLastParameters();  "<AssertPlaceHolder>"; }
getInputByName(final String name) throws ElementNotFoundException { final List<HtmlInput> inputs = getInputsByName(name);  if (inputs.isEmpty()) { throw new ElementNotFoundException(HtmlInput.TAG_NAME, NAME_ATTRIBUTE, name); } return (I) inputs.get(0); }
[*] target: assertEquals(expectedParameters, collectedParameters)
[-] pred: org. junit. Assert. assertEquals ( expectedParameters, collectedParameters )
************************************
************************************
[+] input: Exception { final String html = "<html><head><title>Page A</title></head>\n" + "<body>\n" + "  <img id='myImg' usemap='#imgmap' style='display: none'" + " src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAA" + "HElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=='>\n" + "  <map id='myMap' name='imgmap'>\n" + "    <area id='myArea' shape='rect' coords='0,0,1,1'>\n" + "  </map>\n" + "</body></html>";  final WebDriver driver = loadPage2(html);  boolean displayed = driver.findElement(By.id("myImg")).isDisplayed(); assertFalse(displayed);  displayed = driver.findElement(By.id("myMap")).isDisplayed(); "<AssertPlaceHolder>"; }
isDisplayed() { final HtmlImage image = findReferencingImage(); if (null != image) { return image.isDisplayed(); } return false; }
[*] target: assertFalse(displayed)
[-] pred: org. junit. Assert. assertFalse ( displayed )
************************************
************************************
[+] input: Exception { final String html = "<html><head><title>Page A</title></head>\n" + "<body>\n" + "  <map id='myMap' name='imgmap' style='display: none'>\n" + "    <area id='myArea' shape='rect' coords='0,0,1,1'>\n" + "  </map>\n" + "</body></html>";  final WebDriver driver = loadPage2(html);  final boolean displayed = driver.findElement(By.id("myMap")).isDisplayed(); "<AssertPlaceHolder>"; }
isDisplayed() { final HtmlImage image = findReferencingImage(); if (null != image) { return image.isDisplayed(); } return false; }
[*] target: assertFalse(displayed)
[-] pred: org. junit. Assert. assertFalse ( displayed )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html><body>\n" + "  <form id='form1'>\n" + "    <select name='select1' id='select1'>\n" + "      <option id='option1'>Option1</option>\n" + "      <option id='option2' selected>Number Two</option>\n" + "    </select>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlOption option1 = page.getHtmlElementById("option1"); assertFalse(option1.isSelected()); option1.click(); assertTrue(option1.isSelected()); option1.click(); "<AssertPlaceHolder>"; }
isSelected() { return selected_; }
[*] target: assertTrue(option1.isSelected())
[-] pred: org. junit. Assert. assertTrue ( option1. isSelected() )
************************************
************************************
[+] input: Exception { final String html = "<html><body>" + "  <select multiple><option value='a'>a</option><option value='b'>b</option></select>\n" + "</body></html>";  final HtmlPage page = loadPage(html); final HtmlSelect select = (HtmlSelect) page.getElementsByTagName("select").get(0); assertTrue(select.isMultipleSelectEnabled());  final List<HtmlOption> options = select.getOptions(); for (final HtmlOption option : options) { option.setSelected(true); }  for (final HtmlOption option : options) { "<AssertPlaceHolder>"; } }
isSelected() { return selected_; }
[*] target: assertTrue(option.isSelected())
[-] pred: org. junit. Assert. assertTrue ( option. isSelected() )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html>\n" + "<head><title>foo</title></head>\n" + "<body>\n" + "<form><p>hello world</p>\n" + "<input name='foo' type='submit' disabled='disabled' id='foo'/>\n" + "<input name='bar' type='submit' id='bar'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final List<HtmlElement> expectedElements = new ArrayList<>(); expectedElements.add(page.getHtmlElementById("bar"));  "<AssertPlaceHolder>"; }
getTabbableElements() { final List<HtmlElement> tabbableElements = new ArrayList<>(); for (final HtmlElement element : getHtmlElementDescendants()) { final String tagName = element.getTagName(); if (TABBABLE_TAGS.contains(tagName)) { final boolean disabled = element.hasAttribute(ATTRIBUTE_DISABLED); if (!disabled && !HtmlElement.TAB_INDEX_OUT_OF_BOUNDS.equals(element.getTabIndex())) { tabbableElements.add(element); } } } tabbableElements.sort(createTabOrderComparator()); return Collections.unmodifiableList(tabbableElements); }
[*] target: assertEquals(expectedElements, page.getTabbableElements())
[-] pred: org. junit. Assert. assertEquals ( expectedElements, page. getTabbableElements ( ) )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html>\n" + "<head><title>foo</title></head><body>\n" + "<a id='a' accesskey='a'>foo</a>\n" + "<a id='b' accesskey='a'>foo</a>\n" + "<form>\n" + "<a id='c' accesskey='c'>foo</a>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final List<HtmlElement> expectedElements = Arrays.asList(new HtmlElement[] {page.getHtmlElementById("a"), page.getHtmlElementById("b")}); final List<HtmlElement> collectedElements = page.getHtmlElementsByAccessKey('a'); "<AssertPlaceHolder>"; }
getHtmlElementsByAccessKey(final char accessKey) { final List<HtmlElement> elements = new ArrayList<>();  final String searchString = Character.toString(accessKey).toLowerCase(Locale.ROOT); for (final HtmlElement element : getHtmlElementDescendants()) { if (ACCEPTABLE_TAG_NAMES.contains(element.getTagName())) { final String accessKeyAttribute = element.getAttributeDirect("accesskey"); if (searchString.equalsIgnoreCase(accessKeyAttribute)) { elements.add(element); } } }  return elements; }
[*] target: assertEquals(expectedElements, collectedElements)
[-] pred: org. junit. Assert. assertEquals ( expectedElements, collectedElements )
************************************
************************************
[+] input: Exception { final String html = "<html>\n" + "<head>\n" + "<base href='" + URL_SECOND + "'>\n" + "<base href='" + URL_THIRD + "'>\n" + "</head>\n" + "<body>\n" + "  <a href='somepage.html'>\n" + "</body></html>";  final WebClient webClient = getWebClient(); final List<String> collectedIncorrectness = new ArrayList<>(); final IncorrectnessListener listener = new IncorrectnessListener() { @Override public void notify(final String message, final Object origin) { collectedIncorrectness.add(message); } }; webClient.setIncorrectnessListener(listener);  final MockWebConnection webConnection = new MockWebConnection(); webClient.setWebConnection(webConnection); webConnection.setDefaultResponse(html); final HtmlPage page = webClient.getPage(URL_FIRST); page.getAnchors().get(0).click();  final String[] expectedIncorrectness = {"Multiple 'base' detected, only the first is used.", "Multiple 'base' detected, only the first is used."}; "<AssertPlaceHolder>"; }
getAnchors() { return getDocumentElement().getElementsByTagNameImpl("a"); }
[*] target: assertEquals(expectedIncorrectness, collectedIncorrectness)
[-] pred: org. junit. Assert. assertEquals ( expectedIncorrectness, collectedIncorrectness )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1' multiple>\n" + "<option value='option1' selected='selected'>Option1</option>\n" + "<option value='option2'>Option2</option>\n" + "<option value='option3' selected='selected'>Option3</option>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSelect select = form.getSelectsByName("select1").get(0); final List<HtmlOption> expected = new ArrayList<>(); expected.add(select.getOptionByValue("option1")); expected.add(select.getOptionByValue("option3"));  "<AssertPlaceHolder>"; }
getSelectedOptions() { final List<HtmlOption> result; if (isMultipleSelectEnabled()) { // Multiple selections possible. result = new ArrayList<>(); for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption && ((HtmlOption) element).isSelected()) { result.add((HtmlOption) element); } } } else { // Only a single selection is possible. result = new ArrayList<>(1); HtmlOption lastSelected = null; for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption) { final HtmlOption option = (HtmlOption) element; if (option.isSelected()) { lastSelected = option; } } } if (lastSelected != null) { result.add(lastSelected); } } return Collections.unmodifiableList(result); }
[*] target: assertEquals(expected, select.getSelectedOptions())
[-] pred: org. junit. Assert. assertEquals ( expected, select. getSelectedOptions ( ) )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1'>\n" + "<option value='option1' selected='selected'>Option1</option>\n" + "<option value='option2'>Option2</option>\n" + "<option value='option3' selected='selected'>Option3</option>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSelect select = form.getSelectsByName("select1").get(0); final List<HtmlOption> expected = new ArrayList<>(); expected.add(select.getOptionByValue("option3"));  "<AssertPlaceHolder>"; }
getSelectedOptions() { final List<HtmlOption> result; if (isMultipleSelectEnabled()) { // Multiple selections possible. result = new ArrayList<>(); for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption && ((HtmlOption) element).isSelected()) { result.add((HtmlOption) element); } } } else { // Only a single selection is possible. result = new ArrayList<>(1); HtmlOption lastSelected = null; for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption) { final HtmlOption option = (HtmlOption) element; if (option.isSelected()) { lastSelected = option; } } } if (lastSelected != null) { result.add(lastSelected); } } return Collections.unmodifiableList(result); }
[*] target: assertEquals(expected, select.getSelectedOptions())
[-] pred: org. junit. Assert. assertEquals ( expected, select. getSelectedOptions ( ) )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1'>\n" + "<option value='option1'>Option1</option>\n" + "<option value='option2'>Option2</option>\n" + "<option value='option3'>Option3</option>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSelect select = form.getSelectsByName("select1").get(0); final List<HtmlOption> expected = new ArrayList<>(); expected.add(select.getOptionByValue("option1"));  "<AssertPlaceHolder>"; }
getSelectedOptions() { final List<HtmlOption> result; if (isMultipleSelectEnabled()) { // Multiple selections possible. result = new ArrayList<>(); for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption && ((HtmlOption) element).isSelected()) { result.add((HtmlOption) element); } } } else { // Only a single selection is possible. result = new ArrayList<>(1); HtmlOption lastSelected = null; for (final HtmlElement element : getHtmlElementDescendants()) { if (element instanceof HtmlOption) { final HtmlOption option = (HtmlOption) element; if (option.isSelected()) { lastSelected = option; } } } if (lastSelected != null) { result.add(lastSelected); } } return Collections.unmodifiableList(result); }
[*] target: assertEquals(expected, select.getSelectedOptions())
[-] pred: org. junit. Assert. assertEquals ( expected, select. getSelectedOptions ( ) )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1'>\n" + "<option value='option1' selected='selected'>Option1</option>\n" + "<option value='option2'>Option2</option>\n" + "<optgroup label='group1'>\n" + "  <option value='option3'>Option3</option>\n" + "</optgroup>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSelect select = form.getSelectsByName("select1").get(0);  final List<HtmlOption> expectedOptions = new ArrayList<>(); expectedOptions.add(select.getOptionByValue("option1")); expectedOptions.add(select.getOptionByValue("option2")); expectedOptions.add(select.getOptionByValue("option3"));  "<AssertPlaceHolder>"; }
getOptions() { return Collections.unmodifiableList(this.getElementsByTagNameImpl("option")); }
[*] target: assertEquals(expectedOptions, select.getOptions())
[-] pred: org. junit. Assert. assertEquals ( expectedOptions, select. getOptions ( ) )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1' id='select1' multiple>\n" + "<option value='option1'>Option1</option>\n" + "<option value='option2' >Option2</option>\n" + "<option value='option3'>Option3</option>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlSelect select = page.getHtmlElementById("select1"); "<AssertPlaceHolder>"; }
isMultipleSelectEnabled() { return getAttributeDirect("multiple") != ATTRIBUTE_NOT_DEFINED; }
[*] target: assertTrue(select.isMultipleSelectEnabled())
[-] pred: org. junit. Assert. assertTrue ( select. isMultipleSelectEnabled ( ) )
************************************
************************************
[+] input: performanceManyReplaces() { final String expected = StringUtils.repeat("x\n", 100_000).trim();  final long time = System.currentTimeMillis();  final HtmlSerializerTextBuilder serializer = new HtmlSerializerNormalizedText.HtmlSerializerTextBuilder();  for (int i = 0; i < 100_000; i++) { serializer.append(" x ", Mode.NORMALIZE); serializer.appendBlockSeparator(); }  "<AssertPlaceHolder>";  final long runTime = System.currentTimeMillis() - time; assertTrue("cleanUp() took too much time", runTime < 200); }
getText() { return builder_.substring(0, trimRightPos_); }
[*] target: assertEquals(expected, serializer.getText())
[-] pred: org. junit. Assert. assertEquals ( expected, serializer. getText ( ) )
************************************
************************************
[+] input: performanceManyReplaces() { final String expected = StringUtils.repeat("x\n", 100_000).trim();  final long time = System.currentTimeMillis();  final HtmlSerializerTextBuilder serializer = new HtmlSerializerVisibleText.HtmlSerializerTextBuilder();  for (int i = 0; i < 100_000; i++) { serializer.append(" x ", Mode.WHITE_SPACE_NORMAL); serializer.appendBlockSeparator(); }  "<AssertPlaceHolder>";  final long runTime = System.currentTimeMillis() - time; assertTrue("cleanUp() took too much time", runTime < 200); }
getText() { return builder_.substring(0, trimRightPos_); }
[*] target: assertEquals(expected, serializer.getText())
[-] pred: org. junit. Assert. assertEquals ( expected, serializer. getText ( ) )
************************************
************************************
[+] input: Exception { final String firstContent = "<html><head>\n" + "<script>\n" + "var foo = 'foo';\n" + "var test = new Function('alert(foo);');\n" + "</script>\n" + "</head>\n" + "<body onload='test()'>\n" + "  <iframe src='page2.html'/>\n" + "</body>\n" + "</html>";  final String secondContent = "<html><head><script>\n" + "var foo = 'foo2';\n" + "parent.test();\n" + "var f = parent.test;\n" + "f();\n" + "</script></head></html>";  final WebClient client = getWebClient(); final MockWebConnection webConnection = new MockWebConnection(); webConnection.setDefaultResponse(secondContent); webConnection.setResponse(URL_FIRST, firstContent); client.setWebConnection(webConnection);  final String[] expectedAlerts = {"foo", "foo", "foo"};  final List<String> collectedAlerts = new ArrayList<>(); client.setAlertHandler(new CollectingAlertHandler(collectedAlerts)); client.getPage(URL_FIRST);  "<AssertPlaceHolder>"; }
getWebClient() { return webClient_; }
[*] target: assertEquals(expectedAlerts, collectedAlerts)
[-] pred: org. junit. Assert. assertEquals ( expectedAlerts, collectedAlerts )
************************************
************************************
[+] input: noGlobalContextFactoryUsed() { final WebClient client1 = getWebClient(); final WebClient client2 = createNewWebClient();  final HtmlUnitContextFactory cf1 = ((JavaScriptEngine) client1.getJavaScriptEngine()).getContextFactory(); final HtmlUnitContextFactory cf2 = ((JavaScriptEngine) client2.getJavaScriptEngine()).getContextFactory();  "<AssertPlaceHolder>"; assertFalse(cf1 == ContextFactory.getGlobal()); assertFalse(cf2 == ContextFactory.getGlobal()); }
getContextFactory() { return contextFactory_; }
[*] target: assertFalse(cf1 == cf2)
[-] pred: org. junit. Assert. assertFalse ( cf1 == cf2 )
************************************
************************************
[+] input: Exception { final Cookie cookie1 = new Cookie("localhost", "a", "one"); final Cookie cookie2 = new Cookie("localhost", "a", "one", null, null, false); final Cookie cookie3 = new Cookie("localhost", "a", "one", "/", null, false); assertEquals(cookie1, cookie2); assertEquals(cookie2, cookie3); assertEquals(cookie1.hashCode(), cookie2.hashCode()); "<AssertPlaceHolder>"; }
hashCode() { final String path = getPath() == null ? "/" : getPath(); return new HashCodeBuilder() .append(getName()) .append(getDomain()) .append(path) .toHashCode(); }
[*] target: assertEquals(cookie2.hashCode(), cookie3.hashCode())
[-] pred: org. junit. Assert. assertEquals ( cookie2. hashCode ( ), cookie3. hashCode ( ) )
************************************
************************************
[+] input: containsKey_True_content_based() { // same hash and different content final OrderedFastHashMap<MockKey<String>, String> m = new OrderedFastHashMap<>(); final MockKey<String> mockKey1 = new MockKey<>(10, "akey1"); m.put(mockKey1, "any1"); m.put(new MockKey<>(10, "akey2"), "any2"); m.put(new MockKey<>(10, "akey3"), "any3"); m.put(new MockKey<>(10, "akey4"), "any4"); "<AssertPlaceHolder>"; assertTrue(m.containsKey(new MockKey<>(10, "akey1"))); }
containsKey(final Object key) { return get(key) != null; }
[*] target: assertTrue(m.containsKey(mockKey1))
[-] pred: org. junit. Assert. assertTrue ( m. containsKey ( mockKey1 ) )
************************************
************************************
[+] input: testParseJSONtoHdbtiSuccessfullyWithFileNameWithoutPath() { XSKHDBTIImportConfigModel model = new XSKHDBTIImportConfigModel(); model.setDelimEnclosing("'"); model.setSchemaName("schema"); model.setHeader(true); model.setTableName("table"); model.setFileName("myData2.csv");  String expectedValue = "import = [\n" + "{\n" + "\tdelimEnclosing="'";\n" + "\tschema = "schema";\n" + "\theader = true;\n" + "\ttable = "table";\n" + "\tfile = "myData2.csv";\n" + "}];";  String actualResult = processor.parseJSONtoHdbti(new ArrayList<>(Arrays.asList(model))); "<AssertPlaceHolder>"; }
parseJSONtoHdbti(ArrayList<XSKHDBTIImportConfigModel> json) { for (XSKHDBTIImportConfigModel el : json) { try { el.setFileName(XSKHDBTIUtils.convertPathToHDBTIFileProperty(el.getFileName())); } catch (IllegalArgumentException ex) { XSKCommonsUtils.logProcessorErrors(ex.getMessage(), XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw ex; } if (!el.getTableName().contains("::") && el.getSchemaName() == null) { String errMsg = "Missing schema property"; XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (el.getSchemaName() != null && !XSKHDBTIUtils.isCorrectPropertySyntax(el.getSchemaName())) { String errMsg = "Schema property contains unsupported symbols: " + el.getSchemaName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (!XSKHDBTIUtils.isCorrectTablePropertySyntax(el.getTableName())) { String errMsg = "Table property contains unsupported symbols: " + el.getTableName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } for (Pair key : el.getKeys()) { if (!XSKHDBTIUtils.isCorrectPropertySyntax(key.getColumn())) { String errMsg = "key column property contains unsupported symbols: " + key.getColumn(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } } }  XSKHDBTIImportModel model = new XSKHDBTIImportModel(); model.setConfigModels(json); return model.toString(); }
[*] target: assertEquals(expectedValue, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualResult )
************************************
************************************
[+] input: testParseJSONtoHdbtiSuccessfullyWithDoubleColonTableName() { XSKHDBTIImportConfigModel model = new XSKHDBTIImportConfigModel();  model.setDelimEnclosing("'"); model.setSchemaName("schema"); model.setHeader(true); model.setTableName("sap_xsk.test::c_users"); model.setFileName("myData2.csv");  String actualValue = processor.parseJSONtoHdbti(new ArrayList<>(Arrays.asList(model)));  String expectedValue = "import = [\n" + "{\n" + "\tdelimEnclosing="'";\n" + "\tschema = "schema";\n" + "\theader = true;\n" + "\ttable = "sap_xsk.test::c_users";\n" + "\tfile = "myData2.csv";\n" + "}];";  "<AssertPlaceHolder>"; }
parseJSONtoHdbti(ArrayList<XSKHDBTIImportConfigModel> json) { for (XSKHDBTIImportConfigModel el : json) { try { el.setFileName(XSKHDBTIUtils.convertPathToHDBTIFileProperty(el.getFileName())); } catch (IllegalArgumentException ex) { XSKCommonsUtils.logProcessorErrors(ex.getMessage(), XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw ex; } if (!el.getTableName().contains("::") && el.getSchemaName() == null) { String errMsg = "Missing schema property"; XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (el.getSchemaName() != null && !XSKHDBTIUtils.isCorrectPropertySyntax(el.getSchemaName())) { String errMsg = "Schema property contains unsupported symbols: " + el.getSchemaName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (!XSKHDBTIUtils.isCorrectTablePropertySyntax(el.getTableName())) { String errMsg = "Table property contains unsupported symbols: " + el.getTableName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } for (Pair key : el.getKeys()) { if (!XSKHDBTIUtils.isCorrectPropertySyntax(key.getColumn())) { String errMsg = "key column property contains unsupported symbols: " + key.getColumn(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } } }  XSKHDBTIImportModel model = new XSKHDBTIImportModel(); model.setConfigModels(json); return model.toString(); }
[*] target: assertEquals(expectedValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualValue )
************************************
************************************
[+] input: testParseJSONtoHdbtiSuccessfullyWithMissingSchemaName() { XSKHDBTIImportConfigModel model = new XSKHDBTIImportConfigModel();  model.setDelimEnclosing("'"); model.setHeader(true); model.setTableName("sap_xsk.test::c_users"); model.setFileName("myData2.csv");  String actualValue = processor.parseJSONtoHdbti(new ArrayList<>(Arrays.asList(model)));  String expectedValue = "import = [\n" + "{\n" + "\tdelimEnclosing="'";\n" + "\theader = true;\n" + "\ttable = "sap_xsk.test::c_users";\n" + "\tfile = "myData2.csv";\n" + "}];";  "<AssertPlaceHolder>"; }
parseJSONtoHdbti(ArrayList<XSKHDBTIImportConfigModel> json) { for (XSKHDBTIImportConfigModel el : json) { try { el.setFileName(XSKHDBTIUtils.convertPathToHDBTIFileProperty(el.getFileName())); } catch (IllegalArgumentException ex) { XSKCommonsUtils.logProcessorErrors(ex.getMessage(), XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw ex; } if (!el.getTableName().contains("::") && el.getSchemaName() == null) { String errMsg = "Missing schema property"; XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (el.getSchemaName() != null && !XSKHDBTIUtils.isCorrectPropertySyntax(el.getSchemaName())) { String errMsg = "Schema property contains unsupported symbols: " + el.getSchemaName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (!XSKHDBTIUtils.isCorrectTablePropertySyntax(el.getTableName())) { String errMsg = "Table property contains unsupported symbols: " + el.getTableName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } for (Pair key : el.getKeys()) { if (!XSKHDBTIUtils.isCorrectPropertySyntax(key.getColumn())) { String errMsg = "key column property contains unsupported symbols: " + key.getColumn(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } } }  XSKHDBTIImportModel model = new XSKHDBTIImportModel(); model.setConfigModels(json); return model.toString(); }
[*] target: assertEquals(expectedValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualValue )
************************************
************************************
[+] input: getLoggerTest() { XSKJavascriptEngineRestService restService = new XSKJavascriptEngineRestService(); "<AssertPlaceHolder>"; }
getLogger() { return logger; }
[*] target: assertNotNull(restService.getLogger())
[-] pred: org. junit. Assert. assertNotNull ( restService. getLogger() )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/multipleTableDeclarations.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/duplicateKeys.hdbti", hdbtiSample); } catch (DuplicateFieldNameException duplicateFieldNameException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/invalidSyntax.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/invalidSyntax.hdbti", hdbtiSample); } catch (XSKArtifactParserException parseErrorException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/invalidTablePropertySyntax.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/invalidTablePropertySyntax.hdbti", hdbtiSample); } catch (TablePropertySyntaxException parseErrorException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/duplicateKeys.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/duplicateKeys.hdbti", hdbtiSample); } catch (DuplicateFieldNameException duplicateFieldNameException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/empty_service.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertNull(model.getNamespace()); assertEquals(model.getEntities().size(), 0); assertFalse(model.isEnableOData4SAPAnnotations()); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/empty_service_with_namespace.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertEquals(model.getNamespace(), "my.demo.namespace"); assertEquals(model.getEntities().size(), 0); assertFalse(model.isEnableOData4SAPAnnotations()); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/empty_service_with_annotations.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertNull(model.getNamespace()); assertEquals(model.getEntities().size(), 0); assertTrue(model.isEnableOData4SAPAnnotations()); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/empty_service_with_settings.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertNull(model.getNamespace()); assertEquals(model.getEntities().size(), 0); assertEquals(model.getAssociations().size(), 0); assertNotNull(model.getSetting()); XSKHDBXSODATASetting actualSetting = new XSKHDBXSODATASetting(); actualSetting.setEnableSupportNull(true); actualSetting.setMaxExpandedRecords("30"); actualSetting.setMaxRecords("10"); actualSetting.setContentCacheControl(Collections.singletonList("no-store")); actualSetting.setMetadataCacheControl(Arrays.asList("no-cache", "no-store", "max-age=86401", "must-revalidate")); actualSetting.setHints(Arrays.asList("NO_CALC_VIEW_UNFOLDING", "ABC")); assertEquals(model.getSetting(), actualSetting); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/empty_service_without_hints.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertNull(model.getNamespace()); assertEquals(model.getEntities().size(), 0); assertEquals(model.getAssociations().size(), 0); assertNotNull(model.getSetting()); XSKHDBXSODATASetting actualSetting = new XSKHDBXSODATASetting(); actualSetting.setHints(Collections.singletonList("null")); assertEquals(model.getSetting(), actualSetting); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/entity_with_events.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertEquals(model.getEntities().size(), 4);  XSKHDBXSODATAEntity actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sample.odata::table")); XSKHDBXSODATAModification updateModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.UPDATE); updateModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Arrays.asList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.BEFORE, "sample.odata::beforeMethod"), new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.PRECOMMIT, "sample.odata::beforeMethod")))); XSKHDBXSODATAModification deleteModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.DELETE); deleteModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.AFTER, "sample.odata::afterMethod")))); XSKHDBXSODATAModification createModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.CREATE); createModification.setSpecification(new XSKHDBXSODATAModificationSpec().setForbidden(true)); actualEntity.setModifications(Arrays.asList(updateModification, deleteModification, createModification)); assertEquals(model.getEntities().get(0), actualEntity);  actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sample.odata::table")); createModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.CREATE); createModification.setSpecification(new XSKHDBXSODATAModificationSpec().setModificationAction("sample.odata::createMethod").setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.AFTER, "sample.odata::afterMethod")))); updateModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.UPDATE); updateModification.setSpecification(new XSKHDBXSODATAModificationSpec().setModificationAction("sample.odata::updateMethod")); deleteModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.DELETE); deleteModification.setSpecification(new XSKHDBXSODATAModificationSpec().setModificationAction("sample.odata::deleteMethod")); actualEntity.setModifications(Arrays.asList(createModification, updateModification, deleteModification)); assertEquals(model.getEntities().get(1), actualEntity);  actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sample.odata::table")); createModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.CREATE); createModification.setSpecification(new XSKHDBXSODATAModificationSpec().setModificationAction("sample.odata::createMethod")); updateModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.UPDATE); updateModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.PRECOMMIT, "sample.odata::precommitMethod")))); deleteModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.DELETE).setSpecification(new XSKHDBXSODATAModificationSpec().setForbidden(true)); actualEntity.setModifications(Arrays.asList(createModification, updateModification, deleteModification)); assertEquals(model.getEntities().get(2), actualEntity);  actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sample.odata::table")); createModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.CREATE).setSpecification(new XSKHDBXSODATAModificationSpec().setForbidden(true)); updateModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.UPDATE).setSpecification(new XSKHDBXSODATAModificationSpec().setForbidden(true)); deleteModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.DELETE).setSpecification(new XSKHDBXSODATAModificationSpec().setForbidden(true)); actualEntity.setModifications(Arrays.asList(createModification, updateModification, deleteModification)); assertEquals(model.getEntities().get(3), actualEntity); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/entity_with_associations.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertEquals(model.getAssociations().size(), 6);  XSKHDBXSODATAAssociation actualAssociation = new XSKHDBXSODATAAssociation(); actualAssociation.setName("complex_atob"); actualAssociation.setWithReferentialConstraint(false); XSKHDBXSODATABinding principal = new XSKHDBXSODATABinding(); principal.setEntitySetName("complex_a"); principal.setBindingRole(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.PRINCIPAL).setKeys(Collections.singletonList("ID"))); principal.setMultiplicityType(XSKHDBXSODATAMultiplicityType.MANY); actualAssociation.setPrincipal(principal); XSKHDBXSODATABinding dependent = new XSKHDBXSODATABinding(); dependent.setEntitySetName("complex_b"); dependent.setBindingRole(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.DEPENDENT).setKeys(Collections.singletonList("ID_A"))); dependent.setMultiplicityType(XSKHDBXSODATAMultiplicityType.MANY); actualAssociation.setDependent(dependent); XSKHDBXSODATAAssociationTable table = new XSKHDBXSODATAAssociationTable(); table.setRepositoryObject("xsodata.test.tables::complex_assoc_atob"); table.setPrincipal(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.PRINCIPAL).setKeys(Collections.singletonList("ID_A"))); table.setDependent(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.DEPENDENT).setKeys(Collections.singletonList("ID_B"))); actualAssociation.setAssociationTable(table); assertEquals(model.getAssociations().get(0), actualAssociation);   XSKHDBXSODATAModification updateModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.UPDATE); updateModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.BEFORE, "sample.odata::updateMethod")))); XSKHDBXSODATAModification deleteModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.DELETE); deleteModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.BEFORE, "sample.odata::deleteMethod")))); XSKHDBXSODATAModification createModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.CREATE); createModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.BEFORE, "sample.odata::createMethod")))); table.setModifications(Arrays.asList(deleteModification, createModification, updateModification)); actualAssociation.setAssociationTable(table); assertEquals(model.getAssociations().get(1), actualAssociation);  actualAssociation = new XSKHDBXSODATAAssociation(); actualAssociation.setName("complex_b_to_c"); actualAssociation.setWithReferentialConstraint(false); principal = new XSKHDBXSODATABinding(); principal.setEntitySetName("complex_b"); principal.setBindingRole(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.PRINCIPAL).setKeys(Collections.singletonList("ID"))); principal.setMultiplicityType(XSKHDBXSODATAMultiplicityType.ONE); actualAssociation.setPrincipal(principal); dependent = new XSKHDBXSODATABinding(); dependent.setEntitySetName("complex_c"); dependent.setBindingRole(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.DEPENDENT).setKeys(Collections.singletonList("ID_A"))); dependent.setMultiplicityType(XSKHDBXSODATAMultiplicityType.MANY); actualAssociation.setDependent(dependent); updateModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.UPDATE).setSpecification(new XSKHDBXSODATAModificationSpec().setModificationAction("sap.test:oDataExtendedRules.xsjslib::associationToConditions")); table.setModifications(Arrays.asList(deleteModification, createModification, updateModification)); actualAssociation.setStorage(new XSKHDBXSODATAStorage().setStorageType(XSKHDBXSODATAStorageType.STORAGE_ON_DEPENDENT).setModifications(Collections.singletonList(updateModification))); assertEquals(model.getAssociations().get(2), actualAssociation);  actualAssociation = new XSKHDBXSODATAAssociation(); actualAssociation.setName("complex_b_to_c"); actualAssociation.setWithReferentialConstraint(false); principal = new XSKHDBXSODATABinding(); principal.setEntitySetName("complex_b"); principal.setBindingRole(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.PRINCIPAL).setKeys(Collections.singletonList("ID"))); principal.setMultiplicityType(XSKHDBXSODATAMultiplicityType.ZERO_TO_ONE); actualAssociation.setPrincipal(principal); dependent = new XSKHDBXSODATABinding(); dependent.setEntitySetName("complex_c"); dependent.setBindingRole(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.DEPENDENT).setKeys(Collections.singletonList("ID_B"))); dependent.setMultiplicityType(XSKHDBXSODATAMultiplicityType.ONE); actualAssociation.setDependent(dependent); actualAssociation.setStorage(new XSKHDBXSODATAStorage().setStorageType(XSKHDBXSODATAStorageType.STORAGE_ON_PRINCIPAL)); assertEquals(model.getAssociations().get(3), actualAssociation);  actualAssociation = new XSKHDBXSODATAAssociation(); actualAssociation.setName("complex_b_to_c"); actualAssociation.setWithReferentialConstraint(false); principal = new XSKHDBXSODATABinding(); principal.setEntitySetName("complex_b"); principal.setBindingRole(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.PRINCIPAL).setKeys(Collections.singletonList("ID"))); principal.setMultiplicityType(XSKHDBXSODATAMultiplicityType.ONE_TO_MANY); actualAssociation.setPrincipal(principal); dependent = new XSKHDBXSODATABinding(); dependent.setEntitySetName("complex_c"); dependent.setBindingRole(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.DEPENDENT).setKeys(Collections.singletonList("ID_B"))); dependent.setMultiplicityType(XSKHDBXSODATAMultiplicityType.MANY); actualAssociation.setDependent(dependent); actualAssociation.setStorage(new XSKHDBXSODATAStorage().setStorageType(XSKHDBXSODATAStorageType.NO_STORAGE)); assertEquals(model.getAssociations().get(4), actualAssociation);  actualAssociation = new XSKHDBXSODATAAssociation(); actualAssociation.setName("complex_b_to_c"); actualAssociation.setWithReferentialConstraint(true); principal = new XSKHDBXSODATABinding(); principal.setEntitySetName("complex_b"); principal.setBindingRole(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.PRINCIPAL).setKeys(Collections.singletonList("ID"))); principal.setMultiplicityType(XSKHDBXSODATAMultiplicityType.ONE); actualAssociation.setPrincipal(principal); dependent = new XSKHDBXSODATABinding(); dependent.setEntitySetName("complex_c"); dependent.setBindingRole(new XSKHDBXSODATABindingRole().setBindingType(XSKHDBXSODATABindingType.DEPENDENT).setKeys(Collections.singletonList("ID_B"))); dependent.setMultiplicityType(XSKHDBXSODATAMultiplicityType.MANY); actualAssociation.setDependent(dependent); updateModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.UPDATE); updateModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.BEFORE, "sample.odata::updateMethod")))); deleteModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.DELETE); deleteModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.BEFORE, "sample.odata::deleteMethod")))); createModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.CREATE); createModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.BEFORE, "sample.odata::createMethod")))); actualAssociation.setModifications(Arrays.asList(deleteModification, createModification, updateModification)); assertEquals(model.getAssociations().get(5), actualAssociation); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/empty_service_with_etag.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertEquals(model.getEntities().size(), 4);  XSKHDBXSODATAEntity actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("xsodata.test.tables::all_types")); actualEntity.setAlias("all_types_etag"); actualEntity.setConcurrencyToken(true); assertEquals(model.getEntities().get(0), actualEntity);  actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("xsodata.test.tables::BusinessPartner.BusinessPartner")); actualEntity.setAlias("BusinessPartner"); actualEntity.setConcurrencyToken(true); actualEntity.setWithoutPropertyProjections(Collections.singletonList("isContactPerson")); XSKHDBXSODATANavigation nav1 = new XSKHDBXSODATANavigation().setAssociation("BusinessPartner_To_N_BPRole").setAliasNavigation("Roles"); actualEntity.setNavigates(Collections.singletonList(nav1)); assertEquals(model.getEntities().get(1), actualEntity);  actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sap.test.odata.db.views::Etag")); actualEntity.setAlias("EtagAll"); actualEntity.setConcurrencyToken(true); actualEntity.setKeyList(Arrays.asList("KEY_00", "KEY_01")); assertEquals(model.getEntities().get(2), actualEntity);  actualEntity.setETags(Arrays.asList("NVARCHAR_01", "INTEGER_02")); assertEquals(model.getEntities().get(3), actualEntity); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/entity_with_no_associations.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertEquals(model.getEntities().size(), 20); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken); // Act final ReturnT<String> retval = executorBiz.beat();  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(200, retval.getCode()); Assert.assertNull(retval.getMsg()); }
beat();
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: idleBeat() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.idleBeat(new IdleBeatParam(jobId));  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(500, retval.getCode()); Assert.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(IdleBeatParam idleBeatParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: run() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  // trigger data final TriggerParam triggerParam = new TriggerParam(); triggerParam.setJobId(1); triggerParam.setExecutorHandler("demoJobHandler"); triggerParam.setExecutorParams(null); triggerParam.setExecutorBlockStrategy(ExecutorBlockStrategyEnum.COVER_EARLY.name()); triggerParam.setGlueType(GlueTypeEnum.BEAN.name()); triggerParam.setGlueSource(null); triggerParam.setGlueUpdatetime(System.currentTimeMillis()); triggerParam.setLogId(1); triggerParam.setLogDateTime(System.currentTimeMillis());  // Act final ReturnT<String> retval = executorBiz.run(triggerParam);  // Assert result Assert."<AssertPlaceHolder>"; }
run(TriggerParam triggerParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: kill() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.kill(new KillParam(jobId));  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(200, retval.getCode()); Assert.assertNull(retval.getMsg()); }
kill(KillParam killParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: idleBeat() { final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.idleBeat(jobId);  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(500, retval.getCode()); Assert.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(int jobId) {  // isRunningOrHasQueue boolean isRunningOrHasQueue = false; JobThread jobThread = XxlJobExecutor.loadJobThread(jobId); if (jobThread != null && jobThread.isRunningOrHasQueue()) { isRunningOrHasQueue = true; }  if (isRunningOrHasQueue) { return new ReturnT<String>(ReturnT.FAIL_CODE, "job thread is running or has trigger queue."); } return ReturnT.SUCCESS; }
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: kill() { final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.kill(jobId);  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(200, retval.getCode()); Assert.assertNull(retval.getMsg()); }
kill(int jobId) { // kill handlerThread, and create new one JobThread jobThread = XxlJobExecutor.loadJobThread(jobId); if (jobThread != null) { XxlJobExecutor.removeJobThread(jobId, "scheduling center kill job."); return ReturnT.SUCCESS; }  return new ReturnT<String>(ReturnT.SUCCESS_CODE, "job thread aleady killed."); }
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: log() { final long logDateTim = 0L; final long logId = 0; final int fromLineNum = 0;  // Act final ReturnT<LogResult> retval = executorBiz.log(logDateTim, logId, fromLineNum);  // Assert result Assert."<AssertPlaceHolder>"; }
log(long logDateTim, long logId, int fromLineNum) { // log filename: logPath/yyyy-MM-dd/9999.log String logFileName = XxlJobFileAppender.makeLogFileName(new Date(logDateTim), logId);  LogResult logResult = XxlJobFileAppender.readLog(logFileName, fromLineNum); return new ReturnT<LogResult>(logResult); }
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: testIsEmpty() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); assertTrue(map.isEmpty()); map.put("key1", "value1"); "<AssertPlaceHolder>"; }
isEmpty() { return size.get() == 0; }
[*] target: assertFalse(map.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( map. isEmpty() )
************************************
************************************
[+] input: testClear() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); map.put("key1", "value1"); map.put("key2", "value2"); map.clear(); assertTrue(map.isEmpty()); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size ( ) )
************************************
************************************
[+] input: testPut() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); assertNull(map.put("key1", "value1")); assertEquals("value1", map.get("key1")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, map.size())
[-] pred: org. junit. Assert. assertEquals ( 1, map. size() )
************************************
************************************
[+] input: testPutIfAbsent() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); assertNull(map.putIfAbsent("key1", "value1")); assertEquals("value1", map.get("key1")); assertEquals("value1", map.putIfAbsent("key1", "value2")); assertEquals("value1", map.get("key1")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, map.size())
[-] pred: org. junit. Assert. assertEquals ( 1, map. size() )
************************************
************************************
[+] input: testRemove() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); map.put("key1", "value1"); assertEquals("value1", map.remove("key1")); assertNull(map.remove("key1")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size ( ) )
************************************
************************************
[+] input: testReplace() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); map.put("key1", "value1"); assertEquals("value1", map.replace("key1", "value2")); assertEquals("value2", map.get("key1")); assertNull(map.replace("key2", "value3")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, map.size())
[-] pred: org. junit. Assert. assertEquals ( 1, map. size ( ) )
************************************
************************************
[+] input: testSyncMintNFT() { Provider provider = wallet.getProvider(); Token token = defaultToken(); EthSignature ethSignature = new EthSignature(SignatureType.EthereumSignature, "0xac4f8b1ad65ea143dd2a940c72dd778ba3e07ee766355ed237a89a0b7e925fe76ead0a04e23db1cc1593399ee69faeb31b2e7e0c6fbec70d5061d6fbc431d64a1b"); when(provider.getTokens()).thenReturn(new Tokens(Collections.singletonMap(token.getAddress(), token))); when(provider.submitTx(defaultZkSyncTransaction_MintNFT(), ethSignature, false)).thenReturn("success:hash"); String response = wallet.syncMintNFT( "0x19aa2ed8712072e918632259780e587698ef58df", "0x0000000000000000000000000000000000000000000000000000000000000123", defaultTransactionFee(1000000), 12 ); "<AssertPlaceHolder>"; assertEquals(response, "success:hash"); }
syncMintNFT(String recipient, String contentHash, TransactionFee fee, Integer nonce) { final Integer nonceToUse = nonce == null ? getNonce() : nonce;  final SignedTransaction<MintNFT> signedMintNFT = buildSignedMintNFTTx(recipient, contentHash, fee.getFeeToken(), fee.getFee(), nonceToUse);  return submitSignedTransaction(signedMintNFT.getTransaction(), signedMintNFT.getEthereumSignature()); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testSyncSwap() { Provider provider = mock(Provider.class); when(provider.getState(anyString())).thenReturn(defaultAccountState(5)); ZkSyncWallet wallet = ZkSyncWallet.build(ethSigner, zkSigner, provider);  Token token = new Token(3, Address.DEFAULT.getValue(), "USDT", 1); EthSignature ethSignature = new EthSignature(SignatureType.EthereumSignature, "0x3a459b40838e9445adc59e0cba4bf769b68deda8dadfedfe415f9e8be1c55443090f66cfbd13d96019b9faafb996a5a69d1bc0d1061f08ebf7cb8a1687e09a0f1c"); when(provider.getTokens()).thenReturn(new Tokens(Collections.singletonMap(token.getAddress(), token))); when(provider.submitTx(defaultZkSyncTransaction_Swap(), new EthSignature[]{ethSignature, null, null})).thenReturn("success:hash"); String response = wallet.syncSwap( defaultOrderA(), defaultOrderB(), BigInteger.valueOf(1000000), BigInteger.valueOf(2500000), defaultTransactionFee(123), 1 ); "<AssertPlaceHolder>"; assertEquals(response, "success:hash"); }
syncSwap(Order order1, Order order2, BigInteger amount1, BigInteger amount2, TransactionFee fee, Integer nonce) { final Integer nonceToUse = nonce == null ? getNonce() : nonce;  final SignedTransaction<Swap> signedSwap = buildSignedSwapTx(order1, order2, amount1, amount2, fee.getFeeToken(), fee.getFee(), nonceToUse);  return submitSignedTransaction(signedSwap.getTransaction(), signedSwap.getEthereumSignature()[0], order1.getEthereumSignature(), order2.getEthereumSignature()); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
[+] input: itShouldAccumulateProperly() { Duration smoothingWindow = Duration.ofSeconds(10); long currentTimestamp = 0; ValueStats valueStats_1 = ValueStats.create(smoothingWindow); ValueStats valueStats_2 = ValueStats.create(smoothingWindow); int inputValue_1 = 5; int inputValue_2 = 10; int iterations = 1000;  for (int i = 0; i < iterations; i++) { valueStats_1.recordValue(inputValue_1); valueStats_2.recordValue(inputValue_2); currentTimestamp += ONE_SECOND_IN_MILLIS; valueStats_1.refresh(currentTimestamp); valueStats_2.refresh(currentTimestamp); }  ValueStats accumulator = ValueStats.createAccumulator(); accumulator.add(valueStats_1); accumulator.add(valueStats_2);  double acceptableError = 10E-5; double expectedAccumulatedSmoothedAvg = (5 + 10) / 2.0; "<AssertPlaceHolder>"; }
getSmoothedAverage() { if (totalCount == 0) { return 0.0; }  return smoothedSum / smoothedCount; }
[*] target: assertEquals(expectedAccumulatedSmoothedAvg, accumulator.getSmoothedAverage(), acceptableError)
[-] pred: org. junit. Assert. assertEquals ( expectedAccumulatedSmoothedAvg, accumulator. getSmoothedAverage ( ), acceptableError )
************************************
************************************
[+] input: IOException { Map<String, FileMetadata> before = client.list("**");  Path tempDir = storagePath.resolve(DEFAULT_TEMP_DIR); Files.createDirectories(tempDir); Files.write(tempDir.resolve("systemFile.txt"), "test data".getBytes()); Path folder = tempDir.resolve("folder"); Files.createDirectories(folder); Files.write(folder.resolve("systemFile2.txt"), "test data".getBytes());  Map<String, FileMetadata> after = client.list("**");  "<AssertPlaceHolder>"; }
list(String glob) throws IOException { checkStarted(); if (glob.isEmpty()) return Map.of();  String subdir = extractSubDir(glob); Path subdirectory = resolve(subdir); String subglob = glob.substring(subdir.length());  return findMatching(tempDir, subglob, subdirectory).stream() .collect(Collector.of( (Supplier<Map<String, FileMetadata>>) HashMap::new, uncheckedOf((map, path) -> { FileMetadata metadata = toFileMetadata(path); if (metadata != null) { String filename = TO_REMOTE_NAME.apply(storage.relativize(path).toString()); map.put(filename, metadata); } }), noMergeFunction()) ); }
[*] target: assertEquals(before, after)
[-] pred: org. junit. Assert. assertEquals ( before, after )
************************************
************************************
[+] input: InterruptedException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); eventloopExecutor.execute(() -> actual.add(finalI)); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>"; }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ExecutionException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); eventloopExecutor.submit(() -> actual.add(finalI)).get(); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>"; }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: InterruptedException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); Integer actualI = eventloopExecutor.<Integer>submit(() -> cb -> cb.accept(finalI, null)).get(); actual.add(actualI); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>";  }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { AsyncServlet servlet = request -> request.loadBody(Integer.MAX_VALUE) .then(body -> HttpResponse.ok200().withBody(body.slice()).toPromise()); Exception exception = new Exception("TestException");  ByteBuf byteBuf = ByteBufPool.allocate(100); byteBuf.put("Test1".getBytes(UTF_8));  HttpRequest testRequest = HttpRequest.post("http://example.com") .withBodyStream(ChannelSuppliers.concat( ChannelSuppliers.ofValue(byteBuf), ChannelSuppliers.ofException(exception) )) .build();  Exception e = awaitException(servlet.serve(testRequest));  "<AssertPlaceHolder>"; }
serve(HttpRequest request) throws Exception;  /** * Wraps given {@link BlockingServlet}
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: testRenderAcceptContentType() { String expected = "text/html, application/xhtml+xml, application/xml; q=0.9, image/webp, */*; q=0.8"; ByteBuf buf = ByteBuf.wrapForWriting(new byte[expected.length()]); List<AcceptMediaType> acts = new ArrayList<>(); acts.add(AcceptMediaType.of(HTML)); acts.add(AcceptMediaType.of(XHTML_APP)); acts.add(AcceptMediaType.of(MediaTypes.XML_APP, 90)); acts.add(AcceptMediaType.of(WEBP)); acts.add(AcceptMediaType.of(MediaTypes.ANY, 80)); AcceptMediaType.render(acts, buf); String actual = asAscii(buf); "<AssertPlaceHolder>"; }
render(ContentType type, ByteBuf buf) { int pos = render(type, buf.array(), buf.tail()); buf.tail(pos); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test() { BinarySerializer<ExternalClass> serializer = SerializerFactory.builder() .with(ExternalComponent.class, ctx -> new SimpleSerializerDef<ExternalComponent>() { @Override protected BinarySerializer<ExternalComponent> createSerializer(int version, CompatibilityLevel compatibilityLevel) { return new BinarySerializer<>() { @Override public void encode(BinaryOutput out, ExternalComponent item) { out.writeVarInt(item.getX()); out.writeUTF8(item.getY()); }  @Override public ExternalComponent decode(BinaryInput in) throws CorruptedDataException { int x = in.readVarInt(); String y = in.readUTF8();  return new ExternalComponent(x, y); } }; } }) .build() .create(DEFINING_CLASS_LOADER, ExternalClass.class);  ExternalClass original = new ExternalClass( "test", new ExternalComponent( 123, "inner test 1" ), new ExternalComponent( 456, "inner test 2" ) );  ExternalClass copy = doTest(original, serializer);  "<AssertPlaceHolder>"; }
createSerializer(int version, CompatibilityLevel compatibilityLevel);  public final Class<T> getEncodeType() { return encodeType; }
[*] target: assertEquals(original, copy)
[-] pred: org. junit. Assert. assertEquals ( original, copy )
************************************
************************************
[+] input: IOException { Reactor reactor = Reactor.getCurrentReactor(); Path storageDir = temporaryFolder.newFolder().toPath(); FileSystem fs = FileSystem.create(reactor, newCachedThreadPool(), storageDir); await(fs.start()); IAggregationChunkStorage aggregationChunkStorage = AggregationChunkStorage.create( reactor, stubChunkIdGenerator(), FrameFormats.lz4(), fs);  int nChunks = 100; AggregationChunker<KeyValuePair> chunker = AggregationChunker.create( structure, structure.getMeasures(), KeyValuePair.class, singlePartition(), aggregationChunkStorage, classLoader, 1);  Set<Path> expected = IntStream.range(0, nChunks).mapToObj(i -> Paths.get((i + 1) + AggregationChunkStorage.LOG)).collect(toSet());  Random random = ThreadLocalRandom.current(); StreamSupplier<KeyValuePair> supplier = StreamSuppliers.ofStream( Stream.generate(() -> new KeyValuePair(random.nextInt(), random.nextInt(), random.nextLong())) .limit(nChunks));  List<Path> paths = await(supplier.streamTo(chunker) .then(chunker::getResult) .then(protoAggregationChunks -> aggregationChunkStorage.finish(protoAggregationChunks.stream() .map(ProtoAggregationChunk::protoChunkId) .collect(toSet()))) .map($ -> { try (Stream<Path> list = Files.list(storageDir)) { return list.filter(path -> path.toString().endsWith(AggregationChunkStorage.LOG)).collect(toList()); } catch (IOException e) { throw new AssertionError(e); } }));  Set<Path> actual = paths.stream().filter(Files::isRegularFile).map(Path::getFileName).collect(toSet());  "<AssertPlaceHolder>"; }
finish(Set<String> protoChunkIds) { checkInReactorThread(this); return idGenerator.convertToActualChunkIds(protoChunkIds) .mapException(e -> new AggregationException("Failed to convert to actual chunk IDs: " + Utils.toString(protoChunkIds), e)) .then(chunkIds -> { Map<String, String> renameMap = chunkIds.entrySet().stream() .collect(toMap(e -> toTempPath(e.getKey()), e -> toPath(e.getValue()))); return fileSystem.moveAll(renameMap) .mapException(e -> new AggregationException("Failed to finalize chunks: " + Utils.toString(protoChunkIds), e)) .map($ -> chunkIds); }) .whenResult(() -> finishChunks = protoChunkIds.size()) .whenComplete(promiseFinishChunks.recordStats()); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { manager.saveDiff(100, 10L, 25, 1L);  int integer = manager.loadDiff(25, 1L, 10L); "<AssertPlaceHolder>"; }
loadDiff(T state, Long revisionFrom, Long revisionTo) throws IOException { T loaded = tryLoadDiff(state, revisionFrom, revisionTo); if (loaded == null) { throw new IOException("Cannot find diffs between revision " + revisionFrom + " and " + revisionTo); } return loaded; }
[*] target: assertEquals(100, integer)
[-] pred: org. junit. Assert. assertEquals ( 100, integer )
************************************
************************************
[+] input: testEmptyList() { DynamicArray<Integer> list = new DynamicArray<>(); "<AssertPlaceHolder>"; }
isEmpty() { // YOUR CODE HERE return false; }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: testSetOnJoinResetMoney() { s.setOnJoinResetMoney(false); assertFalse(s.isOnJoinResetMoney()); s.setOnJoinResetMoney(true); "<AssertPlaceHolder>"; }
isOnJoinResetMoney() { return onJoinResetMoney; }
[*] target: assertTrue(s.isOnJoinResetMoney())
[-] pred: org. junit. Assert. assertTrue ( s. isOnJoinResetMoney() )
************************************
************************************
[+] input: testSetOnLeaveResetXP() { assertFalse(s.isOnLeaveResetXP()); s.setOnLeaveResetXP(true); "<AssertPlaceHolder>"; }
isOnLeaveResetXP() { return onLeaveResetXP; }
[*] target: assertTrue(s.isOnLeaveResetXP())
[-] pred: org. junit. Assert. assertTrue ( s. isOnLeaveResetXP() )
************************************
************************************
[+] input: NoSuchAlgorithmException { //        AESPair keyPair = AES256.generateKeyPairOld(); //        SecretKey key = keyPair.getKey(); //        byte[] IV = keyPair.getIV(); //        byte[] sk = AES256.serializeSecretKey(key); // //        List<byte[]> listofbytes = new ArrayList<>(); //        listofbytes.add(sk); //        listofbytes.add(IV); // //        byte[] shareBetweenUsers = ByteHelper.concat(listofbytes); //        assertEquals(shareBetweenUsers.length, 32+16); //        assertTrue(Arrays.equals(Arrays.copyOfRange(shareBetweenUsers, 0, 32), sk)); //        assertTrue(Arrays.equals(Arrays.copyOfRange(shareBetweenUsers, 32, shareBetweenUsers.length), IV)); // //        SecretKey reconstructedKey = AES256.deserializeSecretKey(sk); //        boolean r = (key.equals(reconstructedKey)); // //        "<AssertPlaceHolder>"; }
deserializeSecretKey (byte[] sk) { return new SecretKeySpec(sk, 0, sk.length, Constant.AES); }
[*] target: assertTrue(r)
[-] pred: org. junit. Assert. assertTrue ( r )
************************************
************************************
[+] input: Exception { String message = "1";  KeyPair kp2048 = RSA.generateKeyPair(); PublicKey pk = kp2048.getPublic(); PrivateKey sk = kp2048.getPrivate();  byte[] sign = RSA.signAsBytes(message, sk); assertEquals(sign.length, 256);  boolean valid = RSA.verifyAsBytes(message, sign, pk); "<AssertPlaceHolder>"; }
verifyAsBytes(String plainText, byte[] signatureBytes, PublicKey publicKey) throws Exception { java.security.Signature publicSignature = java.security.Signature.getInstance("SHA256withRSA"); publicSignature.initVerify(publicKey); publicSignature.update(plainText.getBytes(UTF_8));  return publicSignature.verify(signatureBytes); }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: Exception { String message = "1"; KeyPair kp4096 = RSA.generateKeyPair(4096); PublicKey pk = kp4096.getPublic(); PrivateKey sk = kp4096.getPrivate();  byte[] sign = RSA.signAsBytes(message, sk); assertEquals(sign.length, 512);  boolean valid = RSA.verifyAsBytes(message, sign, pk); "<AssertPlaceHolder>"; }
verifyAsBytes(String plainText, byte[] signatureBytes, PublicKey publicKey) throws Exception { java.security.Signature publicSignature = java.security.Signature.getInstance("SHA256withRSA"); publicSignature.initVerify(publicKey); publicSignature.update(plainText.getBytes(UTF_8));  return publicSignature.verify(signatureBytes); }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: NoSuchAlgorithmException { String message = "1"; byte[] messageHash = SHA256.hash(message);  String actualHashHex = "6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b"; byte[] actualHash = ByteHelper.hexStringToByteArray(actualHashHex);  boolean valid = Arrays.equals(messageHash, actualHash); "<AssertPlaceHolder>";  assertEquals(messageHash.length, 32); }
hexStringToByteArray(String hexString){ byte[] bytes = new byte[hexString.length() / 2];  for(int i = 0; i < hexString.length(); i += 2){ String sub = hexString.substring(i, i + 2); Integer intVal = Integer.parseInt(sub, 16); bytes[i / 2] = intVal.byteValue(); String hex = "".format("0x%x", bytes[i / 2]); } return bytes; }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: IOException { //        final List<String> expectedApkFiles = Arrays.asList("base.apk", //                "split_config.en.apk", //                "split_config.hdpi.apk"); //        Collections.sort(expectedApkFiles); //        Path xmlFile = Paths.get(new File(backupLocation, PACKAGE_NAME_APK_SPLITS + ".xml")); //        SBConverter sbConvert = new SBConverter(xmlFile); //        sbConvert.convert(); //        Path newBackupLocation = Prefs.Storage.getAppManagerDirectory().findFile(PACKAGE_NAME_APK_SPLITS).findFile("0_SB"); //        // Verify source //        List<String> actualApkFiles = TarUtilsTest.getFileNamesGZip(Collections.singletonList( //                newBackupLocation.findFile("source.tar.gz.0"))); //        Collections.sort(actualApkFiles); //        "<AssertPlaceHolder>"; //        assertFalse(newBackupLocation.hasFile("data0.tar.gz.0")); //        assertFalse(newBackupLocation.hasFile("data1.tar.gz.0")); //    }
convert() throws BackupException { // Source metadata mSourceMetadata = new MetadataManager.Metadata(); generateMetadata(); // Destination metadata mDestMetadata = new MetadataManager.Metadata(mSourceMetadata); MetadataManager metadataManager = MetadataManager.getNewInstance(); metadataManager.setMetadata(mDestMetadata); // Simulate a backup creation // If the package has another backup named SB, another backup will be created BackupFiles backupFiles; BackupFiles.BackupFile[] backupFileList; try { backupFiles = new BackupFiles(mPackageName, mUserId, new String[]{"SB"}); backupFileList = backupFiles.getBackupPaths(true); } catch (IOException e) { throw new BackupException("Could not get backup files.", e); } for (BackupFiles.BackupFile backupFile : backupFileList) { // We're iterating over a singleton list boolean backupSuccess = false; try { mTempBackupPath = backupFile.getBackupPath(); mCrypto = ConvertUtils.setupCrypto(mDestMetadata); mDestMetadata.backupName = backupFile.backupName; try { mChecksum = backupFile.getChecksum(CryptoUtils.MODE_NO_ENCRYPTION); } catch (IOException e) { throw new BackupException("Failed to create checksum file.", e); } // Backup icon backupIcon(); if (mDestMetadata.flags.backupApkFiles()) { backupApkFile(); } if (mDestMetadata.flags.backupData()) { backupData(); } // Write modified metadata metadataManager.setMetadata(mDestMetadata); try { metadataManager.writeMetadata(backupFile); } catch (IOException e) { throw new BackupException("Failed to write metadata."); } // Store checksum for metadata try { mChecksum.add(MetadataManager.META_FILE, DigestUtils.getHexDigest(mDestMetadata.checksumAlgo, backupFile.getMetadataFile())); } catch (IOException e) { throw new BackupException("Failed to generate checksum for meta.json", e); } mChecksum.close(); // Encrypt checksum try { Path checksumFile = backupFile.getChecksumFile(CryptoUtils.MODE_NO_ENCRYPTION); encrypt(new Path[]{checksumFile}); } catch (IOException e) { throw new BackupException("Failed to encrypt checksums.txt"); } // Replace current backup try { backupFile.commit(); } catch (IOException e) { throw new BackupException("Could not finalise backup.", e); } backupSuccess = true; } catch (BackupException e) { throw e; } catch (Throwable th) { throw new BackupException("Unknown error occurred.", th); } finally { if (!backupSuccess) { backupFile.cleanup(); } if (mCrypto != null) { mCrypto.close(); } mCachedApk.requireParent().delete(); if (backupSuccess) { BackupUtils.putBackupToDbAndBroadcast(ContextUtils.getContext(), mDestMetadata); } } return; } }
[*] target: assertEquals(expectedApkFiles, actualApkFiles)
[-] pred: org. junit. Assert. assertEquals ( expectedApkFiles, actualApkFiles )
************************************
************************************
[+] input: IOException { try (StringWriter writer = new StringWriter()) { List<String[]> records = new ArrayList<String[]>() {{ add(new String[]{"1", "apple", "10", "9.99"}); add(new String[]{"2", "orange", "5", "4.99"}); }}; String expected = "1,apple,10,9.99\n2,orange,5,4.99"; new CsvWriter(writer).addLines(records); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLines(@NonNull Collection<String[]> lines) throws IOException { addLines(lines, false); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { try (StringWriter writer = new StringWriter()) { String expected = "1,apple,10,9.99"; CsvWriter csvWriter = new CsvWriter(writer); csvWriter.addField("1"); csvWriter.addField("apple"); csvWriter.addField("10"); csvWriter.addField("9.99"); csvWriter.addLine(); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLine() { initIfNotAlready(); checkFieldCountSame(); mCurrentFieldCount = 0; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { try (StringWriter writer = new StringWriter()) { String expected = "1,apple,10,9.99\n2,orange,5,4.99"; CsvWriter csvWriter = new CsvWriter(writer); csvWriter.addField("1"); csvWriter.addField("apple"); csvWriter.addField("10"); csvWriter.addField("9.99"); csvWriter.addLine(); csvWriter.addField("2"); csvWriter.addField("orange"); csvWriter.addField("5"); csvWriter.addField("4.99"); csvWriter.addLine(); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLine() { initIfNotAlready(); checkFieldCountSame(); mCurrentFieldCount = 0; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { try (SplitInputStream splitInputStream = new SplitInputStream(fileList)) { // For 1 KB long expectedSkipBytes = 10024; long actualSkipBytes = splitInputStream.skip(expectedSkipBytes); assertEquals(expectedSkipBytes, actualSkipBytes); // For 1 MB expectedSkipBytes = 1024 * 1024; actualSkipBytes = splitInputStream.skip(expectedSkipBytes); assertEquals(expectedSkipBytes, actualSkipBytes); // For 2 MB expectedSkipBytes = 1024 * 1024 * 2; actualSkipBytes = splitInputStream.skip(expectedSkipBytes); "<AssertPlaceHolder>"; } }
skip(long n) throws IOException { if (n <= 0) return 0; return Math.max(read0(null, 0, (int) n), 0); }
[*] target: assertEquals(expectedSkipBytes, actualSkipBytes)
[-] pred: org. junit. Assert. assertEquals ( expectedSkipBytes, actualSkipBytes )
************************************
************************************
[+] input: IOException { List<Path> pathList = new ArrayList<>(); assert classLoader != null; pathList.add(Paths.get(classLoader.getResource("AppManager_v2.5.22.apks.tar.0").getFile())); pathList.add(Paths.get(classLoader.getResource("AppManager_v2.5.22.apks.tar.1").getFile()));  // Always run tests using SplitInputStream try (SplitInputStream sis = new SplitInputStream(pathList); BufferedInputStream bis = new BufferedInputStream(sis); TarArchiveInputStream tis = new TarArchiveInputStream(bis)) { ArchiveEntry entry; while ((entry = tis.getNextEntry()) != null) { // create a new path, remember check zip slip attack File file = new File("/tmp", entry.getName()); // copy TarArchiveInputStream to newPath try (OutputStream os = Paths.get(file).openOutputStream()) { IoUtils.copy(tis, os); } } }  // Check integrity List<String> expectedHashes = new ArrayList<>(); List<File> fileList = new ArrayList<>(); fileList.add(new File(classLoader.getResource("AppManager_v2.5.22.apks.0").getFile())); fileList.add(new File(classLoader.getResource("AppManager_v2.5.22.apks.1").getFile())); for (File file : fileList) { expectedHashes.add(DigestUtils.getHexDigest(DigestUtils.SHA_256, file)); } List<String> actualHashes = new ArrayList<>(); fileList.clear(); fileList.add(new File("/tmp/AppManager_v2.5.22.apks.0")); fileList.add(new File("/tmp/AppManager_v2.5.22.apks.1")); for (File file : fileList) { if (!file.exists()) { throw new FileNotFoundException(file + " does not exist."); } actualHashes.add(DigestUtils.getHexDigest(DigestUtils.SHA_256, file)); junkFiles.add(file); } "<AssertPlaceHolder>"; }
getNextEntry() throws IOException { return getNextTarEntry(); }
[*] target: assertEquals(expectedHashes, actualHashes)
[-] pred: org. junit. Assert. assertEquals ( expectedHashes, actualHashes )
************************************
************************************
[+] input: should_throw_exception_if_directive_class_not_a_wiring1() { directivePostProcessor.postProcessBeforeInitialization(new CorrectDirective(), "a"); Map<String, SchemaDirectiveWiring> map = (Map<String, SchemaDirectiveWiring>) ReflectionTestUtils.getField(RuntimeWiringRegistry.class, "NAME_AND_DIRECTIVE_WIRING"); "<AssertPlaceHolder>"; assertEquals(1, map.size()); assertTrue(map.containsKey("b")); }
postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { Class<?> targetClass = AopProxyUtils.ultimateTargetClass(bean); if (targetClass.isAnnotationPresent(Directive.class)) { Directive directive = targetClass.getAnnotation(Directive.class); if (bean instanceof SchemaDirectiveWiring) { RuntimeWiringRegistry.registerDirective(directive.value(), (SchemaDirectiveWiring) bean); } else { throw new BeanInitializationException("directive bean must implements SchemaDirectiveWiring! bean:" + beanName); } } return bean; }
[*] target: assertNotNull(map)
[-] pred: org. junit. Assert. assertNotNull ( map )
************************************
************************************
[+] input: testHappyPath() { // to make this a unit test, we need to mock out the computations that would ordinarily involve collaborators // such as Bazel Query, filesystem scanning, and file parsing TestBazelQueryProjectStructureStrategy strategy = new TestBazelQueryProjectStructureStrategy(); addSourcePathForTest(strategy, "source/main/java"); addSourcePathForTest(strategy, "source/test/java"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/main/resources"); addTestResourcePathForTest(strategy, "projects/libs/apple/source/test/resources");  addSimQueryResult(strategy, "source/main/java/com/salesforce/apple/api/Apple.java"); addSimQueryResult(strategy, "source/main/java/com/salesforce/apple/api/ApplePie.java"); addSimQueryResult(strategy, "source/main/resources/fruit/kinds.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/pies.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/cakes.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/sauces.properties"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/AppleTest.java"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/ApplePieTest.java"); addSimQueryResult(strategy, "source/test/resources/test.properties");  // run the test String relPath = FSPathHelper.osSeps("projects/libs/apple"); InMemoryPackageLocation packageLocation = new InMemoryPackageLocation(relPath); ProjectStructure structure = null; try { structure = strategy.doStructureAnalysis(bazelWorkspace, packageLocation, nullCommandRunner); } catch (Exception anyE) { anyE.printStackTrace(); }  // validate "<AssertPlaceHolder>"; assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/main/java"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/main/resources"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/source/test/java"); assertContains(structure.testResourceDirFSPaths, "projects/libs/apple/source/test/resources"); }
doStructureAnalysis(BazelWorkspace bazelWorkspace, BazelPackageLocation packageNode, BazelWorkspaceCommandRunner commandRunner) {  File workspaceRootDir = bazelWorkspace.getBazelWorkspaceRootDirectory(); String packageRelPath = packageNode.getBazelPackageFSRelativePath(); File packageDir = new File(workspaceRootDir, packageRelPath); // TODO move this to the PackageLocation api  String labelPath = packageRelPath.replaceAll(FSPathHelper.WINDOWS_BACKSLASH_REGEX, "/"); BazelLabel packageLabel = new BazelLabel(labelPath, BazelLabel.BAZEL_WILDCARD_ALLTARGETS_STAR);  // execute the expensive query, this will take a few seconds to run at least Collection<String> queryResults = runBazelQueryForSourceFiles(workspaceRootDir, packageLabel, commandRunner);  ProjectStructure structure = processQueryResults(packageRelPath, packageDir, packageLabel, queryResults);  return structure; }
[*] target: assertNotNull(structure)
[-] pred: org. junit. Assert. assertNotNull ( structure )
************************************
************************************
[+] input: testMultipleSourceDirs() { // to make this a unit test, we need to mock out the computations that would ordinarily involve collaborators // such as Bazel Query, filesystem scanning, and file parsing TestBazelQueryProjectStructureStrategy strategy = new TestBazelQueryProjectStructureStrategy(); addSourcePathForTest(strategy, "source/dev/java"); addSourcePathForTest(strategy, "source/dev2/java"); addSourcePathForTest(strategy, "source/test/java"); addSourcePathForTest(strategy, "src/test/java"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/dev/resources/fruit"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/dev2/resources"); addTestResourcePathForTest(strategy, "projects/libs/apple/source/test/resources");  addSimQueryResult(strategy, "source/dev/java/com/salesforce/apple/api/Apple.java"); addSimQueryResult(strategy, "source/dev2/java/com/salesforce/apple/api/ApplePie.java"); addSimQueryResult(strategy, "source/dev/resources/fruit/kinds.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/pies.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/cakes.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/sauces.properties"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/AppleTest.java"); addSimQueryResult(strategy, "src/test/java/com/salesforce/apple/api/ApplePieTest.java"); addSimQueryResult(strategy, "source/test/resources/test.properties");  // run the test String relPath = FSPathHelper.osSeps("projects/libs/apple"); InMemoryPackageLocation packageLocation = new InMemoryPackageLocation(relPath); ProjectStructure structure = strategy.doStructureAnalysis(bazelWorkspace, packageLocation, nullCommandRunner);  // validate "<AssertPlaceHolder>"; assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/dev/java"); assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/dev2/java"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/dev/resources/fruit"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/dev2/resources"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/source/test/java"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/src/test/java"); assertContains(structure.testResourceDirFSPaths, "projects/libs/apple/source/test/resources"); }
doStructureAnalysis(BazelWorkspace bazelWorkspace, BazelPackageLocation packageNode, BazelWorkspaceCommandRunner commandRunner) {  File workspaceRootDir = bazelWorkspace.getBazelWorkspaceRootDirectory(); String packageRelPath = packageNode.getBazelPackageFSRelativePath(); File packageDir = new File(workspaceRootDir, packageRelPath); // TODO move this to the PackageLocation api  String labelPath = packageRelPath.replaceAll(FSPathHelper.WINDOWS_BACKSLASH_REGEX, "/"); BazelLabel packageLabel = new BazelLabel(labelPath, BazelLabel.BAZEL_WILDCARD_ALLTARGETS_STAR);  // execute the expensive query, this will take a few seconds to run at least Collection<String> queryResults = runBazelQueryForSourceFiles(workspaceRootDir, packageLabel, commandRunner);  ProjectStructure structure = processQueryResults(packageRelPath, packageDir, packageLabel, queryResults);  return structure; }
[*] target: assertNotNull(structure)
[-] pred: org. junit. Assert. assertNotNull ( structure )
************************************
************************************
[+] input: testPlot() { double[] nums = new double[]{2710, 2755, 2850, 2880, 2880, 2890, 2920, 2940, 2950, 3050, 3130, 3325}; BoxPlot plot = BoxPlotUtil.plot(nums); TestCase."<AssertPlaceHolder>"; TestCase.assertEquals(3202.5D, plot.getMaxRegion()); TestCase.assertEquals(3000.0D, plot.getQ3()); TestCase.assertEquals(2905.0, plot.getMedian()); TestCase.assertEquals(2865.0, plot.getQ1()); TestCase.assertEquals(2662.5D, plot.getMinRegion()); }
plot(double[] data) { List<Double> collect = Arrays.stream(data).boxed().sorted().collect(Collectors.toList()); data = collect.stream().mapToDouble(i -> i).toArray(); if (data.length <= 2) { return null; }  double max; double q3; double median; double q1; double min; double iqr; if (data.length % 2 == 0) { median = (data[(data.length) / 2 - 1] + data[(data.length) / 2]) / 2; q1 = (data[(data.length) / 4 - 1] + data[(data.length) / 4]) / 2; q3 = (data[((data.length) * 3) / 4 - 1] + data[((data.length) * 3) / 4]) / 2; } else { median = data[(data.length) / 2]; q1 = data[(data.length) / 4]; q3 = data[(data.length * 3) / 4]; } max = data[data.length - 1]; min = data[0]; iqr = q3 - q1;  double maxRegion = q3 + 1.5 * iqr; double minRegion = q1 - 1.5 * iqr;  BoxPlot box = new BoxPlot(); box.setMaxRegion(maxRegion); box.setMax(max); box.setQ3(q3); box.setMedian(median); box.setQ1(q1); box.setMin(min); box.setMinRegion(minRegion); box.setIqr(iqr); return box; }
[*] target: assertNotNull(plot)
[-] pred: org. junit. Assert. assertNotNull ( plot )
************************************
************************************
[+] input: testNullPlot() { double[] nums = new double[]{2710, 2755}; BoxPlot plot = BoxPlotUtil.plot(nums); TestCase."<AssertPlaceHolder>"; }
plot(double[] data) { List<Double> collect = Arrays.stream(data).boxed().sorted().collect(Collectors.toList()); data = collect.stream().mapToDouble(i -> i).toArray(); if (data.length <= 2) { return null; }  double max; double q3; double median; double q1; double min; double iqr; if (data.length % 2 == 0) { median = (data[(data.length) / 2 - 1] + data[(data.length) / 2]) / 2; q1 = (data[(data.length) / 4 - 1] + data[(data.length) / 4]) / 2; q3 = (data[((data.length) * 3) / 4 - 1] + data[((data.length) * 3) / 4]) / 2; } else { median = data[(data.length) / 2]; q1 = data[(data.length) / 4]; q3 = data[(data.length * 3) / 4]; } max = data[data.length - 1]; min = data[0]; iqr = q3 - q1;  double maxRegion = q3 + 1.5 * iqr; double minRegion = q1 - 1.5 * iqr;  BoxPlot box = new BoxPlot(); box.setMaxRegion(maxRegion); box.setMax(max); box.setQ3(q3); box.setMedian(median); box.setQ1(q1); box.setMin(min); box.setMinRegion(minRegion); box.setIqr(iqr); return box; }
[*] target: assertNull(plot)
[-] pred: org. junit. Assert. assertNull ( plot )
************************************
************************************
[+] input: Exception { Collection<MessageId> messagesToAck = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToAck(txn, contactId, 123); will(returnValue(messagesToAck)); oneOf(database).lowerAckFlag(txn, contactId, messagesToAck); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Ack a = db.generateAck(transaction, contactId, 123); "<AssertPlaceHolder>"; assertEquals(messagesToAck, a.getMessageIds()); }); }
generateAck(Transaction transaction, ContactId c, int maxMessages) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToAck(txn, c, maxMessages); if (ids.isEmpty()) return null; db.lowerAckFlag(txn, c, ids); return new Ack(ids); }
[*] target: assertNotNull(a)
[-] pred: org. junit. Assert. assertNotNull ( a )
************************************
************************************
[+] input: Exception { MessageId messageId1 = new MessageId(getRandomId()); Collection<MessageId> ids = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToOffer(txn, contactId, 123, maxLatency); will(returnValue(ids)); oneOf(database).updateRetransmissionData(txn, contactId, messageId, maxLatency); oneOf(database).updateRetransmissionData(txn, contactId, messageId1, maxLatency); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Offer o = db.generateOffer(transaction, contactId, 123, maxLatency); "<AssertPlaceHolder>"; assertEquals(ids, o.getMessageIds()); }); }
generateOffer(Transaction transaction, ContactId c, int maxMessages, long maxLatency) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToOffer(txn, c, maxMessages, maxLatency); if (ids.isEmpty()) return null; for (MessageId m : ids) db.updateRetransmissionData(txn, c, m, maxLatency); return new Offer(ids); }
[*] target: assertNotNull(o)
[-] pred: org. junit. Assert. assertNotNull ( o )
************************************
************************************
[+] input: Exception { MessageId messageId1 = new MessageId(getRandomId()); Collection<MessageId> ids = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToRequest(txn, contactId, 123); will(returnValue(ids)); oneOf(database).removeOfferedMessages(txn, contactId, ids); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Request r = db.generateRequest(transaction, contactId, 123); "<AssertPlaceHolder>"; assertEquals(ids, r.getMessageIds()); }); }
generateRequest(Transaction transaction, ContactId c, int maxMessages) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToRequest(txn, c, maxMessages); if (ids.isEmpty()) return null; db.removeOfferedMessages(txn, c, ids); return new Request(ids); }
[*] target: assertNotNull(r)
[-] pred: org. junit. Assert. assertNotNull ( r )
************************************
************************************
[+] input: Exception { OutgoingSessionRecord sessionRecord = new OutgoingSessionRecord();  expectCheckForOrphans(); manager.eventOccurred(new TransportActiveEvent(ID));  context.checking(new Expectations() {{ oneOf(pluginManager).getPlugin(ID); will(returnValue(plugin)); oneOf(plugin).createWriter(with(any(TransportProperties.class))); will(returnValue(transportConnectionWriter)); oneOf(transportConnectionWriter).dispose(false); oneOf(connectionManager).manageOutgoingConnection(with(contactId), with(ID), with(any(TransportConnectionWriter.class)), with(sessionRecord)); // The session succeeds. We need to use an action for this, as // createAndWriteTempFileForUpload() waits for it to happen before // returning will(new ConsumeArgumentAction<>(TransportConnectionWriter.class, 2, writer -> { try { writer.dispose(false); } catch (IOException e) { fail(); } } )); }});  File f = manager.createAndWriteTempFileForUpload(contactId, sessionRecord); "<AssertPlaceHolder>"; }
createAndWriteTempFileForUpload(ContactId contactId, OutgoingSessionRecord sessionRecord) throws IOException { File f = createTempFile(UPLOAD_DIR_NAME); // We shouldn't reach this point until the plugin has been started SimplexPlugin plugin = (SimplexPlugin) requireNonNull(pluginManager.getPlugin(ID)); TransportProperties p = new TransportProperties(); p.put(PROP_PATH, f.getAbsolutePath()); TransportConnectionWriter writer = plugin.createWriter(p); if (writer == null) { delete(f); throw new IOException(); } MailboxFileWriter decorated = new MailboxFileWriter(writer); LOG.info("Writing file for upload"); connectionManager.manageOutgoingConnection(contactId, ID, decorated, sessionRecord); if (decorated.awaitDisposal()) { // An exception was thrown during the session - delete the file delete(f); throw new IOException(); } return f; }
[*] target: assertTrue(f.exists())
[-] pred: org. junit. Assert. assertTrue ( f. exists ( ) )
************************************
************************************
[+] input: Exception { Transaction txn = new Transaction(null, true);  context.checking(new Expectations() {{ oneOf(settingsManager).getSettings(txn, SETTINGS_NAMESPACE); will(returnValue(pairedSettings)); }});  MailboxProperties properties = manager.getOwnMailboxProperties(txn); "<AssertPlaceHolder>"; assertEquals(onion, properties.getOnion()); assertEquals(token, properties.getAuthToken()); assertEquals(serverSupports, properties.getServerSupports()); assertTrue(properties.isOwner()); }
getOwnMailboxProperties(Transaction txn) throws DbException { Settings s = settingsManager.getSettings(txn, SETTINGS_NAMESPACE); String onion = s.get(SETTINGS_KEY_ONION); String token = s.get(SETTINGS_KEY_TOKEN); if (isNullOrEmpty(onion) || isNullOrEmpty(token)) return null; List<MailboxVersion> serverSupports = parseServerSupports(s); try { MailboxAuthToken tokenId = MailboxAuthToken.fromString(token); return new MailboxProperties(onion, tokenId, serverSupports); } catch (InvalidMailboxIdException e) { throw new DbException(e); } }
[*] target: assertNotNull(properties)
[-] pred: org. junit. Assert. assertNotNull ( properties )
************************************
************************************
[+] input: testEmoji() { String webInsert = "{"emoji":"100"}"; String mobileExpected = "{"insert":"\uD83D\uDCAF"}"; LinkedHashMap emojiMap = GSON.fromJson(webInsert, LinkedHashMap.class); String res = GSON.toJson(DeltaConverter.WebToMobile.webToMobileEmoji(emojiMap)); Assert."<AssertPlaceHolder>"; }
webToMobileEmoji(Map insertMap) { LinkedHashMap mobileElement = new LinkedHashMap(); String val = (String) insertMap.get("emoji"); LOGGER.info(" webToMobileEmoji val=" + val); mobileElement.put("insert", EmojiConverter.nameToSurrogatePair(val).get()); return mobileElement; }
[*] target: assertEquals(mobileExpected, res)
[-] pred: org. junit. Assert. assertEquals ( mobileExpected, res )
************************************
************************************
[+] input: canCreateAMiss() { CacheGetResult<Object> miss = CacheGetResult.miss(); "<AssertPlaceHolder>"; }
miss() { return CacheGetResultImpl.getMiss(); }
[*] target: assertNotNull(miss)
[-] pred: org. junit. Assert. assertNotNull ( miss )
************************************
************************************
[+] input: canCalculateAdditiveDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Doe"); p2.setHobbies("Swimming", "Skiing", "Cinema", "Reading"); p2.setPets("Cat", "Dog", "Fish"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); indices.add(petsIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertTrue(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(hobbiesIndex, petsIndex), diff.getChangedIndices()); assertEquals(Sets.newHashSet("Cinema", "Reading"), diff.getAdditions(hobbiesIndex)); assertEquals(Sets.newHashSet("Cat", "Dog", "Fish"), diff.getAdditions(petsIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateSubtractiveDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing", "Cinema", "Reading"); p1.setPets("Cat", "Dog", "Fish"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Doe"); p2.setHobbies("Swimming", "Skiing"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); indices.add(petsIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertTrue(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(hobbiesIndex, petsIndex), diff.getChangedIndices()); assertEquals(Sets.newHashSet("Cinema", "Reading"), diff.getRemovals(hobbiesIndex)); assertEquals(Sets.newHashSet("Cat", "Dog", "Fish"), diff.getRemovals(petsIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateEntryAdditionDiff() { Person johnDoe = createJohnDoe(); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex favoriteColorIndex = new DummyIndex(PersonIndexer.favoriteColor(), "favoriteColor"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(favoriteColorIndex); indices.add(hobbiesIndex); indices.add(petsIndex);  // simulate the addition of John Doe IndexValueDiff diff = IndexingUtils.calculateDiff(indices, null, johnDoe); "<AssertPlaceHolder>"; assertTrue(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); assertTrue(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(firstNameIndex, lastNameIndex, hobbiesIndex), diff.getChangedIndices());  assertEquals(Sets.newHashSet("John"), diff.getAdditions(firstNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(firstNameIndex));  assertEquals(Sets.newHashSet("Doe"), diff.getAdditions(lastNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(lastNameIndex));  assertEquals(Sets.newHashSet("Swimming", "Skiing"), diff.getAdditions(hobbiesIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(hobbiesIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateEntryRemovalDiff() { Person johnDoe = createJohnDoe(); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex favoriteColorIndex = new DummyIndex(PersonIndexer.favoriteColor(), "favoriteColor"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(favoriteColorIndex); indices.add(hobbiesIndex); indices.add(petsIndex); // simulate the deletion of John Doe IndexValueDiff diff = IndexingUtils.calculateDiff(indices, johnDoe, null); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertTrue(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertTrue(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(firstNameIndex, lastNameIndex, hobbiesIndex), diff.getChangedIndices());  assertEquals(Collections.emptySet(), diff.getAdditions(firstNameIndex)); assertEquals(Sets.newHashSet("John"), diff.getRemovals(firstNameIndex));  assertEquals(Collections.emptySet(), diff.getAdditions(lastNameIndex)); assertEquals(Sets.newHashSet("Doe"), diff.getRemovals(lastNameIndex));  assertEquals(Collections.emptySet(), diff.getAdditions(hobbiesIndex)); assertEquals(Sets.newHashSet("Swimming", "Skiing"), diff.getRemovals(hobbiesIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateMixedDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Smith"); p2.setHobbies("Skiing", "Cinema"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertTrue(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Collections.emptySet(), diff.getAdditions(firstNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(firstNameIndex)); assertFalse(diff.isIndexChanged(firstNameIndex)); assertEquals(Collections.singleton("Smith"), diff.getAdditions(lastNameIndex)); assertEquals(Collections.singleton("Doe"), diff.getRemovals(lastNameIndex)); assertTrue(diff.isIndexChanged(lastNameIndex)); assertEquals(Collections.singleton("Cinema"), diff.getAdditions(hobbiesIndex)); assertEquals(Collections.singleton("Swimming"), diff.getRemovals(hobbiesIndex)); assertTrue(diff.isIndexChanged(hobbiesIndex)); assertEquals(Sets.newHashSet(lastNameIndex, hobbiesIndex), diff.getChangedIndices()); assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCreateEmptyDiff() { MutableIndexValueDiff diff = new MutableIndexValueDiff(null, null); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmptyAddition() { MutableIndexValueDiff diff = new MutableIndexValueDiff(null, new Object()); assertNotNull(diff); "<AssertPlaceHolder>"; assertTrue(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmptyRemoval() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), null); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertTrue(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmtpyUpdate() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), new Object()); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canScanForMigrationChain() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA1.class); expectedClasses.add(MigrationA2.class); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred: org. junit. Assert. assertEquals ( expectedClasses, actualClasses )
************************************
************************************
[+] input: canLimitMigrationChainArbitrarilyBetweenVersions() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); chain = chain.startingAt(ChronosVersion.parse("0.6.0")); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred: org. junit. Assert. assertEquals ( expectedClasses, actualClasses )
************************************
************************************
[+] input: canLimitMigrationChainPreciselyAtVersion() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); chain = chain.startingAt(ChronosVersion.parse("0.5.1")); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA2.class); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred: org. junit. Assert. assertEquals ( expectedClasses, actualClasses )
************************************
************************************
[+] input: emptyPeriodIsSingleton() { Period empty1 = Period.empty(); Period empty2 = Period.empty(); "<AssertPlaceHolder>"; assertNotNull(empty2); assertTrue(empty1 == empty2); }
empty() { return PeriodImpl.empty(); }
[*] target: assertNotNull(empty1)
[-] pred: org. junit. Assert. assertNotNull ( empty1 )
************************************
************************************
[+] input: canCreateInMemoryDatabaseEasily() { // without additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().inMemoryGraph().build()) { assertNotNull(graph); } // with additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().inMemoryGraph(config -> config.assumeCachedValuesAreImmutable(true)).build()) { "<AssertPlaceHolder>"; } }
create();
[*] target: assertNotNull(graph)
[-] pred: org. junit. Assert. assertNotNull ( graph )
************************************
************************************
[+] input: Exception { File directory = Files.createTempDirectory("chronodb-test").toFile(); try { // without additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().exodusGraph(directory.getAbsolutePath()).build()) { assertNotNull(graph); } // with additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().exodusGraph(directory.getAbsolutePath(), config -> config.assumeCachedValuesAreImmutable(true)).build()) { "<AssertPlaceHolder>"; } } finally { FileUtils.deleteDirectory(directory); } }
create();
[*] target: assertNotNull(graph)
[-] pred: org. junit. Assert. assertNotNull ( graph )
************************************
************************************
[+] input: canGeneratePerson() { Person person = PersonGenerator.generateRandomPerson(); "<AssertPlaceHolder>"; assertNotNull(person.getFirstName()); assertNotNull(person.getLastName()); assertTrue(person.getFirstName().length() > 0); assertTrue(person.getLastName().length() > 0); }
generateRandomPerson() { Person person = new Person(); person.setFirstName(TestUtils.getRandomEntryOf(FIRST_NAMES)); person.setLastName(TestUtils.getRandomEntryOf(LAST_NAMES)); person.setFavoriteColor(TestUtils.getRandomEntryOf(COLORS)); int numberOfHobbies = TestUtils.randomBetween(0, 3); int numberOfPets = TestUtils.randomBetween(0, 2); person.getHobbies().addAll(TestUtils.getRandomUniqueEntriesOf(HOBBIES, numberOfHobbies)); person.getPets().addAll(TestUtils.getRandomUniqueEntriesOf(PETS, numberOfPets)); return person; }
[*] target: assertNotNull(person)
[-] pred: org. junit. Assert. assertNotNull ( person )
************************************
************************************
[+] input: testNoMatchTransitWithResult() { Map<States, State<States, Events>> stateMap = new HashMap<>(); Transition<States, Events> newTransition = new TransitionImpl<>(); newTransition.setSource(StateHelper.getState(stateMap,States.STATE1)); newTransition.setTarget(StateHelper.getState(stateMap,States.STATE2)); newTransition.setEvent(Events.EVENT1); newTransition.setType(TransitionType.EXTERNAL); newTransition.setCondition(context -> false); Object result = newTransition.transitWithResult(new Object(), true); Assert."<AssertPlaceHolder>"; }
transitWithResult(C request, boolean checkCondition);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: IOException { ClassLoader classLoader = this.getClass().getClassLoader(); URL resource = classLoader.getResource("test.json"); File f = new File(resource.getPath()); String s = readString(f); StructuredDataEncoder structuredData = new StructuredDataEncoder(s); byte[] msgHash = structuredData.hashStructuredData(); String ownerAddress = "0xE10AA6471B33845FaE88DD7bBeB63c250DA3a639"; String sig = "4f4e0dec5f1d6f99460fea04bc374d96a495d96c0c455d4731902cdbf95525fc77c66ee08346466fe188f521c196f0f06bebb8d1a8df44cb68792514ca24808e2a"; byte[] signatureBytes = Hex.decode(sig); byte v = signatureBytes[64]; Sign.SignatureData sd = new Sign.SignatureData( v, Arrays.copyOfRange(signatureBytes, 0, 32), Arrays.copyOfRange(signatureBytes, 32, 64));  boolean verified = false; for (int i = 0; i < 4; i++) { BigInteger publicKey = Sign.recoverFromSignature( (byte) i, new ECDSASignature( new BigInteger(1, sd.getR()), new BigInteger(1, sd.getS())), msgHash);  if (publicKey != null) { String addressRecovered = Keys.toChecksumAddress(Keys.getAddress(publicKey)); if (addressRecovered.equals(ownerAddress)) { verified = true; break; } } } "<AssertPlaceHolder>"; }
getAddress(byte[] publicKey) { byte[] hash = new Keccak.Digest256().digest(publicKey); return Arrays.copyOfRange(hash, hash.length - 20, hash.length);  // right most 160 bits }
[*] target: assertTrue(verified)
[-] pred: org. junit. Assert. assertTrue ( verified )
************************************
************************************
[+] input: sizeObject_Empty_0() { JsonMetadataView view = new JsonMetadataView(new JsonObject(), String::compareTo); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, view.size())
[-] pred: org. junit. Assert. assertEquals ( 0, view. size() )
************************************
************************************
[+] input: sizeArray_Empty_0() { JsonMetadataView view = new JsonMetadataView(new JsonArray()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, view.size())
[-] pred: org. junit. Assert. assertEquals ( 0, view. size() )
************************************
************************************
[+] input: equals_SameColors_Symmetric() { int first = Color.pack(1, 2, 3, 4); int second = Color.pack(1, 2, 3, 4); "<AssertPlaceHolder>"; assertEquals(second, first); }
pack(int red, int green, int blue, int alpha) { checkComponent(red); checkComponent(green); checkComponent(blue); checkComponent(alpha); return (alpha << ALPHA_OFFSET) | (red << RED_OFFSET) | (green << GREEN_OFFSET) | (blue << BLUE_OFFSET); }
[*] target: assertEquals(first, second)
[-] pred: org. junit. Assert. assertEquals ( first, second )
************************************
************************************
[+] input: equals_SameColors_Transitive() { int first = Color.pack(1, 2, 3, 4); int second = Color.pack(1, 2, 3, 4); int third = Color.pack(1, 2, 3, 4); "<AssertPlaceHolder>"; assertEquals(second, third); assertEquals(first, third); }
pack(int red, int green, int blue, int alpha) { checkComponent(red); checkComponent(green); checkComponent(blue); checkComponent(alpha); return (alpha << ALPHA_OFFSET) | (red << RED_OFFSET) | (green << GREEN_OFFSET) | (blue << BLUE_OFFSET); }
[*] target: assertEquals(first, second)
[-] pred: org. junit. Assert. assertEquals ( first, second )
************************************
************************************
[+] input: construct_EmptyWidthArea_ConstructedCorrectly() { Area rect = new Area(0, 0, 0, 10); assertFalse(rect.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, rect.size())
[-] pred: org. junit. Assert. assertEquals ( 0, rect. size ( ) )
************************************
************************************
[+] input: construct_EmptyHeightArea_ConstructedCorrectly() { Area rect = new Area(0, 0, 10, 0); assertFalse(rect.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, rect.size())
[-] pred: org. junit. Assert. assertEquals ( 0, rect. size ( ) )
************************************
************************************
[+] input: list_SomeMatchAllFiltersClient_MatchingFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; assertTrue(resources.contains(ResourceLocation.parse("textures/hello.png"))); assertTrue(resources.contains(ResourceLocation.parse("textures/block/sea/rock/gravel.png"))); }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(2, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 2, resources. size ( ) )
************************************
************************************
[+] input: list_NoneMatchNamespace_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "other", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: list_NoneMatchPathStart_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "other", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: list_EmptyNamespace_NoExceptionIfOriginalAccepts() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: list_EmptyPathStart_NoExceptionIfOriginalAccepts() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; assertTrue(resources.contains(ResourceLocation.parse("textures/hello.png"))); assertTrue(resources.contains(ResourceLocation.parse("textures/block/sea/rock/gravel.png"))); }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(2, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 2, resources. size ( ) )
************************************
************************************
[+] input: list_NoneMatchFilter_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "textures", (file) -> file.endsWith(".jpg"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: listResources_PathStartDifferent_NoMatches() { List<ResourceCollection> collections = new ArrayList<>(); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/one.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("texture/two.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("text/three.png"))));  OrderedResourceRepository repository = new OrderedResourceRepository(PackType.CLIENT_RESOURCES, collections);  Collection<ResourceLocation> results = repository.list("ext", (file) -> true); "<AssertPlaceHolder>"; }
list(String pathStart, Predicate<String> fileFilter) { requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "Path filter cannot be null");  return COLLECTIONS.stream().flatMap( (collection) -> collection.namespaces(RESOURCE_TYPE).stream().flatMap( (namespace) -> collection.list(RESOURCE_TYPE, namespace, pathStart, fileFilter).stream() ) ).collect(Collectors.toSet()); }
[*] target: assertEquals(0, results.size())
[-] pred: org. junit. Assert. assertEquals ( 0, results. size ( ) )
************************************
************************************
[+] input: listResources_FilterNoMatch_NoMatches() { List<ResourceCollection> collections = new ArrayList<>(); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/one.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/two.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/three.png"))));  OrderedResourceRepository repository = new OrderedResourceRepository(PackType.CLIENT_RESOURCES, collections);  Collection<ResourceLocation> results = repository.list("textures", (file) -> file.endsWith(".jpg")); "<AssertPlaceHolder>"; }
list(String pathStart, Predicate<String> fileFilter) { requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "Path filter cannot be null");  return COLLECTIONS.stream().flatMap( (collection) -> collection.namespaces(RESOURCE_TYPE).stream().flatMap( (namespace) -> collection.list(RESOURCE_TYPE, namespace, pathStart, fileFilter).stream() ) ).collect(Collectors.toSet()); }
[*] target: assertEquals(0, results.size())
[-] pred: org. junit. Assert. assertEquals ( 0, results. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPack_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorNotPresent_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorBelow_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ), Set.of( "textures/bat_efgh.png" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorInSame_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta", "textures/bat_efgh.png" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorAbove_PackNotFound() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_efgh.png" ), Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  assertFalse( resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ).isPresent() );  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackSameAsFloor_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_abcd.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_InvalidMetadataDuringRead_LoadsValidTextures() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat.png", "textures/bat.png.moremcmeta", "textures/creeper.png", "textures/zombie.png", "textures/creeper.png.moremcmeta", "textures/zombie.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { if (metadataLocation.getPath().contains("creeper")) { throw new InvalidMetadataException("Dummy exception"); }  return MOCK_READER.parse(metadataLocation, metadataStream, resourceRepository); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures"); "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size() )
************************************
************************************
[+] input: load_SilencedInvalidMetadataDuringRead_LoadsValidTextures() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat.png", "textures/bat.png.moremcmeta", "textures/creeper.png", "textures/zombie.png", "textures/creeper.png.moremcmeta", "textures/zombie.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { if (metadataLocation.getPath().contains("creeper")) { throw new InvalidMetadataException("Dummy exception", new Exception(), true); }  return MOCK_READER.parse(metadataLocation, metadataStream, resourceRepository); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures"); "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size() )
************************************
************************************
[+] input: load_DiffFormatMetadataInPackWithTexture_Conflict() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/zombie.png.other"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/creeper.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: load_DiffFormatMetadataInPackAboveTexture_Conflict() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/creeper.png.other"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: width_WidthProvided_SameWidthReturned() { CloseableImageFrame frame = new CloseableImageFrame( new FrameReader.FrameData(100, 200, 0, 0), ImmutableList.of(new MockCloseableImage(100, 200)), 1 );  "<AssertPlaceHolder>"; }
width() { checkOpen(); return WIDTH; }
[*] target: assertEquals(100, frame.width())
[-] pred: org. junit. Assert. assertEquals ( 100, frame. width() )
************************************
************************************
[+] input: runTest() { final String key = "test key"; final String plainText = "hello world input"; final String encrypted = ARIA.encrypt(plainText, key); final String decrypted = ARIA.decrypt(encrypted, key); "<AssertPlaceHolder>"; }
decrypt(String input, String key) { org.apache.commons.codec.binary.Base64 base64 = new org.apache.commons.codec.binary.Base64(); String output = ""; try { SecretKeySpec secretKey = new SecretKeySpec(getKey(key), "ARIA"); Cipher cipher = Cipher.getInstance("ARIA"); cipher.init(Cipher.DECRYPT_MODE, secretKey); output = new String(cipher.doFinal(base64.decode(input.getBytes()))); } catch (GeneralSecurityException e) { e.printStackTrace(); return e.toString(); } return output; }
[*] target: assertEquals(plainText, decrypted)
[-] pred: org. junit. Assert. assertEquals ( plainText, decrypted )
************************************
************************************
[+] input: runTest() { final String key = "key for idea"; final String plainText = "Hello world input text"; final String encrypted = IDEA.encrypt(plainText, key); final String decrypted = IDEA.decrypt(encrypted, key);  "<AssertPlaceHolder>"; }
decrypt(String input, String key) { org.apache.commons.codec.binary.Base64 base64 = new org.apache.commons.codec.binary.Base64(); String output = ""; try { SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), "IDEA"); Cipher cipher = Cipher.getInstance("IDEA"); cipher.init(Cipher.DECRYPT_MODE, secretKey); output = new String(cipher.doFinal(base64.decode(input.getBytes()))); } catch (GeneralSecurityException e) { e.printStackTrace(); return e.toString(); } return output; }
[*] target: assertEquals(plainText, decrypted)
[-] pred: org. junit. Assert. assertEquals ( plainText, decrypted )
************************************
************************************
[+] input: Exception {  String PEMContentsOriginal = "-----BEGIN PUBLIC KEY-----\n" + "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEVQ6XXBFwG9mAqijwD2DN9Pgq62l0\n" + "oJmXwpptVDHsonyZ3Wl4J5DHBKfRVgD7KUPEwN9lEMjBqVGNSYbI7KP3mw==\n" + "-----END PUBLIC KEY-----";  PublicKey publicKey = PEMToKey.getPemPublicKey(PEMContentsOriginal, "ECDSA");  String PEMContents = PEM.PublicKeyToPEMFormat(publicKey);  "<AssertPlaceHolder>"; }
PublicKeyToPEMFormat(PublicKey publicKey) { return "-----BEGIN PUBLIC KEY-----\n" + new String(encoder.encode(publicKey.getEncoded())) + "\n-----END PUBLIC KEY-----"; }
[*] target: assertEquals(PEMContentsOriginal, PEMContents)
[-] pred: org. junit. Assert. assertEquals ( PEMContentsOriginal, PEMContents )
************************************
************************************
[+] input: testChoose() { Clorus p = new Clorus(2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Plip()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  assertEquals(expected, actual);  p = new Clorus(2); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Plip()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.ATTACK, Direction.TOP);  assertEquals(expected, actual);  p = new Clorus(1); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.REPLICATE, Direction.RIGHT);  assertEquals(expected, actual);  p = new Clorus(0.5); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.MOVE, Direction.RIGHT);  "<AssertPlaceHolder>"; }
chooseAction(Map<Direction, Occupant> neighbors) { List<Direction> empties = getNeighborsOfType(neighbors, "empty"); List<Direction> plip = getNeighborsOfType(neighbors, "plip");  if (empties.size() == 0) { return new Action(Action.ActionType.STAY); } else if (!plip.isEmpty()) { Direction moveDir = HugLifeUtils.randomEntry(plip); return new Action(Action.ActionType.ATTACK, moveDir); } else if (energy >= 1) { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.REPLICATE, moveDir); } else { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.MOVE, moveDir); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testChoose() { Plip p = new Plip(1.2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  //You can create new empties with new Empty(); //Despite what the spec says, you cannot test for Cloruses nearby yet. //Sorry!  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  "<AssertPlaceHolder>"; }
chooseAction(Map<Direction, Occupant> neighbors) { return new Action(Action.ActionType.STAY); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetClientValidAddress() { PeerClientPool pool = PeerClientPool.getInstance(); pool.setPort(PORT);  TraceServiceGrpc.TraceServiceBlockingStub client = pool.getClient(VALID_ADDRESS);  "<AssertPlaceHolder>"; }
getClient(final String address) { // TODO: Resolve to IP first, or is hostname good enough? return peerClients.computeIfAbsent(address, addr -> createGRPCClient(addr)); }
[*] target: assertNotNull(client)
[-] pred: org. junit. Assert. assertNotNull ( client )
************************************
************************************
[+] input: testInsert() { Temperature one = new Temperature(); one.setTs(new Timestamp(1605024000000l)); one.setTemperature(random.nextFloat() * 50); one.setLocation("望京"); int affectRows = mapper.insertOne(one); Assert."<AssertPlaceHolder>"; }
insertOne(Temperature one);
[*] target: assertEquals(1, affectRows)
[-] pred: org. junit. Assert. assertEquals ( 1, affectRows )
************************************
************************************
[+] input: testInsert() { Weather one = new Weather(); one.setTs(new Timestamp(1605024000000l)); one.setTemperature(random.nextFloat() * 50); one.setHumidity(random.nextInt(100)); one.setLocation("望京"); int affectRows = mapper.insert(one); Assert."<AssertPlaceHolder>"; }
insert(Weather weather);
[*] target: assertEquals(1, affectRows)
[-] pred: org. junit. Assert. assertEquals ( 1, affectRows )
************************************
************************************
[+] input: Exception { final Future<Socket> f = executor.submit(new Callable<Socket>() { public Socket call() throws Exception { return serverSocket.accept(); } }); assertBlocks(f); connect().getOutputStream().write(123); final Socket socket = f.get(); "<AssertPlaceHolder>"; assertEquals(123, socket.getInputStream().read()); }
connect() throws Exception { synchronized (lock) { final MockSocketConnection c = new MockSocketConnection(); connection = c.getSocketA(); lock.notifyAll(); while (connection != null) { lock.wait(); } return c.getSocketB(); } }
[*] target: assertNotNull(socket)
[-] pred: org. junit. Assert. assertNotNull ( socket )
************************************
************************************
[+] input: UnknownHostException { final InetAddress addr = controller.getInetAddress("*"); "<AssertPlaceHolder>"; }
getInetAddress(final String address) throws UnknownHostException { if ("*".equals(address)) { return null; } else { return InetAddress.getByName(address); } }
[*] target: assertNull(addr)
[-] pred: org. junit. Assert. assertNull ( addr )
************************************
************************************
[+] input: testGetNoMatchClasses() { MethodCoverageImpl m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 1); addClass(1, true, "Sample1", null, m);  m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 2); addClass(2, true, "Sample2", null, m);  m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 3); addClass(3, false, "Sample3", null, m);  final Set<String> actual = getNames(coverageBuilder.getNoMatchClasses()); final Set<String> expected = new HashSet<String>(Arrays.asList( "Sample1", "Sample2"));  "<AssertPlaceHolder>"; }
getNoMatchClasses() { final Collection<IClassCoverage> result = new ArrayList<>(); for (final IClassCoverage c : classes.values()) { if (c.isNoMatch()) { result.add(c); } } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ZipOutputStream zipout = new ZipOutputStream(buffer); zipout.putNextEntry(new ZipEntry("META-INF/MANIFEST.MF")); zipout.putNextEntry(new ZipEntry("META-INF/ALIAS.SF")); zipout.finish(); ByteArrayOutputStream out = new ByteArrayOutputStream();  int count = instrumenter.instrumentAll( new ByteArrayInputStream(buffer.toByteArray()), out, "Test");  "<AssertPlaceHolder>"; ZipInputStream zipin = new ZipInputStream(new ByteArrayInputStream( out.toByteArray())); assertEquals("META-INF/MANIFEST.MF", zipin.getNextEntry().getName()); assertNull(zipin.getNextEntry()); }
instrumentAll(final InputStream input, final OutputStream output, final String name) throws IOException { final ContentTypeDetector detector; try { detector = new ContentTypeDetector(input); } catch (final IOException e) { throw instrumentError(name, e); } switch (detector.getType()) { case ContentTypeDetector.CLASSFILE: instrument(detector.getInputStream(), output, name); return 1; case ContentTypeDetector.ZIPFILE: return instrumentZip(detector.getInputStream(), output, name); case ContentTypeDetector.GZFILE: return instrumentGzip(detector.getInputStream(), output, name); case ContentTypeDetector.PACK200FILE: return instrumentPack200(detector.getInputStream(), output, name); default: copy(detector.getInputStream(), output, name); return 0; } }
[*] target: assertEquals(0, count)
[-] pred: org. junit. Assert. assertEquals ( 0, count )
************************************
************************************
[+] input: IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ZipOutputStream zipout = new ZipOutputStream(buffer); zipout.putNextEntry(new ZipEntry("META-INF/ALIAS.SF")); zipout.finish(); ByteArrayOutputStream out = new ByteArrayOutputStream();  instrumenter.setRemoveSignatures(false); int count = instrumenter.instrumentAll( new ByteArrayInputStream(buffer.toByteArray()), out, "Test");  "<AssertPlaceHolder>"; ZipInputStream zipin = new ZipInputStream(new ByteArrayInputStream( out.toByteArray())); assertEquals("META-INF/ALIAS.SF", zipin.getNextEntry().getName()); assertNull(zipin.getNextEntry()); }
instrumentAll(final InputStream input, final OutputStream output, final String name) throws IOException { final ContentTypeDetector detector; try { detector = new ContentTypeDetector(input); } catch (final IOException e) { throw instrumentError(name, e); } switch (detector.getType()) { case ContentTypeDetector.CLASSFILE: instrument(detector.getInputStream(), output, name); return 1; case ContentTypeDetector.ZIPFILE: return instrumentZip(detector.getInputStream(), output, name); case ContentTypeDetector.GZFILE: return instrumentGzip(detector.getInputStream(), output, name); case ContentTypeDetector.PACK200FILE: return instrumentPack200(detector.getInputStream(), output, name); default: copy(detector.getInputStream(), output, name); return 0; } }
[*] target: assertEquals(0, count)
[-] pred: org. junit. Assert. assertEquals ( 0, count )
************************************
************************************
[+] input: testFixInstance() { ICounter c1 = CounterImpl.getInstance(30, 30); ICounter c2 = CounterImpl.getInstance(30, 30); "<AssertPlaceHolder>"; }
getInstance(final int missed, final int covered) { if (missed <= SINGLETON_LIMIT && covered <= SINGLETON_LIMIT) { return SINGLETONS[missed][covered]; } else { return new Var(missed, covered); } }
[*] target: assertSame(c1, c2)
[-] pred: org. junit. Assert. assertSame ( c1, c2 )
************************************
************************************
[+] input: testEquals1() { ICounter c1 = CounterImpl.getInstance(300, 123); ICounter c2 = CounterImpl.getInstance(300, 123); "<AssertPlaceHolder>"; }
getInstance(final int missed, final int covered) { if (missed <= SINGLETON_LIMIT && covered <= SINGLETON_LIMIT) { return SINGLETONS[missed][covered]; } else { return new Var(missed, covered); } }
[*] target: assertEquals(c1, c2)
[-] pred: org. junit. Assert. assertEquals ( c1, c2 )
************************************
************************************
[+] input: testEquals1() { line = line.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); LineImpl line2 = LineImpl.EMPTY; line2 = line2.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); "<AssertPlaceHolder>"; }
getInstance(final CounterImpl instructions, final CounterImpl branches) { final int im = instructions.getMissedCount(); final int ic = instructions.getCoveredCount(); final int bm = branches.getMissedCount(); final int bc = branches.getCoveredCount(); if (im <= SINGLETON_INS_LIMIT && ic <= SINGLETON_INS_LIMIT && bm <= SINGLETON_BRA_LIMIT && bc <= SINGLETON_BRA_LIMIT) { return SINGLETONS[im][ic][bm][bc]; } return new Var(instructions, branches); }
[*] target: assertEquals(line, line2)
[-] pred: org. junit. Assert. assertEquals ( line, line2 )
************************************
************************************
[+] input: Exception { generator = new OfflineInstrumentationAccessGenerator(); MethodRecorder actual = new MethodRecorder(); generator.generateDataAccessor(987654321, "foo/Bar", 17, actual.getVisitor());  MethodRecorder expected = new MethodRecorder(); expected.getVisitor().visitLdcInsn(Long.valueOf(987654321)); expected.getVisitor().visitLdcInsn("foo/Bar"); expected.getVisitor().visitIntInsn(Opcodes.BIPUSH, 17); String rtname = JaCoCo.RUNTIMEPACKAGE.replace('.', '/') + "/Offline"; expected.getVisitor().visitMethodInsn(Opcodes.INVOKESTATIC, rtname, "getProbes", "(JLjava/lang/String;I)[Z", false);  "<AssertPlaceHolder>"; }
generateDataAccessor(final long classid, final String classname, final int probecount, final MethodVisitor mv) { mv.visitLdcInsn(Long.valueOf(classid)); mv.visitLdcInsn(classname); InstrSupport.push(mv, probecount); mv.visitMethodInsn(Opcodes.INVOKESTATIC, runtimeClassName, "getProbes", "(JLjava/lang/String;I)[Z", false); return 4; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testMax0() { limit.setMaximum("0"); limit.setMaximum((String) null); "<AssertPlaceHolder>"; }
getMaximum() { return maximum == null ? null : maximum.toPlainString(); }
[*] target: assertNull(limit.getMaximum())
[-] pred: org. junit. Assert. assertNull ( limit. getMaximum() )
************************************
************************************
[+] input: testIsRootPage1() { "<AssertPlaceHolder>"; }
isRootPage() { return parent == null; }
[*] target: assertFalse(page.isRootPage())
[-] pred: org. junit. Assert. assertFalse ( page. isRootPage() )
************************************
************************************
[+] input: emptyListShouldNotFail() { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(new ArrayList<>(), null, null, null, false); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now, boolean withFederationGateway) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now, withFederationGateway); } }
[*] target: assertNull(theException)
[-] pred: org. junit. Assert. assertNull ( theException )
************************************
************************************
[+] input: Exception { Map<String, Object> values = new HashMap<String, Object>(); values.put("intValue", 1); values.put("booleanValue", true); values.put("stringArray", new String[] { "a", "b", "c" }); TypedMap map = new TypedMap(recordType, values);  map.clear(); "<AssertPlaceHolder>"; }
size() { return inner.size(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size ( ) )
************************************
************************************
[+] input: RepositoryException { PackageModel packageModelByPath = packageInfoService.getPackageModelByPath("/etc/packages/testGroup/testPackage-3.zip", resourceResolver);  "<AssertPlaceHolder>"; }
getPackageModelByPath(final String packagePath, final ResourceResolver resourceResolver) { final Session session = resourceResolver.adaptTo(Session.class); JcrPackageManager packMgr = basePackageService.getPackageManager(session);  JcrPackage jcrPackage = null; if (session == null) { return null; } try {  Node packageNode = session.getNode(packagePath); if (packageNode != null) { jcrPackage = packMgr.open(packageNode); return getPackageModel(jcrPackage); }  } catch (RepositoryException e) { LOGGER.error("Error during package opening", e); } finally { if (jcrPackage != null) { jcrPackage.close(); } } return null; }
[*] target: assertNull(packageModelByPath)
[-] pred: org. junit. Assert. assertNull ( packageModelByPath )
************************************
************************************
[+] input: shouldReturnFalseWithNonExistingPackage() { PackageInfoModel packageInfoModel = new PackageInfoModel(); packageInfoModel.setPackagePath(TEST_PACKAGE);  boolean result = packageInfoService.packageExists(resourceResolver, packageInfoModel);  "<AssertPlaceHolder>"; }
packageExists(ResourceResolver resourceResolver, PackageInfoModel packageInfoModel) { final Session session = resourceResolver.adaptTo(Session.class); final JcrPackageManager packageMgr = basePackageService.getPackageManager(session); try { List<Node> nodes = packageMgr.listPackages().stream().map(JcrPackage::getNode) .filter(Objects::nonNull).collect(Collectors.toList()); for (Node node : nodes) { if (node.getPath().equals(packageInfoModel.getPackagePath())) { return true; } } } catch (RepositoryException e) { LOGGER.error(String.format(BackpackConstants.PACKAGE_DOES_NOT_EXIST_MESSAGE, packageInfoModel.getPackagePath())); } return false; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: RepositoryException { PackageInfo packageInfo = getDefaultPackageInfo(); DefaultWorkspaceFilter defaultWorkspaceFilter = new DefaultWorkspaceFilter(); defaultWorkspaceFilter.add(new PathFilterSet(PAGE_1)); createPackage(packageInfo, defaultWorkspaceFilter);  PackageInfoModel packageInfoModel = new PackageInfoModel(); packageInfoModel.setPackagePath(PACKAGE_PATH);  boolean result = packageInfoService.packageExists(resourceResolver, packageInfoModel);  "<AssertPlaceHolder>"; }
packageExists(ResourceResolver resourceResolver, PackageInfoModel packageInfoModel) { final Session session = resourceResolver.adaptTo(Session.class); final JcrPackageManager packageMgr = basePackageService.getPackageManager(session); try { List<Node> nodes = packageMgr.listPackages().stream().map(JcrPackage::getNode) .filter(Objects::nonNull).collect(Collectors.toList()); for (Node node : nodes) { if (node.getPath().equals(packageInfoModel.getPackagePath())) { return true; } } } catch (RepositoryException e) { LOGGER.error(String.format(BackpackConstants.PACKAGE_DOES_NOT_EXIST_MESSAGE, packageInfoModel.getPackagePath())); } return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testFoo() { String targetClassName = Foo.class.getCanonicalName(); GetStaticGraph graph = GetStaticGraphGenerator .generate(targetClassName);  Set<String> expectedClasses = new HashSet<String>(Arrays.asList( Foo.class.getCanonicalName(), Bar1.class.getCanonicalName(), Bar2.class.getCanonicalName(), Bar3.class.getCanonicalName(), Bar4.class.getCanonicalName(), Bar5.class.getCanonicalName(), Bar6.class.getCanonicalName(), Bar7.class.getCanonicalName(), BarBar1.class.getCanonicalName()));  Set<String> allClasses = new HashSet<String>(); allClasses.addAll(graph.getSourceClasses()); allClasses.addAll(graph.getTargetClasses());  assertEquals(expectedClasses, allClasses);  Map<String, Set<String>> expectedStaticFields = new HashMap<String, Set<String>>(); expectedStaticFields.put(Bar2.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar2"))); expectedStaticFields.put(Bar6.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar6"))); expectedStaticFields.put(Bar7.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar7")));  Map<String, Set<String>> staticFields = graph.getStaticFields(); "<AssertPlaceHolder>"; }
getStaticFields() { Map<String, Set<String>> staticFields = new LinkedHashMap<String, Set<String>>(); for (StaticFieldReadEntry read : this.staticFieldReads) { String className = read.getTargetClass().replace('/', '.'); if (!staticFields.containsKey(className)) { staticFields.put(className, new LinkedHashSet<String>()); } staticFields.get(className).add(read.getTargetField()); } return staticFields; }
[*] target: assertEquals(expectedStaticFields, staticFields)
[-] pred: org. junit. Assert. assertEquals ( expectedStaticFields, staticFields )
************************************
************************************
[+] input: testMazeSolution() {  int ret_val = MazeClient.walk('s', 's', 's', 's', 'd', 'd', 'd', 'd', 'w', 'w', 'a', 'a', 'w', 'w', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 'd', 'd', 'w', 'w', 'w', 'w', (char) 0, (char) 0, 28); "<AssertPlaceHolder>"; }
walk(char move0, char move1, char move2, char move3, char move4, char move5, char move6, char move7, char move8, char move9, char move10, char move11, char move12, char move13, char move14, char move15, char move16, char move17, char move18, char move19, char move20, char move21, char move22, char move23, char move24, char move25, char move26, char move27, char move28, char move29, int moveLength) {  char[] moves = new char[] {move0, move1, move2, move3, move4, move5, move6, move7, move8, move9, move10, move11, move12, move13, move14, move15, move16, move17, move18, move19, move20, move21, move22, move23, move24, move25, move26, move27, move28, move29};  return walk(moves, moveLength); }
[*] target: assertEquals(1, ret_val)
[-] pred: org. junit. Assert. assertEquals ( 1, ret_val )
************************************
************************************
[+] input: ClassNotFoundException { Properties.DSE_SOLVER = Properties.SolverType.EVOSUITE_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: ClassNotFoundException { String cvc4_path = System.getenv("cvc4_path"); if (cvc4_path != null) { Properties.CVC4_PATH = cvc4_path; } Assume.assumeTrue(Properties.CVC4_PATH!=null); Properties.DSE_SOLVER = Properties.SolverType.CVC4_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: testConfirmToString() { String res = new OverrideToString().toString(); String diff = res + " a different string";  OverrideToString obj = mock(OverrideToString.class); when(obj.toString()).thenReturn(diff);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(diff, obj.toString())
[-] pred: org. junit. Assert. assertEquals ( diff, obj. toString ( ) )
************************************
************************************
[+] input: testRingTopology_leftNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 2);  Chromosome exepcted_individual = population.get(1); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testRingTopology_rightNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 2);  Chromosome exepcted_individual = population.get(3); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testRingTopology_mostLeftNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 0);  Chromosome exepcted_individual = population.get(15); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testRingTopology_mostRightNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 15);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(1); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(9); Chromosome returned_individual = neighbors.get(1);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(6); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(4); Chromosome returned_individual = neighbors.get(3);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(10); Chromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(8); Chromosome returned_individual = neighbors.get(5);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthNorthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 10);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(8);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthSouthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 10);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(9);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testEastEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 10);  Chromosome exepcted_individual = population.get(8); Chromosome returned_individual = neighbors.get(10);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testWestWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 5);  Chromosome exepcted_individual = population.get(7); Chromosome returned_individual = neighbors.get(11);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 0);  Chromosome exepcted_individual = population.get(15); Chromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 3);  Chromosome exepcted_individual = population.get(12); Chromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostSouthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 12);  Chromosome exepcted_individual = population.get(3); Chromosome returned_individual = neighbors.get(5);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 15);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testInitializeClasses() {   EvoClassLoader loader = new EvoClassLoader(); String className = "com.examples.with.different.packagename.classhandling.TimeA"; //no mocking RuntimeSettings.deactivateAllMocking(); boolean problem = ClassStateSupport.initializeClasses(loader, className); Assert.assertFalse(problem);  //with mocking RuntimeSettings.mockJVMNonDeterminism = true; className = "com.examples.with.different.packagename.classhandling.TimeB"; problem = ClassStateSupport.initializeClasses(loader,className); Assert."<AssertPlaceHolder>"; }
initializeClasses(ClassLoader classLoader, String... classNames) {  boolean problem = false;  List<Class<?>> classes = loadClasses(classLoader, classNames); if(classes.size() != classNames.length) { problem = true; }  initialiseExternalTools(classLoader, classes);  if(RuntimeSettings.isUsingAnyMocking()) {  for (Class<?> clazz : classes) {  if(clazz.isInterface()) { /* FIXME: once we ll start to support Java 8, in which interfaces can have code, we ll need to instrument them as well */ continue; }  if (!InstrumentedClass.class.isAssignableFrom(clazz)) { String msg = "Class " + clazz.getName() + " was not instrumented by EvoSuite. " + "This could happen if you are running JUnit tests in a way that is not handled by EvoSuite, in " + "which some classes are loaded be reflection before the tests are run. Consult the EvoSuite documentation " + "for possible workarounds for this issue."; logger.error(msg); problem = true; //throw new IllegalStateException(msg); // throwing an exception might be a bit too extreme } } }  return problem;  //retransformIfNeeded(classes); // cannot do it, as retransformation does not really work :( }
[*] target: assertFalse(problem)
[-] pred: org. junit. Assert. assertFalse ( problem )
************************************
************************************
[+] input: testDoubleInit() { int n = ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks();  Runtime.getRuntime().addShutdownHook(new Thread(){});  //this should remove the above hook thread ShutdownHookHandler.getInstance().initHandler();  Assert."<AssertPlaceHolder>"; }
getNumberOfAllExistingHooks() { if(hooksReference==null) { return -1; } return hooksReference.size(); }
[*] target: assertEquals(n, ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks())
[-] pred: org. junit. Assert. assertEquals ( n, ShutdownHookHandler.getInstance ( ). getNumberOfAllExistingHooks() )
************************************
************************************
[+] input: testHibernateConfiguration() { EntityManagerFactory factory = MockPersistence.createEntityManagerFactory("foo"); EntityManager em = factory.createEntityManager(); factory.close(); Assert."<AssertPlaceHolder>"; }
createEntityManagerFactory(String persistenceUnitName) { return DBManager.getInstance().getDefaultFactory(); }
[*] target: assertNotNull(em)
[-] pred: org. junit. Assert. assertNotNull ( em )
************************************
************************************
[+] input: testGetCurrentDirectory() {  JFileChooser chooser = new MockJFileChooser(); File dir = chooser.getCurrentDirectory();  Assert."<AssertPlaceHolder>"; Assert.assertTrue(dir instanceof MockFile); }
getCurrentDirectory() { return currentDirectory; }
[*] target: assertTrue(dir.exists())
[-] pred: org. junit. Assert. assertTrue ( dir. exists ( ) )
************************************
************************************
[+] input: Exception {  EvoSuiteLocalAddress addr = new EvoSuiteLocalAddress("127.42.42.42",42); NetworkHandling.sendDataOnTcp(addr,null);  MockServerSocket sut = new MockServerSocket(addr.getPort(), 1, MockInetAddress.getByName(addr.getHost())); Socket socket = sut.accept(); //should not block, should not timeout Assert."<AssertPlaceHolder>"; }
sendDataOnTcp(EvoSuiteLocalAddress sutServer, byte[] data){ if(sutServer==null){ return false; }  NativeTcp connection = VirtualNetwork.getInstance().registerIncomingTcpConnection( DEFAULT_REMOTE_ADDRESS, VirtualNetwork.getInstance().getNewRemoteEphemeralPort(), sutServer.getHost(), sutServer.getPort());  /* * At this point in time the SUT has not opened a connection yet (if it did, * it would had thrown an IOException). * But we can already put the message on the buffer */  if(data != null){ for(byte b : data){ connection.writeToSUT(b); } } //TODO close connection? or should rather be in another helper function?  return true; }
[*] target: assertNotNull(socket)
[-] pred: org. junit. Assert. assertNotNull ( socket )
************************************
************************************
[+] input: Exception { String text = "Hello World!"; EvoSuiteURL url = new EvoSuiteURL("http://evosuite.org/hello.txt");  NetworkHandling.createRemoteTextFile(url,text);  URL mock = MockURL.URL(url.getUrl()); URLConnection connection = mock.openConnection(); Scanner in = new Scanner(connection.getInputStream()); String res = in.nextLine(); Assert."<AssertPlaceHolder>"; }
createRemoteTextFile(EvoSuiteURL url, String text){ if(url == null){ return false; } return VirtualNetwork.getInstance().addRemoteTextFile(url.getUrl(),text); }
[*] target: assertEquals(text,res)
[-] pred: org. junit. Assert. assertEquals ( text, res )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_FORWARDING_ROUTING_V4); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_FORWARDING_NOP_ROUTING_V4) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder().wipeDeferred().build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_FORWARDING_ROUTING_V4); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_FORWARDING_DROP_ROUTING_V4) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_ACL_ACL); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_ACL_NOP_ACL) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .wipeDeferred() .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_ACL_ACL); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_ACL_DROP) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { //     TrafficTreatment treatment = DefaultTrafficTreatment.builder() //             .setOutput(PORT_1) //             .build(); //     PiAction mappedAction = interpreter.mapTreatment( //             treatment, P4InfoConstants.FABRIC_INGRESS_NEXT_SIMPLE); //     PiActionParam param = new PiActionParam(P4InfoConstants.PORT_NUM, PORT_1.toLong()); //     PiAction expectedAction = PiAction.builder() //             .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_OUTPUT_SIMPLE) //             .withParameter(param) //             .build(); //     "<AssertPlaceHolder>"; // }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .setVlanId(VLAN_100) .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_NEXT_VLAN); PiActionParam vlanParam = new PiActionParam( P4InfoConstants.VLAN_ID, VLAN_100.toShort()); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_SET_VLAN) .withParameter(vlanParam) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .setMpls(MPLS_10) .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_NEXT_MPLS); PiActionParam mplsParam = new PiActionParam( P4InfoConstants.LABEL, MPLS_10.toInt()); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_SET_MPLS_LABEL) .withParameter(mplsParam) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: FabricPipelinerException { TrafficTreatment treatment1 = DefaultTrafficTreatment.builder() .setOutput(PORT_1) .build(); TrafficTreatment treatment2 = DefaultTrafficTreatment.builder() .popVlan() .setOutput(PORT_2) .build(); NextObjective nextObjective = DefaultNextObjective.builder() .withId(NEXT_ID_1) .withPriority(PRIORITY) .addTreatment(treatment1) .addTreatment(treatment2) .withMeta(VLAN_META) .withType(NextObjective.Type.BROADCAST) .makePermanent() .fromApp(APP_ID) .add();  ObjectiveTranslation actualTranslation = translatorHashed.doTranslate(nextObjective);  // Should generate 3 flows: // - Multicast table flow that matches on next-id and set multicast group (1) // - Egress VLAN pop handling for treatment2 (0) // - Next VLAN flow (2) // And 2 groups: // - Multicast group  // Expected multicast table flow rule. PiCriterion nextIdCriterion = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_NEXT_ID, NEXT_ID_1) .build(); TrafficSelector nextIdSelector = DefaultTrafficSelector.builder() .matchPi(nextIdCriterion) .build(); PiAction setMcGroupAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_SET_MCAST_GROUP_ID) .withParameter(new PiActionParam( P4InfoConstants.GROUP_ID, NEXT_ID_1)) .build(); TrafficTreatment treatment = DefaultTrafficTreatment.builder() .piTableAction(setMcGroupAction) .build(); FlowRule expectedHashedFlowRule = DefaultFlowRule.builder() .forDevice(DEVICE_ID) .fromApp(APP_ID) .makePermanent() .withPriority(nextObjective.priority()) .forTable(P4InfoConstants.FABRIC_INGRESS_NEXT_MULTICAST) .withSelector(nextIdSelector) .withTreatment(treatment) .build();  // Expected egress VLAN_PUSH flow rule. PiCriterion egressVlanTableMatch = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_EG_PORT, PORT_1.toLong()) .build(); TrafficSelector selectorForEgressVlan = DefaultTrafficSelector.builder() .matchPi(egressVlanTableMatch) .matchVlanId(VLAN_100) .build(); PiAction piActionForEgressVlan = PiAction.builder() .withId(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_PUSH_VLAN) .build(); TrafficTreatment treatmentForEgressVlan = DefaultTrafficTreatment.builder() .piTableAction(piActionForEgressVlan) .build(); FlowRule expectedEgressVlanPushRule = DefaultFlowRule.builder() .withSelector(selectorForEgressVlan) .withTreatment(treatmentForEgressVlan) .forTable(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_EGRESS_VLAN) .makePermanent() .withPriority(nextObjective.priority()) .forDevice(DEVICE_ID) .fromApp(APP_ID) .build();  // Expected egress VLAN POP flow rule. egressVlanTableMatch = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_EG_PORT, PORT_2.toLong()) .build(); selectorForEgressVlan = DefaultTrafficSelector.builder() .matchPi(egressVlanTableMatch) .matchVlanId(VLAN_100) .build(); piActionForEgressVlan = PiAction.builder() .withId(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_POP_VLAN) .build(); treatmentForEgressVlan = DefaultTrafficTreatment.builder() .piTableAction(piActionForEgressVlan) .build(); FlowRule expectedEgressVlanPopRule = DefaultFlowRule.builder() .withSelector(selectorForEgressVlan) .withTreatment(treatmentForEgressVlan) .forTable(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_EGRESS_VLAN) .makePermanent() .withPriority(nextObjective.priority()) .forDevice(DEVICE_ID) .fromApp(APP_ID) .build();  // Expected ALL group. TrafficTreatment allGroupTreatment1 = DefaultTrafficTreatment.builder() .setOutput(PORT_1) .build(); TrafficTreatment allGroupTreatment2 = DefaultTrafficTreatment.builder() .setOutput(PORT_2) .build(); List<TrafficTreatment> allTreatments = ImmutableList.of( allGroupTreatment1, allGroupTreatment2); List<GroupBucket> allBuckets = allTreatments.stream() .map(DefaultGroupBucket::createAllGroupBucket) .collect(Collectors.toList()); GroupBuckets allGroupBuckets = new GroupBuckets(allBuckets); GroupKey allGroupKey = new DefaultGroupKey(FabricUtils.KRYO.serialize(NEXT_ID_1)); GroupDescription expectedAllGroup = new DefaultGroupDescription( DEVICE_ID, GroupDescription.Type.ALL, allGroupBuckets, allGroupKey, NEXT_ID_1, APP_ID );  ObjectiveTranslation expectedTranslation = ObjectiveTranslation.builder() .addFlowRule(expectedHashedFlowRule) .addFlowRule(vlanMetaFlowRule) .addFlowRule(expectedEgressVlanPushRule) .addFlowRule(expectedEgressVlanPopRule) .addGroup(expectedAllGroup) .build();  "<AssertPlaceHolder>"; }
doTranslate(NextObjective obj) throws FabricPipelinerException {  final ObjectiveTranslation.Builder resultBuilder = ObjectiveTranslation.builder();  switch (obj.type()) { case SIMPLE: simpleNext(obj, resultBuilder, false); break; case HASHED: hashedNext(obj, resultBuilder); break; case BROADCAST: if (isXconnect(obj)) { // TODO: re-enable support for xconnext // xconnectNext(obj, resultBuilder); log.warn("Xconnect not supported [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); } else { multicastNext(obj, resultBuilder); } break; default: log.warn("Unsupported NextObjective type [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); }  if (!isGroupModifyOp(obj)) { // Generate next VLAN rules. nextMpls(obj, resultBuilder); nextVlan(obj, resultBuilder); }  return resultBuilder.build(); }
[*] target: assertEquals(expectedTranslation, actualTranslation)
[-] pred: org. junit. Assert. assertEquals ( expectedTranslation, actualTranslation )
************************************
************************************
[+] input: Exception { qifParserTest.should_parse_multiple_accounts(); doImport();  List<Account> accounts = db.getAllAccountsList(); "<AssertPlaceHolder>";  Account a = accounts.get(0); assertEquals("My Bank Account", a.title); assertEquals(AccountType.BANK.name(), a.type);  List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id); assertEquals(2, transactions.size());  TransactionInfo t = transactions.get(0); assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime); assertEquals(-2000, t.fromAmount);  t = transactions.get(1); assertEquals(DateTime.date(2011, 1, 2).atMidnight().asLong(), t.dateTime); assertEquals(5400, t.fromAmount);  a = accounts.get(1); assertEquals("My Cash Account", a.title); assertEquals(AccountType.CASH.name(), a.type);  transactions = db.getTransactionsForAccount(a.id); assertEquals(3, transactions.size());  t = transactions.get(0); assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime); assertEquals(1000, t.fromAmount);  t = transactions.get(1); assertEquals(DateTime.date(2011, 2, 7).atMidnight().asLong(), t.dateTime); assertEquals(-2345, t.fromAmount);  t = transactions.get(2); assertEquals(DateTime.date(2011, 1, 1).atMidnight().asLong(), t.dateTime); assertEquals(-6780, t.fromAmount); }
doImport() throws IOException { long t0 = System.currentTimeMillis(); QifBufferedReader r = new QifBufferedReader(new BufferedReader(new InputStreamReader(new FileInputStream(options.filename), "UTF-8"))); QifParser parser = new QifParser(r, options.dateFormat); parser.parse(); long t1 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Parsing done in "+ TimeUnit.MILLISECONDS.toSeconds(t1-t0)+"s"); doImport(parser); long t2 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Importing done in "+ TimeUnit.MILLISECONDS.toSeconds(t2-t1)+"s"); }
[*] target: assertEquals(2, accounts.size())
[-] pred: org. junit. Assert. assertEquals ( 2, accounts. size ( ) )
************************************
************************************
[+] input: formatHijriDate() { String str = UiUtils.formatHijriDate(10, "Safar", 1415); "<AssertPlaceHolder>"; }
formatHijriDate(int day, String monthName, int year) { NumberFormat numberFormat = NumberFormat.getInstance(); String date = numberFormat.format(day) + " " + monthName + " " + numberFormat.format(year); return date.replaceAll("[٬،.,]", ""); }
[*] target: assertNotNull(str)
[-] pred: org. junit. Assert. assertNotNull ( str )
************************************
************************************
[+] input: getFirstLine() { // assign variables with test data String expectedLine = "First Line";  // allocate test objects StackTrace stackTrace = new StackTrace(expectedLine, null);  // execute methods to be tested String actualLine = stackTrace.getFirstLine();  // assign result Assert."<AssertPlaceHolder>"; }
getFirstLine() { return this.firstLine; }
[*] target: assertEquals(expectedLine, actualLine)
[-] pred: org. junit. Assert. assertEquals ( expectedLine, actualLine )
************************************
************************************
[+] input: getUser() { User user = userMapper.selectByUsername("admin"); Assert."<AssertPlaceHolder>"; }
selectByUsername(@Param("username") String username);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getJobConfigById() { JobConfigDTO jobConfigDTO = jobConfigService.getJobConfigById(1L); System.out.println(jobConfigDTO); Assert."<AssertPlaceHolder>"; }
getJobConfigById(Long id);
[*] target: assertNotNull(jobConfigDTO)
[-] pred: org. junit. Assert. assertNotNull ( jobConfigDTO )
************************************
************************************
[+] input: queryJobConfig() { JobConfigParam jobConfigParam=new JobConfigParam(); jobConfigParam.setPageNum(2); PageModel<JobConfigDTO> pageModel = jobConfigService.queryJobConfig(jobConfigParam); Assert."<AssertPlaceHolder>"; }
queryJobConfig(JobConfigParam jobConfigParam);
[*] target: assertNotNull(pageModel)
[-] pred: org. junit. Assert. assertNotNull ( pageModel )
************************************
************************************
[+] input: checkLogin() { String cookieId = userService.login("admin", "123456"); Assert."<AssertPlaceHolder>"; }
login(String userName, String password);
[*] target: assertNotNull(cookieId)
[-] pred: org. junit. Assert. assertNotNull ( cookieId )
************************************
************************************
[+] input: testClear() { GitHubDataCache<String> cache = new GitHubDataCache<>();  String data = "data to be cached"; GitHubProject project = new GitHubProject(new GitHubOrganization(data), data); cache.put(project, data); assertEquals(1, cache.size()); String cached = cache.get(project).orElseThrow(RuntimeException::new); assertEquals(data, cached);  // fill out the cache for (int i = 1, cacheSize = cache.size(); cacheSize < cache.maxSize(); cacheSize++, i++) { project = new GitHubProject(String.format("org%d", i), String.format("project%d", i)); data = String.format("data%d", i); cache.put(project, data); }  assertEquals(cache.size(), cache.maxSize());  cache.clear(); "<AssertPlaceHolder>"; }
size() { return entries.size(); }
[*] target: assertEquals(0, cache.size())
[-] pred: org. junit. Assert. assertEquals ( 0, cache. size ( ) )
************************************
************************************
[+] input: testOssSecurityRatingIsImmutable() { Rating rating = RatingRepository.INSTANCE.rating(OssSecurityRating.class); "<AssertPlaceHolder>"; ImmutabilityChecker checker = new ImmutabilityChecker(); rating.accept(checker); assertTrue(checker.allImmutable()); }
rating(Class<T> clazz) { Objects.requireNonNull(clazz, "You just gave me a null instead of class!");  Rating rating = ratings.get(clazz); if (rating == null) { throw new IllegalArgumentException( String.format("Oh no! Could not find %s", clazz.getCanonicalName())); }  return clazz.cast(rating); }
[*] target: assertNotNull(rating)
[-] pred: org. junit. Assert. assertNotNull ( rating )
************************************
************************************
[+] input: testValue() { EnumFeature<TestEnum> feature = new EnumFeature<>(TestEnum.class, "test"); EnumValue<TestEnum> value = feature.value(TestEnum.A); "<AssertPlaceHolder>"; assertSame(feature, value.feature()); assertSame(TestEnum.A, value.get()); }
value(T object) { return new EnumValue<>(this, object); }
[*] target: assertNotNull(value)
[-] pred: org. junit. Assert. assertNotNull ( value )
************************************
************************************
[+] input: testEqualsAndHashCode() { GitHubOrganization firstOrg = new GitHubOrganization("first"); GitHubOrganization theSameOrg = new GitHubOrganization("first"); assertTrue(firstOrg.equals(theSameOrg) && theSameOrg.equals(firstOrg)); "<AssertPlaceHolder>";  GitHubOrganization anotherOrg = new GitHubOrganization("another"); assertNotEquals(anotherOrg, firstOrg); }
hashCode() { return Objects.hash(super.hashCode(), name); }
[*] target: assertEquals(firstOrg.hashCode(), theSameOrg.hashCode())
[-] pred: org. junit. Assert. assertEquals ( firstOrg. hashCode ( ), theSameOrg. hashCode ( ) )
************************************
************************************
[+] input: IOException { ArtifactVersion version = new ArtifactVersion("2.0.2", LocalDateTime.now()); ArtifactVersion clone = Json.read(Json.toBytes(version), ArtifactVersion.class); assertTrue(version.equals(clone) && clone.equals(version)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(version, releaseDate); }
[*] target: assertEquals(version.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( version. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { ArtifactVersion version = new ArtifactVersion("MIGHTY-1.2", LocalDateTime.now()); ArtifactVersion clone = Yaml.read(Yaml.toBytes(version), ArtifactVersion.class); assertTrue(version.equals(clone) && clone.equals(version)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(version, releaseDate); }
[*] target: assertEquals(version.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( version. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { PackageManagersFeature feature = new PackageManagersFeature("test"); PackageManagersValue value = new PackageManagersValue( feature, new PackageManagers(PackageManager.MAVEN, PackageManager.OTHER)); PackageManagersValue clone = Json.read(Json.toBytes(value), PackageManagersValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), packageManagers); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { SecurityReview review = new SecurityReview(TEST_REVIEW_DATE, 0.0); SecurityReview clone = Yaml.read(Json.toBytes(review), SecurityReview.class); assertTrue(review.equals(clone) && clone.equals(review)); assertEquals(review.hashCode(), clone.hashCode());  review = new SecurityReview(TEST_REVIEW_DATE, null); clone = Yaml.read(Json.toBytes(review), SecurityReview.class); assertTrue(review.equals(clone) && clone.equals(review)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(date, changes); }
[*] target: assertEquals(review.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( review. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { StringFeature feature = new StringFeature("test"); StringValue value = new StringValue(feature, "2.3.3"); StringValue clone = Json.read(Json.toBytes(value), StringValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), content); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: testWithCustomTemplate() {  // Needed to ensure that decimal points are exactly as expected below... Locale.setDefault(new Locale("en", "US"));  RatingValue ratingValue = RATING.calculate(TEST_VALUES); GitHubProject project = new GitHubProject("org", "test"); project.set(ratingValue);  String template = "%RATING_LABEL%|%SCORE_VALUE%|%MAX_SCORE%|%CONFIDENCE_LABEL%" + "|%CONFIDENCE_VALUE%|%MAX_CONFIDENCE%|%MAIN_SCORE_NAME%" + "|%MAIN_SCORE_DESCRIPTION%|%MAIN_SCORE_EXPLANATION%";  OssSecurityRatingMarkdownFormatter formatter = new OssSecurityRatingMarkdownFormatter(new OssSecurityGithubAdvisor(), template); String text = formatter.print(project);  "<AssertPlaceHolder>"; assertEquals("BAD|3.4|10.0|Max|10.0|10.0|security score for open-source projects||", text); }
print(Subject subject) { if (!subject.ratingValue().isPresent()) { return StringUtils.EMPTY; }  MarkdownElement advice = markdownAdviceFor(subject); RatingValue ratingValue = subject.ratingValue().get(); ScoreValue scoreValue = ratingValue.scoreValue();  return template .replaceAll("%MAX_SCORE%", formatted(Score.MAX)) .replaceAll("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%SCORE_VALUE%", formatted(scoreValue.get())) .replace("%RATING_LABEL%", ratingValue.label().name()) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%MAIN_SCORE_NAME%", scoreValue.score().name().toLowerCase()) .replace("%MAIN_SCORE_VALUE_DETAILS%", highLevelDescriptionOf(scoreValue).make()) .replace("%MAIN_SCORE_DESCRIPTION%", scoreValue.score().description()) .replace("%MAIN_SCORE_EXPLANATION%", explanationOf(scoreValue).make()) .replace("%SUB_SCORE_DETAILS%", descriptionOfSubScoresIn(scoreValue).make()) .replace("%ADVICE%", advice.make()) .replace("%INFO_ABOUT_VULNERABILITIES%", infoAboutVulnerabilitiesIn(scoreValue).make()); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: Exception {  String userId = "u00001"; String password = "123456"; String keyName = "testKey";  PkeyInfoVO pkeyInfoVO = keysManagerService.createPrivateKey(userId, password, keyName) ; EncryptKeyInfo encryptKey = keysManagerService.getEncryptPrivateKeyByUserIdAndAddress(userId, pkeyInfoVO.getKeyAddress()); String privateKey = keysManagerService.decryptPrivateKey(password, encryptKey.getEncryptKey());  String msg = "test message"; String signStr = signatureService.sign(msg, privateKey); String publicKey = addressHandler.computePublicKey(Numeric.hexStringToByteArray(privateKey)); boolean checkResult = signatureService.verify(msg, signStr, publicKey);  Assert."<AssertPlaceHolder>"; }
verify(String msg, String signStr, String publicKey){ return privateKeySigner.verify(msg, signStr, publicKey); }
[*] target: assertTrue(checkResult)
[-] pred: org. junit. Assert. assertTrue ( checkResult )
************************************
************************************
[+] input: testAnyLabelEqualToWildcardLabel() { Label testLabel = new Label("Test");  WildcardLabel wildcardLabel = new WildcardLabel();  "<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) return true; if (o == null) return false; if (o.getClass() == WildcardLabel.class) return true; if (getClass() != o.getClass()) return false; Label label1 = (Label) o; return label.equals(label1.label); }
[*] target: assertTrue(testLabel.equals(wildcardLabel))
[-] pred: org. junit. Assert. assertTrue ( testLabel. equals ( wildcardLabel ) )
************************************
************************************
[+] input: testToStringEdgePatternWithLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"Does"}); EdgePattern edgePattern = new EdgePattern(null, label, null, Direction.LEFT_TO_RIGHT, 1);  String expectedResult = "(->, nil, {{Does}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringEdgePatternWithLabelConjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Does", "AreColleagues"}); EdgePattern edgePattern = new EdgePattern(null, labelSetList, null, Direction.UNDIRECTED, 1);  String expectedResult = "(-, nil, {{Does, AreColleagues}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringEdgePatternWithLabelDisjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"AreColleagues"}); addLabelSetTo(labelSetList, new String[]{"Does"}); EdgePattern edgePattern = new EdgePattern(null, labelSetList, null, Direction.LEFT_TO_RIGHT, 1);  String expectedResult = "(->, nil, {{AreColleagues}, {Does}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"Person"}); NodePattern nodePattern = new NodePattern(null, label, null);  String expectedResult = "(nil, {{Person}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithLabelConjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); NodePattern nodePattern = new NodePattern(null, labelSetList, null);  String expectedResult = "(nil, {{Person, Professor}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithLabelDisjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); addLabelSetTo(labelSetList, new String[]{"Internship"}); NodePattern nodePattern = new NodePattern(null, labelSetList, null);  String expectedResult = "(nil, {{Person, Professor}, {Internship}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithProperty() { HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); NodePattern nodePattern = new NodePattern(null, null, properties);  String expectedResult = "(nil, {}, {(name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithProperties() { HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); properties.put(new GqlIdentifier("studies"), new GqlString("Data Science")); NodePattern nodePattern = new NodePattern(null, null, properties);  String expectedResult = "(nil, {}, {(studies: "Data Science"), (name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithIdAndLabelsAndProperties() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); addLabelSetTo(labelSetList, new String[]{"Internship"});  HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); properties.put(new GqlIdentifier("studies"), new GqlString("Data Science"));  NodePattern nodePattern = new NodePattern(new VariableName("x"), labelSetList, properties);  String expectedResult = "(x, {{Person, Professor}, {Internship}}, {(studies: "Data Science"), (name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithWildCardLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"%"}); NodePattern nodePattern = new NodePattern(null, label, null);  String expectedResult = "(nil, {{%}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testEmptyPathSequence() { PathSequence pathSequence = new PathSequence(pathSequenceList); assertTrue(pathSequence.pathSequence.isEmpty()); "<AssertPlaceHolder>"; }
size() { return this.pathSequence.size(); }
[*] target: assertEquals(0, pathSequence.size())
[-] pred: org. junit. Assert. assertEquals ( 0, pathSequence. size ( ) )
************************************
************************************
[+] input: binaryExpressionTest() { // Create the mock data. Map<String, Object> argMaps = createBinaryFilterArgMap("firstName", "contains", "ABC");  // Invoke method under test. FilterExpressionParser expressionParser = new FilterExpressionParser(); Expression expression = expressionParser.parseFilterExpression(argMaps);  // Verify assertions. Assert."<AssertPlaceHolder>"; Assert.assertEquals("(firstName contains ABC)", expression.infix()); }
parseFilterExpression(Map filterArgs) { return createExpressionTree(filterArgs); }
[*] target: assertNotNull(expression)
[-] pred: org. junit. Assert. assertNotNull ( expression )
************************************
************************************
[+] input: compoundExpressionTest() { // Create the mock data. Map<String, Object> argMaps = createCompoundFilterArgMap();  // Invoke method under test. FilterExpressionParser expressionParser = new FilterExpressionParser(); Expression expression = expressionParser.parseFilterExpression(argMaps);  // Verify assertions. Assert."<AssertPlaceHolder>"; Assert.assertEquals("((firstName contains ABC) or (lastName equals XYZ))", expression.infix()); }
parseFilterExpression(Map filterArgs) { return createExpressionTree(filterArgs); }
[*] target: assertNotNull(expression)
[-] pred: org. junit. Assert. assertNotNull ( expression )
************************************
************************************
[+] input: IOException { String webpathStr = "projects/foo/location/earth/datasets/bar/dicomStores/" + "fee/dicomWeb/studies/abc/series/xyz/instances/123";  WebPathParser parser = new WebPathParser(); WebPathParser.DicomWebPath dicomWebPath = parser.parseDicomWebpath(webpathStr);  Assert."<AssertPlaceHolder>"; Assert.assertEquals("foo", dicomWebPath.project); Assert.assertEquals("earth", dicomWebPath.location); Assert.assertEquals("bar", dicomWebPath.dataset); Assert.assertEquals("fee", dicomWebPath.storeId); Assert.assertEquals("abc", dicomWebPath.studyId); Assert.assertEquals("xyz", dicomWebPath.seriesId); Assert.assertEquals("123", dicomWebPath.instanceId); Assert.assertEquals( "projects/foo/location/earth/datasets/bar/dicomStores/fee", dicomWebPath.dicomStorePath); }
parseDicomWebpath(String unparsedWebpath) throws IOException { String[] webPathSplit = unparsedWebpath.split("/dicomWeb/");  if (webPathSplit.length != 2) { throw new IOException("Invalid DICOM web path"); }  DicomWebPath dicomWebPath = new DicomWebPath();  dicomWebPath.dicomStorePath = webPathSplit[0]; String[] storePathElements = dicomWebPath.dicomStorePath.split("/");  if (storePathElements.length < 8) { throw new IOException("Invalid DICOM web path"); } dicomWebPath.project = storePathElements[1]; dicomWebPath.location = storePathElements[3]; dicomWebPath.dataset = storePathElements[5]; dicomWebPath.storeId = storePathElements[7];  String[] searchParameters; searchParameters = webPathSplit[1].split("/"); if (searchParameters.length < 6) { throw new IOException("Invalid DICOM web path"); } dicomWebPath.studyId = searchParameters[1]; dicomWebPath.seriesId = searchParameters[3]; dicomWebPath.instanceId = searchParameters[5];  return dicomWebPath; }
[*] target: assertNotNull(dicomWebPath)
[-] pred: org. junit. Assert. assertNotNull ( dicomWebPath )
************************************
************************************
[+] input: testExtractMessages_MacbookProUnderflow() { final Data raw = Data.fromHexEncodedString("02011a0aff4c001005031c0b4c"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertNull(messages)
[-] pred: org. junit. Assert. assertNull ( messages )
************************************
************************************
[+] input: testMatch_iPhoneX_F() { final Data raw = Data.fromHexEncodedString("02011A020A0C0BFF4C001006071EA3DD89E014FF4C0001000000000000000000002000000000000000000000000000000000000000000000000000000000"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; assertEquals("1006071EA3DD89E0", messages.get(0).hexEncodedString()); assertEquals("0100000000000000000000200000000000", messages.get(1).hexEncodedString()); }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertEquals(2, messages.size())
[-] pred: org. junit. Assert. assertEquals ( 2, messages. size ( ) )
************************************
************************************
[+] input: testDeserializePrimitives() { Schema schema = new Schema(required(1, "string_type", Types.StringType.get()), required(2, "int_type", Types.IntegerType.get()), required(3, "long_type", Types.LongType.get()), required(4, "boolean_type", Types.BooleanType.get()), required(5, "float_type", Types.FloatType.get()), required(6, "double_type", Types.DoubleType.get()), required(7, "date_type", Types.DateType.get()));  List<?> expected = Arrays.asList("foo", 12, 3000L, true, 3.01F, 3.0D, "1998-11-13");  Record record = TestHelpers.createCustomRecord(schema, expected); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> result = (List<Object>) serDe.deserialize(writable);  "<AssertPlaceHolder>"; }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testDeserializeNestedList() { Schema schema = new Schema(required(1, "map_type", Types.MapType .ofRequired(18, 19, Types.StringType.get(), Types.ListType.ofRequired(17, Types.LongType.get())))); Map<String, List> expected = ImmutableMap.of("foo", Arrays.asList(1000L, 2000L, 3000L)); List<Map> data = new ArrayList<>(); data.add(expected);  Record record = TestHelpers.createCustomRecord(schema, data); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> deserialized = (List<Object>) serDe.deserialize(writable); Map result = (Map) deserialized.get(0);  "<AssertPlaceHolder>"; assertTrue(result.containsKey("foo")); assertTrue(result.containsValue(Arrays.asList(1000L, 2000L, 3000L))); }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: extractWarehouseLocationRegularTable() { // This is the style of input expected from HiveConf String testLocation = "some/folder/database/table_a"; String testTableName = "database.table_a";  String expected = "some/folder/"; String result = TableResolverUtil.extractWarehousePath(testLocation, testTableName);  "<AssertPlaceHolder>"; }
extractWarehousePath(String location, String tableName) { String tablePath = tableName.replaceAll("\\.","/").replaceAll(SNAPSHOT_TABLE_SUFFIX, ""); return location.replaceAll(tablePath, ""); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: extractPropertyFromJobConf() { JobConf conf = new JobConf(); String key = "iceberg.catalog"; String value = "hadoop.tables";  conf.set(key, value);  String result = TableResolverUtil.extractProperty(conf, key);  "<AssertPlaceHolder>"; }
extractProperty(JobConf conf, String key) { String value = conf.get(key); if (value == null) { throw new IllegalArgumentException("Property not set in JobConf: " + key); } return value; }
[*] target: assertEquals(value, result)
[-] pred: org. junit. Assert. assertEquals ( value, result )
************************************
************************************
[+] input: testBssidSeen() { String protocol = "http"; String bssid = "dk/aau/netsec/hostage/fragment"; record.setProtocol(protocol); record.setBssid(bssid);  daoSession.insert(record);  boolean bssidSeen = attackRecordDAO.bssidSeen(protocol,bssid);  "<AssertPlaceHolder>"; }
bssidSeen(String protocol, String BSSID) { if(BSSID == null || protocol == null){ return false; } AttackRecordDao recordDao = this.daoSession.getAttackRecordDao();  QueryBuilder<AttackRecord> qb = recordDao.queryBuilder(); qb.where(AttackRecordDao.Properties.Protocol.eq(protocol),AttackRecordDao.Properties.Bssid.eq(BSSID)); List<AttackRecord> records = qb.list();  return !records.isEmpty(); }
[*] target: assertTrue(bssidSeen)
[-] pred: org. junit. Assert. assertTrue ( bssidSeen )
************************************
************************************
[+] input: testNullClass() { Config config = UnitTestBase.updateWithRequiredOptions( ComputerOptions.WORKER_COMBINER_CLASS, Null.class.getName() ); Object combiner = config.createObject( ComputerOptions.WORKER_COMBINER_CLASS, false); Assert."<AssertPlaceHolder>"; }
createObject(ConfigOption<Class<?>> clazzOption, boolean requiredNotNull) { Class<?> clazz = this.get(clazzOption); if (clazz == Null.class) { if (requiredNotNull) { throw new ComputerException( "Please config required option '%s'", clazzOption.name()); } return null; } try { @SuppressWarnings("unchecked") T instance = (T) clazz.newInstance(); return instance; } catch (Exception e) { throw new ComputerException("Failed to create object for option " + "'%s', class='%s'", e, clazzOption.name(), clazz.getName()); } }
[*] target: assertNull(combiner)
[-] pred: org. junit. Assert. assertNull ( combiner )
************************************
************************************
[+] input: testHashCode() { InputStruct inputStruct = Mockito.mock(InputStruct.class); FileInputSplit split1 = new FileInputSplit(ElemType.VERTEX, inputStruct, "/tmp/test"); FileInputSplit split2 = new FileInputSplit(ElemType.VERTEX, inputStruct, "/tmp/test"); Assert."<AssertPlaceHolder>"; }
hashCode() { return Objects.hashCode(super.hashCode(), this.type, this.path, this.struct); }
[*] target: assertEquals(split1.hashCode(), split2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( split1. hashCode(), split2. hashCode() )
************************************
************************************
[+] input: testRemoteConnectionIDWithNull() { Channel channel = null; ConnectionId connectionId = TransportUtil.remoteConnectionId(channel); Assert.assertNull(connectionId);  Channel channel2 = new EmbeddedChannel(); channel2.close(); ConnectionId connectionId2 = TransportUtil.remoteConnectionId(channel2); Assert."<AssertPlaceHolder>"; }
remoteConnectionId(Channel channel) { if (channel == null || channel.remoteAddress() == null) { return null; } InetSocketAddress address = (InetSocketAddress) channel.remoteAddress(); return ConnectionId.parseConnectionId(address.getHostName(), address.getPort()); }
[*] target: assertNull(connectionId2)
[-] pred: org. junit. Assert. assertNull ( connectionId2 )
************************************
************************************
[+] input: IOException { NettyTransportClient client = (NettyTransportClient) this.oneClient(); ConnectionId connectionId = ConnectionId.parseConnectionId(host, port); ConnectionId clientConnectionId = client.connectionId(); Assert."<AssertPlaceHolder>"; }
connectionId() { return this.connectionId; }
[*] target: assertEquals(connectionId, clientConnectionId)
[-] pred: org. junit. Assert. assertEquals ( connectionId, clientConnectionId )
************************************
************************************
[+] input: IOException { NettyTransportClient client = (NettyTransportClient) this.oneClient(); client.startSession();  Mockito.doThrow(new RuntimeException("test exception")).when(serverHandler) .handle(Mockito.any(), Mockito.anyInt(), Mockito.any());  ByteBuffer buffer = ByteBuffer.wrap(StringEncodeUtil.encode("test data")); boolean send = client.send(MessageType.MSG, 1, buffer); Assert."<AssertPlaceHolder>";  Whitebox.setInternalState(client, "timeoutFinishSession", 1000L);  Assert.assertThrows(TransportException.class, client::finishSession, e -> { Assert.assertContains("finish-response", e.getMessage()); });  Mockito.verify(serverHandler, Mockito.timeout(10_000L).times(1)) .exceptionCaught(Mockito.any(), Mockito.any()); }
send(MessageType messageType, int partition, ByteBuffer buffer) throws TransportException { if (!this.checkSendAvailable()) { return false; } this.session.sendAsync(messageType, partition, buffer); return true; }
[*] target: assertTrue(send)
[-] pred: org. junit. Assert. assertTrue ( send )
************************************
************************************
[+] input: testSubmitJob() { Map<String, String> params = new HashMap<>(); params.put(KubeSpecOptions.WORKER_INSTANCES.name(), "10"); String jobId = this.driver.submitJob("PageRank", params); HugeGraphComputerJob computerJob = this.operation.withName(KubeUtil.crName(jobId)).get(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(computerJob.getSpec().getAlgorithmName(), "PageRank"); Assert.assertEquals(computerJob.getSpec().getJobId(), jobId); }
submitJob(String algorithmName, Map<String, String> params) { HugeGraphComputerJob computerJob = new HugeGraphComputerJob(); String jobId = KubeUtil.genJobId(algorithmName); String crName = KubeUtil.crName(jobId);  ObjectMeta meta = new ObjectMetaBuilder().withNamespace(this.namespace) .withName(crName) .build(); computerJob.setMetadata(meta);  ComputerJobSpec spec = this.computerJobSpec(this.defaultSpec, params);  Map<String, String> computerConf = this.computerConf(this.defaultConf, params); this.checkComputerConf(computerConf, spec);  spec.withAlgorithmName(algorithmName) .withJobId(jobId) .withComputerConf(computerConf);  if (this.enableInternalAlgorithm && this.internalAlgorithms.contains(algorithmName)) { spec.withImage(this.internalAlgorithmImageUrl); } else if (StringUtils.isNotBlank(spec.getRemoteJarUri())) { spec.withImage(this.frameworkImageUrl); } else { String imageUrl = this.buildImageUrl(algorithmName); String jarFileDir = this.conf.get(KubeDriverOptions.JAR_FILE_DIR); String jarFile = this.buildJarFile(jarFileDir, algorithmName); spec.withImage(imageUrl) .withJarFile(jarFile); }  computerJob.setSpec(spec);  this.operation.createOrReplace(computerJob); return jobId; }
[*] target: assertNotNull(computerJob)
[-] pred: org. junit. Assert. assertNotNull ( computerJob )
************************************
************************************
[+] input: testEstimate() { OptimizationContext optimizationContext = mock(OptimizationContext.class); when(optimizationContext.getConfiguration()).thenReturn(new Configuration());  CardinalityEstimator partialEstimator1 = new DefaultCardinalityEstimator(0.9, 1, false, cards -> cards[0] * 2); CardinalityEstimator partialEstimator2 = new DefaultCardinalityEstimator(0.8, 1, false, cards -> cards[0] * 3); CardinalityEstimator estimator = new AggregatingCardinalityEstimator( Arrays.asList(partialEstimator1, partialEstimator2) );  CardinalityEstimate inputEstimate = new CardinalityEstimate(10, 100, 0.3); CardinalityEstimate outputEstimate = estimator.estimate(optimizationContext, inputEstimate); CardinalityEstimate expectedEstimate = new CardinalityEstimate(2 * 10, 2 * 100, 0.3 * 0.9);  Assert."<AssertPlaceHolder>"; }
estimate(OptimizationContext optimizationContext, CardinalityEstimate... inputEstimates) { // Simply use the estimate with the highest correctness probability. // TODO: Check if this is a good way. There are other palpable approaches (e.g., weighted average). return this.alternativeEstimators.stream() .map(alternativeEstimator -> alternativeEstimator.estimate(optimizationContext, inputEstimates)) .sorted((estimate1, estimate2) -> Double.compare(estimate2.getCorrectnessProbability(), estimate1.getCorrectnessProbability())) .findFirst() .orElseThrow(IllegalStateException::new); }
[*] target: assertEquals(expectedEstimate, outputEstimate)
[-] pred: org. junit. Assert. assertEquals ( expectedEstimate, outputEstimate )
************************************
************************************
[+] input: testDAGShapedSubplan() { // _/-\_ //  \ / final DataSetType<String> stringDataSetType = DataSetType.createDefault(String.class); TestMapOperator<String, String> map1 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map1.setName("map1"); TestMapOperator<String, String> map2 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map2.setName("map2"); TestMapOperator<String, String> map3 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map3.setName("map3"); TestJoin<String, String, String> join1 = new TestJoin<>(stringDataSetType, stringDataSetType, stringDataSetType); join1.setName("join1"); TestMapOperator<String, String> map4 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map4.setName("map4");  map1.connectTo(0, map2, 0); map1.connectTo(0, map3, 0); map2.connectTo(0, join1, 0); map3.connectTo(0, join1, 1); join1.connectTo(0, map4, 0);  Subplan subplan = (Subplan) Subplan.wrap(map1, map4); OptimizationContext optimizationContext = new DefaultOptimizationContext(this.job, subplan); final OptimizationContext.OperatorContext subplanCtx = optimizationContext.getOperatorContext(subplan); final CardinalityEstimate inputCardinality = new CardinalityEstimate(10, 100, 0.9d); subplanCtx.setInputCardinality(0, inputCardinality); subplan.propagateInputCardinality(0, subplanCtx);  final CardinalityPusher pusher = SubplanCardinalityPusher.createFor(subplan, this.configuration); pusher.push(subplanCtx, this.configuration);  final CardinalityEstimate outputCardinality = subplanCtx.getOutputCardinality(0); final CardinalityEstimate expectedCardinality = new CardinalityEstimate(10 * 10, 100 * 100, 0.9d * 0.7d); Assert."<AssertPlaceHolder>"; }
createFor(OperatorContainer container, Configuration configuration) { final CompositeOperator compositeOperator = container.toOperator(); final InputSlot<?>[] outerInputs = compositeOperator.getAllInputs(); final List<InputSlot<?>> innerInputs = Arrays.stream(outerInputs) .flatMap(inputSlot -> container.followInput(inputSlot).stream()) .collect(Collectors.toList()); final Collection<Operator> sourceOperators = compositeOperator.isSource() ? Collections.singleton(container.getSource()) : Collections.emptySet(); final CardinalityEstimationTraversal traversal = CardinalityEstimationTraversal.createPushTraversal( innerInputs, sourceOperators, configuration);  return new SubplanCardinalityPusher(traversal, compositeOperator); }
[*] target: assertEquals(expectedCardinality, outputCardinality)
[-] pred: org. junit. Assert. assertEquals ( expectedCardinality, outputCardinality )
************************************
************************************
[+] input: shouldFailOnInvalidInput() { Collection<String> expressions = Arrays.asList( // TODO: For some reason this is not failing on my machine //"2x", "f(x,)", "~3", "", "*2", "f(3, x" ); for (String expression : expressions) { boolean isFailed = false; try { ExpressionBuilder.parse(expression); } catch (ParseException e) { isFailed = true; } finally { Assert."<AssertPlaceHolder>"; } } }
parse(String specification) throws ParseException { MathExLexer lexer = new MathExLexer(new ANTLRInputStream(specification)); lexer.removeErrorListeners(); lexer.addErrorListener(new BaseErrorListener() { @Override public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) { throw new ParseException("Syntax error.", e); } }); MathExParser parser = new MathExParser(new CommonTokenStream(lexer));  // Suppress console output on errors. Throw exceptions instead. parser.removeErrorListeners(); parser.addErrorListener(new BaseErrorListener() { @Override public void syntaxError(Recognizer<?, ?> recognizer, Object o, int i, int i1, String s, RecognitionException e) { throw new ParseException("Syntax error.", e); }  }); MathExParser.ExpressionContext expressionContext = parser.expression();  return new ExpressionBuilder().visit(expressionContext); }
[*] target: assertTrue(isFailed)
[-] pred: org. junit. Assert. assertTrue ( isFailed )
************************************
************************************
[+] input: Exception { final String topicPath = DEFAULT_TENANT + InlongConstants.SLASH + DEFAULT_NAMESPACE + InlongConstants.SLASH + "testGetPartitionedTopicMetadata"; PulsarUtils.createPartitionedTopic(client, pulsarCluster, topicPath, DEFAULT_PARTITIONS_NUM); Thread.sleep(500); PulsarTopicMetadata metadata = PulsarUtils.getPartitionedTopicMetadata(client, pulsarCluster, topicPath); "<AssertPlaceHolder>"; }
getPartitionedTopicMetadata(RestTemplate restTemplate, PulsarClusterInfo clusterInfo, String topicPath) throws Exception { return HttpUtils.request(restTemplate, clusterInfo.getAdminUrls(QUERY_PERSISTENT_PATH + "/" + topicPath + "/partitions"), HttpMethod.GET, null, getHttpHeaders(clusterInfo.getToken()), PulsarTopicMetadata.class); }
[*] target: assertNotNull(metadata)
[-] pred: org. junit. Assert. assertNotNull ( metadata )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.COLLECTION_NAME, "STRING METADATA FROM 'collection_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'database_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'op_ts' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_DEBEZIUM, "BYTES METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_DEBEZIUM, "STRING METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); MongoExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.COLLECTION_NAME, MetaField.DATABASE_NAME, MetaField.OP_TS, MetaField.DATA_DEBEZIUM, MetaField.DATA_BYTES_DEBEZIUM, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'meta.database_name' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'meta.schema_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.op_ts' VIRTUAL"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'meta.op_type' VIRTUAL"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES, "BYTES METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'meta.is_ddl' VIRTUAL"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.ts' VIRTUAL"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'meta.sql_type' VIRTUAL"); formatMap.put(MetaField.ORACLE_TYPE, "MAP<STRING, STRING> METADATA FROM 'meta.oracle_type' VIRTUAL"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'meta.pk_names' VIRTUAL"); OracleExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS, MetaField.OP_TYPE, MetaField.DATA, MetaField.DATA_BYTES, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL, MetaField.IS_DDL, MetaField.TS, MetaField.SQL_TYPE, MetaField.ORACLE_TYPE, MetaField.PK_NAMES); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'meta.database_name' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'meta.schema_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.op_ts' VIRTUAL"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'meta.op_type' VIRTUAL"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_DEBEZIUM, "STRING METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES, "BYTES METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_DEBEZIUM, "BYTES METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'meta.is_ddl' VIRTUAL"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.ts' VIRTUAL"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'meta.sql_type' VIRTUAL"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'meta.pk_names' VIRTUAL"); PostgresExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS, MetaField.OP_TYPE, MetaField.DATA, MetaField.DATA_BYTES, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL, MetaField.DATA_DEBEZIUM, MetaField.DATA_BYTES_DEBEZIUM, MetaField.IS_DDL, MetaField.TS, MetaField.SQL_TYPE, MetaField.PK_NAMES); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'database_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'op_ts' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'schema_name' VIRTUAL"); SqlServerExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'value.data_canal'"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'value.data_canal'"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'value.table'"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'value.database'"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'value.type'"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'value.event-timestamp'"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'value.is-ddl'"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'value.ingestion-timestamp'"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'value.sql-type'"); formatMap.put(MetaField.MYSQL_TYPE, "MAP<STRING, STRING> METADATA FROM 'value.mysql-type'"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'value.pk-names'"); formatMap.put(MetaField.BATCH_ID, "BIGINT METADATA FROM 'value.batch-id'"); formatMap.put(MetaField.UPDATE_BEFORE, "ARRAY<MAP<STRING, STRING>> METADATA FROM 'value.update-before'"); KafkaLoadNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.OP_TYPE, MetaField.DATABASE_NAME, MetaField.SQL_TYPE, MetaField.PK_NAMES, MetaField.TS, MetaField.OP_TS, MetaField.IS_DDL, MetaField.MYSQL_TYPE, MetaField.BATCH_ID, MetaField.UPDATE_BEFORE, MetaField.DATA_CANAL, MetaField.DATA); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testSchemaDeserializationSchema() { final JsonRowDataDeserializationSchema expectedDeser = JsonRowDataDeserializationSchema.builder(PHYSICAL_TYPE, InternalTypeInfo.of(PHYSICAL_TYPE)).build();  final DynamicTableSource actualSource = createTableSource(SCHEMA, getAllOptions()); assert actualSource instanceof TestDynamicTableFactory.DynamicTableSourceMock; TestDynamicTableFactory.DynamicTableSourceMock scanSourceMock = (TestDynamicTableFactory.DynamicTableSourceMock) actualSource;  DeserializationSchema<RowData> actualDeser = scanSourceMock.valueFormat.createRuntimeDecoder( ScanRuntimeProviderContext.INSTANCE, SCHEMA.toPhysicalRowDataType());  "<AssertPlaceHolder>"; }
createRuntimeDecoder( DynamicTableSource.Context context, DataType physicalDataType) { final RowType rowType = (RowType) physicalDataType.getLogicalType(); final TypeInformation<RowData> rowDataTypeInfo = context.createTypeInformation(physicalDataType); JsonRowDataDeserializationSchema.Builder builder = JsonRowDataDeserializationSchema.builder(rowType, rowDataTypeInfo); return builder .setFailOnMissingField(formatOptions.get(TextFormatOptions.FAIL_ON_MISSING_FIELD)) .setIgnoreParseErrors(formatOptions.get(TableFormatOptions.IGNORE_ERRORS)) .setTimestampFormat(formatOptions.get(TextFormatOptions.TIMESTAMP_FORMAT)) .setCharset(formatOptions.get(TextFormatOptions.CHARSET)) .setObjectMapperConfig(formatOptions) .build(); }
[*] target: assertEquals(expectedDeser, actualDeser)
[-] pred: org. junit. Assert. assertEquals ( expectedDeser, actualDeser )
************************************
************************************
[+] input: testSchemaSerializationSchema() { final JsonRowDataSerializationSchema expectedSer = JsonRowDataSerializationSchema.builder(PHYSICAL_TYPE).build();  final DynamicTableSink actualSink = createTableSink(SCHEMA, getAllOptions()); assert actualSink instanceof TestDynamicTableFactory.DynamicTableSinkMock; TestDynamicTableFactory.DynamicTableSinkMock sinkMock = (TestDynamicTableFactory.DynamicTableSinkMock) actualSink;  SerializationSchema<RowData> actualSer = sinkMock.valueFormat.createRuntimeEncoder( new SinkRuntimeProviderContext(false), PHYSICAL_DATA_TYPE);  "<AssertPlaceHolder>"; }
createRuntimeEncoder( DynamicTableSink.Context context, DataType physicalDataType) { RowType rowType = (RowType) physicalDataType.getLogicalType(); JsonRowDataSerializationSchema.Builder builder = JsonRowDataSerializationSchema.builder(rowType); return builder .setMapNullKeyMode(formatOptions.get(TextFormatOptions.MAP_NULL_KEY_MODE)) .setMapNullKeyLiteral(formatOptions.get(TextFormatOptions.MAP_NULL_KEY_LITERAL)) .setTimestampFormat(formatOptions.get(TextFormatOptions.TIMESTAMP_FORMAT)) .setCharset(formatOptions.get(TextFormatOptions.CHARSET)) .setIgnoreErrors(formatOptions.get(TableFormatOptions.IGNORE_ERRORS)) .setObjectMapperConfig(formatOptions) .build(); }
[*] target: assertEquals(expectedSer, actualSer)
[-] pred: org. junit. Assert. assertEquals ( expectedSer, actualSer )
************************************
************************************
[+] input: IOException { JsonRowDataSerializationSchema.Builder serBuilder = JsonRowDataSerializationSchema.builder(rowType); JsonRowDataSerializationSchema serializationSchema = serBuilder.setCharset(CHARSET.defaultValue()) .setTimestampFormat(ISO_8601) .build(); byte[] serialize = serializationSchema.serialize(testRowData);  ObjectMapper objectMapper = new ObjectMapper(); JsonNode expectedNode = objectMapper.readTree(testJson); JsonNode actualNode = objectMapper.readTree(new String(serialize)); "<AssertPlaceHolder>"; assertFalse(serializationSchema.skipCurrentRecord(testRowData)); }
build() { return new JsonRowDataSerializationSchema( rowType, timestampFormat, mapNullKeyMode, mapNullKeyLiteral, charset, objectMapper, ignoreErrors); }
[*] target: assertEquals(expectedNode, actualNode)
[-] pred: org. junit. Assert. assertEquals ( expectedNode, actualNode )
************************************
************************************
[+] input: Exception { TubeClientConfig clientConfig = mock(TubeClientConfig.class); PowerMockito.mockStatic(AddressUtils.class); PowerMockito.when(AddressUtils.getLocalAddress()).thenReturn("127.0.0.1");  when(clientConfig.getMasterInfo()).thenReturn(new MasterInfo("127.0.0.1:18080")); ConsumerConfig config = new ConsumerConfig("127.0.0.1:18080", "test"); ClientFactory clientFactory = new NettyClientFactory(); TubeBaseSessionFactory factory = new TubeBaseSessionFactory(clientFactory, clientConfig); SimplePushMessageConsumer consumer = new SimplePushMessageConsumer(factory, config); MessageFetchManager fetchManager = new MessageFetchManager(config, consumer);  Assert.assertFalse(fetchManager.isShutdown()); fetchManager.startFetchWorkers(); fetchManager.stopFetchWorkers(true); Assert."<AssertPlaceHolder>"; }
isShutdown() { return this.managerStatus.get() == 0; }
[*] target: assertTrue(fetchManager.isShutdown())
[-] pred: org. junit. Assert. assertTrue ( fetchManager. isShutdown() )
************************************
************************************
[+] input: Exception { Map<String, String> map = new HashMap<String, String>(); map.put("h1", "1");  PowerMockito.doReturn(401).when(connection).getResponseCode(); PowerMockito.doReturn(new ByteArrayOutputStream()).when(connection).getOutputStream(); PowerMockito.doReturn(new ByteArrayInputStream("{}".getBytes())).when(connection).getInputStream(); HttpClientTest response = new HttpClient("http://localhost") .path("/api") .param(map) .header(map) .timeout(100) .body(new ByteArrayInputStream(new byte[]{})) .get(HttpClientTest.class); Assert."<AssertPlaceHolder>"; }
get(Class<T> returnType) { return requestRetryTimes("GET", returnType); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: Exception { Map<String, String> map = new HashMap<String, String>(); map.put("h1", "1");  PowerMockito.doReturn(401).when(connection).getResponseCode(); PowerMockito.doReturn(new ByteArrayOutputStream()).when(connection).getOutputStream(); PowerMockito.doReturn(new ByteArrayInputStream("{}".getBytes())).when(connection).getInputStream();  InputStream inputStreamBody = Mockito.spy(new ByteArrayInputStream(new byte[]{})); Mockito.doThrow(new IOException()).when(inputStreamBody).close();  HttpClientTest response = new HttpClient("http://localhost") .path("/api") .param(map) .header(map) .timeout(100) .body(inputStreamBody) .post(HttpClientTest.class); Assert."<AssertPlaceHolder>"; }
post(Class<T> returnType) { return requestRetryTimes("POST", returnType); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: Exception { File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.isAbsolute()).thenReturn(true);  DirFileScanner scanner = Mockito.mock(DirFileScanner.class); PowerMockito.whenNew(DirFileScanner.class).withAnyArguments().thenReturn(scanner); Mockito.when(scanner.scan(Mockito.anyString())).thenReturn(Arrays.asList("f1"));  Artifact artifact = new Artifact(); artifact.setPatternType(PatternType.DIR);  FileUploader fileUploader = new FileUploader() { @Override public void upload(File file, String toFile) { } };  int filesCount = new JobArtifact("u1", "ws", new SaAsyncLogger("uuid", true)) .artifact(artifact) .fileUploader(fileUploader) .toDir("d1") .upload();  Assert."<AssertPlaceHolder>"; }
upload() { FileScanner scanner; String fromDir = this.ws; switch (artifact.getPatternType()) { case DIR: if (new File(artifact.getFilePattern()).isAbsolute()) { fromDir = artifact.getFilePattern(); } else { fromDir = fromDir + File.separator + artifact.getFilePattern(); } // 当路径所指的目标是单文件时，直接读取单上传文件。 if (new File(fromDir).exists() && new File(fromDir).isFile()) { String fileName = FilenameUtils.getName(FilenameUtils.normalizeNoEndSeparator(fromDir)); String toFile = uuid + "/" + toDir + "/" + fileName; jobAsyncLogger.log("INFO", "single file uploading..."); fileUploader.upload(new File(fromDir), toFile); return 1; } scanner = new DirFileScanner(artifact.getFilePattern()); break; case ANT: scanner = new AntFileScanner(artifact.getFilePattern()); break; default: throw new AgentException("Not supported file pattern type:" + artifact.getPatternType()); } List<String> files = scanner.scan(ws); if (CollectionUtils.isEmpty(files)) { return 0; } new FilesUploader(jobAsyncLogger) .fromDir(fromDir) .files(files) .toDir(uuid + "/" + toDir) .fileUploader(fileUploader).upload(); return files.size(); }
[*] target: assertEquals(1, filesCount)
[-] pred: org. junit. Assert. assertEquals ( 1, filesCount )
************************************
************************************
[+] input: Exception {  File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.isAbsolute()).thenReturn(false); Mockito.when(file.exists()).thenReturn(true); Mockito.when(file.isFile()).thenReturn(true);  DirFileScanner scanner = Mockito.mock(DirFileScanner.class); PowerMockito.whenNew(DirFileScanner.class).withAnyArguments().thenReturn(scanner); Mockito.when(scanner.scan(Mockito.anyString())).thenReturn(Arrays.asList("f1"));  Artifact artifact = new Artifact(); artifact.setFilePattern("/sss/sss"); artifact.setPatternType(PatternType.DIR); new SaAsyncLogger("uuid", true); FileUploader fileUploader = new FileUploader() { @Override public void upload(File file, String toFile) { } };  int filesCount = new JobArtifact("u1", "ws", new SaAsyncLogger("uuid", true)) .artifact(artifact) .fileUploader(fileUploader) .toDir("d1") .upload();  Assert."<AssertPlaceHolder>"; }
upload() { FileScanner scanner; String fromDir = this.ws; switch (artifact.getPatternType()) { case DIR: if (new File(artifact.getFilePattern()).isAbsolute()) { fromDir = artifact.getFilePattern(); } else { fromDir = fromDir + File.separator + artifact.getFilePattern(); } // 当路径所指的目标是单文件时，直接读取单上传文件。 if (new File(fromDir).exists() && new File(fromDir).isFile()) { String fileName = FilenameUtils.getName(FilenameUtils.normalizeNoEndSeparator(fromDir)); String toFile = uuid + "/" + toDir + "/" + fileName; jobAsyncLogger.log("INFO", "single file uploading..."); fileUploader.upload(new File(fromDir), toFile); return 1; } scanner = new DirFileScanner(artifact.getFilePattern()); break; case ANT: scanner = new AntFileScanner(artifact.getFilePattern()); break; default: throw new AgentException("Not supported file pattern type:" + artifact.getPatternType()); } List<String> files = scanner.scan(ws); if (CollectionUtils.isEmpty(files)) { return 0; } new FilesUploader(jobAsyncLogger) .fromDir(fromDir) .files(files) .toDir(uuid + "/" + toDir) .fileUploader(fileUploader).upload(); return files.size(); }
[*] target: assertEquals(1, filesCount)
[-] pred: org. junit. Assert. assertEquals ( 1, filesCount )
************************************
************************************
[+] input: Exception { HttpDownloader downloader = Mockito.spy(new HttpDownloader()); PowerMockito.whenNew(HttpDownloader.class).withAnyArguments().thenReturn(downloader); Mockito.doNothing().when(downloader).download(); File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.exists()).thenReturn(true); Mockito.when(file.canExecute()).thenReturn(false); Mockito.when(file.renameTo(Mockito.any(File.class))).thenReturn(true); PowerMockito.mock(FileUtils.class, new DoesNothing()); boolean result = UpgraderExecutor.prepare(Context.getServerContext().getAgentUpdateInfo()); Assert."<AssertPlaceHolder>"; }
prepare(SystemCmdInfoFactory.AgentUpdateInfo updateInfo) {  log("upgrade_prepare_start"); boolean hasJar = upgradeJarOnce(updateInfo); boolean javaExecutable = setExecutable4Java(); if (!hasJar) { log("upgrade_prepare_fail_no_jar"); return false; }  if (!javaExecutable) { log("upgrade_prepare_fail_java_cannot_executable"); return false; } log("upgrade_prepare_finish"); return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { PowerMockito.mockStatic(Watcher.class); String[] args = {"echo hello"}; Process process = PowerMockito.mock(Process.class); PowerMockito.mockStatic(Runtime.class); PowerMockito.when(Runtime.getRuntime().exec(args)).thenReturn(process); UpgradeStatus upgradeStatus = new UpgradeStatus(); PowerMockito.when(Watcher.watch(process)).thenReturn(upgradeStatus); UpgradeStatus result = UpgraderExecutor.executeUpgrade(args); Assert."<AssertPlaceHolder>"; }
executeUpgrade(String[] cmd) {  try { // 守护进程启动，则不自动更新；直接退出，由守护进程拉起 if (Launcher.isSuperviseRun()) { log("upgrade_execute_success_agent_run_by_supervise"); return new UpgradeStatus(true, true); } Process process = Runtime.getRuntime().exec(cmd); return Watcher.watch(process); } catch (Throwable e) { log("upgrade_execute_fail_error_" + e.getMessage() + "\n" + ExceptionUtils.getFullStackTrace(e)); return null; } }
[*] target: assertEquals(upgradeStatus, result)
[-] pred: org. junit. Assert. assertEquals ( upgradeStatus, result )
************************************
************************************
[+] input: testLongValue() { Currency instance = new Currency(1234567890123456L); long expResult = 1234567890123456L; long result = instance.longValue(); "<AssertPlaceHolder>"; }
longValue() { return embeddedValue.longValue(); }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: testCompareTo_Currency() { Currency anotherCurrency = new Currency(1234567890123456L); Currency instance = new Currency(1234567890000000L); int expResult = -1; int result = instance.compareTo(anotherCurrency); "<AssertPlaceHolder>"; }
compareTo(Currency anotherCurrency) { return embeddedValue.compareTo(anotherCurrency.getLongValue()); }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: testEquals() { Object o = new Object(); Currency instance = new Currency(1234567890123456L); boolean expResult = false; boolean result = instance.equals(o); "<AssertPlaceHolder>"; }
equals(Object o) { if (o == null) { return false; // Modified EJP 31/8/2023 } else if (o instanceof Currency && compareTo((Currency) o) == 0) { return true; } else { return false; } }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: keyPairWithPasswd() { try { SM2Util instance = new SM2Util(); KeyPair keyPair = instance.generatekeyPair(); String privateKeyPem = SM2Util.pemFrom(keyPair.getPrivate(), passwd); Files.write(Paths.get(encryptedprivFileName), privateKeyPem.getBytes()); PrivateKey key = SM2Util.loadPrivFromFile(encryptedprivFileName, passwd); Assert."<AssertPlaceHolder>"; Assert.assertEquals(keyEqualHint, keyPair.getPrivate(), key); } catch (Exception e) { e.printStackTrace(); Assert.fail(exceptionHappened); } }
loadPrivFromFile(String filename, String password) throws IOException, OperatorCreationException, PKCSException { return loadPriv(password, () -> { try { return new FileReader(filename); } catch (FileNotFoundException e) { throw new RuntimeException("Private key "" + filename + "" not found", e); } }); }
[*] target: assertNotNull(key)
[-] pred: org. junit. Assert. assertNotNull ( key )
************************************
************************************
[+] input: Exception { Map<String, Object> javagm = this.configMap.get("javagm"); Object testdata = javagm.get("testdata"); String privateKey = (String) ((Map<String, Object>) testdata).get("private-key");  PrivateKey privKey = SM2Util.loadPrivFromString(privateKey, ""); Assert."<AssertPlaceHolder>"; }
loadPrivFromString(String privateKey, String password) throws IOException, OperatorCreationException, PKCSException { return loadPriv(password, () -> new StringReader(privateKey)); }
[*] target: assertNotNull(privKey)
[-] pred: org. junit. Assert. assertNotNull ( privKey )
************************************
************************************
[+] input: Exception { Map<String, Object> javagm = this.configMap.get("javagm"); Object testdata = javagm.get("testdata");  String cert = (String) ((Map<String, Object>) testdata).get("cert"); Assert.assertNotNull(cert);  X509Certificate certificate = SM2Util.loadX509CertificateFromString(cert); Assert."<AssertPlaceHolder>"; Assert.assertEquals("SM3WITHSM2", certificate.getSigAlgName()); }
loadX509CertificateFromString(String cert) throws IOException, CertificateException, NoSuchProviderException { try (InputStream in = new ByteArrayInputStream(cert.getBytes())) { CertificateFactory cf = CertificateFactory.getInstance("X.509", BouncyCastleProvider.PROVIDER_NAME); return (X509Certificate) cf.generateCertificate(in); } }
[*] target: assertNotNull(certificate)
[-] pred: org. junit. Assert. assertNotNull ( certificate )
************************************
************************************
[+] input: Exception { Topic expectedResponse = Topic.newBuilder() .setName(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartitionConfig(Topic.PartitionConfig.newBuilder().build()) .setRetentionConfig(Topic.RetentionConfig.newBuilder().build()) .setReservationConfig(Topic.ReservationConfig.newBuilder().build()) .build(); mockAdminService.addResponse(expectedResponse);  Topic topic = Topic.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Topic actualResponse = client.updateTopic(topic, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateTopicRequest actualRequest = ((UpdateTopicRequest) actualRequests.get(0));  Assert.assertEquals(topic, actualRequest.getTopic()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateTopic(Topic topic, FieldMask updateMask) { UpdateTopicRequest request = UpdateTopicRequest.newBuilder().setTopic(topic).setUpdateMask(updateMask).build(); return updateTopic(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { Subscription expectedResponse = Subscription.newBuilder() .setName(SubscriptionName.of("[PROJECT]", "[LOCATION]", "[SUBSCRIPTION]").toString()) .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setDeliveryConfig(Subscription.DeliveryConfig.newBuilder().build()) .setExportConfig(ExportConfig.newBuilder().build()) .build(); mockAdminService.addResponse(expectedResponse);  Subscription subscription = Subscription.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Subscription actualResponse = client.updateSubscription(subscription, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateSubscriptionRequest actualRequest = ((UpdateSubscriptionRequest) actualRequests.get(0));  Assert.assertEquals(subscription, actualRequest.getSubscription()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateSubscription(Subscription subscription, FieldMask updateMask) { UpdateSubscriptionRequest request = UpdateSubscriptionRequest.newBuilder() .setSubscription(subscription) .setUpdateMask(updateMask) .build(); return updateSubscription(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { SeekSubscriptionResponse expectedResponse = SeekSubscriptionResponse.newBuilder().build(); Operation resultOperation = Operation.newBuilder() .setName("seekSubscriptionTest") .setDone(true) .setResponse(Any.pack(expectedResponse)) .build(); mockAdminService.addResponse(resultOperation);  SeekSubscriptionRequest request = SeekSubscriptionRequest.newBuilder() .setName(SubscriptionName.of("[PROJECT]", "[LOCATION]", "[SUBSCRIPTION]").toString()) .build();  SeekSubscriptionResponse actualResponse = client.seekSubscriptionAsync(request).get(); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); SeekSubscriptionRequest actualRequest = ((SeekSubscriptionRequest) actualRequests.get(0));  Assert.assertEquals(request.getName(), actualRequest.getName()); Assert.assertEquals(request.getNamedTarget(), actualRequest.getNamedTarget()); Assert.assertEquals(request.getTimeTarget(), actualRequest.getTimeTarget()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
seekSubscriptionAsync( SeekSubscriptionRequest request) { return seekSubscriptionOperationCallable().futureCall(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { Reservation expectedResponse = Reservation.newBuilder() .setName(ReservationName.of("[PROJECT]", "[LOCATION]", "[RESERVATION]").toString()) .setThroughputCapacity(-1174790353) .build(); mockAdminService.addResponse(expectedResponse);  Reservation reservation = Reservation.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Reservation actualResponse = client.updateReservation(reservation, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateReservationRequest actualRequest = ((UpdateReservationRequest) actualRequests.get(0));  Assert.assertEquals(reservation, actualRequest.getReservation()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateReservation(Reservation reservation, FieldMask updateMask) { UpdateReservationRequest request = UpdateReservationRequest.newBuilder() .setReservation(reservation) .setUpdateMask(updateMask) .build(); return updateReservation(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { CommitCursorResponse expectedResponse = CommitCursorResponse.newBuilder().build(); mockCursorService.addResponse(expectedResponse);  CommitCursorRequest request = CommitCursorRequest.newBuilder() .setSubscription("subscription341203229") .setPartition(-1799810326) .setCursor(Cursor.newBuilder().build()) .build();  CommitCursorResponse actualResponse = client.commitCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockCursorService.getRequests(); Assert.assertEquals(1, actualRequests.size()); CommitCursorRequest actualRequest = ((CommitCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getSubscription(), actualRequest.getSubscription()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getCursor(), actualRequest.getCursor()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
commitCursor(CommitCursorRequest request) { return commitCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeMessageStatsResponse expectedResponse = ComputeMessageStatsResponse.newBuilder() .setMessageCount(-1229303081) .setMessageBytes(-1229929933) .setMinimumPublishTime(Timestamp.newBuilder().build()) .setMinimumEventTime(Timestamp.newBuilder().build()) .build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeMessageStatsRequest request = ComputeMessageStatsRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .setStartCursor(Cursor.newBuilder().build()) .setEndCursor(Cursor.newBuilder().build()) .build();  ComputeMessageStatsResponse actualResponse = client.computeMessageStats(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeMessageStatsRequest actualRequest = ((ComputeMessageStatsRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getStartCursor(), actualRequest.getStartCursor()); Assert.assertEquals(request.getEndCursor(), actualRequest.getEndCursor()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeMessageStats(ComputeMessageStatsRequest request) { return computeMessageStatsCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeHeadCursorResponse expectedResponse = ComputeHeadCursorResponse.newBuilder().setHeadCursor(Cursor.newBuilder().build()).build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeHeadCursorRequest request = ComputeHeadCursorRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .build();  ComputeHeadCursorResponse actualResponse = client.computeHeadCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeHeadCursorRequest actualRequest = ((ComputeHeadCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeHeadCursor(ComputeHeadCursorRequest request) { return computeHeadCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeTimeCursorResponse expectedResponse = ComputeTimeCursorResponse.newBuilder().setCursor(Cursor.newBuilder().build()).build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeTimeCursorRequest request = ComputeTimeCursorRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .setTarget(TimeTarget.newBuilder().build()) .build();  ComputeTimeCursorResponse actualResponse = client.computeTimeCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeTimeCursorRequest actualRequest = ((ComputeTimeCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getTarget(), actualRequest.getTarget()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeTimeCursor(ComputeTimeCursorRequest request) { return computeTimeCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: test_getmainstr1() { String s = cnid.getmainstr(f); "<AssertPlaceHolder>"; System.out.println(s); }
getmainstr(Faker f) { String cn = f.regexify( "[1-6][1-3][0-2][0-9]21-[1-2]\\d{3}[0-1][0-9][0-2][0-8]-\\d{3}"); //原理：通过正则表达式生成符合条件的 id，并且排除掉不符合的id。生成不符合的则重新生成。 //正则表达式中，\d 匹配一个数字字符。等价于 [0-9]。 boolean isValid = true; for (String invalidSSNPattern : invalidCNPatterns) { if (cn.matches(invalidSSNPattern)) { isValid = false; break; } } if (!isValid) { cn = getmainstr(f); } return cn; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: test_getmainstr2() { String s = cnid.getmainstr(f); "<AssertPlaceHolder>"; System.out.println(s); }
getmainstr(Faker f) { String cn = f.regexify( "[1-6][1-3][0-2][0-9]21-[1-2]\\d{3}[0-1][0-9][0-2][0-8]-\\d{3}"); //原理：通过正则表达式生成符合条件的 id，并且排除掉不符合的id。生成不符合的则重新生成。 //正则表达式中，\d 匹配一个数字字符。等价于 [0-9]。 boolean isValid = true; for (String invalidSSNPattern : invalidCNPatterns) { if (cn.matches(invalidSSNPattern)) { isValid = false; break; } } if (!isValid) { cn = getmainstr(f); } return cn; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: print_json_diffInputNotNullZeroNotNullZeroNotNullOutputNotNull() {  // Arrange final LogBuffer buffer = new LogBuffer(); final long len = 0L; final String columnName = ","; final int columnIndex = 0; final String charsetName = "1a 2b 3c";  // Act final StringBuilder actual = JsonDiffConversion.print_json_diff(buffer, len, columnName, columnIndex, charsetName);  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertEquals(",", actual.toString()); }
print_json_diff(LogBuffer buffer, long len, String columnName, int columnIndex, String charsetName) { int position = buffer.position(); List<String> operation_names = new ArrayList<String>(); while (buffer.hasRemaining()) { int operation_int = buffer.getUint8(); if (operation_int >= JSON_DIFF_OPERATION_COUNT) { throw new IllegalArgumentException("reading operation type (invalid operation code)"); }  // skip path long path_length = buffer.getPackedLong(); if (path_length > len) { throw new IllegalArgumentException("skipping path"); }  // compute operation name byte[] lastP = buffer.getData(buffer.position() + (int) path_length - 1, 1); String operation_name = json_diff_operation_name(operation_int, lastP[0]); operation_names.add(operation_name);  buffer.forward((int) path_length); // skip value if (operation_int != DIFF_OPERATION_REMOVE) { long value_length = buffer.getPackedLong(); if (value_length > len) { throw new IllegalArgumentException("skipping path"); }  buffer.forward((int) value_length); } }  // Print function names in reverse order. StringBuilder builder = new StringBuilder(); for (int i = operation_names.size() - 1; i >= 0; i--) { if (i == 0 || operation_names.get(i - 1) != operation_names.get(i)) { builder.append(operation_names.get(i)).append("("); } }  // Print column id if (columnName != null) { builder.append(columnName); } else { builder.append("@").append(columnIndex); }  // In case this vector is empty (a no-op), make an early return // after printing only the column name if (operation_names.size() == 0) { return builder; }  // Print comma between column name and next function argument builder.append(", "); // Print paths and values. buffer.position(position); int diff_i = 0; while (buffer.hasRemaining()) { // Read operation int operation_int = buffer.getUint8();  // Read path length long path_length = buffer.getPackedLong(); // Print path builder.append(''').append(buffer.getFixString((int) path_length)).append(''');  if (operation_int != DIFF_OPERATION_REMOVE) { // Print comma between path and value builder.append(", "); // Read value length long value_length = buffer.getPackedLong();  Json_Value jsonValue = JsonConversion.parse_value(buffer.getUint8(), buffer, value_length - 1, charsetName); buffer.forward((int) value_length - 1); // Read value if (jsonValue.m_type == Json_enum_type.ERROR) { throw new IllegalArgumentException("parsing json value"); } StringBuilder jsonBuilder = new StringBuilder(); jsonValue.toJsonString(jsonBuilder, charsetName); builder.append(jsonBuilder); }  // Print closing parenthesis if (!buffer.hasRemaining() || operation_names.get(diff_i + 1) != operation_names.get(diff_i)) { builder.append(")"); }  if (buffer.hasRemaining()) { builder.append(", "); } diff_i++; }  return builder; }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: getCurrentGtidLastCommitOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtidLastCommit();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtidLastCommit() { return gtidMap.get(CURRENT_GTID_LAST_COMMIT); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getCurrentGtidOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtid();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtid() { return gtidMap.get(CURRENT_GTID_STRING); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getCurrentGtidSnOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtidSn();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtidSn() { return gtidMap.get(CURRENT_GTID_SN); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getEventLenOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getEventLen();  // Assert result Assert."<AssertPlaceHolder>"; }
getEventLen() { return eventLen; }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: getFlagsOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getFlags();  // Assert result Assert."<AssertPlaceHolder>"; }
getFlags() { return flags; }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: getGtidSetStrOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getGtidSetStr();  // Assert result Assert."<AssertPlaceHolder>"; }
getGtidSetStr() { return gtidMap.get(GTID_SET_STRING); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getLogFileNameOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getLogFileName();  // Assert result Assert."<AssertPlaceHolder>"; }
getLogFileName() { return logFileName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getTypeOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getType();  // Assert result Assert."<AssertPlaceHolder>"; }
getType() { return type; }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: testParse() { Map<String, MysqlGTIDSet> cases = new HashMap<String, MysqlGTIDSet>(5); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 2))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3:4", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 5))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3:7-9", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4, 7, 10))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3,726757ad-4455-11e8-ae04-0242ac110003:4", buildForTest(Arrays.asList(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4), new Material("726757ad-4455-11e8-ae04-0242ac110003", 4, 5))));  for (Map.Entry<String, MysqlGTIDSet> entry : cases.entrySet()) { MysqlGTIDSet expected = entry.getValue(); MysqlGTIDSet actual = MysqlGTIDSet.parse(entry.getKey());  "<AssertPlaceHolder>"; } }
parse(String gtidData) { Map<String, UUIDSet> m;  if (gtidData == null || gtidData.length() < 1) { m = new HashMap<String, UUIDSet>(); } else { // 存在多个GTID时会有回车符 String[] uuidStrs = gtidData.replaceAll("\n", "").split(","); m = new HashMap<String, UUIDSet>(uuidStrs.length); for (int i = 0; i < uuidStrs.length; i++) { UUIDSet uuidSet = UUIDSet.parse(uuidStrs[i]); m.put(uuidSet.SID.toString(), uuidSet); } }  MysqlGTIDSet gs = new MysqlGTIDSet(); gs.sets = m;  return gs; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: getOriSchemaNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getOriSchemaName();  // Assert result Assert."<AssertPlaceHolder>"; }
getOriSchemaName() { return oriSchemaName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getOriTableNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getOriTableName();  // Assert result Assert."<AssertPlaceHolder>"; }
getOriTableName() { return oriTableName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getRenameTableResultOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final DdlResult actual = objectUnderTest.getRenameTableResult();  // Assert result Assert."<AssertPlaceHolder>"; }
getRenameTableResult() { return renameTableResult; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getSchemaNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getSchemaName();  // Assert result Assert."<AssertPlaceHolder>"; }
getSchemaName() { return schemaName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getTableNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getTableName();  // Assert result Assert."<AssertPlaceHolder>"; }
getTableName() { return tableName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getTypeOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final EventType actual = objectUnderTest.getType();  // Assert result Assert."<AssertPlaceHolder>"; }
getType() { return type; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: NoSuchAlgorithmException { byte[] seed = { 1, 2, 3, 4, 5, 6, 7, 8 }; // String str = "e3619321c1a937c46a0d8bd1dac39f93b27d4458"; // canal // passwd String str = SecurityUtil.scrambleGenPass("canal".getBytes()); byte[] client = SecurityUtil.scramble411("canal".getBytes(), seed); boolean check = SecurityUtil.scrambleServerAuth(client, SecurityUtil.hexStr2Bytes(str), seed); Assert."<AssertPlaceHolder>"; }
hexStr2Bytes(String src) { if (src == null) { return null; } int offset = 0; int length = src.length(); if (length == 0) { return new byte[0]; }  boolean odd = length << 31 == Integer.MIN_VALUE; byte[] bs = new byte[odd ? (length + 1) >> 1 : length >> 1]; for (int i = offset, limit = offset + length; i < limit; ++i) { char high, low; if (i == offset && odd) { high = '0'; low = src.charAt(i); } else { high = src.charAt(i); low = src.charAt(++i); } int b; switch (high) { case '0': b = 0; break; case '1': b = 0x10; break; case '2': b = 0x20; break; case '3': b = 0x30; break; case '4': b = 0x40; break; case '5': b = 0x50; break; case '6': b = 0x60; break; case '7': b = 0x70; break; case '8': b = 0x80; break; case '9': b = 0x90; break; case 'a': case 'A': b = 0xa0; break; case 'b': case 'B': b = 0xb0; break; case 'c': case 'C': b = 0xc0; break; case 'd': case 'D': b = 0xd0; break; case 'e': case 'E': b = 0xe0; break; case 'f': case 'F': b = 0xf0; break; default: throw new IllegalArgumentException("illegal hex-string: " + src); } switch (low) { case '0': break; case '1': b += 1; break; case '2': b += 2; break; case '3': b += 3; break; case '4': b += 4; break; case '5': b += 5; break; case '6': b += 6; break; case '7': b += 7; break; case '8': b += 8; break; case '9': b += 9; break; case 'a': case 'A': b += 10; break; case 'b': case 'B': b += 11; break; case 'c': case 'C': b += 12; break; case 'd': case 'D': b += 13; break; case 'e': case 'E': b += 14; break; case 'f': case 'F': b += 15; break; default: throw new IllegalArgumentException("illegal hex-string: " + src); } bs[(i - offset) >> 1] = (byte) b; } return bs; }
[*] target: assertTrue(check)
[-] pred: org. junit. Assert. assertTrue ( check )
************************************
************************************
[+] input: testRemove() { map.put(1, "a"); map.put(2, "b"); Assert.assertEquals("a", map.get(1));  Assert.assertEquals("a", map.remove(1)); Assert.assertEquals(1, map.size()); Assert.assertEquals("b", map.remove(2)); Assert.assertNull(map.remove(2)); Assert."<AssertPlaceHolder>"; }
isEmpty() { return lowestNode() != null; }
[*] target: assertTrue(map.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( map. isEmpty() )
************************************
************************************
[+] input: evaluateWhenExpressionVarIsUndefined() { String expression = "dummy.intValue"; Map<String, Object> vars = new HashMap<>(); ExpressionEvaluator expressionEvaluator = new JexlExpressionEvaluatorNoThreadLocal(); Object result = expressionEvaluator.evaluate( expression, vars ); "<AssertPlaceHolder>"; }
evaluate(String expression, Map<String, Object> context) { JexlContext jexlContext = new MapContext(context); try { JexlExpression jexlExpression = expressionMap.get(expression); if (jexlExpression == null) { jexlExpression = jexl.createExpression(expression); expressionMap.put(expression, jexlExpression); } return jexlExpression.evaluate(jexlContext); } catch (Exception e) { throw new EvaluationException("An error occurred when evaluating expression " + expression, e); // JxlsLogger not needed here. } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: evaluateWhenExpressionVarIsUndefined() { String expression = "dummy.intValue"; Map<String, Object> vars = new HashMap<>(); ExpressionEvaluator expressionEvaluator = new JexlExpressionEvaluator(); Object result = expressionEvaluator.evaluate( expression, vars ); "<AssertPlaceHolder>"; }
evaluate(String expression, Map<String, Object> context) { JexlContext jexlContext = new MapContext(context); try { Map<String, JexlExpression> expressionMap = expressionMapThreadLocal.get(); JexlExpression jexlExpression = expressionMap.get(expression); if (jexlExpression == null) { jexlExpression = getJexlEngine().createExpression(expression); expressionMap.put(expression, jexlExpression); } return jexlExpression.evaluate(jexlContext); } catch (Exception e) { throw new EvaluationException("An error occurred when evaluating expression " + expression, e); // JxlsLogger not needed here. } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: UnknownHostException { // Try connecting connectionStates.connecting(nodeId1, time.milliseconds(), "localhost", ClientDnsLookup.DEFAULT);  time.sleep(100);  connectionStates.authenticationFailed(nodeId1, time.milliseconds(), new AuthenticationException("No path to CA for certificate!")); time.sleep(1000); assertEquals(connectionStates.connectionState(nodeId1), ConnectionState.AUTHENTICATION_FAILED); assertTrue(connectionStates.authenticationException(nodeId1) instanceof AuthenticationException); assertFalse(connectionStates.hasReadyNodes(time.milliseconds())); assertFalse(connectionStates.canConnect(nodeId1, time.milliseconds()));  time.sleep(connectionStates.connectionDelay(nodeId1, time.milliseconds()) + 1);  assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds())); connectionStates.ready(nodeId1); "<AssertPlaceHolder>"; }
authenticationException(String id) { NodeConnectionState state = nodeState.get(id); return state != null ? state.authenticationException : null; }
[*] target: assertNull(connectionStates.authenticationException(nodeId1))
[-] pred: org. junit. Assert. assertNull ( connectionStates. authenticationException(nodeId1) )
************************************
************************************
[+] input: testConnectionDelayWithNoExponentialBackoff() { long now = time.milliseconds(); long delay = clientWithNoExponentialBackoff.connectionDelay(node, now);  "<AssertPlaceHolder>"; }
connectionDelay(Node node, long now) { return connectionStates.connectionDelay(node.idString(), now); }
[*] target: assertEquals(0, delay)
[-] pred: org. junit. Assert. assertEquals ( 0, delay )
************************************
************************************
[+] input: testBasicCompletion() { RequestFuture<String> future = new RequestFuture<>(); String value = "foo"; future.complete(value); assertTrue(future.isDone()); "<AssertPlaceHolder>"; }
value() { if (!succeeded()) throw new IllegalStateException("Attempt to retrieve value from future which hasn't successfully completed"); return (T) result.get(); }
[*] target: assertEquals(value, future.value())
[-] pred: org. junit. Assert. assertEquals ( value, future. value() )
************************************
************************************
[+] input: testChecksumNullForMagicV2() { ProducerBatch batch = new ProducerBatch(new TopicPartition("topic", 1), memoryRecordsBuilder, now); FutureRecordMetadata future = batch.tryAppend(now, null, new byte[10], Record.EMPTY_HEADERS, null, now); "<AssertPlaceHolder>"; assertNull(future.checksumOrNull()); }
tryAppend(long timestamp, byte[] key, byte[] value, Header[] headers, Callback callback, long now) { if (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) { return null; } else { Long checksum = this.recordsBuilder.append(timestamp, key, value, headers); this.maxRecordSize = Math.max(this.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(), recordsBuilder.compressionType(), key, value, headers)); this.lastAppendTime = now; FutureRecordMetadata future = new FutureRecordMetadata(this.produceFuture, this.recordCount, timestamp, checksum, key == null ? -1 : key.length, value == null ? -1 : value.length, Time.SYSTEM); // we have to keep every future returned to the users in case the batch needs to be // split to several new batches and resent. thunks.add(new Thunk(callback, future)); this.recordCount++; return future; } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testAppendedChecksumMagicV0AndV1() { for (byte magic : Arrays.asList(MAGIC_VALUE_V0, MAGIC_VALUE_V1)) { MemoryRecordsBuilder builder = MemoryRecords.builder(ByteBuffer.allocate(128), magic, CompressionType.NONE, TimestampType.CREATE_TIME, 0L); ProducerBatch batch = new ProducerBatch(new TopicPartition("topic", 1), builder, now); byte[] key = "hi".getBytes(); byte[] value = "there".getBytes();  FutureRecordMetadata future = batch.tryAppend(now, key, value, Record.EMPTY_HEADERS, null, now); "<AssertPlaceHolder>"; byte attributes = LegacyRecord.computeAttributes(magic, CompressionType.NONE, TimestampType.CREATE_TIME); long expectedChecksum = LegacyRecord.computeChecksum(magic, attributes, now, key, value); assertEquals(expectedChecksum, future.checksumOrNull().longValue()); } }
tryAppend(long timestamp, byte[] key, byte[] value, Header[] headers, Callback callback, long now) { if (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) { return null; } else { Long checksum = this.recordsBuilder.append(timestamp, key, value, headers); this.maxRecordSize = Math.max(this.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(), recordsBuilder.compressionType(), key, value, headers)); this.lastAppendTime = now; FutureRecordMetadata future = new FutureRecordMetadata(this.produceFuture, this.recordCount, timestamp, checksum, key == null ? -1 : key.length, value == null ? -1 : value.length, Time.SYSTEM); // we have to keep every future returned to the users in case the batch needs to be // split to several new batches and resent. thunks.add(new Thunk(callback, future)); this.recordCount++; return future; } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testBootstrap() { String ipAddress = "140.211.11.105"; String hostName = "www.example.com"; Cluster cluster = Cluster.bootstrap(Arrays.asList( new InetSocketAddress(ipAddress, 9002), new InetSocketAddress(hostName, 9002) )); Set<String> expectedHosts = Utils.mkSet(ipAddress, hostName); Set<String> actualHosts = new HashSet<>(); for (Node node : cluster.nodes()) actualHosts.add(node.host()); "<AssertPlaceHolder>"; }
nodes() { return this.nodes; }
[*] target: assertEquals(expectedHosts, actualHosts)
[-] pred: org. junit. Assert. assertEquals ( expectedHosts, actualHosts )
************************************
************************************
[+] input: toRst() { final ConfigDef def = new ConfigDef() .define("opt1", Type.STRING, "a", ValidString.in("a", "b", "c"), Importance.HIGH, "docs1") .define("opt2", Type.INT, Importance.MEDIUM, "docs2") .define("opt3", Type.LIST, Arrays.asList("a", "b"), Importance.LOW, "docs3");  final String expectedRst = "" + "``opt2``\n" + "  docs2\n" + "\n" + "  * Type: int\n" + "  * Importance: medium\n" + "\n" + "``opt1``\n" + "  docs1\n" + "\n" + "  * Type: string\n" + "  * Default: a\n" + "  * Valid Values: [a, b, c]\n" + "  * Importance: high\n" + "\n" + "``opt3``\n" + "  docs3\n" + "\n" + "  * Type: list\n" + "  * Default: a,b\n" + "  * Importance: low\n" + "\n";  "<AssertPlaceHolder>"; }
toRst() { StringBuilder b = new StringBuilder(); for (ConfigKey key : sortedConfigs()) { if (key.internalConfig) { continue; } getConfigKeyRst(key, b); b.append("\n"); } return b.toString(); }
[*] target: assertEquals(expectedRst, def.toRst())
[-] pred: org. junit. Assert. assertEquals ( expectedRst, def. toRst ( ) )
************************************
************************************
[+] input: testRequestHeader() { RequestHeader header = new RequestHeader(ApiKeys.FIND_COORDINATOR, (short) 1, "", 10); ByteBuffer buffer = toBuffer(header.toStruct()); RequestHeader deserialized = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { try { short apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); Schema schema = schema(apiKey, apiVersion); buffer.rewind(); return new RequestHeader(schema.read(buffer)); } catch (InvalidRequestException e) { throw e; } catch (Throwable  ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + buffer.getShort(0), ex); } }
[*] target: assertEquals(header, deserialized)
[-] pred: org. junit. Assert. assertEquals ( header, deserialized )
************************************
************************************
[+] input: Exception { String expectedMesssage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001";  Map<String, String> extensions = new HashMap<>(); extensions.put("nineteen", "42"); OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse("123.345.567", new SaslExtensions(extensions));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (extensions.length() > 0) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(expectedMesssage, message)
[-] pred: org. junit. Assert. assertEquals ( expectedMesssage, message )
************************************
************************************
[+] input: Exception { String serverMessage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001"; OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse(serverMessage.getBytes(StandardCharsets.UTF_8));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (extensions.length() > 0) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(serverMessage, message)
[-] pred: org. junit. Assert. assertEquals ( serverMessage, message )
************************************
************************************
[+] input: Exception { File trustStoreFile = File.createTempFile("truststore", ".jks"); Map<String, Object> serverSslConfig = TestSslUtils.createSslConfig(false, true, Mode.SERVER, trustStoreFile, "server"); SslFactory sslFactory = new SslFactory(Mode.SERVER); sslFactory.configure(serverSslConfig); //host and port are hints SSLEngine engine = sslFactory.createSslEngine("localhost", 0); "<AssertPlaceHolder>"; String[] expectedProtocols = {"TLSv1.2"}; assertArrayEquals(expectedProtocols, engine.getEnabledProtocols()); assertEquals(false, engine.getUseClientMode()); }
createSslEngine(String peerHost, int peerPort) { return createSslEngine(sslContext, peerHost, peerPort); }
[*] target: assertNotNull(engine)
[-] pred: org. junit. Assert. assertNotNull ( engine )
************************************
************************************
[+] input: testReadUnsignedInt() { ByteBuffer buffer = ByteBuffer.allocate(4); long writeValue = 133444; ByteUtils.writeUnsignedInt(buffer, writeValue); buffer.flip(); long readValue = ByteUtils.readUnsignedInt(buffer); "<AssertPlaceHolder>"; }
readUnsignedInt(ByteBuffer buffer) { return buffer.getInt() & 0xffffffffL; }
[*] target: assertEquals(writeValue, readValue)
[-] pred: org. junit. Assert. assertEquals ( writeValue, readValue )
************************************
************************************
[+] input: testTimeoutOverflow() { Timer timer = time.timer(Long.MAX_VALUE); assertEquals(Long.MAX_VALUE - timer.currentTimeMs(), timer.remainingMs()); "<AssertPlaceHolder>"; }
elapsedMs() { return currentTimeMs - startMs; }
[*] target: assertEquals(0, timer.elapsedMs())
[-] pred: org. junit. Assert. assertEquals ( 0, timer. elapsedMs() )
************************************
************************************
[+] input: shouldInstantiateAndConfigureExplicitlySetHeaderConverterWithCurrentClassLoader() { assertNotNull(props.get(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG)); HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNotNull(headerConverter); assertTrue(headerConverter instanceof TestHeaderConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config"));  headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertTrue(headerConverter instanceof TestHeaderConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config")); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { HeaderConverter plugin = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) plugin = getInstance(config, classPropertyName, HeaderConverter.class); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); Class<? extends HeaderConverter> klass; try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(delegatingLoader.headerConverters()) ); } plugin = newPlugin(klass); } if (plugin == null) { throw new ConnectException("Unable to instantiate the Converter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration:{}{}", System.lineSeparator(), converterConfig); plugin.configure(converterConfig); return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: shouldInstantiateAndConfigureConnectRestExtension() { props.put(WorkerConfig.REST_EXTENSION_CLASSES_CONFIG, TestConnectRestExtension.class.getName()); createConfig();  List<ConnectRestExtension> connectRestExtensions = plugins.newPlugins(config.getList(WorkerConfig.REST_EXTENSION_CLASSES_CONFIG), config, ConnectRestExtension.class); "<AssertPlaceHolder>"; assertEquals("One Rest Extension expected", 1, connectRestExtensions.size()); assertNotNull(connectRestExtensions.get(0)); assertTrue("Should be instance of TestConnectRestExtension", connectRestExtensions.get(0) instanceof TestConnectRestExtension); assertNotNull(((TestConnectRestExtension) connectRestExtensions.get(0)).configs); assertEquals(config.originals(), ((TestConnectRestExtension) connectRestExtensions.get(0)).configs); }
newPlugins(List<String> klassNames, AbstractConfig config, Class<T> pluginKlass) { List<T> plugins = new ArrayList<>(); if (klassNames != null) { for (String klassName : klassNames) { plugins.add(newPlugin(klassName, config, pluginKlass)); } } return plugins; }
[*] target: assertNotNull(connectRestExtensions)
[-] pred: org. junit. Assert. assertNotNull ( connectRestExtensions )
************************************
************************************
[+] input: shouldInstantiateAndConfigureDefaultHeaderConverter() { props.remove(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG); createConfig();  // Because it's not explicitly set on the supplied configuration, the logic to use the current classloader for the connector // will exit immediately, and so this method always returns null HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNull(headerConverter); // But we should always find it (or the worker's default) when using the plugins classloader ... headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertTrue(headerConverter instanceof SimpleHeaderConverter); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { HeaderConverter plugin = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) plugin = getInstance(config, classPropertyName, HeaderConverter.class); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); Class<? extends HeaderConverter> klass; try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(delegatingLoader.headerConverters()) ); } plugin = newPlugin(klass); } if (plugin == null) { throw new ConnectException("Unable to instantiate the Converter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration:{}{}", System.lineSeparator(), converterConfig); plugin.configure(converterConfig); return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: returnNullWithApiVersionMismatch() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().setNodeApiVersions(NodeApiVersions.create()); env.kafkaClient().prepareResponse(createTopicResponseWithUnsupportedVersion(newTopic)); TopicAdmin admin = new TopicAdmin(null, env.adminClient()); boolean created = admin.createTopic(newTopic); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred: org. junit. Assert. assertFalse ( created )
************************************
************************************
[+] input: returnNullWithClusterAuthorizationFailure() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(createTopicResponseWithClusterAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(null, env.adminClient()); boolean created = admin.createTopic(newTopic); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred: org. junit. Assert. assertFalse ( created )
************************************
************************************
[+] input: shouldReturnFalseWhenSuppliedNullTopicDescription() { Cluster cluster = createCluster(1); try (MockAdminClient mockAdminClient = new MockAdminClient(cluster.nodes(), cluster.nodeById(0))) { TopicAdmin admin = new TopicAdmin(null, mockAdminClient); boolean created = admin.createTopic(null); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred: org. junit. Assert. assertFalse ( created )
************************************
************************************
[+] input: updateSchemaOfNonStruct() { Object value = new Integer(1); Object updatedValue = SetSchemaMetadata.updateSchemaIn(value, Schema.INT32_SCHEMA); "<AssertPlaceHolder>"; }
updateSchemaIn(Object keyOrValue, Schema updatedSchema) { if (keyOrValue instanceof Struct) { Struct origStruct = (Struct) keyOrValue; Struct newStruct = new Struct(updatedSchema); for (Field field : updatedSchema.fields()) { // assume both schemas have exact same fields with same names and schemas ... newStruct.put(field, origStruct.get(field)); } return newStruct; } return keyOrValue; }
[*] target: assertSame(value, updatedValue)
[-] pred: org. junit. Assert. assertSame ( value, updatedValue )
************************************
************************************
[+] input: testTimeWindowSerdeFrom() { final Windowed<Integer> timeWindowed = new Windowed<>(10, new TimeWindow(0, Long.MAX_VALUE)); final Serde<Windowed<Integer>> timeWindowedSerde = WindowedSerdes.timeWindowedSerdeFrom(Integer.class); final byte[] bytes = timeWindowedSerde.serializer().serialize(topic, timeWindowed); final Windowed<Integer> windowed = timeWindowedSerde.deserializer().deserialize(topic, bytes); Assert."<AssertPlaceHolder>"; }
timeWindowedSerdeFrom(final Class<T> type) { return new TimeWindowedSerde<>(Serdes.serdeFrom(type)); }
[*] target: assertEquals(timeWindowed, windowed)
[-] pred: org. junit. Assert. assertEquals ( timeWindowed, windowed )
************************************
************************************
[+] input: testSessionWindowedSerdeFrom() { final Windowed<Integer> sessionWindowed = new Windowed<>(10, new SessionWindow(0, 1)); final Serde<Windowed<Integer>> sessionWindowedSerde = WindowedSerdes.sessionWindowedSerdeFrom(Integer.class); final byte[] bytes = sessionWindowedSerde.serializer().serialize(topic, sessionWindowed); final Windowed<Integer> windowed = sessionWindowedSerde.deserializer().deserialize(topic, bytes); Assert."<AssertPlaceHolder>"; }
sessionWindowedSerdeFrom(final Class<T> type) { return new SessionWindowedSerde<>(Serdes.serdeFrom(type)); }
[*] target: assertEquals(sessionWindowed, windowed)
[-] pred: org. junit. Assert. assertEquals ( sessionWindowed, windowed )
************************************
************************************
[+] input: testCopartitioning() { final Random rand = new Random(); final DefaultPartitioner defaultPartitioner = new DefaultPartitioner(); final WindowedSerializer<Integer> timeWindowedSerializer = new TimeWindowedSerializer<>(intSerializer); final WindowedStreamPartitioner<Integer, String> streamPartitioner = new WindowedStreamPartitioner<>(timeWindowedSerializer);  for (int k = 0; k < 10; k++) { final Integer key = rand.nextInt(); final byte[] keyBytes = intSerializer.serialize(topicName, key);  final String value = key.toString(); final byte[] valueBytes = stringSerializer.serialize(topicName, value);  final Integer expected = defaultPartitioner.partition("topic", key, keyBytes, value, valueBytes, cluster);  for (int w = 1; w < 10; w++) { final TimeWindow window = new TimeWindow(10 * w, 20 * w);  final Windowed<Integer> windowedKey = new Windowed<>(key, window); final Integer actual = streamPartitioner.partition(topicName, windowedKey, value, infos.size());  "<AssertPlaceHolder>"; } }  defaultPartitioner.close(); }
partition(final String topic, final Windowed<K> windowedKey, final V value, final int numPartitions) { final byte[] keyBytes = serializer.serializeBaseKey(topic, windowedKey);  // hash the keyBytes to choose a partition return toPositive(Utils.murmur2(keyBytes)) % numPartitions; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { final Map<TopicPartition, Long> expected = writeCheckpoint();  stateManager.initialize(); final Map<TopicPartition, Long> offsets = stateManager.checkpointed(); "<AssertPlaceHolder>"; }
checkpointed() { return Collections.unmodifiableMap(checkpointableOffsets); }
[*] target: assertEquals(expected, offsets)
[-] pred: org. junit. Assert. assertEquals ( expected, offsets )
************************************
************************************
[+] input: shouldLogAWarningIfCheckpointThrowsAnIOException() { final LogCaptureAppender appender = LogCaptureAppender.createAndRegister();  final ProcessorStateManager stateMgr; try { stateMgr = new ProcessorStateManager( taskId, noPartitions, false, stateDirectory, Collections.singletonMap(persistentStore.name(), persistentStoreTopicName), changelogReader, false, logContext); } catch (final IOException e) { e.printStackTrace(); throw new AssertionError(e); } stateMgr.register(persistentStore, persistentStore.stateRestoreCallback);  stateDirectory.clean(); stateMgr.checkpoint(Collections.singletonMap(persistentStorePartition, 10L)); LogCaptureAppender.unregister(appender);  boolean foundExpectedLogMessage = false; for (final LogCaptureAppender.Event event : appender.getEvents()) { if ("WARN".equals(event.getLevel()) && event.getMessage().startsWith("process-state-manager-test Failed to write offset checkpoint file to [") && event.getMessage().endsWith(".checkpoint]") && event.getThrowableInfo().get().startsWith("java.io.FileNotFoundException: ")) {  foundExpectedLogMessage = true; break; } } "<AssertPlaceHolder>"; }
register(final StateStore store, final StateRestoreCallback stateRestoreCallback) { final String storeName = store.name(); log.debug("Registering state store {} to its state manager", storeName);  if (CHECKPOINT_FILE_NAME.equals(storeName)) { throw new IllegalArgumentException(String.format("%sIllegal store name: %s", logPrefix, CHECKPOINT_FILE_NAME)); }  if (stores.containsKey(storeName)) { throw new IllegalArgumentException(String.format("%sStore %s has already been registered.", logPrefix, storeName)); }  // check that the underlying change log topic exist or not final String topic = storeToChangelogTopic.get(storeName); if (topic == null) { stores.put(storeName, store); return; }  final TopicPartition storePartition = new TopicPartition(topic, getPartition(topic));  final RecordConverter recordConverter = converterForStore(store);  if (isStandby) { log.trace("Preparing standby replica of persistent state store {} with changelog topic {}", storeName, topic);  restoreCallbacks.put(topic, stateRestoreCallback); recordConverters.put(topic, recordConverter); } else { log.trace("Restoring state store {} from changelog topic {} at checkpoint {}", storeName, topic, checkpointableOffsets.get(storePartition));  final StateRestorer restorer = new StateRestorer( storePartition, new CompositeRestoreListener(stateRestoreCallback), checkpointableOffsets.get(storePartition), offsetLimit(storePartition), store.persistent(), storeName, recordConverter );  changelogReader.register(restorer); } changelogPartitions.add(storePartition);  stores.put(storeName, store); }
[*] target: assertTrue(foundExpectedLogMessage)
[-] pred: org. junit. Assert. assertTrue ( foundExpectedLogMessage )
************************************
************************************
[+] input: shouldCreateTaskStateDirectory() { final TaskId taskId = new TaskId(0, 0); final File taskDirectory = directory.directoryForTask(taskId); "<AssertPlaceHolder>"; assertTrue(taskDirectory.isDirectory()); }
directoryForTask(final TaskId taskId) { final File taskDir = new File(stateDir, taskId.toString()); if (createStateDirectory && !taskDir.exists() && !taskDir.mkdir()) { throw new ProcessorStateException( String.format("task directory [%s] doesn't exist and couldn't be created", taskDir.getPath())); } return taskDir; }
[*] target: assertTrue(taskDirectory.exists())
[-] pred: org. junit. Assert. assertTrue ( taskDirectory. exists ( ) )
************************************
************************************
[+] input: Exception { initializeStateDirectory(false); final TaskId taskId = new TaskId(0, 0); final File taskDirectory = directory.directoryForTask(taskId); "<AssertPlaceHolder>"; }
directoryForTask(final TaskId taskId) { final File taskDir = new File(stateDir, taskId.toString()); if (createStateDirectory && !taskDir.exists() && !taskDir.mkdir()) { throw new ProcessorStateException( String.format("task directory [%s] doesn't exist and couldn't be created", taskDir.getPath())); } return taskDir; }
[*] target: assertFalse(taskDirectory.exists())
[-] pred: org. junit. Assert. assertFalse ( taskDirectory. exists ( ) )
************************************
************************************
[+] input: Exception { initializeStateDirectory(false); final File globalStateDir = directory.globalStateDir(); "<AssertPlaceHolder>"; }
globalStateDir() { final File dir = new File(stateDir, "global"); if (createStateDirectory && !dir.exists() && !dir.mkdir()) { throw new ProcessorStateException( String.format("global state directory [%s] doesn't exist and couldn't be created", dir.getPath())); } return dir; }
[*] target: assertFalse(globalStateDir.exists())
[-] pred: org. junit. Assert. assertFalse ( globalStateDir. exists ( ) )
************************************
************************************
[+] input: shouldNotCheckpointOffsetsOnCommitIfEosIsEnabled() { task = createStatefulTask(createConfig(true), true); task.initializeStateStores(); task.initializeTopology(); task.commit(); final File checkpointFile = new File( stateDirectory.directoryForTask(taskId00), ProcessorStateManager.CHECKPOINT_FILE_NAME );  "<AssertPlaceHolder>"; }
commit() { commit(true); }
[*] target: assertFalse(checkpointFile.exists())
[-] pred: org. junit. Assert. assertFalse ( checkpointFile. exists ( ) )
************************************
************************************
[+] input: shouldCreateWriteBatches() { final String key = "a"; final Collection<KeyValue<byte[], byte[]>> records = new ArrayList<>(); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[0])).get(), serializeValue(50L))); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[3])).get(), serializeValue(100L))); final Map<KeyValueSegment, WriteBatch> writeBatchMap = bytesStore.getWriteBatches(records); "<AssertPlaceHolder>"; for (final WriteBatch batch : writeBatchMap.values()) { assertEquals(1, batch.count()); } }
getWriteBatches(final Collection<KeyValue<byte[], byte[]>> records) { // advance stream time to the max timestamp in the batch for (final KeyValue<byte[], byte[]> record : records) { final long timestamp = keySchema.segmentTimestamp(Bytes.wrap(record.key)); observedStreamTime = Math.max(observedStreamTime, timestamp); }  final Map<KeyValueSegment, WriteBatch> writeBatchMap = new HashMap<>(); for (final KeyValue<byte[], byte[]> record : records) { final long timestamp = keySchema.segmentTimestamp(Bytes.wrap(record.key)); final long segmentId = segments.segmentId(timestamp); final KeyValueSegment segment = segments.getOrCreateSegmentIfLive(segmentId, context, observedStreamTime); if (segment != null) { // This handles the case that state store is moved to a new client and does not // have the local RocksDB instance for the segment. In this case, toggleDBForBulkLoading // will only close the database and open it again with bulk loading enabled. if (!bulkLoadSegments.contains(segment)) { segment.toggleDbForBulkLoading(true); // If the store does not exist yet, the getOrCreateSegmentIfLive will call openDB that // makes the open flag for the newly created store. // if the store does exist already, then toggleDbForBulkLoading will make sure that // the store is already open here. bulkLoadSegments = new HashSet<>(segments.allSegments()); } try { final WriteBatch batch = writeBatchMap.computeIfAbsent(segment, s -> new WriteBatch()); if (record.value == null) { batch.delete(record.key); } else { batch.put(record.key, record.value); } } catch (final RocksDBException e) { throw new ProcessorStateException("Error restoring batch to store " + this.name, e); } } } return writeBatchMap; }
[*] target: assertEquals(2, writeBatchMap.size())
[-] pred: org. junit. Assert. assertEquals ( 2, writeBatchMap. size ( ) )
************************************
************************************
[+] input: shouldCallRocksDbConfigSetter() { MockRocksDbConfigSetter.called = false;  rocksDBStore.openDB(context);  "<AssertPlaceHolder>"; }
openDB(final ProcessorContext context) { // initialize the default rocksdb options  final DBOptions dbOptions = new DBOptions(); final ColumnFamilyOptions columnFamilyOptions = new ColumnFamilyOptions(); userSpecifiedOptions = new RocksDBGenericOptionsToDbOptionsColumnFamilyOptionsAdapter(dbOptions, columnFamilyOptions);  final BlockBasedTableConfig tableConfig = new BlockBasedTableConfig(); tableConfig.setBlockCacheSize(BLOCK_CACHE_SIZE); tableConfig.setBlockSize(BLOCK_SIZE); tableConfig.setFilter(new BloomFilter());  userSpecifiedOptions.optimizeFiltersForHits(); userSpecifiedOptions.setTableFormatConfig(tableConfig); userSpecifiedOptions.setWriteBufferSize(WRITE_BUFFER_SIZE); userSpecifiedOptions.setCompressionType(COMPRESSION_TYPE); userSpecifiedOptions.setCompactionStyle(COMPACTION_STYLE); userSpecifiedOptions.setMaxWriteBufferNumber(MAX_WRITE_BUFFERS); userSpecifiedOptions.setCreateIfMissing(true); userSpecifiedOptions.setErrorIfExists(false); userSpecifiedOptions.setInfoLogLevel(InfoLogLevel.ERROR_LEVEL); // this is the recommended way to increase parallelism in RocksDb // note that the current implementation of setIncreaseParallelism affects the number // of compaction threads but not flush threads (the latter remains one). Also // the parallelism value needs to be at least two because of the code in // https://github.com/facebook/rocksdb/blob/62ad0a9b19f0be4cefa70b6b32876e764b7f3c11/util/options.cc#L580 // subtracts one from the value passed to determine the number of compaction threads // (this could be a bug in the RocksDB code and their devs have been contacted). userSpecifiedOptions.setIncreaseParallelism(Math.max(Runtime.getRuntime().availableProcessors(), 2));  wOptions = new WriteOptions(); wOptions.setDisableWAL(true);  fOptions = new FlushOptions(); fOptions.setWaitForFlush(true);  final Map<String, Object> configs = context.appConfigs(); final Class<RocksDBConfigSetter> configSetterClass = (Class<RocksDBConfigSetter>) configs.get(StreamsConfig.ROCKSDB_CONFIG_SETTER_CLASS_CONFIG);  if (configSetterClass != null) { final RocksDBConfigSetter configSetter = Utils.newInstance(configSetterClass); configSetter.setConfig(name, userSpecifiedOptions, configs); }  if (prepareForBulkload) { userSpecifiedOptions.prepareForBulkLoad(); }  dbDir = new File(new File(context.stateDir(), parentDir), name);  try { Files.createDirectories(dbDir.getParentFile().toPath()); Files.createDirectories(dbDir.getAbsoluteFile().toPath()); } catch (final IOException fatal) { throw new ProcessorStateException(fatal); }  openRocksDB(dbOptions, columnFamilyOptions); open = true; }
[*] target: assertTrue(MockRocksDbConfigSetter.called)
[-] pred: org. junit. Assert. assertTrue ( MockRocksDbConfigSetter.called )
************************************
************************************
[+] input: shouldFlushDirtyEntriesForNamespace() { final ThreadCache cache = new ThreadCache(logContext, 100000, new MockStreamsMetrics(new Metrics())); final List<byte[]> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace1, new ThreadCache.DirtyEntryFlushListener() { @Override public void apply(final List<ThreadCache.DirtyEntry> dirty) { for (final ThreadCache.DirtyEntry dirtyEntry : dirty) { received.add(dirtyEntry.key().get()); } } }); final List<byte[]> expected = Arrays.asList(new byte[]{0}, new byte[]{1}, new byte[]{2}); for (final byte[] bytes : expected) { cache.put(namespace1, Bytes.wrap(bytes), dirtyEntry(bytes)); } cache.put(namespace2, Bytes.wrap(new byte[]{4}), dirtyEntry(new byte[]{4}));  cache.flush(namespace1); "<AssertPlaceHolder>"; }
flush(final String namespace) { numFlushes++;  final NamedCache cache = getCache(namespace); if (cache == null) { return; } cache.flush();  if (log.isTraceEnabled()) { log.trace("Cache stats on flush: #puts={}, #gets={}, #evicts={}, #flushes={}", puts(), gets(), evicts(), flushes()); } }
[*] target: assertEquals(expected, received)
[-] pred: org. junit. Assert. assertEquals ( expected, received )
************************************
************************************
[+] input: shouldNotForwardCleanEntryOnEviction() { final ThreadCache cache = new ThreadCache(logContext, 0, new MockStreamsMetrics(new Metrics())); final List<ThreadCache.DirtyEntry> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace, new ThreadCache.DirtyEntryFlushListener() { @Override public void apply(final List<ThreadCache.DirtyEntry> dirty) { received.addAll(dirty); } }); cache.put(namespace, Bytes.wrap(new byte[]{1}), cleanEntry(new byte[]{0})); "<AssertPlaceHolder>"; }
size() { long size = 0; for (final NamedCache cache : caches.values()) { size += cache.size(); if (isOverflowing(size)) { return Long.MAX_VALUE; } } return size; }
[*] target: assertEquals(0, received.size())
[-] pred: org. junit. Assert. assertEquals ( 0, received. size ( ) )
************************************
************************************
[+] input: shouldParseSingleKeyValuePairString() { final Map<String, String> expectedSinglePairMap = new HashMap<>(); expectedSinglePairMap.put("foo", "bar"); final String singleValueString = "foo=bar"; final Map<String, String> parsedMap = SystemTestUtil.parseConfigs(singleValueString); "<AssertPlaceHolder>"; }
parseConfigs(final String formattedConfigs) { Objects.requireNonNull(formattedConfigs, "Formatted config String can't be null");  if (formattedConfigs.indexOf('=') == -1) { throw new IllegalStateException(String.format("Provided string [ %s ] does not have expected key-value separator of '='", formattedConfigs)); }  final String[] parts = formattedConfigs.split(","); final Map<String, String> configs = new HashMap<>(); for (final String part : parts) { final String[] keyValue = part.split("="); if (keyValue.length > 2) { throw new IllegalStateException( String.format("Provided string [ %s ] does not have expected key-value pair separator of ','", formattedConfigs)); } configs.put(keyValue[KEY], keyValue[VALUE]); } return configs; }
[*] target: assertEquals(expectedSinglePairMap, parsedMap)
[-] pred: org. junit. Assert. assertEquals ( expectedSinglePairMap, parsedMap )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) { CoordinatorClient coordinatorClient = cluster.coordinatorClient();  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); coordinatorClient.createTask(new CreateTaskRequest("foo", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("foo").taskState(new TaskPending(fooSpec)).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("foo")); "<AssertPlaceHolder>";   time.sleep(2); new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskRunning(fooSpec, 2, new TextNode("active"))). workerState(new WorkerRunning("foo", fooSpec, 2, new TextNode("active"))). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); time.sleep(550); // coordinator heartbeat sees that the agent is back up, re-schedules the task but the agent expires it new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). workerState(new WorkerDone("foo", fooSpec, 552, 552, null, "worker expired")). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); // coordinator heartbeat sees that the agent is back up but does not re-schedule the task as it is DONE new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). // no worker states build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02")); } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); time.sleep(552);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); NoOpTaskSpec updatedSpec = new NoOpTaskSpec(552, 500); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskRunning(updatedSpec, 552, new TextNode("receiving")) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1000, 500); time.sleep(999);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskPending(fooSpec) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: testGetDistributedId() { String distributedId = distributedIdManager.getDistributedId(); Assert."<AssertPlaceHolder>"; }
getDistributedId();
[*] target: assertNotNull(distributedId)
[-] pred: org. junit. Assert. assertNotNull ( distributedId )
************************************
************************************
[+] input: IOException { JKongAdmin admin = new JKongAdmin(adminUrl); boolean contains = admin .containsTarget("ba4ccac7-8d9c-4d05-b282-e0e113c29852", "192.168.0.120:8800"); Assert."<AssertPlaceHolder>"; System.out.println(contains); }
containsTarget(String upstreamNameOrId, String target) throws IOException { TargetPageResp pageResp = listTargets(upstreamNameOrId, null);  if (pageResp.getData().size() == 0) { return false; }  for (TargetResp resp : pageResp.getData()) { if (resp.getTarget().equals(target)) { return true; } }  return false; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
************************************
[+] input: testValueOfNull() { // test：when passValue is null ParamTracking paramTracking1 = ParamTracking.build( "param", "source", ScopeTypeEnum.REQUEST, null, String.class, "converter" );  FieldSerializeTracking fieldSerializeTracking1 = new FieldSerializeTracking(); String serializedValue1 = fieldSerializeTracking1.valueSerialize(paramTracking1); Assert."<AssertPlaceHolder>"; }
valueSerialize(FieldTracking fieldTracking) { Object passValue = fieldTracking.getPassValue(); if (passValue == null) { return null; }  String v; if (passValue instanceof String) { v = (String) passValue; } else { v = JSON.toJSONString(passValue, SerializerFeature.DisableCircularReferenceDetect); } if (GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT == -1 || (v.length() <= GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT)) { return v; } else { try { return v.substring(0, GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT); } catch (Exception e) { LOGGER.error("build ParamTracking error! tracking: {}", fieldTracking, e); } } return null; }
[*] target: assertNull(serializedValue1)
[-] pred: org. junit. Assert. assertNull ( serializedValue1 )
************************************
************************************
[+] input: testSendMessage_toUser_success() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToUserUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  List<String> weComIds = ImmutableList.of("user1", "user2"); String msg = "test msg"; boolean result = weComSender.sendMessageToUsers(weComIds, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToUsers(List<String> weComUserIds, String msg) { if (CollectionUtils.isEmpty(weComUserIds)) { log.warn("Prepare to send messages to weCom users, but `weComUserIds` is empty"); return false; }  String token = getToken(); String url = String.format(sendToUserUrl, token); WeComToUserMessage weComToUserMessage = WeComToUserMessage.from(StringUtils.join(weComUserIds, "|"), agentid, msg); log.debug("ready to send message: {} to wecom users: {}", msg, weComToUserMessage.getTouser()); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToUserMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom users: {} failed.", msg, weComToUserMessage.getTouser()); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testSendMessage_toUser_failed() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToUserUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(1, "invalid token"); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  List<String> weComIds = ImmutableList.of("user1", "user2"); String msg = "test msg"; boolean result = weComSender.sendMessageToUsers(weComIds, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToUsers(List<String> weComUserIds, String msg) { if (CollectionUtils.isEmpty(weComUserIds)) { log.warn("Prepare to send messages to weCom users, but `weComUserIds` is empty"); return false; }  String token = getToken(); String url = String.format(sendToUserUrl, token); WeComToUserMessage weComToUserMessage = WeComToUserMessage.from(StringUtils.join(weComUserIds, "|"), agentid, msg); log.debug("ready to send message: {} to wecom users: {}", msg, weComToUserMessage.getTouser()); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToUserMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom users: {} failed.", msg, weComToUserMessage.getTouser()); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testSendMessage_toChat_success() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToChatUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  String chatid = "1"; String msg = "test msg"; boolean result = weComSender.sendMessageToChat(chatid, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToChat(String chatid, String msg) { if (StringUtils.isBlank(chatid)) { log.warn("Prepare to send messages to weCom chat, but `chatid` is empty"); return false; }  String token = getToken(); String url = String.format(sendToChatUrl, token); WeComToChatMessage weComToChatMessage = WeComToChatMessage.from(chatid, msg); log.debug("ready to send message: {} to wecom chat: {}", msg, chatid); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToChatMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom chat: {} failed.", msg, chatid); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testSendMessage_toChat_failed() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToChatUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(1, "invalid token"); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  String chatid = "1"; String msg = "test msg"; boolean result = weComSender.sendMessageToChat(chatid, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToChat(String chatid, String msg) { if (StringUtils.isBlank(chatid)) { log.warn("Prepare to send messages to weCom chat, but `chatid` is empty"); return false; }  String token = getToken(); String url = String.format(sendToChatUrl, token); WeComToChatMessage weComToChatMessage = WeComToChatMessage.from(chatid, msg); log.debug("ready to send message: {} to wecom chat: {}", msg, chatid); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToChatMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom chat: {} failed.", msg, chatid); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testGetTaskRunDetail() { TaskRun taskRun = prepareData(); TaskRunVO existedRun = taskRunService.getTaskRunDetail(taskRun.getId()).get(); "<AssertPlaceHolder>"; assertNotNull(existedRun.getTask()); }
getTaskRunDetail(Long taskRunId) { Optional<TaskRun> taskRun = taskRunDao.fetchTaskRunById(taskRunId); return taskRun.map(this::convertToVO); }
[*] target: assertNotNull(existedRun)
[-] pred: org. junit. Assert. assertNotNull ( existedRun )
************************************
************************************
[+] input: generateToken() { SingleJWT jwt = new SingleJWT("secret", 1000); String token = jwt.generateToken("test", 1, "test", 1000); "<AssertPlaceHolder>"; log.info(token); }
generateToken(String tokenType, long identity, String scope, long expire) { Date expireDate = DateUtil.getDurationDate(expire); return builder .withClaim("type", tokenType) .withClaim("identity", identity) .withClaim("scope", scope) .withExpiresAt(expireDate) .sign(algorithm); }
[*] target: assertNotNull(token)
[-] pred: org. junit. Assert. assertNotNull ( token )
************************************
************************************
[+] input: SemanticException { SubstringDomain assume1 = domainB.assume(YSubstringOfX, null, null, null); SubstringDomain assume2 = domainB.assume(XEndsWithY, null, null, null); SubstringDomain assume3 = domainB.assume(XStartsWithY, null, null, null);  "<AssertPlaceHolder>"; assertEquals(assume1, assume3); assertTrue(assume1.getState(x).contains(y)); assertTrue(assume1.getState(x).contains(w)); assertTrue(assume1.getState(x).contains(z)); assertTrue(assume1.getState(y).contains(z)); }
assume( ValueExpression expression, ProgramPoint src, ProgramPoint dest, SemanticOracle oracle) throws SemanticException {  /* * Assume only binary expressions */ if (expression instanceof BinaryExpression) {  BinaryExpression binaryExpression = (BinaryExpression) expression; BinaryOperator binaryOperator = binaryExpression.getOperator();  SymbolicExpression left = binaryExpression.getLeft(); SymbolicExpression right = binaryExpression.getRight();  /* * The string type is unique and can be retrieved from the type * system. */ Type strType; if (src != null) // Correct: get the string type from the program // point strType = src.getProgram().getTypes().getStringType(); else // Used in tests where src is null, get the string type from // the expression strType = left.getStaticType();  if (binaryOperator instanceof StringContains || binaryOperator instanceof StringStartsWith || binaryOperator instanceof StringEndsWith) {  /* * Evaluate only if the left operand is an identidier */  if (!(left instanceof Identifier)) return this;  if (!(right instanceof ValueExpression)) throw new SemanticException("instanceof right");  Set<SymbolicExpression> extracted = extrPlus((ValueExpression) right, src, oracle, strType); SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.add(extracted, (Identifier) left); result = result.closure(); return result.clear();  } else if (binaryOperator instanceof StringEquals) {  // case both operands are identifiers if ((left instanceof Identifier) && (right instanceof Identifier)) { SubstringDomain result = mk(lattice, mkNewFunction(function, false)); result = result.add(left, (Identifier) right); result = result.add(right, (Identifier) left); result = result.closure(); return result.clear(); } // case where only one is an identifier else if ((left instanceof Identifier) || (right instanceof Identifier)) { if (right instanceof Identifier) { // make left the identifier SymbolicExpression temp = left; left = right; right = temp; }  if (!(right instanceof ValueExpression)) throw new SemanticException("instanceof right != ValueExpression.class");  Set<SymbolicExpression> add = extrPlus((ValueExpression) right, src, oracle, strType);  SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.add(add, (Identifier) left); result = result.closure(); return result.clear();  } } else if (binaryOperator instanceof LogicalOr || binaryOperator instanceof LogicalAnd) {  if (!(left instanceof ValueExpression) || !(right instanceof ValueExpression)) throw new SemanticException( "!(left instanceof ValueExpression) || !(right instanceof ValueExpression)");  ValueExpression rightValueExpression = (ValueExpression) right; ValueExpression leftValueExpression = (ValueExpression) left; SubstringDomain leftDomain = assume(leftValueExpression, src, dest, oracle); SubstringDomain rightDomain = assume(rightValueExpression, src, dest, oracle);  if (binaryOperator instanceof LogicalOr) { return leftDomain.lub(rightDomain).clear(); } else { return leftDomain.glb(rightDomain).clear(); } }  }  return this; }
[*] target: assertEquals(assume1, assume2)
[-] pred: org. junit. Assert. assertEquals ( assume1, assume2 )
************************************
************************************
[+] input: SemanticException { ValueExpression abcd = new Constant(StringType.INSTANCE, "abcd", SyntheticLocation.INSTANCE); ValueExpression ab = new Constant(StringType.INSTANCE, "ab", SyntheticLocation.INSTANCE); ValueExpression cd = new Constant(StringType.INSTANCE, "cd", SyntheticLocation.INSTANCE); ValueExpression ABConcatCD = new BinaryExpression(StringType.INSTANCE, ab, cd, StringConcat.INSTANCE, SyntheticLocation.INSTANCE);  SubstringDomain empty = new SubstringDomain(); SubstringDomain assigned1 = empty.assign(x, abcd, null, null); SubstringDomain assigned2 = empty.assign(x, ABConcatCD, null, null);  "<AssertPlaceHolder>"; }
assign( Identifier id, ValueExpression expression, ProgramPoint pp, SemanticOracle oracle) throws SemanticException {  /* * If the assigned expression is not dynamically typed as a string (or * untyped) return this. */ if (oracle != null && pp != null && oracle.getRuntimeTypesOf(expression, pp, oracle).stream() .allMatch(t -> !t.isStringType() && !t.isUntyped())) return this;  /* * The string type is unique and can be retrieved from the type system. */ Type strType; if (pp != null) // Correct: get the string type from the program point strType = pp.getProgram().getTypes().getStringType(); else // Used in tests where pp is null, get the string type from the // expression strType = expression.getStaticType();  Set<SymbolicExpression> expressions = extrPlus(expression, pp, oracle, strType); SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.remove(expressions, id); result = result.add(expressions, id); result = result.interasg(id, expression); result = result.closure(id); return result.clear(); }
[*] target: assertEquals(assigned1, assigned2)
[-] pred: org. junit. Assert. assertEquals ( assigned1, assigned2 )
************************************
************************************
[+] input: SemanticException { List<Brick> bricksList = new ArrayList<>(); List<Brick> bricksList1 = new ArrayList<>();  Set<String> treeSet = new TreeSet<>(); treeSet.add("mo"); treeSet.add("de");  Brick brick = new Brick(1, 4, treeSet);  Set<String> treeSet1 = new TreeSet<>(); treeSet1.add("mo"); treeSet1.add("de"); treeSet1.add("re");  Brick brick1 = new Brick(0, 5, treeSet1);  Set<String> treeSet2 = new TreeSet<>(); treeSet2.add("ge"); treeSet2.add("ze");  Brick brick2 = new Brick(1, 3, treeSet2);  Set<String> treeSet3 = new TreeSet<>(); treeSet3.add("ge"); treeSet3.add("ze"); treeSet3.add("le");  Brick brick3 = new Brick(1, 4, treeSet3);  bricksList.add(brick); bricksList.add(brick2);  bricksList1.add(brick1); bricksList1.add(brick3);  Bricks bricks = new Bricks(bricksList); Bricks bricks1 = new Bricks(bricksList1);  "<AssertPlaceHolder>"; }
lessOrEqualAux( Bricks other) throws SemanticException { List<Brick> thisPaddedList = this.bricks; List<Brick> otherPaddedList = other.bricks;  if (this.bricks.size() < other.bricks.size()) thisPaddedList = this.padList(other); else if (other.bricks.size() < this.bricks.size()) otherPaddedList = other.padList(this);  for (int i = 0; i < thisPaddedList.size(); ++i) { Brick first = thisPaddedList.get(i); Brick second = otherPaddedList.get(i); if (!first.lessOrEqual(second)) return false; }  return true; }
[*] target: assertTrue(bricks.lessOrEqualAux(bricks1))
[-] pred: org. junit. Assert. assertTrue ( bricks. lessOrEqualAux ( bricks1 ) )
************************************
************************************
[+] input: testFetchingExecutorForValidCommand() { final CommandExecutor commandExecutor = factory.getCommandExecutor(new Command("leave 1")); "<AssertPlaceHolder>"; assertTrue(commandExecutor instanceof LeaveCommandExecutor); }
getCommandExecutor(final Command command) { final CommandExecutor commandExecutor = commands.get(command.getCommandName()); if (commandExecutor == null) { throw new InvalidCommandException(); } return commandExecutor; }
[*] target: assertNotNull(commandExecutor)
[-] pred: org. junit. Assert. assertNotNull ( commandExecutor )
************************************
************************************
[+] input: testGetSlotsForAParticularCarColorWhenNoCarMatches() { final Map<Integer, Slot> allSlots = new HashMap<>(); final Slot slot1 = new Slot(1); slot1.assignCar(new Car("test-car-no1", "blue")); final Slot slot2 = new Slot(2); final Slot slot3 = new Slot(3); slot3.assignCar(new Car("test-car-no2", "red"));  allSlots.put(1, slot1); allSlots.put(2, slot2); allSlots.put(3, slot3);  when(parkingLot.getSlots()).thenReturn(allSlots); when(parkingLot.getCapacity()).thenReturn(10);  final List<Slot> slots = parkingLotService.getSlotsForColor("white"); "<AssertPlaceHolder>"; }
getSlotsForColor(final String color) { final List<Slot> occupiedSlots = getOccupiedSlots(); return occupiedSlots.stream() .filter(slot -> slot.getParkedCar().getColor().equals(color)) .collect(Collectors.toList()); }
[*] target: assertEquals(0, slots.size())
[-] pred: org. junit. Assert. assertEquals ( 0, slots. size ( ) )
************************************
************************************
[+] input: InterruptedException { Path file = Paths.get(getTestLog("utf8.log"));  byte[] data = Files.readAllBytes(file);  int nonLatinCharOffset = -1; for (int i = 0; i < data.length; i++) { if (data[i] < 0) { assert data[i + 1] < 0; nonLatinCharOffset = i; break; } }  assert nonLatinCharOffset >= 0;  Log log = getLogService().openLog(file, new SimpleLogFormat(StandardCharsets.UTF_8));  Pair<String, Integer> pair = log.loadContent(0, nonLatinCharOffset + 1).get();  int dataLen = pair.getSecond();  "<AssertPlaceHolder>"; assertEquals(new String(Arrays.copyOf(data, dataLen), StandardCharsets.UTF_8), pair.getFirst()); }
loadContent(long offset, int length) { CompletableFuture<Pair<String, Integer>> res = new CompletableFuture<>();  executor.submit(() -> { try { if (!accessManager.isFileVisible(file)) { res.completeExceptionally(new SecurityException(accessManager.errorMessage(file))); return; }  if (length > ParserConfig.MAX_LINE_LENGTH) throw new IllegalStateException();  try (RandomAccessFile input = new RandomAccessFile(file.toFile(), "r")) { input.seek(offset);  byte[] data = new byte[length]; input.readFully(data);  res.complete(Utils.decode(data, encoding)); } } catch (Throwable e) { res.completeExceptionally(e); } });  return res; }
[*] target: assertEquals(nonLatinCharOffset, dataLen)
[-] pred: org. junit. Assert. assertEquals ( nonLatinCharOffset, dataLen )
************************************
************************************
[+] input: InterruptedException { for (int i = 0; i < (Integer.MAX_VALUE - 500); i+=100) { BigInteger s = BigInteger.valueOf(i);  byte[] bytes = ConverterUtil.bigIntegerToByte(s); BigInteger l = ConverterUtil.byteToBigInteger(bytes); Assert."<AssertPlaceHolder>"; }  }
byteToBigInteger(byte[] bytes) { BigInteger res = BigInteger.valueOf(0); for (byte b : bytes) { res = res.shiftLeft(8); res = res.or(BigInteger.valueOf(b & 0xff)); } return res; }
[*] target: assertEquals(s, l)
[-] pred: org. junit. Assert. assertEquals ( s, l )
************************************
************************************
[+] input: Exception { var bout = new ByteArrayOutputStream(); var out = new BytesOut(bout, 8); out.flush();  byte[] b1 = "hello".getBytes("UTF-8"); out.write(b1, 0, b1.length);  byte[] b2 = "world".getBytes("UTF-8"); out.write(b2, 0, b2.length);  byte[] b3 = "hello, world!!!".getBytes("UTF-8"); out.write(b3, 0, b3.length);  out.flush(); byte[] result = bout.toByteArray(); byte[] expect = "helloworldhello, world!!!".getBytes("UTF-8"); "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertArrayEquals(expect, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, result )
************************************
************************************
[+] input: Exception { var bout = new ByteArrayOutputStream(); var out = new BytesOut(bout, 15);  out.writeLong(Long.MAX_VALUE); out.writeLong(Long.MIN_VALUE);  out.flush(); byte[] result = bout.toByteArray(); byte[] expect = {127, -1, -1, -1, -1, -1, -1, -1, -128, 0, 0, 0, 0, 0, 0, 0}; "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertArrayEquals(expect, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, result )
************************************
************************************
[+] input: IOException { String testStr = "( defun test () "hi there")"; Sexp parsedExpression = SexpFactory.parse(testStr); Sexp expectedExpression = SexpFactory.newNonAtomicSexp(); expectedExpression.add(SexpFactory.newAtomicSexp("defun")); expectedExpression.add(SexpFactory.newAtomicSexp("test")); expectedExpression.add(SexpFactory.newNonAtomicSexp()); expectedExpression.add(SexpFactory.newAtomicSexp(""hi there"")); Assert."<AssertPlaceHolder>"; }
add(Sexp item);
[*] target: assertEquals(expectedExpression, parsedExpression)
[-] pred: org. junit. Assert. assertEquals ( expectedExpression, parsedExpression )
************************************
************************************
[+] input: testEquals() { RoleDTO roleDTO = new RoleDTO(1L, "USER"); RoleDTO roleDTO2 = new RoleDTO(1L, "USER");  assertTrue(roleDTO.equals(roleDTO)); assertFalse(roleDTO.equals("WRONG")); "<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) return true; if (!(o instanceof RoleDTO)) return false; return id != null && id.equals(((RoleDTO) o).getId()); }
[*] target: assertTrue(roleDTO.equals(roleDTO2))
[-] pred: org. junit. Assert. assertTrue ( roleDTO. equals ( roleDTO2 ) )
************************************
************************************
[+] input: given_existing_user_when_getUserById_returnUser() { Long userId = 1L;  User user = getUserTestData(userId, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findById(userId)).willReturn(Optional.of(user));  User userRet = userService.getUserById(userId);  "<AssertPlaceHolder>"; assertEquals(userId, userRet.getId()); assertEquals("andrea", userRet.getUsername()); assertEquals("Andrea", userRet.getName()); assertEquals("Giassi", userRet.getSurname()); assertEquals("andrea.test@gmail.com", userRet.getContact().getEmail()); assertEquals("+3531122334455", userRet.getContact().getPhone()); }
getUserById(Long id) { if (id == null) { throw new InvalidUserIdentifierException("User Id cannot be null"); } Optional<User> userOpt = userRepository.findById(id); if (userOpt.isPresent()) { return userOpt.get(); } throw new UserNotFoundException(String.format("User not found for Id = %s", id)); }
[*] target: assertNotNull(userRet)
[-] pred: org. junit. Assert. assertNotNull ( userRet )
************************************
************************************
[+] input: given_existing_username_when_getUserByUsername_return_user() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findByUsername("andrea")).willReturn(userDataForTest);  User user = userService.getUserByUsername("andrea");  "<AssertPlaceHolder>"; assertEquals(Long.valueOf(1L), user.getId()); assertEquals("andrea", user.getUsername()); assertEquals("Andrea", user.getName()); assertEquals("Giassi", user.getSurname()); assertEquals("andrea.test@gmail.com", user.getContact().getEmail()); assertEquals("+3531122334455", user.getContact().getPhone()); }
getUserByUsername(String username) { if (username == null) { throw new InvalidUsernameException("username cannot be null"); } return userRepository.findByUsername(username); }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_existing_email_when_getUserByEmail_return_user() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findByEmail("andrea.test@gmail.com")).willReturn(userDataForTest);  User user = userService.getUserByEmail("andrea.test@gmail.com");  "<AssertPlaceHolder>"; assertEquals(Long.valueOf(1L), user.getId()); assertEquals("andrea", user.getUsername()); assertEquals("Andrea", user.getName()); assertEquals("Giassi", user.getSurname()); assertEquals("andrea.test@gmail.com", user.getContact().getEmail()); assertEquals("+3531122334455", user.getContact().getPhone()); }
getUserByEmail(String email) { if (email == null) { throw new InvalidEmailException("email cannot be null"); } return userRepository.findByEmail(email); }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_validUserAndRoleIds_when_addRole_returnUser() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findById(1L)).willReturn(Optional.of(userDataForTest));  Role roleAdmin = new Role(Role.ADMINISTRATOR, "Administrator");  given(roleRepository.findById(2L)).willReturn(Optional.of(roleAdmin));  User user = userService.addRole(1L, 2L);  "<AssertPlaceHolder>";  // check the new added role Set<Role> roleSet = user.getRoles();  assertNotNull(roleSet); assertEquals(2, roleSet.size()); assertTrue(roleSet.contains(roleAdmin)); }
addRole(Long id, Long roleId) { // check user Optional<User> userOpt = userRepository.findById(id); if (!userOpt.isPresent()) { throw new UserNotFoundException(String.format("User not found with Id = %s", id)); } User user = userOpt.get();  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); }  Role role = roleOpt.get();  user.getRoles().add(role); user.setUpdatedDt(LocalDateTime.now());  userRepository.save(user); log.info(String.format("Added role %s on user id = %s", role.getRole(), user.getId()));  return user; }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_validUserAndRoleIds_when_removeRole_returnUser() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  Role roleAdmin = new Role(Role.ADMINISTRATOR, "Administrator"); userDataForTest.getRoles().add(roleAdmin);  given(userRepository.findById(1L)).willReturn(Optional.of(userDataForTest)); given(roleRepository.findById(2L)).willReturn(Optional.of(roleAdmin));  User user = userService.removeRole(1L, 2L);  "<AssertPlaceHolder>";  // check the remove role Set<Role> roleSet = user.getRoles();  assertNotNull(roleSet); assertEquals(1, roleSet.size()); assertTrue(!roleSet.contains(roleAdmin)); }
removeRole(Long id, Long roleId) { // check user Optional<User> userOpt = userRepository.findById(id); if (!userOpt.isPresent()) { throw new UserNotFoundException(String.format("User not found with Id = %s", id)); } User user = userOpt.get();  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); }  Role role = roleOpt.get();  user.getRoles().remove(role); user.setUpdatedDt(LocalDateTime.now());  userRepository.save(user); log.info(String.format("Removed role %s on user id = %s", role.getRole(), user.getId()));  return user; }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: mergeReduceFile() { CommonFile.mergeReduceOutFiles(Collections.singletonList(MR_EXPECT_REDUCE)); String expect = FileUtil.readFile(MR_EXPECT_OUT); String act = FileUtil.readFile(CommonFile.MR_MERGE_OUT); Assert."<AssertPlaceHolder>"; }
mergeReduceOutFiles(List<String> reduceFiles) { Map<String, String> kvs = new HashMap<>(); reduceFiles.forEach(reduceFile -> { Stream<String> stream = FileUtil.stream(reduceFile); if (stream == null) { return; } stream.forEach(s -> { KeyValue keyValue = JSON.parseObject(s.getBytes(StandardCharsets.UTF_8), KeyValue.class); kvs.put(keyValue.getKey(), keyValue.getValue()); } ); }); List<String> keys = new ArrayList<>(kvs.keySet()); keys.sort(String::compareTo); keys.forEach(key -> { FileUtil.append(MR_MERGE_OUT, key + ": " + kvs.get(key)); }); LogUtil.log("ok to merge all files"); }
[*] target: assertEquals(expect, act)
[-] pred: org. junit. Assert. assertEquals ( expect, act )
************************************
************************************
[+] input: initModel() { boolean res = activityActivityTestRule.getActivity().initModel(); Log.d("EnhancementTest", "res:" + res); "<AssertPlaceHolder>"; }
initModel() { enhancement = new com.sensifai.enhancement.tflite.Enhancement(true); return enhancement.init(this, ENHANCEMENT_TFLITE_MODEL_NAME, Device.GPU, 1); }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: testSaveToString() { FileConfiguration config = getConfig();  for (Map.Entry<String, Object> entry : getTestValues().entrySet()) { config.set(entry.getKey(), entry.getValue()); }  String result = config.saveToString(); String expected = getTestValuesString();  "<AssertPlaceHolder>"; }
saveToString();  /** * Loads this {@link FileConfiguration}
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testSaveToStringWithIndent() { YamlConfiguration config = getConfig(); config.options().indent(9);  config.set("section.key", 1);  String result = config.saveToString(); String expected = "section:\n         key: 1\n";  "<AssertPlaceHolder>"; }
saveToString() { yamlOptions.setIndent(options().indent()); yamlOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK); yamlOptions.setAllowUnicode(SYSTEM_UTF); yamlRepresenter.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);  String header = buildHeader(); String dump = yaml.dump(getValues(false));  if (dump.equals(BLANK_CONFIG)) { dump = ""; }  return header + dump; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: Exception { ComponentName cn = new ComponentName(getContext(), TEST_ACTIVITY); initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), false  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: Exception { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = new ComponentName(mContext.getPackageName(), "placeholder-do"); WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), true  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: UnsupportedEncodingException { BigDecimal decimal = new BigDecimal("1234567890123456789012345678901234567890.1234567809"); byte[] bytes = SerializeUtils.bigDecimal2Bytes(decimal); BigDecimal decimal1 = SerializeUtils.bytes2BigDecimal(bytes); "<AssertPlaceHolder>"; }
bytes2BigDecimal(byte[] bytes) throws UnsupportedEncodingException { String val = new String(bytes, "UTF-8"); return new BigDecimal(val); }
[*] target: assertEquals(decimal,decimal1)
[-] pred: org. junit. Assert. assertEquals ( decimal, decimal1 )
************************************
************************************
[+] input: backupAccountToKeyStoreTest() { //Create password accounts Chain chain = new Chain(); chain.setConfig(new ConfigBean(chainId, assetId)); List<Account> accountList = accountService.createAccount(chain, 1, password); String address = accountList.get(0).getAddress().getBase58(); //Test not specifying backup path String pathDir = ""; //Backup accountkeystore  backup account keyStore String path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); assertNotNull(path);  //Test specified nonwindowsBackup path pathDir = "test1/back/up"; //Backup accountkeystore  backup account keyStore path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); assertNotNull(path);  //Test specifiedwindowsBackup path pathDir = "D:\\workspace\\github\\nuls_2.0\\test2\\back\\up"; //Create an unencrypted account for test accountList = accountService.createAccount(chain, 1, null); address = accountList.get(0).getAddress().getBase58(); //Backup accountkeystore  backup account keyStore path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); "<AssertPlaceHolder>";  }
backupAccountToKeyStore(String path, int chainId, String address, String password);
[*] target: assertNotNull(path)
[-] pred: org. junit. Assert. assertNotNull ( path )
************************************
************************************
[+] input: Exception { // create account Alias alias = AliasStorageServiceTest.createAlias(); boolean result = aliasService.aliasTxCommit(chainId,alias); "<AssertPlaceHolder>"; Account account = accountService.getAccount(chainId, AddressTool.getStringAddressByBytes(alias.getAddress())); assertNotNull(account); assertEquals(account.getAlias(),alias.getAlias()); }
aliasTxCommit(int chainId, Alias alias) throws NulsException;
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { Account account = AccountTool.createAccount(chainId); boolean result = accountStorageService.saveAccount(new AccountPO(account)); "<AssertPlaceHolder>"; }
saveAccount(AccountPO account);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { Alias alias1 = createAlias(); boolean result = aliasStorageService.saveAlias(chainId,alias1); assertTrue(result); Alias alias2 = createAlias(); result = aliasStorageService.saveAlias(chainId,alias2); "<AssertPlaceHolder>"; }
saveAlias(int chainId, Alias alias);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { int start = 1; int count = 10; List<Block> blocks = new ArrayList<>();  GenesisBlock genesisBlock = GenesisBlock.getInstance(0, 0); blocks.add(genesisBlock);  Block preBlock = genesisBlock; do{ Block block = BlockGenerator.generate(preBlock); blocks.add(block); preBlock = block; start++; } while (start < count);  for (int i = 0; i < blocks.size()-1; i++) { NulsHash prehash = blocks.get(i).getHeader().getHash(); NulsHash hash = blocks.get(i+1).getHeader().getPreHash(); Assert."<AssertPlaceHolder>"; } }
generate(Block latestBlock) throws Exception { return generate(latestBlock, 1, "1"); }
[*] target: assertEquals(prehash, hash)
[-] pred: org. junit. Assert. assertEquals ( prehash, hash )
************************************
************************************
[+] input: NulsException { ProtocolVersion version1 = new ProtocolVersion(); version1.setVersion((byte) 1); version1.setEffectiveRatio((byte) 85); version1.setContinuousIntervalCount((short) 260); String hex = HexUtil.encode(version1.serialize()); ProtocolVersion version2 = new ProtocolVersion(); version2.parse(new NulsByteBuffer(HexUtil.decode(hex))); assertEquals(version1.getVersion(), version2.getVersion()); assertEquals(version1.getEffectiveRatio(), version2.getEffectiveRatio()); "<AssertPlaceHolder>"; assertEquals(version1, version2); }
getContinuousIntervalCount() { return continuousIntervalCount; }
[*] target: assertEquals(version1.getContinuousIntervalCount(), version2.getContinuousIntervalCount())
[-] pred: org. junit. Assert. assertEquals ( version1. getContinuousIntervalCount ( ), version2. getContinuousIntervalCount ( ) )
************************************
************************************
[+] input: Exception { List<TransactionConfirmedPO> list = new ArrayList<>(); for (int i = 0; i < 5; i++) { Transaction tx = TestConstant.getTransaction2(); tx.setRemark(StringUtils.bytes("tx remark" + i)); list.add(new TransactionConfirmedPO(tx, 1, (byte)1)); } boolean result = confirmedTxStorageService.saveTxList(chainId, list); Assert."<AssertPlaceHolder>"; }
saveTxList(int chainId, List<TransactionConfirmedPO> txList);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { Transaction tx = TestConstant.getTransaction2(); boolean result = unconfirmedTxStorageService.putTx(chainId, tx); Assert."<AssertPlaceHolder>"; }
putTx(int chainId, Transaction tx);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: dumpSites() { final Context context = ServiceLocator.getInstance().getAppContext();  for (final Site.Type type : Site.Type.values()) { final List<Site> sites = type.getSites(); Log.d(TAG, "\n------------------------------------------\n\n" + type);  for (final Site site : sites) { final EngineId engineId = site.getEngineId(); final SearchEngineConfig config = engineId.getConfig(); assertNotNull(config); final SearchEngine searchEngine = engineId.createSearchEngine(context); "<AssertPlaceHolder>";  Log.d(TAG, "\n" + config + "\n\n" + site + "\n\n" + searchEngine); } } }
createSearchEngine(@NonNull final Context context) { try { final Constructor<? extends SearchEngine> c = clazz.getConstructor(Context.class, SearchEngineConfig.class); return c.newInstance(context.getApplicationContext(), config);  } catch (@NonNull final NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) { throw new IllegalStateException( clazz + " must implement SearchEngine(Context, SearchEngineConfig)", e); } }
[*] target: assertNotNull(searchEngine)
[-] pred: org. junit. Assert. assertNotNull ( searchEngine )
************************************
************************************
[+] input: testParseJson() { String json = "[\n" + "{\n" + ""id": "Source__TableSourceScan(table=[[default_catalog__default_database__nexmark]]__fi.numRecordsOutPerSecond",\n" + ""min": 5003.2,\n" + ""max": 5003.2,\n" + ""avg": 5003.2,\n" + ""sum": 10006.3\n" + "}\n" + "]";  TpsMetric tps = TpsMetric.fromJson(json); TpsMetric expected = new TpsMetric( "Source__TableSourceScan(table=[[default_catalog__default_database__nexmark]]__fi.numRecordsOutPerSecond", 5003.2, 5003.2, 5003.2, 10006.3); "<AssertPlaceHolder>"; }
fromJson(String json) { try { JsonNode jsonNode = NexmarkUtils.MAPPER.readTree(json); return NexmarkUtils.MAPPER.convertValue(jsonNode.get(0), TpsMetric.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } }
[*] target: assertEquals(expected, tps)
[-] pred: org. junit. Assert. assertEquals ( expected, tps )
************************************
************************************
[+] input: authorize() { Mockito.when(session.principal()).thenReturn(customPrincipal); Mockito.when(customPrincipal.getOauthBearerTokenJwt()).thenReturn(jwt);  Set<String> set = new HashSet<>(); set.add("urn:kafka:topic:test:write");  Mockito.when(jwt.scope()).thenReturn(set); Mockito.when(resource.name()).thenReturn("test"); Mockito.when(resource.resourceType()).thenReturn(ResourceType.fromString("topic")); Mockito.when(operation.toJava()).thenReturn(AclOperation.fromString("write")); boolean result = customAuthorizer.authorize(session, operation, resource);  "<AssertPlaceHolder>"; }
authorize(Session session, Operation operation, Resource resource) { try { log.info("Starting Authorization."); // log.info("Session Info: {}", session.toString()); log.info("Operation request Info: {}", operation.toString()); log.info("Resource request Info: {}", resource.toString()); if (!(session.principal() instanceof CustomPrincipal)) { log.error("Session Principal is not using the proper class. Should be instance of CustomPrincipal."); return false; }  CustomPrincipal principal = (CustomPrincipal) session.principal(); if (principal.getOauthBearerTokenJwt() == null) { log.error("Custom Principal does not contain token information."); return false; }  OAuthBearerTokenJwt jwt = principal.getOauthBearerTokenJwt(); if (jwt.scope() == null || jwt.scope().isEmpty()) { log.error("No scopes provided in JWT. Unable to Authorize."); return false; }  java.util.Set<String> scopes = jwt.scope(); List<OAuthScope> scopeInfo = parseScopes(scopes); String operationStr = operation.toJava().toString(); return checkAuthorization(scopeInfo, resource, operationStr); } catch (Exception e) { log.error("Error in authorization. ", e); } return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: checkAuthorization() { List<OAuthScope> list = new ArrayList<>(); OAuthScope scope = new OAuthScope(); scope.setOperation("Write"); scope.setResourceName("test"); scope.setResourceType("topic"); list.add(scope);  Resource resource = new Resource(ResourceType.fromString("Topic"), "TEST");  CustomAuthorizer authorizer = new CustomAuthorizer();  boolean result = authorizer.checkAuthorization(list, resource, "write");  "<AssertPlaceHolder>";  }
checkAuthorization(List<OAuthScope> scopeInfo, Resource resource, String operation) { for (int i = 0; i < scopeInfo.size(); i++) { OAuthScope scope = scopeInfo.get(i); String lowerCaseOperation = operation.toLowerCase(); String lowerCaseResourceName = resource.name().toLowerCase(); String lowerCaseCaseResourceType = resource.resourceType().toString().toLowerCase();  boolean operationVal = scope.getOperation().toLowerCase().equals(lowerCaseOperation); boolean nameVal = scope.getResourceName().toLowerCase().equals(lowerCaseResourceName); boolean typeVal = scope.getResourceType().toLowerCase().equals(lowerCaseCaseResourceType);  if (operationVal && nameVal && typeVal) { log.info("Successfully Authorized."); return true; } } log.info("Not Authorized to operate on the given resource."); return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testServicesEmpty() { Collection<Service> services = collector.services(); Assert."<AssertPlaceHolder>"; }
services() { return Collections.unmodifiableMap(services).values(); }
[*] target: assertEquals(0, services.size())
[-] pred: org. junit. Assert. assertEquals ( 0, services. size ( ) )
************************************
************************************
[+] input: if_validator_data_missing_then_retrieved_via_radix_engine() { var self = BFTNode.random(); var radixEngine = TypedMocks.cmock(new TypeLiteral<RadixEngine<LedgerAndBFTProof>>() {}); var systemInfo = new InMemorySystemInfo(null, null, self, radixEngine); var validatorBFTData = Optional.of(new ValidatorBFTDataEvent(self.getKey(), 10, 1));  when(radixEngine.read(any())).thenReturn(validatorBFTData);  var result = systemInfo.getValidatorBFTData(); var expected = Optional.of(new ValidatorBFTDataEvent(self.getKey(), 10, 1));  "<AssertPlaceHolder>"; }
getValidatorBFTData() { if (!missedProposals.isMarked()) { // There were no relevant events yet missedProposals.set(getProposalStats(), true); }  return missedProposals.getReference(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: verify_that_tobytearray_returns_same_as_passed_in_constructor() { byte[] bytes = Bytes.fromHexString("dead000000000000000000000000beef"); EUID euid = new EUID(bytes); "<AssertPlaceHolder>"; }
toByteArray() { return value.toByteArray(); }
[*] target: assertArrayEquals(bytes, euid.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( bytes, euid. toByteArray ( ) )
************************************
************************************
[+] input: InactiveSensorException { sensor = new TempSensor("TEST"); String testString = "TempSensor{name='TEST', alias='test', address='28-456A123654xxx', sensorOffset=2, gpio=null, lastReadTime=null, lastTempRead=0}"; "<AssertPlaceHolder>"; }
toString() { return "TempSensor{" + "name='" + name + ''' + ", alias='" + alias + ''' + ", address='" + address + ''' + ", sensorOffset=" + sensorOffset + ", lastReadTime=" + lastReadTime + ", lastTempRead=" + lastTempRead + '}'; }
[*] target: assertEquals(testString,sensor.toString())
[-] pred: org. junit. Assert. assertEquals ( testString, sensor. toString ( ) )
************************************
************************************
[+] input: shouldReturnNullForInvalidUrl() { PatientIdentifierType actualIdentifierType = dao.getPatientIdentifierTypeByUrl("invalidUrl"); "<AssertPlaceHolder>"; }
getPatientIdentifierTypeByUrl(String url) { return (PatientIdentifierType) sessionFactory.getCurrentSession().createCriteria(FhirPatientIdentifierSystem.class) .add(eq("url", url)).setProjection(Projections.property("patientIdentifierType")).uniqueResult(); }
[*] target: assertNull(actualIdentifierType)
[-] pred: org. junit. Assert. assertNull ( actualIdentifierType )
************************************
************************************
[+] input: shouldReturnNullForNullUrl() { PatientIdentifierType actualIdentifierType = dao.getPatientIdentifierTypeByUrl(null); "<AssertPlaceHolder>"; }
getPatientIdentifierTypeByUrl(String url) { return (PatientIdentifierType) sessionFactory.getCurrentSession().createCriteria(FhirPatientIdentifierSystem.class) .add(eq("url", url)).setProjection(Projections.property("patientIdentifierType")).uniqueResult(); }
[*] target: assertNull(actualIdentifierType)
[-] pred: org. junit. Assert. assertNull ( actualIdentifierType )
************************************
************************************
[+] input: shouldReturnObjectsByClassAndPattern() { Point point1 = new Point("Point-00001"); pool.addObject(point1); Point point2 = new Point("Point-00002"); pool.addObject(point2); Path path1 = new Path("Point-00003", point1.getReference(), point2.getReference()); pool.addObject(path1);  Set<Point> points = pool.getObjects(Point.class, Pattern.compile("Point.*"));  assertEquals(2, points.size()); assertTrue(points.contains(point1)); "<AssertPlaceHolder>"; }
contains(String objectName) { requireNonNull(objectName, "objectName");  return objectsByName.containsKey(objectName); }
[*] target: assertTrue(points.contains(point2))
[-] pred: org. junit. Assert. assertTrue ( points. contains ( point2 ) )
************************************
************************************
[+] input: shouldReturnObjectsByClass() { Point point1 = new Point("Point-00001"); pool.addObject(point1); Point point2 = new Point("Point-00002"); pool.addObject(point2); Path path1 = new Path("Path-00001", point1.getReference(), point2.getReference()); pool.addObject(path1);  Set<Point> points = pool.getObjects(Point.class);  assertEquals(2, points.size()); assertTrue(points.contains(point1)); "<AssertPlaceHolder>"; }
contains(String objectName) { requireNonNull(objectName, "objectName");  return objectsByName.containsKey(objectName); }
[*] target: assertTrue(points.contains(point2))
[-] pred: org. junit. Assert. assertTrue ( points. contains ( point2 ) )
************************************
************************************
[+] input: shouldMergeDriveOrders() { DriveOrder orderA = createDriveOrder(10, "A", "B", "C", "D", "E", "F", "G"); DriveOrder orderB = createDriveOrder(10, "D", "H", "I", "J");  when(router.getCosts(any(Vehicle.class), any(Point.class), any(Point.class))).thenReturn(20L);  Route expected = createDriveOrder(20, "A", "B", "C", "D", "H", "I", "J").getRoute(); Route actual = rerouteUtil.mergeDriveOrders(orderA, orderB, new Vehicle("Vehicle")).getRoute();  "<AssertPlaceHolder>"; }
mergeDriveOrders(DriveOrder orderA, DriveOrder orderB, Vehicle vehicle) { // Merge the drive order routes Route mergedRoute = mergeRoutes(vehicle, orderA.getRoute(), orderB.getRoute());  DriveOrder mergedOrder = new DriveOrder(orderA.getDestination()) .withState(orderA.getState()) .withTransportOrder(orderA.getTransportOrder()) .withRoute(mergedRoute);  return mergedOrder; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldReturnFutureSteps() { List<DriveOrder> driveOrders = Arrays.asList(createDriveOrder(10, "A", "B", "C"), createDriveOrder(20, "C", "D", "E", "F", "G", "H"), createDriveOrder(20, "H", "I", "J", "K", "L")); TransportOrder transportOrder = new TransportOrder("TransportOrder", driveOrders) .withCurrentDriveOrderIndex(1); Vehicle vehicle = new Vehicle("Vehicle") .withTransportOrder(transportOrder.getReference());  VehicleController controller = mock(VehicleController.class); when(transportOrderService.fetchObject(TransportOrder.class, transportOrder.getReference())) .thenReturn(transportOrder); when(vehicleControllerPool.getVehicleController(vehicle.getName())).thenReturn(controller); when(controller.getCommandsSent()).thenReturn(commandsSentToVehicle(driveOrders));  List<String> expected = Arrays.asList("H", "I", "J", "K", "L"); List<String> actual = rerouteUtil.getFutureSteps(vehicle).stream() .map(step -> step.getDestinationPoint().getName()) .collect(Collectors.toList());  "<AssertPlaceHolder>"; }
getFutureSteps(Vehicle vehicle) { TCSObjectReference<TransportOrder> orderRef = vehicle.getTransportOrder(); if (orderRef == null) { LOG.debug("Vehicle {} isn't processing any order. Can't determine future steps.", vehicle.getName()); return new ArrayList<>(); }  TransportOrder order = transportOrderService.fetchObject(TransportOrder.class, orderRef); VehicleController controller = vehicleControllerPool.getVehicleController(vehicle.getName());  // Get the steps for the drive order the vehicle is currently processing // The transport order's drive orders and their routes can't be null at this point List<Step> currentSteps = order.getCurrentDriveOrder().getRoute().getSteps();  // If movement commands have been sent to the comm adapter, trim the current steps by these. // Movement commands may have not been sent to the comm adapter yet, i.e. if needed resources // are already allocated by another vehicle. if (!controller.getCommandsSent().isEmpty()) { List<MovementCommand> commandsSent = new ArrayList<>(controller.getCommandsSent()); MovementCommand lastCommandSent = commandsSent.get(commandsSent.size() - 1);  // Trim the current steps / Get the steps that haven't been sent to the comm adapter yet currentSteps = currentSteps.subList( currentSteps.indexOf(lastCommandSent.getStep()) + 1, currentSteps.size()); }  List<Step> futureSteps = new ArrayList<>(); futureSteps.addAll(currentSteps);  // Add the steps from all future drive orders order.getFutureDriveOrders().stream() .map(driveOrder -> driveOrder.getRoute()) .map(route -> route.getSteps()) .forEach(steps -> futureSteps.addAll(steps));  return futureSteps; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: findExistingRechargePosition() { Point currentVehiclePoint = new Point("Current vehicle point") .withType(Point.Type.HALT_POSITION); Vehicle vehicle = new Vehicle("Some vehicle") .withRechargeOperation("Do some recharging") .withCurrentPosition(currentVehiclePoint.getReference());  Point locationAccessPoint = new Point("Location access point") .withType(Point.Type.HALT_POSITION);  LocationType rechargeLocType = new LocationType("Recharge location type") .withAllowedOperations(Collections.singletonList(vehicle.getRechargeOperation())); Location location = new Location("Recharge location", rechargeLocType.getReference());  Location.Link link = new Location.Link(location.getReference(), locationAccessPoint.getReference()); location = location.withAttachedLinks(new HashSet<>(Arrays.asList(link)));  locationAccessPoint = locationAccessPoint.withAttachedLinks(new HashSet<>(Arrays.asList(link)));  when(plantModelService.fetchObjects(Location.class)) .thenReturn(Collections.singleton(location)); when(plantModelService.fetchObject(LocationType.class, rechargeLocType.getReference())) .thenReturn(rechargeLocType); when(plantModelService.fetchObject(Point.class, currentVehiclePoint.getReference())) .thenReturn(currentVehiclePoint); when(plantModelService.fetchObject(Point.class, locationAccessPoint.getReference())) .thenReturn(locationAccessPoint);  rechargePosSupplier.initialize();  List<Destination> result = rechargePosSupplier.findRechargeSequence(vehicle); "<AssertPlaceHolder>"; assertThat(result, is(not(empty()))); }
findRechargeSequence(Vehicle vehicle) { requireNonNull(vehicle, "vehicle");  if (vehicle.getCurrentPosition() == null) { return new ArrayList<>(); }  Map<Location, Set<Point>> rechargeLocations = findLocationsForOperation(vehicle.getRechargeOperation(), vehicle, router.getTargetedPoints());  String assignedRechargeLocationName = vehicle.getProperty(PROPKEY_ASSIGNED_RECHARGE_LOCATION); if (assignedRechargeLocationName != null) { Location location = pickLocationWithName(assignedRechargeLocationName, rechargeLocations.keySet()); if (location == null) { return new ArrayList<>(); } // XXX Strictly, we should check whether there is a viable route to the location. return Arrays.asList(createDestination(location, vehicle.getRechargeOperation())); }  String preferredRechargeLocationName = vehicle.getProperty(PROPKEY_PREFERRED_RECHARGE_LOCATION); if (assignedRechargeLocationName != null) { Location location = pickLocationWithName(preferredRechargeLocationName, rechargeLocations.keySet()); if (location != null) { // XXX Strictly, we should check whether there is a viable route to the location. return Arrays.asList(createDestination(location, vehicle.getRechargeOperation())); } }  Location bestLocation = findCheapestLocation(rechargeLocations, vehicle); if (bestLocation != null) { return Arrays.asList(createDestination(bestLocation, vehicle.getRechargeOperation())); }  return new ArrayList<>(); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: returnGraphPathStepsForExistingRoute() { List<Step> steps = pointRouter.getRouteSteps(pointA, pointC); "<AssertPlaceHolder>"; assertThat(steps, is(not(empty()))); }
getRouteSteps(Point srcPoint, Point destPoint) { requireNonNull(srcPoint, "srcPoint"); requireNonNull(destPoint, "destPoint");  long timeBefore = System.currentTimeMillis(); if (Objects.equals(srcPoint.getName(), destPoint.getName())) { return new ArrayList<>(); }  GraphPath<String, ModelEdge> graphPath = algo.getPath(srcPoint.getName(), destPoint.getName()); if (graphPath == null) { return null; }  List<Route.Step> result = translateToSteps(graphPath);  LOG.debug("Looking up route from {} to {} took {} milliseconds.", srcPoint.getName(), destPoint.getName(), System.currentTimeMillis() - timeBefore);  return result; }
[*] target: assertNotNull(steps)
[-] pred: org. junit. Assert. assertNotNull ( steps )
************************************
************************************
[+] input: verifyExporterWorksWithDefaultConfiguration() { try (MockedStatic<ServiceOptions> mockedServiceOptions = Mockito.mockStatic(ServiceOptions.class); MockedStatic<MetricServiceClient> mockedMetricServiceClient = Mockito.mockStatic(MetricServiceClient.class); MockedStatic<GoogleCredentials> mockedGoogleCredentials = Mockito.mockStatic(GoogleCredentials.class)) { mockedServiceOptions.when(ServiceOptions::getDefaultProjectId).thenReturn(PROJECT_ID); mockedMetricServiceClient .when(() -> MetricServiceClient.create(Mockito.any(MetricServiceSettings.class))) .thenReturn(this.mockMetricServiceClient); mockedGoogleCredentials .when(GoogleCredentials::getApplicationDefault) .thenReturn(Mockito.mock(GoogleCredentials.class));  MetricExporter metricExporter = GoogleCloudMetricExporter.createWithDefaultConfiguration(); "<AssertPlaceHolder>"; generateOpenTelemetryUsingGoogleCloudMetricExporter(metricExporter); simulateExport(metricExporter);  mockedMetricServiceClient.verify( Mockito.times(1), () -> MetricServiceClient.create((MetricServiceSettings) Mockito.any())); mockedServiceOptions.verify(Mockito.times(1), ServiceOptions::getDefaultProjectId); Mockito.verify(this.mockMetricServiceClient) .createTimeSeries((ProjectName) Mockito.any(), Mockito.anyList()); } finally { GlobalOpenTelemetry.resetForTest(); } }
createWithDefaultConfiguration() { return new GoogleCloudMetricExporter(MetricConfiguration.builder().build()); }
[*] target: assertNotNull(metricExporter)
[-] pred: org. junit. Assert. assertNotNull ( metricExporter )
************************************
************************************
[+] input: testMapMetricWithWierdAttributeNameSucceeds() { String type = DEFAULT_PREFIX + "/" + anInstrumentationLibraryInfo.getName(); Attributes attributes = io.opentelemetry.api.common.Attributes.of(stringKey("test.bad"), "value"); Metric expectedMetric = Metric.newBuilder().setType(type).putLabels("test_bad", "value").build(); Metric actualMetric = MetricTranslator.mapMetric(attributes, type); "<AssertPlaceHolder>"; }
mapMetric(Attributes attributes, String type) { Metric.Builder metricBuilder = Metric.newBuilder().setType(type); attributes.forEach( (key, value) -> metricBuilder.putLabels(cleanAttributeKey(key.getKey()), value.toString())); return metricBuilder.build(); }
[*] target: assertEquals(expectedMetric, actualMetric)
[-] pred: org. junit. Assert. assertEquals ( expectedMetric, actualMetric )
************************************
************************************
[+] input: testMapConstantLabelWithStringValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(stringKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.STRING).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel )
************************************
************************************
[+] input: testMapConstantLabelWithBooleanValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(booleanKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.BOOL).build(); assertEquals(expectedLabel, actualLabel);  LabelDescriptor actualLabel2 = MetricTranslator.mapAttribute(booleanKey("label1"), CUSTOM_PREFIX); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel2)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel2 )
************************************
************************************
[+] input: testMapConstantLabelWithLongValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(longKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.INT64).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel )
************************************
************************************
[+] input: testMapLabelWithPeriodInNameSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(longKey("label.test"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label_test").setValueType(ValueType.INT64).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel )
************************************
************************************
[+] input: IOException { String binaryFile = "laptop.bin"; Laptop laptop1 = new Generator().NewLaptop();  Serializer serializer = new Serializer(); serializer.WriteBinaryFile(laptop1, binaryFile);  Laptop laptop2 = serializer.ReadBinaryFile(binaryFile); Assert."<AssertPlaceHolder>"; }
ReadBinaryFile(String filename) throws IOException { FileInputStream inStream = new FileInputStream(filename); Laptop laptop = Laptop.parseFrom(inStream); inStream.close(); return laptop; }
[*] target: assertEquals(laptop1, laptop2)
[-] pred: org. junit. Assert. assertEquals ( laptop1, laptop2 )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test1234"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeAll(null, createSchemaSql, false, false, false); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("plugin_test1"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeOneUpdate(null, createSchemaSql); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test123"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeAll(null, createSchemaSql, false, false, false); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test123"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(CREATE_SCHEMA, schema); this.executeOneUpdate(null, createSchemaSql); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: testGetById() { try (SqlSession sqlSession = getSqlSession()) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.getById(1L); Assert."<AssertPlaceHolder>"; Assert.assertEquals("张无忌", user.getUsername()); Assert.assertEquals("男", user.getSex()); Assert.assertEquals("明教", user.getAddress().get(0)); Assert.assertEquals("教主", user.getAddress().get(1)); } }
getById(Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: ExpressionException { graalJsExpressionHandler.evaluateExpression("var what = true", pugModel); boolean what = (boolean) pugModel.get("what"); "<AssertPlaceHolder>"; }
public Object evaluateExpression(String expression, PugModel model) throws ExpressionException { Context context = contextThreadLocal.get(); Map<String,Value> cache = cacheThreadLocal.get(); //        context.enter(); try{ saveLocalVariableName(expression, model); Value jsContextBindings = context.getBindings("js"); for (Map.Entry<String, Object> objectEntry : model.entrySet()) { String key = objectEntry.getKey(); if(!PugModel.LOCAL_VARS.equals(key)) { jsContextBindings.putMember(key, objectEntry.getValue()); } }  Source js; Value eval = cache.get(expression); if(eval==null){ if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } eval = context.parse(js); cache.put(expression,eval); } eval = eval.execute(); Set<String> memberKeys = jsContextBindings.getMemberKeys(); for (String memberKey : memberKeys) { if (model.knowsKey(memberKey)){ if (!memberKey.startsWith(PUG4J_MODEL_PREFIX)) { Value member = jsContextBindings.getMember(memberKey); model.put(memberKey, member.as(Object.class)); try { jsContextBindings.removeMember(memberKey); }catch(UnsupportedOperationException e){ //                            e.printStackTrace(); jsContextBindings.putMember(memberKey, null); } } } } return eval.as(Object.class); } catch (Exception ex){ if(ex.getMessage()!=null && ex.getMessage().startsWith("ReferenceError:")){ return null; } throw new ExpressionException(expression, ex); }finally { //            context.leave(); } }  @Override public String evaluateStringExpression(String expression, PugModel model) throws ExpressionException { Object result = evaluateExpression(expression, model); return result == null ? "" : result.toString(); }  @Override public void assertExpression(String expression) throws ExpressionException { Context context = contextThreadLocal.get(); Source js; if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } try { Value parse = context.eval(js); }catch(PolyglotException e){ if(e.getMessage().startsWith("SyntaxError:")){ throw new ExpressionException(e.getMessage()); } } }  @Override public void setCache(boolean cache) {  }  @Override public void clearCache() {  } public Context getContext(){ return contextThreadLocal.get(); } }
[*] target: assertTrue(what)
[-] pred: org. junit. Assert. assertTrue ( what )
************************************
************************************
[+] input: URISyntaxException { PugConfiguration config = new PugConfiguration(); config.setTemplateLoader(new FileTemplateLoader(TestFileHelper.getRootResourcePath() + "/parser/", "jade")); PugTemplate template = config.getTemplate("assignment"); "<AssertPlaceHolder>"; }
getTemplate(String name) throws IOException, PugException { if (caching) { long lastModified = templateLoader.getLastModified(name); PugTemplate template = cache.get(getKeyValue(name, lastModified)); if (template != null) { return template; }  String key = getCachedKey(name, lastModified); synchronized (key) { PugTemplate newTemplate = createTemplate(name); cache.put(key, newTemplate); return newTemplate; } }  return createTemplate(name); }
[*] target: assertNotNull(template)
[-] pred: org. junit. Assert. assertNotNull ( template )
************************************
************************************
[+] input: IOException { PugConfiguration config = new PugConfiguration(); config.setPrettyPrint(true); PugTemplate template = config.getTemplate(templatePath); "<AssertPlaceHolder>"; }
isPrettyPrint() { return prettyPrint; }
[*] target: assertTrue(template.isPrettyPrint())
[-] pred: org. junit. Assert. assertTrue ( template. isPrettyPrint() )
************************************
************************************
[+] input: emptyListShouldNotFail() { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(new ArrayList<>(), null, null, null); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now); } }
[*] target: assertNull(theException)
[-] pred: org. junit. Assert. assertNull ( theException )
************************************
************************************
[+] input: failedConsensusMessage() { ConsensusEventMessage msg1 = new ConsensusEventMessage(); "<AssertPlaceHolder>"; }
getConsensusMessage() { ConsensusEvent event = consensusMessageInternal(); if (event == null) { throw new IllegalStateException("No consensus message."); } return event; }
[*] target: assertNotNull(msg1.getConsensusMessage())
[-] pred: org. junit. Assert. assertNotNull ( msg1. getConsensusMessage ( ) )
************************************
************************************
[+] input: test_atom_content_transformation_to_byte_array_and_back() { LedgerHeader ledgerHeader = LedgerHeader.genesis(HashUtils.zero256(), null); VerifiedLedgerHeaderAndProof proof = new VerifiedLedgerHeaderAndProof( new BFTHeader(View.of(1), HashUtils.random256(), ledgerHeader), new BFTHeader(View.of(1), HashUtils.random256(), ledgerHeader), 1L, HashUtils.random256(), ledgerHeader, new TimestampedECDSASignatures() ); StoredCommittedCommand committedCommand = new StoredCommittedCommand( new Command(new byte[] {0, 1, 2, 3}), proof );  byte[] serializedCommand = commandToBinaryConverter.toLedgerEntryContent(committedCommand); StoredCommittedCommand deserializedCommand = commandToBinaryConverter.toCommand(serializedCommand); "<AssertPlaceHolder>"; }
toCommand(byte[] ledgerEntryContent) { try { return serializer.fromDson(ledgerEntryContent, StoredCommittedCommand.class); } catch (DeserializeException e) { throw new IllegalStateException("Deserialization of Command failed", e); } }
[*] target: assertEquals(committedCommand, deserializedCommand)
[-] pred: org. junit. Assert. assertEquals ( committedCommand, deserializedCommand )
************************************
************************************
[+] input: testFindTransportWithSelectionHiPriority() { byte[] dummyMessage = new byte[0];  TransportInfo dummyTransport = TransportInfo.of("DUMMY", StaticTransportMetadata.empty()); TransportInfo udpTransport = TransportInfo.of(UDPConstants.NAME, StaticTransportMetadata.empty());  List<TransportInfo> transports = ImmutableList.of(dummyTransport, udpTransport);  Peer peer1 = mock(Peer.class); doAnswer(invocation -> transports.stream()).when(peer1).supportedTransports(); doAnswer( invocation -> "DUMMY".equals(invocation.getArgument(0)) || UDPConstants.NAME.equals(invocation.getArgument(0)) ).when(peer1).supportsTransport(any()); @SuppressWarnings("resource") Transport found = transportManager.findTransport(peer1, dummyMessage); "<AssertPlaceHolder>"; assertEquals("DUMMY", found.name()); }
findTransport(Peer peer, byte[] bytes) { if (peer != null) { // Could probably do something a bit more efficient here with caching and such // once the list of transports supported gets reasonably long.  // Check in priority order for first capable matching transport return this.transports.stream() .filter(t -> peer.supportsTransport(t.name())) .filter(t -> t.canHandle(bytes)) .findFirst() .orElse(this.defaultTransport); } return this.defaultTransport; }
[*] target: assertNotNull(found)
[-] pred: org. junit. Assert. assertNotNull ( found )
************************************
************************************
[+] input: ExecutionException { Context ctx = ContextAdapter.adapt(studioContext); List<Callable<String>> callables = new ArrayList<>(); for (int i = 0; i < 20; i++) { String val = "" + i; callables.add(() -> val); } List<String> result = ctx.call(callables); List<String> expected = IntStream.range(0, 20).mapToObj(i -> "" + i).collect(Collectors.toList()); TestCase."<AssertPlaceHolder>"; }
call(List<Callable<T>> list) throws ExecutionException { // ensure that NPE is thrown instead of IllegalArgumentException by ConcurrencyContext#call if (list == null) { throw new NullPointerException("callables must not be null"); } // check for null tasks for (Callable<T> callable : list) { if (callable == null) { throw new NullPointerException("callables must not contain null"); } } try { return studioContext.call(list); } catch (ExecutionStoppedException e) { throw new ExecutionAbortedException("Execution was aborted", e); } catch (ExecutionException e) { if (e.getCause() instanceof ExecutionAbortedException) { throw (ExecutionAbortedException) e.getCause(); } throw e; } }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: acceptingNullInputs() { final ConnectionConfiguration accept = new ConnectionConfigurationBuilder("accept nulls", CONFIGURATION_TYPE_TEST) .withDescription(null) .withTags(null) .withValueProviders(null) .withKeys(null) .build(); "<AssertPlaceHolder>"; }
build() { ConnectionConfiguration configuration = object; object = null; return configuration; }
[*] target: assertNotNull(accept)
[-] pred: org. junit. Assert. assertNotNull ( accept )
************************************
************************************
[+] input: testInjectValuesSuccessful() { MacroValueProviderHandler handler = MacroValueProviderHandler.getInstance(); ValueProvider provider = handler.createNewProvider("provider", PREFIX); Operator operator = getOperatorWithMacros(); Map<String, String> result = handler.injectValues(provider, REQUESTED, operator, null);  Map<String, String> expected = new HashMap<>(); expected.put("first", "first"); expected.put("second", "other");  // Test equals "<AssertPlaceHolder>"; }
injectValues(ValueProvider vp, Map<String, String> injectables, Operator operator, ConnectionInformation connection) { if (!isValid(vp, operator) || injectables == null || injectables.isEmpty()) { return Collections.emptyMap(); }  String prefix = getPrefix(vp); Map<String, String> result = new LinkedHashMap<>(); for (Entry<String, String> entry : injectables.entrySet()) { String fullKey = entry.getKey(); String needed = entry.getValue(); String value = null; String key = prefix + needed; try { value = operator.getProcess().getMacroHandler().getMacro(key, operator); } catch (Exception e) { // this can only happen with detached operators LogService.log(LogService.getRoot(), Level.WARNING, e, "com.rapidminer.connection.valueprovider.handler.MacroValueProviderHandler.retrieval_failed", key, vp.getName()); } if (value != null) { result.put(fullKey, value); } else { LogService.getRoot().log(Level.WARNING, "com.rapidminer.connection.valueprovider.handler.MacroValueProviderHandler.macro_not_found", key); } }  return result; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: createNoRowsTest() { ExampleTable table = new ColumnarExampleTable(Arrays.asList(ExampleTestTools.attributeInt()));  assertEquals(1, table.getAttributeCount()); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(0, table.size())
[-] pred: org. junit. Assert. assertEquals ( 0, table. size() )
************************************
************************************
[+] input: createNoRowsTwoAttributesRemoveTest() { ExampleTable table = new ColumnarExampleTable( Arrays.asList(ExampleTestTools.attributeInt(), ExampleTestTools.attributeReal())); table.removeAttribute(1);  assertEquals(1, table.getAttributeCount()); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(0, table.size())
[-] pred: org. junit. Assert. assertEquals ( 0, table. size() )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnParameterPrecondition precondition = new ColumnParameterPrecondition(generateDummyInputPort(errors), handler, "some_parameter"); final ExampleSetMetaData emd = FromTableMetaDataConverter.convert(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); precondition.check(emd); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd == null) { return; } String columnName = getName(); if (columnName != null) { // checking if attribute with name and type exists MetaDataInfo containsRelation = tmd.contains(columnName); if (containsRelation == MetaDataInfo.YES) { checkExistingColumn(tmd, columnName); } else if (containsRelation == MetaDataInfo.UNKNOWN) { createError(Severity.WARNING, "missing_attribute", columnName); } else { createError(Severity.ERROR, "missing_attribute", columnName); } } makeAdditionalChecks(tmd);  }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key")); final ExampleSetMetaData emd = FromTableMetaDataConverter.convert(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); precondition.check(emd); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { // checking column names checkColumnNames(requiredNames, tmd);  // checking provider names if (requiredNameProvider != null) { checkColumnNames(requiredNameProvider.getRequiredColumnNames(), tmd); } makeAdditionalChecks(tmd); } }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key"), ColumnType.REAL); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameter(ParameterHandler handler, String... parameterKeys) { return new ParameterColumnNameProvider(handler, parameterKeys); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.isParameterSet(anyString())).thenReturn(true); when(handler.getParameterList(anyString())).thenReturn(Collections.singletonList(new String[]{"bla","real"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key", 1), ColumnType.REAL); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.isParameterSet(anyString())).thenReturn(true); when(handler.getParameterList(anyString())).thenReturn(Arrays.asList(new String[]{"bla","real"}, new String[]{"bla","int"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key",1), Column.Category.NUMERIC); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterList(anyString())).thenReturn(Arrays.asList(new String[]{"bla","real"}, new String[]{"bla","int"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key",1), Column.Category.OBJECT); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: testOther() { final TablePassThroughRule tablePassThroughRule = new TablePassThroughRule(generateDummyInputPort(), generateDummyOutputPort(), SetRelation.SUBSET); final PredictionModelMetaData modelMetaData = new PredictionModelMetaData(PredictionModel.class); final MetaData result = tablePassThroughRule.modifyMetaData(modelMetaData); "<AssertPlaceHolder>"; }
modifyMetaData(MetaData metaData) { TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { if (relation != null && relation != SetRelation.EQUAL) { TableMetaDataBuilder builder = new TableMetaDataBuilder(tmd); builder.mergeColumnSetRelation(relation); tmd = builder.build(); } try { return modifyTableMetaData(tmd); } catch (UndefinedParameterError e) { //ignore return tmd; } } else { return metaData; } }
[*] target: assertSame(modelMetaData, result)
[-] pred: org. junit. Assert. assertSame ( modelMetaData, result )
************************************
************************************
[+] input: testExampleSetMD() { List<MetaDataError> errors = new ArrayList<>(); final TablePrecondition tablePrecondition = new TablePrecondition(generateDummyInputPort(errors)); tablePrecondition.check(new ExampleSetMetaData()); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final InputPort inputPort = getInputPort(); if (metaData == null) { if (!optional) { // on purpose using ExampleSet for consistent display inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, null)); } } else { TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { checkColumnNames(tmd); checkTypes(tmd); checkRoles(inputPort, tmd); try { makeAdditionalChecks(tmd); } catch (UndefinedParameterError e) { //ignore } } else { inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, metaData.getObjectClass())); } } }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: RepositoryException { JwtClaim jwtClaim = jwtReader.readClaim(null); Assert."<AssertPlaceHolder>"; }
readClaim(RemoteRepository source) throws RepositoryException, IOException { try { JwtWrapper wrapper = loadJwtWrapper(source); if (wrapper == null) { return null; } //Split the token into header, payload and signature String[] token = wrapper.getIdToken().split(JWT_SEPARATOR_REGEX); //Verify the structure of the Token if (token.length == JWT_STRUCTURE.length) { //Extract the payload String base64Body = token[JWT_PAYLOAD]; //Base64 Decode byte[] jsonBody = Base64.getDecoder().decode(base64Body); //Read the decoded JSON return mapper.readValue(jsonBody, JwtClaim.class); } else { throw new RepositoryException("Invalid response from TokenService."); } } catch (IllegalArgumentException | JsonMappingException e) { throw new RepositoryException("Invalid response from TokenService.", e); } }
[*] target: assertNull(jwtClaim)
[-] pred: org. junit. Assert. assertNull ( jwtClaim )
************************************
************************************
[+] input: shouldNotFindInvalidCountryCode() { CountryCode cc = OnfidoSdkModule.findCountryCodeByAlpha2("12"); "<AssertPlaceHolder>"; }
findCountryCodeByAlpha2(String countryCodeString) { CountryCode countryCode = null; // We'll use a loop to find the value, because streams are not supported in Java 7. for (CountryCode cc : CountryCode.values()) { if (cc.name().equals(countryCodeString)) { countryCode = cc; } } return countryCode; }
[*] target: assertNull(cc)
[-] pred: org. junit. Assert. assertNull ( cc )
************************************
************************************
[+] input: InvocationTargetException { Field f = RestrictionBypass.getDeclaredField(this.getClass(), "testField1"); "<AssertPlaceHolder>"; assertSame(f.get(this), testField1); }
getDeclaredField(Class obj, String name) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) { return NativeReflectionBypass.getDeclaredField(obj, name); } else { Method getDeclaredField = Class.class.getMethod("getDeclaredField", String.class); return (Field) getDeclaredField.invoke(obj, name); } }
[*] target: assertNotNull(f)
[-] pred: org. junit. Assert. assertNotNull ( f )
************************************
************************************
[+] input: InvocationTargetException { Field f = RestrictionBypass.getDeclaredField(this.getClass(), "testField2"); "<AssertPlaceHolder>"; assertSame(f.get(this), testField2); }
getDeclaredField(Class obj, String name) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) { return NativeReflectionBypass.getDeclaredField(obj, name); } else { Method getDeclaredField = Class.class.getMethod("getDeclaredField", String.class); return (Field) getDeclaredField.invoke(obj, name); } }
[*] target: assertNotNull(f)
[-] pred: org. junit. Assert. assertNotNull ( f )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = userService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserError() { mockServerReturnObject(USER_MIKE, 0, ERROR_CODE); User user = userService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserAsync() { mockServerReturnObject(USER_MIKE); CompletableFuture<User> userCompletableFuture = userService.getUserAsync(Long100); "<AssertPlaceHolder>"; User user; try { user = userCompletableFuture.get(); } catch (Exception e) { throw new IllegalStateException("userCompletableFuture get error"); } assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserAsync(@Query("id") Long id);
[*] target: assertNotNull(userCompletableFuture)
[-] pred: org. junit. Assert. assertNotNull ( userCompletableFuture )
************************************
************************************
[+] input: getUserReturnResponse() { mockServerReturnObject(USER_MIKE); Response<User> userReturnResponse = userService.getUserReturnResponse(Long100); "<AssertPlaceHolder>"; assertEquals(SUCCESS_CODE, userReturnResponse.code()); User user = userReturnResponse.body(); assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserReturnResponse(@Query("id") Long id);
[*] target: assertNotNull(userReturnResponse)
[-] pred: org. junit. Assert. assertNotNull ( userReturnResponse )
************************************
************************************
[+] input: getUserReturnCall() { mockServerReturnObject(USER_MIKE); Call<User> userReturnCall = userService.getUserReturnCall(Long100); "<AssertPlaceHolder>"; try { Response<User> userResponse = userReturnCall.execute(); assertEquals(SUCCESS_CODE, userResponse.code()); User user = userResponse.body(); assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); } catch (IOException e) { throw new IllegalStateException("userReturnCall execute error"); } }
getUserReturnCall(@Query("id") Long id);
[*] target: assertNotNull(userReturnCall)
[-] pred: org. junit. Assert. assertNotNull ( userReturnCall )
************************************
************************************
[+] input: isMale() { mockServerReturnString(true); Boolean male = userService.isMale(Long100); "<AssertPlaceHolder>"; }
isMale(@Query("id") Long id);
[*] target: assertTrue(male)
[-] pred: org. junit. Assert. assertTrue ( male )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = chooserOkHttpUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = logUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = metaAnnotationUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: distribution() {  SLD.Distribution<Object> actual = SLD.extractDistributions(graph)[0];  SLD.Distribution<Object> expected = new DistributionBuilder(""). access("ws://localhost:4567/access/colours", false) .format(Format.STRING) .license(License.CC) .protocol(Protocol.WebSocket) .security(Security.SSL) .publisher(SLD.extractPublisher(g)) .buildSource(g);   //        expected.describe().stream().forEach(triple -> { //            assertTrue(actual.describe().contains(triple)); //        }); // //        actual.describe().stream().forEach(triple -> { //            assertTrue(expected.describe().contains(triple)); // //        });   SLD.WebDataStream<Object> expectedWebStream = expected.getWebStream(); SLD.WebDataStream<Object> actualWebStream = actual.getWebStream();  "<AssertPlaceHolder>"; }
getWebStream(); }   public interface WebStream<E> extends Describable, Named {  SLD.Publisher publisher();  WebDataStream<E> serve();  }
[*] target: assertEquals(expectedWebStream, actualWebStream)
[-] pred: org. junit. Assert. assertEquals ( expectedWebStream, actualWebStream )
************************************
************************************
[+] input: CodingException { ScheduledTask original = TaskTestUtil.makeTask("id", TaskTestUtil.JOB).newBuilder();  byte[] deflated = ThriftBinaryCodec.deflateNonNull(original);  ScheduledTask inflated = ThriftBinaryCodec.inflateNonNull(ScheduledTask.class, deflated);  "<AssertPlaceHolder>"; }
inflateNonNull(Class<T> clazz, byte[] buffer) throws CodingException {  requireNonNull(clazz); requireNonNull(buffer);  T tBase = newInstance(clazz); TTransport transport = new TIOStreamTransport( new InflaterInputStream(new ByteArrayInputStream(buffer))); try { TProtocol protocol = PROTOCOL_FACTORY.getProtocol(transport); tBase.read(protocol); return tBase; } catch (TException e) { throw new CodingException("Failed to deserialize: " + e, e); } finally { transport.close(); } }
[*] target: assertEquals(original, inflated)
[-] pred: org. junit. Assert. assertEquals ( original, inflated )
************************************
************************************
[+] input: testWildcards() { CrontabEntry wildcardMinuteEntry = CrontabEntry.parse("* 1 1 1 *"); assertEquals("*", wildcardMinuteEntry.getMinuteAsString()); assertTrue(wildcardMinuteEntry.hasWildcardMinute()); assertFalse(wildcardMinuteEntry.hasWildcardHour()); assertFalse(wildcardMinuteEntry.hasWildcardDayOfMonth()); assertFalse(wildcardMinuteEntry.hasWildcardMonth()); assertTrue(wildcardMinuteEntry.hasWildcardDayOfWeek());  CrontabEntry wildcardHourEntry = CrontabEntry.parse("1 * 1 1 *"); assertEquals("*", wildcardHourEntry.getHourAsString()); assertFalse(wildcardHourEntry.hasWildcardMinute()); assertTrue(wildcardHourEntry.hasWildcardHour()); assertFalse(wildcardHourEntry.hasWildcardDayOfMonth()); assertFalse(wildcardHourEntry.hasWildcardMonth()); assertTrue(wildcardHourEntry.hasWildcardDayOfWeek());  CrontabEntry wildcardDayOfMonth = CrontabEntry.parse("1 1 * 1 *"); assertEquals("*", wildcardDayOfMonth.getDayOfMonthAsString()); assertFalse(wildcardDayOfMonth.hasWildcardMinute()); assertFalse(wildcardDayOfMonth.hasWildcardHour()); assertTrue(wildcardDayOfMonth.hasWildcardDayOfMonth()); assertFalse(wildcardDayOfMonth.hasWildcardMonth()); assertTrue(wildcardDayOfMonth.hasWildcardDayOfWeek());  CrontabEntry wildcardMonth = CrontabEntry.parse("1 1 1 * *"); assertEquals("*", wildcardMonth.getMonthAsString()); assertFalse(wildcardMonth.hasWildcardMinute()); assertFalse(wildcardMonth.hasWildcardHour()); assertFalse(wildcardMonth.hasWildcardDayOfMonth()); assertTrue(wildcardMonth.hasWildcardMonth()); assertTrue(wildcardMonth.hasWildcardDayOfWeek());  CrontabEntry wildcardDayOfWeek = CrontabEntry.parse("1 1 1 1 *"); assertEquals("*", wildcardDayOfWeek.getDayOfWeekAsString()); assertFalse(wildcardDayOfWeek.hasWildcardMinute()); assertFalse(wildcardDayOfWeek.hasWildcardHour()); assertFalse(wildcardDayOfWeek.hasWildcardDayOfMonth()); assertFalse(wildcardDayOfWeek.hasWildcardMonth()); "<AssertPlaceHolder>"; }
hasWildcardDayOfWeek() { return getDayOfWeek().encloses(DAY_OF_WEEK); }
[*] target: assertTrue(wildcardDayOfWeek.hasWildcardDayOfWeek())
[-] pred: org. junit. Assert. assertTrue ( wildcardDayOfWeek. hasWildcardDayOfWeek ( ) )
************************************
************************************
[+] input: IOException { // Making a task that is not in PENDING state. IJobKey jobKey = IJobKey.build(new JobKey("role", "test", "nonPendingJob")); IScheduledTask task = TestUtils.makeTask(jobKey, "task0", 0, ScheduleStatus.ASSIGNED, 10, 10, 10);  PubsubEvent.TaskStateChange taskStateChange = PubsubEvent.TaskStateChange.transition( task, ScheduleStatus.INIT);  pendingTaskGroups.taskChangedState(taskStateChange); expectLastCall();  // Recording the return value of pendingTaskGroups.getGroups(). List<TaskGroup> taskGroupList = new ArrayList<>(); expect(pendingTaskGroups.getGroups()).andReturn(taskGroupList).anyTimes();  replay(pendingTaskGroups);  // Testing. pendingTaskGroups.taskChangedState(taskStateChange); PendingTasks pendingTasks = new PendingTasks(pendingTaskGroups, nearestFit); JsonNode mimicResponseNoPendingTaskJson = new ObjectMapper().createArrayNode(); JsonNode actualResponseJson = new ObjectMapper().valueToTree( pendingTasks.getOffers().getEntity()); "<AssertPlaceHolder>"; }
getOffers() throws IOException { Map<TaskGroupKey, List<String>> taskGroupReasonMap = nearestFit.getPendingReasons(taskGroups.getGroups());  ObjectMapper mapper = new ObjectMapper(); ArrayNode jsonNode = mapper.createArrayNode();  // Add the attribute "reason" to each serialized taskgroup for (TaskGroup group : taskGroups.getGroups()) { ObjectNode pendingTask = (ObjectNode) mapper.valueToTree(group);  pendingTask.put("reason", taskGroupReasonMap.get(group.getKey()).toString()); jsonNode.add(pendingTask); } return Response.ok(jsonNode).build(); }
[*] target: assertEquals(mimicResponseNoPendingTaskJson, actualResponseJson)
[-] pred: org. junit. Assert. assertEquals ( mimicResponseNoPendingTaskJson, actualResponseJson )
************************************
************************************
[+] input: builderShouldSetValues() { User user = new User("ziltoid"); AuthenticationInfo authInfo = helper.createAuthenticationInfo("unit-test", user);  "<AssertPlaceHolder>"; assertEquals("ziltoid", authInfo.getPrincipals().getPrimaryPrincipal()); assertThat(authInfo.getPrincipals().getRealmNames(), hasItem("unit-test")); assertEquals(user, authInfo.getPrincipals().oneByType(User.class)); }
createAuthenticationInfo(String realm, User user) { SimplePrincipalCollection collection = new SimplePrincipalCollection();  collection.add(user.getId(), realm); collection.add(user, realm);  return new SimpleAuthenticationInfo(collection, user.getPassword()); }
[*] target: assertNotNull(authInfo)
[-] pred: org. junit. Assert. assertNotNull ( authInfo )
************************************
************************************
[+] input: IOException { // without default branch, the repository head should be used FileObject root = createCommand().getBrowserResult(new BrowseCommandRequest()).getFile(); assertNotNull(root);  Collection<FileObject> foList = root.getChildren(); "<AssertPlaceHolder>"; assertFalse(foList.isEmpty());  assertThat(foList) .extracting("name") .containsExactly("c", "a.txt", "b.txt", "f.txt"); }
getChildren() { if (!sorted) { sort(children, entry -> entry.type != TreeType.FILE, TreeEntry::getNameString); sorted = true; } return children; }
[*] target: assertNotNull(foList)
[-] pred: org. junit. Assert. assertNotNull ( foList )
************************************
************************************
[+] input: IOException { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(2, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); line = result.getLine(1); assertEquals(2, line.getLineNumber()); assertEquals("2baab8e80280ef05a9aa76c49c76feca2872afb7", line.getRevision()); checkDate(line.getWhen()); assertEquals("line for blame", line.getCode()); assertEquals("added new line for blame", line.getDescription()); assertEquals("Zaphod Beeblebrox", line.getAuthor().getName()); assertEquals("zaphod.beeblebrox@hitchhiker.com", line.getAuthor().getMail()); }
getBlameResult(BlameCommandRequest request) throws IOException { if (logger.isDebugEnabled()) { logger.debug("get blame result for {}", request); }  AnnotateCommand cmd = AnnotateCommand.on(open());  cmd.rev(HgUtil.getRevision(request.getRevision()));  List<BlameLine> blameLines = Lists.newArrayList(); List<AnnotateLine> lines = cmd.execute(request.getPath()); int counter = 0;  for (AnnotateLine line : lines) { blameLines.add(convert(line, ++counter)); }  return new BlameResult(blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt"); request.setRevision("a9bacaf1b7fa0cebfca71fed4e59ed69a6319427");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(1, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); }
getBlameResult(BlameCommandRequest request) throws IOException { if (logger.isDebugEnabled()) { logger.debug("get blame result for {}", request); }  AnnotateCommand cmd = AnnotateCommand.on(open());  cmd.rev(HgUtil.getRevision(request.getRevision()));  List<BlameLine> blameLines = Lists.newArrayList(); List<AnnotateLine> lines = cmd.execute(request.getPath()); int counter = 0;  for (AnnotateLine line : lines) { blameLines.add(convert(line, ++counter)); }  return new BlameResult(blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BrowseCommandRequest request = new BrowseCommandRequest();  request.setPath("c");  BrowserResult result = new HgBrowseCommand(cmdContext).getBrowserResult(request);  "<AssertPlaceHolder>";  FileObject c = result.getFile(); assertEquals("c", c.getName()); Collection<FileObject> foList = c.getChildren();  assertThat(foList) .extracting("name") .containsExactly("d.txt", "e.txt");  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(2, foList.size());  FileObject d = null; FileObject e = null;  for (FileObject f : foList) { if ("d.txt".equals(f.getName())) { d = f; } else if ("e.txt".equals(f.getName())) { e = f; } }  assertNotNull(d); assertFalse(d.isDirectory()); assertEquals("d.txt", d.getName()); assertEquals("c/d.txt", d.getPath()); assertEquals("added file d and e in folder c", d.getDescription().get()); assertTrue(d.getLength().getAsLong() > 0); checkDate(d.getCommitDate().getAsLong()); assertNotNull(e); assertFalse(e.isDirectory()); assertEquals("e.txt", e.getName()); assertEquals("c/e.txt", e.getPath()); assertEquals("added file d and e in folder c", e.getDescription().get()); assertTrue(e.getLength().getAsLong() > 0); checkDate(e.getCommitDate().getAsLong()); }
getBrowserResult(BrowseCommandRequest request) throws IOException { HgFileviewCommand cmd = HgFileviewCommand.on(open());  String revision = MoreObjects.firstNonNull(request.getRevision(), "tip"); Changeset c = LogCommand.on(getContext().open()).rev(revision).limit(1).single();  if (c != null) { cmd.rev(c.getNode()); }  if (!Strings.isNullOrEmpty(request.getPath())) { cmd.path(request.getPath()); }  if (request.isDisableLastCommit()) { cmd.disableLastCommit(); }  if (request.isRecursive()) { cmd.recursive(); }  if (request.isDisableSubRepositoryDetection()) { cmd.disableSubRepositoryDetection(); }  cmd.setLimit(request.getLimit()); cmd.setOffset(request.getOffset());  FileObject file = cmd.execute() .orElseThrow(() -> notFound(entity("File", request.getPath()).in("Revision", revision).in(getRepository()))); return new BrowserResult(c == null? "tip": c.getNode(), revision, file); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BrowseCommandRequest request = new BrowseCommandRequest();  request.setRecursive(true);  BrowserResult result = new HgBrowseCommand(cmdContext).getBrowserResult(request);  "<AssertPlaceHolder>";  FileObject root = result.getFile(); Collection<FileObject> foList = root.getChildren();  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(4, foList.size());  FileObject c = getFileObject(foList, "c"); assertTrue(c.isDirectory()); assertEquals(2, c.getChildren().size()); }
getBrowserResult(BrowseCommandRequest request) throws IOException { HgFileviewCommand cmd = HgFileviewCommand.on(open());  String revision = MoreObjects.firstNonNull(request.getRevision(), "tip"); Changeset c = LogCommand.on(getContext().open()).rev(revision).limit(1).single();  if (c != null) { cmd.rev(c.getNode()); }  if (!Strings.isNullOrEmpty(request.getPath())) { cmd.path(request.getPath()); }  if (request.isDisableLastCommit()) { cmd.disableLastCommit(); }  if (request.isRecursive()) { cmd.recursive(); }  if (request.isDisableSubRepositoryDetection()) { cmd.disableSubRepositoryDetection(); }  cmd.setLimit(request.getLimit()); cmd.setOffset(request.getOffset());  FileObject file = cmd.execute() .orElseThrow(() -> notFound(entity("File", request.getPath()).in("Revision", revision).in(getRepository()))); return new BrowserResult(c == null? "tip": c.getNode(), revision, file); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { HgLogCommand command = createCommand(); String revision = "a9bacaf1b7fa0cebfca71fed4e59ed69a6319427"; Changeset c = command.getChangeset(revision, null);  "<AssertPlaceHolder>"; assertEquals(revision, c.getId()); assertEquals("added a and b files", c.getDescription()); checkDate(c.getDate()); assertEquals("Douglas Adams", c.getAuthor().getName()); assertEquals("douglas.adams@hitchhiker.com", c.getAuthor().getMail()); assertEquals("added a and b files", c.getDescription()); ModificationsCommand modificationsCommand = new HgModificationsCommand(cmdContext); Modifications modifications = modificationsCommand.getModifications(revision);  assertNotNull(modifications); assertTrue("modified list should be empty", modifications.getModified().isEmpty()); assertTrue("removed list should be empty", modifications.getRemoved().isEmpty()); assertFalse("added list should not be empty", modifications.getAdded().isEmpty()); assertEquals(2, modifications.getAdded().size()); assertThat(modifications.getAdded()) .extracting("path") .containsExactly("a.txt", "b.txt"); }
getChangeset(String id, LogCommandRequest request) { org.javahg.Repository repository = open(); HgLogChangesetCommand cmd = on(repository);  return cmd.rev(id).single(); }
[*] target: assertNotNull(c)
[-] pred: org. junit. Assert. assertNotNull ( c )
************************************
************************************
[+] input: testGetBlameResultWithRevision() { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt"); request.setRevision("3");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(1, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); }
getBlameResult(BlameCommandRequest request) { String path = request.getPath(); String revision = request.getRevision(); List<BlameLine> blameLines = Lists.newArrayList(); SVNRevision endRevision = null;  if (Util.isNotEmpty(revision)) { endRevision = SVNRevision.create(Long.parseLong(revision)); } else { endRevision = SVNRevision.HEAD; }  try { SVNURL svnurl = SVNURL.fromFile(new File(context.getDirectory(), path)); SVNRepository svnRepository = SVNRepositoryFactory.create(context.createUrl()); ISVNAuthenticationManager svnManager = svnRepository.getAuthenticationManager(); SVNLogClient svnLogClient = new SVNLogClient(svnManager, null);  svnLogClient.doAnnotate(svnurl, SVNRevision.UNDEFINED, SVNRevision.create(1l), endRevision, new SvnBlameHandler(svnRepository, path, blameLines)); } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not create blame result", ex); }  return new BlameResult(blameLines.size(), blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testBrowse() { BrowserResult result = createCommand().getBrowserResult(new BrowseCommandRequest());  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("c", "a.txt");  Iterator<FileObject> iterator = foList.iterator(); FileObject c = iterator.next(); FileObject a = iterator.next();  assertFalse(a.isDirectory()); assertEquals("a.txt", a.getName()); assertEquals("a.txt", a.getPath()); assertEquals("added line for blame test", a.getDescription().get()); assertTrue(a.getLength().getAsLong() > 0); checkDate(a.getCommitDate().getAsLong()); assertTrue(c.isDirectory()); assertEquals("c", c.getName()); assertEquals("c", c.getPath()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testBrowseSubDirectory() { BrowseCommandRequest request = new BrowseCommandRequest();  request.setPath("c");  BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("d.txt", "e.txt");  Iterator<FileObject> iterator = foList.iterator(); FileObject d = iterator.next(); FileObject e = iterator.next();  assertNotNull(d); assertFalse(d.isDirectory()); assertEquals("d.txt", d.getName()); assertEquals("c/d.txt", d.getPath()); assertEquals("added d and e in folder c", d.getDescription().get()); assertTrue(d.getLength().getAsLong() > 0); checkDate(d.getCommitDate().getAsLong()); assertNotNull(e); assertFalse(e.isDirectory()); assertEquals("e.txt", e.getName()); assertEquals("c/e.txt", e.getPath()); assertEquals("added d and e in folder c", e.getDescription().get()); assertTrue(e.getLength().getAsLong() > 0); checkDate(e.getCommitDate().getAsLong()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testRecursive() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setRecursive(true); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(2, foList.size());  FileObject c = getFileObject(foList, "c"); assertEquals("c", c.getName()); assertTrue(c.isDirectory()); assertEquals(2, c.getChildren().size()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testLimit() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setLimit(1); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("c", "a.txt"); assertThat(result.getFile().isTruncated()).isTrue(); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testOffset() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setOffset(1); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).isEmpty(); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: shouldNotReturnChangesetWithIdZero() { ChangesetPagingResult result = createCommand().getChangesets(new LogCommandRequest()); boolean found = StreamSupport.stream(result.spliterator(), false).anyMatch(c -> "0".equals(c.getId())); "<AssertPlaceHolder>"; }
getChangesets(LogCommandRequest request) { if (LOG.isDebugEnabled()) { LOG.debug("fetch changesets for {}", request); }  ChangesetPagingResult changesets; int start = request.getPagingStart(); int limit = request.getPagingLimit(); long startRevision = parseRevision(request.getStartChangeset(), repository); long endRevision = parseRevision(request.getEndChangeset(), repository); String[] pathArray = null;  if (!Strings.isNullOrEmpty(request.getPath())) { pathArray = new String[]{request.getPath()}; }  try { SVNRepository repo = open();  if ((startRevision > 0) || (pathArray != null)) { changesets = getChangesets(repo, startRevision, endRevision, start, limit, pathArray); } else { changesets = getChangesets(repo, start, limit); } } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not open repository", ex); }  return changesets; }
[*] target: assertFalse(found)
[-] pred: org. junit. Assert. assertFalse ( found )
************************************
************************************
[+] input: testGetCommit() { Changeset c = createCommand().getChangeset("3", null);  "<AssertPlaceHolder>"; assertEquals("3", c.getId()); assertEquals("remove b and modified a", c.getDescription()); checkDate(c.getDate()); assertEquals("perfect", c.getAuthor().getName()); assertNull("douglas.adams@hitchhiker.com", c.getAuthor().getMail()); SvnModificationsCommand modificationsCommand = new SvnModificationsCommand(createContext()); Modifications modifications = modificationsCommand.getModifications("3");  assertNotNull(modifications); assertEquals(1, modifications.getModified().size()); assertEquals(1, modifications.getRemoved().size()); assertTrue("added list should be empty", modifications.getAdded().isEmpty()); assertEquals("a.txt", modifications.getModified().get(0).getPath()); assertEquals("b.txt", modifications.getRemoved().get(0).getPath()); }
getChangeset(String revision, LogCommandRequest request) { Changeset changeset = null;  if (LOG.isDebugEnabled()) { LOG.debug("fetch changeset {}", revision); }  try { long revisioNumber = parseRevision(revision, repository); Preconditions.checkArgument(revisioNumber > 0, "revision must be greater than zero: %d", revisioNumber); SVNRepository repo = open(); Collection<SVNLogEntry> entries = repo.log(null, null, revisioNumber, revisioNumber, true, true);  if (Util.isNotEmpty(entries)) { changeset = SvnUtil.createChangeset(entries.iterator().next()); } } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not open repository", ex); }  return changeset; }
[*] target: assertNotNull(c)
[-] pred: org. junit. Assert. assertNotNull ( c )
************************************
************************************
[+] input: Exception { ActivityRuleConfig config = new ActivityRuleConfig(); config.setActivityId(1L); config.setConfigKey("city"); config.setConfigValue("1,2,3");  ActivityRule activityRule = ActivityRuleRegistrar.parseRule(config); Assert."<AssertPlaceHolder>"; }
parseRule(ActivityRuleConfig config) { String configKey = config.getConfigKey();  try { ActivityRule activityRule = ruleClassMap.get(configKey).newInstance(); activityRule.decode(config); return activityRule; } catch (Exception e) { throw new CustomException(BizStatusCode.ACTIVITY_RULE_CONFIG_ERROR, configKey); } }
[*] target: assertNotNull(activityRule)
[-] pred: org. junit. Assert. assertNotNull ( activityRule )
************************************
************************************
[+] input: Exception { ActivityRuleConfig config = new ActivityRuleConfig(); config.setActivityId(1L); config.setConfigKey("abc"); config.setConfigValue("1,2,3");  ActivityRule activityRule = ActivityRuleRegistrar.parseRule(config); Assert."<AssertPlaceHolder>"; }
parseRule(ActivityRuleConfig config) { String configKey = config.getConfigKey();  try { ActivityRule activityRule = ruleClassMap.get(configKey).newInstance(); activityRule.decode(config); return activityRule; } catch (Exception e) { throw new CustomException(BizStatusCode.ACTIVITY_RULE_CONFIG_ERROR, configKey); } }
[*] target: assertNotNull(activityRule)
[-] pred: org. junit. Assert. assertNotNull ( activityRule )
************************************
************************************
[+] input: test_isStartWithHttpOrHttps() { boolean start = ShortUrlManager.isStartWithHttpOrHttps("http://www.yefan813.github.io"); Assert."<AssertPlaceHolder>"; }
isStartWithHttpOrHttps(String url) { String regex = "^((https|http)?://)"; Pattern p = Pattern.compile(regex); Matcher matcher = p.matcher(url); return matcher.find(); }
[*] target: assertTrue(start)
[-] pred: org. junit. Assert. assertTrue ( start )
************************************
************************************
[+] input: cleaningCounterVeryOld() { alertCounter.update(new AlertContext(1, new Object[]{"secret", 1})); alertCounter.clean(1002); Assert.assertNull(alertCounter.getOldest()); Assert.assertEquals(0, alertCounter.getSize()); Assert."<AssertPlaceHolder>"; }
isEmpty() { return alertContextHeap.isEmpty(); }
[*] target: assertTrue(alertCounter.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( alertCounter. isEmpty() )
************************************
************************************
[+] input: builderOneMatcherAndMultipleNegatedMatchers() { var nonNegatedMatcher = Mockito.mock(Matcher.class); when(nonNegatedMatcher.isNegated()).thenReturn(false); when(matcher.isNegated()).thenReturn(true); rule = Rule.builder() .matchers(List.of(matcher, matcher, nonNegatedMatcher, matcher, matcher)) .name(name) .version(version) .tags(constants) .protections(protections) .build(); Assert."<AssertPlaceHolder>"; }
builder() {  return new Builder<>() { @Override protected Rule buildInternally() { prepareBuild(); return new Rule(this); } }; }
[*] target: assertNotNull(rule)
[-] pred: org. junit. Assert. assertNotNull ( rule )
************************************
************************************
[+] input: IOException { when(zooKeeperConnector.getData()).thenReturn(Collections.singletonList(rulesForCorrelation)); AlertingEngineBolt.prepare(null, null, collector);  AlertingEngineBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof AlertMessages); Assert.assertTrue(values.get(1) instanceof ExceptionMessages);  AlertMessages alerts = (AlertMessages)values.get(0); Assert.assertEquals(1, alerts.size()); Assert.assertTrue(alerts.get(0).isCorrelationAlert()); Assert.assertFalse(alerts.get(0).isVisibleAlert());  Assert.assertEquals("siembol_alert_generic_v1", alerts.get(0).getFullRuleName()); Assert.assertTrue(alerts.get(0).getCorrelationKey().isPresent()); Assert.assertEquals("1", alerts.get(0).getCorrelationKey().get()); Assert.assertEquals(100, alerts.get(0).getMaxDayMatches()); Assert.assertEquals(30, alerts.get(0).getMaxHourMatches());  Map<String, Object> parsed = JSON_READER.readValue(alerts.get(0).getAlertJson()); Assert.assertEquals("siembol_alert_generic_v1", parsed.get(AlertingFields.FULL_RULE_NAME.getAlertingName())); Assert.assertEquals(100, parsed.get(AlertingFields.MAX_PER_DAY_FIELD.getAlertingName())); Assert.assertEquals(30, parsed.get(AlertingFields.MAX_PER_HOUR_FIELD.getAlertingName())); Assert.assertEquals("secret", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("secret", parsed.get("sensor")); Assert.assertEquals(1, parsed.get("dummy_field_int")); Assert.assertEquals(false, parsed.get("dummy_field_boolean")); verify(collector, times(1)).ack(eq(tuple)); }
execute(Tuple tuple) { AlertingEngine currentEngine = AlertingEngine.get(); String event = tuple.getStringByField(TupleFieldNames.EVENT.toString()); AlertingResult ret = currentEngine.evaluate(event);  if (ret.getStatusCode() == AlertingResult.StatusCode.OK && ret.getAttributes().getEvaluationResult() == EvaluationResult.NO_MATCH && ret.getAttributes().getExceptionEvents() == null) { LOG.debug(ACK_NO_MATCH_LOG, event); collector.ack(tuple); return; }  AlertMessages matches = new AlertMessages(); ExceptionMessages exceptions = new ExceptionMessages();  if (ret.getStatusCode() != AlertingResult.StatusCode.OK) { exceptions.add(String.format(EXCEPTION_MSG_FORMAT, ret.getAttributes().getException(), event)); }  if (ret.getAttributes().getExceptionEvents() != null) { ret.getAttributes().getExceptionEvents() .forEach( x -> { try { exceptions.add(JSON_WRITER.writeValueAsString(x)); } catch (JsonProcessingException e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  if (ret.getAttributes().getOutputEvents() != null) { ret.getAttributes().getOutputEvents() .forEach( x -> { try { matches.add(new AlertMessage(currentEngine.getAlertingEngineType(), x, JSON_WRITER.writeValueAsString(x))); } catch (Exception e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  collector.emit(tuple, new Values(matches, exceptions)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: Exception { ConfigSchemaService service = EnrichmentSchemaService .createEnrichmentsSchemaService(new ConfigEditorUiLayout()); Assert."<AssertPlaceHolder>"; }
createEnrichmentsSchemaService(ConfigEditorUiLayout uiLayout) throws Exception { LOG.info("Initialising enrichment config schema service"); ConfigSchemaServiceContext context = new ConfigSchemaServiceContext(); EnrichmentCompiler compiler = EnrichmentCompilerImpl.createEnrichmentCompiler(); String rulesSchema = compiler.getSchema().getAttributes().getRulesSchema(); String testSchema = compiler.getTestSpecificationSchema().getAttributes().getTestSchema();  Optional<String> rulesSchemaUi = ConfigEditorUtils.patchJsonSchema(rulesSchema, uiLayout.getConfigLayout()); Optional<String> testSchemaUi = ConfigEditorUtils.patchJsonSchema(testSchema, uiLayout.getTestLayout()); SiembolJsonSchemaValidator adminConfigValidator = new SiembolJsonSchemaValidator( StormEnrichmentAttributesDto.class); Optional<String> adminConfigSchemaUi = ConfigEditorUtils.patchJsonSchema( adminConfigValidator.getJsonSchema().getAttributes().getJsonSchema(), uiLayout.getAdminConfigLayout());  if (!rulesSchemaUi.isPresent() || !testSchemaUi.isPresent() || !adminConfigSchemaUi.isPresent()) { LOG.error(INIT_ERROR); throw new IllegalArgumentException(INIT_ERROR); }  context.setConfigSchema(rulesSchemaUi.get()); context.setTestSchema(testSchemaUi.get()); context.setAdminConfigSchema(adminConfigSchemaUi.get()); context.setAdminConfigValidator(adminConfigValidator); var defaultConfigTester = new EnrichmentConfigTester( new SiembolJsonSchemaValidator(EnrichmentTestingSpecificationDto.class), testSchemaUi.get(), compiler); context.setConfigTesters(List.of(defaultConfigTester)); LOG.info("Initialising enrichment config schema service completed"); return new EnrichmentSchemaService(compiler, context); }
[*] target: assertNotNull(service)
[-] pred: org. junit. Assert. assertNotNull ( service )
************************************
************************************
[+] input: IOException { when(httpProvider.post(any(), any())).thenReturn(null); boolean response = stormProvider.killTopology("topology"); Assert."<AssertPlaceHolder>"; }
killTopology(String id) { LOG.info("Stopping topology: {}", id); String url = String.format(StormApplicationPaths.KILL_TOPOLOGY.getName(), id, killWaitSeconds); try { StormResponseDto response = post(url, ""); if (response != null && response.getStatus() != null) return response.getStatus().equals(STORM_RESPONSE_SUCCESS); } catch (IllegalArgumentException | IOException e){ LOG.error("Exception killing storm topology: ", e); } return false; }
[*] target: assertFalse(response)
[-] pred: org. junit. Assert. assertFalse ( response )
************************************
************************************
[+] input: IOException { when(httpProvider.post(any(), any())).thenReturn("{"status": "success"}"); boolean response = stormProvider.killTopology("topology"); Assert."<AssertPlaceHolder>"; }
killTopology(String id) { LOG.info("Stopping topology: {}", id); String url = String.format(StormApplicationPaths.KILL_TOPOLOGY.getName(), id, killWaitSeconds); try { StormResponseDto response = post(url, ""); if (response != null && response.getStatus() != null) return response.getStatus().equals(STORM_RESPONSE_SUCCESS); } catch (IllegalArgumentException | IOException e){ LOG.error("Exception killing storm topology: ", e); } return false; }
[*] target: assertTrue(response)
[-] pred: org. junit. Assert. assertTrue ( response )
************************************
************************************
[+] input: IOException { String enriched = EnrichmentEvaluatorLibrary.mergeEnrichments(simpleEvent, enrichments, Optional.of("enrichment_timestamp")); Assert."<AssertPlaceHolder>"; Map<String, Object> map = JSON_MAP_READER.readValue(enriched); Assert.assertEquals(6, map.size()); Assert.assertEquals(1, map.get("timestamp")); Assert.assertEquals(true, map.get("dummy_bool")); Assert.assertEquals("test", map.get("dummy_str")); Assert.assertEquals("b", map.get("a")); Assert.assertEquals("d", map.get("c")); Assert.assertTrue(map.get("enrichment_timestamp") instanceof Number); }
mergeEnrichments(String event, List<Pair<String, String>> enrichments, Optional<String> timestampField) throws IOException { ObjectNode node = (ObjectNode)OBJECT_MAPPER.readTree(event); enrichments.forEach(x -> node.put(x.getKey(), x.getValue())); if (timestampField.isPresent()) { node.put(timestampField.get(), System.currentTimeMillis()); } return node.toString(); }
[*] target: assertNotNull(enriched)
[-] pred: org. junit. Assert. assertNotNull ( enriched )
************************************
************************************
[+] input: testNoOutputField() { RegexSelectExtractor extractor = RegexSelectExtractor.builder() .patterns(patterns) .outputField(null) .defaultValue("default_topic") .extractorFlags(extractorFlags) .name(name) .field(field) .build(); Map<String, Object> out = extractor.extract(simpleMessage.trim()); Assert."<AssertPlaceHolder>"; }
build() { if (this.outputField == null || patterns == null) { throw new IllegalArgumentException(MISSING_ARGUMENTS); } return new RegexSelectExtractor(this); }
[*] target: assertNull(out)
[-] pred: org. junit. Assert. assertNull ( out )
************************************
************************************
[+] input: Exception { parsingAttributes.setApplicationParserSpecification(simpleSingleApplicationParser.replace( ""parse_metadata" : false", ""parse_metadata" : true" )); parsingApplicationBolt = new ParsingApplicationBolt(attributes, parsingAttributes, zooKeeperConnectorFactory, metricsTestRegistrarFactory); parsingApplicationBolt.prepare(null, null, collector);  when(tuple.getStringByField(eq(ParsingApplicationTuples.METADATA.toString()))).thenReturn("INVALID"); parsingApplicationBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0); Assert.assertEquals(1, messages.size()); Assert.assertEquals("error", messages.get(0).getTopic());  Map<String, Object> parsed = JSON_READER.readValue(messages.get(0).getMessage()); Assert.assertEquals("RAW_LOG", parsed.get("raw_message")); Assert.assertEquals("error", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("parser_error", parsed.get("error_type"));  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counters = (SiembolMetricsCounters)values.get(1); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_APP_ERROR_MESSAGES.getMetricName())); }
execute(Tuple tuple) { ParsingApplicationParser currentParser = parsingApplicationParser.get();  String source = tuple.getStringByField(ParsingApplicationTuples.SOURCE.toString()); String metadata = tuple.getStringByField(ParsingApplicationTuples.METADATA.toString()); Object logObj = tuple.getValueByField(ParsingApplicationTuples.LOG.toString()); if (!(logObj instanceof byte[])) { throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLE); }  byte[] log = (byte[]) logObj; ArrayList<ParsingApplicationResult> results = currentParser.parse(source, metadata, log);  var kafkaWriterMessages = new KafkaWriterMessages(); var counters = new SiembolMetricsCounters(); for (var result : results) { if (result.getResultFlags().contains(ParsingApplicationResult.ResultFlag.FILTERED)) { metricsRegistrar.registerCounter( SiembolMetrics.PARSING_SOURCE_TYPE_FILTERED_MESSAGES.getMetricName(result.getSourceType())) .increment(); metricsRegistrar.registerCounter(SiembolMetrics.PARSING_APP_FILTERED_MESSAGES.getMetricName()) .increment(); } else { result.getMessages().forEach(x -> { kafkaWriterMessages.add(new KafkaWriterMessage(result.getTopic(), x)); addCounters(counters, result.getResultFlags(), result.getSourceType()); }); } }  if (!kafkaWriterMessages.isEmpty()) { collector.emit(tuple, new Values(kafkaWriterMessages, counters)); }  collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: testFindOne() { dao.insert(entity);  ActivityInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ActivityInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>";   }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  DeploymentInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testUpdate() { dao.insert(entity);  entity.setProcessDefinitionContent("abc_content");  dao.update( entity);  DeploymentInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>";   Assert.assertTrue("abc_content".equals(result.getProcessDefinitionContent())); }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ExecutionInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testUpdate() { dao.insert(entity);  entity.setActive(true);  dao.update(entity);  ExecutionInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; Assert.assertTrue(entity.isActive());  }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ProcessInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  // 返回删除行数,去掉findAll 接口 dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert.assertNull(result);  result = dao.findOneForUpdate(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOneForUpdate(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testFindOne() { dao.insert(entity);  TaskInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.getClaimTime()); Assert.assertEquals("comment",result.getComment()); Assert.assertEquals("extension",result.getExtension()); }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  TaskInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testQuery() { dao.insert(entity); TaskInstanceQueryParam param = new TaskInstanceQueryParam(); param.setExtension("extension1"); List<TaskInstanceEntity> result = dao.findTaskList(param);  Assert.assertNotNull(result); Assert.assertTrue(result.size() == 0);  param = new TaskInstanceQueryParam(); param.setExtension("extension"); param.setTitle("title"); param.setTag("tag"); param.setComment("comment"); param.setPriority(333); param.setClaimUserId("assign_id");  result = dao.findTaskList(param);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(result.size() == 1); Assert.assertTrue(  result.get(0).getExtension().equals("extension")); }
findTaskList(TaskInstanceQueryParam taskInstanceQueryParam);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: createCustomMusicList() { final String name = "TestMusicList";  MusicList musicList = mMusicStore.createCustomMusicList(name);  assertEquals(name, musicList.getName());  boolean exception = false; try { mMusicStore.createCustomMusicList(MusicStore.MUSIC_LIST_FAVORITE); } catch (IllegalArgumentException e) { exception = true; }  "<AssertPlaceHolder>"; }
createCustomMusicList(@NonNull String name) throws IllegalArgumentException { Preconditions.checkNotNull(name); Preconditions.checkArgument(!name.isEmpty(), "name must not empty"); checkThread();  if (isBuiltInName(name)) { throw new IllegalArgumentException("Illegal music list name, conflicts with built-in name."); }  name = trimName(name);  if (isMusicListExists(name)) { MusicList musicList = getCustomMusicList(name); assert musicList != null; return musicList; }  mAllCustomMusicListName.add(name); MusicListEntity entity = new MusicListEntity(0, name, 0, MusicList.SortOrder.BY_ADD_TIME, new byte[0]); mMusicListEntityBox.put(entity); return new MusicList(entity); }
[*] target: assertTrue(exception)
[-] pred: org. junit. Assert. assertTrue ( exception )
************************************
************************************
[+] input: copyConstructorTest() { PlayerState source = new PlayerState(); source.setPlayProgress(1000); source.setPlayProgressUpdateTime(SystemClock.elapsedRealtime()); source.setMusicItem(new MusicItem()); source.setPlayPosition(15); source.setPlayMode(PlayMode.LOOP); source.setPlaybackState(PlaybackState.ERROR); source.setPreparing(false); source.setPrepared(true); source.setAudioSessionId(12); source.setBufferedProgress(100); source.setStalled(true); source.setErrorCode(ErrorCode.PLAYER_ERROR); source.setErrorMessage("player error"); source.setSleepTimerStarted(true); source.setSleepTimerTime(60_000); source.setSleepTimerStartTime(System.currentTimeMillis()); source.setTimeoutAction(SleepTimer.TimeoutAction.STOP);  PlayerState copy = new PlayerState(source);  "<AssertPlaceHolder>"; }
setTimeoutAction(@NonNull SleepTimer.TimeoutAction action) { Preconditions.checkNotNull(timeoutAction); this.timeoutAction = action; }
[*] target: assertEquals(source, copy)
[-] pred: org. junit. Assert. assertEquals ( source, copy )
************************************
************************************
[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier(); try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL();  Properties p = new Properties(); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder( p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph(); Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv"); expected.add("test.json"); expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, null, null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier();   //		System.out.println("test/".matches("[^t]*"));   try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL();  Properties p = new Properties(); p.setProperty(ZipTriplifier.MATCHES.toString(), ".*(?<!\\.json)"); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder(p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph();  Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv");  expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, null, null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier(); try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL(); Properties p = new Properties(); p.setProperty(IRIArgument.BLANK_NODES.toString(), "false"); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder( p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph(); //			ModelFactory.createModelForGraph(dg.getDefaultGraph()).write(System.out, "TTL");  Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv"); expected.add("test.json"); expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, NodeFactory.createURI(Path.of(url.toURI()).toUri() + "#"), null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ScriptException { LarkyScriptEngineFactory factory = new LarkyScriptEngineFactory(); LarkyScriptEngine engine = (LarkyScriptEngine) factory.getScriptEngine(); String script = "print("Hello World!!!")"; LarkyCompiledScript instance = (LarkyCompiledScript) engine.compile(script);  Object expResult = "Larky ScriptEngine"; Object result = instance.getEngine().getFactory().getEngineName(); "<AssertPlaceHolder>"; }
getEngine() { return engine; }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: Exception { LarkyScriptEngineFactory factory = new LarkyScriptEngineFactory(); LarkyScriptEngine engine = (LarkyScriptEngine) factory.getScriptEngine(); ScriptContext context = new SimpleScriptContext(); StringWriter writer = new StringWriter(); StringWriter errorWriter = new StringWriter(); context.setWriter(writer); context.setErrorWriter(errorWriter);  context.setAttribute("message", "Hello World!!!!!", ScriptContext.ENGINE_SCOPE); engine.setContext(context); String script = "print(message)"; LarkyCompiledScript instance = (LarkyCompiledScript) engine.compile(script); Object expResult = "Hello World!!!!!"; instance.eval(context); Object result = writer.toString().trim(); "<AssertPlaceHolder>"; writer.close(); errorWriter.close(); }
eval(ScriptContext context) throws LarkyEvaluationScriptException { ParsedStarFile result; Bindings globalBindings = context.getBindings(ScriptContext.GLOBAL_SCOPE); Bindings engineBindings = context.getBindings(ScriptContext.ENGINE_SCOPE);  try (Reader reader = context.getReader()) { final StarFile script = InMemMapBackedStarFile.createStarFile(DEFAULT_SCRIPT_NAME, CharStreams.toString(reader)); final DefaultLarkyInterpreter larkyInterpreter = new DefaultLarkyInterpreter(LARKY_MODE, globalBindings, engineBindings); result = larkyInterpreter.evaluate(script, context.getWriter()); } catch (IOException | StarlarkEvalWrapper.Exc.RuntimeEvalException | Starlark.UncheckedEvalException | EvalException e) { throw LarkyEvaluationScriptException.of(e); } setBindingsValue(globalBindings, engineBindings, result.getGlobals()); return result; }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: optionsForNoAttendees() { MeetingRequest request = new MeetingRequest(NO_ATTENDEES, DURATION_1_HOUR);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: noOptionsForTooLongOfARequest() { // The duration should be longer than a day. This means there should be no options. int duration = TimeRange.WHOLE_DAY.duration() + 1; MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), duration);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList();  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: eventSplitsRestriction() { // The event should split the day into two options (before and after the event). Collection<Event> events = Arrays.asList(new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: everyAttendeeIsConsidered() { // Have each person have different events. We should see two options because each person has // split the restricted times. // // Events  :       |--A--|     |--B--| // Day     : |-----------------------------| // Options : |--1--|     |--2--|     |--3--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0800AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0800AM, false), TimeRange.fromStartEnd(TIME_0830AM, TIME_0900AM, false), TimeRange.fromStartEnd(TIME_0930AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: overlappingEvents() { // Have an event for each person, but have their events overlap. We should only see two options. // // Events  :       |--A--| //                     |--B--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_60_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_60_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_1000AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: nestedEvents() { // Have an event for each person, but have one person's event fully contain another's event. We // should see two options. // // Events  :       |----A----| //                   |--B--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_90_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_1000AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: doubleBookedPeople() { // Have one person, but have them registered to attend two events at the same time. // // Events  :       |----A----| //                     |--A--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_60_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_0930AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: justEnoughRoom() { // Have one person, but make it so that there is just enough room at one point in the day to // have the meeting. // // Events  : |--A--|     |----A----| // Day     : |---------------------| // Options :       |-----|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartDuration(TIME_0830AM, DURATION_30_MINUTES));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ignoresPeopleNotAttending() { // Add an event, but make the only attendee someone different from the person looking to book // a meeting. This event should not affect the booking. Collection<Event> events = Arrays.asList(new Event("Event 1", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A))); MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: noConflicts() { MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: notEnoughRoom() { // Have one person, but make it so that there is not enough room at any point in the day to // have the meeting. // // Events  : |--A-----| |-----A----| // Day     : |---------------------| // Options :  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_60_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList();  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: CantAddOptionalAttendeeWhoIsAlsoMandatory() { MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_1_HOUR); request.addOptionalAttendee(PERSON_A);  int actual = request.getOptionalAttendees().size(); int expected = 0; Assert."<AssertPlaceHolder>"; }
getOptionalAttendees() { return Collections.unmodifiableCollection(optional_attendees); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testNormalizeValidPhoneNumber() { { String inputPhoneNumber = "+1 650-555-1234"; String expectedNormalizedPhoneNumber = "+16505551234"; String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); assertEquals(expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber); } { String inputPhoneNumber = "+640223334444"; String expectedNormalizedPhoneNumber = "+64223334444"; String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); "<AssertPlaceHolder>"; } }
normalizeIfPhoneNumber(String phoneNumber) { if (phoneNumber == null) { return null; }  PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();  try { // Attempt to parse the phone number with default region code "ZZ" (unknown // region) Phonenumber.PhoneNumber parsedPhoneNumber = phoneNumberUtil.parse(phoneNumber.trim(), "ZZ");  // Format the parsed phone number according to E.164 standard phoneNumber = phoneNumberUtil.format(parsedPhoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164); } catch (NumberParseException e) { // Parsing failed, use the original trimmed phone number phoneNumber = phoneNumber.trim(); }  return phoneNumber; }
[*] target: assertEquals(expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber)
[-] pred: org. junit. Assert. assertEquals ( expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber )
************************************
************************************
[+] input: testNormalizeInvalidPhoneNumber() { String inputPhoneNumber = "  johndoe@gmail.com  "; String expectedTrimmedPhoneNumber = inputPhoneNumber.trim(); String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); "<AssertPlaceHolder>"; }
normalizeIfPhoneNumber(String phoneNumber) { if (phoneNumber == null) { return null; }  PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();  try { // Attempt to parse the phone number with default region code "ZZ" (unknown // region) Phonenumber.PhoneNumber parsedPhoneNumber = phoneNumberUtil.parse(phoneNumber.trim(), "ZZ");  // Format the parsed phone number according to E.164 standard phoneNumber = phoneNumberUtil.format(parsedPhoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164); } catch (NumberParseException e) { // Parsing failed, use the original trimmed phone number phoneNumber = phoneNumber.trim(); }  return phoneNumber; }
[*] target: assertEquals(expectedTrimmedPhoneNumber, actualNormalizedPhoneNumber)
[-] pred: org. junit. Assert. assertEquals ( expectedTrimmedPhoneNumber, actualNormalizedPhoneNumber )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // format for Firebase SCrypt hashes stored in supertokens. // $f_scrypt$passwordHash$salt$m=memory$r=rounds$s=saltSeparator  String passwordHash = "passwordHash"; String salt = "salt"; int memory = 14; int rounds = 8; String saltSeparator = "Bw==";  // when password hash is in the regular format { String validPasswordHash = "$" + ParsedFirebaseSCryptResponse.FIREBASE_SCRYPT_PREFIX + "$" + passwordHash + "$" + salt + "$" + "m=" + memory + "$" + "r=" + rounds + "$" + "s=" + saltSeparator;  ParsedFirebaseSCryptResponse response = ParsedFirebaseSCryptResponse.fromHashString(validPasswordHash); assertNotNull(response);  assertEquals(passwordHash, response.passwordHash); assertEquals(salt, response.salt); assertEquals(memory, response.memCost); assertEquals(saltSeparator, response.saltSeparator); }  // with memory, rounds and saltSeparator switched around { String validPasswordHash = "$" + ParsedFirebaseSCryptResponse.FIREBASE_SCRYPT_PREFIX + "$" + passwordHash + "$" + salt + "$" + "s=" + saltSeparator + "$" + "m=" + memory + "$" + "r=" + rounds;  ParsedFirebaseSCryptResponse response = ParsedFirebaseSCryptResponse.fromHashString(validPasswordHash); "<AssertPlaceHolder>";  assertEquals(passwordHash, response.passwordHash); assertEquals(salt, response.salt); assertEquals(memory, response.memCost); assertEquals(saltSeparator, response.saltSeparator); }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
fromHashString(String hash) { try { String[] separatedPasswordHash = hash.split(FIREBASE_SCRYPT_SEPARATOR);  // check that stored password hash contains 7 fields and after splitting, the first field is empty and the // second field has the firebase scrypt prefix if (!(separatedPasswordHash.length == 7 && separatedPasswordHash[0].equals("") && separatedPasswordHash[1].equals(FIREBASE_SCRYPT_PREFIX))) { return null; }  String passwordHash = separatedPasswordHash[2]; String salt = separatedPasswordHash[3]; String saltSeparator = null; Integer memCost = null; Integer rounds = null;  for (int i = 4; i < separatedPasswordHash.length; i++) { if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_MEM_COST_SEPARATOR)) { memCost = Integer.parseInt(separatedPasswordHash[i].split(FIREBASE_SCRYPT_MEM_COST_SEPARATOR)[1]); continue; } if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_ROUNDS_SEPARATOR)) { rounds = Integer.parseInt(separatedPasswordHash[i].split(FIREBASE_SCRYPT_ROUNDS_SEPARATOR)[1]); continue; } if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_SALT_SEPARATOR)) { saltSeparator = separatedPasswordHash[i].split(FIREBASE_SCRYPT_SALT_SEPARATOR)[1]; } }  if (passwordHash == null || salt == null || saltSeparator == null || memCost == null || rounds == null) { return null; } return new ParsedFirebaseSCryptResponse(passwordHash, salt, saltSeparator, rounds, memCost); } catch (Throwable e) { return null; } }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: IOException { String[] args = {"../"};  Utils.setValueInConfig("access_token_validity", "-1"); TestingProcessManager.TestingProcess process = TestingProcessManager.start(args, false); FeatureFlagTestContent.getInstance(process.getProcess()) .setKeyValue(FeatureFlagTestContent.ENABLED_FEATURES, new EE_FEATURES[]{EE_FEATURES.MULTI_TENANCY}); process.startProcess();  ProcessState.EventAndException e = process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.INIT_FAILURE); "<AssertPlaceHolder>"; assertEquals(e.exception.getCause().getMessage(), "'access_token_validity' must be between 1 and 86400000 seconds inclusive. The config file can be " + "found here: " + getConfigFileLocation(process.getProcess()));  assertNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.LOADING_ALL_TENANT_CONFIG, 1000));  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getInstance(Start start) { return (Config) start.getResourceDistributor() .getResource(RESOURCE_KEY); }
[*] target: assertNotNull(e)
[-] pred: org. junit. Assert. assertNotNull ( e )
************************************
************************************
[+] input: Exception { { TestInput input = new TestInput("value"); io.supertokens.utils.Utils.PubPriKey rsa = io.supertokens.utils.Utils.generateNewPubPriKey(); String token = JWT.createAndSignLegacyAccessToken(new Gson().toJsonTree(input), rsa.privateKey, AccessToken.VERSION.V1); TestInput output = new Gson().fromJson( JWT.verifyJWTAndGetPayload(JWT.preParseJWTInfo(token), rsa.publicKey).payload, TestInput.class); assertEquals(input, output); }  { TestInput input = new TestInput("value"); io.supertokens.utils.Utils.PubPriKey rsa = io.supertokens.utils.Utils.generateNewPubPriKey(); String token = JWT.createAndSignLegacyAccessToken(new Gson().toJsonTree(input), rsa.privateKey, AccessToken.VERSION.V2); TestInput output = new Gson().fromJson( JWT.verifyJWTAndGetPayload(JWT.preParseJWTInfo(token), rsa.publicKey).payload, TestInput.class); "<AssertPlaceHolder>"; } }
preParseJWTInfo(String jwt) throws JWTException { initHeader(); String[] splittedInput = jwt.split("\\."); if (splittedInput.length != 3) { throw new JWTException("Invalid JWT"); }  if (splittedInput[0].equals(JWT.HEADERv1)) { return new JWTPreParseInfo(splittedInput, AccessToken.VERSION.V1, null); }  if (splittedInput[0].equals(JWT.HEADERv2)) { return new JWTPreParseInfo(splittedInput, AccessToken.VERSION.V2, null); }  JsonObject parsedHeader = new JsonParser().parse(Utils.convertFromBase64(splittedInput[0])).getAsJsonObject();  if (parsedHeader.get("typ") == null) { throw new JWTException("JWT header missing - typ"); } JsonPrimitive typ = parsedHeader.get("typ").getAsJsonPrimitive(); if (!typ.isString() || !typ.getAsString().equals("JWT")) { throw new JWTException("JWT header mismatch - typ"); }  if (parsedHeader.get("alg") == null) { throw new JWTException("JWT header missing - alg"); } JsonPrimitive alg = parsedHeader.get("alg").getAsJsonPrimitive(); if (!alg.isString() || !alg.getAsString().equals("RS256")) { throw new JWTException("JWT header mismatch - alg"); }  JsonElement versionElement = parsedHeader.get("version"); // We default to using the latest access token version here for JWTs not created by the session recipe String versionString = AccessToken.getVersionStringFromAccessTokenVersion(AccessToken.getLatestVersion());  if (versionElement != null) { JsonPrimitive version = versionElement.getAsJsonPrimitive(); if (!version.isString() || version.getAsString().equals("1") || version.getAsString().equals("2")) { throw new JWTException("JWT header mismatch - version"); }  versionString = version.getAsString(); }  JsonPrimitive kid = parsedHeader.get("kid").getAsJsonPrimitive(); if (parsedHeader.get("kid") == null) { throw new JWTException("JWT header missing - kid"); } if (!kid.isString()) { throw new JWTException("JWT header mismatch - kid"); } return new JWTPreParseInfo(splittedInput, AccessToken.getVersionFromString(versionString), kid.getAsString()); }
[*] target: assertEquals(input, output)
[-] pred: org. junit. Assert. assertEquals ( input, output )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create a user AuthRecipeUserInfo userInfo = EmailPassword.signUp(process.main, "test@example.com", "testPassword");  String externalUserId = "external-test";  UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), externalUserId, null, false);  { // duplicate exception with both supertokensUserId and externalUserId Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), externalUserId, null, false); } catch (Exception e) { error = e; }  assertNotNull(error); assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertTrue(usersIdMappingExistsError.doesExternalUserIdExist); assertTrue(usersIdMappingExistsError.doesSuperTokensUserIdExist); }  { // duplicate exception with superTokensUserId Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), "newExternalId", null, false); } catch (Exception e) { error = e; }  assertNotNull(error); assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertFalse(usersIdMappingExistsError.doesExternalUserIdExist); assertTrue(usersIdMappingExistsError.doesSuperTokensUserIdExist);  }  { // duplicate exception with externalUserId  AuthRecipeUserInfo newUser = EmailPassword.signUp(process.main, "test2@example.com", "testPass123"); Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, newUser.getSupertokensUserId(), externalUserId, null, false); } catch (Exception e) { error = e; }  "<AssertPlaceHolder>"; assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertTrue(usersIdMappingExistsError.doesExternalUserIdExist); assertFalse(usersIdMappingExistsError.doesSuperTokensUserIdExist);  }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  ArrayList<String> nonAuthRecipesWhichDontNeedUserIdMapping = new ArrayList<>( List.of("io.supertokens.pluginInterface.jwt.JWTRecipeStorage", ActiveUsersStorage.class.getName())); Reflections reflections = new Reflections("io.supertokens.pluginInterface"); Set<Class<? extends NonAuthRecipeStorage>> classes = reflections.getSubTypesOf(NonAuthRecipeStorage.class); List<String> names = classes.stream().map(Class::getCanonicalName).collect(Collectors.toList()); List<String> classNames = new ArrayList<>(); for (String name : names) { if (!name.contains("SQLStorage")) { classNames.add(name); } } String externalId = "externalId"; for (String className : classNames) { // Create a User AuthRecipeUserInfo user = EmailPassword.signUp(process.main, "test@example.com", "testPass123");  // create a mapping with the user UserIdMapping.createUserIdMapping(process.main, user.getSupertokensUserId(), externalId, null, false);  // create entry in nonAuth table with externalId StorageLayer.getStorage(process.main) .addInfoToNonAuthRecipesBasedOnUserId(TenantIdentifier.BASE_TENANT, className, externalId);  // try to delete UserIdMapping String errorMessage = null; try { UserIdMapping.deleteUserIdMapping(process.main, user.getSupertokensUserId(), UserIdType.SUPERTOKENS, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } if (!nonAuthRecipesWhichDontNeedUserIdMapping.contains(className)) { "<AssertPlaceHolder>"; assertTrue(errorMessage.contains("UserId is already in use")); } // delete user data AuthRecipe.deleteUser(process.main, user.getSupertokensUserId()); }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
deleteUserIdMapping(Main main, String userId, UserIdType userIdType, boolean force) throws StorageQueryException, ServletException { Storage storage = StorageLayer.getStorage(main); return deleteUserIdMapping( new AppIdentifier(null, null), storage, userId, userIdType, force); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create an EmailPassword User AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123"); // create a mapping for the EmailPassword User UserIdMapping.createUserIdMapping(process.main, user_1.getSupertokensUserId(), "externalId", null, false);  // create some metadata for the user JsonObject data = new JsonObject(); data.addProperty("test", "testData"); UserMetadata.updateUserMetadata(process.main, "externalId", data);  // Create another User AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@example.com", "testPass123");  // try and map user_2 to user_1s superTokensUserId String errorMessage = null; try { UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } "<AssertPlaceHolder>"; assertEquals("Cannot create a userId mapping where the externalId is also a SuperTokens userID", errorMessage);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create user 1 AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123");  // create user 2 AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@example.com", "testPass123");  // create a mapping between User_1 and User_2 with force UserIdMapping.createUserIdMapping(process.main, user_1.getSupertokensUserId(), user_2.getSupertokensUserId(), null, true);  // try and create a mapping between User_2 and User_1 without force String errorMessage = null; try { UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } "<AssertPlaceHolder>"; assertEquals("Cannot create a userId mapping where the externalId is also a SuperTokens userID", errorMessage);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  String userId = "userId"; JsonObject metadata = UserMetadata.getUserMetadata(process.getProcess(), userId);  "<AssertPlaceHolder>"; assertEquals(metadata.entrySet().size(), 0);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserMetadata(Main main, @Nonnull String userId) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserMetadata(new AppIdentifier(null, null), storage, userId); }
[*] target: assertNotNull(metadata)
[-] pred: org. junit. Assert. assertNotNull ( metadata )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  String userId = "userId"; JsonObject update = new JsonObject(); update.addProperty("test", "123"); update.add("testNull", JsonNull.INSTANCE); JsonObject updateResult = UserMetadata.updateUserMetadata(process.getProcess(), userId, update);  JsonObject newMetadata = UserMetadata.getUserMetadata(process.getProcess(), userId);  "<AssertPlaceHolder>"; assertEquals(1, updateResult.entrySet().size()); assertEquals("123", updateResult.get("test").getAsString()); assert (!updateResult.has("testNull"));  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserMetadata(Main main, @Nonnull String userId) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserMetadata(new AppIdentifier(null, null), storage, userId); }
[*] target: assertEquals(updateResult, newMetadata)
[-] pred: org. junit. Assert. assertEquals ( updateResult, newMetadata )
************************************
************************************
[+] input: givenClientSessionDetails_whenGetSessionInfo_thenReturnExpectedResult() { UUID sessionId = UUID.randomUUID(); String clientId = "clientId"; MqttConnectMsg msg = getMqttConnectMsg(sessionId, clientId); SessionInfo actualSessionInfo = connectService.getSessionInfo(msg, sessionId, clientId, ClientType.DEVICE, 0, BrokerConstants.LOCAL_ADR);  SessionInfo expectedSessionInfo = ClientSessionInfoFactory.getSessionInfo( sessionId, false, SERVICE_ID, getClientInfo(clientId), getConnectionInfo(1000, actualSessionInfo.getConnectionInfo().getConnectedAt()), 0);  Assert."<AssertPlaceHolder>"; }
getSessionInfo(MqttConnectMsg msg, UUID sessionId, String clientId, ClientType clientType, int sessionExpiryInterval, byte[] clientIpAdr) { return ClientSessionInfoFactory.getSessionInfo( sessionId, msg.isCleanStart(), serviceInfoProvider.getServiceId(), new ClientInfo(clientId, clientType, clientIpAdr), ClientSessionInfoFactory.getConnectionInfo(msg.getKeepAliveTimeSeconds()), sessionExpiryInterval); }
[*] target: assertEquals(expectedSessionInfo, actualSessionInfo)
[-] pred: org. junit. Assert. assertEquals ( expectedSessionInfo, actualSessionInfo )
************************************
************************************
[+] input: givenSuccessReasonCode_whenCheckIfReasonCodeFailure_thenReturnFalse() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.SUCCESS)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenFailureReasonCode_whenCheckIfReasonCodeFailure_thenReturnTrue() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenOtherFailureReasonCode_whenCheckIfReasonCodeFailure_thenReturnTrue() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.PAYLOAD_FORMAT_INVALID)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenNoDelayedMessages_whenProcessDelayedMsg_thenRemoveClientFromDelayedProcessing() { publishedInFlightCtx.getPublishedInFlightMsgCounter().set(5);  boolean result = publishedInFlightCtx.processMsg(1);  verify(flowControlService, times(1)).removeFromMap("test");  "<AssertPlaceHolder>"; }
processMsg(long ttlMs) { lock.lock(); try { if (!allowedToSendMsg()) { if (log.isDebugEnabled()) { log.debug("[{}] Still reaching clientReceiveMax... Waiting for more ack messages", clientId); } return false; }  while (true) { MqttPubMsgWithCreatedTime head = delayedMsgQueue.poll(); if (head == null) { if (log.isDebugEnabled()) { log.debug("[{}] Delayed queue is empty!", clientId); } flowControlService.removeFromMap(clientId); return false; } delayedMsgCounter.decrementAndGet(); if (head.getCreatedTime() + ttlMs < System.currentTimeMillis()) { if (log.isDebugEnabled()) { log.debug("[{}] Msg expired in delayed queue {}", clientId, head); } continue; }  addPublishedInFlightMsg(head.getMqttPublishMessage()); sendDelayedMsg(head.getMqttPublishMessage()); break; } return true; } finally { lock.unlock(); } }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenMqttPropertiesWithResponseTopicAndCorrelationData_whenGetMqttPropsProtoBuilder_thenGetExpectedResult() { MqttProperties properties = new MqttProperties(); properties.add(new MqttProperties.BinaryProperty(BrokerConstants.CORRELATION_DATA_PROP_ID, "test".getBytes(StandardCharsets.UTF_8))); properties.add(new MqttProperties.StringProperty(BrokerConstants.RESPONSE_TOPIC_PROP_ID, "test/"));  QueueProtos.MqttPropertiesProto.Builder mqttPropsProtoBuilder = ProtoConverter.getMqttPropsProtoBuilder(properties);  "<AssertPlaceHolder>"; QueueProtos.MqttPropertiesProto proto = mqttPropsProtoBuilder.build(); assertEquals("test/", proto.getResponseTopic()); assertEquals("test", proto.getCorrelationData().toString(StandardCharsets.UTF_8)); }
getMqttPropsProtoBuilder(MqttProperties properties) { Integer payloadFormatIndicator = getPayloadFormatIndicatorFromMqttProperties(properties); String contentType = getContentTypeFromMqttProperties(properties); String responseTopic = MqttPropertiesUtil.getResponseTopicValue(properties); byte[] correlationData = MqttPropertiesUtil.getCorrelationDataValue(properties); if (payloadFormatIndicator != null || contentType != null || responseTopic != null || correlationData != null) { QueueProtos.MqttPropertiesProto.Builder mqttPropertiesBuilder = QueueProtos.MqttPropertiesProto.newBuilder(); if (payloadFormatIndicator != null) { mqttPropertiesBuilder.setPayloadFormatIndicator(payloadFormatIndicator); } if (contentType != null) { mqttPropertiesBuilder.setContentType(contentType); } if (responseTopic != null) { mqttPropertiesBuilder.setResponseTopic(responseTopic); } if (correlationData != null) { mqttPropertiesBuilder.setCorrelationData(ByteString.copyFrom(correlationData)); } return mqttPropertiesBuilder; } return null; }
[*] target: assertNotNull(mqttPropsProtoBuilder)
[-] pred: org. junit. Assert. assertNotNull ( mqttPropsProtoBuilder )
************************************
************************************
[+] input: testDevicePersistedMsgsBucketConfiguration() { DevicePersistedMsgsRateLimitsConfiguration config = new DevicePersistedMsgsRateLimitsConfiguration(); config.setEnabled(true); config.setConfig("100:60,200:120");  BucketConfiguration bucketConfig = config.devicePersistedMsgsBucketConfiguration();  "<AssertPlaceHolder>"; assertEquals(2, bucketConfig.getBandwidths().length);  Bandwidth bw1 = bucketConfig.getBandwidths()[0]; assertEquals(100, bw1.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(60), bw1.getRefillPeriodNanos());  Bandwidth bw2 = bucketConfig.getBandwidths()[1]; assertEquals(200, bw2.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(120), bw2.getRefillPeriodNanos()); }
devicePersistedMsgsBucketConfiguration() { return getBucketConfiguration(); }
[*] target: assertNotNull(bucketConfig)
[-] pred: org. junit. Assert. assertNotNull ( bucketConfig )
************************************
************************************
[+] input: testTotalMsgsBucketConfiguration() { TotalMsgsRateLimitsConfiguration config = new TotalMsgsRateLimitsConfiguration(); config.setEnabled(true); config.setConfig("100:60,200:120");  BucketConfiguration bucketConfig = config.totalMsgsBucketConfiguration();  "<AssertPlaceHolder>"; assertEquals(2, bucketConfig.getBandwidths().length);  Bandwidth bw1 = bucketConfig.getBandwidths()[0]; assertEquals(100, bw1.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(60), bw1.getRefillPeriodNanos());  Bandwidth bw2 = bucketConfig.getBandwidths()[1]; assertEquals(200, bw2.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(120), bw2.getRefillPeriodNanos()); }
totalMsgsBucketConfiguration() { return getBucketConfiguration(); }
[*] target: assertNotNull(bucketConfig)
[-] pred: org. junit. Assert. assertNotNull ( bucketConfig )
************************************
************************************
[+] input: testTryConsumeDevicePersistedMsg() { // Set up bucket proxy Bandwidth limit = Bandwidth.builder().capacity(10).refillGreedy(10, Duration.ofMinutes(1)).build(); BucketConfiguration bucketConfig = BucketConfiguration.builder().addLimit(limit).build(); when(jedisBasedProxyManager.getProxy(anyString(), any())).thenReturn(bucketProxy); rateLimitRedisCacheService = new RateLimitRedisCacheServiceImpl(redisTemplate, jedisBasedProxyManager, bucketConfig, null); setCachePrefixAndInit();  when(bucketProxy.tryConsume(1)).thenReturn(true);  boolean result = rateLimitRedisCacheService.tryConsumeDevicePersistedMsg();  "<AssertPlaceHolder>"; verify(bucketProxy, times(1)).tryConsume(1); }
tryConsumeDevicePersistedMsg() { return devicePersistedMsgsBucketProxy.tryConsume(1); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testTryConsumeTotalMsg() { // Set up bucket proxy Bandwidth limit = Bandwidth.builder().capacity(10).refillGreedy(10, Duration.ofMinutes(1)).build(); BucketConfiguration bucketConfig = BucketConfiguration.builder().addLimit(limit).build(); when(jedisBasedProxyManager.getProxy(anyString(), any())).thenReturn(bucketProxy); rateLimitRedisCacheService = new RateLimitRedisCacheServiceImpl(redisTemplate, jedisBasedProxyManager, null, bucketConfig); setCachePrefixAndInit();  when(bucketProxy.tryConsume(1)).thenReturn(true);  boolean result = rateLimitRedisCacheService.tryConsumeTotalMsg();  "<AssertPlaceHolder>"; verify(bucketProxy, times(1)).tryConsume(1); }
tryConsumeTotalMsg() { return totalMsgsBucketProxy.tryConsume(1); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenIncomingRateLimitsDisabled_whenCheckIncomingLimits_thenSuccess() { when(incomingRateLimitsConfiguration.isEnabled()).thenReturn(false);  boolean result = rateLimitService.checkIncomingLimits(CLIENT_ID, UUID.randomUUID(), null); Assert."<AssertPlaceHolder>"; }
checkIncomingLimits(String clientId, UUID sessionId, MqttMessage msg) { if (!incomingRateLimitsConfiguration.isEnabled()) { return true; } TbRateLimits rateLimits = incomingPublishClientLimits.computeIfAbsent(clientId, id -> new TbRateLimits(incomingRateLimitsConfiguration.getClientConfig())); if (!rateLimits.tryConsume()) { if (log.isTraceEnabled()) { log.trace("[{}][{}] Client level incoming PUBLISH rate limit detected: {}", clientId, sessionId, msg); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenNoSessionsLimit_whenCheckSessionsLimit_thenSuccess() { rateLimitService.setSessionsLimit(0);  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenSessionsLimitReached_whenCheckSessionsLimit_thenFailure() { rateLimitService.setSessionsLimit(1); when(rateLimitCacheService.incrementSessionCount()).thenReturn(2L);  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenSessionsLimitReached_whenCheckSessionsLimitForExistingClient_thenSuccess() { rateLimitService.setSessionsLimit(1); when(rateLimitCacheService.incrementSessionCount()).thenReturn(2L); when(clientSessionService.getClientSessionInfo(CLIENT_ID)).thenReturn(ClientSessionInfo.builder().build());  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenNoApplicationClientsLimit_whenCheckApplicationClientsLimit_thenSuccess() { rateLimitService.setApplicationClientsLimit(0);  SessionInfo sessionInfo = SessionInfo.builder().build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenApplicationClientsLimitReached_whenCheckApplicationClientsLimit_thenFailure() { rateLimitService.setApplicationClientsLimit(1); when(rateLimitCacheService.incrementApplicationClientsCount()).thenReturn(2L);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).clientId(CLIENT_ID).build()).cleanStart(false).build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenApplicationClientsLimitReached_whenCheckApplicationClientsLimitForExistingClient_thenSuccess() { rateLimitService.setApplicationClientsLimit(1); when(rateLimitCacheService.incrementApplicationClientsCount()).thenReturn(2L);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).clientId(CLIENT_ID).build()).cleanStart(false).build(); ClientSessionInfo clientSessionInfo = ClientSessionInfo.builder().type(ClientType.APPLICATION).cleanStart(false).build(); when(clientSessionService.getClientSessionInfo(CLIENT_ID)).thenReturn(clientSessionInfo);  boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenDevicePersistedMsgsRateLimitsEnabled_whenRateLimitNotReached_thenSuccess() { when(devicePersistedMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeDevicePersistedMsg()).thenReturn(true);  boolean result = rateLimitService.checkDevicePersistedMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkDevicePersistedMsgsLimit() { if (!devicePersistedMsgsRateLimitsConfiguration.isEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeDevicePersistedMsg()) { if (log.isTraceEnabled()) { log.trace("Device persisted messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenDevicePersistedMsgsRateLimitsEnabled_whenRateLimitReached_thenFailure() { when(devicePersistedMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeDevicePersistedMsg()).thenReturn(false);  boolean result = rateLimitService.checkDevicePersistedMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkDevicePersistedMsgsLimit() { if (!devicePersistedMsgsRateLimitsConfiguration.isEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeDevicePersistedMsg()) { if (log.isTraceEnabled()) { log.trace("Device persisted messages rate limit detected!"); } return false; } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenTotalMsgsRateLimitsEnabled_whenRateLimitNotReached_thenSuccess() { when(totalMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeTotalMsg()).thenReturn(true);  boolean result = rateLimitService.checkTotalMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkTotalMsgsLimit() { if (!isTotalMsgsLimitEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeTotalMsg()) { if (log.isTraceEnabled()) { log.trace("Total incoming and outgoing messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenTotalMsgsRateLimitsEnabled_whenRateLimitReached_thenFailure() { when(totalMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeTotalMsg()).thenReturn(false);  boolean result = rateLimitService.checkTotalMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkTotalMsgsLimit() { if (!isTotalMsgsLimitEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeTotalMsg()) { if (log.isTraceEnabled()) { log.trace("Total incoming and outgoing messages rate limit detected!"); } return false; } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: loadPersistedMsgCtxTest() { ApplicationSessionCtx applicationSessionCtx = buildApplicationSessionCtx(); when(sessionCtxService.findApplicationSessionCtx(CLIENT_ID)).thenReturn(Optional.of(applicationSessionCtx));  ApplicationPersistedMsgCtx actual = applicationPersistedMsgCtxService.loadPersistedMsgCtx(CLIENT_ID); ApplicationPersistedMsgCtx expected = new ApplicationPersistedMsgCtx(getPendingMsgIdsMap(), getPendingMsgIdsMap()); Assert."<AssertPlaceHolder>"; }
loadPersistedMsgCtx(String clientId) { if (log.isTraceEnabled()) { log.trace("[{}] Loading persisted messages context.", clientId); } ApplicationSessionCtx applicationSessionCtx = findApplicationSessionCtx(clientId); if (applicationSessionCtx == null) { return new ApplicationPersistedMsgCtx(Collections.emptyMap(), Collections.emptyMap()); } Map<Long, Integer> publishMsgIds = getPendingMsgsFromApplicationCtx(applicationSessionCtx.getPublishMsgInfos()); Map<Long, Integer> pubRelMsgIds = getPendingMsgsFromApplicationCtx(applicationSessionCtx.getPubRelMsgInfos()); return new ApplicationPersistedMsgCtx(publishMsgIds, pubRelMsgIds); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: givenClientContextAndAllowPublishToTopic_whenValidateClientAccess_thenSuccess() { when(authorizationRuleService.isPubAuthorized(any(), any(), any())).thenReturn(true); boolean result = publishMsgValidationService.validateClientAccess(ctx, "clientId", "topic/1"); Assert."<AssertPlaceHolder>"; }
validateClientAccess(ClientSessionCtx ctx, String clientId, String topic) { boolean isClientAuthorized = authorizationRuleService.isPubAuthorized(clientId, topic, ctx.getAuthRulePatterns()); if (!isClientAuthorized) { log.warn("[{}][{}][{}] Client is not authorized to publish to the topic {}", clientId, ctx.getSessionId(), ctx.getAuthRulePatterns(), topic); } return isClientAuthorized; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenClientContextAndNotAllowPublishToTopic_whenValidateClientAccess_thenFailure() { when(authorizationRuleService.isPubAuthorized(any(), any(), any())).thenReturn(false); boolean result = publishMsgValidationService.validateClientAccess(ctx, "clientId", "topic/1"); Assert."<AssertPlaceHolder>"; }
validateClientAccess(ClientSessionCtx ctx, String clientId, String topic) { boolean isClientAuthorized = authorizationRuleService.isPubAuthorized(clientId, topic, ctx.getAuthRulePatterns()); if (!isClientAuthorized) { log.warn("[{}][{}][{}] Client is not authorized to publish to the topic {}", clientId, ctx.getSessionId(), ctx.getAuthRulePatterns(), topic); } return isClientAuthorized; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testApplyTotalMsgsRateLimits_whenTotalMsgsLimitDisabled() { when(rateLimitService.isTotalMsgsLimitEnabled()).thenReturn(false);  List<ValueWithTopicFilter<ClientSubscription>> list = List.of( newValueWithTopicFilter("c1", 0, "t1"), newValueWithTopicFilter("c2", 1, "t2"), newValueWithTopicFilter("c3", 2, "t3") ); List<ValueWithTopicFilter<ClientSubscription>> result = msgDispatcherService.applyTotalMsgsRateLimits(list);  "<AssertPlaceHolder>"; }
applyTotalMsgsRateLimits(List<ValueWithTopicFilter<ClientSubscription>> clientSubscriptions) { if (rateLimitService.isTotalMsgsLimitEnabled() && clientSubscriptions.size() > 1) { int availableTokens = (int) rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(clientSubscriptions.size()); if (availableTokens == 0) { log.debug("No available tokens left for total msgs bucket"); return Collections.emptyList(); } if (log.isDebugEnabled() && availableTokens < clientSubscriptions.size()) { log.debug("Hitting total messages rate limits on subscriptions processing. Skipping {} messages", clientSubscriptions.size() - availableTokens); } return clientSubscriptions.subList(0, availableTokens); } return clientSubscriptions; }
[*] target: assertEquals(list, result)
[-] pred: org. junit. Assert. assertEquals ( list, result )
************************************
************************************
[+] input: testApplyTotalMsgsRateLimits_whenTotalMsgsLimitEnabledAndLimitNotUsed() { when(rateLimitService.isTotalMsgsLimitEnabled()).thenReturn(true); when(rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(eq(3L))).thenReturn(3L);  List<ValueWithTopicFilter<ClientSubscription>> list = List.of( newValueWithTopicFilter("c1", 0, "t1"), newValueWithTopicFilter("c2", 1, "t2"), newValueWithTopicFilter("c3", 2, "t3") ); List<ValueWithTopicFilter<ClientSubscription>> result = msgDispatcherService.applyTotalMsgsRateLimits(list);  "<AssertPlaceHolder>"; }
applyTotalMsgsRateLimits(List<ValueWithTopicFilter<ClientSubscription>> clientSubscriptions) { if (rateLimitService.isTotalMsgsLimitEnabled() && clientSubscriptions.size() > 1) { int availableTokens = (int) rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(clientSubscriptions.size()); if (availableTokens == 0) { log.debug("No available tokens left for total msgs bucket"); return Collections.emptyList(); } if (log.isDebugEnabled() && availableTokens < clientSubscriptions.size()) { log.debug("Hitting total messages rate limits on subscriptions processing. Skipping {} messages", clientSubscriptions.size() - availableTokens); } return clientSubscriptions.subList(0, availableTokens); } return clientSubscriptions; }
[*] target: assertEquals(list, result)
[-] pred: org. junit. Assert. assertEquals ( list, result )
************************************
************************************
[+] input: givenPubMsgAndSubscriptionWithSameQosAndFalseRetainAsPublish_whenProcessUpdatePublishMsg_thenReturnSameMsg() { Subscription subscription = new Subscription("test/topic", 1, ClientSessionInfo.builder().build()); QueueProtos.PublishMsgProto beforePublishMsgProto = QueueProtos.PublishMsgProto.newBuilder().setQos(1).setRetain(false).build();  QueueProtos.PublishMsgProto afterPublishMsgProto = downLinkProxy.updatePublishMsg(subscription, beforePublishMsgProto);  Assert."<AssertPlaceHolder>"; }
updatePublishMsg(Subscription subscription, PublishMsgProto publishMsgProto) { var minQos = Math.min(subscription.getQos(), publishMsgProto.getQos()); var retain = subscription.getOptions().isRetain(publishMsgProto.getRetain());  if (minQos != publishMsgProto.getQos() || retain != publishMsgProto.getRetain()) { return publishMsgProto.toBuilder() .setQos(minQos) .setRetain(retain) .build(); } else { return publishMsgProto; } }
[*] target: assertEquals(beforePublishMsgProto, afterPublishMsgProto)
[-] pred: org. junit. Assert. assertEquals ( beforePublishMsgProto, afterPublishMsgProto )
************************************
************************************
[+] input: givenSameClient_whenCheckIsAnyOtherDeviceClientConnected_thenFalse() { when(clientSessionInfo1.isConnected()).thenReturn(true); when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_1, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertFalse(anyDeviceClientConnected)
[-] pred: org. junit. Assert. assertFalse ( anyDeviceClientConnected )
************************************
************************************
[+] input: givenDisconnectedClients_whenCheckIsAnyOtherDeviceClientConnected_thenFalse() { when(clientSessionInfo1.isConnected()).thenReturn(false); when(clientSessionInfo2.isConnected()).thenReturn(false);  when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1); when(clientSessionInfo2.getClientId()).thenReturn(CLIENT_ID_2);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") )); sharedSubscriptionCache.put(CLIENT_ID_2, List.of( new TopicSubscription("something", 2, "g1") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_3, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertFalse(anyDeviceClientConnected)
[-] pred: org. junit. Assert. assertFalse ( anyDeviceClientConnected )
************************************
************************************
[+] input: givenConnectedClient_whenCheckIsAnyOtherDeviceClientConnected_thenTrue() { when(clientSessionInfo1.isConnected()).thenReturn(true); when(clientSessionInfo2.isConnected()).thenReturn(false);  when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1); when(clientSessionInfo2.getClientId()).thenReturn(CLIENT_ID_2);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") )); sharedSubscriptionCache.put(CLIENT_ID_2, List.of( new TopicSubscription("something", 2, "g1") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_3, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertTrue(anyDeviceClientConnected)
[-] pred: org. junit. Assert. assertTrue ( anyDeviceClientConnected )
************************************
************************************
[+] input: givenPubMsgWithoutTopicAlias_whenGetTopicNameByAlias_thenNoTopicReturned() { topicAliasCtx = new TopicAliasCtx(true, 5);  MqttProperties properties = new MqttProperties(); PublishMsg publishMsg = PublishMsg.builder().properties(properties).build(); String topicNameByAlias = topicAliasCtx.getTopicNameByAlias(publishMsg);  Assert."<AssertPlaceHolder>"; }
getTopicNameByAlias(PublishMsg publishMsg) { if (enabled) { var receivedTopicName = publishMsg.getTopicName(); var topicAliasProperty = MqttPropertiesUtil.getTopicAliasProperty(publishMsg.getProperties()); if (topicAliasProperty != null) { int topicAlias = topicAliasProperty.value(); validateTopicAlias(topicAlias);  if (receivedTopicName.isEmpty()) { var topicName = getTopicByAlias(topicAlias); if (topicName == null) { throw new MqttException(UNKNOWN_TOPIC_ALIAS_MSG); } else { return topicName; } } else { saveMapping(topicAlias, receivedTopicName); return receivedTopicName; } } } return null; }
[*] target: assertNull(topicNameByAlias)
[-] pred: org. junit. Assert. assertNull ( topicNameByAlias )
************************************
************************************
[+] input: givenMaxAliasesReached_whenGetNextTopicAlias_thenDoNotReturnNewAlias() { topicAliasCtx = new TopicAliasCtx(true, 2, new ConcurrentHashMap<>(Map.of(1, "1", 2, "2")), new ConcurrentHashMap<>());  int topicAlias = topicAliasCtx.getNextTopicAlias("test/topic/1"); Assert."<AssertPlaceHolder>"; }
getNextTopicAlias(String topicName) { if (isMoreTopicAliasAvailable()) { int lastTopicAlias = serverMappings.size(); int nextTopicAlias = lastTopicAlias + 1; serverMappings.put(topicName, nextTopicAlias); return nextTopicAlias; } return 0; }
[*] target: assertEquals(0, topicAlias)
[-] pred: org. junit. Assert. assertEquals ( 0, topicAlias )
************************************
************************************
[+] input: givenMaxAliasesNotReached_whenGetNextTopicAlias_thenReturnNewAlias() { topicAliasCtx = new TopicAliasCtx(true, 2, new ConcurrentHashMap<>(), new ConcurrentHashMap<>(Map.of("1", 1)));  int topicAlias = topicAliasCtx.getNextTopicAlias("test/topic/1"); Assert."<AssertPlaceHolder>"; }
getNextTopicAlias(String topicName) { if (isMoreTopicAliasAvailable()) { int lastTopicAlias = serverMappings.size(); int nextTopicAlias = lastTopicAlias + 1; serverMappings.put(topicName, nextTopicAlias); return nextTopicAlias; } return 0; }
[*] target: assertEquals(2, topicAlias)
[-] pred: org. junit. Assert. assertEquals ( 2, topicAlias )
************************************
************************************
[+] input: testCleanUpBySize() { int maxPersistedMessages = 10;  deviceMsgCleanUpDao.cleanUpBySize(maxPersistedMessages);  List<DevicePublishMsgEntity> remainingMessages = deviceMsgRepository.findAll(); Assert."<AssertPlaceHolder>";  for (int i = 0; i < maxPersistedMessages; i++) { Assert.assertEquals(i + 10, remainingMessages.get(i).getSerialNumber().intValue()); } }
cleanUpBySize(int maxPersistedMessages) { if (maxPersistedMessages <= 0) { log.error("Only positive numbers are allowed."); return; } log.trace("Cleaning up device publish messages to match max size {}.", maxPersistedMessages);  Page<DeviceSessionCtxEntity> deviceSessionCtxEntities; int pageCounter = 0; do { deviceSessionCtxEntities = deviceSessionCtxRepository.findAll(PageRequest.of(pageCounter++, sessionCtxPageSize)); for (DeviceSessionCtxEntity deviceSessionCtxEntity : deviceSessionCtxEntities) { String clientId = deviceSessionCtxEntity.getClientId(); DevicePublishMsgEntity earliestPersistedMsg = deviceMsgRepository.findEntityByClientIdAfterOffset(clientId, maxPersistedMessages - 1); if (earliestPersistedMsg == null) { log.trace("[{}] No messages to clean up.", clientId); } else { log.trace("[{}] Clearing messages with serial number less than {}.", clientId, earliestPersistedMsg.getSerialNumber()); int removed = deviceMsgRepository.removeAllByClientIdAndSerialNumberLessThan(clientId, earliestPersistedMsg.getSerialNumber()); log.debug("[{}] Removed {} messages.", clientId, removed); } } } while (!deviceSessionCtxEntities.isLast());  }
[*] target: assertEquals(maxPersistedMessages, remainingMessages.size())
[-] pred: org. junit. Assert. assertEquals ( maxPersistedMessages, remainingMessages. size ( ) )
************************************
************************************
[+] input: testFindUserById() { User user = userService.findUserByEmail("sysadmin@thingsboard.org"); Assert.assertNotNull(user); User foundUser = userService.findUserById(user.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(user, foundUser); }
findUserById(UUID userId);
[*] target: assertNotNull(foundUser)
[-] pred: org. junit. Assert. assertNotNull ( foundUser )
************************************
************************************
[+] input: testFindUserCredentials() { User user = userService.findUserByEmail("sysadmin@thingsboard.org"); Assert.assertNotNull(user); UserCredentials userCredentials = userService.findUserCredentialsByUserId(user.getId()); Assert."<AssertPlaceHolder>"; }
findUserCredentialsByUserId(UUID userId);
[*] target: assertNotNull(userCredentials)
[-] pred: org. junit. Assert. assertNotNull ( userCredentials )
************************************
************************************
[+] input: Exception { String base64QrCodeContent = "BTkCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkIjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABNJzYWx0eXJ0Yy5leGFtcGxlLm9yZw==";  QRCodeParser service = new QRCodeParserImpl(); QRCodeParser.Result result = service.parse(Base64.decode(base64QrCodeContent)); "<AssertPlaceHolder>"; assertEquals("saltyrtc.example.org", result.saltyRtcHost); assertEquals(1234, result.saltyRtcPort); assertEquals(true, result.isPermanent); assertTrue(Arrays.equals(result.authToken, new byte[]{ 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35 })); assertTrue(Arrays.equals(result.key, new byte[]{ 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66 }));  //no server key assertNull(result.serverKey); }
parse(@Nullable byte[] payload) throws InvalidQrCodeException {  if(payload == null) { throw new InvalidQrCodeException("invalid payload string"); }  int fixedLength = PROTOCOL_VERSION_LENGTH + OPTIONS_LENGTH + KEY_LENGTH + AUTH_TOKEN_LENGTH + SERVER_KEY_LENGTH + SALTY_RTC_PORT_LENGTH ;  if(payload.length < fixedLength+1) { throw new InvalidQrCodeException("invalid payload length"); }  try { ByteArrayInputStream bis = new ByteArrayInputStream(payload);  byte[] protocolVersionBytes = new byte[PROTOCOL_VERSION_LENGTH]; bis.read(protocolVersionBytes);  int protocolVersion = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(protocolVersionBytes).getShort());  byte[] options = new byte[OPTIONS_LENGTH]; bis.read(options);  boolean isSelfHosted = (options[0] & 0x01) != 0; boolean isPermanent = (options[0] & 0x02) != 0;  byte[] key = new byte[KEY_LENGTH]; bis.read(key);  byte[] authToken = new byte[AUTH_TOKEN_LENGTH]; bis.read(authToken);  // Note: Server public key may consist of only 0 bytes if not defined in Threema Web byte[] serverKey = null; byte[] serverKeyTemporary = new byte[SERVER_KEY_LENGTH]; bis.read(serverKeyTemporary); for (byte b : serverKeyTemporary) { if (b != 0) { serverKey = serverKeyTemporary; break; } }  byte[] portBytes = new byte[SALTY_RTC_PORT_LENGTH]; bis.read(portBytes); int port = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(portBytes).getShort());  String host = new String(payload, fixedLength, payload.length - fixedLength);  return new Result( protocolVersion, isSelfHosted, isPermanent, key, authToken, serverKey, port, host); } catch (IOException x) { throw new InvalidQrCodeException("Invalid Threema Web QR code contents"); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testUnsignedLongToBigInteger() { final BigInteger bigInteger = new BigInteger("18446744073709551610"); final long unsignedLong = bigInteger.longValue(); Assert.assertTrue(unsignedLong < 0); final BigInteger bigInteger2 = UnsignedHelper.unsignedLongToBigInteger(unsignedLong); Assert."<AssertPlaceHolder>"; }
unsignedLongToBigInteger(long val) { if (val >= 0L) { return BigInteger.valueOf(val); } else { int upper = (int) (val >>> 32); int lower = (int) val; return (BigInteger.valueOf(Integer.toUnsignedLong(upper))).shiftLeft(32). add(BigInteger.valueOf(Integer.toUnsignedLong(lower))); } }
[*] target: assertEquals(bigInteger, bigInteger2)
[-] pred: org. junit. Assert. assertEquals ( bigInteger, bigInteger2 )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"support":"the-support-url"}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertEquals("the-support-url", result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject .put("username", "u") .put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"logo":{"dark": "the-dark-logo"}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertEquals("the-dark-logo", result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"logo":{"light": "the-light-logo"}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertEquals("the-light-logo", result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn( new PostJsonResult( "{"contacts":[" + "{"id":"id1","pk":"AQ=="}," + "{"id":"id2","pk":"Aq==","first":"id2-firstname"}," + "{"id":"id3","pk":"Aw==","last":"id3-lastname"}," + "{"id":"id4","pk":"BA==","first": "id4-firstname", "last":"id4-lastname"}" + "]}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(4, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size());  // Verify contacts Assert.assertEquals("id1", result.workContacts.get(0).threemaId); Assert.assertArrayEquals(new byte[]{0x01}, result.workContacts.get(0).publicKey); Assert.assertNull(result.workContacts.get(0).firstName); Assert.assertNull(result.workContacts.get(0).lastName);  Assert.assertEquals("id2", result.workContacts.get(1).threemaId); Assert.assertArrayEquals(new byte[]{0x02}, result.workContacts.get(1).publicKey); Assert.assertEquals("id2-firstname", result.workContacts.get(1).firstName); Assert.assertNull(result.workContacts.get(1).lastName);  Assert.assertEquals("id3", result.workContacts.get(2).threemaId); Assert.assertArrayEquals(new byte[]{0x03}, result.workContacts.get(2).publicKey); Assert.assertNull(result.workContacts.get(2).firstName); Assert.assertEquals("id3-lastname", result.workContacts.get(2).lastName);  Assert.assertEquals("id4", result.workContacts.get(3).threemaId); Assert.assertArrayEquals(new byte[]{0x04}, result.workContacts.get(3).publicKey); Assert.assertEquals("id4-firstname", result.workContacts.get(3).firstName); Assert.assertEquals("id4-lastname", result.workContacts.get(3).lastName); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"mdm":{" + ""override": true," + ""params":{" + ""param-string": "string-param"," + ""param-bool": true," + ""param-int": 123" + "}}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertTrue(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(3, result.mdm.parameters.size());  Assert.assertTrue(result.mdm.parameters.containsKey("param-string")); Assert.assertEquals("string-param", result.mdm.parameters.get("param-string")); Assert.assertTrue(result.mdm.parameters.containsKey("param-bool")); Assert.assertEquals(true, result.mdm.parameters.get("param-bool")); Assert.assertTrue(result.mdm.parameters.containsKey("param-int")); Assert.assertEquals(123, result.mdm.parameters.get("param-int")); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  when(connector.fetchIdentity(eq("ERIC4911"))).thenCallRealMethod(); when(connector.doGet(eq("https://server.url/identity/ERIC4911"))) .thenReturn("{" + ""identity": "ERIC4911"," + ""publicKey": "aGVsbG8="," + ""featureLevel": 3," + ""featureMask": 15," + ""state": 1," + ""type": 2" + "}"); APIConnector.FetchIdentityResult result = connector.fetchIdentity("ERIC4911"); Assert."<AssertPlaceHolder>"; Assert.assertEquals("ERIC4911", result.identity); Assert.assertEquals(15, result.featureMask); Assert.assertEquals(1, result.state); Assert.assertEquals(2, result.type); }
fetchIdentity(String identity) throws ThreemaException, NetworkException, HttpConnectionException { try { String responseStr = doGet(getServerUrl() + "identity/" + identity); JSONObject jsonResponse = new JSONObject(responseStr);  FetchIdentityResult result = new FetchIdentityResult(); result.publicKey = Base64.decode(jsonResponse.getString("publicKey")); result.featureLevel = jsonResponse.optInt("featureLevel"); result.featureMask = jsonResponse.optInt("featureMask"); result.identity = jsonResponse.getString("identity"); result.state = jsonResponse.optInt("state"); result.type = jsonResponse.optInt("type"); return result; } catch (JSONException | IOException e) { throw new NetworkException(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock(); final IdentityStoreInterface identityStore = getIdentityStoreInterfaceMock();  when(identityStore.getIdentity()).thenReturn("FOOBAR12"); when(identityStore.calcSharedSecret(any())).thenReturn(new byte[32]); System.out.println(identityStore.getIdentity()); when(connector.obtainTurnServers(eq(identityStore), eq("voip"))).thenCallRealMethod(); when(connector.postJson(eq("https://server.url/identity/turn_cred"), ArgumentMatchers.any())) .thenReturn("{" + ""token": "/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="," + ""tokenRespKeyPub": "dummy"" + "}") .thenReturn("{" + ""success": true," + ""turnUrls": ["turn:foo", "turn:bar"]," + ""turnUrlsDualStack": ["turn:ds-foo", "turn:ds-bar"]," + ""turnUsername": "s00perturnuser"," + ""turnPassword": "t0psecret"," + ""expiration": 86400" + "}");  APIConnector.TurnServerInfo result = connector.obtainTurnServers(identityStore, "voip"); Assert."<AssertPlaceHolder>"; Assert.assertArrayEquals(new String[] {"turn:foo", "turn:bar"}, result.turnUrls); Assert.assertArrayEquals(new String[] {"turn:ds-foo", "turn:ds-bar"}, result.turnUrlsDualStack); Assert.assertEquals("s00perturnuser", result.turnUsername); Assert.assertEquals("t0psecret", result.turnPassword);  Date expectedExpirationDate = new Date(new Date().getTime() + 86400*1000); Assert.assertTrue(Math.abs(expectedExpirationDate.getTime() - result.expirationDate.getTime()) < 10000); }
obtainTurnServers(IdentityStoreInterface identityStore, String type) throws Exception { if (identityStore == null || identityStore.getIdentity() == null || identityStore.getIdentity().isEmpty()) { return null; }  String url = getServerUrl() + "identity/turn_cred";  // Phase 1: send identity and type JSONObject request = new JSONObject(); request.put("identity", identityStore.getIdentity()); request.put("type", type);  logger.debug("Obtain TURN servers phase 1: sending to server: {}", request); JSONObject p1Result = new JSONObject(this.postJson(url, request)); logger.debug("Obtain TURN servers phase 1: response from server: {}", p1Result);  makeTokenResponse(p1Result, request, identityStore);  // Phase 2: send token response logger.debug("Obtain TURN servers phase 2: sending to server: {}", request); JSONObject p2Result = new JSONObject(this.postJson(url, request)); logger.debug("Obtain TURN servers phase 2: response from server: {}", p2Result);  if (!p2Result.getBoolean("success")) { throw new ThreemaException(p2Result.getString("error")); }  String[] turnUrls = jsonArrayToStringArray(p2Result.getJSONArray("turnUrls")); String[] turnUrlsDualStack = jsonArrayToStringArray(p2Result.getJSONArray("turnUrlsDualStack")); String turnUsername = p2Result.getString("turnUsername"); String turnPassword = p2Result.getString("turnPassword"); int expiration = p2Result.getInt("expiration"); Date expirationDate = new Date(new Date().getTime() + expiration * 1000L);  return new TurnServerInfo(turnUrls, turnUrlsDualStack, turnUsername, turnPassword, expirationDate); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"org":{" + ""name": "monkeybusiness"" + "}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertEquals("monkeybusiness", result.organization.name);  }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertNull(result.organization.name);  }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{" + "directory:{" + "enabled: true," + "cat: {" + ""c1": "Category 1"," + ""c2": "Category 2"," + ""c3": "Category 3"" + "}}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertNull(result.organization.name); Assert.assertTrue(result.directory.enabled); Assert.assertNotNull(result.directory.categories); Assert.assertEquals(3, result.directory.categories.size());  boolean c1 = false; boolean c2 = false; boolean c3 = false;  for(WorkDirectoryCategory c: result.directory.categories) { switch (c.id) { case "c1": Assert.assertFalse("c1 already found", c1); c1 = true; Assert.assertEquals("Category 1", c.name); break; case "c2": Assert.assertFalse("c1 already found", c2); c2 = true; Assert.assertEquals("Category 2", c.name); break; case "c3": Assert.assertFalse("c1 already found", c3); c3 = true; Assert.assertEquals("Category 3", c.name); break; default: Assert.fail("Invalid category " + c.id); } } }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); final IdentityStoreInterface identityStore = getIdentityStoreInterfaceMock(); when(identityStore.getIdentity()).thenReturn("IDENTITY"); JSONObject requiredObject = new JSONObject(); requiredObject .put("username", "u") .put("password", "eric") .put("identity", "IDENTITY") .put("query", "Query String") .put("categories", (new JSONArray()).put("c100")) .put("sort", (new JSONObject()) .put("asc", true) .put("by", "firstName")) .put("page", 1);  when(connector.fetchWorkDirectory(any(), any(), any(), any())).thenCallRealMethod(); when(connector.postJson( eq("https://api-work.threema.ch/directory"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn( "{\n" + "   "contacts": [\n" + "      {\n" + "         "id": "ECHOECHO",\n" + "         "pk": "base64",\n" + "         "first": "Hans",\n" + "         "last": "Nötig",\n" + "         "csi": "CSI_NR",\n" + "         "org": { "name": "Name der Firma/Organisation" },\n" + "         "cat": [\n" + "            "catId1",\n" + "            "catId2"\n" + "         ]\n" + "      }\n" + "   ],\n" + "   "paging": {\n" + "      "size": 10,\n" + "      "total": 8923,\n" + "      "next": 2,\n" + "      "prev": 0\n" + "   }\n" + "}" );  WorkDirectoryFilter filter = new WorkDirectoryFilter(); filter.addCategory(new WorkDirectoryCategory("c100", "Category 100")); filter.query("Query String"); filter.page(1); WorkDirectory result = connector.fetchWorkDirectory("u", "eric", identityStore, filter);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, result.workContacts.size()); Assert.assertEquals("ECHOECHO", result.workContacts.get(0).threemaId); Assert.assertEquals("Hans", result.workContacts.get(0).firstName); Assert.assertEquals("Nötig", result.workContacts.get(0).lastName); Assert.assertEquals("CSI_NR", result.workContacts.get(0).csi); Assert.assertEquals("Name der Firma/Organisation", result.workContacts.get(0).organization.name); Assert.assertEquals(2, result.workContacts.get(0).categoryIds.size()); Assert.assertEquals("catId1", result.workContacts.get(0).categoryIds.get(0)); Assert.assertEquals("catId2", result.workContacts.get(0).categoryIds.get(1)); Assert.assertEquals(10, result.pageSize); Assert.assertEquals(8923, result.totalRecord); Assert.assertEquals(2, result.nextFilter.getPage()); Assert.assertEquals(filter.getQuery(), result.nextFilter.getQuery()); Assert.assertEquals(filter.getCategories(), result.nextFilter.getCategories()); Assert.assertEquals(0, result.previousFilter.getPage()); Assert.assertEquals(filter.getQuery(), result.previousFilter.getQuery()); Assert.assertEquals(filter.getCategories(), result.previousFilter.getCategories()); }
fetchWorkDirectory( @NonNull String username, @NonNull String password, @NonNull IdentityStoreInterface identityStore, @NonNull WorkDirectoryFilter filter ) throws Exception { JSONObject request = new JSONObject(); request.put("username", username); request.put("password", password); request.put("identity", identityStore.getIdentity()); request.put("query", filter.getQuery());  // Filter category if (filter.getCategories() != null && filter.getCategories().size() > 0) { JSONArray jsonCategories = new JSONArray(); for (WorkDirectoryCategory category: filter.getCategories()) { jsonCategories.put(category.id); } request.put("categories", jsonCategories); }  // Sorting JSONObject jsonSort = new JSONObject();  jsonSort.put("asc", filter.isSortAscending()); //noinspection SwitchStatementWithTooFewBranches switch (filter.getSortBy()) { case WorkDirectoryFilter.SORT_BY_LAST_NAME: jsonSort.put("by", "lastName"); break; default: jsonSort.put("by", "firstName"); break; }  request.put("sort", jsonSort);  // Paging request.put("page", filter.getPage());  String data = this.postJson(getWorkServerUrl() + "directory", request);  // Verify request if (data == null || data.length() == 0) { return null; }  JSONObject jsonResponse = new JSONObject(data);  if (jsonResponse.has("contacts") && !jsonResponse.isNull("contacts")) {  // Verify content JSONArray contacts = jsonResponse.getJSONArray("contacts");  int total = contacts.length(); int pageSize = total; WorkDirectoryFilter filterNext = null; WorkDirectoryFilter filterPrevious = null;  if (jsonResponse.has("paging") && !jsonResponse.isNull("paging")) { JSONObject paging = jsonResponse.getJSONObject("paging");  pageSize = paging.optInt("size", pageSize); total = paging.optInt("total", total); if (paging.has("next")) { // Next filter filterNext = filter.copy() .page(jsonResponse.optInt("next", filter.getPage() + 1)); } if (paging.has("prev")) { // Next filter filterPrevious = filter.copy() .page(jsonResponse.optInt("prev", filter.getPage() - 1)); } }  WorkDirectory workDirectory = new WorkDirectory( total, pageSize, filter, filterNext, filterPrevious );  for (int n = 0; n < contacts.length(); n++) { JSONObject contact = contacts.getJSONObject(n);  //validate fields if (contact.has("id") && contact.has("pk")) { WorkDirectoryContact directoryContact = new WorkDirectoryContact( contact.getString("id"), Base64.decode(contact.getString("pk")), contact.has("first") ? (contact.isNull("first") ? null : contact.optString("first")) : null, contact.has("last") ? (contact.isNull("last") ? null : contact.optString("last")) : null, contact.has("csi") ? (contact.isNull("csi") ? null : contact.optString("csi")) : null );  if (!contact.isNull("org")) { JSONObject jsonResponseOrganization = contact.optJSONObject("org");  if (jsonResponseOrganization != null && !jsonResponseOrganization.isNull("name")) { directoryContact.organization.name = jsonResponseOrganization.optString("name"); } }  JSONArray categoryArray = contact.optJSONArray("cat"); if (categoryArray != null) { for (int cN = 0; cN < categoryArray.length(); cN++) { directoryContact.categoryIds.add(categoryArray.getString(cN)); } }  workDirectory.workContacts.add(directoryContact); } }  return workDirectory; }  // Invalid request return null;  }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: JSONException { final JSONObject o = new JSONObject(); final FeatureList list = FeatureList.parse(o); Assert."<AssertPlaceHolder>"; }
isEmpty() { return this.features.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty ( ) )
************************************
************************************
[+] input: testLabelTreeKeyRegressionShare_sharedNodesShouldBeEqual() { int depth = 20; int from = 2000; int to = 3000; IPRF aesni = PRFFactory.getDefaultPRF(); TreeKeyRegression reg = (TreeKeyRegression) TreeKeyRegressionFactory.getNewDefaultTESTKeyRegression(aesni, depth); LabelTreeKeyRegression reg2 = new LabelTreeKeyRegression(aesni, depth, new byte[16]); ArrayList<SeedNode> nodes = reg.revealSeeds(from, to); List<SeedNode> nodes2 = reg2.constrainNodes(from, to + 1);  for (SeedNode tn : nodes2) { boolean ok = false; for (SeedNode sn : nodes) { if (Arrays.equals(sn.getSeed(), tn.getSeed())) { ok = true; break; } } "<AssertPlaceHolder>"; } }
revealSeeds(long from, long to) { assert isOwner; ArrayList<SeedNode> seedNodes = new ArrayList<SeedNode>(); if (from > to || rootSeed == null) throw new RuntimeException(String.format("%d is not smaller than %d", from, to)); for (int d = depth; d >= 0; d--) { for (int i = 0; i < kFactor - 1; i++) { if (from == to) { TreeKeyRegressionNode node = reveal(d, from); if (!seedNodes.contains(node)) seedNodes.add(node); } if (from % kFactor != 0) { TreeKeyRegressionNode node = reveal(d, from); if (!seedNodes.contains(node)) seedNodes.add(node); from++; } if (to % kFactor != kFactor - 1) { TreeKeyRegressionNode node = reveal(d, to); if (!seedNodes.contains(node)) seedNodes.add(node); to--; } if (from > to) { break; } } if (from > to) { break; } from /= kFactor; to /= kFactor; } sortNodeArray(seedNodes); return seedNodes; }
[*] target: assertTrue(ok)
[-] pred: org. junit. Assert. assertTrue ( ok )
************************************
************************************
[+] input: DecodingException { AlfenSignatureVerifier verifier = new AlfenSignatureVerifier(); AlfenReader reader = new AlfenReader(); AlfenSignature signature = reader.parseString(ALFEN_TEST_STRING); String publicKey = signature.getPublicKey();  boolean result = verifier.verify(EncodingType.base32Decode(publicKey), signature.getSignature(), signature.getDataset()); Assert."<AssertPlaceHolder>"; }
verify(byte[] publicKey, byte[] signature, byte[] payloadData) throws ValidationException { ECDSASigner signer = new ECDSASigner(); X9ECParameters ecParameters = SECNamedCurves.getByName(ELLIPTIC_CURVE_ALGORITHM); ECCurve curve = ecParameters.getCurve();  //create the public key paramters for init of the signing lib ECDomainParameters ecDomainParameters = new ECDomainParameters(curve, ecParameters.getG(), ecParameters.getN(), ecParameters.getH(), ecParameters.getSeed()); ECPublicKeyParameters publicKeyParsed; try { publicKeyParsed = new ECPublicKeyParameters(curve.decodePoint(publicKey), ecDomainParameters); } catch (IllegalArgumentException e) { LOGGER.error("Invalid point given for public key", e); //is thrown if point is not valid e.g. not on curve throw new ValidationException("Invalid public key point given", "error.invalid.public.key"); }  if (signature.length != SIGNATURE_LENGTH) { throw new ValidationException("Invalid length of signature given", "error.invalid.signature.length"); } //verify the signature divided in two coordinates, r and s BigInteger signatureR = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 0, 24)); BigInteger signatureS = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 24, 24));  byte[] hashedData = Utils.hashSHA256(payloadData);  signer.init(false, publicKeyParsed); boolean verify = signer.verifySignature(hashedData, signatureR, signatureS); VerificationLogger.log("ALFEN", ELLIPTIC_CURVE_ALGORITHM, publicKey, hashedData, signature, verify); return verify;  }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: DecodingException { AlfenSignatureVerifier verifier = new AlfenSignatureVerifier(); AlfenReader reader = new AlfenReader(); AlfenSignature signature = reader.parseString(ALFEN_TEST_STRING_2); boolean result = verifier.verify(EncodingType.base32Decode(signature.getPublicKey()), signature.getSignature(), signature.getDataset()); Assert."<AssertPlaceHolder>"; }
verify(byte[] publicKey, byte[] signature, byte[] payloadData) throws ValidationException { ECDSASigner signer = new ECDSASigner(); X9ECParameters ecParameters = SECNamedCurves.getByName(ELLIPTIC_CURVE_ALGORITHM); ECCurve curve = ecParameters.getCurve();  //create the public key paramters for init of the signing lib ECDomainParameters ecDomainParameters = new ECDomainParameters(curve, ecParameters.getG(), ecParameters.getN(), ecParameters.getH(), ecParameters.getSeed()); ECPublicKeyParameters publicKeyParsed; try { publicKeyParsed = new ECPublicKeyParameters(curve.decodePoint(publicKey), ecDomainParameters); } catch (IllegalArgumentException e) { LOGGER.error("Invalid point given for public key", e); //is thrown if point is not valid e.g. not on curve throw new ValidationException("Invalid public key point given", "error.invalid.public.key"); }  if (signature.length != SIGNATURE_LENGTH) { throw new ValidationException("Invalid length of signature given", "error.invalid.signature.length"); } //verify the signature divided in two coordinates, r and s BigInteger signatureR = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 0, 24)); BigInteger signatureS = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 24, 24));  byte[] hashedData = Utils.hashSHA256(payloadData);  signer.init(false, publicKeyParsed); boolean verify = signer.verifySignature(hashedData, signatureR, signatureS); VerificationLogger.log("ALFEN", ELLIPTIC_CURVE_ALGORITHM, publicKey, hashedData, signature, verify); return verify;  }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: DecodingException { SMLReader smlReader = new SMLReader(); SMLSignature signature = smlReader.parsePayloadData(EncodingType.BASE64.decode(SML_DATA_FULL_NEW)); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(signature.getProvidedSignature()); Assert.assertEquals(2918, signature.getMeterPositionAsLong()); Assert.assertEquals("09 01 45 4D 48 00 00 7A C6 62", Utils.toFormattedHex(signature.getServerId())); Assert.assertEquals(65, new BigInteger(Utils.reverseByteOrder(signature.getPagination())).intValue()); Assert.assertEquals(340285, new BigInteger(Utils.reverseByteOrder(signature.getSecondsIndex())).intValue()); Assert.assertEquals(10, new BigInteger(signature.getBytesLog()).intValue()); Assert.assertEquals(8, new BigInteger(new byte[]{signature.getStatus()}).intValue());  LocalDateTime dateTime = LocalDateTime.of(2018, Month.AUGUST, 28, 18, 57, 37); OffsetDateTime offsetDateTime = OffsetDateTime.of(dateTime, ZoneOffset.of("+02:00")); Assert.assertEquals(offsetDateTime, signature.getTimestampAsDate());   }
parsePayloadData(byte[] smlData) throws ValidationException { try { final SMLSignature smlSignature = parseRawSMLBytes(smlData); if (smlSignature == null) { throw new SMLValidationException("Could not read sml data incomplete data", "error.sml.incomplete"); } // will throw an sml validation exception if check fails smlSignature.isDataComplete();  if (smlSignature.getUnit() != 30) { throw new SMLValidationException("Invalid unit present in sml data", "error.sml.invalid.unit"); } return smlSignature; } catch (final IOException e) { throw new SMLValidationException("Could not read sml data, invalid format", e); }  }
[*] target: assertNotNull(signature)
[-] pred: org. junit. Assert. assertNotNull ( signature )
************************************
************************************
[+] input: DecodingException { SMLReader smlReader = new SMLReader(); SMLSignature signature = smlReader.parsePayloadData(EncodingType.BASE64.decode(SML_DATA_TECHNAGON)); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(signature.getProvidedSignature()); Assert.assertEquals(46201, signature.getMeterPositionAsLong()); Assert.assertEquals("09 01 45 4D 48 00 00 7F 92 03", Utils.toFormattedHex(signature.getServerId())); Assert.assertEquals(14, new BigInteger(Utils.reverseByteOrder(signature.getPagination())).intValue()); Assert.assertEquals(83696, new BigInteger(Utils.reverseByteOrder(signature.getSecondsIndex())).intValue()); Assert.assertEquals(59, new BigInteger(signature.getBytesLog()).intValue()); Assert.assertEquals(8, new BigInteger(new byte[]{signature.getStatus()}).intValue());  LocalDateTime dateTime = LocalDateTime.of(2017, Month.NOVEMBER, 23, 15, 13, 07); OffsetDateTime offsetDateTime = OffsetDateTime.of(dateTime, ZoneOffset.of("+00:00")); Assert.assertEquals(offsetDateTime, signature.getTimestampAsDate());   }
parsePayloadData(byte[] smlData) throws ValidationException { try { final SMLSignature smlSignature = parseRawSMLBytes(smlData); if (smlSignature == null) { throw new SMLValidationException("Could not read sml data incomplete data", "error.sml.incomplete"); } // will throw an sml validation exception if check fails smlSignature.isDataComplete();  if (smlSignature.getUnit() != 30) { throw new SMLValidationException("Invalid unit present in sml data", "error.sml.invalid.unit"); } return smlSignature; } catch (final IOException e) { throw new SMLValidationException("Could not read sml data, invalid format", e); }  }
[*] target: assertNotNull(signature)
[-] pred: org. junit. Assert. assertNotNull ( signature )
************************************
************************************
[+] input: test_read_public_key() { final SignatureOnlyVerificationParser parser = new SignatureOnlyVerificationParser(); final String s = parser.parsePublicKey(TestUtils.TEST_SIG_ONLY); Assert."<AssertPlaceHolder>"; }
parsePublicKey(String data) { try { final SignedMeterValue signedMeterValue = smlReader.readFromString(Utils.unescapeXML(data)); return signedMeterValue.getPublicKey() != null ? signedMeterValue.getPublicKey().getCleanedValue() : null; } catch (final ValidationException e) { return null; } }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: InterruptedException {  long second = Instant.parse("2021-12-31T23:59:59.000Z").getEpochSecond(); long leapSecond = second - 1; // simulate a leap second long times[] = { second, leapSecond };  Clock clock = new Clock() { private int i;  @Override public long millis() { return times[i++ % times.length] * 1000; }  @Override public ZoneId getZone() { return null; }  @Override public Clock withZone(ZoneId zone) { return null; }  @Override public Instant instant() { return null; } };  // a function that forces the clock to restart to ZERO IntFunction<byte[]> randomFunction = x -> new byte[x];  TsidFactory factory = TsidFactory.builder().withClock(clock).withRandomFunction(randomFunction).build();  long ms1 = factory.create().getUnixMilliseconds(); // second long ms2 = factory.create().getUnixMilliseconds(); // leap second  "<AssertPlaceHolder>"; // LEAP SECOND! DON'T MOVE BACKWARDS! }
create() { lock.lock(); try { final long _time = getTime() << RANDOM_BITS; final long _node = (long) this.node << this.counterBits; final long _counter = (long) this.counter & this.counterMask;  return new Tsid(_time | _node | _counter); } finally { lock.unlock(); } }
[*] target: assertEquals(ms1, ms2)
[-] pred: org. junit. Assert. assertEquals ( ms1, ms2 )
************************************
************************************
[+] input: testToString() { for (int i = 0; i < LOOP_MAX; i++) { final long number = ThreadLocalRandom.current().nextLong(); final String string0 = toString(number); final String string1 = Tsid.from(number).toString(); "<AssertPlaceHolder>"; } }
toString() { return toString(ALPHABET_UPPERCASE); }
[*] target: assertEquals(string0, string1)
[-] pred: org. junit. Assert. assertEquals ( string0, string1 )
************************************
************************************
[+] input: checkOutgoingAccess() { FlowElement exclusiveGateway= EntityBuilder.buildExclusiveGateway(); FlowElement outgoningSequence = EntityBuilder.buildSequenceFlow2(); FlowElement outgoningSequence1 = EntityBuilder.buildSequenceFlow3(); Map<String, FlowElement> map = new HashMap<>(); map.put(exclusiveGateway.getKey(), exclusiveGateway); map.put(outgoningSequence.getKey(), outgoningSequence); map.put(outgoningSequence1.getKey(), outgoningSequence1); boolean access = false; try { exclusiveGatewayValidator.checkOutgoing(map, exclusiveGateway); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { List<String> outgoing = flowElement.getOutgoing();  if (CollectionUtils.isEmpty(outgoing)) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_LACK_OUTGOING); }  List<String> outgoingList = flowElement.getOutgoing(); int defaultConditionCount = 0;  for (String outgoingKey : outgoingList) { FlowElement outgoingSequenceFlow = FlowModelUtil.getFlowElement(flowElementMap, outgoingKey);  String condition = FlowModelUtil.getConditionFromSequenceFlow(outgoingSequenceFlow); boolean isDefaultCondition = FlowModelUtil.isDefaultCondition(outgoingSequenceFlow);  if (StringUtils.isBlank(condition) && !isDefaultCondition) { throwElementValidatorException(flowElement, ErrorEnum.EMPTY_SEQUENCE_OUTGOING); } if (isDefaultCondition) { defaultConditionCount++; } }  if (defaultConditionCount > 1) { throwElementValidatorException(flowElement, ErrorEnum.TOO_MANY_DEFAULT_SEQUENCE); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: validateElementKeyNotUnique() { List<FlowElement> flowElementsList = EntityBuilder.buildFlowElementList(); SequenceFlow sequenceFlow1 = new SequenceFlow(); sequenceFlow1.setKey("sequenceFlow1"); sequenceFlow1.setType(FlowElementType.SEQUENCE_FLOW); List<String> sfIncomings = new ArrayList<>(); sfIncomings.add("startEvent1"); sequenceFlow1.setIncoming(sfIncomings); List<String> sfOutgoings = new ArrayList<>(); sfOutgoings.add("userTask1"); sequenceFlow1.setOutgoing(sfOutgoings); flowElementsList.add(sequenceFlow1); FlowModel flowModel = new FlowModel(); flowModel.setFlowElementList(flowElementsList); boolean access = false; try { flowModelValidator.validate(flowModel); access = true; Assert."<AssertPlaceHolder>"; } catch (ProcessException e) { LOGGER.error("", e); Assert.assertFalse(access); } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
validate(FlowModel flowModel) throws ProcessException, DefinitionException { this.validate(flowModel, null); }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: validateAccess() { String modelStr = EntityBuilder.buildModelStringAccess(); boolean access = false; try { modelValidator.validate(modelStr); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } catch (ProcessException e) { LOGGER.error("", e); Assert.assertTrue(access); }   }
validate(String flowModelStr) throws DefinitionException, ProcessException { this.validate(flowModelStr, null); }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: checkIncomingAccess() { FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkIncoming(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkIncoming(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkIncoming(flowElementMap, flowElement);  List<String> incomingList = flowElement.getIncoming(); if (incomingList.size() >1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_INCOMING); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: checkOutgoingAccess() {  FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkOutgoing(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkOutgoing(flowElementMap, flowElement);  List<String> outgoingList = flowElement.getOutgoing(); if (outgoingList.size() > 1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_OUTGOING); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: regexPreprocessorTest() { RegexPreprocessor rpp = new RegexPreprocessor("^.*(fakebook\\.com.*)/$", "$1"); String test = "https://www.fakebook.com/personOne/"; String res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "www.fakebook.com/personOne/"; res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "fakebook.com/personOne/"; res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "personOne/"; res = "personOne/"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "insertedWithoutAppliedRegex"; res = "insertedWithoutAppliedRegex"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = ""; res = ""; Assert."<AssertPlaceHolder>"; }
applyProcessor(String value) { return value.replaceAll(match, replace); }
[*] target: assertEquals(res, rpp.applyProcessor(test))
[-] pred: org. junit. Assert. assertEquals ( res, rpp. applyProcessor( test ) )
************************************
************************************
[+] input: testPolymorphicDifference2() { VariableSet pDiff2 = VariableSet.polymorphicDifference2(fA, fB);  // everything in pDiff2 must be in A assertTrue(fA.containsAll(pDiff2));  // the normal difference is a subset of the second polymorphic difference // (it removes everything a normal difference would + possibly some more) // we want to take a look everything that gets only removed by the // second polymorphic difference  VariableSet diff = VariableSet.difference(fA, fB); VariableSet pDiffExcl = VariableSet.difference(diff, pDiff2);  // for each element in pDiffExcl the following must hold: // - element of A // - not element of B // - B has a variable with that name // - one of its types must be a subtype of the current elements type for (String name : pDiffExcl.getNames()) { for (Type type : pDiffExcl.getTypes(name)) { assertTrue(fA.contains(name, type)); assertFalse(fB.contains(name, type)); assertTrue(fB.contains(name)); boolean containsSubType = false; for (Type otherType : fB.getTypes(name)) { if (otherType.conformsTo(type)) { containsSubType = true; break; } } "<AssertPlaceHolder>"; } } }
getTypes(String name) { return fEntries.get(name); }
[*] target: assertTrue(containsSubType)
[-] pred: org. junit. Assert. assertTrue ( containsSubType )
************************************
************************************
[+] input: Exception { byte[] bytes = new byte[64]; bytes[0] = 15; Node nearNode = new Node(bytes, "127.0.0.19", 18888, 18888); bytes[0] = 70; Node farNode = new Node(bytes, "127.0.0.20", 18888, 18888); nodeTable.addNode(nearNode); nodeTable.addNode(farNode); for (int i = 0; i < KademliaOptions.BUCKET_SIZE - 1; i++) { //To control totally 17 nodes, however closest's capacity is 16 nodeTable.addNode(new Node(ids.get(i), ips[i], 18888, 18888)); TimeUnit.MILLISECONDS.sleep(10); } Assert.assertTrue(nodeTable.getBucketsCount() > 1); //3 buckets, nearnode's distance is 252, far's is 255, others' are 253 List<Node> closest = nodeTable.getClosestNodes(homeNode.getId()); Assert."<AssertPlaceHolder>"; //the farest node should be excluded }
contains(Node n) { NodeEntry e = new NodeEntry(node.getId(), n); for (NodeBucket b : buckets) { if (b.getNodes().contains(e)) { return true; } } return false; }
[*] target: assertTrue(closest.contains(nearNode))
[-] pred: org. junit. Assert. assertTrue ( closest. contains ( nearNode ) )
************************************
************************************
[+] input: InterruptedException { Node node1 = Node.instanceOf("127.0.0.1:10001"); NodeEntry ne1 = new NodeEntry(node1); Thread.sleep(1); Node node2 = Node.instanceOf("127.0.0.1:10002"); NodeEntry ne2 = new NodeEntry(node2); TimeComparator tc = new TimeComparator(); int result = tc.compare(ne1, ne2); Assert."<AssertPlaceHolder>";  }
compare(NodeEntry e1, NodeEntry e2) { long t1 = e1.getModified(); long t2 = e2.getModified();  if (t1 < t2) { return 1; } else if (t1 > t2) { return -1; } else { return 0; } }
[*] target: assertEquals(1, result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: JSONException { OpenWeatherMapSource source = new OpenWeatherMapSource(context); Location location = new SimpleLocation("lat=54.96&lon=73.38", true); JSONObject json = source.queryCurrentWeather(location); "<AssertPlaceHolder>"; assertEquals("Omsk", json.getString("name")); }
queryCurrentWeather(Location location) throws WeatherException { String url = getWeatherUrl(location); return queryJSON(url); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: JSONException { OpenWeatherMapSource source = new OpenWeatherMapSource(context); Location location = new SimpleLocation("q=omsk", false); JSONObject json = source.queryCurrentWeather(location); "<AssertPlaceHolder>"; assertEquals("Omsk", json.getString("name")); }
queryCurrentWeather(Location location) throws WeatherException { String url = getWeatherUrl(location); return queryJSON(url); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: WeatherException { JSONTokener parser = new JSONTokener("{ "cod": "404"}"); OpenWeatherMapWeather weather = new OpenWeatherMapWeather(context, (JSONObject)parser.nextValue()); //        assertNotNull(weather); //        "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertTrue(weather.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( weather. isEmpty() )
************************************
************************************
[+] input: testNotNullLocation() { OpenWeatherMapWeather weather = new OpenWeatherMapWeather(context); assertNotNull(weather.getLocation()); "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertTrue(weather.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( weather. isEmpty() )
************************************
************************************
[+] input: Exception { OpenWeatherMapWeather weather = WeatherUtils.createIncompleteOpenWeather(context); assertNotNull(weather); "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertFalse(weather.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( weather. isEmpty() )
************************************
************************************
[+] input: Exception { OpenWeatherMapWeather weather = WeatherUtils.createIncompleteOpenWeather(context); Location location = weather.getLocation(); assertNotNull(location); "<AssertPlaceHolder>"; assertEquals("Omsk", location.getText()); // geo coordinates are taken from the response assertTrue(location.isGeo()); assertEquals("lat=55.0&lon=73.4", location.getQuery()); }
isEmpty() { return this.empty; }
[*] target: assertFalse(location.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( location. isEmpty() )
************************************
************************************
[+] input: test2() { List<MahjongTileDef> mahjongInHand = List.of( MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._4_TIAO, MahjongTileDef._6_TIAO, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._4_BING, MahjongTileDef._4_BING, MahjongTileDef._4_BING, MahjongTileDef._5_BING, MahjongTileDef._5_BING );  boolean canHu = HuFormula.test( mahjongInHand, MahjongTileDef._5_TIAO );  Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: test3() { List<MahjongTileDef> mahjongInHand = List.of( MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._5_WAN, MahjongTileDef._1_TIAO, MahjongTileDef._2_TIAO, MahjongTileDef._3_TIAO, MahjongTileDef._4_TIAO, MahjongTileDef._5_TIAO, MahjongTileDef._6_TIAO, MahjongTileDef._7_TIAO );  boolean canHu = HuFormula.test( mahjongInHand, MahjongTileDef._1_TIAO );  Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: test4() { List<MahjongTileDef> mahjongInHand = Arrays.asList( MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._2_WAN, MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._5_WAN, MahjongTileDef._6_WAN, MahjongTileDef._7_WAN, MahjongTileDef._8_WAN, MahjongTileDef._9_WAN, MahjongTileDef._9_WAN, MahjongTileDef._9_WAN );  // 测试是否可以胡牌 boolean canHu = HuFormula.test(mahjongInHand, MahjongTileDef._5_WAN); Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: test5() { List<MahjongTileDef> mahjongInHand = Arrays.asList( MahjongTileDef._2_WAN, MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._6_TIAO, MahjongTileDef._7_TIAO, MahjongTileDef._1_BING, MahjongTileDef._2_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._4_BING, MahjongTileDef._5_BING, MahjongTileDef._6_BING );  // 测试是否可以胡牌 boolean canHu = HuFormula.test(mahjongInHand, MahjongTileDef._5_TIAO); Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); RootAssociation association = (RootAssociation) panel.getAssociation(); assertSame(panel, association.getJavaInfo()); assertTrue(association.canDelete()); // try to remove() "<AssertPlaceHolder>"; assertSame(association, panel.getAssociation()); }
remove() throws Exception { return false; }
[*] target: assertFalse(association.remove())
[-] pred: org. junit. Assert. assertFalse ( association. remove ( ) )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "class Test extends JPanel {", "  Test() {", "    addKeyListener(new KeyAdapter() {", "      public void keyReleased(KeyEvent e) {", "      }", "    });", "  }", "}"); DesignPageSite.Helper.setSite(panel, DesignPageSite.EMPTY); // prepare properties Property keyPressedProperty = getEventsListenerMethod(panel, "key", "pressed"); Property keyReleasedProperty = getEventsListenerMethod(panel, "key", "released"); assertNull(getPropertyText(keyPressedProperty)); assertEquals("line 8", getPropertyText(keyReleasedProperty)); // prepare context menu IMenuManager manager; { manager = getDesignerMenuManager(); panel.getBroadcastObject().addContextMenu(null, panel, manager); } // check action for existing "keyReleased" event { IAction keyReleasedAction = findChildAction(manager, "keyReleased -> line 8"); "<AssertPlaceHolder>"; assertSame( EventsPropertyUtils.LISTENER_METHOD_IMAGE_DESCRIPTOR, keyReleasedAction.getImageDescriptor()); // run, no change expected String expectedSource = m_lastEditor.getSource(); keyReleasedAction.run(); assertEditor(expectedSource, m_lastEditor); } // add new handler using action { IMenuManager manager2 = findChildMenuManager(manager, "Add event handler"); manager2 = findChildMenuManager(manager2, "key"); assertSame(EventsPropertyUtils.EXISTING_CLASS_IMAGE, ((MenuManagerEx) manager2).getImage()); // IAction keyPressedAction = findChildAction(manager2, "keyPressed"); assertNotNull(keyPressedAction); // run, new handler should be added keyPressedAction.run(); assertEditor( "class Test extends JPanel {", "  Test() {", "    addKeyListener(new KeyAdapter() {", "      public void keyReleased(KeyEvent e) {", "      }", "      @Override", "      public void keyPressed(KeyEvent e) {", "      }", "    });", "  }", "}"); } // check for images { IMenuManager manager2 = findChildMenuManager(manager, "Add event handler"); assertSame( EventsPropertyUtils.LISTENER_INTERFACE_IMAGE, ((MenuManagerEx) findChildMenuManager(manager2, "ancestor")).getImage()); } }
addContextMenu(List<? extends ObjectInfo> objects, ObjectInfo object, IMenuManager manager) throws Exception { if (object == m_javaInfo) { contributeActions(manager, ModelMessages.EventsProperty_menuManagerName); } }
[*] target: assertNotNull(keyReleasedAction)
[-] pred: org. junit. Assert. assertNotNull ( keyReleasedAction )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); final GenericProperty enabledProperty = (GenericProperty) panel.getPropertyByTitle("enabled"); final AtomicBoolean wasFired = new AtomicBoolean(); // add listener panel.addBroadcastListener(new JavaEventListener() { @Override public void propertyValueWasSet(GenericPropertyImpl property) throws Exception { if (property == enabledProperty) { wasFired.set(true); } } }); // set value for "enabled" to "false" wasFired.set(false); enabledProperty.setValue(false); assertTrue(wasFired.get()); assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); // set value for "enabled" to "true" wasFired.set(false); enabledProperty.setValue(true); "<AssertPlaceHolder>"; assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); // set value for "enabled" to "false" wasFired.set(false); enabledProperty.setExpression("false", Property.UNKNOWN_VALUE); assertTrue(wasFired.get()); assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); }
setValue(Object value) throws Exception;  //////////////////////////////////////////////////////////////////////////// // // Editor // //////////////////////////////////////////////////////////////////////////// /** * @return the {@link PropertyEditor}
[*] target: assertTrue(wasFired.get())
[-] pred: org. junit. Assert. assertTrue ( wasFired. get ( ) )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyPanel.java", getTestSource( "// filler filler filler filler filler", "// filler filler filler filler filler", "public class MyPanel extends JPanel {", "  public int foo;", "}")); waitForAutoBuild(); // parse // parse ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("foo"); FieldAccessor accessor = (FieldAccessor) getGenericPropertyAccessors(property).get(0); // check that IAccessibleExpressionAccessor is available // note, that we don't check it, I just don't know how to do this more easy than perform full check // but we expect that it should be from IAccessibleExpressionAccessor.Utils.forField() IAccessibleExpressionAccessor accessibleAccessor = accessor.getAdapter(IAccessibleExpressionAccessor.class); "<AssertPlaceHolder>"; assertNotNull(ReflectionUtils.getFieldByName(accessibleAccessor.getClass(), "val$field")); }
getAdapter(Class<T> adapter) { if (adapter == IAccessibleExpressionAccessor.class) { return adapter.cast(m_accessibleAccessor); } if (adapter == IExposableExpressionAccessor.class) { return adapter.cast(m_exposableAccessor); } if (adapter == PropertyTooltipProvider.class) { return adapter.cast(m_tooltipProvider); } // other return super.getAdapter(adapter); }
[*] target: assertNotNull(accessibleAccessor)
[-] pred: org. junit. Assert. assertNotNull ( accessibleAccessor )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("enabled"); SetterAccessor accessor = (SetterAccessor) getGenericPropertyAccessors(property).get(0); // check Method getter = accessor.getGetter(); "<AssertPlaceHolder>"; assertEquals("isEnabled", getter.getName()); }
getGetter() { return m_getter; }
[*] target: assertNotNull(getter)
[-] pred: org. junit. Assert. assertNotNull ( getter )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("enabled"); SetterAccessor accessor = (SetterAccessor) getGenericPropertyAccessors(property).get(0); // check that IAccessibleExpressionAccessor is available // note, that we don't check it, I just don't know how to do this more easy than perform full check // but we expect that it should be from IAccessibleExpressionAccessor.Utils.forMethod() IAccessibleExpressionAccessor accessibleAccessor = accessor.getAdapter(IAccessibleExpressionAccessor.class); "<AssertPlaceHolder>"; assertNotNull(ReflectionUtils.getFieldByName(accessibleAccessor.getClass(), "val$method")); }
getAdapter(Class<T> adapter) { if (adapter == IAccessibleExpressionAccessor.class) { return adapter.cast(m_accessibleAccessor); } if (adapter == IExposableExpressionAccessor.class) { return adapter.cast(m_exposableAccessor); } if (adapter == PropertyTooltipProvider.class) { return adapter.cast(m_tooltipProvider); } // other return super.getAdapter(adapter); }
[*] target: assertNotNull(accessibleAccessor)
[-] pred: org. junit. Assert. assertNotNull ( accessibleAccessor )
************************************
************************************
[+] input: Exception { IFile file = getFileSrc("test/messages.properties"); // prepare file in UTF-8 with Russian characters String key = "key"; String value = "" + (char) 0x410 + (char) 0x411 + (char) 0x412; String newValue = "" + (char) 0x430 + (char) 0x431 + (char) 0x432; { String content = key + "=" + value; setFileContent(file, content.getBytes("UTF-8")); file.setCharset("UTF-8", null); } // use BundleInfo, session #1 // check for initial value { BundleInfo bundle = BundleInfo.createBundle( StandardPropertiesAccessor.INSTANCE, "test.messages", LocaleInfo.DEFAULT, new IFile[]{file}); assertNotNull(bundle); assertEquals(value, bundle.getValue(key)); // set new value bundle.setValue(key, newValue); bundle.save(""); assertEquals("UTF-8", file.getCharset()); } // use BundleInfo, session #2 // check for new value { BundleInfo bundle = BundleInfo.createBundle( StandardPropertiesAccessor.INSTANCE, "test.messages", LocaleInfo.DEFAULT, new IFile[]{file}); assertNotNull(bundle); "<AssertPlaceHolder>"; } }
getValue(String key) throws Exception { return getProperties().get(key); }
[*] target: assertEquals(newValue, bundle.getValue(key))
[-] pred: org. junit. Assert. assertEquals ( newValue, bundle. getValue( key ) )
************************************
************************************
[+] input: Exception { CategoryInfo category = new CategoryInfo(); assertFalse(category.isOpen()); category.setOpen(true); "<AssertPlaceHolder>"; }
isOpen() { return m_open; }
[*] target: assertTrue(category.isOpen())
[-] pred: org. junit. Assert. assertTrue ( category. isOpen() )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyAbstractButton.java", getTestSource( "// filler filler filler filler filler", "// filler filler filler filler filler", "public abstract class MyAbstractButton extends JButton {", "}")); setFileContentSrc( "test/MyAbstractButton.wbp-component.xml", getSourceDQ( "<?xml version='1.0' encoding='UTF-8'?>", "<component xmlns='http://www.eclipse.org/wb/WBPComponent'>", "  <creation>", "    <source><![CDATA[new test.MyAbstractButton(){}]]></source>", "    <tag name='createAnonymous' value='true'/>", "  </creation>", "</component>")); waitForAutoBuild(); // prepare palette addPaletteExtension(new String[]{ "<category id='category_1' name='category 1'>", "  <component class='test.MyAbstractButton'/>", "</category>"}); PaletteInfo palette = loadPalette(); // prepare component final CategoryInfo category = palette.getCategory("category_1"); final ComponentEntryInfo componentEntry = (ComponentEntryInfo) category.getEntries().get(0); // set palette site IPaletteSite.Helper.setSite(m_lastParseInfo, new IPaletteSite.Empty() { @Override public Shell getShell() { return DesignerPlugin.getShell(); } }); // do initialize assertTrue(componentEntry.initialize(null, m_lastParseInfo)); // create tool CreationTool creationTool = (CreationTool) componentEntry.createTool(); "<AssertPlaceHolder>"; }
createTool() throws Exception { if (!ensureDescriptions()) { return null; } if (ReflectionUtils.isAbstract(m_class) && !m_creation.hasTrueTag("createAnonymous")) { Shell parentShell = IPaletteSite.Helper.getSite(m_rootJavaInfo).getShell(); UiUtils.openError( parentShell, Messages.ComponentEntryInfo_abstractTitle, Messages.ComponentEntryInfo_abstractMessage); return null; } // prepare generics final Map<String, String> genericArguments = getTypeArguments(); if (genericArguments == null) { return null; } // prepare factory ICreationFactory factory = new ICreationFactory() { private JavaInfo m_javaInfo;  @Override public void activate() throws Exception { CreationSupport creationSupport = new ConstructorCreationSupport(m_creationId, true); m_javaInfo = JavaInfoUtils.createJavaInfo(m_editor, m_description, creationSupport); m_javaInfo.putTemplateArguments(genericArguments); m_javaInfo = JavaInfoUtils.getWrapped(m_javaInfo); m_javaInfo.putArbitraryValue(JavaInfo.FLAG_MANUAL_COMPONENT, Boolean.TRUE); }  @Override public Object getNewObject() { return m_javaInfo; } }; // return tool ensureLibraries(); return new CreationTool(factory); }
[*] target: assertNotNull(creationTool)
[-] pred: org. junit. Assert. assertNotNull ( creationTool )
************************************
************************************
[+] input: Exception { // prepare objects List<Object> objects; { objects = new ArrayList<>(); objects.add("123"); objects.add(555); } // prepare selection provider ISelectionProvider selectionProvider; { final ISelection selection = new StructuredSelection(objects); selectionProvider = new ISelectionProvider() { @Override public ISelection getSelection() { return selection; }  @Override public void setSelection(ISelection _selection) { }  @Override public void removeSelectionChangedListener(ISelectionChangedListener listener) { }  @Override public void addSelectionChangedListener(ISelectionChangedListener listener) { } }; } // get iterable Iterable<Object> iterable = GenericsUtils.iterableSelection(selectionProvider); // iterate { // prepare iterator Iterator<Object> iterator = iterable.iterator(); // first element assertTrue(iterator.hasNext()); assertSame(objects.get(0), iterator.next()); // second element assertTrue(iterator.hasNext()); assertSame(objects.get(1), iterator.next()); // not more elements "<AssertPlaceHolder>"; } }
hasNext() { return iterator.hasNext(); }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext() )
************************************
************************************
[+] input: Exception { Map<String, String> options = ProjectUtils.getOptions(m_testProject.getJavaProject()); "<AssertPlaceHolder>"; // check one option assertEquals("error", options.get("org.eclipse.jdt.core.incompleteClasspath")); }
getOptions(IJavaProject project) { return project.getOptions(true); }
[*] target: assertNotNull(options)
[-] pred: org. junit. Assert. assertNotNull ( options )
************************************
************************************
[+] input: Exception { IPath workspacePath = new Path("/noSuchProject/andNoFolder"); IPath osPath = ProjectUtils.getOSPath(workspacePath); "<AssertPlaceHolder>"; }
getOSPath(IPath path) { IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot(); IResource resource = workspaceRoot.findMember(path); return resource != null ? resource.getLocation() : null; }
[*] target: assertNull(osPath)
[-] pred: org. junit. Assert. assertNull ( osPath )
************************************
************************************
[+] input: Exception { Object imageDescriptor = null; Object image = ReflectionUtils.invokeMethod( ManagerClass, "getImage(org.eclipse.jface.resource.ImageDescriptor)", imageDescriptor); "<AssertPlaceHolder>"; }
getImage(ImageDescriptor descriptor) { if (descriptor == null) { return null; } Image image = m_descriptorImageMap.get(descriptor); if (image == null) { image = descriptor.createImage(); m_descriptorImageMap.put(descriptor, image); } return image; }
[*] target: assertNull(image)
[-] pred: org. junit. Assert. assertNull ( image )
************************************
************************************
[+] input: Exception { Class<?> SWTClass = m_lastLoader.loadClass("org.eclipse.swt.SWT"); ColorInfo info = ColorSupport.createInfo(ReflectionUtils.getFieldByName(SWTClass, "COLOR_RED")); // check create "<AssertPlaceHolder>"; // check color name assertEquals("COLOR_RED", info.m_name); // check special data assertEquals("org.eclipse.swt.SWT.COLOR_RED", info.getData()); // check RGB assertNotNull(info.m_rgb); assertEquals(255, info.m_rgb.red); assertEquals(0, info.m_rgb.green); assertEquals(0, info.m_rgb.blue); }
createInfo(String name, Object color) throws Exception { return new ColorInfo(name, getRed(color), getGreen(color), getBlue(color)); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: Exception { Object shell = ContainerSupport.createShell(); Image rcpImage = ImageDescriptor.createFromFile(Object.class, "/javax/swing/plaf/basic/icons/JavaCup16.png") .createImage(); try { assertNull(ReflectionUtils.invokeMethod(shell, "getImage()")); // ContainerSupport.setShellImage(shell, rcpImage); // check newly set image { Object image = ReflectionUtils.invokeMethod(shell, "getImage()"); // exists... "<AssertPlaceHolder>"; // ..and has same size { Object bounds = ReflectionUtils.invokeMethod(image, "getBounds()"); assertEquals(rcpImage.getBounds().width, ReflectionUtils.getFieldInt(bounds, "width")); assertEquals(rcpImage.getBounds().height, ReflectionUtils.getFieldInt(bounds, "height")); } } } finally { rcpImage.dispose(); ControlSupport.dispose(shell); } }
setShellImage(Object shell, Image swtImage) throws Exception { Object image = SWT_TO_TOOLKIT_IMAGES.get(swtImage); if (image == null) { image = ToolkitSupport.createToolkitImage(swtImage); SWT_TO_TOOLKIT_IMAGES.put(swtImage, image); } ReflectionUtils.invokeMethod(shell, "setImage(org.eclipse.swt.graphics.Image)", image); }
[*] target: assertNotNull(image)
[-] pred: org. junit. Assert. assertNotNull ( image )
************************************
************************************
[+] input: Exception { disposeLastModel(); CompositeInfo shellInfo = (CompositeInfo) parseSource( "test", "Test2.java", getTestSource( "public class Test2 extends Shell {", "  public Test2() {", "    setLayout(new RowLayout());", "    Button button = new Button(this, SWT.NONE);", "    button.setLayoutData(new RowData(100, 50));", "  }", "}")); shellInfo.refresh(); ControlInfo buttonInfo = shellInfo.getChildrenControls().get(0); Object button = buttonInfo.getObject(); // call getLayoutData() Object layoutData = ControlSupport.getLayoutData(button); "<AssertPlaceHolder>"; assertEquals("org.eclipse.swt.layout.RowData", layoutData.getClass().getName()); }
getLayoutData(Object control) { return ReflectionUtils.invokeMethodEx(control, "getLayoutData()"); }
[*] target: assertNotNull(layoutData)
[-] pred: org. junit. Assert. assertNotNull ( layoutData )
************************************
************************************
[+] input: testShouldProduceTheSameMnemonic() { final String expected = "clinic excuse minimum until indoor flower fun concert inquiry letter audit patrol"; final String actual = MnemonicUtils.generateMnemonic(MnemonicUtils.generateEntropy(expected)); "<AssertPlaceHolder>"; }
generateEntropy(String mnemonic) { final BitSet bits = new BitSet(); final int size = mnemonicToBits(mnemonic, bits); if (size == 0) { throw new IllegalArgumentException("Empty mnemonic"); }  final int ent = 32 * size / 33; if (ent % 8 != 0) { throw new IllegalArgumentException("Wrong mnemonic size"); } final byte[] entropy = new byte[ent / 8]; for (int i = 0; i < entropy.length; i++) { entropy[i] = readByte(bits, i); } validateEntropy(entropy);  final byte expectedChecksum = calculateChecksum(entropy); final byte actualChecksum = readByte(bits, entropy.length); if (expectedChecksum != actualChecksum) { throw new IllegalArgumentException("Wrong checksum"); }  return entropy; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { final String html = "<html><head>\n" + "  <script src='script.js'></script>\n" + "</head>\n" + "<body>\n" + "</body>\n" + "</html>";  final WebClient webClient = getWebClient();  final List<String> collectedIncorrectness = new ArrayList<>(); final IncorrectnessListener listener = new IncorrectnessListener() { @Override public void notify(final String message, final Object origin) { collectedIncorrectness.add(message); } }; webClient.setIncorrectnessListener(listener);  final MockWebConnection webConnection = new MockWebConnection(); webClient.setWebConnection(webConnection); webConnection.setResponse(URL_FIRST, html); webConnection.setDefaultResponse("alert('Hello');", "application/x-javascript"); webClient.getPage(URL_FIRST);  final String[] expectedIncorrectness = { "Obsolete content type encountered: 'application/x-javascript' for " + "remotely loaded JavaScript element at 'http://localhost:22222/script.js'." }; "<AssertPlaceHolder>"; }
notify(String message, Object origin);
[*] target: assertEquals(expectedIncorrectness, collectedIncorrectness)
[-] pred: org. junit. Assert. assertEquals ( expectedIncorrectness, collectedIncorrectness )
************************************
************************************
[+] input: isInNetRange() { final boolean isInNet = ProxyAutoConfig.isInNet("172.22.0.7", "172.16.0.0", "255.240.0.0"); "<AssertPlaceHolder>"; }
isInNet(final String host, final String pattern, final String mask) { final String dnsResolve = dnsResolve(host); if (null == dnsResolve) { return false; }  final SubnetUtils subnetUtils = new SubnetUtils(pattern, mask); return subnetUtils.getInfo().isInRange(dnsResolve); }
[*] target: assertTrue(isInNet)
[-] pred: org. junit. Assert. assertTrue ( isInNet )
************************************
************************************
[+] input: Exception { final WebClient client = getWebClient(); final WebWindow window = client.openWindow(null, "TestingWindow"); "<AssertPlaceHolder>"; }
openWindow(final URL url, final String windowName) { WebAssert.notNull("windowName", windowName); return openWindow(url, windowName, getCurrentWindow()); }
[*] target: assertNotNull(window)
[-] pred: org. junit. Assert. assertNotNull ( window )
************************************
************************************
[+] input: Exception { final WebClient client = getWebClient(); final WebWindow window = client.openWindow(UrlUtils.URL_ABOUT_BLANK, "TestingWindow"); "<AssertPlaceHolder>"; }
openWindow(final URL url, final String windowName) { WebAssert.notNull("windowName", windowName); return openWindow(url, windowName, getCurrentWindow()); }
[*] target: assertNotNull(window)
[-] pred: org. junit. Assert. assertNotNull ( window )
************************************
************************************
[+] input: Exception { final WebRequest request = new WebRequest(new URL("http://localhost/test")); request.setHttpMethod(HttpMethod.POST); request.setEncodingType(FormEncodingType.MULTIPART);  final List<NameValuePair> requestParams = new ArrayList<>(); requestParams.add(new NameValuePair("test", null)); requestParams.add(new KeyDataPair("file", null, null, null, StandardCharsets.UTF_8)); request.setRequestParameters(requestParams);  final List<NameValuePair> expectedResults = new ArrayList<>(); expectedResults.add(new NameValuePair("test", "")); // the constructor of the KeyDataPair already creates normalized object // where the value is set to empty string if the passed file is null. expectedResults.add(new KeyDataPair("file", null, null, null, StandardCharsets.UTF_8));  final List<NameValuePair> normalizedParams = request.getParameters(); "<AssertPlaceHolder>";  // check that the value of the KeyDataPair is really normalized to empty string assertEquals("", normalizedParams.get(1).getValue()); }
getParameters() { // developer note: // this has to be in sync with // org.htmlunit.HttpWebConnection.makeHttpMethod(WebRequest, HttpClientBuilder)  if (HttpMethod.POST != getHttpMethod() && HttpMethod.PUT != getHttpMethod() && HttpMethod.PATCH != getHttpMethod()) {  if (!getRequestParameters().isEmpty()) { return normalize(getRequestParameters()); }  return normalize(HttpClientConverter.parseUrlQuery(getUrl().getQuery(), getCharset()));  }  if (getEncodingType() == FormEncodingType.URL_ENCODED && HttpMethod.POST == getHttpMethod()) { if (getRequestBody() == null) { return normalize(getRequestParameters()); }  return normalize(HttpClientConverter.parseUrlQuery(getRequestBody(), getCharset())); }  if (getEncodingType() == FormEncodingType.TEXT_PLAIN  && HttpMethod.POST == getHttpMethod()) { if (getRequestBody() == null) { return normalize(getRequestParameters()); }  return Collections.emptyList(); }  if (FormEncodingType.MULTIPART == getEncodingType()) { return normalize(getRequestParameters()); }  // for instance a PUT or PATCH request return Collections.emptyList(); }
[*] target: assertEquals(expectedResults, normalizedParams)
[-] pred: org. junit. Assert. assertEquals ( expectedResults, normalizedParams )
************************************
************************************
[+] input: Exception { final String html = "<html><head><title>foo</title></head><body>\n" + "<form id='form1' method='post'>\n" + "  <input type='text' name='textfield' value='*'/>\n" + "  <input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(html); final MockWebConnection webConnection = getMockConnection(page);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSubmitInput button = form.getInputByName("button"); button.click();  final List<NameValuePair> expectedParameters = Arrays.asList(new NameValuePair[]{ new NameValuePair("textfield", "*"), new NameValuePair("button", "foo") }); final List<NameValuePair> collectedParameters = webConnection.getLastParameters();  "<AssertPlaceHolder>"; }
getInputByName(final String name) throws ElementNotFoundException { final List<HtmlInput> inputs = getInputsByName(name);  if (inputs.isEmpty()) { throw new ElementNotFoundException(HtmlInput.TAG_NAME, NAME_ATTRIBUTE, name); } return (I) inputs.get(0); }
[*] target: assertEquals(expectedParameters, collectedParameters)
[-] pred: org. junit. Assert. assertEquals ( expectedParameters, collectedParameters )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html>\n" + "<head><title>foo</title></head>\n" + "<body>\n" + "<form><p>hello world</p>\n" + "<input name='foo' type='submit' disabled='disabled' id='foo'/>\n" + "<input name='bar' type='submit' id='bar'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final List<HtmlElement> expectedElements = new ArrayList<>(); expectedElements.add(page.getHtmlElementById("bar"));  "<AssertPlaceHolder>"; }
getTabbableElements() { final List<HtmlElement> tabbableElements = new ArrayList<>(); for (final HtmlElement element : getHtmlElementDescendants()) { final String tagName = element.getTagName(); if (TABBABLE_TAGS.contains(tagName)) { final boolean disabled = element.hasAttribute(ATTRIBUTE_DISABLED); if (!disabled && !HtmlElement.TAB_INDEX_OUT_OF_BOUNDS.equals(element.getTabIndex())) { tabbableElements.add(element); } } } tabbableElements.sort(createTabOrderComparator()); return Collections.unmodifiableList(tabbableElements); }
[*] target: assertEquals(expectedElements, page.getTabbableElements())
[-] pred: org. junit. Assert. assertEquals ( expectedElements, page. getTabbableElements ( ) )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html>\n" + "<head><title>foo</title></head><body>\n" + "<a id='a' accesskey='a'>foo</a>\n" + "<a id='b' accesskey='a'>foo</a>\n" + "<form>\n" + "<a id='c' accesskey='c'>foo</a>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final List<HtmlElement> expectedElements = Arrays.asList(new HtmlElement[] {page.getHtmlElementById("a"), page.getHtmlElementById("b")}); final List<HtmlElement> collectedElements = page.getHtmlElementsByAccessKey('a'); "<AssertPlaceHolder>"; }
getHtmlElementsByAccessKey(final char accessKey) { final List<HtmlElement> elements = new ArrayList<>();  final String searchString = Character.toString(accessKey).toLowerCase(Locale.ROOT); for (final HtmlElement element : getHtmlElementDescendants()) { if (ACCEPTABLE_TAG_NAMES.contains(element.getTagName())) { final String accessKeyAttribute = element.getAttributeDirect("accesskey"); if (searchString.equalsIgnoreCase(accessKeyAttribute)) { elements.add(element); } } }  return elements; }
[*] target: assertEquals(expectedElements, collectedElements)
[-] pred: org. junit. Assert. assertEquals ( expectedElements, collectedElements )
************************************
************************************
[+] input: Exception { final String html = "<html>\n" + "<head>\n" + "<base href='" + URL_SECOND + "'>\n" + "<base href='" + URL_THIRD + "'>\n" + "</head>\n" + "<body>\n" + "  <a href='somepage.html'>\n" + "</body></html>";  final WebClient webClient = getWebClient(); final List<String> collectedIncorrectness = new ArrayList<>(); final IncorrectnessListener listener = new IncorrectnessListener() { @Override public void notify(final String message, final Object origin) { collectedIncorrectness.add(message); } }; webClient.setIncorrectnessListener(listener);  final MockWebConnection webConnection = new MockWebConnection(); webClient.setWebConnection(webConnection); webConnection.setDefaultResponse(html); final HtmlPage page = webClient.getPage(URL_FIRST); page.getAnchors().get(0).click();  final String[] expectedIncorrectness = {"Multiple 'base' detected, only the first is used.", "Multiple 'base' detected, only the first is used."}; "<AssertPlaceHolder>"; }
getAnchors() { return getDocumentElement().getElementsByTagNameImpl("a"); }
[*] target: assertEquals(expectedIncorrectness, collectedIncorrectness)
[-] pred: org. junit. Assert. assertEquals ( expectedIncorrectness, collectedIncorrectness )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1' id='select1' multiple>\n" + "<option value='option1'>Option1</option>\n" + "<option value='option2' >Option2</option>\n" + "<option value='option3'>Option3</option>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlSelect select = page.getHtmlElementById("select1"); "<AssertPlaceHolder>"; }
isMultipleSelectEnabled() { return getAttributeDirect("multiple") != ATTRIBUTE_NOT_DEFINED; }
[*] target: assertTrue(select.isMultipleSelectEnabled())
[-] pred: org. junit. Assert. assertTrue ( select. isMultipleSelectEnabled ( ) )
************************************
************************************
[+] input: Exception { final String firstContent = "<html><head>\n" + "<script>\n" + "var foo = 'foo';\n" + "var test = new Function('alert(foo);');\n" + "</script>\n" + "</head>\n" + "<body onload='test()'>\n" + "  <iframe src='page2.html'/>\n" + "</body>\n" + "</html>";  final String secondContent = "<html><head><script>\n" + "var foo = 'foo2';\n" + "parent.test();\n" + "var f = parent.test;\n" + "f();\n" + "</script></head></html>";  final WebClient client = getWebClient(); final MockWebConnection webConnection = new MockWebConnection(); webConnection.setDefaultResponse(secondContent); webConnection.setResponse(URL_FIRST, firstContent); client.setWebConnection(webConnection);  final String[] expectedAlerts = {"foo", "foo", "foo"};  final List<String> collectedAlerts = new ArrayList<>(); client.setAlertHandler(new CollectingAlertHandler(collectedAlerts)); client.getPage(URL_FIRST);  "<AssertPlaceHolder>"; }
getWebClient() { return webClient_; }
[*] target: assertEquals(expectedAlerts, collectedAlerts)
[-] pred: org. junit. Assert. assertEquals ( expectedAlerts, collectedAlerts )
************************************
************************************
[+] input: containsKey_True_content_based() { // same hash and different content final OrderedFastHashMap<MockKey<String>, String> m = new OrderedFastHashMap<>(); final MockKey<String> mockKey1 = new MockKey<>(10, "akey1"); m.put(mockKey1, "any1"); m.put(new MockKey<>(10, "akey2"), "any2"); m.put(new MockKey<>(10, "akey3"), "any3"); m.put(new MockKey<>(10, "akey4"), "any4"); "<AssertPlaceHolder>"; assertTrue(m.containsKey(new MockKey<>(10, "akey1"))); }
containsKey(final Object key) { return get(key) != null; }
[*] target: assertTrue(m.containsKey(mockKey1))
[-] pred: org. junit. Assert. assertTrue ( m. containsKey ( mockKey1 ) )
************************************
************************************
[+] input: testParseJSONtoHdbtiSuccessfullyWithFileNameWithoutPath() { XSKHDBTIImportConfigModel model = new XSKHDBTIImportConfigModel(); model.setDelimEnclosing("'"); model.setSchemaName("schema"); model.setHeader(true); model.setTableName("table"); model.setFileName("myData2.csv");  String expectedValue = "import = [\n" + "{\n" + "\tdelimEnclosing="'";\n" + "\tschema = "schema";\n" + "\theader = true;\n" + "\ttable = "table";\n" + "\tfile = "myData2.csv";\n" + "}];";  String actualResult = processor.parseJSONtoHdbti(new ArrayList<>(Arrays.asList(model))); "<AssertPlaceHolder>"; }
parseJSONtoHdbti(ArrayList<XSKHDBTIImportConfigModel> json) { for (XSKHDBTIImportConfigModel el : json) { try { el.setFileName(XSKHDBTIUtils.convertPathToHDBTIFileProperty(el.getFileName())); } catch (IllegalArgumentException ex) { XSKCommonsUtils.logProcessorErrors(ex.getMessage(), XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw ex; } if (!el.getTableName().contains("::") && el.getSchemaName() == null) { String errMsg = "Missing schema property"; XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (el.getSchemaName() != null && !XSKHDBTIUtils.isCorrectPropertySyntax(el.getSchemaName())) { String errMsg = "Schema property contains unsupported symbols: " + el.getSchemaName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (!XSKHDBTIUtils.isCorrectTablePropertySyntax(el.getTableName())) { String errMsg = "Table property contains unsupported symbols: " + el.getTableName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } for (Pair key : el.getKeys()) { if (!XSKHDBTIUtils.isCorrectPropertySyntax(key.getColumn())) { String errMsg = "key column property contains unsupported symbols: " + key.getColumn(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } } }  XSKHDBTIImportModel model = new XSKHDBTIImportModel(); model.setConfigModels(json); return model.toString(); }
[*] target: assertEquals(expectedValue, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualResult )
************************************
************************************
[+] input: testParseJSONtoHdbtiSuccessfullyWithMissingSchemaName() { XSKHDBTIImportConfigModel model = new XSKHDBTIImportConfigModel();  model.setDelimEnclosing("'"); model.setHeader(true); model.setTableName("sap_xsk.test::c_users"); model.setFileName("myData2.csv");  String actualValue = processor.parseJSONtoHdbti(new ArrayList<>(Arrays.asList(model)));  String expectedValue = "import = [\n" + "{\n" + "\tdelimEnclosing="'";\n" + "\theader = true;\n" + "\ttable = "sap_xsk.test::c_users";\n" + "\tfile = "myData2.csv";\n" + "}];";  "<AssertPlaceHolder>"; }
parseJSONtoHdbti(ArrayList<XSKHDBTIImportConfigModel> json) { for (XSKHDBTIImportConfigModel el : json) { try { el.setFileName(XSKHDBTIUtils.convertPathToHDBTIFileProperty(el.getFileName())); } catch (IllegalArgumentException ex) { XSKCommonsUtils.logProcessorErrors(ex.getMessage(), XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw ex; } if (!el.getTableName().contains("::") && el.getSchemaName() == null) { String errMsg = "Missing schema property"; XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (el.getSchemaName() != null && !XSKHDBTIUtils.isCorrectPropertySyntax(el.getSchemaName())) { String errMsg = "Schema property contains unsupported symbols: " + el.getSchemaName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (!XSKHDBTIUtils.isCorrectTablePropertySyntax(el.getTableName())) { String errMsg = "Table property contains unsupported symbols: " + el.getTableName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } for (Pair key : el.getKeys()) { if (!XSKHDBTIUtils.isCorrectPropertySyntax(key.getColumn())) { String errMsg = "key column property contains unsupported symbols: " + key.getColumn(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } } }  XSKHDBTIImportModel model = new XSKHDBTIImportModel(); model.setConfigModels(json); return model.toString(); }
[*] target: assertEquals(expectedValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualValue )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/multipleTableDeclarations.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/duplicateKeys.hdbti", hdbtiSample); } catch (DuplicateFieldNameException duplicateFieldNameException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/invalidSyntax.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/invalidSyntax.hdbti", hdbtiSample); } catch (XSKArtifactParserException parseErrorException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/invalidTablePropertySyntax.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/invalidTablePropertySyntax.hdbti", hdbtiSample); } catch (TablePropertySyntaxException parseErrorException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/duplicateKeys.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/duplicateKeys.hdbti", hdbtiSample); } catch (DuplicateFieldNameException duplicateFieldNameException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: idleBeat() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.idleBeat(new IdleBeatParam(jobId));  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(500, retval.getCode()); Assert.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(IdleBeatParam idleBeatParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: run() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  // trigger data final TriggerParam triggerParam = new TriggerParam(); triggerParam.setJobId(1); triggerParam.setExecutorHandler("demoJobHandler"); triggerParam.setExecutorParams(null); triggerParam.setExecutorBlockStrategy(ExecutorBlockStrategyEnum.COVER_EARLY.name()); triggerParam.setGlueType(GlueTypeEnum.BEAN.name()); triggerParam.setGlueSource(null); triggerParam.setGlueUpdatetime(System.currentTimeMillis()); triggerParam.setLogId(1); triggerParam.setLogDateTime(System.currentTimeMillis());  // Act final ReturnT<String> retval = executorBiz.run(triggerParam);  // Assert result Assert."<AssertPlaceHolder>"; }
run(TriggerParam triggerParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: kill() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.kill(new KillParam(jobId));  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(200, retval.getCode()); Assert.assertNull(retval.getMsg()); }
kill(KillParam killParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: testClear() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); map.put("key1", "value1"); map.put("key2", "value2"); map.clear(); assertTrue(map.isEmpty()); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size ( ) )
************************************
************************************
[+] input: testPutIfAbsent() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); assertNull(map.putIfAbsent("key1", "value1")); assertEquals("value1", map.get("key1")); assertEquals("value1", map.putIfAbsent("key1", "value2")); assertEquals("value1", map.get("key1")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, map.size())
[-] pred: org. junit. Assert. assertEquals ( 1, map. size() )
************************************
************************************
[+] input: testRemove() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); map.put("key1", "value1"); assertEquals("value1", map.remove("key1")); assertNull(map.remove("key1")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size ( ) )
************************************
************************************
[+] input: testSyncMintNFT() { Provider provider = wallet.getProvider(); Token token = defaultToken(); EthSignature ethSignature = new EthSignature(SignatureType.EthereumSignature, "0xac4f8b1ad65ea143dd2a940c72dd778ba3e07ee766355ed237a89a0b7e925fe76ead0a04e23db1cc1593399ee69faeb31b2e7e0c6fbec70d5061d6fbc431d64a1b"); when(provider.getTokens()).thenReturn(new Tokens(Collections.singletonMap(token.getAddress(), token))); when(provider.submitTx(defaultZkSyncTransaction_MintNFT(), ethSignature, false)).thenReturn("success:hash"); String response = wallet.syncMintNFT( "0x19aa2ed8712072e918632259780e587698ef58df", "0x0000000000000000000000000000000000000000000000000000000000000123", defaultTransactionFee(1000000), 12 ); "<AssertPlaceHolder>"; assertEquals(response, "success:hash"); }
syncMintNFT(String recipient, String contentHash, TransactionFee fee, Integer nonce) { final Integer nonceToUse = nonce == null ? getNonce() : nonce;  final SignedTransaction<MintNFT> signedMintNFT = buildSignedMintNFTTx(recipient, contentHash, fee.getFeeToken(), fee.getFee(), nonceToUse);  return submitSignedTransaction(signedMintNFT.getTransaction(), signedMintNFT.getEthereumSignature()); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
[+] input: test01() { SearchWrapper rw = new SearchWrapper(); rw.eq("akey", "avalue").eq(Connector.OR, "bkey", "bvalue").group(rw1 -> { rw1.eq("ckey", "avalue").in(Connector.AND_NOT, "dkey", Arrays.asList("aa", "bb")); }).eq("a", "b");  String expr = "akey = "avalue" OR bkey = "bvalue" AND (ckey = "avalue" AND NOT dkey IN ("aa","bb")) AND a = "b""; Assert."<AssertPlaceHolder>";  System.out.println(rw.toFilterExpression()); }
toFilterExpression() { return toFilterExpression(ExpressionAdaptor.DEFAULT); }
[*] target: assertEquals(expr, rw.toFilterExpression())
[-] pred: org. junit. Assert. assertTrue ( ( ( a. toFilterExpression ( ). size ( ) ) > 0 ) )



************************************
************************************
[+] input: test02() { SearchWrapper rw = new SearchWrapper(); rw.eq("akey", "avalue").between(Connector.OR, "bkey", "1", "100").in("ckey", Arrays.asList("aa", "bb"));  String expr = "akey = "avalue" OR bkey BETWEEN "1" AND "100" AND ckey IN ("aa","bb")"; Assert."<AssertPlaceHolder>";  System.out.println(rw.toFilterExpression()); }
toFilterExpression() { return toFilterExpression(ExpressionAdaptor.DEFAULT); }
[*] target: assertEquals(expr, rw.toFilterExpression())
[-] pred: org. junit. Assert. assertEquals ( expr, toFilterExpression(). toFilterExpression ( ) )



************************************
************************************
[+] input: testAdd() { Controlador controlador = new Controlador(); int result = controlador.add(2, 3); "<AssertPlaceHolder>"; }
add(int n1, int n2) { int n5 = n1 + n2; return n5; }
[*] target: assertEquals(5, result)
[-] pred: org. junit. Assert. assertEquals ( 4, result )



************************************
************************************
[+] input: testSubstraction() { Controlador controlador = new Controlador(); int result = controlador.substraction(5, 3); "<AssertPlaceHolder>"; }
substraction(int n1, int n2) { int n5 = n1 - n2; return n5; }
[*] target: assertEquals(2, result)
[-] pred: org. junit. Assert. assertEquals ( 5, result )



************************************
************************************
[+] input: testMultiplication() { Controlador controlador = new Controlador(); int result = controlador.multiplication(2, 3); "<AssertPlaceHolder>"; }
multiplication(int n1, int n2) { int n5 = n1 * n2; return n5; }
[*] target: assertEquals(6, result)
[-] pred: org. junit. Assert. assertEquals ( 2, result )



************************************
************************************
[+] input: Exception { Controlador controlador = new Controlador(); int result = controlador.division(6, 3); "<AssertPlaceHolder>"; }
division(int n1, int n2) throws Exception { int n5 = n1 / n2; return n5; }
[*] target: assertEquals(2, result)
[-] pred: org. junit. Assert. assertEquals ( 8, result )



************************************
************************************
[+] input: Exception { Controlador controlador = new Controlador(); int result = controlador.residue(7, 3); "<AssertPlaceHolder>"; }
residue(int n1, int n2) throws Exception { return 0; }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 7, result )



************************************
************************************
[+] input: Exception { Controlador controlador = new Controlador(); ArrayList<Character> elements = new ArrayList<>(); elements.add('1'); elements.add('2'); elements.add('+'); elements.add('4'); elements.add('*'); elements.add('3'); elements.add('+');  int result = controlador.solve(elements); "<AssertPlaceHolder>"; }
solve(ArrayList<Character> elements) throws Exception { return 0; }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 0, result )



************************************
************************************
[+] input: testInOrderTraversal() { BinarySearchTree<Integer, String> tree = new BinarySearchTree<>(Comparator.naturalOrder()); tree.insert(5, "Five"); tree.insert(3, "Three"); tree.insert(7, "Seven"); tree.insert(1, "One");  SaveInArrayListWalk<String> walk = new SaveInArrayListWalk<>(); tree.InOrderWalk(walk); "<AssertPlaceHolder>"; }
InOrderWalk(IWalk<V> walk) { InternalInOrderWalk(root, walk); }
[*] target: assertEquals("[One, Three, Five, Seven]", walk.getListado().toString())
[-] pred: org. junit. Assert. assertTrue ( ( walk!= null ) )



************************************
************************************
[+] input: testInsertAndRemoveWithEmptyHeap() { // Crear un comparador de prioridades Comparator<Integer> comparator = new ComparadorNumeros<>();  // Crear un heap utilizando el árbol binario iterativo HeapUsingIterativeBinaryTree<Integer, String> heap = new HeapUsingIterativeBinaryTree<>(comparator);  // Prueba remove en un heap vacío "<AssertPlaceHolder>"; }
remove() {  if (isEmpty()) { return null; }  if (count() == 1) { _count--; TreeNode<P, V> temporal = _root; _root = null; return temporal.get_value(); }  //if has more than 1 element  // Obtener el binario de la cantidad de nodos byte[] movimientos = convertToBinary(_count);  // Encontrar el nodo a eliminar //Reccorer de acuerdo a los movimientos int index = 1; TreeNode<P, V> actual = _root; TreeNode<P, V> nodoToBeDeleted = null;  while (index < movimientos.length) {  if (index == movimientos.length - 1) { if (movimientos[index] == 0) { // Inserto en el hijo izquierdo nodoToBeDeleted = actual.get_left(); } else { //Inserto en el hijo derecho nodoToBeDeleted = actual.get_right(); }  } else { if (movimientos[index] == 0) { // Inserto en el hijo izquierdo actual = actual.get_left(); } else { //Inserto en el hijo derecho actual = actual.get_right(); } }  index++; }  // Hacer Swap de la hoja con la raiz P tempPriority = nodoToBeDeleted.get_priority(); V tempValue = nodoToBeDeleted.get_value();  nodoToBeDeleted.set_priority(_root.get_priority()); nodoToBeDeleted.set_value(_root.get_value());  _root.set_priority(tempPriority); _root.set_value(tempValue);   // Eliminar el nodo hoja tempPriority = nodoToBeDeleted.get_priority(); tempValue = nodoToBeDeleted.get_value();  TreeNode<P, V> parent = nodoToBeDeleted.get_parent(); if (parent.get_left() == nodoToBeDeleted) parent.set_left(null); else parent.set_right(null);   // buscar el lugar de insercion actual = _root;  while (actual != null) {  boolean actualHasLeftChild = actual.get_left() != null; boolean actualHasRightChild = actual.get_right() != null;  if (actualHasLeftChild && actualHasRightChild) { //Tiene a los 2 hijos  //Si tiene a los dos hijos verifico quien es el mayor int result = _priorityComparator.compare(actual.get_left().get_priority(), actual.get_right().get_priority());  if (result == 0) { //Son iguales  result = _priorityComparator.compare(actual.get_priority(), actual.get_left().get_priority()); if (result < 0) { P tempPriority2 = actual.get_priority(); V tempValue2 = actual.get_value();  actual.set_priority(actual.get_left().get_priority()); actual.set_value(actual.get_left().get_value());  actual.get_left().set_priority(tempPriority2); actual.get_left().set_value(tempValue2);  actual = actual.get_left(); } else { break; }  } else if (result > 0){ //Hijo izquierdo mayor result = _priorityComparator.compare(actual.get_priority(), actual.get_left().get_priority()); if (result < 0) { P tempPriority2 = actual.get_priority(); V tempValue2 = actual.get_value();  actual.set_priority(actual.get_left().get_priority()); actual.set_value(actual.get_left().get_value());  actual.get_left().set_priority(tempPriority2); actual.get_left().set_value(tempValue2); actual = actual.get_left(); } else { break; } } else { result = _priorityComparator.compare(actual.get_priority(), actual.get_right().get_priority()); if (result < 0) { P tempPriority2 = actual.get_priority(); V tempValue2 = actual.get_value();  actual.set_priority(actual.get_right().get_priority()); actual.set_value(actual.get_right().get_value());  actual.get_right().set_priority(tempPriority2); actual.get_right().set_value(tempValue2); actual = actual.get_right(); } else { break; } }  } else if (!actualHasLeftChild && !actualHasRightChild){ //No tiene hijos break; } else if (actualHasLeftChild){ //Solo tiene izquierdo int result = _priorityComparator.compare(actual.get_priority(), actual.get_left().get_priority()); if (result < 0) { P tempPriority2 = actual.get_priority(); V tempValue2 = actual.get_value();  actual.set_priority(actual.get_left().get_priority()); actual.set_value(actual.get_left().get_value());  actual.get_left().set_priority(tempPriority2); actual.get_left().set_value(tempValue2); } else { break; } } else { //Solo tiene derecho int result = _priorityComparator.compare(actual.get_priority(), actual.get_right().get_priority()); if (result < 0) { P tempPriority2 = actual.get_priority(); V tempValue2 = actual.get_value();  actual.set_priority(actual.get_right().get_priority()); actual.set_value(actual.get_right().get_value());  actual.get_right().set_priority(tempPriority2); actual.get_right().set_value(tempValue2); } else { break; } } }  // reducir la cantidad _count--;  return tempValue; }
[*] target: assertNull(heap.remove())
[-] pred: org. junit. Assert. assertEquals ( 0, heap. size ( ) )



************************************
************************************
[+] input: testGetID() { //GIVEN CorporateEdsLoginAuthenticatorFactory factory = new CorporateEdsLoginAuthenticatorFactory();  //WHEN String id = factory.getId();  //THEN "<AssertPlaceHolder>"; }
getId() { return ID; }
[*] target: assertEquals("The ID should be keycloak-corporate-eds-login", "keycloak-corporate-eds-login", id)
[-] pred: org. junit. Assert. assertEquals ( id, uintteEdsLoginAuthenticatorFactory();SimpleTypeWHEN. getId() ( ) )



************************************
************************************
[+] input: testGetReferenceCategory() { //GIVEN CorporateEdsLoginAuthenticatorFactory factory = new CorporateEdsLoginAuthenticatorFactory();  //WHEN String category = factory.getReferenceCategory();  //THEN "<AssertPlaceHolder>"; }
getReferenceCategory() { return "CorporateEdsLogin"; }
[*] target: assertEquals("The category should be CorporateEdsLogin", "CorporateEdsLogin", category)
[-] pred: org. junit. Assert. assertEquals ( category, STRINGAcc )



************************************
************************************
[+] input: testGetDisplayType() { //GIVEN CorporateEdsLoginAuthenticatorFactory factory = new CorporateEdsLoginAuthenticatorFactory();  //WHEN String type = factory.getDisplayType();  //THEN "<AssertPlaceHolder>"; }
getDisplayType() { return "Corporate EDS Login"; }
[*] target: assertEquals("The display type should be Corporate EDS Login", "Corporate EDS Login", type)
[-] pred: org. junit. Assert. assertEquals ( ""149te EDS Login";"", type )



************************************
************************************
[+] input: testGetHelpText() { //GIVEN CorporateEdsLoginAuthenticatorFactory factory = new CorporateEdsLoginAuthenticatorFactory();  //WHEN String type = factory.getHelpText();  //THEN "<AssertPlaceHolder>"; }
getHelpText() { return "Corporate EDS Login"; }
[*] target: assertEquals("Help text should be Corporate EDS Login", "Corporate EDS Login", type)
[-] pred: org. junit. Assert. assertEquals ( type, factory. getHelpText() )



************************************
************************************
[+] input: testVerifyValidData() { CertificateMetadata metadata = new CertificateMetadata(); metadata.withBin("BIN_VALUE"); metadata.withTaxCode("TAX_CODE_VALUE");  UserModel user = Mockito.mock(UserModel.class); HashMap<String, List<String>> attributes = new HashMap<>(); List<String> taxCodeList = new ArrayList<>(); taxCodeList.add("TAX_CODE_VALUE"); attributes.put(KeycloakAttributes.TAX_CODE, taxCodeList); List<String> binList = new ArrayList<>(); binList.add("BIN_VALUE"); attributes.put(KeycloakAttributes.BIN, binList); Mockito.when(user.getAttributes()).thenReturn(attributes);  var res = CorporateUserVerifierImpl.verify(user, metadata);  "<AssertPlaceHolder>"; }
verify(@Nonnull UserModel currentUser, @Nonnull CertificateMetadata edsMetadata) { logger.info("Trying to match via user attributes and bin & taxCode..."); Map<String, List<String>> attrs = currentUser.getAttributes(); String bin = edsMetadata.getBin(), taxCode = edsMetadata.getTaxCode(); if (null == bin && null == taxCode) { logger.warn("Input bin {} or taxCode {} is null", bin, taxCode); return false; } if (attrs != null && !attrs.isEmpty()) { List<String> taxCodeValues = attrs.get(KeycloakAttributes.TAX_CODE); List<String> binValues = attrs.get(KeycloakAttributes.BIN); logger.info("Trying to match taxCode {} in values {}," + " bin {} in values {}", taxCode, taxCodeValues, bin, binValues); boolean isValidTaxCode = null == taxCodeValues ? false : taxCodeValues.contains(taxCode); boolean isValidBin = null == binValues ? false : binValues.contains(bin); if (isValidBin && isValidTaxCode) { return true; } logger.info("Not matched by this verifier."); } return false; }
[*] target: assertThat(res).isTrue()
[-] pred: org. junit. Assert. assertTrue ( res. verify ( true ) )



************************************
************************************
[+] input: testVerifyInvalidData() { CertificateMetadata metadata = new CertificateMetadata(); metadata.withBin("ANOTHER_BIN_VALUE"); metadata.withTaxCode("ANOTHER_TAX_CODE_VALUE");  UserModel user = Mockito.mock(UserModel.class); HashMap<String, List<String>> attributes = new HashMap<>(); List<String> taxCodeList = new ArrayList<>(); taxCodeList.add("TAX_CODE_VALUE"); attributes.put(KeycloakAttributes.TAX_CODE, taxCodeList); List<String> binList = new ArrayList<>(); binList.add("BIN_VALUE"); attributes.put(KeycloakAttributes.BIN, binList); Mockito.when(user.getAttributes()).thenReturn(attributes);  var res = CorporateUserVerifierImpl.verify(user, metadata);  "<AssertPlaceHolder>"; }
verify(@Nonnull UserModel currentUser, @Nonnull CertificateMetadata edsMetadata) { logger.info("Trying to match via user attributes and bin & taxCode..."); Map<String, List<String>> attrs = currentUser.getAttributes(); String bin = edsMetadata.getBin(), taxCode = edsMetadata.getTaxCode(); if (null == bin && null == taxCode) { logger.warn("Input bin {} or taxCode {} is null", bin, taxCode); return false; } if (attrs != null && !attrs.isEmpty()) { List<String> taxCodeValues = attrs.get(KeycloakAttributes.TAX_CODE); List<String> binValues = attrs.get(KeycloakAttributes.BIN); logger.info("Trying to match taxCode {} in values {}," + " bin {} in values {}", taxCode, taxCodeValues, bin, binValues); boolean isValidTaxCode = null == taxCodeValues ? false : taxCodeValues.contains(taxCode); boolean isValidBin = null == binValues ? false : binValues.contains(bin); if (isValidBin && isValidTaxCode) { return true; } logger.info("Not matched by this verifier."); } return false; }
[*] target: assertThat(res).isFalse()
[-] pred: org. junit. Assert. assertTrue ( res. verify ( true ) )



************************************
************************************
[+] input: testVerifyEmptyData() { CertificateMetadata metadata = new CertificateMetadata(); metadata.withBin("BIN_VALUE"); metadata.withTaxCode("TAX_CODE_VALUE");  UserModel user = Mockito.mock(UserModel.class); HashMap<String, List<String>> attributes = new HashMap<>(); Mockito.when(user.getAttributes()).thenReturn(attributes);  var res = CorporateUserVerifierImpl.verify(user, metadata);  "<AssertPlaceHolder>"; }
verify(@Nonnull UserModel currentUser, @Nonnull CertificateMetadata edsMetadata) { logger.info("Trying to match via user attributes and bin & taxCode..."); Map<String, List<String>> attrs = currentUser.getAttributes(); String bin = edsMetadata.getBin(), taxCode = edsMetadata.getTaxCode(); if (null == bin && null == taxCode) { logger.warn("Input bin {} or taxCode {} is null", bin, taxCode); return false; } if (attrs != null && !attrs.isEmpty()) { List<String> taxCodeValues = attrs.get(KeycloakAttributes.TAX_CODE); List<String> binValues = attrs.get(KeycloakAttributes.BIN); logger.info("Trying to match taxCode {} in values {}," + " bin {} in values {}", taxCode, taxCodeValues, bin, binValues); boolean isValidTaxCode = null == taxCodeValues ? false : taxCodeValues.contains(taxCode); boolean isValidBin = null == binValues ? false : binValues.contains(bin); if (isValidBin && isValidTaxCode) { return true; } logger.info("Not matched by this verifier."); } return false; }
[*] target: assertThat(res).isFalse()
[-] pred: org. junit. Assert. assertTrue ( res. verify(@Nonnull UserModel currentUser, @ @"" Certificate_11 )



************************************
************************************
[+] input: testDateTime() { Date testDate = Date.from(java.time.LocalDateTime.of(2022, 12, 25, 10, 20, 30).atZone(ZoneId.systemDefault()).toInstant()); String expected = "2022-12-25 10:20:30"; String actual = DateUtils.dateTime(testDate); "<AssertPlaceHolder>"; }
dateTime(Date date) { if (date == null) { return null; } return formatter.format(date.toInstant().atZone(ZoneId.systemDefault())); }
[*] target: assertEquals("Test when date is not null",expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: testDateTimeWithNullDate() { Date nullDate = null; String actual = DateUtils.dateTime(nullDate); "<AssertPlaceHolder>"; }
dateTime(Date date) { if (date == null) { return null; } return formatter.format(date.toInstant().atZone(ZoneId.systemDefault())); }
[*] target: assertNull("Test when date is null", actual)
[-] pred: org. junit. Assert. assertEquals ( formatter.format(date.toInstant ( nullDate ), actual )



************************************
************************************
[+] input: testOQLunion6() { StringBuilder sb = new StringBuilder(); sb.append("select s from 1 s"); OQL.union(sb, "select s from 2 s"); OQL.union(sb, "select t from 17 t"); OQL.union(sb, "select t from 23 t"); OQL.union(sb, "select s from 3 s"); "<AssertPlaceHolder>"; }
union(StringBuilder query, String other) { if ((query.length() > 0)) { int end = query.length(); while (query.charAt(end - 1) == ')') { int start = query.lastIndexOf(" UNION (", end - 1); //$NON-NLS-1$ if (start == -1) break; if (union(query, start + 8, end - 1, other)) return; if (start < 1) break; end = start; } if (union(query, 0, end, other)) return; // Default query.append(" UNION (").append(other).append(")"); //$NON-NLS-1$ //$NON-NLS-2$ } else query.append(other); }
[*] target: assertEquals("select s from 1,2,3 s UNION (select t from 17,23 t)", sb.toString())
[-] pred: org. junit. Assert. assertEquals ( t from1sCatUtil. union(StringBuilder query, sb. toString ( ) )



************************************
************************************
[+] input: test_adjustInstant_ReturnsSameInstant_WeekendModeDisabled() { SharedPreferences preferences = Mockito.mock(SharedPreferences.class); WeekendMode weekendMode = new WeekendMode(preferences); Instant instant = Instant.now();  Mockito.when(preferences.getBoolean(eq(WeekendModePreferencesFragment.WEEKEND_MODE), anyBoolean())).thenReturn(false);  Instant adjustedInstant = weekendMode.adjustInstant(instant);  "<AssertPlaceHolder>"; }
adjustInstant(Instant instant) { if (isWeekendModeEnabled()) { int weekendTime = preferences.getInt(WeekendModePreferencesFragment.WEEKEND_TIME, 540); Set<String> weekendDays = preferences.getStringSet(WeekendModePreferencesFragment.WEEKEND_DAYS, new ArraySet<>()); ZonedDateTime localDateTime = instant.atZone(ZoneId.systemDefault()); DayOfWeek dayOfWeek = localDateTime.getDayOfWeek(); int minutes = localDateTime.getMinute() + localDateTime.getHour() * 60; int deltaMinutes = weekendTime - minutes; if (weekendDays.contains(String.valueOf(dayOfWeek.getValue())) && deltaMinutes > 0) { instant = instant.plusSeconds(deltaMinutes * 60L); } } return instant; }
[*] target: assertEquals(instant, adjustedInstant)
[-] pred: org. junit. Assert. assertSame ( instant, adjustedInstant )



************************************
************************************
[+] input: test_adjustInstant_ReturnsSameInstant_WeekendDaysEmpty() { SharedPreferences preferences = Mockito.mock(SharedPreferences.class); WeekendMode weekendMode = new WeekendMode(preferences); Instant instant = Instant.now();  Mockito.when(preferences.getBoolean(WeekendModePreferencesFragment.WEEKEND_MODE, false)).thenReturn(true); Mockito.when(preferences.getStringSet(WeekendModePreferencesFragment.WEEKEND_DAYS, new ArraySet<>())).thenReturn(new HashSet<>());  Instant adjustedInstant = weekendMode.adjustInstant(instant);  "<AssertPlaceHolder>"; }
adjustInstant(Instant instant) { if (isWeekendModeEnabled()) { int weekendTime = preferences.getInt(WeekendModePreferencesFragment.WEEKEND_TIME, 540); Set<String> weekendDays = preferences.getStringSet(WeekendModePreferencesFragment.WEEKEND_DAYS, new ArraySet<>()); ZonedDateTime localDateTime = instant.atZone(ZoneId.systemDefault()); DayOfWeek dayOfWeek = localDateTime.getDayOfWeek(); int minutes = localDateTime.getMinute() + localDateTime.getHour() * 60; int deltaMinutes = weekendTime - minutes; if (weekendDays.contains(String.valueOf(dayOfWeek.getValue())) && deltaMinutes > 0) { instant = instant.plusSeconds(deltaMinutes * 60L); } } return instant; }
[*] target: assertEquals(instant, adjustedInstant)
[-] pred: org. junit. Assert. assertTrue ( adjustedInstant. adjustInstant(Instant ) )



************************************
************************************
[+] input: test_adjustInstant_ReturnsSameInstant_CurrentDayIsNotWeekend() { SharedPreferences preferences = Mockito.mock(SharedPreferences.class); Instant instant = Mockito.mock(Instant.class); WeekendMode weekendMode = new WeekendMode(preferences); ZonedDateTime testZonedDateTime = ZonedDateTime.of(2024, 4, 6, 8, 0, 0, 0, ZoneId.of("Z"));  Mockito.when(preferences.getBoolean(eq(WeekendModePreferencesFragment.WEEKEND_MODE), anyBoolean())).thenReturn(true); Mockito.when(preferences.getInt(eq(WeekendModePreferencesFragment.WEEKEND_TIME), anyInt())).thenReturn(10 * 60); Mockito.when(instant.atZone(any())).thenReturn(testZonedDateTime); Set<String> weekendDays = new HashSet<>(); weekendDays.add(String.valueOf(DayOfWeek.TUESDAY.getValue())); weekendDays.add(String.valueOf(DayOfWeek.WEDNESDAY.getValue())); Mockito.when(preferences.getStringSet(WeekendModePreferencesFragment.WEEKEND_DAYS, new ArraySet<>())).thenReturn(weekendDays);  Instant adjustedInstant = weekendMode.adjustInstant(instant);  "<AssertPlaceHolder>"; }
adjustInstant(Instant instant) { if (isWeekendModeEnabled()) { int weekendTime = preferences.getInt(WeekendModePreferencesFragment.WEEKEND_TIME, 540); Set<String> weekendDays = preferences.getStringSet(WeekendModePreferencesFragment.WEEKEND_DAYS, new ArraySet<>()); ZonedDateTime localDateTime = instant.atZone(ZoneId.systemDefault()); DayOfWeek dayOfWeek = localDateTime.getDayOfWeek(); int minutes = localDateTime.getMinute() + localDateTime.getHour() * 60; int deltaMinutes = weekendTime - minutes; if (weekendDays.contains(String.valueOf(dayOfWeek.getValue())) && deltaMinutes > 0) { instant = instant.plusSeconds(deltaMinutes * 60L); } } return instant; }
[*] target: assertEquals(instant, adjustedInstant)
[-] pred: org. junit. Assert. assertFalse ( adjustedInstant. adjustInstant ( testonedDateTime ) )



************************************
************************************
[+] input: Exception { final String emptySource = "{"app_version":"0.11.6","app_version_int": 47,"subscriptions":[]}";  final List<SubscriptionItem> items = ImportExportJsonHelper.readFrom( new ByteArrayInputStream(emptySource.getBytes(StandardCharsets.UTF_8)), null); "<AssertPlaceHolder>"; }
readFrom( final InputStream in, @Nullable final ImportExportEventListener eventListener) throws InvalidSourceException { if (in == null) { throw new InvalidSourceException("input is null"); }  final List<SubscriptionItem> channels = new ArrayList<>();  try { final JsonObject parentObject = JsonParser.object().from(in);  if (!parentObject.has(JSON_SUBSCRIPTIONS_ARRAY_KEY)) { throw new InvalidSourceException("Channels array is null"); }  final JsonArray channelsArray = parentObject.getArray(JSON_SUBSCRIPTIONS_ARRAY_KEY);  if (eventListener != null) { eventListener.onSizeReceived(channelsArray.size()); }  for (final Object o : channelsArray) { if (o instanceof JsonObject) { final JsonObject itemObject = (JsonObject) o; final int serviceId = itemObject.getInt(JSON_SERVICE_ID_KEY, 0); final String url = itemObject.getString(JSON_URL_KEY); final String name = itemObject.getString(JSON_NAME_KEY);  if (url != null && name != null && !url.isEmpty() && !name.isEmpty()) { channels.add(new SubscriptionItem(serviceId, url, name)); if (eventListener != null) { eventListener.onItemCompleted(name); } } } } } catch (final Throwable e) { throw new InvalidSourceException("Couldn't parse json", e); }  return channels; }
[*] target: assertTrue(items.isEmpty())
[-] pred: org. junit. Assert. assertEquals ( emptySource, items )



************************************
************************************
[+] input: testInvalidSource() { final List<String> invalidList = Arrays.asList( "{}", "", null, "gibberish");  for (final String invalidContent : invalidList) { try { if (invalidContent != null) { final byte[] bytes = invalidContent.getBytes(StandardCharsets.UTF_8); ImportExportJsonHelper.readFrom((new ByteArrayInputStream(bytes)), null); } else { ImportExportJsonHelper.readFrom(null, null); }  fail("didn't throw exception"); } catch (final Exception e) { final boolean isExpectedException = e instanceof SubscriptionExtractor.InvalidSourceException; "<AssertPlaceHolder>"; } } }
readFrom( final InputStream in, @Nullable final ImportExportEventListener eventListener) throws InvalidSourceException { if (in == null) { throw new InvalidSourceException("input is null"); }  final List<SubscriptionItem> channels = new ArrayList<>();  try { final JsonObject parentObject = JsonParser.object().from(in);  if (!parentObject.has(JSON_SUBSCRIPTIONS_ARRAY_KEY)) { throw new InvalidSourceException("Channels array is null"); }  final JsonArray channelsArray = parentObject.getArray(JSON_SUBSCRIPTIONS_ARRAY_KEY);  if (eventListener != null) { eventListener.onSizeReceived(channelsArray.size()); }  for (final Object o : channelsArray) { if (o instanceof JsonObject) { final JsonObject itemObject = (JsonObject) o; final int serviceId = itemObject.getInt(JSON_SERVICE_ID_KEY, 0); final String url = itemObject.getString(JSON_URL_KEY); final String name = itemObject.getString(JSON_NAME_KEY);  if (url != null && name != null && !url.isEmpty() && !name.isEmpty()) { channels.add(new SubscriptionItem(serviceId, url, name)); if (eventListener != null) { eventListener.onItemCompleted(name); } } } } } catch (final Throwable e) { throw new InvalidSourceException("Couldn't parse json", e); }  return channels; }
[*] target: assertTrue(""" + e.getClass().getSimpleName() + "" is not the expected exception", isExpectedException)
[-] pred: org. junit. Assert. assertTrue ( isExpectedException )



************************************
************************************
[+] input: inBounds() { nonEmptyQueue.setIndex(2); "<AssertPlaceHolder>";  // emptyQueue not tested because 0 isn't technically inBounds }
getIndex() { return queueIndex.get(); }
[*] target: assertEquals(2, nonEmptyQueue.getIndex())
[-] pred: org. junit. Assert. assertEquals ( inBounds, qQueue. getIndex() ( ) )



************************************
************************************
[+] input: itemsAreNotCloned() { final PlayQueueItem item = makeItemWithUrl("A url"); final PlayQueue playQueue = makePlayQueue(0, List.of(item));  // make sure that items are not cloned when added to the queue "<AssertPlaceHolder>"; }
getItem() { return getItem(getIndex()); }
[*] target: assertSame(playQueue.getItem(), item)
[-] pred: org. junit. Assert. assertThat ( item. getItem() ( ), org. hamcrest. CoreMatchers. is ( item ) )



************************************
************************************
[+] input: sameSizeDifferentItems() { final List<PlayQueueItem> streams1 = Collections.nCopies(5, item1); final List<PlayQueueItem> streams2 = Collections.nCopies(5, item2); final PlayQueue queue1 = makePlayQueue(0, streams1); final PlayQueue queue2 = makePlayQueue(0, streams2); "<AssertPlaceHolder>"; }
equalStreams(@Nullable final PlayQueue other) { if (other == null) { return false; } if (size() != other.size()) { return false; } for (int i = 0; i < size(); i++) { final PlayQueueItem stream = streams.get(i); final PlayQueueItem otherStream = other.streams.get(i); // Check is based on serviceId and URL if (stream.getServiceId() != otherStream.getServiceId() || !stream.getUrl().equals(otherStream.getUrl())) { return false; } } return true; }
[*] target: assertFalse(queue1.equalStreams(queue2))
[-] pred: org. junit. Assert. assertTrue ( streams1. equalStreams(@Nullable final PlayQueueQueue2 ) )



************************************
************************************
[+] input: differentSizeStreams() { final List<PlayQueueItem> streams1 = Collections.nCopies(5, item1); final List<PlayQueueItem> streams2 = Collections.nCopies(6, item2); final PlayQueue queue1 = makePlayQueue(0, streams1); final PlayQueue queue2 = makePlayQueue(0, streams2); "<AssertPlaceHolder>"; }
equalStreams(@Nullable final PlayQueue other) { if (other == null) { return false; } if (size() != other.size()) { return false; } for (int i = 0; i < size(); i++) { final PlayQueueItem stream = streams.get(i); final PlayQueueItem otherStream = other.streams.get(i); // Check is based on serviceId and URL if (stream.getServiceId() != otherStream.getServiceId() || !stream.getUrl().equals(otherStream.getUrl())) { return false; } } return true; }
[*] target: assertFalse(queue1.equalStreams(queue2))
[-] pred: org. junit. Assert. assertTrue ( streams1. equalStreams(@Nullable final PlayQueueQueue2 ) )



************************************
************************************
[+] input: testInvalidRead() { final List<String> invalidList = Arrays.asList( "{"notTabsArray":[]}", "{invalidJSON]}", "{}" );  for (final String invalidContent : invalidList) { try { TabsJsonHelper.getTabsFromJson(invalidContent);  fail("didn't throw exception"); } catch (final Exception e) { final boolean isExpectedException = e instanceof TabsJsonHelper.InvalidJsonException; "<AssertPlaceHolder>"; } } }
getTabsFromJson(@Nullable final String tabsJson) throws InvalidJsonException { if (tabsJson == null || tabsJson.isEmpty()) { return getDefaultTabs(); }  final List<Tab> returnTabs = new ArrayList<>();  final JsonObject outerJsonObject; try { outerJsonObject = JsonParser.object().from(tabsJson);  if (!outerJsonObject.has(JSON_TABS_ARRAY_KEY)) { throw new InvalidJsonException("JSON doesn't contain "" + JSON_TABS_ARRAY_KEY + "" array"); }  final JsonArray tabsArray = outerJsonObject.getArray(JSON_TABS_ARRAY_KEY);  for (final Object o : tabsArray) { if (!(o instanceof JsonObject)) { continue; }  final Tab tab = Tab.from((JsonObject) o);  if (tab != null) { returnTabs.add(tab); } } } catch (final JsonParserException e) { throw new InvalidJsonException(e); }  if (returnTabs.isEmpty()) { return getDefaultTabs(); }  return returnTabs; }
[*] target: assertTrue(""" + e.getClass().getSimpleName() + "" is not the expected exception", isExpectedException)
[-] pred: org. junit. Assert. assertTrue ( isExpectedException )



************************************
************************************
[+] input: test17() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("丁丑", new EightChar("己丑", "戊辰", "戊辰", "甲子").getOwnSign().getName())
[-] pred: org. junit. Assert. assertNull ( context. getName() ( ) )



************************************
************************************
[+] input: test18() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("乙卯", new EightChar("戊戌", "庚申", "丁亥", "丙午").getOwnSign().getName())
[-] pred: org. junit. Assert. assertNull ( context. getName() ( ) )



************************************
************************************
[+] input: test19() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("甲戌", new EightChar(SixtyCycle.fromName("甲子"), SixtyCycle.fromName("壬申"), null, SixtyCycle.fromName("乙亥")).getOwnSign().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( element ) )



************************************
************************************
[+] input: test21() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("庚子", new EightChar(SixtyCycle.fromName("辛亥"), SixtyCycle.fromName("乙未"), null, SixtyCycle.fromName("甲辰")).getBodySign().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( element ) )



************************************
************************************
[+] input: test22() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("丙寅", ChildLimit.fromSolarTime(SolarTime.fromYmdHms(1990, 1, 27, 0, 0, 0), Gender.MAN).getEightChar().getBodySign().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( name ) )



************************************
************************************
[+] input: test23() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("甲戌", ChildLimit.fromSolarTime(SolarTime.fromYmdHms(2019, 3, 7, 8, 0, 0), Gender.MAN).getEightChar().getOwnSign().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( name ) )



************************************
************************************
[+] input: test24() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("丁丑", ChildLimit.fromSolarTime(SolarTime.fromYmdHms(2019, 3, 27, 2, 0, 0), Gender.MAN).getEightChar().getOwnSign().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( element ) )



************************************
************************************
[+] input: test25() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("丙寅", LunarHour.fromYmdHms(1994, 5, 20, 18, 0, 0).getEightChar().getOwnSign().getName())
[-] pred: org. junit. Assert. assertNull ( context. getName() ( ) )



************************************
************************************
[+] input: test26() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("己丑", SolarTime.fromYmdHms(1986, 5, 29, 13, 37, 0).getLunarHour().getEightChar().getBodySign().getName())
[-] pred: org. junit. Assert. assertNull ( context. getName() ( ) )



************************************
************************************
[+] input: test27() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("乙丑", SolarTime.fromYmdHms(1994, 12, 6, 2, 0, 0).getLunarHour().getEightChar().getBodySign().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( name ) )



************************************
************************************
[+] input: test28() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("辛卯", new EightChar("辛亥", "丁酉", "丙午", "癸巳").getOwnSign().getName())
[-] pred: org. junit. Assert. assertNull ( context. getName() ( ) )



************************************
************************************
[+] input: test30() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("乙巳", new EightChar("壬子", "辛亥", "壬戌", "乙巳").getBodySign().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( name ) )



************************************
************************************
[+] input: test31() { List<SolarTime> solarTimes = new EightChar("丙辰", "丁酉", "丙子", "甲午").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1916年10月6日 12:00:00"); expected.add("1976年9月21日 12:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: test32() { List<SolarTime> solarTimes = new EightChar("壬寅", "庚戌", "己未", "乙亥").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("2022年11月2日 22:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: test33() { List<SolarTime> solarTimes = new EightChar("己卯", "辛未", "甲戌", "壬申").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1939年8月5日 16:00:00"); expected.add("1999年7月21日 16:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: test34() { List<SolarTime> solarTimes = new EightChar("庚子", "戊子", "己卯", "庚午").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1901年1月1日 12:00:00"); expected.add("1960年12月17日 12:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: test35() { List<SolarTime> solarTimes = new EightChar("庚子", "癸未", "乙丑", "丁亥").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1960年8月5日 22:00:00"); expected.add("2020年7月21日 22:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: test36() { List<SolarTime> solarTimes = new EightChar("癸卯", "甲寅", "甲寅", "甲子").getSolarTimes(1800, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1843年2月9日 00:00:00"); expected.add("2023年2月25日 00:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: test37() { List<SolarTime> solarTimes = new EightChar("甲辰", "丙寅", "己亥", "戊辰").getSolarTimes(1800, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1964年2月20日 08:00:00"); expected.add("2024年2月5日 08:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: test38() { List<SolarTime> solarTimes = new EightChar("己亥", "丁丑", "壬寅", "戊申").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1900年1月29日 16:00:00"); expected.add("1960年1月15日 16:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: test39() { List<SolarTime> solarTimes = new EightChar("己亥", "丙子", "癸酉", "庚申").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1959年12月17日 16:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: test40() { List<SolarTime> solarTimes = new EightChar("丁丑", "癸卯", "癸丑", "辛酉").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1937年3月27日 18:00:00"); expected.add("1997年3月12日 18:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: test41() { List<SolarTime> solarTimes = new EightChar("乙未", "己卯", "丁丑", "甲辰").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1955年3月17日 08:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )



************************************
************************************
[+] input: test42() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%s %s %s %s", year, month, day, hour); }
[*] target: assertEquals("壬申", new EightChar("甲辰", "丙寅", "己亥", "辛未").getOwnSign().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( name ) )



************************************
************************************
[+] input: test0() { Assert."<AssertPlaceHolder>"; }
getRestrain() { return next(2); }
[*] target: assertEquals(Element.fromName("木"), Element.fromName("金").getRestrain())
[-] pred: org. junit. Assert. assertFalse ( script. getRestrain() ( ). isEmpty ( ) )



************************************
************************************
[+] input: test1() { Assert."<AssertPlaceHolder>"; }
getReinforce() { return next(1); }
[*] target: assertEquals(Element.fromName("土"), Element.fromName("火").getReinforce())
[-] pred: org. junit. Assert. assertEquals ( 1, instance. getReinforce() ( ) )



************************************
************************************
[+] input: test4() { Assert."<AssertPlaceHolder>"; }
getReinforced() { return next(-1); }
[*] target: assertEquals(Element.fromName("火"), Element.fromName("土").getReinforced())
[-] pred: org. junit. Assert. assertEquals ( element, object. getReinforced() ( ) )



************************************
************************************
[+] input: test0() { Assert."<AssertPlaceHolder>"; }
getSolarDay() { int d = (int) (this.day + 0.5); double f = this.day + 0.5 - d;  if (d >= 2299161) { int c = (int) ((d - 1867216.25) / 36524.25); d += 1 + c - (int) (c * 1D / 4); } d += 1524; int year = (int) ((d - 122.1) / 365.25); d -= (int) (365.25 * year); int month = (int) (d * 1D / 30.601); d -= (int) (30.601 * month); int day = d; if (month > 13) { month -= 13; year -= 4715; } else { month -= 1; year -= 4716; } f *= 24; int hour = (int) f;  f -= hour; f *= 60; int minute = (int) f;  f -= minute; f *= 60; int second = (int) Math.round(f); if (second > 59) { minute++; } if (minute > 59) { hour++; } if (hour > 23) { day += 1; } return SolarDay.fromYmd(year, month, day); }
[*] target: assertEquals("2023年1月1日", SolarDay.fromYmd(2023, 1, 1).getJulianDay().getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( 12, getSolarDay(). getSolarDay() ( ) )



************************************
************************************
[+] input: test1() { LegalHoliday d = LegalHoliday.fromYmd(2010, 1, 1); Assert."<AssertPlaceHolder>"; }
fromYmd(int year, int month, int day) { Matcher matcher = Pattern.compile(String.format("%04d%02d%02d[0-1][0-8][\\+|-]\\d{2}", year, month, day)).matcher(DATA); return !matcher.find() ? null : new LegalHoliday(year, month, day, matcher.group()); }
[*] target: assertNotNull(d)
[-] pred: org. junit. Assert. assertNotNull ( d )



************************************
************************************
[+] input: test2() { LegalHoliday d = LegalHoliday.fromYmd(2010, 1, 1); Assert."<AssertPlaceHolder>"; }
fromYmd(int year, int month, int day) { Matcher matcher = Pattern.compile(String.format("%04d%02d%02d[0-1][0-8][\\+|-]\\d{2}", year, month, day)).matcher(DATA); return !matcher.find() ? null : new LegalHoliday(year, month, day, matcher.group()); }
[*] target: assertNotNull(d)
[-] pred: org. junit. Assert. assertNotNull ( d )



************************************
************************************
[+] input: test1() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("1年1月1日", LunarDay.fromYmd(0, 11, 18).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test2() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("9999年12月31日", LunarDay.fromYmd(9999, 12, 2).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test3() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("1905年2月4日", LunarDay.fromYmd(1905, 1, 1).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test4() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("2039年1月23日", LunarDay.fromYmd(2038, 12, 29).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test5() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("1500年1月31日", LunarDay.fromYmd(1500, 1, 1).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test6() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("1501年1月18日", LunarDay.fromYmd(1500, 12, 29).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test7() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("1582年10月4日", LunarDay.fromYmd(1582, 9, 18).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test8() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("1582年10月15日", LunarDay.fromYmd(1582, 9, 19).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test9() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("2020年1月6日", LunarDay.fromYmd(2019, 12, 12).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test10() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("2033年12月22日", LunarDay.fromYmd(2033, -11, 1).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test11() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("2021年7月16日", LunarDay.fromYmd(2021, 6, 7).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test12() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("2034年2月19日", LunarDay.fromYmd(2034, 1, 1).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test13() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("2034年1月20日", LunarDay.fromYmd(2033, 12, 1).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test14() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("7013年12月24日", LunarDay.fromYmd(7013, -11, 4).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test15() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("己亥", LunarDay.fromYmd(2023, 8, 24).getSixtyCycle().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test16() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("癸酉", LunarDay.fromYmd(1653, 1, 6).getSixtyCycle().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test17() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("农历庚寅年二月初二", LunarDay.fromYmd(2010, 1, 1).next(31).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test18() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("农历壬辰年闰四月初一", LunarDay.fromYmd(2012, 3, 1).next(60).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test19() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("农历壬辰年闰四月廿九", LunarDay.fromYmd(2012, 3, 1).next(88).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test20() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("农历壬辰年五月初一", LunarDay.fromYmd(2012, 3, 1).next(89).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test21() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("2020年4月23日", LunarDay.fromYmd(2020, 4, 1).getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test22() { Assert."<AssertPlaceHolder>"; }
getName() { return NAMES[day - 1]; }
[*] target: assertEquals("甲辰", LunarDay.fromYmd(2024, 1, 1).getLunarMonth().getLunarYear().getSixtyCycle().getName())
[-] pred: org. junit. Assert. assertEquals ( name, container. getName() ( ) )



************************************
************************************
[+] input: test23() { Assert."<AssertPlaceHolder>"; }
getName() { return NAMES[day - 1]; }
[*] target: assertEquals("癸卯", LunarDay.fromYmd(2023, 12, 30).getLunarMonth().getLunarYear().getSixtyCycle().getName())
[-] pred: org. junit. Assert. assertEquals ( name, container. getName() ( ) )



************************************
************************************
[+] input: test27() { LunarDay lunar = LunarDay.fromYmd(2024, 1, 1); Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("农历甲辰年二月初三", lunar.next(31).toString())
[-] pred: org. junit. Assert. assertNotNull ( lunar. toString ( ) )



************************************
************************************
[+] input: test0() { Assert."<AssertPlaceHolder>"; }
getName() { return (leap ? "闰" : "") + NAMES[month - 1]; }
[*] target: assertEquals("七月", LunarMonth.fromYm(2359, 7).getName())
[-] pred: org. junit. Assert. assertNull ( e. getName() ( ) )



************************************
************************************
[+] input: test1() { Assert."<AssertPlaceHolder>"; }
getName() { return (leap ? "闰" : "") + NAMES[month - 1]; }
[*] target: assertEquals("闰七月", LunarMonth.fromYm(2359, -7).getName())
[-] pred: org. junit. Assert. assertEquals ( name, event. getName() ( ) )



************************************
************************************
[+] input: test2() { Assert."<AssertPlaceHolder>"; }
getDayCount() { return dayCount; }
[*] target: assertEquals(29, LunarMonth.fromYm(2023, 6).getDayCount())
[-] pred: org. junit. Assert. assertEquals ( 1, instance. getDayCount() ( ) )



************************************
************************************
[+] input: test3() { Assert."<AssertPlaceHolder>"; }
getDayCount() { return dayCount; }
[*] target: assertEquals(30, LunarMonth.fromYm(2023, 7).getDayCount())
[-] pred: org. junit. Assert. assertEquals ( 1, instance. getDayCount() ( ) )



************************************
************************************
[+] input: test4() { Assert."<AssertPlaceHolder>"; }
getDayCount() { return dayCount; }
[*] target: assertEquals(30, LunarMonth.fromYm(2023, 8).getDayCount())
[-] pred: org. junit. Assert. assertEquals ( 1, java. lang. Long. valueOf ( 6 ). getDayCount() ( ) )



************************************
************************************
[+] input: test5() { Assert."<AssertPlaceHolder>"; }
getDayCount() { return dayCount; }
[*] target: assertEquals(29, LunarMonth.fromYm(2023, 9).getDayCount())
[-] pred: org. junit. Assert. assertEquals ( 1, instance. getDayCount() ( ) )



************************************
************************************
[+] input: test6() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("2023年10月15日", LunarMonth.fromYm(2023, 9).getFirstJulianDay().getSolarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test7() { Assert."<AssertPlaceHolder>"; }
getName() { return (leap ? "闰" : "") + NAMES[month - 1]; }
[*] target: assertEquals("甲寅", LunarMonth.fromYm(2023, 1).getSixtyCycle().getName())
[-] pred: org. junit. Assert. assertEquals ( name, event. getName() ( ) )



************************************
************************************
[+] input: test8() { Assert."<AssertPlaceHolder>"; }
getName() { return (leap ? "闰" : "") + NAMES[month - 1]; }
[*] target: assertEquals("丙辰", LunarMonth.fromYm(2023, -2).getSixtyCycle().getName())
[-] pred: org. junit. Assert. assertEquals ( name, event. getName() ( ) )



************************************
************************************
[+] input: test9() { Assert."<AssertPlaceHolder>"; }
getName() { return (leap ? "闰" : "") + NAMES[month - 1]; }
[*] target: assertEquals("丁巳", LunarMonth.fromYm(2023, 3).getSixtyCycle().getName())
[-] pred: org. junit. Assert. assertNull ( e. getName() )



************************************
************************************
[+] input: test10() { Assert."<AssertPlaceHolder>"; }
getName() { return (leap ? "闰" : "") + NAMES[month - 1]; }
[*] target: assertEquals("丙寅", LunarMonth.fromYm(2024, 1).getSixtyCycle().getName())
[-] pred: org. junit. Assert. assertEquals ( name, event. getName() ( ) )



************************************
************************************
[+] input: test11() { Assert."<AssertPlaceHolder>"; }
getName() { return (leap ? "闰" : "") + NAMES[month - 1]; }
[*] target: assertEquals("丙寅", LunarMonth.fromYm(2023, 12).getSixtyCycle().getName())
[-] pred: org. junit. Assert. assertNull ( e. getName() ( ) )



************************************
************************************
[+] input: test12() { Assert."<AssertPlaceHolder>"; }
getName() { return (leap ? "闰" : "") + NAMES[month - 1]; }
[*] target: assertEquals("壬寅", LunarMonth.fromYm(2022, 1).getSixtyCycle().getName())
[-] pred: org. junit. Assert. assertNull ( e. getName() ( ) )



************************************
************************************
[+] input: test13() { Assert."<AssertPlaceHolder>"; }
getName() { return (leap ? "闰" : "") + NAMES[month - 1]; }
[*] target: assertEquals("闰十二月", LunarMonth.fromYm(37, -12).getName())
[-] pred: org. junit. Assert. assertEquals ( name, event. getName() ( ) )



************************************
************************************
[+] input: test14() { Assert."<AssertPlaceHolder>"; }
getName() { return (leap ? "闰" : "") + NAMES[month - 1]; }
[*] target: assertEquals("闰十二月", LunarMonth.fromYm(5552, -12).getName())
[-] pred: org. junit. Assert. assertNull ( e. getName() ( ) )



************************************
************************************
[+] input: test15() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历戊子年十二月", LunarMonth.fromYm(2008, 11).next(1).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), converter. toString ( ) )



************************************
************************************
[+] input: test16() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历己丑年正月", LunarMonth.fromYm(2008, 11).next(2).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), converter. toString ( ) )



************************************
************************************
[+] input: test17() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历己丑年五月", LunarMonth.fromYm(2008, 11).next(6).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test18() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历己丑年闰五月", LunarMonth.fromYm(2008, 11).next(7).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), converter. toString ( ) )



************************************
************************************
[+] input: test19() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历己丑年六月", LunarMonth.fromYm(2008, 11).next(8).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test20() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历庚寅年正月", LunarMonth.fromYm(2008, 11).next(15).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test21() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历戊子年十一月", LunarMonth.fromYm(2008, 12).next(-1).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test22() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历戊子年十一月", LunarMonth.fromYm(2009, 1).next(-2).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), converter. toString ( ) )



************************************
************************************
[+] input: test23() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历戊子年十一月", LunarMonth.fromYm(2009, 5).next(-6).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), converter. toString ( ) )



************************************
************************************
[+] input: test24() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历戊子年十一月", LunarMonth.fromYm(2009, -5).next(-7).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test25() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历戊子年十一月", LunarMonth.fromYm(2009, 6).next(-8).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), converter. toString ( ) )



************************************
************************************
[+] input: test26() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("农历戊子年十一月", LunarMonth.fromYm(2010, 1).next(-15).toString())
[-] pred: org. junit. Assert. assertTrue ( true )



************************************
************************************
[+] input: test27() { Assert."<AssertPlaceHolder>"; }
getDayCount() { return dayCount; }
[*] target: assertEquals(29, LunarMonth.fromYm(2012, -4).getDayCount())
[-] pred: org. junit. Assert. assertEquals ( 1, dayCount(). getDayCount() ( ) )



************************************
************************************
[+] input: test28() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("癸亥", LunarMonth.fromYm(2023, 9).getSixtyCycle().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), converter. toString ( ) )



************************************
************************************
[+] input: test40() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("庚申", LunarDay.fromYmd(2018, 6, 26).getMonthSixtyCycle().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), converter. toString ( ) )



************************************
************************************
[+] input: test41() { Assert."<AssertPlaceHolder>"; }
toString() { return year + getName(); }
[*] target: assertEquals("辛丑", LunarMonth.fromYm(1991, 12).getSixtyCycle().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), converter. toString ( ) )



************************************
************************************
[+] input: test0() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("农历癸卯年", LunarYear.fromYear(2023).getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""foo"" ) )



************************************
************************************
[+] input: test1() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("农历戊申年", LunarYear.fromYear(2023).next(5).getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""foo"" ) )



************************************
************************************
[+] input: test2() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("农历戊戌年", LunarYear.fromYear(2023).next(-5).getName())
[-] pred: org. junit. Assert. assertThat ( test2, org. hamcrest. CoreMatchers. is ( ""test"" ) )



************************************
************************************
[+] input: test3() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("庚子", LunarYear.fromYear(2020).getSixtyCycle().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""foo"" ) )



************************************
************************************
[+] input: test4() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("虎", LunarYear.fromYear(1986).getSixtyCycle().getEarthBranch().getZodiac().getName())
[-] pred: org. junit. Assert. assertThat ( org. hamcrest. CoreMatchers. is ( ""test"" ) )



************************************
************************************
[+] input: test5() { Assert."<AssertPlaceHolder>"; }
getLeapMonth() { if (year == -1) { return 11; } for (Map.Entry<Integer, List<Integer>> entry : LEAP.entrySet()) { if (entry.getValue().contains(year)) { return entry.getKey(); } } return 0; }
[*] target: assertEquals(12, LunarYear.fromYear(151).getLeapMonth())
[-] pred: org. junit. Assert. assertEquals ( 11;, provider. getLeapMonth() ( ) )



************************************
************************************
[+] input: test6() { Assert."<AssertPlaceHolder>"; }
getLeapMonth() { if (year == -1) { return 11; } for (Map.Entry<Integer, List<Integer>> entry : LEAP.entrySet()) { if (entry.getValue().contains(year)) { return entry.getKey(); } } return 0; }
[*] target: assertEquals(1, LunarYear.fromYear(2357).getLeapMonth())
[-] pred: org. junit. Assert. assertEquals ( 11;, provider. getLeapMonth() ( ) )



************************************
************************************
[+] input: test8() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("上元", LunarYear.fromYear(1864).getTwenty().getSixty().getName())
[-] pred: org. junit. Assert. assertThat ( org. hamcrest. CoreMatchers. is ( ""test"" ) )



************************************
************************************
[+] input: test9() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("上元", LunarYear.fromYear(1923).getTwenty().getSixty().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( """" ) )



************************************
************************************
[+] input: test10() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("中元", LunarYear.fromYear(1924).getTwenty().getSixty().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""test"" ) )



************************************
************************************
[+] input: test11() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("中元", LunarYear.fromYear(1983).getTwenty().getSixty().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""foo"" ) )



************************************
************************************
[+] input: test12() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("下元", LunarYear.fromYear(1984).getTwenty().getSixty().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""12"" ) )



************************************
************************************
[+] input: test13() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("下元", LunarYear.fromYear(2043).getTwenty().getSixty().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""name"" ) )



************************************
************************************
[+] input: test14() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("一运", LunarYear.fromYear(1864).getTwenty().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""foo"" ) )



************************************
************************************
[+] input: test15() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("一运", LunarYear.fromYear(1883).getTwenty().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""test"" ) )



************************************
************************************
[+] input: test16() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("二运", LunarYear.fromYear(1884).getTwenty().getName())
[-] pred: org. junit. Assert. assertThat ( org. hamcrest. CoreMatchers. is ( ""a"" ) )



************************************
************************************
[+] input: test17() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("二运", LunarYear.fromYear(1903).getTwenty().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""foo"" ) )



************************************
************************************
[+] input: test18() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("三运", LunarYear.fromYear(1904).getTwenty().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""foo"" ) )



************************************
************************************
[+] input: test19() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("三运", LunarYear.fromYear(1923).getTwenty().getName())
[-] pred: org. junit. Assert. assertThat ( org. hamcrest. CoreMatchers. is ( ""foo"" ) )



************************************
************************************
[+] input: test20() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("农历%s年", getSixtyCycle()); }
[*] target: assertEquals("八运", LunarYear.fromYear(2004).getTwenty().getName())
[-] pred: org. junit. Assert. assertThat ( context. getName(), org. hamcrest. CoreMatchers. is ( ""test"" ) )



************************************
************************************
[+] input: test4() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("1582年10月4日", SolarDay.fromYmd(1582, 10, 15).next(-1).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test5() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("2000年3月1日", SolarDay.fromYmd(2000, 2, 28).next(2).toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test6() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("农历庚子年闰四月初二", SolarDay.fromYmd(2020, 5, 24).getLunarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test8() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("农历丙子年十一月十二", SolarDay.fromYmd(16, 11, 30).getLunarDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test9() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("霜降", SolarDay.fromYmd(2023, 10, 27).getTerm().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test10() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("豺乃祭兽第4天", SolarDay.fromYmd(2023, 10, 27).getPhenologyDay().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test11() { Assert."<AssertPlaceHolder>"; }
toString() { return month + getName(); }
[*] target: assertEquals("初候", SolarDay.fromYmd(2023, 10, 27).getPhenologyDay().getPhenology().getThreePhenology().toString())
[-] pred: org. junit. Assert. assertEquals ( java. lang. String. valueOf ( 1 ), e. toString ( ) )



************************************
************************************
[+] input: test22() { Assert."<AssertPlaceHolder>"; }
getName() { return NAMES[day - 1]; }
[*] target: assertEquals("甲辰", SolarDay.fromYmd(2024, 2, 10).getLunarDay().getLunarMonth().getLunarYear().getSixtyCycle().getName())
[-] pred: org. junit. Assert. assertEquals ( name, container. getName() ( ) )



************************************
************************************
[+] input: test23() { Assert."<AssertPlaceHolder>"; }
getName() { return NAMES[day - 1]; }
[*] target: assertEquals("癸卯", SolarDay.fromYmd(2024, 2, 9).getLunarDay().getLunarMonth().getLunarYear().getSixtyCycle().getName())
[-] pred: org. junit. Assert. assertEquals ( name, container. getName() ( ) )



************************************
************************************
[+] input: test6() { SolarFestival f = SolarDay.fromYmd(1939, 5, 4).getFestival(); Assert."<AssertPlaceHolder>"; }
fromYmd(int year, int month, int day) { Matcher matcher = Pattern.compile(String.format("@\\d{2}0%02d%02d\\d+", month, day)).matcher(DATA); if (!matcher.find()) { return null; } String data = matcher.group(); int startYear = Integer.parseInt(data.substring(8), 10); return year < startYear ? null : new SolarFestival(FestivalType.DAY, SolarDay.fromYmd(year, month, day), startYear, data); }
[*] target: assertNull(f)
[-] pred: org. junit. Assert. assertNotNull ( f )



************************************
************************************
[+] input: test0() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%d年", year); }
[*] target: assertEquals("2023年", SolarYear.fromYear(2023).getName())
[-] pred: org. junit. Assert. assertNull ( component. getName() )



************************************
************************************
[+] input: test1() { Assert."<AssertPlaceHolder>"; }
isLeap() { if (year < 1600) { return year % 4 == 0; } return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0); }
[*] target: assertFalse(SolarYear.fromYear(2023).isLeap())
[-] pred: org. junit. Assert. assertFalse ( ss. isLeap() ( ) )



************************************
************************************
[+] input: test2() { Assert."<AssertPlaceHolder>"; }
isLeap() { if (year < 1600) { return year % 4 == 0; } return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0); }
[*] target: assertTrue(SolarYear.fromYear(1500).isLeap())
[-] pred: org. junit. Assert. assertFalse ( test2. isLeap() ( ) )



************************************
************************************
[+] input: test3() { Assert."<AssertPlaceHolder>"; }
isLeap() { if (year < 1600) { return year % 4 == 0; } return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0); }
[*] target: assertFalse(SolarYear.fromYear(1700).isLeap())
[-] pred: org. junit. Assert. assertFalse ( test. isLeap() ( ) )



************************************
************************************
[+] input: test4() { Assert."<AssertPlaceHolder>"; }
getDayCount() { if (1582 == year) { return 355; } return isLeap() ? 366 : 365; }
[*] target: assertEquals(365, SolarYear.fromYear(2023).getDayCount())
[-] pred: org. junit. Assert. assertEquals ( 8, instance. getDayCount() ( ) )



************************************
************************************
[+] input: test5() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%d年", year); }
[*] target: assertEquals("2028年", SolarYear.fromYear(2023).next(5).getName())
[-] pred: org. junit. Assert. assertNull ( component. getName() )



************************************
************************************
[+] input: test6() { Assert."<AssertPlaceHolder>"; }
getName() { return String.format("%d年", year); }
[*] target: assertEquals("2018年", SolarYear.fromYear(2023).next(-5).getName())
[-] pred: org. junit. Assert. assertNull ( component. getName() )



************************************
************************************
[+] input: prettyHexEmptyByteArray() { "<AssertPlaceHolder>"; }
prettyHex(byte[] data) { return prettyHex(data, 0, data.length); }
[*] target: assertEquals("", ByteArrayUtils.prettyHex(new byte[0]))
[-] pred: org. junit. Assert. assertNull ( prettyHex(data, 0, data.length);. prettyHex(byte[] data) )



************************************
************************************
[+] input: serializationOfString() { "<AssertPlaceHolder>"; }
serialize(Object obj) { try (final ByteArrayOutputStream bos = new ByteArrayOutputStream()) { try (final ObjectOutputStream oos = new ObjectOutputStream(bos)) { oos.writeObject(obj); } return bos.toByteArray(); } catch (IOException e) { throw new RuntimeException("Unexpected IO exception", e); } }
[*] target: assertEquals("Hello world!", ObjectUtils.deserialize(ObjectUtils.serialize("Hello world!")))
[-] pred: org. junit. Assert. assertEquals ( 1, s. serialize(Object obj ) )



************************************
************************************
[+] input: serializationOfStringUsingCustomLoader() { "<AssertPlaceHolder>"; }
serialize(Object obj) { try (final ByteArrayOutputStream bos = new ByteArrayOutputStream()) { try (final ObjectOutputStream oos = new ObjectOutputStream(bos)) { oos.writeObject(obj); } return bos.toByteArray(); } catch (IOException e) { throw new RuntimeException("Unexpected IO exception", e); } }
[*] target: assertEquals("Hello world!", ObjectUtils.deserialize( ObjectUtils.serialize("Hello world!"), getClass().getClassLoader(), String.class ))
[-] pred: org. junit. Assert. assertEquals ( 1, s. serialize(Object obj ) )



************************************
************************************
[+] input: shouldDeriveEncryptionKey() { "<AssertPlaceHolder>"; }
deriveEnc(byte[] seed, byte[] nonce) { final MessageDigest md = DigestUtils.digest("SHA-256"); md.update(seed); if (nonce != null) md.update(nonce); md.update(new byte[] {0, 0, 0, 1}); return Arrays.copyOfRange(md.digest(), 0, 32); }
[*] target: assertEquals( "SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS", ByteArrayUtils.prettyHex(AESSecureMessaging.deriveEnc(Hex.decode("CA"), null)) )
[-] pred: org. junit. Assert. assertNotNull ( dao. deriveEnc(byte[] seed, byte[] nonce) )



************************************
************************************
[+] input: shouldDeriveEncryptionKeyWithNonce() { "<AssertPlaceHolder>"; }
deriveEnc(byte[] seed, byte[] nonce) { final MessageDigest md = DigestUtils.digest("SHA-256"); md.update(seed); if (nonce != null) md.update(nonce); md.update(new byte[] {0, 0, 0, 1}); return Arrays.copyOfRange(md.digest(), 0, 32); }
[*] target: assertEquals( "SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS", ByteArrayUtils.prettyHex(AESSecureMessaging.deriveEnc(Hex.decode("CA"), Hex.decode("FE"))) )
[-] pred: org. junit. Assert. assertNotNull ( impl. deriveEnc(byte[] seed, byte[] nonce) )



************************************
************************************
[+] input: shouldDeriveMacKey() { "<AssertPlaceHolder>"; }
deriveMac(byte[] seed, byte[] nonce) { final MessageDigest md = DigestUtils.digest("SHA-256"); md.update(seed); if (nonce != null) md.update(nonce); md.update(new byte[] {0, 0, 0, 2}); return Arrays.copyOfRange(md.digest(), 0, 32); }
[*] target: assertEquals( "SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS", ByteArrayUtils.prettyHex(AESSecureMessaging.deriveMac(Hex.decode("CA"), null)) )
[-] pred: org. junit. Assert. assertArrayEquals ( new byte [ ] { 0, 1, 2 }, metadata. deriveMac(byte[] seed, byte[] nonce) )



************************************
************************************
[+] input: shouldDeriveMacKeyWithNonce() { "<AssertPlaceHolder>"; }
deriveMac(byte[] seed, byte[] nonce) { final MessageDigest md = DigestUtils.digest("SHA-256"); md.update(seed); if (nonce != null) md.update(nonce); md.update(new byte[] {0, 0, 0, 2}); return Arrays.copyOfRange(md.digest(), 0, 32); }
[*] target: assertEquals( "SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS", ByteArrayUtils.prettyHex(AESSecureMessaging.deriveMac(Hex.decode("CA"), Hex.decode("FE"))) )
[-] pred: org. junit. Assert. assertFalse ( ctx. deriveMac(byte[] seed, byte[] nonce) )



************************************
************************************
[+] input: shouldDeriveEncryptionKey() { "<AssertPlaceHolder>"; }
deriveEnc(byte[] seed, int offset, int length) { final MessageDigest md = DigestUtils.digest("SHA1"); md.update(seed, offset, length); md.update(new byte[] {0, 0, 0, 1}); return Arrays.copyOfRange(md.digest(), 0, 16); }
[*] target: assertEquals( "SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS", ByteArrayUtils.prettyHex(TDEASecureMessaging.deriveEnc( Hex.decode("SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"),0, 16) ) )
[-] pred: org. junit. Assert. assertNotNull ( dao. deriveEnc(byte[] seed, offset, length) )



************************************
************************************
[+] input: shouldDeriveMacKey() { "<AssertPlaceHolder>"; }
deriveMac(byte[] seed, int offset, int length) { final MessageDigest md = DigestUtils.digest("SHA1"); md.update(seed, offset, length); md.update(new byte[] {0, 0, 0, 2}); return Arrays.copyOfRange(md.digest(), 0, 16); }
[*] target: assertEquals( "SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS", ByteArrayUtils.prettyHex(TDEASecureMessaging.deriveMac( Hex.decode("SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS"),0, 16) ) )
[-] pred: org. junit. Assert. assertArrayEquals ( new byte [ ] { 0, 1, 2, 0, 16 }, obj. deriveMac(byte[] seed, int offset, int length ) )



************************************
************************************
[+] input: shouldCallPostConstructAfterConstruction() { final byte[] data = new byte[] { 0x30, 3, 0x02, 1, 31 }; "<AssertPlaceHolder>"; }
read(byte[] data, Class<T> type) { return read(data, 0, data.length, type); }
[*] target: assertEquals(31, mapper.read(data, ConstructedObj.class).check)
[-] pred: org. junit. Assert. assertThat ( read(byte[] data, Class<T> type), org. hamcrest. CoreMatchers. is ( data ) )



************************************
************************************
[+] input: shouldSetRawIfAsn1RawIsImplemented() { final byte[] data = new byte[] { 0x30, 3, 0x02, 1, 31 }; "<AssertPlaceHolder>"; }
read(byte[] data, Class<T> type) { return read(data, 0, data.length, type); }
[*] target: assertArrayEquals(data, mapper.read(data, RawObj.class).raw)
[-] pred: org. junit. Assert. assertEquals ( 0, read(byte[] data, Class<T>length, data.length, type) )



************************************
************************************
[+] input: IOException { "<AssertPlaceHolder>";  }
write(byte[] buffer, int offset, int length) { bos.write(buffer, offset, length); }
[*] target: assertArrayEquals(new byte[] {1, 2}, write( (o) -> o.write(new byte[] { 1, 2}, 2)))
[-] pred: org. junit. Assert. assertNull ( bos.write(byte[] buffer, offset, length);. write(byte[] buffer, offset, length) )



************************************
************************************
[+] input: IOException { "<AssertPlaceHolder>"; }
write(byte[] buffer, int offset, int length) { bos.write(buffer, offset, length); }
[*] target: assertArrayEquals(new byte[] {0, 1, 2}, write( (o) -> o.write(new byte[] { 1, 2}, 3)))
[-] pred: org. junit. Assert. assertNull ( bos.write(byte[] buffer, offset, length);. write(byte[] buffer, offset, length) )



************************************
************************************
[+] input: getLengthSingleByte() { final byte[] data = new byte[0x7f]; final byte[] obj = Arrays.concatenate(new byte[] { 0x10, (byte) 0x7f }, data); "<AssertPlaceHolder>"; }
getLength(byte[] raw) { try (final Asn1InputStream is = new Asn1InputStream(raw)) { is.readTag(); return is.readLength(); } }
[*] target: assertEquals(0x7f, Asn1Utils.getLength(obj))
[-] pred: org. junit. Assert. assertEquals ( data, obj )



************************************
************************************
[+] input: getLengthMultipleBytes() { final byte[] data = new byte[0x80]; final byte[] obj = Arrays.concatenate(new byte[] { 0x10, (byte) 0x81, (byte) 0x80 }, data); "<AssertPlaceHolder>"; }
getLength(byte[] raw) { try (final Asn1InputStream is = new Asn1InputStream(raw)) { is.readTag(); return is.readLength(); } }
[*] target: assertEquals(0x80, Asn1Utils.getLength(obj))
[-] pred: org. junit. Assert. assertEquals ( data, obj )



************************************
************************************
[+] input: getValueShouldSkipTagAndExtendedLength() { final byte[] data = new byte[0x81]; new SecureRandom().nextBytes(data); final byte[] obj = Arrays.concatenate(new byte[] { 0x10, (byte) 0x81, (byte) 0x81 }, data); "<AssertPlaceHolder>"; }
getValue(byte[] raw) { try (final Asn1InputStream is = new Asn1InputStream(raw)) { is.readTag(); return is.read(is.readLength()); } }
[*] target: assertArrayEquals(data, Asn1Utils.getValue(obj))
[-] pred: org. junit. Assert. assertSame ( data, obj )



************************************
************************************
[+] input: decodeObjectIdentifierWithDoubleBytes() { "<AssertPlaceHolder>"; }
decodeObjectIdentifier(byte[] data, int offset, int length) { final StringBuilder sb = new StringBuilder(data.length * 3); final int stop = offset + length;  boolean first = true; int carry = 0; for (int i = offset; i < stop; i++) { int v = Byte.toUnsignedInt(data[i]); if ((v & 0x80) == 0x80) { carry |= (v & 0x7f); carry <<= 7; continue; } v |= carry; if (first) { if (v < 40) { sb.append('0'); } else if (v < 80) { sb.append('1'); v -= 40; } else { sb.append('2'); v -= 80; } first = false; } sb.append('.').append(v); carry = 0; } if (carry != 0) { throw new Asn1Exception("Incomplete object identifier"); } return sb.toString(); }
[*] target: assertEquals("1.2.131", Asn1Utils.decodeObjectIdentifier(new byte[] { 0x2a, (byte) 0x81, 0x03 }))
[-] pred: org. junit. Assert. assertEquals ( true, decodeObjectIdentifier(byte[] data, int offset, int length ) )



************************************
************************************
[+] input: decodeObjectIdentifierWithTripleFirst() { "<AssertPlaceHolder>"; }
decodeObjectIdentifier(byte[] data, int offset, int length) { final StringBuilder sb = new StringBuilder(data.length * 3); final int stop = offset + length;  boolean first = true; int carry = 0; for (int i = offset; i < stop; i++) { int v = Byte.toUnsignedInt(data[i]); if ((v & 0x80) == 0x80) { carry |= (v & 0x7f); carry <<= 7; continue; } v |= carry; if (first) { if (v < 40) { sb.append('0'); } else if (v < 80) { sb.append('1'); v -= 40; } else { sb.append('2'); v -= 80; } first = false; } sb.append('.').append(v); carry = 0; } if (carry != 0) { throw new Asn1Exception("Incomplete object identifier"); } return sb.toString(); }
[*] target: assertEquals("2.2096950", Asn1Utils.decodeObjectIdentifier(new byte[] { (byte) 0xff, (byte) 0xff, 6 }))
[-] pred: org. junit. Assert. assertEquals ( 0, decodeObjectIdentifier(byte[] data, int offset, int length )



************************************
************************************
[+] input: shouldSerialize() { "<AssertPlaceHolder>"; }
serialize(Asn1OutputStream out, Class<? extends Object> type, Object instance, Asn1ObjectMapper mapper) throws IOException { writeFields(mapper, out, type, instance); }
[*] target: assertArrayEquals( new byte[] { (byte) 0x81, 1, 0x01, (byte) 0x82, 1, 0x02 }, serialize(new SetConverter(), Set.class, new Set(1, 2)) )
[-] pred: org. junit. Assert. assertFalse ( converter. serialize(Asn1OutputStream out, Class<? extends Object> type,Object instance, Asn1ObjectMapper. class ) )



************************************
************************************
[+] input: shouldEncode() { "<AssertPlaceHolder>"; }
getEncoded() { final byte[] data = new byte[2*length]; ByteArrayUtils.copyAdjustedLength(r.toByteArray(), length, data, 0); ByteArrayUtils.copyAdjustedLength(s.toByteArray(), length, data, length); return data; }
[*] target: assertArrayEquals(new byte[] { 0, 0, 0, 1, 0, 0, 0, 10}, new EcSignature(4, BigInteger.ONE, BigInteger.TEN).getEncoded())
[-] pred: org. junit. Assert. assertEquals ( 15, container. getEncoded() ( ) )



************************************
************************************
[+] input: serialization() { final EcSignature signature = new EcSignature(4, BigInteger.ONE, BigInteger.TEN); "<AssertPlaceHolder>"; }
deserialize(Asn1ObjectInputStream in) { final int length = in.length / 2; final BigInteger r = new BigInteger(1, in.read(length)); final BigInteger s = new BigInteger(1, in.read(in.length - length)); return new EcSignature(length, r, s); }
[*] target: assertEquals(signature, ObjectUtils.deserialize(ObjectUtils.serialize(signature)))
[-] pred: org. junit. Assert. assertSame ( signature, signature. deserialize(Asn1ObjectInputStream in ) )



************************************
************************************
[+] input: Exception { final LdsSecurityObject ldsSecurityObject = mapper.read( readFromCms("dl1"), LdsSecurityObject.class); "<AssertPlaceHolder>"; }
getDigests() { return digests; }
[*] target: assertEquals(ImmutableSet.of(1, 5, 6, 11, 12, 13), ldsSecurityObject.getDigests().keySet())
[-] pred: org. junit. Assert. assertEquals ( 4, ldsSecurityObject. getDigests(). size ( ) )



************************************
************************************
[+] input: Exception { final LdsSecurityObject ldsSecurityObject = mapper.read( readFromCms("dl2"), LdsSecurityObject.class); "<AssertPlaceHolder>"; }
getDigests() { return digests; }
[*] target: assertEquals(ImmutableSet.of(1, 5, 6, 11, 12, 13, 14), ldsSecurityObject.getDigests().keySet())
[-] pred: org. junit. Assert. assertEquals ( 4, ldsSecurityObject. getDigests(). size ( ) )



************************************
************************************
[+] input: Exception { final LdsSecurityObject ldsSecurityObject = mapper.read( readFromCms("rvig2011"), LdsSecurityObject.class); "<AssertPlaceHolder>"; }
getDigests() { return digests; }
[*] target: assertEquals(ImmutableSet.of(1, 2, 3, 14, 15), ldsSecurityObject.getDigests().keySet())
[-] pred: org. junit. Assert. assertEquals ( 3, ldsSecurityObject. getDigests(). size ( ) )



************************************
************************************
[+] input: Exception { final LdsSecurityObject ldsSecurityObject = mapper.read( readFromCms("rvig2014"), LdsSecurityObject.class); "<AssertPlaceHolder>"; }
getDigests() { return digests; }
[*] target: assertEquals(ImmutableSet.of(1, 2, 3, 14, 15), ldsSecurityObject.getDigests().keySet())
[-] pred: org. junit. Assert. assertEquals ( 3, ldsSecurityObject. getDigests(). size ( ) )



************************************
************************************
[+] input: Exception { final LdsSecurityObject ldsSecurityObject = mapper.read( readFromCms("pca-rvig"), LdsSecurityObject.class); "<AssertPlaceHolder>"; }
getDigests() { return digests; }
[*] target: assertEquals(ImmutableSet.of(14), ldsSecurityObject.getDigests().keySet())
[-] pred: org. junit. Assert. assertEquals ( 3, ldsSecurityObject. getDigests() ( ) )



************************************
************************************
[+] input: Exception { final ContentInfo signedMessage = ContentInfo.getInstance(fixture()); final byte[] data = new CmsVerifier(new CertificateVerifier.None()).verifyMessage( signedMessage, LdsSecurityObject.OID ); "<AssertPlaceHolder>"; }
verifyMessage(ContentInfo signedMessage, String oid) { return encapsulatedData(verify(signedMessage, null), oid); }
[*] target: assertEquals("SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS", Hex.toHexString( DigestUtils.digest("SHA1").digest(data) ))
[-] pred: org. junit. Assert. assertTrue ( verifyMessage(ContentInfo signedMessage, LdsSecurityObject.OID ) )



************************************
************************************
[+] input: shouldConvertParams() { "<AssertPlaceHolder>"; }
toDomainParameters() { return new ECDomainParameters(curve, base, curve.getOrder(), curve.getCofactor(), seed); }
[*] target: assertEquals(PARAMS, new EcParameters(PARAMS).toDomainParameters())
[-] pred: org. junit. Assert. assertSame ( root, toDomainParameters(). toDomainParameters() ( ) )



************************************
************************************
[+] input: shouldConvertSpec() { "<AssertPlaceHolder>"; }
toParameterSpec() { return new ECParameterSpec(curve, base, curve.getOrder(), curve.getCofactor(), seed); }
[*] target: assertEquals(SPEC, new EcParameters(SPEC).toParameterSpec())
[-] pred: org. junit. Assert. assertNotNull ( e. toParameterSpec(). br ( ) )



************************************
************************************
[+] input: shouldConvertPrivateFactor() { "<AssertPlaceHolder>"; }
getD() { return d; }
[*] target: assertEquals(D, new EcPrivateKey(new ECPrivateKeyParameters(D, PARAMS)).getD())
[-] pred: org. junit. Assert. assertEquals ( 3, service. getD() ( ) )



************************************
************************************
[+] input: shouldConvertPublicPoint() { "<AssertPlaceHolder>"; }
getQ() { return q; }
[*] target: assertEquals(Q, new EcPublicKey( new ECPublicKeyParameters(Q, PARAMS)).getQ())
[-] pred: org. junit. Assert. assertNotNull ( factory. getQ() ( ) )



************************************
************************************
[+] input: serviceDiscovery() { ServiceMetaInfo serviceMetaInfo = new ServiceMetaInfo(); serviceMetaInfo.setServiceName("myService"); serviceMetaInfo.setServiceVersion("1.0"); String serviceKey = serviceMetaInfo.getServiceKey(); List<ServiceMetaInfo> serviceMetaInfoList = registry.serviceDiscovery(serviceKey); Assert."<AssertPlaceHolder>"; }
serviceDiscovery(String serviceKey);
[*] target: assertNotNull(serviceMetaInfoList)
[-] pred: org. junit. Assert. assertEquals ( serviceMetaInfoList. size ( ), 4 )


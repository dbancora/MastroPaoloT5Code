[+] input: show_실패_존재하지_않는_id_입력() { // 1. 예상 데이터 Long id = -1L; Article expected = null; // 2. 실제 데이터 Article article = articleService.show(id); // 3. 비교 및 검증 "<AssertPlaceHolder>"; }
show(Long id) { return articleRepository.findById(id).orElse(null); }
[*] target: assertEquals(expected, article)
[-] pred: org. junit. Assert. assertEquals ( expected, article )
************************************
************************************
[+] input: 회원이_가족_구성원인지_확인_테스트() { // given String familyId = "familyId"; Member member = new Member( "memberId", familyId, LocalDate.now(), "name", "", "", LocalDateTime.now() ); when(memberRepository.findById(member.getId())).thenReturn(Optional.of(member));  // when boolean isFamilyMember = memberService.isFamilyMember(member.getId(), familyId);  // then "<AssertPlaceHolder>"; }
isFamilyMember(String memberId, String familyId) { Member member = getMemberByMemberId(memberId); return member.getFamilyId().equals(familyId); }
[*] target: assertTrue(isFamilyMember)
[-] pred: org. junit. Assert. assertTrue ( isFamilyMember )
************************************
************************************
[+] input: testButtonOrderConsistent() { boolean okBeforeCancel1 = SystemInfo.putOKBeforeCancel(); boolean okBeforeCancel2 = SystemInfo.putOKBeforeCancel(); "<AssertPlaceHolder>"; }
putOKBeforeCancel() { // Windows usually has "OK - Cancel" order, while macOS and Linux prefer "Cancel - OK" order return (getOperatingSystem() == OperatingSystem.WINDOWS); }
[*] target: assertEquals(okBeforeCancel1, okBeforeCancel2)
[-] pred: org. junit. Assert. assertEquals ( okBeforeCancel1, okBeforeCancel2 )
************************************
************************************
[+] input: testInsertLeftSiblingError() { boolean throwsException = false; try { buildCommand("any_method( a = 1 ).", ")").insertLeftSibling(Token.createForAbap(0, 1, " " comment", 1)); } catch(IntegrityBrokenException e) { throwsException = true; } "<AssertPlaceHolder>"; }
createForAbap(int lineBreaks, int spacesLeft, String text, int sourceLineNum) { return new Token(lineBreaks, spacesLeft, text, sourceLineNum, Language.ABAP); }
[*] target: assertTrue(throwsException)
[-] pred: org. junit. Assert. assertTrue ( throwsException )
************************************
************************************
[+] input: testInsertRightSiblingAfterLevelOpenerErr() { boolean raisedException = false; try { buildCommand("any_method( ).", 0).insertRightSibling(Token.createForAbap(0, 1, "a", 0), false); } catch (IntegrityBrokenException e) { // expected case raisedException = true; } "<AssertPlaceHolder>"; }
createForAbap(int lineBreaks, int spacesLeft, String text, int sourceLineNum) { return new Token(lineBreaks, spacesLeft, text, sourceLineNum, Language.ABAP); }
[*] target: assertTrue(raisedException)
[-] pred: org. junit. Assert. assertTrue ( raisedException )
************************************
************************************
[+] input: testInsertRightSiblingAfterFinalCommentErr() { boolean raisedException = false; try { buildCommand("a = 1. " comment", 4).insertRightSibling(Token.createForAbap(0, 1, ".", 0), false); } catch (IntegrityBrokenException e) { // expected case raisedException = true; } "<AssertPlaceHolder>"; }
createForAbap(int lineBreaks, int spacesLeft, String text, int sourceLineNum) { return new Token(lineBreaks, spacesLeft, text, sourceLineNum, Language.ABAP); }
[*] target: assertTrue(raisedException)
[-] pred: org. junit. Assert. assertTrue ( raisedException )
************************************
************************************
[+] input: testGetLoadPathsExc() { boolean exceptionThrown = false; try { persistency.getLoadPaths(FileType.SETTINGS_MAIN_TEXT); } catch (IllegalArgumentException e) { exceptionThrown = true; } "<AssertPlaceHolder>"; }
getLoadPaths(FileType fileType) { return getLoadPaths(fileType, getExistingDirs(fileType, 0)); }
[*] target: assertTrue(exceptionThrown)
[-] pred: org. junit. Assert. assertTrue ( exceptionThrown )
************************************
************************************
[+] input: testGetLoadPathExc() { boolean exceptionThrown = false; try { persistency.getLoadPath(FileType.PROFILE_TEXT); } catch (IllegalArgumentException e) { exceptionThrown = true; } "<AssertPlaceHolder>"; }
getLoadPath(FileType fileType) { return getLoadPath(fileType, 0, null); }
[*] target: assertTrue(exceptionThrown)
[-] pred: org. junit. Assert. assertTrue ( exceptionThrown )
************************************
************************************
[+] input: testGetSavePathExc() { boolean exceptionThrown = false; try { persistency.getSavePath(FileType.CODE); } catch (IllegalArgumentException e) { exceptionThrown = true; } "<AssertPlaceHolder>"; }
getSavePath(FileType fileType) { return getSavePath(fileType, ""); }
[*] target: assertTrue(exceptionThrown)
[-] pred: org. junit. Assert. assertTrue ( exceptionThrown )
************************************
************************************
[+] input: IOException { final AirbyteProtocolVersionRange targetRange = new AirbyteProtocolVersionRange(V1_0_0, V2_0_0);  final UUID source1 = UUID.randomUUID(); final UUID source2 = UUID.randomUUID(); final UUID source3 = UUID.randomUUID(); final UUID dest1 = UUID.randomUUID(); final UUID dest2 = UUID.randomUUID();  final Map<UUID, Entry<ActorType, Version>> initialActorDefinitions = Map.of( source1, Map.entry(ActorType.SOURCE, V0_0_0), source2, Map.entry(ActorType.SOURCE, V1_0_0), source3, Map.entry(ActorType.SOURCE, V2_0_0), dest1, Map.entry(ActorType.DESTINATION, V0_0_0), dest2, Map.entry(ActorType.DESTINATION, V0_0_0)); when(configRepository.getActorDefinitionToProtocolVersionMap()).thenReturn(initialActorDefinitions);  final ProtocolVersionChecker protocolVersionChecker = new ProtocolVersionChecker(jobPersistence, targetRange, configRepository, definitionsProvider); final Map<ActorType, Set<UUID>> conflicts = protocolVersionChecker.getConflictingActorDefinitions(targetRange);  final Map<ActorType, Set<UUID>> expectedConflicts = Map.of( ActorType.DESTINATION, Set.of(dest1, dest2), ActorType.SOURCE, Set.of(source1)); "<AssertPlaceHolder>"; }
getConflictingActorDefinitions(final AirbyteProtocolVersionRange targetRange) throws IOException { final Map<UUID, Map.Entry<ActorType, Version>> actorDefIdToProtocolVersion = configRepository.getActorDefinitionToProtocolVersionMap(); final Map<ActorType, Set<UUID>> conflicts = actorDefIdToProtocolVersion.entrySet().stream() // Keeping only ActorDefinitionIds that have an unsupported protocol version .filter(e -> !targetRange.isSupported(e.getValue().getValue())) // Build the ActorType -> List[ActorDefIds] map .map(e -> Map.entry(e.getValue().getKey(), e.getKey())) // Group by ActorType and transform the List<Entry<ActorType, UUID>> into a Set<UUID> .collect(Collectors.groupingBy(Entry::getKey, Collectors.collectingAndThen(Collectors.toList(), list -> list.stream().map(Entry::getValue).collect(Collectors.toSet())))); return conflicts; }
[*] target: assertEquals(expectedConflicts, conflicts)
[-] pred: org. junit. Assert. assertEquals ( expectedConflicts, conflicts )
************************************
************************************
[+] input: testProjectRemainingSourceConflicts() { final AirbyteProtocolVersionRange targetRange = new AirbyteProtocolVersionRange(V1_0_0, V2_0_0);  final UUID unrelatedSource = UUID.randomUUID(); final UUID upgradedSource = UUID.randomUUID(); final UUID notChangedSource = UUID.randomUUID(); final UUID missingSource = UUID.randomUUID(); final Set<UUID> initialConflicts = Set.of(upgradedSource, notChangedSource, missingSource);  setNewSourceDefinitions(List.of( Map.entry(unrelatedSource, V2_0_0), Map.entry(upgradedSource, V1_0_0), Map.entry(notChangedSource, V0_0_0)));  final ProtocolVersionChecker protocolVersionChecker = new ProtocolVersionChecker(jobPersistence, targetRange, configRepository, definitionsProvider); final Set<UUID> actualConflicts = protocolVersionChecker.projectRemainingConflictsAfterConnectorUpgrades(targetRange, initialConflicts, ActorType.SOURCE);  final Set<UUID> expectedConflicts = Set.of(notChangedSource, missingSource); "<AssertPlaceHolder>"; }
projectRemainingConflictsAfterConnectorUpgrades(final AirbyteProtocolVersionRange targetRange, final Set<UUID> initialConflicts, final ActorType actorType) { if (initialConflicts.isEmpty()) { return Set.of(); }  final Set<UUID> upgradedSourceDefs = getProtocolVersionsForActorDefinitions(actorType) // Keep definition ids if the protocol version will fall into the new supported range .filter(e -> initialConflicts.contains(e.getKey()) && targetRange.isSupported(e.getValue())) .map(Entry::getKey) .collect(Collectors.toSet());  // Get the set of source definitions that will still have conflict after the connector upgrades final Set<UUID> remainingConflicts = new HashSet<>(initialConflicts); remainingConflicts.removeAll(upgradedSourceDefs); return remainingConflicts; }
[*] target: assertEquals(expectedConflicts, actualConflicts)
[-] pred: org. junit. Assert. assertEquals ( expectedConflicts, actualConflicts )
************************************
************************************
[+] input: testProjectRemainingDestinationConflicts() { final AirbyteProtocolVersionRange targetRange = new AirbyteProtocolVersionRange(V1_0_0, V2_0_0);  final UUID dest1 = UUID.randomUUID(); final UUID dest2 = UUID.randomUUID(); final UUID dest3 = UUID.randomUUID(); final Set<UUID> initialConflicts = Set.of(dest1, dest2, dest3);  setNewDestinationDefinitions(List.of( Map.entry(dest1, V2_0_0), Map.entry(dest2, V1_0_0), Map.entry(dest3, V2_0_0)));  final ProtocolVersionChecker protocolVersionChecker = new ProtocolVersionChecker(jobPersistence, targetRange, configRepository, definitionsProvider); final Set<UUID> actualConflicts = protocolVersionChecker.projectRemainingConflictsAfterConnectorUpgrades(targetRange, initialConflicts, ActorType.DESTINATION);  final Set<UUID> expectedConflicts = Set.of(); "<AssertPlaceHolder>"; }
projectRemainingConflictsAfterConnectorUpgrades(final AirbyteProtocolVersionRange targetRange, final Set<UUID> initialConflicts, final ActorType actorType) { if (initialConflicts.isEmpty()) { return Set.of(); }  final Set<UUID> upgradedSourceDefs = getProtocolVersionsForActorDefinitions(actorType) // Keep definition ids if the protocol version will fall into the new supported range .filter(e -> initialConflicts.contains(e.getKey()) && targetRange.isSupported(e.getValue())) .map(Entry::getKey) .collect(Collectors.toSet());  // Get the set of source definitions that will still have conflict after the connector upgrades final Set<UUID> remainingConflicts = new HashSet<>(initialConflicts); remainingConflicts.removeAll(upgradedSourceDefs); return remainingConflicts; }
[*] target: assertEquals(expectedConflicts, actualConflicts)
[-] pred: org. junit. Assert. assertEquals ( expectedConflicts, actualConflicts )
************************************
************************************
[+] input: IOException {  final AirbyteCatalog actorCatalog = CatalogHelpers.createAirbyteCatalog("clothes", Field.of("name", JsonSchemaType.STRING), Field.of("size", JsonSchemaType.NUMBER), Field.of("color", JsonSchemaType.STRING), Field.of("price", JsonSchemaType.NUMBER));  final String actualJson = Jsons.canonicalJsonSerialize(actorCatalog);  final String expectedJson = "{" + ""streams":[" + "{" + ""default_cursor_field":[]," + ""json_schema":{" + ""properties":{" + ""color":{"type":"string"}," + ""name":{"type":"string"}," + ""price":{"type":"number"}," + ""size":{"type":"number"}" + "}," + ""type":"object"" + "}," + ""name":"clothes"," + ""source_defined_primary_key":[]," + ""supported_sync_modes":["full_refresh"]" + "}" + "]" + "}";  // Assert that the result is a JSON string with keys sorted in alphabetical order "<AssertPlaceHolder>"; }
canonicalJsonSerialize(final Object object) throws IOException { final ObjectMapper mapper = new ObjectMapper(); final ObjectNode objectNode = mapper.valueToTree(object); final ObjectNode sortedObjectNode = (ObjectNode) sortProperties(objectNode); return mapper.writer().writeValueAsString(sortedObjectNode); }
[*] target: assertEquals(expectedJson, actualJson)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, actualJson )
************************************
************************************
[+] input: IOException { final String envFileContents = "OPTION1=hello\n" + "OPTION2=2\n" + "OPTION3=\n"; final File envFile = File.createTempFile("properties-test", ".env"); IOs.writeFile(envFile.toPath(), envFileContents);  final Properties actual = MoreProperties.envFileToProperties(envFile); final Properties expected = new Properties(); expected.put("OPTION1", "hello"); expected.put("OPTION2", "2"); expected.put("OPTION3", "");  "<AssertPlaceHolder>"; }
envFileToProperties(final File envFile) throws IOException { final Properties prop = new Properties(); prop.load(new FileInputStream(envFile)); return prop; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testBasicUpgrade() { // This isn't actually a valid stream schema (since it's not an object) // but this test case is mostly about preserving the message structure, so it's not super relevant final io.airbyte.protocol.models.v0.ConfiguredAirbyteCatalog downgradedCatalog = new io.airbyte.protocol.models.v0.ConfiguredAirbyteCatalog() .withStreams(List.of( new io.airbyte.protocol.models.v0.ConfiguredAirbyteStream().withStream(new io.airbyte.protocol.models.v0.AirbyteStream().withJsonSchema( Jsons.deserialize( """ { "type": "string" } """)))));  final ConfiguredAirbyteCatalog upgradedMessage = migration.upgrade(downgradedCatalog);  final ConfiguredAirbyteCatalog expectedMessage = Jsons.deserialize( """ { "streams": [ { "stream": { "json_schema": { "$ref": "WellKnownTypes.json#/definitions/String" } } } ] } """, ConfiguredAirbyteCatalog.class); "<AssertPlaceHolder>"; }
upgrade(final io.airbyte.protocol.models.v0.ConfiguredAirbyteCatalog oldMessage) { final ConfiguredAirbyteCatalog newMessage = Jsons.object( Jsons.jsonNode(oldMessage), ConfiguredAirbyteCatalog.class); for (final ConfiguredAirbyteStream stream : newMessage.getStreams()) { final JsonNode schema = stream.getStream().getJsonSchema(); SchemaMigrationV1.upgradeSchema(schema); } return newMessage; }
[*] target: assertEquals(expectedMessage, upgradedMessage)
[-] pred: org. junit. Assert. assertEquals ( expectedMessage, upgradedMessage )
************************************
************************************
[+] input: IOException { final UUID sourceDefinitionId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardSourceDefinition(sourceDefinitionId)).thenReturn(SOURCE_DEFINITION); when(actorDefinitionVersionHelper.getSourceVersion(SOURCE_DEFINITION, workspaceId, sourceId)).thenReturn(SOURCE_DEFINITION_VERSION_OLD);  when(remoteDefinitionsProvider.getConnectorDocumentation(SOURCE_DOCKER_REPO, SOURCE_VERSION_OLD)) .thenReturn(Optional.of(DOC_CONTENTS_OLD));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.SOURCE) .actorDefinitionId(sourceDefinitionId).workspaceId(workspaceId).actorId(sourceId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_OLD); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: IOException { final UUID sourceDefinitionId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardSourceDefinition(sourceDefinitionId)).thenReturn(SOURCE_DEFINITION); when(actorDefinitionVersionHelper.getSourceVersion(SOURCE_DEFINITION, workspaceId, null)).thenReturn(SOURCE_DEFINITION_VERSION_LATEST);  when(remoteDefinitionsProvider.getConnectorDocumentation(SOURCE_DOCKER_REPO, SOURCE_VERSION_LATEST)) .thenReturn(Optional.of(DOC_CONTENTS_LATEST));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.SOURCE).actorDefinitionId(sourceDefinitionId).workspaceId(workspaceId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_LATEST); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: IOException { final UUID destinationDefinitionId = UUID.randomUUID(); final UUID destinationId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardDestinationDefinition(destinationDefinitionId)).thenReturn(DESTINATION_DEFINITION); when(actorDefinitionVersionHelper.getDestinationVersion(DESTINATION_DEFINITION, workspaceId, destinationId)) .thenReturn(DESTINATION_DEFINITION_VERSION_OLD);  when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, DESTINATION_VERSION_OLD)) .thenReturn(Optional.of(DOC_CONTENTS_OLD));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.DESTINATION) .actorDefinitionId(destinationDefinitionId).workspaceId(workspaceId).actorId(destinationId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_OLD); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: IOException { final UUID destinationDefinitionId = UUID.randomUUID(); final UUID destinationId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardDestinationDefinition(destinationDefinitionId)).thenReturn(DESTINATION_DEFINITION); when(actorDefinitionVersionHelper.getDestinationVersion(DESTINATION_DEFINITION, workspaceId, destinationId)) .thenReturn(DESTINATION_DEFINITION_VERSION_OLD);  when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, DESTINATION_VERSION_OLD)).thenReturn(Optional.empty()); when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, LATEST)) .thenReturn(Optional.of(DOC_CONTENTS_LATEST));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.DESTINATION) .actorDefinitionId(destinationDefinitionId).workspaceId(workspaceId).actorId(destinationId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_LATEST); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: IOException { final UUID destinationDefinitionId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardDestinationDefinition(destinationDefinitionId)).thenReturn(DESTINATION_DEFINITION); when(actorDefinitionVersionHelper.getDestinationVersion(DESTINATION_DEFINITION, workspaceId, null)) .thenReturn(DESTINATION_DEFINITION_VERSION_LATEST);  when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, DESTINATION_VERSION_LATEST)) .thenReturn(Optional.of(DOC_CONTENTS_LATEST));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.DESTINATION).actorDefinitionId(destinationDefinitionId).workspaceId(workspaceId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_LATEST); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: IOException { final UUID destinationDefinitionId = UUID.randomUUID(); final UUID workspaceId = UUID.randomUUID(); when(configRepository.getStandardDestinationDefinition(destinationDefinitionId)).thenReturn(DESTINATION_DEFINITION); when(actorDefinitionVersionHelper.getDestinationVersion(DESTINATION_DEFINITION, workspaceId, null)) .thenReturn(DESTINATION_DEFINITION_VERSION_LATEST);  when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, DESTINATION_VERSION_LATEST)) .thenReturn(Optional.empty()); when(remoteDefinitionsProvider.getConnectorDocumentation(DESTINATION_DOCKER_REPO, LATEST)) .thenReturn(Optional.of(DOC_CONTENTS_LATEST));  final ConnectorDocumentationRequestBody request = new ConnectorDocumentationRequestBody().actorType(ActorType.DESTINATION).actorDefinitionId(destinationDefinitionId).workspaceId(workspaceId);  final ConnectorDocumentationRead expectedResult = new ConnectorDocumentationRead().doc(DOC_CONTENTS_LATEST); final ConnectorDocumentationRead actualResult = connectorDocumentationHandler.getConnectorDocumentation(request);  "<AssertPlaceHolder>"; }
getConnectorDocumentation(final ConnectorDocumentationRequestBody request) throws JsonValidationException, ConfigNotFoundException, IOException { final ActorDefinitionVersion actorDefinitionVersion = request.getActorType().equals(ActorType.SOURCE) ? getSourceActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()) : getDestinationActorDefinitionVersion(request.getActorDefinitionId(), request.getWorkspaceId(), request.getActorId()); final String dockerRepo = actorDefinitionVersion.getDockerRepository(); final String version = actorDefinitionVersion.getDockerImageTag();  // prioritize versioned over latest final Optional<String> versionedDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, version); if (versionedDocString.isPresent()) { return new ConnectorDocumentationRead().doc(versionedDocString.get()); }  final Optional<String> latestDocString = remoteDefinitionsProvider.getConnectorDocumentation(dockerRepo, LATEST); if (latestDocString.isPresent()) { return new ConnectorDocumentationRead().doc(latestDocString.get()); }  throw new NotFoundException(String.format("Could not find any documentation for connector %s", dockerRepo)); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: Exception { final List<Permission> existingPermissions = List.of(); when(permissionService.getPermissionsForUser(any())).thenReturn(existingPermissions); when(uuidSupplier.get()).thenReturn(PERMISSION_ID); final PermissionCreate permissionCreate = new PermissionCreate() .permissionType(io.airbyte.api.model.generated.PermissionType.WORKSPACE_OWNER) .userId(USER_ID) .workspaceId(WORKSPACE_ID); when(permissionService.createPermission(any())).thenReturn(PERMISSION); final PermissionRead actualRead = permissionHandler.createPermission(permissionCreate); final PermissionRead expectedRead = new PermissionRead() .permissionId(PERMISSION_ID) .permissionType(io.airbyte.api.model.generated.PermissionType.WORKSPACE_ADMIN) .userId(USER_ID) .workspaceId(WORKSPACE_ID);  "<AssertPlaceHolder>"; }
createPermission(final PermissionCreate permissionCreate) throws IOException, JsonValidationException {  // INSTANCE_ADMIN permissions are only created in special cases, so we block them here. if (permissionCreate.getPermissionType().equals(PermissionType.INSTANCE_ADMIN)) { throw new JsonValidationException("Cannot create INSTANCE_ADMIN permission record."); }  final Optional<PermissionRead> existingPermission = getExistingPermission(permissionCreate); if (existingPermission.isPresent()) { return existingPermission.get(); }  final UUID permissionId = permissionCreate.getPermissionId() != null ? permissionCreate.getPermissionId() : uuidGenerator.get();  final Permission permission = new Permission() .withPermissionId(permissionId) .withPermissionType(Enums.convertTo(permissionCreate.getPermissionType(), Permission.PermissionType.class)) .withUserId(permissionCreate.getUserId()) .withWorkspaceId(permissionCreate.getWorkspaceId()) .withOrganizationId(permissionCreate.getOrganizationId());  try { return buildPermissionRead(permissionService.createPermission(permission)); } catch (final PermissionRedundantException e) { throw new ConflictException(e.getMessage(), e); } }
[*] target: assertEquals(expectedRead, actualRead)
[-] pred: org. junit. Assert. assertEquals ( expectedRead, actualRead )
************************************
************************************
[+] input: io.airbyte.data.exceptions.ConfigNotFoundException { final String updatedSourceName = "my updated source name"; final JsonNode newConfiguration = sourceConnection.getConfiguration(); ((ObjectNode) newConfiguration).put("apiKey", "987-xyz");  final SourceConnection expectedSourceConnection = Jsons.clone(sourceConnection) .withName(updatedSourceName) .withConfiguration(newConfiguration) .withTombstone(false);  final SourceUpdate sourceUpdate = new SourceUpdate() .name(updatedSourceName) .sourceId(sourceConnection.getSourceId()) .connectionConfiguration(newConfiguration);  when(secretsProcessor .copySecrets(sourceConnection.getConfiguration(), newConfiguration, sourceDefinitionSpecificationRead.getConnectionSpecification())) .thenReturn(newConfiguration); when(secretsProcessor.prepareSecretsForOutput(newConfiguration, sourceDefinitionSpecificationRead.getConnectionSpecification())) .thenReturn(newConfiguration); when(oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionSpecificationRead.getSourceDefinitionId(), sourceConnection.getWorkspaceId(), newConfiguration, sourceDefinitionVersion.getSpec())).thenReturn(newConfiguration); when(configRepository.getStandardSourceDefinition(sourceDefinitionSpecificationRead.getSourceDefinitionId())) .thenReturn(standardSourceDefinition); when(actorDefinitionVersionHelper.getSourceVersion(standardSourceDefinition, sourceConnection.getWorkspaceId(), sourceConnection.getSourceId())) .thenReturn(sourceDefinitionVersion); when(configRepository.getSourceDefinitionFromSource(sourceConnection.getSourceId())) .thenReturn(standardSourceDefinition); when(configRepository.getSourceConnection(sourceConnection.getSourceId())) .thenReturn(sourceConnection) .thenReturn(expectedSourceConnection); when(configurationUpdate.source(sourceConnection.getSourceId(), updatedSourceName, newConfiguration)) .thenReturn(expectedSourceConnection); when(actorDefinitionVersionHelper.getSourceVersionWithOverrideStatus(standardSourceDefinition, sourceConnection.getWorkspaceId(), sourceConnection.getSourceId())).thenReturn(sourceDefinitionVersionWithOverrideStatus);  final SourceRead actualSourceRead = sourceHandler.updateSource(sourceUpdate); final SourceRead expectedSourceRead = SourceHelpers.getSourceRead(expectedSourceConnection, standardSourceDefinition, IS_VERSION_OVERRIDE_APPLIED, SUPPORT_STATE) .connectionConfiguration(newConfiguration);  "<AssertPlaceHolder>";  verify(secretsProcessor).prepareSecretsForOutput(newConfiguration, sourceDefinitionSpecificationRead.getConnectionSpecification()); verify(oAuthConfigSupplier).maskSourceOAuthParameters(sourceDefinitionSpecificationRead.getSourceDefinitionId(), sourceConnection.getWorkspaceId(), newConfiguration, sourceDefinitionVersion.getSpec()); verify(sourceService).writeSourceConnectionWithSecrets(expectedSourceConnection, connectorSpecification); verify(actorDefinitionVersionHelper).getSourceVersion(standardSourceDefinition, sourceConnection.getWorkspaceId(), sourceConnection.getSourceId()); verify(validator).ensure(sourceDefinitionSpecificationRead.getConnectionSpecification(), newConfiguration); }
updateSource(final SourceUpdate sourceUpdate) throws ConfigNotFoundException, IOException, JsonValidationException {  final UUID sourceId = sourceUpdate.getSourceId(); final SourceConnection updatedSource = configurationUpdate .source(sourceId, sourceUpdate.getName(), sourceUpdate.getConnectionConfiguration()); final ConnectorSpecification spec = getSpecFromSourceId(sourceId); validateSource(spec, sourceUpdate.getConnectionConfiguration());  // persist persistSourceConnection( updatedSource.getName(), updatedSource.getSourceDefinitionId(), updatedSource.getWorkspaceId(), updatedSource.getSourceId(), updatedSource.getTombstone(), updatedSource.getConfiguration(), spec);  // read configuration from db return buildSourceRead(configRepository.getSourceConnection(sourceId), spec); }
[*] target: assertEquals(expectedSourceRead, actualSourceRead)
[-] pred: org. junit. Assert. assertEquals ( expectedSourceRead, actualSourceRead )
************************************
************************************
[+] input: IOException { when(statePersistence.getCurrentState(CONNECTION_ID)).thenReturn(Optional.empty());  final ConnectionState expected = new ConnectionState().connectionId(CONNECTION_ID).stateType(ConnectionStateType.NOT_SET).streamState(null); final ConnectionState actual = stateHandler.getState(new ConnectionIdRequestBody().connectionId(CONNECTION_ID)); "<AssertPlaceHolder>"; }
getState(final ConnectionIdRequestBody connectionIdRequestBody) throws IOException { final UUID connectionId = connectionIdRequestBody.getConnectionId(); final Optional<StateWrapper> currentState = statePersistence.getCurrentState(connectionId); return StateConverter.toApi(connectionId, currentState.orElse(null)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { when(statePersistence.getCurrentState(CONNECTION_ID)).thenReturn(Optional.of( new StateWrapper() .withStateType(StateType.LEGACY) .withLegacyState(JSON_BLOB)));  final ConnectionState expected = new ConnectionState() .connectionId(CONNECTION_ID) .stateType(ConnectionStateType.LEGACY) .streamState(null) .state(JSON_BLOB); final ConnectionState actual = stateHandler.getState(new ConnectionIdRequestBody().connectionId(CONNECTION_ID)); "<AssertPlaceHolder>"; }
getState(final ConnectionIdRequestBody connectionIdRequestBody) throws IOException { final UUID connectionId = connectionIdRequestBody.getConnectionId(); final Optional<StateWrapper> currentState = statePersistence.getCurrentState(connectionId); return StateConverter.toApi(connectionId, currentState.orElse(null)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { when(statePersistence.getCurrentState(CONNECTION_ID)).thenReturn(Optional.of( new StateWrapper() .withStateType(StateType.GLOBAL) .withGlobal(new AirbyteStateMessage().withType(AirbyteStateType.GLOBAL).withGlobal(new AirbyteGlobalState() .withSharedState(JSON_BLOB) .withStreamStates(List.of( new AirbyteStreamState().withStreamDescriptor(STREAM_DESCRIPTOR1).withStreamState(JSON_BLOB), new AirbyteStreamState().withStreamDescriptor(STREAM_DESCRIPTOR2).withStreamState(JSON_BLOB)))))));  final ConnectionState expected = new ConnectionState() .connectionId(CONNECTION_ID) .stateType(ConnectionStateType.GLOBAL) .streamState(null) .globalState(new GlobalState().sharedState(JSON_BLOB).streamStates(List.of( new StreamState().streamDescriptor(toApi(STREAM_DESCRIPTOR1)).streamState(JSON_BLOB), new StreamState().streamDescriptor(toApi(STREAM_DESCRIPTOR2)).streamState(JSON_BLOB)))); final ConnectionState actual = stateHandler.getState(new ConnectionIdRequestBody().connectionId(CONNECTION_ID)); "<AssertPlaceHolder>"; }
getState(final ConnectionIdRequestBody connectionIdRequestBody) throws IOException { final UUID connectionId = connectionIdRequestBody.getConnectionId(); final Optional<StateWrapper> currentState = statePersistence.getCurrentState(connectionId); return StateConverter.toApi(connectionId, currentState.orElse(null)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { when(statePersistence.getCurrentState(CONNECTION_ID)).thenReturn(Optional.of( new StateWrapper() .withStateType(StateType.STREAM) .withStateMessages(List.of( new AirbyteStateMessage() .withType(AirbyteStateType.STREAM) .withStream(new AirbyteStreamState().withStreamDescriptor(STREAM_DESCRIPTOR1).withStreamState(JSON_BLOB)), new AirbyteStateMessage() .withType(AirbyteStateType.STREAM) .withStream(new AirbyteStreamState().withStreamDescriptor(STREAM_DESCRIPTOR2).withStreamState(JSON_BLOB))))));  final ConnectionState expected = new ConnectionState() .connectionId(CONNECTION_ID) .stateType(ConnectionStateType.STREAM) .streamState(List.of( new StreamState().streamDescriptor(toApi(STREAM_DESCRIPTOR1)).streamState(JSON_BLOB), new StreamState().streamDescriptor(toApi(STREAM_DESCRIPTOR2)).streamState(JSON_BLOB))); final ConnectionState actual = stateHandler.getState(new ConnectionIdRequestBody().connectionId(CONNECTION_ID)); "<AssertPlaceHolder>"; }
getState(final ConnectionIdRequestBody connectionIdRequestBody) throws IOException { final UUID connectionId = connectionIdRequestBody.getConnectionId(); final Optional<StateWrapper> currentState = statePersistence.getCurrentState(connectionId); return StateConverter.toApi(connectionId, currentState.orElse(null)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { final UUID organizationId = UUID.randomUUID(); final UUID userID = UUID.randomUUID();  // expecting the default user to be excluded from the response final UserPermission defaultUserPermission = new UserPermission() .withUser(new User().withName("default").withUserId(DEFAULT_USER_ID).withEmail("default@airbyte.io")) .withPermission(new Permission().withPermissionId(UUID.randomUUID()).withPermissionType(PermissionType.ORGANIZATION_ADMIN));  final UserPermission realUserPermission = new UserPermission() .withUser(new User().withName(USER_NAME).withUserId(userID).withEmail(USER_EMAIL)) .withPermission(new Permission().withPermissionId(PERMISSION1_ID).withPermissionType(PermissionType.ORGANIZATION_ADMIN));  when(permissionPersistence.listUsersInOrganization(organizationId)).thenReturn(List.of(defaultUserPermission, realUserPermission));  // no default user present final var expectedListResult = new OrganizationUserReadList().users(List.of(new OrganizationUserRead() .name(USER_NAME) .userId(userID) .email(USER_EMAIL) .organizationId(organizationId) .permissionId(PERMISSION1_ID) .permissionType(io.airbyte.api.model.generated.PermissionType.ORGANIZATION_ADMIN)));  final var result = userHandler.listUsersInOrganization(new OrganizationIdRequestBody().organizationId(organizationId)); "<AssertPlaceHolder>"; }
listUsersInOrganization(final OrganizationIdRequestBody organizationIdRequestBody) throws IOException { final UUID organizationId = organizationIdRequestBody.getOrganizationId(); final List<UserPermission> userPermissions = permissionPersistence.listUsersInOrganization(organizationId); return buildOrganizationUserReadList(userPermissions, organizationId); }
[*] target: assertEquals(expectedListResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedListResult, result )
************************************
************************************
[+] input: IOException { final UUID workspaceId = UUID.randomUUID(); final UUID userID = UUID.randomUUID();  // expecting the default user to be excluded from the response final UserPermission defaultUserPermission = new UserPermission() .withUser(new User().withName("default").withUserId(DEFAULT_USER_ID).withEmail("default@airbyte.io")) .withPermission(new Permission().withPermissionId(UUID.randomUUID()).withPermissionType(PermissionType.WORKSPACE_ADMIN));  final UserPermission realUserPermission = new UserPermission() .withUser(new User().withName(USER_NAME).withUserId(userID).withEmail(USER_EMAIL).withDefaultWorkspaceId(workspaceId)) .withPermission(new Permission().withPermissionId(PERMISSION1_ID).withPermissionType(PermissionType.WORKSPACE_ADMIN));  when(permissionPersistence.listUsersInWorkspace(workspaceId)).thenReturn(List.of(defaultUserPermission, realUserPermission));  // no default user present final var expectedListResult = new WorkspaceUserReadList().users(List.of(new WorkspaceUserRead() .userId(userID) .name(USER_NAME) .isDefaultWorkspace(true) .email(USER_EMAIL) .workspaceId(workspaceId) .permissionId(PERMISSION1_ID) .permissionType(io.airbyte.api.model.generated.PermissionType.WORKSPACE_ADMIN)));  final var result = userHandler.listUsersInWorkspace(new WorkspaceIdRequestBody().workspaceId(workspaceId)); "<AssertPlaceHolder>"; }
listUsersInWorkspace(final WorkspaceIdRequestBody workspaceIdRequestBody) throws IOException { final UUID workspaceId = workspaceIdRequestBody.getWorkspaceId(); final List<UserPermission> userPermissions = permissionPersistence.listUsersInWorkspace(workspaceId); return buildWorkspaceUserReadList(userPermissions, workspaceId); }
[*] target: assertEquals(expectedListResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedListResult, result )
************************************
************************************
[+] input: Exception { when(permissionPersistence.listInstanceAdminUsers()).thenReturn(List.of(new UserPermission().withUser( new User().withName(USER_NAME).withUserId(USER_ID).withEmail(USER_EMAIL)) .withPermission(new Permission().withPermissionId(PERMISSION1_ID).withPermissionType(PermissionType.INSTANCE_ADMIN))));  final var result = userHandler.listInstanceAdminUsers();  final var expectedResult = new UserWithPermissionInfoReadList().users(List.of( new io.airbyte.api.model.generated.UserWithPermissionInfoRead().name(USER_NAME).userId(USER_ID).email(USER_EMAIL) .permissionId(PERMISSION1_ID))); "<AssertPlaceHolder>";  }
listInstanceAdminUsers() throws IOException { final List<UserPermission> userPermissions = permissionPersistence.listInstanceAdminUsers(); return new UserWithPermissionInfoReadList().users(userPermissions.stream() .map(userPermission -> new UserWithPermissionInfoRead() .userId(userPermission.getUser().getUserId()) .email(userPermission.getUser().getEmail()) .name(userPermission.getUser().getName()) .permissionId(userPermission.getPermission().getPermissionId())) .collect(Collectors.toList())); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: Exception { final UUID workspaceId = UUID.randomUUID(); when(userPersistence.listWorkspaceUserAccessInfo(workspaceId)).thenReturn(List.of( new WorkspaceUserAccessInfo() .withUserId(DEFAULT_USER_ID), // expect the default user to be filtered out. new WorkspaceUserAccessInfo() .withUserId(USER_ID) .withUserName(USER_NAME) .withUserEmail(USER_EMAIL) .withWorkspaceId(workspaceId) .withWorkspacePermission(new Permission() .withPermissionId(PERMISSION1_ID) .withPermissionType(PermissionType.WORKSPACE_ADMIN) .withUserId(USER_ID) .withWorkspaceId(workspaceId))));  final var result = userHandler.listAccessInfoByWorkspaceId(new WorkspaceIdRequestBody().workspaceId(workspaceId));  final var expected = new WorkspaceUserAccessInfoReadList().usersWithAccess(List.of( new io.airbyte.api.model.generated.WorkspaceUserAccessInfoRead() .userId(USER_ID) .userName(USER_NAME) .userEmail(USER_EMAIL) .workspaceId(workspaceId) .workspacePermission(new PermissionRead() .permissionId(PERMISSION1_ID) .permissionType(io.airbyte.api.model.generated.PermissionType.WORKSPACE_ADMIN) .userId(USER_ID) .workspaceId(workspaceId))));  "<AssertPlaceHolder>"; }
listAccessInfoByWorkspaceId(final WorkspaceIdRequestBody workspaceIdRequestBody) throws IOException { final UUID workspaceId = workspaceIdRequestBody.getWorkspaceId(); final List<WorkspaceUserAccessInfo> userAccessInfo = userPersistence.listWorkspaceUserAccessInfo(workspaceId); return buildWorkspaceUserAccessInfoReadList(userAccessInfo); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { final SourceConnection source = SourceHelpers.generateSource(UUID.randomUUID()); final StandardSync standardSync = ConnectionHelpers.generateSyncWithSourceId(source.getSourceId());  final AirbyteCatalog catalog = ConnectionHelpers.generateBasicApiCatalog(); catalog.getStreams().get(0).getStream().setName("azkaban_users");  final ConnectionSchedule schedule = new ConnectionSchedule().units(1L).timeUnit(TimeUnitEnum.MINUTES);  final UUID newSourceId = UUID.randomUUID(); final UUID newDestinationId = UUID.randomUUID(); final UUID newOperationId = UUID.randomUUID(); final UUID sourceCatalogId = UUID.randomUUID(); final WebBackendConnectionCreate input = new WebBackendConnectionCreate() .name("testConnectionCreate") .namespaceDefinition(Enums.convertTo(standardSync.getNamespaceDefinition(), NamespaceDefinitionType.class)) .namespaceFormat(standardSync.getNamespaceFormat()) .prefix(standardSync.getPrefix()) .sourceId(newSourceId) .destinationId(newDestinationId) .operationIds(List.of(newOperationId)) .status(ConnectionStatus.INACTIVE) .schedule(schedule) .syncCatalog(catalog) .sourceCatalogId(sourceCatalogId) .geography(Geography.US) .nonBreakingChangesPreference(NonBreakingChangesPreference.DISABLE);  final List<UUID> operationIds = List.of(newOperationId);  final ConnectionCreate expected = new ConnectionCreate() .name("testConnectionCreate") .namespaceDefinition(Enums.convertTo(standardSync.getNamespaceDefinition(), NamespaceDefinitionType.class)) .namespaceFormat(standardSync.getNamespaceFormat()) .prefix(standardSync.getPrefix()) .sourceId(newSourceId) .destinationId(newDestinationId) .operationIds(operationIds) .status(ConnectionStatus.INACTIVE) .schedule(schedule) .syncCatalog(catalog) .sourceCatalogId(sourceCatalogId) .geography(Geography.US) .nonBreakingChangesPreference(NonBreakingChangesPreference.DISABLE);  final ConnectionCreate actual = WebBackendConnectionsHandler.toConnectionCreate(input, operationIds);  "<AssertPlaceHolder>"; }
toConnectionCreate(final WebBackendConnectionCreate webBackendConnectionCreate, final List<UUID> operationIds) { final ConnectionCreate connectionCreate = new ConnectionCreate();  connectionCreate.name(webBackendConnectionCreate.getName()); connectionCreate.namespaceDefinition(webBackendConnectionCreate.getNamespaceDefinition()); connectionCreate.namespaceFormat(webBackendConnectionCreate.getNamespaceFormat()); connectionCreate.prefix(webBackendConnectionCreate.getPrefix()); connectionCreate.sourceId(webBackendConnectionCreate.getSourceId()); connectionCreate.destinationId(webBackendConnectionCreate.getDestinationId()); connectionCreate.operationIds(operationIds); connectionCreate.syncCatalog(webBackendConnectionCreate.getSyncCatalog()); connectionCreate.schedule(webBackendConnectionCreate.getSchedule()); connectionCreate.scheduleType(webBackendConnectionCreate.getScheduleType()); connectionCreate.scheduleData(webBackendConnectionCreate.getScheduleData()); connectionCreate.status(webBackendConnectionCreate.getStatus()); connectionCreate.resourceRequirements(webBackendConnectionCreate.getResourceRequirements()); connectionCreate.sourceCatalogId(webBackendConnectionCreate.getSourceCatalogId()); connectionCreate.geography(webBackendConnectionCreate.getGeography()); connectionCreate.notifySchemaChanges(webBackendConnectionCreate.getNotifySchemaChanges()); connectionCreate.nonBreakingChangesPreference(webBackendConnectionCreate.getNonBreakingChangesPreference()); connectionCreate.backfillPreference(webBackendConnectionCreate.getBackfillPreference());  return connectionCreate; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testUpdateSchemaWithDiscoveryFromEmpty() { final AirbyteCatalog original = new AirbyteCatalog().streams(List.of()); final AirbyteCatalog discovered = ConnectionHelpers.generateBasicApiCatalog(); discovered.getStreams().get(0).getStream() .name(STREAM1) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD1, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH)); discovered.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1);  final AirbyteCatalog expected = ConnectionHelpers.generateBasicApiCatalog(); expected.getStreams().get(0).getStream() .name(STREAM1) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD1, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH)); expected.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1) .selected(false) .suggested(false) .selectedFields(List.of());  final AirbyteCatalog actual = WebBackendConnectionsHandler.updateSchemaWithRefreshedDiscoveredCatalog(original, original, discovered);  "<AssertPlaceHolder>"; }
updateSchemaWithRefreshedDiscoveredCatalog(final AirbyteCatalog originalConfigured, final AirbyteCatalog originalDiscovered, final AirbyteCatalog discovered) { /* * We can't directly use s.getStream() as the key, because it contains a bunch of other fields, so * we just define a quick-and-dirty record class. */ final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalStream = originalConfigured.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s)); final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalDiscoveredStream = originalDiscovered.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s));  final List<AirbyteStreamAndConfiguration> streams = new ArrayList<>();  for (final AirbyteStreamAndConfiguration discoveredStream : discovered.getStreams()) { final AirbyteStream stream = discoveredStream.getStream(); final AirbyteStreamAndConfiguration originalConfiguredStream = streamDescriptorToOriginalStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamAndConfiguration originalDiscoveredStream = streamDescriptorToOriginalDiscoveredStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamConfiguration outputStreamConfig;  if (originalConfiguredStream != null) { final AirbyteStreamConfiguration originalStreamConfig = originalConfiguredStream.getConfig(); final AirbyteStreamConfiguration discoveredStreamConfig = discoveredStream.getConfig(); outputStreamConfig = new AirbyteStreamConfiguration();  if (stream.getSupportedSyncModes().contains(originalStreamConfig.getSyncMode())) { outputStreamConfig.setSyncMode(originalStreamConfig.getSyncMode()); } else { outputStreamConfig.setSyncMode(discoveredStreamConfig.getSyncMode()); }  if (!originalStreamConfig.getCursorField().isEmpty()) { outputStreamConfig.setCursorField(originalStreamConfig.getCursorField()); } else { outputStreamConfig.setCursorField(discoveredStreamConfig.getCursorField()); }  outputStreamConfig.setDestinationSyncMode(originalStreamConfig.getDestinationSyncMode());  final boolean hasSourceDefinedPK = stream.getSourceDefinedPrimaryKey() != null && !stream.getSourceDefinedPrimaryKey().isEmpty(); if (hasSourceDefinedPK) { outputStreamConfig.setPrimaryKey(stream.getSourceDefinedPrimaryKey()); } else if (!originalStreamConfig.getPrimaryKey().isEmpty()) { outputStreamConfig.setPrimaryKey(originalStreamConfig.getPrimaryKey()); } else { outputStreamConfig.setPrimaryKey(discoveredStreamConfig.getPrimaryKey()); }  outputStreamConfig.setAliasName(originalStreamConfig.getAliasName()); outputStreamConfig.setSelected(originalConfiguredStream.getConfig().getSelected()); outputStreamConfig.setSuggested(originalConfiguredStream.getConfig().getSuggested()); outputStreamConfig.setFieldSelectionEnabled(originalStreamConfig.getFieldSelectionEnabled());  if (outputStreamConfig.getFieldSelectionEnabled()) { // TODO(mfsiega-airbyte): support nested fields. // If field selection is enabled, populate the selected fields. final Set<String> originallyDiscovered = new HashSet<>(); final Set<String> refreshDiscovered = new HashSet<>(); // NOTE: by only taking the first element of the path, we're restricting to top-level fields. final Set<String> originallySelected = new HashSet<>( originalConfiguredStream.getConfig().getSelectedFields().stream().map((field) -> field.getFieldPath().get(0)).toList()); originalDiscoveredStream.getStream().getJsonSchema().findPath("properties").fieldNames() .forEachRemaining(originallyDiscovered::add); stream.getJsonSchema().findPath("properties").fieldNames().forEachRemaining(refreshDiscovered::add); // We include a selected field if it: // (is in the newly discovered schema) AND (it was either originally selected OR not in the // originally discovered schema at all) // NOTE: this implies that the default behaviour for newly-discovered columns is to add them. for (final String discoveredField : refreshDiscovered) { if (originallySelected.contains(discoveredField) || !originallyDiscovered.contains(discoveredField)) { outputStreamConfig.addSelectedFieldsItem(new SelectedFieldInfo().addFieldPathItem(discoveredField)); } } } else { outputStreamConfig.setSelectedFields(List.of()); }  } else { outputStreamConfig = discoveredStream.getConfig(); outputStreamConfig.setSelected(false); } final AirbyteStreamAndConfiguration outputStream = new AirbyteStreamAndConfiguration() .stream(Jsons.clone(stream)) .config(outputStreamConfig); streams.add(outputStream); } return new AirbyteCatalog().streams(streams); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testUpdateSchemaWithDiscoveryResetStream() { final AirbyteCatalog original = ConnectionHelpers.generateBasicApiCatalog(); original.getStreams().get(0).getStream() .name("random-stream") .defaultCursorField(List.of(FIELD1)) .jsonSchema(CatalogHelpers.fieldsToJsonSchema( Field.of(FIELD1, JsonSchemaType.NUMBER), Field.of(FIELD2, JsonSchemaType.NUMBER), Field.of(FIELD5, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH, SyncMode.INCREMENTAL)); original.getStreams().get(0).getConfig() .syncMode(SyncMode.INCREMENTAL) .cursorField(List.of(FIELD1)) .destinationSyncMode(DestinationSyncMode.APPEND) .primaryKey(Collections.emptyList()) .aliasName("random_stream");  final AirbyteCatalog discovered = ConnectionHelpers.generateBasicApiCatalog(); discovered.getStreams().get(0).getStream() .name(STREAM1) .defaultCursorField(List.of(FIELD3)) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD2, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH, SyncMode.INCREMENTAL)); discovered.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1);  final AirbyteCatalog expected = ConnectionHelpers.generateBasicApiCatalog(); expected.getStreams().get(0).getStream() .name(STREAM1) .defaultCursorField(List.of(FIELD3)) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD2, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH, SyncMode.INCREMENTAL)); expected.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1) .selected(false) .suggested(false) .selectedFields(List.of());  final AirbyteCatalog actual = WebBackendConnectionsHandler.updateSchemaWithRefreshedDiscoveredCatalog(original, original, discovered);  "<AssertPlaceHolder>"; }
updateSchemaWithRefreshedDiscoveredCatalog(final AirbyteCatalog originalConfigured, final AirbyteCatalog originalDiscovered, final AirbyteCatalog discovered) { /* * We can't directly use s.getStream() as the key, because it contains a bunch of other fields, so * we just define a quick-and-dirty record class. */ final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalStream = originalConfigured.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s)); final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalDiscoveredStream = originalDiscovered.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s));  final List<AirbyteStreamAndConfiguration> streams = new ArrayList<>();  for (final AirbyteStreamAndConfiguration discoveredStream : discovered.getStreams()) { final AirbyteStream stream = discoveredStream.getStream(); final AirbyteStreamAndConfiguration originalConfiguredStream = streamDescriptorToOriginalStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamAndConfiguration originalDiscoveredStream = streamDescriptorToOriginalDiscoveredStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamConfiguration outputStreamConfig;  if (originalConfiguredStream != null) { final AirbyteStreamConfiguration originalStreamConfig = originalConfiguredStream.getConfig(); final AirbyteStreamConfiguration discoveredStreamConfig = discoveredStream.getConfig(); outputStreamConfig = new AirbyteStreamConfiguration();  if (stream.getSupportedSyncModes().contains(originalStreamConfig.getSyncMode())) { outputStreamConfig.setSyncMode(originalStreamConfig.getSyncMode()); } else { outputStreamConfig.setSyncMode(discoveredStreamConfig.getSyncMode()); }  if (!originalStreamConfig.getCursorField().isEmpty()) { outputStreamConfig.setCursorField(originalStreamConfig.getCursorField()); } else { outputStreamConfig.setCursorField(discoveredStreamConfig.getCursorField()); }  outputStreamConfig.setDestinationSyncMode(originalStreamConfig.getDestinationSyncMode());  final boolean hasSourceDefinedPK = stream.getSourceDefinedPrimaryKey() != null && !stream.getSourceDefinedPrimaryKey().isEmpty(); if (hasSourceDefinedPK) { outputStreamConfig.setPrimaryKey(stream.getSourceDefinedPrimaryKey()); } else if (!originalStreamConfig.getPrimaryKey().isEmpty()) { outputStreamConfig.setPrimaryKey(originalStreamConfig.getPrimaryKey()); } else { outputStreamConfig.setPrimaryKey(discoveredStreamConfig.getPrimaryKey()); }  outputStreamConfig.setAliasName(originalStreamConfig.getAliasName()); outputStreamConfig.setSelected(originalConfiguredStream.getConfig().getSelected()); outputStreamConfig.setSuggested(originalConfiguredStream.getConfig().getSuggested()); outputStreamConfig.setFieldSelectionEnabled(originalStreamConfig.getFieldSelectionEnabled());  if (outputStreamConfig.getFieldSelectionEnabled()) { // TODO(mfsiega-airbyte): support nested fields. // If field selection is enabled, populate the selected fields. final Set<String> originallyDiscovered = new HashSet<>(); final Set<String> refreshDiscovered = new HashSet<>(); // NOTE: by only taking the first element of the path, we're restricting to top-level fields. final Set<String> originallySelected = new HashSet<>( originalConfiguredStream.getConfig().getSelectedFields().stream().map((field) -> field.getFieldPath().get(0)).toList()); originalDiscoveredStream.getStream().getJsonSchema().findPath("properties").fieldNames() .forEachRemaining(originallyDiscovered::add); stream.getJsonSchema().findPath("properties").fieldNames().forEachRemaining(refreshDiscovered::add); // We include a selected field if it: // (is in the newly discovered schema) AND (it was either originally selected OR not in the // originally discovered schema at all) // NOTE: this implies that the default behaviour for newly-discovered columns is to add them. for (final String discoveredField : refreshDiscovered) { if (originallySelected.contains(discoveredField) || !originallyDiscovered.contains(discoveredField)) { outputStreamConfig.addSelectedFieldsItem(new SelectedFieldInfo().addFieldPathItem(discoveredField)); } } } else { outputStreamConfig.setSelectedFields(List.of()); }  } else { outputStreamConfig = discoveredStream.getConfig(); outputStreamConfig.setSelected(false); } final AirbyteStreamAndConfiguration outputStream = new AirbyteStreamAndConfiguration() .stream(Jsons.clone(stream)) .config(outputStreamConfig); streams.add(outputStream); } return new AirbyteCatalog().streams(streams); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testUpdateSchemaWithNamespacedStreams() { final AirbyteCatalog original = ConnectionHelpers.generateBasicApiCatalog(); final AirbyteStreamAndConfiguration stream1Config = original.getStreams().get(0); final AirbyteStream stream1 = stream1Config.getStream(); final AirbyteStream stream2 = new AirbyteStream() .name(stream1.getName()) .namespace("second_namespace") .jsonSchema(stream1.getJsonSchema()) .defaultCursorField(stream1.getDefaultCursorField()) .supportedSyncModes(stream1.getSupportedSyncModes()) .sourceDefinedCursor(stream1.getSourceDefinedCursor()) .sourceDefinedPrimaryKey(stream1.getSourceDefinedPrimaryKey()); final AirbyteStreamAndConfiguration stream2Config = new AirbyteStreamAndConfiguration() .config(stream1Config.getConfig()) .stream(stream2); original.getStreams().add(stream2Config);  final AirbyteCatalog discovered = ConnectionHelpers.generateBasicApiCatalog(); discovered.getStreams().get(0).getStream() .name(STREAM1) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD1, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH)); discovered.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1);  final AirbyteCatalog expected = ConnectionHelpers.generateBasicApiCatalog(); expected.getStreams().get(0).getStream() .name(STREAM1) .jsonSchema(CatalogHelpers.fieldsToJsonSchema(Field.of(FIELD1, JsonSchemaType.STRING))) .supportedSyncModes(List.of(SyncMode.FULL_REFRESH)); expected.getStreams().get(0).getConfig() .syncMode(SyncMode.FULL_REFRESH) .cursorField(Collections.emptyList()) .destinationSyncMode(DestinationSyncMode.OVERWRITE) .primaryKey(Collections.emptyList()) .aliasName(STREAM1) .selected(false) .suggested(false) .selectedFields(List.of());  final AirbyteCatalog actual = WebBackendConnectionsHandler.updateSchemaWithRefreshedDiscoveredCatalog(original, original, discovered);  "<AssertPlaceHolder>"; }
updateSchemaWithRefreshedDiscoveredCatalog(final AirbyteCatalog originalConfigured, final AirbyteCatalog originalDiscovered, final AirbyteCatalog discovered) { /* * We can't directly use s.getStream() as the key, because it contains a bunch of other fields, so * we just define a quick-and-dirty record class. */ final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalStream = originalConfigured.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s)); final Map<Stream, AirbyteStreamAndConfiguration> streamDescriptorToOriginalDiscoveredStream = originalDiscovered.getStreams() .stream() .collect(toMap(s -> new Stream(s.getStream().getName(), s.getStream().getNamespace()), s -> s));  final List<AirbyteStreamAndConfiguration> streams = new ArrayList<>();  for (final AirbyteStreamAndConfiguration discoveredStream : discovered.getStreams()) { final AirbyteStream stream = discoveredStream.getStream(); final AirbyteStreamAndConfiguration originalConfiguredStream = streamDescriptorToOriginalStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamAndConfiguration originalDiscoveredStream = streamDescriptorToOriginalDiscoveredStream.get( new Stream(stream.getName(), stream.getNamespace())); final AirbyteStreamConfiguration outputStreamConfig;  if (originalConfiguredStream != null) { final AirbyteStreamConfiguration originalStreamConfig = originalConfiguredStream.getConfig(); final AirbyteStreamConfiguration discoveredStreamConfig = discoveredStream.getConfig(); outputStreamConfig = new AirbyteStreamConfiguration();  if (stream.getSupportedSyncModes().contains(originalStreamConfig.getSyncMode())) { outputStreamConfig.setSyncMode(originalStreamConfig.getSyncMode()); } else { outputStreamConfig.setSyncMode(discoveredStreamConfig.getSyncMode()); }  if (!originalStreamConfig.getCursorField().isEmpty()) { outputStreamConfig.setCursorField(originalStreamConfig.getCursorField()); } else { outputStreamConfig.setCursorField(discoveredStreamConfig.getCursorField()); }  outputStreamConfig.setDestinationSyncMode(originalStreamConfig.getDestinationSyncMode());  final boolean hasSourceDefinedPK = stream.getSourceDefinedPrimaryKey() != null && !stream.getSourceDefinedPrimaryKey().isEmpty(); if (hasSourceDefinedPK) { outputStreamConfig.setPrimaryKey(stream.getSourceDefinedPrimaryKey()); } else if (!originalStreamConfig.getPrimaryKey().isEmpty()) { outputStreamConfig.setPrimaryKey(originalStreamConfig.getPrimaryKey()); } else { outputStreamConfig.setPrimaryKey(discoveredStreamConfig.getPrimaryKey()); }  outputStreamConfig.setAliasName(originalStreamConfig.getAliasName()); outputStreamConfig.setSelected(originalConfiguredStream.getConfig().getSelected()); outputStreamConfig.setSuggested(originalConfiguredStream.getConfig().getSuggested()); outputStreamConfig.setFieldSelectionEnabled(originalStreamConfig.getFieldSelectionEnabled());  if (outputStreamConfig.getFieldSelectionEnabled()) { // TODO(mfsiega-airbyte): support nested fields. // If field selection is enabled, populate the selected fields. final Set<String> originallyDiscovered = new HashSet<>(); final Set<String> refreshDiscovered = new HashSet<>(); // NOTE: by only taking the first element of the path, we're restricting to top-level fields. final Set<String> originallySelected = new HashSet<>( originalConfiguredStream.getConfig().getSelectedFields().stream().map((field) -> field.getFieldPath().get(0)).toList()); originalDiscoveredStream.getStream().getJsonSchema().findPath("properties").fieldNames() .forEachRemaining(originallyDiscovered::add); stream.getJsonSchema().findPath("properties").fieldNames().forEachRemaining(refreshDiscovered::add); // We include a selected field if it: // (is in the newly discovered schema) AND (it was either originally selected OR not in the // originally discovered schema at all) // NOTE: this implies that the default behaviour for newly-discovered columns is to add them. for (final String discoveredField : refreshDiscovered) { if (originallySelected.contains(discoveredField) || !originallyDiscovered.contains(discoveredField)) { outputStreamConfig.addSelectedFieldsItem(new SelectedFieldInfo().addFieldPathItem(discoveredField)); } } } else { outputStreamConfig.setSelectedFields(List.of()); }  } else { outputStreamConfig = discoveredStream.getConfig(); outputStreamConfig.setSelected(false); } final AirbyteStreamAndConfiguration outputStream = new AirbyteStreamAndConfiguration() .stream(Jsons.clone(stream)) .config(outputStreamConfig); streams.add(outputStream); } return new AirbyteCatalog().streams(streams); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testListGeographiesOSS() { final WebBackendGeographiesListResult expected = new WebBackendGeographiesListResult().geographies( List.of(Geography.AUTO));  final WebBackendGeographiesListResult actual = webBackendGeographiesHandler.listGeographiesOSS();  Assertions."<AssertPlaceHolder>"; }
listGeographiesOSS() { // for now, OSS only supports AUTO. This can evolve to account for complex OSS use cases, but for // now we expect OSS deployments to use a single default Task Queue for scheduling syncs in a vast // majority of cases. return new WebBackendGeographiesListResult().geographies( Collections.singletonList(Geography.AUTO)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testListGeographiesCloud() { final WebBackendGeographiesListResult expected = new WebBackendGeographiesListResult().geographies( List.of(Geography.AUTO, Geography.US, Geography.EU));  final WebBackendGeographiesListResult actual = webBackendGeographiesHandler.listGeographiesCloud();  Assertions."<AssertPlaceHolder>"; }
listGeographiesCloud() { return new WebBackendGeographiesListResult().geographies(Arrays.asList(Geography.values())); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ConfigNotFoundException { workspace.withWebhookOperationConfigs(PERSISTED_WEBHOOK_CONFIGS); when(configRepository.getStandardWorkspaceNoSecrets(any(), eq(false))).thenReturn(workspace);  final UUID uuid = UUID.randomUUID(); when(uuidSupplier.get()).thenReturn(uuid);  configRepository.writeStandardWorkspaceNoSecrets(workspace);  final WorkspaceCreate workspaceCreate = new WorkspaceCreate() .name(NEW_WORKSPACE) .email(TEST_EMAIL) .news(false) .anonymousDataCollection(false) .securityUpdates(false) .notifications(List.of(generateApiNotification())) .notificationSettings(generateApiNotificationSettings()) .defaultGeography(GEOGRAPHY_US) .webhookConfigs(List.of(new WebhookConfigWrite().name(TEST_NAME).authToken(TEST_AUTH_TOKEN))) .organizationId(ORGANIZATION_ID);  when(secretPersistence.read(any())).thenReturn("");  final WorkspaceRead actualRead = workspacesHandler.createWorkspace(workspaceCreate); final WorkspaceRead expectedRead = new WorkspaceRead() .workspaceId(uuid) .customerId(uuid) .email(TEST_EMAIL) .name(NEW_WORKSPACE) .slug("new-workspace") .initialSetupComplete(false) .displaySetupWizard(false) .news(false) .anonymousDataCollection(false) .securityUpdates(false) .notifications(List.of(generateApiNotification())) .notificationSettings(generateApiNotificationSettingsWithDefaultValue()) .defaultGeography(GEOGRAPHY_US) .webhookConfigs(List.of(new WebhookConfigRead().id(uuid).name(TEST_NAME))) .organizationId(ORGANIZATION_ID) .tombstone(false);  "<AssertPlaceHolder>"; }
createWorkspace(final WorkspaceCreate workspaceCreate) throws JsonValidationException, IOException, ValueConflictKnownException, ConfigNotFoundException {  final WorkspaceCreateWithId workspaceCreateWithId = new WorkspaceCreateWithId() .id(uuidSupplier.get()) .organizationId(workspaceCreate.getOrganizationId()) .defaultGeography(workspaceCreate.getDefaultGeography()) .displaySetupWizard(workspaceCreate.getDisplaySetupWizard()) .name(workspaceCreate.getName()) .notifications(workspaceCreate.getNotifications()) .webhookConfigs(workspaceCreate.getWebhookConfigs()) .anonymousDataCollection(workspaceCreate.getAnonymousDataCollection()) .email(workspaceCreate.getEmail()) .news(workspaceCreate.getNews()) .notificationSettings(workspaceCreate.getNotificationSettings()) .securityUpdates(workspaceCreate.getSecurityUpdates());  return createWorkspaceIfNotExist(workspaceCreateWithId); }
[*] target: assertEquals(expectedRead, actualRead)
[-] pred: org. junit. Assert. assertEquals ( expectedRead, actualRead )
************************************
************************************
[+] input: ConfigNotFoundException { when(configRepository.getStandardWorkspaceNoSecrets(any(), eq(false))).thenReturn(workspace);  final UUID uuid = UUID.randomUUID(); when(uuidSupplier.get()).thenReturn(uuid);  configRepository.writeStandardWorkspaceNoSecrets(workspace);  final WorkspaceCreate workspaceCreate = new WorkspaceCreate() .name(NEW_WORKSPACE) .email(TEST_EMAIL) .organizationId(ORGANIZATION_ID);  final WorkspaceRead actualRead = workspacesHandler.createWorkspace(workspaceCreate); final WorkspaceRead expectedRead = new WorkspaceRead() .workspaceId(actualRead.getWorkspaceId()) .customerId(actualRead.getCustomerId()) .email(TEST_EMAIL) .name(NEW_WORKSPACE) .slug(actualRead.getSlug()) .initialSetupComplete(false) .displaySetupWizard(false) .news(false) .anonymousDataCollection(false) .securityUpdates(false) .notifications(List.of()) .notificationSettings(generateDefaultApiNotificationSettings()) .defaultGeography(GEOGRAPHY_AUTO) .webhookConfigs(Collections.emptyList()) .tombstone(false) .organizationId(ORGANIZATION_ID);  "<AssertPlaceHolder>"; }
createWorkspace(final WorkspaceCreate workspaceCreate) throws JsonValidationException, IOException, ValueConflictKnownException, ConfigNotFoundException {  final WorkspaceCreateWithId workspaceCreateWithId = new WorkspaceCreateWithId() .id(uuidSupplier.get()) .organizationId(workspaceCreate.getOrganizationId()) .defaultGeography(workspaceCreate.getDefaultGeography()) .displaySetupWizard(workspaceCreate.getDisplaySetupWizard()) .name(workspaceCreate.getName()) .notifications(workspaceCreate.getNotifications()) .webhookConfigs(workspaceCreate.getWebhookConfigs()) .anonymousDataCollection(workspaceCreate.getAnonymousDataCollection()) .email(workspaceCreate.getEmail()) .news(workspaceCreate.getNews()) .notificationSettings(workspaceCreate.getNotificationSettings()) .securityUpdates(workspaceCreate.getSecurityUpdates());  return createWorkspaceIfNotExist(workspaceCreateWithId); }
[*] target: assertEquals(expectedRead, actualRead)
[-] pred: org. junit. Assert. assertEquals ( expectedRead, actualRead )
************************************
************************************
[+] input: JsonValidationException { final ConnectorSpecification connectorSpecification = ConnectorSpecificationHelpers.generateAdvancedAuthConnectorSpecification(); final Map<String, List<String>> result = OAuthSecretHelper.getOAuthConfigPaths(connectorSpecification); final Map<String, List<String>> expected = Map.of( REFRESH_TOKEN, List.of(REFRESH_TOKEN), CLIENT_ID, List.of(CLIENT_ID), CLIENT_SECRET, List.of(CLIENT_SECRET)); "<AssertPlaceHolder>"; }
getOAuthConfigPaths(ConnectorSpecification spec) throws JsonValidationException { if (OAuthConfigSupplier.hasOAuthConfigSpecification(spec)) { return getAdvancedAuthOAuthPaths(spec, true); } else { throw new IllegalStateException("No OAuth data in specification"); } }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: JsonValidationException { final ConnectorSpecification connectorSpecification = ConnectorSpecificationHelpers.generateNestedAdvancedAuthConnectorSpecification(); final Map<String, List<String>> result = OAuthSecretHelper.getOAuthInputPaths(connectorSpecification); final Map<String, List<String>> expected = Map.of( CLIENT_ID, List.of(CREDENTIALS, CLIENT_ID), CLIENT_SECRET, List.of(CREDENTIALS, CLIENT_SECRET)); "<AssertPlaceHolder>"; }
getOAuthInputPaths(ConnectorSpecification spec) throws JsonValidationException { if (OAuthConfigSupplier.hasOAuthConfigSpecification(spec)) { return getAdvancedAuthOAuthPaths(spec, false); } else { throw new IllegalStateException("No OAuth data in specification"); } }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: JsonValidationException { final ConnectorSpecification connectorSpecification = ConnectorSpecificationHelpers.generateAdvancedAuthConnectorSpecification(); final Map<String, List<String>> result = OAuthSecretHelper.getOAuthInputPaths(connectorSpecification); final Map<String, List<String>> expected = Map.of( CLIENT_ID, List.of(CLIENT_ID), CLIENT_SECRET, List.of(CLIENT_SECRET)); "<AssertPlaceHolder>"; }
getOAuthInputPaths(ConnectorSpecification spec) throws JsonValidationException { if (OAuthConfigSupplier.hasOAuthConfigSpecification(spec)) { return getAdvancedAuthOAuthPaths(spec, false); } else { throw new IllegalStateException("No OAuth data in specification"); } }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: Exception { final UUID userId = UUID.randomUUID(); final Map<String, String> properties = Map.of(AIRBYTE_USER_ID_HEADER, userId.toString()); final Set<String> expectedAuthUserIds = Set.of(AUTH_USER_ID, "some-other-id"); when(userPersistence.listAuthUserIdsForUser(userId)).thenReturn(expectedAuthUserIds.stream().toList());  final Set<String> resolvedAuthUserIds = resolver.resolveAuthUserIds(properties);  "<AssertPlaceHolder>"; }
resolveAuthUserIds(final Map<String, String> properties) { log.debug("properties: {}", properties); try { if (properties.containsKey(EXTERNAL_AUTH_ID_HEADER)) { final String authUserId = properties.get(EXTERNAL_AUTH_ID_HEADER); return Set.of(authUserId); } else if (properties.containsKey(AIRBYTE_USER_ID_HEADER)) { return resolveAirbyteUserIdToAuthUserIds(properties.get(AIRBYTE_USER_ID_HEADER)); } else if (properties.containsKey(CREATOR_USER_ID_HEADER)) { return resolveAirbyteUserIdToAuthUserIds(properties.get(CREATOR_USER_ID_HEADER)); } else { log.debug("Request does not contain any headers that resolve to a user ID."); return null; } } catch (final Exception e) { log.debug("Unable to resolve user ID.", e); return null; } }
[*] target: assertEquals(expectedAuthUserIds, resolvedAuthUserIds)
[-] pred: org. junit. Assert. assertEquals ( expectedAuthUserIds, resolvedAuthUserIds )
************************************
************************************
[+] input: Exception { final UUID userId = UUID.randomUUID(); final Map<String, String> properties = Map.of(CREATOR_USER_ID_HEADER, userId.toString()); final Set<String> expectedAuthUserIds = Set.of(AUTH_USER_ID, "some-other-id"); when(userPersistence.listAuthUserIdsForUser(userId)).thenReturn(expectedAuthUserIds.stream().toList());  final Set<String> resolvedAuthUserIds = resolver.resolveAuthUserIds(properties);  "<AssertPlaceHolder>"; }
resolveAuthUserIds(final Map<String, String> properties) { log.debug("properties: {}", properties); try { if (properties.containsKey(EXTERNAL_AUTH_ID_HEADER)) { final String authUserId = properties.get(EXTERNAL_AUTH_ID_HEADER); return Set.of(authUserId); } else if (properties.containsKey(AIRBYTE_USER_ID_HEADER)) { return resolveAirbyteUserIdToAuthUserIds(properties.get(AIRBYTE_USER_ID_HEADER)); } else if (properties.containsKey(CREATOR_USER_ID_HEADER)) { return resolveAirbyteUserIdToAuthUserIds(properties.get(CREATOR_USER_ID_HEADER)); } else { log.debug("Request does not contain any headers that resolve to a user ID."); return null; } } catch (final Exception e) { log.debug("Unable to resolve user ID.", e); return null; } }
[*] target: assertEquals(expectedAuthUserIds, resolvedAuthUserIds)
[-] pred: org. junit. Assert. assertEquals ( expectedAuthUserIds, resolvedAuthUserIds )
************************************
************************************
[+] input: getInstanceAdminRoles() { final Set<String> expectedRoles = Set.of( AuthRole.ADMIN.getLabel(), AuthRole.EDITOR.getLabel(), AuthRole.READER.getLabel(), AuthRole.AUTHENTICATED_USER.getLabel(), WorkspaceAuthRole.WORKSPACE_ADMIN.getLabel(), WorkspaceAuthRole.WORKSPACE_EDITOR.getLabel(), WorkspaceAuthRole.WORKSPACE_READER.getLabel(), OrganizationAuthRole.ORGANIZATION_ADMIN.getLabel(), OrganizationAuthRole.ORGANIZATION_EDITOR.getLabel(), OrganizationAuthRole.ORGANIZATION_READER.getLabel(), OrganizationAuthRole.ORGANIZATION_MEMBER.getLabel());  final Set<String> actualRoles = RbacRoleHelper.getInstanceAdminRoles();  Assertions."<AssertPlaceHolder>"; }
getInstanceAdminRoles() { final Set<String> roles = new HashSet<>(); roles.addAll(AuthRole.buildAuthRolesSet(AuthRole.ADMIN)); roles.addAll(WorkspaceAuthRole.buildWorkspaceAuthRolesSet(WorkspaceAuthRole.WORKSPACE_ADMIN)); roles.addAll(OrganizationAuthRole.buildOrganizationAuthRolesSet(OrganizationAuthRole.ORGANIZATION_ADMIN)); // For now, SELF is intentionally excluded from instance admin roles. If a user-centric endpoint // should be // callable by an instance admin, then the endpoint should be annotated with ADMIN in addition to // SELF. return roles; }
[*] target: assertEquals(expectedRoles, actualRoles)
[-] pred: org. junit. Assert. assertEquals ( expectedRoles, actualRoles )
************************************
************************************
[+] input: testBlockingDescribeWorkflowExecution() { final DescribeWorkflowExecutionResponse expected = mock(DescribeWorkflowExecutionResponse.class); when(temporalWorkflowServiceBlockingStub.describeWorkflowExecution(any())) .thenThrow(unavailable()) .thenReturn(expected);  final DescribeWorkflowExecutionResponse actual = workflowClient.blockingDescribeWorkflowExecution(mock(DescribeWorkflowExecutionRequest.class)); "<AssertPlaceHolder>"; }
blockingDescribeWorkflowExecution(final DescribeWorkflowExecutionRequest request) { return withRetries(() -> temporalWorkflowClient.getWorkflowServiceStubs().blockingStub().describeWorkflowExecution(request), "describeWorkflowExecution"); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testListClosedWorkflowExecutions() { final var request = ListClosedWorkflowExecutionsRequest.newBuilder().build(); final var response = ListClosedWorkflowExecutionsResponse.newBuilder().build(); when(temporalWorkflowServiceBlockingStub.listClosedWorkflowExecutions(request)) .thenThrow(unavailable()) .thenReturn(response);  final var actual = serviceStubsWrapped.blockingStubListClosedWorkflowExecutions(request); "<AssertPlaceHolder>"; }
blockingStubListClosedWorkflowExecutions(final ListClosedWorkflowExecutionsRequest request) { return withRetries(() -> workflowServiceStubs.blockingStub().listClosedWorkflowExecutions(request), "listClosedWorkflowExecutions"); }
[*] target: assertEquals(response, actual)
[-] pred: org. junit. Assert. assertEquals ( response, actual )
************************************
************************************
[+] input: testListOpenWorkflowExecutions() { final var request = ListOpenWorkflowExecutionsRequest.newBuilder().build(); final var response = ListOpenWorkflowExecutionsResponse.newBuilder().build(); when(temporalWorkflowServiceBlockingStub.listOpenWorkflowExecutions(request)) .thenThrow(unavailable()) .thenReturn(response);  final var actual = serviceStubsWrapped.blockingStubListOpenWorkflowExecutions(request); "<AssertPlaceHolder>"; }
blockingStubListOpenWorkflowExecutions(final ListOpenWorkflowExecutionsRequest request) { return withRetries(() -> workflowServiceStubs.blockingStub().listOpenWorkflowExecutions(request), "listOpenWorkflowExecutions"); }
[*] target: assertEquals(response, actual)
[-] pred: org. junit. Assert. assertEquals ( response, actual )
************************************
************************************
[+] input: IOException { final List<UserPermission> userPermissions = permissionPersistence.listUsersInOrganization(MockData.ORGANIZATION_ID_1); Assertions."<AssertPlaceHolder>"; }
listUsersInOrganization(final UUID organizationId) throws IOException { return this.database.query(ctx -> listPermissionsForOrganization(ctx, organizationId)); }
[*] target: assertEquals(1, userPermissions.size())
[-] pred: org. junit. Assert. assertEquals ( 1, userPermissions. size ( ) )
************************************
************************************
[+] input: IOException { for (final User user : MockData.users()) { final Optional<User> userFromDb = userPersistence.getUserByEmail(user.getEmail()); Assertions."<AssertPlaceHolder>"; } }
getUserByEmail(final String email) throws IOException { final Result<Record> result = database.query(ctx -> ctx .select(asterisk()) .from(USER) .leftJoin(AUTH_USER).on(USER.ID.eq(AUTH_USER.USER_ID)) .where(USER.EMAIL.eq(email)).fetch());  if (result.isEmpty()) { return Optional.empty(); }  // FIXME: in the case of multiple auth providers, this will return the first one found. return Optional.of(createUserFromRecord(result.get(0))); }
[*] target: assertEquals(user, userFromDb.get())
[-] pred: org. junit. Assert. assertEquals ( user, userFromDb. get ( ) )
************************************
************************************
[+] input: IOException { final StandardWorkspace expectedWorkspace = createBaseStandardWorkspace() .withWorkspaceId(UUID.randomUUID()) .withOrganizationId(MockData.ORGANIZATION_ID_1) .withName("workspaceInOrganization1");  configRepository.writeStandardWorkspaceNoSecrets(expectedWorkspace);  final StandardWorkspace tombstonedWorkspace = createBaseStandardWorkspace() .withWorkspaceId(UUID.randomUUID()) .withOrganizationId(MockData.ORGANIZATION_ID_1) .withName("tombstonedWorkspace") .withTombstone(true);  configRepository.writeStandardWorkspaceNoSecrets(tombstonedWorkspace);  final StandardWorkspace laterWorkspace = createBaseStandardWorkspace() .withWorkspaceId(UUID.randomUUID()) .withOrganizationId(MockData.ORGANIZATION_ID_1) .withName("laterWorkspace");  configRepository.writeStandardWorkspaceNoSecrets(laterWorkspace);  final StandardWorkspace actualWorkspace = workspacePersistence.getDefaultWorkspaceForOrganization(MockData.ORGANIZATION_ID_1);  "<AssertPlaceHolder>"; }
getDefaultWorkspaceForOrganization(final UUID organizationId) throws IOException { return database.query(ctx -> ctx.select(WORKSPACE.asterisk()) .from(WORKSPACE) .where(WORKSPACE.ORGANIZATION_ID.eq(organizationId)) .and(WORKSPACE.TOMBSTONE.notEqual(true)) .orderBy(WORKSPACE.CREATED_AT.asc()) .limit(1) .fetch()) .stream() .map(DbConverter::buildStandardWorkspace) .findFirst() .orElseThrow(() -> new RuntimeException("No workspace found for organization: " + organizationId)); }
[*] target: assertEquals(expectedWorkspace, actualWorkspace)
[-] pred: org. junit. Assert. assertEquals ( expectedWorkspace, actualWorkspace )
************************************
************************************
[+] input: testCreatePythonPathFromListOfPaths() { List<String> subdirectories = Lists.newArrayList("source-connector", "destination-connector"); String pythonpath = ApplicationBeanFactory.createPythonPathFromListOfPaths(ROOT_PATH, subdirectories);  String expectedPythonPath = "/path/to/root/source-connector:/path/to/root/destination-connector";  "<AssertPlaceHolder>"; }
createPythonPathFromListOfPaths(final String path, final List<String> subdirectories) { /* * Creates a `:`-separated path of all connector directories. The connector directories that contain * a python module can then be imported. */ return subdirectories.stream() .map(subdirectory -> path + "/" + subdirectory) .collect(Collectors.joining(":")); }
[*] target: assertEquals(expectedPythonPath, pythonpath)
[-] pred: org. junit. Assert. assertEquals ( expectedPythonPath, pythonpath )
************************************
************************************
[+] input: testCreatePythonPathFromListOfPathsNoSubdirectories() { // This test case verifies the scenario where no local files are mounted List<String> subdirectories = Lists.newArrayList(); String pythonpath = ApplicationBeanFactory.createPythonPathFromListOfPaths(ROOT_PATH, subdirectories);  String expectedPythonPath = "";  "<AssertPlaceHolder>"; }
createPythonPathFromListOfPaths(final String path, final List<String> subdirectories) { /* * Creates a `:`-separated path of all connector directories. The connector directories that contain * a python module can then be imported. */ return subdirectories.stream() .map(subdirectory -> path + "/" + subdirectory) .collect(Collectors.joining(":")); }
[*] target: assertEquals(expectedPythonPath, pythonpath)
[-] pred: org. junit. Assert. assertEquals ( expectedPythonPath, pythonpath )
************************************
************************************
[+] input: JsonProcessingException { Notification notification = new Notification(); notification.setText("test content");  ObjectMapper mapper = new ObjectMapper();  JsonNode expected = mapper.readTree(""" { "text": "test content" }"""); "<AssertPlaceHolder>"; }
toJsonNode() { JsonNodeFactory jsonNodeFactory = JsonNodeFactory.instance; ObjectNode node = jsonNodeFactory.objectNode(); if (text != null) { node.put("text", text); }  if (!blocks.isEmpty()) { ArrayNode blocksNode = jsonNodeFactory.arrayNode(); for (Block block : blocks) { blocksNode.add(block.toJsonNode()); } node.put("blocks", blocksNode); } if (data != null) { node.put("data", MAPPER.valueToTree(data)); } return node; }
[*] target: assertEquals(expected, notification.toJsonNode())
[-] pred: org. junit. Assert. assertEquals ( expected, notification. toJsonNode ( ) )
************************************
************************************
[+] input: testFlattenConfig() { final JsonNode nestedConfig = Jsons.jsonNode(Map.of( FIELD, "value1", "top-level", Map.of( "nested_field", "value2"))); final JsonNode expectedConfig = Jsons.jsonNode(Map.of( FIELD, "value1", "nested_field", "value2")); final JsonNode actualConfig = MoreOAuthParameters.flattenOAuthConfig(nestedConfig); "<AssertPlaceHolder>"; }
flattenOAuthConfig(final JsonNode config) { if (config.getNodeType() == OBJECT) { return flattenOAuthConfig((ObjectNode) Jsons.emptyObject(), (ObjectNode) config); } else { throw new IllegalStateException("Config is not an Object config, unable to flatten"); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: testInjectUnnestedNode() { final ObjectNode oauthParams = (ObjectNode) Jsons.jsonNode(generateOAuthParameters());  final ObjectNode actual = generateJsonConfig(); final ObjectNode expected = Jsons.clone(actual); expected.setAll(oauthParams);  MoreOAuthParameters.mergeJsons(actual, oauthParams);  "<AssertPlaceHolder>"; }
mergeJsons(final ObjectNode mainConfig, final ObjectNode fromConfig) { for (final String key : Jsons.keys(fromConfig)) { // keys with _secret Jsons are objects but we still want to merge those if (fromConfig.get(key).getNodeType() == OBJECT && !isSecretNode(fromConfig.get(key))) { // nested objects are merged rather than overwrite the contents of the equivalent object in config if (mainConfig.get(key) == null) { mergeJsons(mainConfig.putObject(key), (ObjectNode) fromConfig.get(key)); } else if (mainConfig.get(key).getNodeType() == OBJECT) { mergeJsons((ObjectNode) mainConfig.get(key), (ObjectNode) fromConfig.get(key)); } else { throw new IllegalStateException("Can't merge an object node into a non-object node!"); } } else { if (!mainConfig.has(key) || isSecretMask(mainConfig.get(key).asText())) { LOGGER.debug(String.format("injecting instance wide parameter %s into config", key)); mainConfig.set(key, fromConfig.get(key)); } } } return mainConfig; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testDefinitionDefaultReqsOverrideWorker() { final ResourceRequirements workerDefaultReqs = new ResourceRequirements().withCpuRequest("1").withCpuLimit("1"); final ResourceRequirements definitionDefaultReqs = new ResourceRequirements().withCpuLimit("2").withMemoryRequest("100Mi"); final ActorDefinitionResourceRequirements definitionReqs = new ActorDefinitionResourceRequirements().withDefault(definitionDefaultReqs);  final ResourceRequirements result = ResourceRequirementsUtils.getResourceRequirements( null, definitionReqs, workerDefaultReqs, JobType.SYNC);  final ResourceRequirements expectedReqs = new ResourceRequirements() .withCpuRequest("1") .withCpuLimit("2") .withMemoryRequest("100Mi");  "<AssertPlaceHolder>"; }
getResourceRequirements(@Nullable final ResourceRequirements connectionResourceReqs, @Nullable final ActorDefinitionResourceRequirements actorDefinitionResourceReqs, @Nullable final ResourceRequirements workerDefaultResourceReqs, final JobType jobType) { final ResourceRequirements jobSpecificDefinitionResourceReqs = getResourceRequirementsForJobType(actorDefinitionResourceReqs, jobType) .orElse(null); final ResourceRequirements defaultDefinitionResourceReqs = Optional.ofNullable(actorDefinitionResourceReqs) .map(ActorDefinitionResourceRequirements::getDefault).orElse(null); return mergeResourceRequirements( connectionResourceReqs, jobSpecificDefinitionResourceReqs, defaultDefinitionResourceReqs, workerDefaultResourceReqs); }
[*] target: assertEquals(expectedReqs, result)
[-] pred: org. junit. Assert. assertEquals ( expectedReqs, result )
************************************
************************************
[+] input: testJobSpecificReqsOverrideDefault() { final ResourceRequirements workerDefaultReqs = new ResourceRequirements().withCpuRequest("1").withCpuLimit("1"); final ResourceRequirements definitionDefaultReqs = new ResourceRequirements().withCpuLimit("2").withMemoryRequest("100Mi"); final JobTypeResourceLimit jobTypeResourceLimit = new JobTypeResourceLimit().withJobType(JobType.SYNC).withResourceRequirements( new ResourceRequirements().withCpuRequest("2").withMemoryRequest("200Mi").withMemoryLimit("300Mi")); final ActorDefinitionResourceRequirements definitionReqs = new ActorDefinitionResourceRequirements() .withDefault(definitionDefaultReqs) .withJobSpecific(List.of(jobTypeResourceLimit));  final ResourceRequirements result = ResourceRequirementsUtils.getResourceRequirements( null, definitionReqs, workerDefaultReqs, JobType.SYNC);  final ResourceRequirements expectedReqs = new ResourceRequirements() .withCpuRequest("2") .withCpuLimit("2") .withMemoryRequest("200Mi") .withMemoryLimit("300Mi"); "<AssertPlaceHolder>"; }
getResourceRequirements(@Nullable final ResourceRequirements connectionResourceReqs, @Nullable final ActorDefinitionResourceRequirements actorDefinitionResourceReqs, @Nullable final ResourceRequirements workerDefaultResourceReqs, final JobType jobType) { final ResourceRequirements jobSpecificDefinitionResourceReqs = getResourceRequirementsForJobType(actorDefinitionResourceReqs, jobType) .orElse(null); final ResourceRequirements defaultDefinitionResourceReqs = Optional.ofNullable(actorDefinitionResourceReqs) .map(ActorDefinitionResourceRequirements::getDefault).orElse(null); return mergeResourceRequirements( connectionResourceReqs, jobSpecificDefinitionResourceReqs, defaultDefinitionResourceReqs, workerDefaultResourceReqs); }
[*] target: assertEquals(expectedReqs, result)
[-] pred: org. junit. Assert. assertEquals ( expectedReqs, result )
************************************
************************************
[+] input: testConnectionResourceRequirementsOverrideDefault() { final ResourceRequirements workerDefaultReqs = new ResourceRequirements().withCpuRequest("1"); final ResourceRequirements definitionDefaultReqs = new ResourceRequirements().withCpuLimit("2").withCpuRequest("2"); final JobTypeResourceLimit jobTypeResourceLimit = new JobTypeResourceLimit().withJobType(JobType.SYNC).withResourceRequirements( new ResourceRequirements().withCpuLimit("3").withMemoryRequest("200Mi")); final ActorDefinitionResourceRequirements definitionReqs = new ActorDefinitionResourceRequirements() .withDefault(definitionDefaultReqs) .withJobSpecific(List.of(jobTypeResourceLimit)); final ResourceRequirements connectionResourceRequirements = new ResourceRequirements().withMemoryRequest("400Mi").withMemoryLimit(FIVE_HUNDRED_MEM);  final ResourceRequirements result = ResourceRequirementsUtils.getResourceRequirements( connectionResourceRequirements, definitionReqs, workerDefaultReqs, JobType.SYNC);  final ResourceRequirements expectedReqs = new ResourceRequirements() .withCpuRequest("2") .withCpuLimit("3") .withMemoryRequest("400Mi") .withMemoryLimit(FIVE_HUNDRED_MEM); "<AssertPlaceHolder>"; }
getResourceRequirements(@Nullable final ResourceRequirements connectionResourceReqs, @Nullable final ActorDefinitionResourceRequirements actorDefinitionResourceReqs, @Nullable final ResourceRequirements workerDefaultResourceReqs, final JobType jobType) { final ResourceRequirements jobSpecificDefinitionResourceReqs = getResourceRequirementsForJobType(actorDefinitionResourceReqs, jobType) .orElse(null); final ResourceRequirements defaultDefinitionResourceReqs = Optional.ofNullable(actorDefinitionResourceReqs) .map(ActorDefinitionResourceRequirements::getDefault).orElse(null); return mergeResourceRequirements( connectionResourceReqs, jobSpecificDefinitionResourceReqs, defaultDefinitionResourceReqs, workerDefaultResourceReqs); }
[*] target: assertEquals(expectedReqs, result)
[-] pred: org. junit. Assert. assertEquals ( expectedReqs, result )
************************************
************************************
[+] input: testConnectionResourceRequirementsOverrideWorker() { final ResourceRequirements workerDefaultReqs = new ResourceRequirements().withCpuRequest("1").withCpuLimit("1"); final ResourceRequirements connectionResourceRequirements = new ResourceRequirements().withCpuLimit("2").withMemoryLimit(FIVE_HUNDRED_MEM);  final ResourceRequirements result = ResourceRequirementsUtils.getResourceRequirements(connectionResourceRequirements, workerDefaultReqs);  final ResourceRequirements expectedReqs = new ResourceRequirements() .withCpuRequest("1") .withCpuLimit("2") .withMemoryLimit(FIVE_HUNDRED_MEM); "<AssertPlaceHolder>"; }
getResourceRequirements(@Nullable final ResourceRequirements higherPriorityResourceReqs, @Nullable final ResourceRequirements lowerPriorityResourceReqs) { return mergeResourceRequirements( higherPriorityResourceReqs, lowerPriorityResourceReqs); }
[*] target: assertEquals(expectedReqs, result)
[-] pred: org. junit. Assert. assertEquals ( expectedReqs, result )
************************************
************************************
[+] input: testGetWorkspaceUrl() { final WebUrlHelper webUrlHelper = new WebUrlHelper(LOCALHOST_8000); final String workspaceUrl = webUrlHelper.getWorkspaceUrl(WORKSPACE_ID); final String expectedUrl = String.format("http://localhost:8000/workspaces/%s", WORKSPACE_ID); Assertions."<AssertPlaceHolder>"; }
getWorkspaceUrl(final UUID workspaceId) { return String.format("%s/workspaces/%s", getBaseUrl(), workspaceId); }
[*] target: assertEquals(expectedUrl, workspaceUrl)
[-] pred: org. junit. Assert. assertEquals ( expectedUrl, workspaceUrl )
************************************
************************************
[+] input: testGetConnectionUrl() { final WebUrlHelper webUrlHelper = new WebUrlHelper(LOCALHOST_8000); final String connectionUrl = webUrlHelper.getConnectionUrl(WORKSPACE_ID, CONNECTION_ID); final String expectedUrl = String.format("http://localhost:8000/workspaces/%s/connections/%s", WORKSPACE_ID, CONNECTION_ID); Assertions."<AssertPlaceHolder>"; }
getConnectionUrl(final UUID workspaceId, final UUID connectionId) { return String.format("%s/connections/%s", getWorkspaceUrl(workspaceId), connectionId); }
[*] target: assertEquals(expectedUrl, connectionUrl)
[-] pred: org. junit. Assert. assertEquals ( expectedUrl, connectionUrl )
************************************
************************************
[+] input: testGetSourceUrl() { final WebUrlHelper webUrlHelper = new WebUrlHelper(LOCALHOST_8000); final String sourceUrl = webUrlHelper.getSourceUrl(WORKSPACE_ID, SOURCE_ID); final String expectedUrl = String.format("%s/workspaces/%s/source/%s", LOCALHOST_8000, WORKSPACE_ID, SOURCE_ID); Assertions."<AssertPlaceHolder>"; }
getSourceUrl(final UUID workspaceId, final UUID sourceId) { return String.format("%s/source/%s", getWorkspaceUrl(workspaceId), sourceId); }
[*] target: assertEquals(expectedUrl, sourceUrl)
[-] pred: org. junit. Assert. assertEquals ( expectedUrl, sourceUrl )
************************************
************************************
[+] input: testGetDestinationUrl() { final WebUrlHelper webUrlHelper = new WebUrlHelper(LOCALHOST_8000); final String destinationUrl = webUrlHelper.getSourceUrl(WORKSPACE_ID, DESTINATION_ID); final String expectedUrl = String.format("%s/workspaces/%s/source/%s", LOCALHOST_8000, WORKSPACE_ID, DESTINATION_ID); Assertions."<AssertPlaceHolder>";  }
getSourceUrl(final UUID workspaceId, final UUID sourceId) { return String.format("%s/source/%s", getWorkspaceUrl(workspaceId), sourceId); }
[*] target: assertEquals(expectedUrl, destinationUrl)
[-] pred: org. junit. Assert. assertEquals ( expectedUrl, destinationUrl )
************************************
************************************
[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), testConnectorSpecification); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(config, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( config, actualConfig )
************************************
************************************
[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), testConnectorSpecification); final JsonNode expectedConfig = getExpectedNode(MoreOAuthParameters.SECRET_MASK); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final ConnectorSpecification spec = createConnectorSpecification(createAdvancedAuth() .withPredicateKey(null) .withPredicateValue(null)); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), spec); final JsonNode expectedConfig = getExpectedNode(MoreOAuthParameters.SECRET_MASK); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final ConnectorSpecification spec = createConnectorSpecification(createAdvancedAuth() .withPredicateKey(List.of(CREDENTIALS, AUTH_TYPE)) .withPredicateValue("")); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), spec); final JsonNode expectedConfig = getExpectedNode(MoreOAuthParameters.SECRET_MASK); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), null); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(config, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( config, actualConfig )
************************************
************************************
[+] input: IOException { // Until https://github.com/airbytehq/airbyte/issues/7624 is solved, we need to handle nested oauth // parameters final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateNestedOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.maskSourceOAuthParameters(sourceDefinitionId, workspaceId, Jsons.clone(config), testConnectorSpecification); final JsonNode expectedConfig = getExpectedNode(MoreOAuthParameters.SECRET_MASK); "<AssertPlaceHolder>"; }
maskSourceOAuthParameters(final UUID sourceDefinitionId, final UUID workspaceId, final JsonNode sourceConnectorConfig, final ConnectorSpecification sourceConnectorSpec) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> maskOauthParameters(sourceDefinition.getName(), sourceConnectorSpec, sourceConnectorConfig)); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: IOException { final String configJson = MoreResources.readResource("example_config.json"); final JsonNode config = Jsons.deserialize(configJson);  final String schemaJson = MoreResources.readResource("example_config_schema.json"); final JsonNode schema = Jsons.deserialize(schemaJson);  final Map<String, Object> expected = new ImmutableMap.Builder<String, Object>() .put("username", JobTracker.SET) .put("has_ssl", false) .put("password", JobTracker.SET) .put("one_of.type_key", "foo") .put("one_of.some_key", JobTracker.SET) .put("const_object.sub_key", "bar") .put("const_object.sub_array", "[1,2,3]") .put("const_object.sub_object.sub_sub_key", "baz") .put("enum_string", "foo") .put("additionalPropertiesUnset.foo", JobTracker.SET) .put("additionalPropertiesBoolean.foo", JobTracker.SET) .put("additionalPropertiesSchema.foo", JobTracker.SET) .put("additionalPropertiesConst.foo", 42) .put("additionalPropertiesEnumString", "foo") .build();  final Map<String, Object> actual = JobTracker.configToMetadata(config, schema);  "<AssertPlaceHolder>"; }
configToMetadata(final JsonNode config, final JsonNode schema) { if (schema.hasNonNull("const") || schema.hasNonNull("enum")) { // If this schema is a const or an enum, then just dump it into a map: // * If it's an object, flatten it // * Otherwise, do some basic conversions to value-ish data. // It would be a weird thing to declare const: null, but in that case we don't want to report null // anyway, so explicitly use hasNonNull. return Jsons.flatten(config); } else if (schema.has("oneOf")) { // If this schema is a oneOf, then find the first sub-schema which the config matches // and use that sub-schema to convert the config to a map final JsonSchemaValidator validator = new JsonSchemaValidator(); for (final Iterator<JsonNode> it = schema.get("oneOf").elements(); it.hasNext();) { final JsonNode subSchema = it.next(); if (validator.test(subSchema, config)) { return configToMetadata(config, subSchema); } } // If we didn't match any of the subschemas, then something is wrong. Bail out silently. return emptyMap(); } else if (config.isObject()) { // If the schema is not a oneOf, but the config is an object (i.e. the schema has "type": "object") // then we need to recursively convert each field of the object to a map. final Map<String, Object> output = new HashMap<>(); final JsonNode maybeProperties = schema.get("properties");  // If additionalProperties is not set, or it's a boolean, then there's no schema for additional // properties. Use the accept-all schema. // Otherwise, it's an actual schema. final JsonNode maybeAdditionalProperties = schema.get("additionalProperties"); final JsonNode additionalPropertiesSchema; if (maybeAdditionalProperties == null || maybeAdditionalProperties.isBoolean()) { additionalPropertiesSchema = OBJECT_MAPPER.createObjectNode(); } else { additionalPropertiesSchema = maybeAdditionalProperties; }  for (final Iterator<Entry<String, JsonNode>> it = config.fields(); it.hasNext();) { final Entry<String, JsonNode> entry = it.next(); final String field = entry.getKey(); final JsonNode value = entry.getValue();  final JsonNode propertySchema; if (maybeProperties != null && maybeProperties.hasNonNull(field)) { // If this property is explicitly declared, then use its schema propertySchema = maybeProperties.get(field); } else { // otherwise, use the additionalProperties schema propertySchema = additionalPropertiesSchema; }  Jsons.mergeMaps(output, field, configToMetadata(value, propertySchema)); } return output; } else if (config.isBoolean()) { return singletonMap(null, config.asBoolean()); } else if ((!config.isTextual() && !config.isNull()) || (config.isTextual() && !config.asText().isEmpty())) { // This is either non-textual (e.g. integer, array, etc) or non-empty text return singletonMap(null, SET); } else { // Otherwise, this is an empty string, so just ignore it return emptyMap(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ConfigNotFoundException { final UUID connectionId = UUID.randomUUID(); final String streamName = "tableA"; final String streamNamespace = "schemaA"; final ConnectionStream connectionStream = new ConnectionStream() .streamName(streamName) .streamNamespace(streamNamespace); final ConnectionStreamRequestBody connectionStreamRequestBody = new ConnectionStreamRequestBody() .connectionId(connectionId) .streams(List.of(connectionStream)); final JobInfoRead expectedJobInfoRead = new JobInfoRead();  when(schedulerHandler.resetConnectionStream(connectionStreamRequestBody)).thenReturn(expectedJobInfoRead);  final JobInfoRead jobInfoRead = connectionApiController.resetConnectionStream(connectionStreamRequestBody); Assertions."<AssertPlaceHolder>"; }
resetConnectionStream(@Body final ConnectionStreamRequestBody connectionStreamRequestBody) { return ApiHelper.execute(() -> schedulerHandler.resetConnectionStream(connectionStreamRequestBody)); }
[*] target: assertEquals(expectedJobInfoRead, jobInfoRead)
[-] pred: org. junit. Assert. assertEquals ( expectedJobInfoRead, jobInfoRead )
************************************
************************************
[+] input: InterruptedException { final HttpResponse mockHttpResponse = mock(HttpResponse.class); when(mockHttpResponse.statusCode()).thenReturn(HttpStatus.OK.getCode()).thenReturn(HttpStatus.OK.getCode()); when(secretsRepositoryReader.hydrateConfigFromDefaultSecretPersistence(any())).thenReturn(Jsons.jsonNode(WORKSPACE_WEBHOOK_CONFIGS)); final OperatorWebhookInput input = new OperatorWebhookInput() .withExecutionBody(WEBHOOK_EXECUTION_BODY) .withExecutionUrl(WEBHOOK_EXECUTION_URL) .withWebhookConfigId(WEBHOOK_ID) .withConnectionContext(new ConnectionContext().withOrganizationId(ORGANIZATION_ID)); // TODO(mfsiega-airbyte): make these matchers more specific. when(httpClient.send(any(), any())).thenReturn(mockHttpResponse); final boolean success = webhookActivity.invokeWebhook(input); "<AssertPlaceHolder>"; }
invokeWebhook(OperatorWebhookInput input);
[*] target: assertTrue(success)
[-] pred: org. junit. Assert. assertTrue ( success )
************************************
************************************
[+] input: Exception { final String expected = "louis XVI"; when(worker.run(anyString(), any())).thenReturn(expected);  final String actual = attemptExecution.get();  "<AssertPlaceHolder>";  verify(worker).run(anyString(), any()); verify(mdcSetter, atLeast(1)).accept(jobRoot); verify(attemptApi, times(1)).setWorkflowInAttempt( argThat(request -> request.getAttemptNumber() == ATTEMPT_NUMBER && request.getJobId() == Long.parseLong(JOB_ID))); }
get() { try { try (final var mdcScope = new MdcScope.Builder() .setLogPrefix(LoggingHelper.PLATFORM_LOGGER_PREFIX) .setPrefixColor(LoggingHelper.Color.CYAN_BACKGROUND) .build()) {  mdcSetter.accept(jobRoot);  LOGGER.info("Using job log path: {}", logClientManager.fullLogPath(jobRoot)); LOGGER.info("Executing worker wrapper. Airbyte version: {}", airbyteVersion); saveWorkflowIdForCancellation(airbyteApiClient); return worker.run(input, jobRoot); }  } catch (final Exception e) { addActualRootCauseToTrace(e); throw Activity.wrap(e); } finally { mdcSetter.accept(null); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { UpdateSecretParameterResponse expectedResponse = new UpdateSecretParameterResponse(); new Expectations() {{ mockedClient.updateSecretParameter((UpdateSecretParameterRequest) any); result = expectedResponse; }};  // Call the method under test and verify the result UpdateSecretParameterResponse actualResponse = oosClient.updateSecretParameter("testName", "testValue"); "<AssertPlaceHolder>"; }
updateSecretParameter(String name, String value) { try { UpdateSecretParameterRequest updateSecretParameterRequest = new UpdateSecretParameterRequest() .setRegionId(regionId) .setName(name) .setValue(value); return client.updateSecretParameter(updateSecretParameterRequest); } catch (Exception e) { log.error("oosClient.updateSecretParameter request:{}{}, throw Exception", JsonUtil.toJsonString(name), JsonUtil.toJsonString(value), e); throw new BizException(ErrorInfo.RESOURCE_NOT_FOUND); } }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { GetParametersResponse expectedResponse = new GetParametersResponse(); new Expectations() {{ mockedClient.getParameters((GetParametersRequest) any); result = expectedResponse; }};  // Call the method under test and verify the result GetParametersResponse actualResponse = oosClient.listParameters(Collections.singletonList("testName")); "<AssertPlaceHolder>"; }
listParameters(List<String> nameList) { try { String names = JsonUtil.toJsonString(nameList); GetParametersRequest getParametersRequest = new GetParametersRequest() .setRegionId(regionId) .setNames(names); return client.getParameters(getParametersRequest); } catch (Exception e) { log.error("oosClient.listParameters request:{}, throw Exception", JsonUtil.toJsonString(nameList), e); throw new BizException(ErrorInfo.RESOURCE_NOT_FOUND); } }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { UpdateParameterResponse expectedResponse = new UpdateParameterResponse(); new Expectations() {{ mockedClient.updateParameter((UpdateParameterRequest) any); result = expectedResponse; }};  // Call the method under test and verify the result UpdateParameterResponse actualResponse = oosClient.updateParameter("testName", "testValue"); "<AssertPlaceHolder>"; }
updateParameter(String name, String value) { try { UpdateParameterRequest updateParameterRequest = new UpdateParameterRequest() .setRegionId(regionId) .setName(name) .setValue(value); return client.updateParameter(updateParameterRequest); } catch (Exception e) { log.error("oosClient.updateParameter request:{}, throw Exception", JsonUtil.toJsonString(name), e); throw new BizException(ErrorInfo.RESOURCE_NOT_FOUND); } }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: dateUtilMock) { Long lastBillingEndDateLong = null; Long payPeriod = 30L; PayPeriodUnit payPeriodUnit = PayPeriodUnit.Day; Long billingDays = 30L; String currentDate = "2022-01-01"; Long expectedBillingEndDateTimeLong = 1640995200000L;  new Expectations() {{ DateUtil.getCurrentIs08601Time(); result = currentDate;  DateUtil.getIsO8601FutureDateMillis(currentDate, billingDays); result = expectedBillingEndDateTimeLong; }};  WalletHelper walletHelper = new WalletHelper(); Long actualBillingEndDateTimeLong = walletHelper.getBillingEndDateTimeMillis(lastBillingEndDateLong, payPeriod, payPeriodUnit);  "<AssertPlaceHolder>"; }
getBillingEndDateTimeMillis(Long lastBillingEndDateLong, Long payPeriod, PayPeriodUnit payPeriodUnit) { Long billingDays = getBillingDays(payPeriodUnit, payPeriod); if (lastBillingEndDateLong != null) { return DateUtil.getIsO8601FutureDateMillis(lastBillingEndDateLong, billingDays); } else { String currentDate = DateUtil.getCurrentIs08601Time(); return DateUtil.getIsO8601FutureDateMillis(currentDate, billingDays); } }
[*] target: assertEquals(expectedBillingEndDateTimeLong, actualBillingEndDateTimeLong)
[-] pred: org. junit. Assert. assertEquals ( expectedBillingEndDateTimeLong, actualBillingEndDateTimeLong )
************************************
************************************
[+] input: isOrderInConsumingReturnsTrue() { Long currentLocalDateTimeMillis = 123456789L; when(order.getBillingStartDateMillis()).thenReturn(10000L); when(order.getBillingEndDateMillis()).thenReturn(223456789L);  Boolean result = orderOtsHelper.isOrderInConsuming(order, currentLocalDateTimeMillis);  "<AssertPlaceHolder>"; }
isOrderInConsuming(OrderDTO orderDTO, Long currentLocalDateTimeMillis) { if (orderDTO == null || orderDTO.getBillingStartDateMillis() == null || orderDTO.getBillingEndDateMillis() == null) { return Boolean.TRUE; } return currentLocalDateTimeMillis >= orderDTO.getBillingStartDateMillis() && currentLocalDateTimeMillis < orderDTO.getBillingEndDateMillis(); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testRequestToMap() { MockHttpServletRequest request = new MockHttpServletRequest(); request.setParameter("trade_status", "TRADE_SUCCESS"); request.setParameter("type", "ALIPAY"); Map<String, String> requestToMap = HttpUtil.requestToMap(request); Map<String, String> map = new HashMap<>(); map.put("trade_status", "TRADE_SUCCESS"); map.put("type", "ALIPAY"); Assertions."<AssertPlaceHolder>"; }
requestToMap(HttpServletRequest request) { if (request == null) { return null; } return request.getParameterMap().entrySet().stream() .collect(Collectors.toMap(Map.Entry::getKey, entry -> String.join(",", entry.getValue()))); }
[*] target: assertEquals(map, requestToMap)
[-] pred: org. junit. Assert. assertEquals ( map, requestToMap )
************************************
************************************
[+] input: testCreateOrderSpiToken() { CreateOrderParam param = new CreateOrderParam(); param.setChargeType(ChargeType.PrePaid); param.setPayPeriod(1L); param.setPayPeriodUnit(PayPeriodUnit.Month); param.setOrderType("new"); param.setSpecificationName("basic"); param.setCommodityCode("saas-boost-176625a4"); param.setToken("ignoredToken"); param.setUserId("1563457855438522");  Map<String, String> map = new HashMap<>(); map.put("commodityCode", "saas-boost-176625a4"); map.put("chargeType", ChargeType.PrePaid.toString()); map.put("payPeriodUnit", PayPeriodUnit.Month.toString()); map.put("orderType", "new"); map.put("specificationName", "basic"); map.put("payPeriod", "1"); map.put("userId", "1563457855438522");  String data = TokenUtil.buildUrlParams(map); data += "&key=" + "isvKey"; String md5HexString = EncryptionUtil.getMd5HexString(data); String actualToken = TokenUtil.createSpiToken(param, "isvKey");  "<AssertPlaceHolder>"; }
createSpiToken(Object param, String isvKey) { if (StringUtils.isNotEmpty(isvKey)) { Map<String, String> paramMap = beanPropertiesToMap(param); String params = buildUrlParams(paramMap); params += "&key=" + isvKey; String md5Token = EncryptionUtil.getMd5HexString(params); log.info("createValidToken {} token {}.", params, md5Token); return md5Token; } return null; }
[*] target: assertEquals(md5HexString, actualToken)
[-] pred: org. junit. Assert. assertEquals ( md5HexString, actualToken )
************************************
************************************
[+] input: testGetCommodityPriceSpiToken() { GetCommodityPriceParam param = new GetCommodityPriceParam(); param.setPayPeriod(12L); param.setPayPeriodUnit(PayPeriodUnit.Month); param.setSpecificationName("basic"); param.setCommodityCode("saas-boost-176625a4"); param.setToken("ignoredToken");  Map<String, String> map = new HashMap<>(); map.put("commodityCode", "saas-boost-176625a4"); map.put("payPeriodUnit", PayPeriodUnit.Month.toString()); map.put("specificationName", "basic"); map.put("payPeriod", "12");  String data = TokenUtil.buildUrlParams(map); data += "&key=" + "isvKey"; String md5HexString = EncryptionUtil.getMd5HexString(data); String actualToken = TokenUtil.createSpiToken(param, "isvKey");  "<AssertPlaceHolder>"; }
createSpiToken(Object param, String isvKey) { if (StringUtils.isNotEmpty(isvKey)) { Map<String, String> paramMap = beanPropertiesToMap(param); String params = buildUrlParams(paramMap); params += "&key=" + isvKey; String md5Token = EncryptionUtil.getMd5HexString(params); log.info("createValidToken {} token {}.", params, md5Token); return md5Token; } return null; }
[*] target: assertEquals(md5HexString, actualToken)
[-] pred: org. junit. Assert. assertEquals ( md5HexString, actualToken )
************************************
************************************
[+] input: testGetCommodity() { GetCommodityParam getCommodityParam = new GetCommodityParam(); CommodityDTO expectedCommodityDTO = new CommodityDTO();  when(commodityService.getCommodity(any(GetCommodityParam.class))) .thenReturn(expectedCommodityDTO);  CommodityDTO result = commodityController.getCommodity(getCommodityParam);  Assertions."<AssertPlaceHolder>"; }
getCommodity(@Valid @RequestBody GetCommodityParam param) { return commodityService.getCommodity(param); }
[*] target: assertEquals(expectedCommodityDTO, result)
[-] pred: org. junit. Assert. assertEquals ( expectedCommodityDTO, result )
************************************
************************************
[+] input: testGetCommodityPrice() { GetCommodityPriceParam getCommodityPriceParam = new GetCommodityPriceParam(); CommodityPriceModel expectedCommodityPriceModel = new CommodityPriceModel();  when(commodityService.getCommodityPrice(any(GetCommodityPriceParam.class))) .thenReturn(expectedCommodityPriceModel);  CommodityPriceModel result = commodityController.getCommodityPrice(getCommodityPriceParam);  Assertions."<AssertPlaceHolder>";  }
getCommodityPrice(@Valid @RequestBody GetCommodityPriceParam param) { return commodityService.getCommodityPrice(param); }
[*] target: assertEquals(expectedCommodityPriceModel, result)
[-] pred: org. junit. Assert. assertEquals ( expectedCommodityPriceModel, result )
************************************
************************************
[+] input: testCreateCommoditySpecification() { CreateCommoditySpecificationParam param = new CreateCommoditySpecificationParam(); BaseResult<Void> expectedResponse = new BaseResult<>("code", "message", null, "requestId");  when(commoditySpecificationService.createCommoditySpecification(any(UserInfoModel.class), any(CreateCommoditySpecificationParam.class))) .thenReturn(expectedResponse);  BaseResult<Void> result = commoditySpecificationController.createCommoditySpecification(userInfo, param);  "<AssertPlaceHolder>"; }
createCommoditySpecification(@ApiIgnore @AuthenticationPrincipal UserInfoModel userInfoModel, @Valid @RequestBody CreateCommoditySpecificationParam param) { return commoditySpecificationService.createCommoditySpecification(userInfoModel, param); }
[*] target: assertEquals(expectedResponse, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, result )
************************************
************************************
[+] input: testListAllSpecifications() { ListCommoditySpecificationParam param = new ListCommoditySpecificationParam(); ListResult<CommoditySpecificationDTO> expectedResponse = ListResult.genSuccessListResult(Arrays.asList(new CommoditySpecificationDTO()), 1);  when(commoditySpecificationService.listAllSpecifications(any(UserInfoModel.class), any(ListCommoditySpecificationParam.class))) .thenReturn(expectedResponse);  ListResult<CommoditySpecificationDTO> result = commoditySpecificationController.listAllSpecifications(userInfo, param);  "<AssertPlaceHolder>"; }
listAllSpecifications(@ApiIgnore @AuthenticationPrincipal UserInfoModel userInfoModel, ListCommoditySpecificationParam param) { return commoditySpecificationService.listAllSpecifications(userInfoModel, param); }
[*] target: assertEquals(expectedResponse, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, result )
************************************
************************************
[+] input: testUpdateCommoditySpecification() { UpdateCommoditySpecificationParam param = new UpdateCommoditySpecificationParam(); BaseResult<Void> expectedResponse = new BaseResult<>("code", "message", null, "requestId");  when(commoditySpecificationService.updateCommoditySpecification(any(UserInfoModel.class), any(UpdateCommoditySpecificationParam.class))) .thenReturn(expectedResponse);  BaseResult<Void> result = commoditySpecificationController.updateCommoditySpecification(userInfo, param);  "<AssertPlaceHolder>"; }
updateCommoditySpecification(@ApiIgnore @AuthenticationPrincipal UserInfoModel userInfoModel, @RequestBody @Valid UpdateCommoditySpecificationParam param) { return commoditySpecificationService.updateCommoditySpecification(userInfoModel, param); }
[*] target: assertEquals(expectedResponse, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, result )
************************************
************************************
[+] input: testDeleteCommoditySpecification() { CommoditySpecificationParam param = new CommoditySpecificationParam(); BaseResult<Void> expectedResponse = new BaseResult<>("code", "message", null, "requestId");  when(commoditySpecificationService.deleteCommoditySpecification(any(UserInfoModel.class), any(CommoditySpecificationParam.class))) .thenReturn(expectedResponse);  BaseResult<Void> result = commoditySpecificationController.deleteCommoditySpecification(userInfo, param);  "<AssertPlaceHolder>"; }
deleteCommoditySpecification(@ApiIgnore @AuthenticationPrincipal UserInfoModel userInfoModel, @Valid CommoditySpecificationParam param) { return commoditySpecificationService.deleteCommoditySpecification(userInfoModel, param); }
[*] target: assertEquals(expectedResponse, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, result )
************************************
************************************
[+] input: testGetAuthToken() { GetAuthTokenParam getAuthTokenParam = createGetAuthTokenParam(); BaseResult<AuthTokenModel> expectedResult = new BaseResult<>("200","OK", new AuthTokenModel("idToken", "refreshToken", "expiresIn"),"aaa"); BaseResult<AuthTokenModel> result1 = new BaseResult<>(new AuthTokenModel("idToken", "refreshToken", "expiresIn")); GetAuthTokenParam getAuthTokenParam1 = createGetAuthTokenParam(); when(mockLoginService.getAuthToken(getAuthTokenParam1)).thenReturn(result1); BaseResult<AuthTokenModel> result = userControllerUnderTest.getAuthToken(getAuthTokenParam); result.setRequestId("aaa"); "<AssertPlaceHolder>"; }
getAuthToken(@Valid @APIParameterConvert GetAuthTokenParam getAuthTokenParam) { return loginService.getAuthToken(getAuthTokenParam); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testCreateTransaction() { String outTradeNo = "TestTradeNo";  OrderDTO mockOrder = new OrderDTO(); mockOrder.setOrderId("TestTradeNo"); mockOrder.setCommodityName("Test Subject"); mockOrder.setTotalAmount(100L); mockOrder.setPaymentForm("");  when(orderOtsHelper.getOrder(outTradeNo, null)).thenReturn(mockOrder); String expectedTransaction = "ExpectedTransactionForm"; when(baseAlipayClient.createOutTrade(mockOrder)).thenReturn(expectedTransaction);  String result = alipayService.createTransaction(mockOrder);  "<AssertPlaceHolder>"; }
createTransaction(OrderDTO order) { if (StringUtils.isNotEmpty(order.getPaymentForm()) && PayChannel.ALIPAY.equals(order.getPayChannel())) { return order.getPaymentForm(); } String transaction = baseAlipayClient.createOutTrade(order); OrderDO orderDO = new OrderDO(); orderDO.setOrderId(order.getOrderId()); orderDO.setPayChannel(PayChannel.ALIPAY); orderDO.setPaymentForm(transaction); orderOtsHelper.updateOrder(orderDO); return transaction; }
[*] target: assertEquals(expectedTransaction, result)
[-] pred: org. junit. Assert. assertEquals ( expectedTransaction, result )
************************************
************************************
[+] input: testListConfigParameters() { ListResult<ConfigParameterModel> expectedListResult = new ListResult<>(); ListConfigParametersParam listConfigParametersParam = new ListConfigParametersParam(); ConfigParameterQueryModel configParameterQueryModel = new ConfigParameterQueryModel(); configParameterQueryModel.setName("name"); configParameterQueryModel.setEncrypted(true); listConfigParametersParam.setConfigParameterQueryModels(Arrays.asList(configParameterQueryModel)); ConfigParameterModel expectedConfigParameterModel1 = new ConfigParameterModel(); expectedConfigParameterModel1.setName("adjusted-name1"); expectedConfigParameterModel1.setValue("adjusted-value1"); ConfigParameterModel expectedConfigParameterModel2 = new ConfigParameterModel(); expectedConfigParameterModel2.setName("adjusted-name2"); expectedConfigParameterModel2.setValue("adjusted-value2"); List<String> secretNames = Arrays.asList("adjusted-name1", "adjusted-name2"); List<String> names = new ArrayList<>(); List<ConfigParameterModel> secretParameterModels = Arrays.asList(expectedConfigParameterModel1, expectedConfigParameterModel2); List<ConfigParameterModel> parameterModels = new ArrayList<>(); expectedListResult.setData(Arrays.asList(expectedConfigParameterModel1, expectedConfigParameterModel2));  new Expectations() {{ parameterOosHelper.listSecretParameters(withAny(secretNames)); result = secretParameterModels; parameterOosHelper.listParameters(withAny(names)); result = parameterModels; }};  ListResult<ConfigParameterModel> actualListResult = parameterManagerService.listConfigParameters(userInfoModel, listConfigParametersParam);  "<AssertPlaceHolder>"; }
listConfigParameters(UserInfoModel userInfoModel, ListConfigParametersParam listConfigParametersParam) { ListResult<ConfigParameterModel> results = new ListResult<>(); results.setData(new ArrayList<>()); List<ConfigParameterQueryModel> queries = listConfigParametersParam.getConfigParameterQueryModels(); if (queries == null || queries.isEmpty()) { results.setMessage("Invalid query: 'encrypted' must not be null and 'name' must not be null or empty"); return results; }  List<String> secretNameList = new ArrayList<>(); List<String> nameList = new ArrayList<>(); for(ConfigParameterQueryModel configParameterQueryModel : listConfigParametersParam.getConfigParameterQueryModels()){ String format = String.format("%s-%s-%s", SERVICE_INSTANCE_ID, stackName, configParameterQueryModel.getName()); if (configParameterQueryModel.getEncrypted()) { secretNameList.add(format); } else { nameList.add(format); } }  List<ConfigParameterModel> secretParametersList = parameterOosHelper.listSecretParameters(secretNameList); List<ConfigParameterModel> parametersList = parameterOosHelper.listParameters(nameList); List<ConfigParameterModel> listConfigParameters = new ArrayList<>(secretParametersList); listConfigParameters.addAll(parametersList); for (ConfigParameterModel configParameterModel : listConfigParameters) { configParameterModel.setName(configParameterModel.getName().replace(String.format("%s-%s-", SERVICE_INSTANCE_ID, stackName), "")); } results.setData(listConfigParameters); return results; }
[*] target: assertEquals(expectedListResult, actualListResult)
[-] pred: org. junit. Assert. assertEquals ( expectedListResult, actualListResult )
************************************
************************************
[+] input: testUpdateConfigParameterWithNullResponse() { new Expectations() {{ parameterOosHelper.updateConfigParameter(updateConfigParameterParam); result = null; }};  BaseResult<Void> actualResult = parameterManagerService.updateConfigParameter(userInfoModel, updateConfigParameterParam);  "<AssertPlaceHolder>"; }
updateConfigParameter(UserInfoModel userInfoModel, UpdateConfigParameterParam updateConfigParameterParam) { String format = String.format("%s-%s-%s", SERVICE_INSTANCE_ID, stackName, updateConfigParameterParam.getName()); updateConfigParameterParam.setName(format); return parameterOosHelper.updateConfigParameter(updateConfigParameterParam); }
[*] target: assertNull(actualResult)
[-] pred: org. junit. Assert. assertNull ( actualResult )
************************************
************************************
[+] input: test2() { UsuarioDto esperado = new UsuarioDto(3L, "Martin"); UsuarioDto resultado = usuarioServicio.crearUsuario(3L, "Martin");  Assertions."<AssertPlaceHolder>"; // Esto usara el metodo equals }
crearUsuario(Long id, String nombre) { UsuarioDto usuarioDto = usuarios.put(id, new UsuarioDto(id, nombre)); return usuarios.get(id); }
[*] target: assertEquals(esperado, resultado)
[-] pred: org. junit. Assert. assertEquals ( esperado, resultado )
************************************
************************************
[+] input: testConnectionDelayWithNoExponentialBackoff() { long now = time.milliseconds(); long delay = clientWithNoExponentialBackoff.connectionDelay(node, now);  "<AssertPlaceHolder>"; }
connectionDelay(Node node, long now) { return connectionStates.connectionDelay(node.idString(), now); }
[*] target: assertEquals(0, delay)
[-] pred: org. junit. Assert. assertEquals ( 0, delay )
************************************
************************************
[+] input: testVersionsToString() { List<ApiVersion> versionList = new ArrayList<>(); for (ApiKeys apiKey : ApiKeys.values()) { if (apiKey == ApiKeys.DELETE_TOPICS) { versionList.add(new ApiVersion() .setApiKey(apiKey.id) .setMinVersion((short) 10000) .setMaxVersion((short) 10001)); } else versionList.add(ApiVersionsResponse.toApiVersion(apiKey)); } NodeApiVersions versions = new NodeApiVersions(versionList, Collections.emptyList(), false); StringBuilder bld = new StringBuilder(); String prefix = "("; for (ApiKeys apiKey : ApiKeys.values()) { bld.append(prefix); if (apiKey == ApiKeys.DELETE_TOPICS) { bld.append("DeleteTopics(20): 10000 to 10001 [unusable: node too new]"); } else { bld.append(apiKey.name).append("("). append(apiKey.id).append("): "); if (apiKey.oldestVersion() == apiKey.latestVersion()) { bld.append(apiKey.oldestVersion()); } else { bld.append(apiKey.oldestVersion()). append(" to "). append(apiKey.latestVersion()); } bld.append(" [usable: ").append(apiKey.latestVersion()). append("]"); } prefix = ", "; } bld.append(")"); "<AssertPlaceHolder>"; }
toString() { return toString(false); }
[*] target: assertEquals(bld.toString(), versions.toString())
[-] pred: org. junit. Assert. assertEquals ( bld. toString ( ), versions. toString ( ) )
************************************
************************************
[+] input: testNoRecordsInFetch() { FetchResponseData.PartitionData partitionData = new FetchResponseData.PartitionData() .setPartitionIndex(0) .setHighWatermark(10) .setLastStableOffset(20) .setLogStartOffset(0);  CompletedFetch completedFetch = newCompletedFetch(1, partitionData); try (final Deserializers<String, String> deserializers = newStringDeserializers()) { FetchConfig fetchConfig = newFetchConfig(IsolationLevel.READ_UNCOMMITTED, true); List<ConsumerRecord<String, String>> records = completedFetch.fetchRecords(fetchConfig, deserializers, 10); "<AssertPlaceHolder>"; } }
fetchRecords(FetchConfig fetchConfig, Deserializers<K, V> deserializers, int maxRecords) { // Error when fetching the next record before deserialization. if (corruptLastRecord) throw new KafkaException("Received exception when fetching the next record from " + partition + ". If needed, please seek past the record to " + "continue consumption.", cachedRecordException);  if (isConsumed) return Collections.emptyList();  List<ConsumerRecord<K, V>> records = new ArrayList<>();  try { for (int i = 0; i < maxRecords; i++) { // Only move to next record if there was no exception in the last fetch. Otherwise, we should // use the last record to do deserialization again. if (cachedRecordException == null) { corruptLastRecord = true; lastRecord = nextFetchedRecord(fetchConfig); corruptLastRecord = false; }  if (lastRecord == null) break;  Optional<Integer> leaderEpoch = maybeLeaderEpoch(currentBatch.partitionLeaderEpoch()); TimestampType timestampType = currentBatch.timestampType(); ConsumerRecord<K, V> record = parseRecord(deserializers, partition, leaderEpoch, timestampType, lastRecord); records.add(record); recordsRead++; bytesRead += lastRecord.sizeInBytes(); nextFetchOffset = lastRecord.offset() + 1; // In some cases, the deserialization may have thrown an exception and the retry may succeed, // we allow user to move forward in this case. cachedRecordException = null; } } catch (SerializationException se) { cachedRecordException = se; if (records.isEmpty()) throw se; } catch (KafkaException e) { cachedRecordException = e; if (records.isEmpty()) throw new KafkaException("Received exception when fetching the next record from " + partition + ". If needed, please seek past the record to " + "continue consumption.", e); } return records; }
[*] target: assertEquals(0, records.size())
[-] pred: org. junit. Assert. assertEquals ( 0, records. size ( ) )
************************************
************************************
[+] input: testCommitOffsetOnly() { subscriptions.assignFromUser(singleton(t1p));  client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);  AtomicBoolean success = new AtomicBoolean(false); coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success)); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertTrue(success.get())
[-] pred: org. junit. Assert. assertTrue ( success. get ( ) )
************************************
************************************
[+] input: testCommitOffsetMetadataSync() { subscriptions.assignFromUser(singleton(t1p));  client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);  OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(100L, "hello"); Map<TopicPartition, OffsetAndMetadata> offsets = singletonMap(t1p, offsetAndMetadata); boolean success = coordinator.commitOffsetsSync(offsets, time.timer(Long.MAX_VALUE)); "<AssertPlaceHolder>"; }
commitOffsetsSync(Map<TopicPartition, OffsetAndMetadata> offsets, Timer timer) { invokeCompletedOffsetCommitCallbacks();  if (offsets.isEmpty()) { // We guarantee that the callbacks for all commitAsync() will be invoked when // commitSync() completes, even if the user tries to commit empty offsets. return invokePendingAsyncCommits(timer); }  long attempts = 0L; do { if (coordinatorUnknownAndUnreadySync(timer)) { return false; }  RequestFuture<Void> future = sendOffsetCommitRequest(offsets); client.poll(future, timer);  // We may have had in-flight offset commits when the synchronous commit began. If so, ensure that // the corresponding callbacks are invoked prior to returning in order to preserve the order that // the offset commits were applied. invokeCompletedOffsetCommitCallbacks();  if (future.succeeded()) { if (interceptors != null) interceptors.onCommit(offsets); return true; }  if (future.failed() && !future.isRetriable()) throw future.exception();  timer.sleep(retryBackoff.backoff(attempts++)); } while (timer.notExpired());  return false; }
[*] target: assertTrue(success)
[-] pred: org. junit. Assert. assertTrue ( success )
************************************
************************************
[+] input: testClientInstanceId() { Properties props = new Properties(); props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9999");  ClientTelemetryReporter clientTelemetryReporter = mock(ClientTelemetryReporter.class); clientTelemetryReporter.configure(any());  try (MockedStatic<CommonClientConfigs> mockedCommonClientConfigs = mockStatic(CommonClientConfigs.class, new CallsRealMethods())) { mockedCommonClientConfigs.when(() -> CommonClientConfigs.telemetryReporter(anyString(), any())).thenReturn(Optional.of(clientTelemetryReporter));  ClientTelemetrySender clientTelemetrySender = mock(ClientTelemetrySender.class); Uuid expectedUuid = Uuid.randomUuid(); when(clientTelemetryReporter.telemetrySender()).thenReturn(clientTelemetrySender); when(clientTelemetrySender.clientInstanceId(any())).thenReturn(Optional.of(expectedUuid));  try (KafkaProducer<String, String> producer = new KafkaProducer<>(props, new StringSerializer(), new StringSerializer())) { Uuid uuid = producer.clientInstanceId(Duration.ofMillis(0)); "<AssertPlaceHolder>"; } } }
clientInstanceId(Duration timeout) { if (!clientTelemetryReporter.isPresent()) { throw new IllegalStateException("Telemetry is not enabled. Set config `" + ProducerConfig.ENABLE_METRICS_PUSH_CONFIG + "` to `true`."); }  return ClientTelemetryUtils.fetchClientInstanceId(clientTelemetryReporter.get(), timeout); }
[*] target: assertEquals(expectedUuid, uuid)
[-] pred: org. junit. Assert. assertEquals ( expectedUuid, uuid )
************************************
************************************
[+] input: testBootstrap() { String ipAddress = "140.211.11.105"; String hostName = "www.example.com"; Cluster cluster = Cluster.bootstrap(Arrays.asList( new InetSocketAddress(ipAddress, 9002), new InetSocketAddress(hostName, 9002) )); Set<String> expectedHosts = Utils.mkSet(ipAddress, hostName); Set<String> actualHosts = new HashSet<>(); for (Node node : cluster.nodes()) actualHosts.add(node.host()); "<AssertPlaceHolder>"; }
nodes() { return this.nodes; }
[*] target: assertEquals(expectedHosts, actualHosts)
[-] pred: org. junit. Assert. assertEquals ( expectedHosts, actualHosts )
************************************
************************************
[+] input: toRst() { final ConfigDef def = new ConfigDef() .define("opt1", Type.STRING, "a", ValidString.in("a", "b", "c"), Importance.HIGH, "docs1") .define("opt2", Type.INT, Importance.MEDIUM, "docs2") .define("opt3", Type.LIST, Arrays.asList("a", "b"), Importance.LOW, "docs3") .define("opt4", Type.BOOLEAN, false, Importance.LOW, null);  final String expectedRst = "" + "``opt2``\n" + "  docs2\n" + "\n" + "  * Type: int\n" + "  * Importance: medium\n" + "\n" + "``opt1``\n" + "  docs1\n" + "\n" + "  * Type: string\n" + "  * Default: a\n" + "  * Valid Values: [a, b, c]\n" + "  * Importance: high\n" + "\n" + "``opt3``\n" + "  docs3\n" + "\n" + "  * Type: list\n" + "  * Default: a,b\n" + "  * Importance: low\n" + "\n" + "``opt4``\n" + "\n" + "  * Type: boolean\n" + "  * Default: false\n" + "  * Importance: low\n" + "\n";  "<AssertPlaceHolder>"; }
toRst() { StringBuilder b = new StringBuilder(); for (ConfigKey key : sortedConfigs()) { if (key.internalConfig) { continue; } getConfigKeyRst(key, b); b.append("\n"); } return b.toString(); }
[*] target: assertEquals(expectedRst, def.toRst())
[-] pred: org. junit. Assert. assertEquals ( expectedRst, def. toRst ( ) )
************************************
************************************
[+] input: testNullAllowedPathsTraversal() { allowedPaths = new AllowedPaths(""); Path traversedPath = Paths.get(dir, "..", "dir2"); Path actual = allowedPaths.parseUntrustedPath(traversedPath.toString()); // we expect non-normalised path if allowed.paths is not specified to avoid backward compatibility "<AssertPlaceHolder>"; }
parseUntrustedPath(String path) { Path parsedPath = Paths.get(path);  if (allowedPaths != null) { Path normalisedPath = parsedPath.normalize(); long allowed = allowedPaths.stream().filter(allowedPath -> normalisedPath.startsWith(allowedPath)).count(); if (allowed == 0) { return null; } return normalisedPath; }  return parsedPath; }
[*] target: assertEquals(traversedPath, actual)
[-] pred: org. junit. Assert. assertEquals ( traversedPath, actual )
************************************
************************************
[+] input: testPartitionDir() { AlterReplicaLogDirsRequestData data = new AlterReplicaLogDirsRequestData() .setDirs(new AlterReplicaLogDirCollection( asList(new AlterReplicaLogDir() .setPath("/data0") .setTopics(new AlterReplicaLogDirTopicCollection( asList(new AlterReplicaLogDirTopic() .setName("topic") .setPartitions(asList(0, 1)), new AlterReplicaLogDirTopic() .setName("topic2") .setPartitions(asList(7))).iterator())), new AlterReplicaLogDir() .setPath("/data1") .setTopics(new AlterReplicaLogDirTopicCollection( asList(new AlterReplicaLogDirTopic() .setName("topic3") .setPartitions(asList(12))).iterator()))).iterator())); AlterReplicaLogDirsRequest request = new AlterReplicaLogDirsRequest.Builder(data).build(); Map<TopicPartition, String> expect = new HashMap<>(); expect.put(new TopicPartition("topic", 0), "/data0"); expect.put(new TopicPartition("topic", 1), "/data0"); expect.put(new TopicPartition("topic2", 7), "/data0"); expect.put(new TopicPartition("topic3", 12), "/data1"); "<AssertPlaceHolder>"; }
partitionDirs() { Map<TopicPartition, String> result = new HashMap<>(); data.dirs().forEach(alterDir -> alterDir.topics().forEach(topic -> topic.partitions().forEach(partition -> result.put(new TopicPartition(topic.name(), partition), alterDir.path()))) ); return result; }
[*] target: assertEquals(expect, request.partitionDirs())
[-] pred: org. junit. Assert. assertEquals ( expect, request. partitionDirs ( ) )
************************************
************************************
[+] input: parseHeaderFromBufferWithNonZeroPosition() { ByteBuffer buffer = ByteBuffer.allocate(64); buffer.position(10);  RequestHeader header = new RequestHeader(ApiKeys.FIND_COORDINATOR, (short) 1, "", 10); ObjectSerializationCache serializationCache = new ObjectSerializationCache(); // size must be called before write to avoid an NPE with the current implementation header.size(serializationCache); header.write(buffer, serializationCache); int limit = buffer.position(); buffer.position(10); buffer.limit(limit);  RequestHeader parsed = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { short apiKey = -1; try { // We derive the header version from the request api version, so we read that first. // The request api version is part of `RequestHeaderData`, so we reset the buffer position after the read. int bufferStartPositionForHeader = buffer.position(); apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); short headerVersion = ApiKeys.forId(apiKey).requestHeaderVersion(apiVersion); buffer.position(bufferStartPositionForHeader); final RequestHeaderData headerData = new RequestHeaderData(new ByteBufferAccessor(buffer), headerVersion); // Due to a quirk in the protocol, client ID is marked as nullable. // However, we treat a null client ID as equivalent to an empty client ID. if (headerData.clientId() == null) { headerData.setClientId(""); } final RequestHeader header = new RequestHeader(headerData, headerVersion); // Size of header is calculated by the shift in the position of buffer's start position during parsing. // Prior to parsing, the buffer's start position points to header data and after the parsing operation // the buffer's start position points to api message. For more information on how the buffer is // constructed, see RequestUtils#serialize() header.size = Math.max(buffer.position() - bufferStartPositionForHeader, 0); return header; } catch (UnsupportedVersionException e) { throw new InvalidRequestException("Unknown API key " + apiKey, e); } catch (Throwable ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + apiKey, ex); } }
[*] target: assertEquals(header, parsed)
[-] pred: org. junit. Assert. assertEquals ( header, parsed )
************************************
************************************
[+] input: Exception { String expectedMessage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001";  Map<String, String> extensions = new HashMap<>(); extensions.put("nineteen", "42"); OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse("123.345.567", new SaslExtensions(extensions));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (!extensions.isEmpty()) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(expectedMessage, message)
[-] pred: org. junit. Assert. assertEquals ( expectedMessage, message )
************************************
************************************
[+] input: Exception { String serverMessage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001"; OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse(serverMessage.getBytes(StandardCharsets.UTF_8));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (!extensions.isEmpty()) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(serverMessage, message)
[-] pred: org. junit. Assert. assertEquals ( serverMessage, message )
************************************
************************************
[+] input: testValidateExpirationAllowsZero() { Long expected = 0L; Long actual = ClaimValidationUtils.validateExpiration("exp", expected); "<AssertPlaceHolder>"; }
validateExpiration(String claimName, Long claimValue) throws ValidateException { if (claimValue == null) throw new ValidateException(String.format("%s value must be non-null", claimName));  if (claimValue < 0) throw new ValidateException(String.format("%s value must be non-negative; value given was "%s"", claimName, claimValue));  return claimValue; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testValidateSubject() { String expected = "jdoe"; String actual = ClaimValidationUtils.validateSubject("sub", expected); "<AssertPlaceHolder>"; }
validateSubject(String claimName, String claimValue) throws ValidateException { return validateString(claimName, claimValue); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testValidateIssuedAt() { Long expected = 1L; Long actual = ClaimValidationUtils.validateIssuedAt("iat", expected); "<AssertPlaceHolder>"; }
validateIssuedAt(String claimName, Long claimValue) throws ValidateException { if (claimValue != null && claimValue < 0) throw new ValidateException(String.format("%s value must be null or non-negative; value given was "%s"", claimName, claimValue));  return claimValue; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testValidateIssuedAtAllowsZero() { Long expected = 0L; Long actual = ClaimValidationUtils.validateIssuedAt("iat", expected); "<AssertPlaceHolder>"; }
validateIssuedAt(String claimName, Long claimValue) throws ValidateException { if (claimValue != null && claimValue < 0) throw new ValidateException(String.format("%s value must be null or non-negative; value given was "%s"", claimName, claimValue));  return claimValue; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testValidateIssuedAtAllowsNull() { Long expected = null; Long actual = ClaimValidationUtils.validateIssuedAt("iat", expected); "<AssertPlaceHolder>"; }
validateIssuedAt(String claimName, Long claimValue) throws ValidateException { if (claimValue != null && claimValue < 0) throw new ValidateException(String.format("%s value must be null or non-negative; value given was "%s"", claimName, claimValue));  return claimValue; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { String expected = "abc"; ObjectMapper mapper = new ObjectMapper(); ObjectNode node = mapper.createObjectNode(); node.put("access_token", expected);  String actual = HttpAccessTokenRetriever.parseAccessToken(mapper.writeValueAsString(node)); "<AssertPlaceHolder>"; }
parseAccessToken(String responseBody) throws IOException { ObjectMapper mapper = new ObjectMapper(); JsonNode rootNode = mapper.readTree(responseBody); JsonNode accessTokenNode = rootNode.at("/access_token");  if (accessTokenNode == null) { // Only grab the first N characters so that if the response body is huge, we don't // blow up. String snippet = responseBody;  if (snippet.length() > MAX_RESPONSE_BODY_LENGTH) { int actualLength = responseBody.length(); String s = responseBody.substring(0, MAX_RESPONSE_BODY_LENGTH); snippet = String.format("%s (trimmed to first %d characters out of %d total)", s, MAX_RESPONSE_BODY_LENGTH, actualLength); }  throw new IOException(String.format("The token endpoint response did not contain an access_token value. Response: (%s)", snippet)); }  return sanitizeString("the token endpoint response's access_token JSON attribute", accessTokenNode.textValue()); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { String expected = "grant_type=client_credentials&scope=scope"; String actual = HttpAccessTokenRetriever.formatRequestBody("scope"); "<AssertPlaceHolder>"; }
formatRequestBody(String scope) throws IOException { try { StringBuilder requestParameters = new StringBuilder(); requestParameters.append("grant_type=client_credentials");  if (scope != null && !scope.trim().isEmpty()) { scope = scope.trim(); String encodedScope = URLEncoder.encode(scope, StandardCharsets.UTF_8.name()); requestParameters.append("&scope=").append(encodedScope); }  return requestParameters.toString(); } catch (UnsupportedEncodingException e) { // The world has gone crazy! throw new IOException(String.format("Encoding %s not supported", StandardCharsets.UTF_8.name())); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testReadUnsignedInt() { ByteBuffer buffer = ByteBuffer.allocate(4); long writeValue = 133444; ByteUtils.writeUnsignedInt(buffer, writeValue); buffer.flip(); long readValue = ByteUtils.readUnsignedInt(buffer); "<AssertPlaceHolder>"; }
readUnsignedInt(ByteBuffer buffer) { return buffer.getInt() & 0xffffffffL; }
[*] target: assertEquals(writeValue, readValue)
[-] pred: org. junit. Assert. assertEquals ( writeValue, readValue )
************************************
************************************
[+] input: testSizeOfUnsignedVarint() { // The old well-known implementation for sizeOfUnsignedVarint IntFunction<Integer> simpleImplementation = (int value) -> { int bytes = 1; while ((value & 0xffffff80) != 0L) { bytes += 1; value >>>= 7; } return bytes; };  // compare the full range of values for (int i = 0; i < Integer.MAX_VALUE && i >= 0; i += 13) { final int actual = ByteUtils.sizeOfUnsignedVarint(i); final int expected = simpleImplementation.apply(i); "<AssertPlaceHolder>"; } }
sizeOfUnsignedVarint(int value) { // Protocol buffers varint encoding is variable length, with a minimum of 1 byte // (for zero). The values themselves are not important. What's important here is // any leading zero bits are dropped from output. We can use this leading zero // count w/ fast intrinsic to calc the output length directly.  // Test cases verify this matches the output for loop logic exactly.  // return (38 - leadingZeros) / 7 + leadingZeros / 32;  // The above formula provides the implementation, but the Java encoding is suboptimal // when we have a narrow range of integers, so we can do better manually  int leadingZeros = Integer.numberOfLeadingZeros(value); int leadingZerosBelow38DividedBy7 = ((38 - leadingZeros) * 0b10010010010010011) >>> 19; return leadingZerosBelow38DividedBy7 + (leadingZeros >>> 5); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldTransformHeadersWhenEmpty() { headers.apply(appendToKey("-suffix")); headers.apply(key, appendToKey("-suffix")); "<AssertPlaceHolder>"; }
isEmpty() { return headers == null || headers.isEmpty(); }
[*] target: assertTrue(headers.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( headers. isEmpty() )
************************************
************************************
[+] input: bytesToConnect() { ByteBuffer reference = ByteBuffer.wrap(Utils.utf8("test-string")); String msg = "{ "schema": { "type": "bytes" }, "payload": "dGVzdC1zdHJpbmc=" }"; SchemaAndValue schemaAndValue = converter.toConnectData(TOPIC, msg.getBytes()); ByteBuffer converted = ByteBuffer.wrap((byte[]) schemaAndValue.value()); "<AssertPlaceHolder>"; }
toConnectData(String topic, byte[] value) { JsonNode jsonValue;  // This handles a tombstone message if (value == null) { return SchemaAndValue.NULL; }  try { jsonValue = deserializer.deserialize(topic, value); } catch (SerializationException e) { throw new DataException("Converting byte[] to Kafka Connect data failed due to serialization error: ", e); }  if (config.schemasEnabled() && (!jsonValue.isObject() || jsonValue.size() != 2 || !jsonValue.has(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME) || !jsonValue.has(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME))) throw new DataException("JsonConverter with schemas.enable requires "schema" and "payload" fields and may not contain additional fields." + " If you are trying to deserialize plain JSON data, set schemas.enable=false in your converter configuration.");  // The deserialized data should either be an envelope object containing the schema and the payload or the schema // was stripped during serialization and we need to fill in an all-encompassing schema. if (!config.schemasEnabled()) { ObjectNode envelope = JSON_NODE_FACTORY.objectNode(); envelope.set(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME, null); envelope.set(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME, jsonValue); jsonValue = envelope; }  Schema schema = asConnectSchema(jsonValue.get(JsonSchema.ENVELOPE_SCHEMA_FIELD_NAME)); return new SchemaAndValue( schema, convertToConnect(schema, jsonValue.get(JsonSchema.ENVELOPE_PAYLOAD_FIELD_NAME), config) ); }
[*] target: assertEquals(reference, converted)
[-] pred: org. junit. Assert. assertEquals ( reference, converted )
************************************
************************************
[+] input: serializeFieldNullToDefault() { converter.configure(Collections.singletonMap(JsonConverterConfig.REPLACE_NULL_WITH_DEFAULT_CONFIG, true), false); Schema schema = SchemaBuilder.string().optional().defaultValue("default").build(); Schema structSchema = SchemaBuilder.struct().field("field1", schema).build(); JsonNode converted = parse(converter.fromConnectData(TOPIC, structSchema, new Struct(structSchema))); JsonNode expected = parse("{"schema":{"type":"struct","fields":[{"field":"field1","type":"string","optional":true,"default":"default"}],"optional":false},"payload":{"field1":"default"}}"); "<AssertPlaceHolder>"; }
fromConnectData(String topic, Schema schema, Object value) { if (schema == null && value == null) { return null; }  JsonNode jsonValue = config.schemasEnabled() ? convertToJsonWithEnvelope(schema, value) : convertToJsonWithoutEnvelope(schema, value); try { return serializer.serialize(topic, jsonValue); } catch (SerializationException e) { throw new DataException("Converting Kafka Connect data to byte[] failed due to serialization error: ", e); } }
[*] target: assertEquals(expected, converted)
[-] pred: org. junit. Assert. assertEquals ( expected, converted )
************************************
************************************
[+] input: serializeFieldNullToNull() { converter.configure(Collections.singletonMap(JsonConverterConfig.REPLACE_NULL_WITH_DEFAULT_CONFIG, false), false); Schema schema = SchemaBuilder.string().optional().defaultValue("default").build(); Schema structSchema = SchemaBuilder.struct().field("field1", schema).build(); JsonNode converted = parse(converter.fromConnectData(TOPIC, structSchema, new Struct(structSchema))); JsonNode expected = parse("{"schema":{"type":"struct","fields":[{"field":"field1","type":"string","optional":true,"default":"default"}],"optional":false},"payload":{"field1":null}}"); "<AssertPlaceHolder>"; }
fromConnectData(String topic, Schema schema, Object value) { if (schema == null && value == null) { return null; }  JsonNode jsonValue = config.schemasEnabled() ? convertToJsonWithEnvelope(schema, value) : convertToJsonWithoutEnvelope(schema, value); try { return serializer.serialize(topic, jsonValue); } catch (SerializationException e) { throw new DataException("Converting Kafka Connect data to byte[] failed due to serialization error: ", e); } }
[*] target: assertEquals(expected, converted)
[-] pred: org. junit. Assert. assertEquals ( expected, converted )
************************************
************************************
[+] input: updateSchemaOfNull() { Object updatedValue = SetSchemaMetadata.updateSchemaIn(null, Schema.INT32_SCHEMA); "<AssertPlaceHolder>"; }
updateSchemaIn(Object keyOrValue, Schema updatedSchema) { if (keyOrValue instanceof Struct) { Struct origStruct = (Struct) keyOrValue; Struct newStruct = new Struct(updatedSchema); for (Field field : updatedSchema.fields()) { // assume both schemas have exact same fields with same names and schemas ... newStruct.put(field, origStruct.get(field)); } return newStruct; } return keyOrValue; }
[*] target: assertNull(updatedValue)
[-] pred: org. junit. Assert. assertNull ( updatedValue )
************************************
************************************
[+] input: testBuildFilteredLeaderEpochMap() { TreeMap<Integer, Long> leaderEpochToStartOffset = new TreeMap<>(); leaderEpochToStartOffset.put(0, 0L); leaderEpochToStartOffset.put(1, 0L); leaderEpochToStartOffset.put(2, 0L); leaderEpochToStartOffset.put(3, 30L); leaderEpochToStartOffset.put(4, 40L); leaderEpochToStartOffset.put(5, 60L); leaderEpochToStartOffset.put(6, 60L); leaderEpochToStartOffset.put(7, 70L); leaderEpochToStartOffset.put(8, 70L);  TreeMap<Integer, Long> expectedLeaderEpochs = new TreeMap<>(); expectedLeaderEpochs.put(2, 0L); expectedLeaderEpochs.put(3, 30L); expectedLeaderEpochs.put(4, 40L); expectedLeaderEpochs.put(6, 60L); expectedLeaderEpochs.put(8, 70L);  NavigableMap<Integer, Long> refinedLeaderEpochMap = RemoteLogManager.buildFilteredLeaderEpochMap(leaderEpochToStartOffset); "<AssertPlaceHolder>"; }
buildFilteredLeaderEpochMap(NavigableMap<Integer, Long> leaderEpochs) { List<Integer> epochsWithNoMessages = new ArrayList<>(); Map.Entry<Integer, Long> previousEpochAndOffset = null; for (Map.Entry<Integer, Long> currentEpochAndOffset : leaderEpochs.entrySet()) { if (previousEpochAndOffset != null && previousEpochAndOffset.getValue().equals(currentEpochAndOffset.getValue())) { epochsWithNoMessages.add(previousEpochAndOffset.getKey()); } previousEpochAndOffset = currentEpochAndOffset; } if (epochsWithNoMessages.isEmpty()) { return leaderEpochs; } TreeMap<Integer, Long> filteredLeaderEpochs = new TreeMap<>(leaderEpochs); for (Integer epochWithNoMessage : epochsWithNoMessages) { filteredLeaderEpochs.remove(epochWithNoMessage); } return filteredLeaderEpochs; }
[*] target: assertEquals(expectedLeaderEpochs, refinedLeaderEpochMap)
[-] pred: org. junit. Assert. assertEquals ( expectedLeaderEpochs, refinedLeaderEpochMap )
************************************
************************************
[+] input: testCandidateLogSegmentsSkipsActiveSegment() { UnifiedLog log = mock(UnifiedLog.class); LogSegment segment1 = mock(LogSegment.class); LogSegment segment2 = mock(LogSegment.class); LogSegment activeSegment = mock(LogSegment.class);  when(segment1.baseOffset()).thenReturn(5L); when(segment2.baseOffset()).thenReturn(10L); when(activeSegment.baseOffset()).thenReturn(15L);  when(log.logSegments(5L, Long.MAX_VALUE)) .thenReturn(JavaConverters.collectionAsScalaIterable(Arrays.asList(segment1, segment2, activeSegment)));  RemoteLogManager.RLMTask task = remoteLogManager.new RLMTask(leaderTopicIdPartition, 128); List<RemoteLogManager.EnrichedLogSegment> expected = Arrays.asList( new RemoteLogManager.EnrichedLogSegment(segment1, 10L), new RemoteLogManager.EnrichedLogSegment(segment2, 15L) ); List<RemoteLogManager.EnrichedLogSegment> actual = task.candidateLogSegments(log, 5L, 20L); "<AssertPlaceHolder>"; }
candidateLogSegments(UnifiedLog log, Long fromOffset, Long lastStableOffset) { List<EnrichedLogSegment> candidateLogSegments = new ArrayList<>(); List<LogSegment> segments = JavaConverters.seqAsJavaList(log.logSegments(fromOffset, Long.MAX_VALUE).toSeq()); if (!segments.isEmpty()) { for (int idx = 1; idx < segments.size(); idx++) { LogSegment previousSeg = segments.get(idx - 1); LogSegment currentSeg = segments.get(idx); if (currentSeg.baseOffset() <= lastStableOffset) { candidateLogSegments.add(new EnrichedLogSegment(previousSeg, currentSeg.baseOffset())); } } // Discard the last active segment } return candidateLogSegments; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testCandidateLogSegmentsSkipsSegmentsAfterLastStableOffset() { UnifiedLog log = mock(UnifiedLog.class); LogSegment segment1 = mock(LogSegment.class); LogSegment segment2 = mock(LogSegment.class); LogSegment segment3 = mock(LogSegment.class); LogSegment activeSegment = mock(LogSegment.class);  when(segment1.baseOffset()).thenReturn(5L); when(segment2.baseOffset()).thenReturn(10L); when(segment3.baseOffset()).thenReturn(15L); when(activeSegment.baseOffset()).thenReturn(20L);  when(log.logSegments(5L, Long.MAX_VALUE)) .thenReturn(JavaConverters.collectionAsScalaIterable(Arrays.asList(segment1, segment2, segment3, activeSegment)));  RemoteLogManager.RLMTask task = remoteLogManager.new RLMTask(leaderTopicIdPartition, 128); List<RemoteLogManager.EnrichedLogSegment> expected = Arrays.asList( new RemoteLogManager.EnrichedLogSegment(segment1, 10L), new RemoteLogManager.EnrichedLogSegment(segment2, 15L) ); List<RemoteLogManager.EnrichedLogSegment> actual = task.candidateLogSegments(log, 5L, 15L); "<AssertPlaceHolder>"; }
candidateLogSegments(UnifiedLog log, Long fromOffset, Long lastStableOffset) { List<EnrichedLogSegment> candidateLogSegments = new ArrayList<>(); List<LogSegment> segments = JavaConverters.seqAsJavaList(log.logSegments(fromOffset, Long.MAX_VALUE).toSeq()); if (!segments.isEmpty()) { for (int idx = 1; idx < segments.size(); idx++) { LogSegment previousSeg = segments.get(idx - 1); LogSegment currentSeg = segments.get(idx); if (currentSeg.baseOffset() <= lastStableOffset) { candidateLogSegments.add(new EnrichedLogSegment(previousSeg, currentSeg.baseOffset())); } } // Discard the last active segment } return candidateLogSegments; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException {  ElasticLogSegment seg = createOrLoadSegment(40, 10, Time.SYSTEM);  MemoryRecords ms = records(40, "hello", "there"); seg.append(41, RecordBatch.NO_TIMESTAMP, -1L, ms); MemoryRecords ms2 = records(42, "alpha", "beta"); seg.append(43, RecordBatch.NO_TIMESTAMP, -1L, ms2); FetchDataInfo read = seg.read(42, 200); checkEquals(ms2.records().iterator(), read.records.records().iterator()); int oldSize = seg.size(); seg.close();  ElasticLogSegment segReopen = createOrLoadSegment(40, 10, Time.SYSTEM);  FetchDataInfo readAgain = segReopen.read(42, 200); checkEquals(ms2.records().iterator(), readAgain.records.records().iterator()); int size = segReopen.size();  "<AssertPlaceHolder>"; }
size() { return log.sizeInBytes(); }
[*] target: assertEquals(oldSize, size)
[-] pred: org. junit. Assert. assertEquals ( oldSize, size )
************************************
************************************
[+] input: testNewGroupMetadataTombstoneRecord() { CoordinatorRecord expectedRecord = new CoordinatorRecord( new ApiMessageAndVersion( new GroupMetadataKey() .setGroup("group-id"), (short) 2), null);  CoordinatorRecord groupMetadataRecord = CoordinatorRecordHelpers.newGroupMetadataTombstoneRecord("group-id"); "<AssertPlaceHolder>"; }
newGroupMetadataTombstoneRecord( String groupId ) { return new CoordinatorRecord( new ApiMessageAndVersion( new GroupMetadataKey() .setGroup(groupId), (short) 2 ), null // Tombstone ); }
[*] target: assertEquals(expectedRecord, groupMetadataRecord)
[-] pred: org. junit. Assert. assertEquals ( expectedRecord, groupMetadataRecord )
************************************
************************************
[+] input: testNewOffsetCommitTombstoneRecord() { CoordinatorRecord expectedRecord = new CoordinatorRecord( new ApiMessageAndVersion( new OffsetCommitKey() .setGroup("group-id") .setTopic("foo") .setPartition(1), (short) 1), null);  CoordinatorRecord record = CoordinatorRecordHelpers.newOffsetCommitTombstoneRecord("group-id", "foo", 1); "<AssertPlaceHolder>"; }
newOffsetCommitTombstoneRecord( String groupId, String topic, int partitionId ) { return new CoordinatorRecord( new ApiMessageAndVersion( new OffsetCommitKey() .setGroup(groupId) .setTopic(topic) .setPartition(partitionId), (short) 1 ), null ); }
[*] target: assertEquals(expectedRecord, record)
[-] pred: org. junit. Assert. assertEquals ( expectedRecord, record )
************************************
************************************
[+] input: testConsumerGroupDescribeNoErrors() { List<String> consumerGroupIds = Arrays.asList("group-id-1", "group-id-2"); int epoch = 10; String memberId = "member-id"; String topicName = "topicName"; ConsumerGroupMember.Builder memberBuilder = new ConsumerGroupMember.Builder(memberId) .setSubscribedTopicNames(Collections.singletonList(topicName)) .setServerAssignorName("assignorName");  MockPartitionAssignor assignor = new MockPartitionAssignor("range"); GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .withConsumerGroupAssignors(Collections.singletonList(assignor)) .withConsumerGroup(new ConsumerGroupBuilder(consumerGroupIds.get(0), epoch)) .withConsumerGroup(new ConsumerGroupBuilder(consumerGroupIds.get(1), epoch) .withMember(memberBuilder.build())) .build();  List<ConsumerGroupDescribeResponseData.DescribedGroup> expected = Arrays.asList( new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupEpoch(epoch) .setGroupId(consumerGroupIds.get(0)) .setGroupState(ConsumerGroup.ConsumerGroupState.EMPTY.toString()) .setAssignorName("range"), new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupEpoch(epoch) .setGroupId(consumerGroupIds.get(1)) .setMembers(Collections.singletonList( memberBuilder.build().asConsumerGroupDescribeMember( new Assignment(Collections.emptyMap()), new MetadataImageBuilder().build().topics() ) )) .setGroupState(ConsumerGroup.ConsumerGroupState.ASSIGNING.toString()) .setAssignorName("assignorName") ); List<ConsumerGroupDescribeResponseData.DescribedGroup> actual = context.sendConsumerGroupDescribe(consumerGroupIds);  "<AssertPlaceHolder>"; }
build() { if (logContext == null) logContext = new LogContext(); if (snapshotRegistry == null) snapshotRegistry = new SnapshotRegistry(logContext); if (metadataImage == null) metadataImage = MetadataImage.EMPTY; if (time == null) time = Time.SYSTEM;  if (timer == null) throw new IllegalArgumentException("Timer must be set."); if (consumerGroupAssignors == null || consumerGroupAssignors.isEmpty()) throw new IllegalArgumentException("Assignors must be set before building."); if (metrics == null) throw new IllegalArgumentException("GroupCoordinatorMetricsShard must be set.");  return new GroupMetadataManager( snapshotRegistry, logContext, time, timer, metrics, consumerGroupAssignors, metadataImage, consumerGroupMaxSize, consumerGroupSessionTimeoutMs, consumerGroupHeartbeatIntervalMs, consumerGroupMetadataRefreshIntervalMs, classicGroupMaxSize, classicGroupInitialRebalanceDelayMs, classicGroupNewMemberJoinTimeoutMs, classicGroupMinSessionTimeoutMs, classicGroupMaxSessionTimeoutMs, consumerGroupMigrationPolicy ); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testConsumerGroupDescribeWithErrors() { String groupId = "groupId";  MockPartitionAssignor assignor = new MockPartitionAssignor("range"); GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .withConsumerGroupAssignors(Collections.singletonList(assignor)) .build();  List<ConsumerGroupDescribeResponseData.DescribedGroup> actual = context.sendConsumerGroupDescribe(Collections.singletonList(groupId)); ConsumerGroupDescribeResponseData.DescribedGroup describedGroup = new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupId(groupId) .setErrorCode(Errors.GROUP_ID_NOT_FOUND.code()); List<ConsumerGroupDescribeResponseData.DescribedGroup> expected = Collections.singletonList( describedGroup );  "<AssertPlaceHolder>"; }
build() { if (logContext == null) logContext = new LogContext(); if (snapshotRegistry == null) snapshotRegistry = new SnapshotRegistry(logContext); if (metadataImage == null) metadataImage = MetadataImage.EMPTY; if (time == null) time = Time.SYSTEM;  if (timer == null) throw new IllegalArgumentException("Timer must be set."); if (consumerGroupAssignors == null || consumerGroupAssignors.isEmpty()) throw new IllegalArgumentException("Assignors must be set before building."); if (metrics == null) throw new IllegalArgumentException("GroupCoordinatorMetricsShard must be set.");  return new GroupMetadataManager( snapshotRegistry, logContext, time, timer, metrics, consumerGroupAssignors, metadataImage, consumerGroupMaxSize, consumerGroupSessionTimeoutMs, consumerGroupHeartbeatIntervalMs, consumerGroupMetadataRefreshIntervalMs, classicGroupMaxSize, classicGroupInitialRebalanceDelayMs, classicGroupNewMemberJoinTimeoutMs, classicGroupMinSessionTimeoutMs, classicGroupMaxSessionTimeoutMs, consumerGroupMigrationPolicy ); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testDescribeGroupStable() { GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .build();  GroupMetadataValue.MemberMetadata memberMetadata = new GroupMetadataValue.MemberMetadata() .setMemberId("member-id") .setGroupInstanceId("group-instance-id") .setClientHost("client-host") .setClientId("client-id") .setAssignment(new byte[]{0}) .setSubscription(new byte[]{0, 1, 2}); GroupMetadataValue groupMetadataValue = new GroupMetadataValue() .setMembers(Collections.singletonList(memberMetadata)) .setProtocolType("consumer") .setProtocol("range") .setCurrentStateTimestamp(context.time.milliseconds());  context.replay(GroupMetadataManagerTestContext.newGroupMetadataRecord( "group-id", groupMetadataValue, MetadataVersion.latestTesting() )); context.verifyDescribeGroupsReturnsDeadGroup("group-id"); context.commit();  List<DescribeGroupsResponseData.DescribedGroup> expectedDescribedGroups = Collections.singletonList( new DescribeGroupsResponseData.DescribedGroup() .setGroupId("group-id") .setGroupState(STABLE.toString()) .setProtocolType(groupMetadataValue.protocolType()) .setProtocolData(groupMetadataValue.protocol()) .setMembers(Collections.singletonList( new DescribeGroupsResponseData.DescribedGroupMember() .setMemberId(memberMetadata.memberId()) .setGroupInstanceId(memberMetadata.groupInstanceId()) .setClientId(memberMetadata.clientId()) .setClientHost(memberMetadata.clientHost()) .setMemberMetadata(memberMetadata.subscription()) .setMemberAssignment(memberMetadata.assignment()) )) );  List<DescribeGroupsResponseData.DescribedGroup> describedGroups = context.describeGroups(Collections.singletonList("group-id"));  "<AssertPlaceHolder>"; }
build() { if (logContext == null) logContext = new LogContext(); if (snapshotRegistry == null) snapshotRegistry = new SnapshotRegistry(logContext); if (metadataImage == null) metadataImage = MetadataImage.EMPTY; if (time == null) time = Time.SYSTEM;  if (timer == null) throw new IllegalArgumentException("Timer must be set."); if (consumerGroupAssignors == null || consumerGroupAssignors.isEmpty()) throw new IllegalArgumentException("Assignors must be set before building."); if (metrics == null) throw new IllegalArgumentException("GroupCoordinatorMetricsShard must be set.");  return new GroupMetadataManager( snapshotRegistry, logContext, time, timer, metrics, consumerGroupAssignors, metadataImage, consumerGroupMaxSize, consumerGroupSessionTimeoutMs, consumerGroupHeartbeatIntervalMs, consumerGroupMetadataRefreshIntervalMs, classicGroupMaxSize, classicGroupInitialRebalanceDelayMs, classicGroupNewMemberJoinTimeoutMs, classicGroupMinSessionTimeoutMs, classicGroupMaxSessionTimeoutMs, consumerGroupMigrationPolicy ); }
[*] target: assertEquals(expectedDescribedGroups, describedGroups)
[-] pred: org. junit. Assert. assertEquals ( expectedDescribedGroups, describedGroups )
************************************
************************************
[+] input: Exception { GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .build();  GroupMetadataValue.MemberMetadata memberMetadata = new GroupMetadataValue.MemberMetadata() .setMemberId("member-id") .setGroupInstanceId("group-instance-id") .setClientHost("client-host") .setClientId("client-id") .setAssignment(new byte[]{0}) .setSubscription(new byte[]{0, 1, 2}); GroupMetadataValue groupMetadataValue = new GroupMetadataValue() .setMembers(Collections.singletonList(memberMetadata)) .setProtocolType("consumer") .setProtocol("range") .setCurrentStateTimestamp(context.time.milliseconds());  context.replay(GroupMetadataManagerTestContext.newGroupMetadataRecord( "group-id", groupMetadataValue, MetadataVersion.latestTesting() )); ClassicGroup group = context.groupMetadataManager.getOrMaybeCreateClassicGroup("group-id", false); context.groupMetadataManager.prepareRebalance(group, "trigger rebalance");  context.verifyDescribeGroupsReturnsDeadGroup("group-id"); context.commit();  List<DescribeGroupsResponseData.DescribedGroup> expectedDescribedGroups = Collections.singletonList( new DescribeGroupsResponseData.DescribedGroup() .setGroupId("group-id") .setGroupState(PREPARING_REBALANCE.toString()) .setProtocolType(groupMetadataValue.protocolType()) .setProtocolData("") .setMembers(Collections.singletonList( new DescribeGroupsResponseData.DescribedGroupMember() .setMemberId(memberMetadata.memberId()) .setGroupInstanceId(memberMetadata.groupInstanceId()) .setClientId(memberMetadata.clientId()) .setClientHost(memberMetadata.clientHost()) .setMemberAssignment(memberMetadata.assignment()) )) );  List<DescribeGroupsResponseData.DescribedGroup> describedGroups = context.describeGroups(Collections.singletonList("group-id"));  "<AssertPlaceHolder>"; }
prepareRebalance( ClassicGroup group, String reason ) { // If any members are awaiting sync, cancel their request and have them rejoin. if (group.isInState(COMPLETING_REBALANCE)) { resetAndPropagateAssignmentWithError(group, Errors.REBALANCE_IN_PROGRESS); }  // If a sync expiration is pending, cancel it. removeSyncExpiration(group);  boolean isInitialRebalance = group.isInState(EMPTY); if (isInitialRebalance) { // The group is new. Provide more time for the members to join. int delayMs = classicGroupInitialRebalanceDelayMs; int remainingMs = Math.max(group.rebalanceTimeoutMs() - classicGroupInitialRebalanceDelayMs, 0);  timer.schedule( classicGroupJoinKey(group.groupId()), delayMs, TimeUnit.MILLISECONDS, false, () -> tryCompleteInitialRebalanceElseSchedule(group.groupId(), delayMs, remainingMs) ); }  group.transitionTo(PREPARING_REBALANCE);  log.info("Preparing to rebalance group {} in state {} with old generation {} (reason: {}).", group.groupId(), group.currentState(), group.generationId(), reason);  return isInitialRebalance ? EMPTY_RESULT : maybeCompleteJoinElseSchedule(group); }
[*] target: assertEquals(expectedDescribedGroups, describedGroups)
[-] pred: org. junit. Assert. assertEquals ( expectedDescribedGroups, describedGroups )
************************************
************************************
[+] input: testDescribeNoMetadata() { ClassicGroupMember member = new ClassicGroupMember( "member", Optional.of("group-instance-id"), "client-id", "client-host", 10, 4500, "generic", new JoinGroupRequestProtocolCollection(), new byte[0] );  DescribeGroupsResponseData.DescribedGroupMember expectedDescribedGroupMember = new DescribeGroupsResponseData.DescribedGroupMember() .setMemberId("member") .setGroupInstanceId("group-instance-id") .setClientId("client-id") .setClientHost("client-host") .setMemberAssignment(new byte[0]);  DescribeGroupsResponseData.DescribedGroupMember describedGroupMember = member.describeNoMetadata();  "<AssertPlaceHolder>"; }
describeNoMetadata() { return new DescribeGroupsResponseData.DescribedGroupMember() .setMemberId(memberId()) .setGroupInstanceId(groupInstanceId().orElse(null)) .setClientId(clientId()) .setClientHost(clientHost()) .setMemberAssignment(assignment()); }
[*] target: assertEquals(expectedDescribedGroupMember, describedGroupMember)
[-] pred: org. junit. Assert. assertEquals ( expectedDescribedGroupMember, describedGroupMember )
************************************
************************************
[+] input: testDescribe() { JoinGroupRequestProtocolCollection protocols = new JoinGroupRequestProtocolCollection(Collections.singletonList( new JoinGroupRequestProtocol() .setName("range") .setMetadata(new byte[]{0}) ).iterator());  ClassicGroupMember member = new ClassicGroupMember( "member", Optional.of("group-instance-id"), "client-id", "client-host", 10, 4500, "generic", protocols, new byte[0] );  DescribeGroupsResponseData.DescribedGroupMember expectedDescribedGroupMember = new DescribeGroupsResponseData.DescribedGroupMember() .setMemberId("member") .setGroupInstanceId("group-instance-id") .setClientId("client-id") .setClientHost("client-host") .setMemberAssignment(new byte[0]) .setMemberMetadata(member.metadata("range"));  DescribeGroupsResponseData.DescribedGroupMember describedGroupMember = member.describe("range");  "<AssertPlaceHolder>"; }
describe(String protocolName) { return describeNoMetadata().setMemberMetadata(metadata(protocolName)); }
[*] target: assertEquals(expectedDescribedGroupMember, describedGroupMember)
[-] pred: org. junit. Assert. assertEquals ( expectedDescribedGroupMember, describedGroupMember )
************************************
************************************
[+] input: testAsConsumerGroupDescribeMember() { Uuid topicId1 = Uuid.randomUuid(); Uuid topicId2 = Uuid.randomUuid(); Uuid topicId3 = Uuid.randomUuid(); Uuid topicId4 = Uuid.randomUuid(); MetadataImage metadataImage = new MetadataImageBuilder() .addTopic(topicId1, "topic1", 3) .addTopic(topicId2, "topic2", 3) .addTopic(topicId3, "topic3", 3) .addTopic(topicId4, "topic4", 3) .build(); List<Integer> assignedPartitions = Arrays.asList(0, 1, 2); int epoch = 10; ConsumerGroupCurrentMemberAssignmentValue record = new ConsumerGroupCurrentMemberAssignmentValue() .setMemberEpoch(epoch) .setPreviousMemberEpoch(epoch - 1) .setAssignedPartitions(Collections.singletonList(new ConsumerGroupCurrentMemberAssignmentValue.TopicPartitions() .setTopicId(topicId1) .setPartitions(assignedPartitions))) .setPartitionsPendingRevocation(Collections.singletonList(new ConsumerGroupCurrentMemberAssignmentValue.TopicPartitions() .setTopicId(topicId2) .setPartitions(Arrays.asList(3, 4, 5)))); String memberId = Uuid.randomUuid().toString(); String clientId = "clientId"; String instanceId = "instanceId"; String rackId = "rackId"; String clientHost = "clientHost"; List<String> subscribedTopicNames = Arrays.asList("topic1", "topic2"); String subscribedTopicRegex = "topic.*"; Map<Uuid, Set<Integer>> assignmentMap = new HashMap<>(); assignmentMap.put(topicId4, new HashSet<>(assignedPartitions)); Assignment targetAssignment = new Assignment(assignmentMap); ConsumerGroupMember member = new ConsumerGroupMember.Builder(memberId) .updateWith(record) .setClientId(clientId) .setInstanceId(instanceId) .setRackId(rackId) .setClientHost(clientHost) .setSubscribedTopicNames(subscribedTopicNames) .setSubscribedTopicRegex(subscribedTopicRegex) .build();  ConsumerGroupDescribeResponseData.Member actual = member.asConsumerGroupDescribeMember(targetAssignment, metadataImage.topics()); ConsumerGroupDescribeResponseData.Member expected = new ConsumerGroupDescribeResponseData.Member() .setMemberId(memberId) .setMemberEpoch(epoch) .setClientId(clientId) .setInstanceId(instanceId) .setRackId(rackId) .setClientHost(clientHost) .setSubscribedTopicNames(new ArrayList<>(subscribedTopicNames)) .setSubscribedTopicRegex(subscribedTopicRegex) .setAssignment( new ConsumerGroupDescribeResponseData.Assignment() .setTopicPartitions(Collections.singletonList(new ConsumerGroupDescribeResponseData.TopicPartitions() .setTopicId(topicId1) .setTopicName("topic1") .setPartitions(assignedPartitions) )) ) .setTargetAssignment( new ConsumerGroupDescribeResponseData.Assignment() .setTopicPartitions(targetAssignment.partitions().entrySet().stream().map( item -> new ConsumerGroupDescribeResponseData.TopicPartitions() .setTopicId(item.getKey()) .setTopicName("topic4") .setPartitions(new ArrayList<>(item.getValue())) ).collect(Collectors.toList())) );  "<AssertPlaceHolder>"; }
setSubscribedTopicRegex(String subscribedTopicRegex) { this.subscribedTopicRegex = subscribedTopicRegex; return this; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testAsConsumerGroupDescribeWithTopicNameNotFound() { Uuid memberId = Uuid.randomUuid(); ConsumerGroupCurrentMemberAssignmentValue record = new ConsumerGroupCurrentMemberAssignmentValue() .setAssignedPartitions(Collections.singletonList(new ConsumerGroupCurrentMemberAssignmentValue.TopicPartitions() .setTopicId(Uuid.randomUuid()) .setPartitions(Arrays.asList(0, 1, 2)))); ConsumerGroupMember member = new ConsumerGroupMember.Builder(memberId.toString()) .updateWith(record) .build();  ConsumerGroupDescribeResponseData.Member expected = new ConsumerGroupDescribeResponseData.Member() .setMemberId(memberId.toString()) .setSubscribedTopicRegex(""); ConsumerGroupDescribeResponseData.Member actual = member.asConsumerGroupDescribeMember(null, new MetadataImageBuilder() .addTopic(Uuid.randomUuid(), "foo", 3) .build().topics() ); "<AssertPlaceHolder>"; }
build() { return new ConsumerGroupMember( memberId, memberEpoch, previousMemberEpoch, instanceId, rackId, rebalanceTimeoutMs, clientId, clientHost, subscribedTopicNames, subscribedTopicRegex, serverAssignorName, state, assignedPartitions, partitionsPendingRevocation, classicMemberMetadata ); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { ClientQuotaControlManager manager = new ClientQuotaControlManager.Builder().build();  Map<ClientQuotaEntity, Map<String, Double>> quotasToTest = new HashMap<>(); quotasToTest.put(userClientEntity("user-1", "client-id-1"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 50.50)); quotasToTest.put(userClientEntity("user-2", "client-id-1"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 51.51)); quotasToTest.put(userClientEntity("user-3", "client-id-2"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 52.52)); quotasToTest.put(userClientEntity(null, "client-id-1"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 53.53)); quotasToTest.put(userClientEntity("user-1", null), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 54.54)); quotasToTest.put(userClientEntity("user-3", null), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 55.55)); quotasToTest.put(userEntity("user-1"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 56.56)); quotasToTest.put(userEntity("user-2"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 57.57)); quotasToTest.put(userEntity("user-3"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 58.58)); quotasToTest.put(userEntity(null), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 59.59)); quotasToTest.put(clientEntity("client-id-2"), quotas(QuotaConfigs.REQUEST_PERCENTAGE_OVERRIDE_CONFIG, 60.60));  List<ClientQuotaAlteration> alters = new ArrayList<>(); quotasToTest.forEach((entity, quota) -> entityQuotaToAlterations(entity, quota, alters::add)); List<ApiMessageAndVersion> records = alterQuotas(alters, manager); List<ApiMessageAndVersion> expectedRecords = Arrays.asList( new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-1"), new EntityData().setEntityType("client-id").setEntityName("client-id-1"))). setKey("request_percentage").setValue(50.5).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-2"), new EntityData().setEntityType("client-id").setEntityName("client-id-1"))). setKey("request_percentage").setValue(51.51).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-3"), new EntityData().setEntityType("client-id").setEntityName("client-id-2"))). setKey("request_percentage").setValue(52.52).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName(null), new EntityData().setEntityType("client-id").setEntityName("client-id-1"))). setKey("request_percentage").setValue(53.53).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-1"), new EntityData().setEntityType("client-id").setEntityName(null))). setKey("request_percentage").setValue(54.54).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-3"), new EntityData().setEntityType("client-id").setEntityName(null))). setKey("request_percentage").setValue(55.55).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-1"))). setKey("request_percentage").setValue(56.56).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-2"))). setKey("request_percentage").setValue(57.57).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName("user-3"))). setKey("request_percentage").setValue(58.58).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("user").setEntityName(null))). setKey("request_percentage").setValue(59.59).setRemove(false), (short) 0), new ApiMessageAndVersion(new ClientQuotaRecord().setEntity(Arrays.asList( new EntityData().setEntityType("client-id").setEntityName("client-id-2"))). setKey("request_percentage").setValue(60.60).setRemove(false), (short) 0)); records = new ArrayList<>(records); RecordTestUtils.deepSortRecords(records); RecordTestUtils.deepSortRecords(expectedRecords); "<AssertPlaceHolder>"; }
build() { if (logContext == null) logContext = new LogContext(); if (snapshotRegistry == null) snapshotRegistry = new SnapshotRegistry(logContext); return new ClientQuotaControlManager(logContext, snapshotRegistry); }
[*] target: assertEquals(expectedRecords, records)
[-] pred: org. junit. Assert. assertEquals ( expectedRecords, records )
************************************
************************************
[+] input: testKeepsDirectoriesAfterReassignment() { PartitionRegistration registration = new PartitionRegistration.Builder(). setReplicas(new int[]{2, 1, 3}). setDirectories(new Uuid[]{ Uuid.fromString("v1PVrX6uS5m8CByXlLfmWg"), Uuid.fromString("iU2znv45Q9yQkOpkTSy3jA"), Uuid.fromString("fM5NKyWTQHqEihjIkUl99Q") }). setIsr(new int[]{2, 1, 3}). setLeader(1). setLeaderRecoveryState(LeaderRecoveryState.RECOVERED). setLeaderEpoch(100). setPartitionEpoch(200). build(); Optional<ApiMessageAndVersion> built = new PartitionChangeBuilder(registration, FOO_ID, 0, r -> true, MetadataVersion.IBP_3_7_IV2, 2). setTargetReplicas(Arrays.asList(3, 1, 5, 4)). setDirectory(5, Uuid.fromString("RNJ5oFjjSSWMMFRwqdCfJg")). setDefaultDirProvider(DEFAULT_DIR_PROVIDER). build(); Optional<ApiMessageAndVersion> expected = Optional.of(new ApiMessageAndVersion( new PartitionChangeRecord(). setTopicId(FOO_ID). setPartitionId(0). setLeader(1). setReplicas(Arrays.asList(3, 1, 5, 4)). setDirectories(Arrays.asList( Uuid.fromString("fM5NKyWTQHqEihjIkUl99Q"), Uuid.fromString("iU2znv45Q9yQkOpkTSy3jA"), Uuid.fromString("RNJ5oFjjSSWMMFRwqdCfJg"), DirectoryId.UNASSIGNED )), (short) 1 )); "<AssertPlaceHolder>"; }
build() { PartitionChangeRecord record = new PartitionChangeRecord(). setTopicId(topicId). setPartitionId(partitionId);  completeReassignmentIfNeeded();  maybePopulateTargetElr();  tryElection(record);  triggerLeaderEpochBumpForReplicaReassignmentIfNeeded(record);  maybeUpdateRecordElr(record);  // If ELR is enabled, the ISR is allowed to be empty. if (record.isr() == null && (!targetIsr.isEmpty() || eligibleLeaderReplicasEnabled) && !targetIsr.equals(Replicas.toList(partition.isr))) { // Set the new ISR if it is different from the current ISR and unclean leader election didn't already set it. if (targetIsr.isEmpty()) { log.debug("A partition will have an empty ISR. " + this); } record.setIsr(targetIsr); }  triggerLeaderEpochBumpForIsrShrinkIfNeeded(record);  maybeUpdateLastKnownLeader(record);  setAssignmentChanges(record);  if (targetLeaderRecoveryState != partition.leaderRecoveryState) { record.setLeaderRecoveryState(targetLeaderRecoveryState.value()); }  if (changeRecordIsNoOp(record)) { return Optional.empty(); } else { return Optional.of(new ApiMessageAndVersion(record, metadataVersion.partitionChangeRecordVersion())); } }
[*] target: assertEquals(expected, built)
[-] pred: org. junit. Assert. assertEquals ( expected, built )
************************************
************************************
[+] input: testUpdateDirectories() { PartitionRegistration registration = new PartitionRegistration.Builder(). setReplicas(new int[]{2, 1, 3}). setDirectories(new Uuid[]{ Uuid.fromString("S1zMYZczRjWmucidLqGA5g"), Uuid.fromString("9eRNXTvFTsWUJObvW51V5A"), Uuid.fromString("UpePYVBgRAi3c4ujQrf3Kg") }). setIsr(new int[]{2, 1, 3}). setLeader(2). setLeaderRecoveryState(LeaderRecoveryState.RECOVERED). setLeaderEpoch(100). setPartitionEpoch(200). build(); Optional<ApiMessageAndVersion> built = new PartitionChangeBuilder(registration, FOO_ID, 0, r -> true, MetadataVersion.latestTesting(), 2). setDirectory(3, Uuid.fromString("pN1VKs9zRzK4APflpegAVg")). setDirectory(1, DirectoryId.LOST). setDefaultDirProvider(DEFAULT_DIR_PROVIDER). build(); Optional<ApiMessageAndVersion> expected = Optional.of(new ApiMessageAndVersion( new PartitionChangeRecord(). setTopicId(FOO_ID). setPartitionId(0). setDirectories(Arrays.asList( Uuid.fromString("S1zMYZczRjWmucidLqGA5g"), DirectoryId.LOST, Uuid.fromString("pN1VKs9zRzK4APflpegAVg") )), (short) 2 )); "<AssertPlaceHolder>"; }
build() { PartitionChangeRecord record = new PartitionChangeRecord(). setTopicId(topicId). setPartitionId(partitionId);  completeReassignmentIfNeeded();  maybePopulateTargetElr();  tryElection(record);  triggerLeaderEpochBumpForReplicaReassignmentIfNeeded(record);  maybeUpdateRecordElr(record);  // If ELR is enabled, the ISR is allowed to be empty. if (record.isr() == null && (!targetIsr.isEmpty() || eligibleLeaderReplicasEnabled) && !targetIsr.equals(Replicas.toList(partition.isr))) { // Set the new ISR if it is different from the current ISR and unclean leader election didn't already set it. if (targetIsr.isEmpty()) { log.debug("A partition will have an empty ISR. " + this); } record.setIsr(targetIsr); }  triggerLeaderEpochBumpForIsrShrinkIfNeeded(record);  maybeUpdateLastKnownLeader(record);  setAssignmentChanges(record);  if (targetLeaderRecoveryState != partition.leaderRecoveryState) { record.setLeaderRecoveryState(targetLeaderRecoveryState.value()); }  if (changeRecordIsNoOp(record)) { return Optional.empty(); } else { return Optional.of(new ApiMessageAndVersion(record, metadataVersion.partitionChangeRecordVersion())); } }
[*] target: assertEquals(expected, built)
[-] pred: org. junit. Assert. assertEquals ( expected, built )
************************************
************************************
[+] input: RemoteResourceNotFoundException { Map<RemoteLogSegmentId, RemoteLogSegmentMetadata> segmentIdToMetadataMap = new HashMap<>();  // copy started but never finished so marked as unreferenced RemoteLogSegmentId segmentId1 = new RemoteLogSegmentId(tpId, Uuid.randomUuid()); epochState.handleSegmentWithCopySegmentStartedState(segmentId1); segmentIdToMetadataMap.put(segmentId1, createRemoteLogSegmentMetadata(segmentId1, 0L));  // copy finished successfully RemoteLogSegmentId segmentId2 = new RemoteLogSegmentId(tpId, Uuid.randomUuid()); epochState.handleSegmentWithCopySegmentFinishedState(5L, segmentId2, 10L); segmentIdToMetadataMap.put(segmentId2, createRemoteLogSegmentMetadata(segmentId2, 5L));  // copy finished successfully, but overwritten by the next segment upload so marked as unreferenced. RemoteLogSegmentId segmentId3 = new RemoteLogSegmentId(tpId, Uuid.randomUuid()); epochState.handleSegmentWithCopySegmentFinishedState(11L, segmentId3, 100L); segmentIdToMetadataMap.put(segmentId3, createRemoteLogSegmentMetadata(segmentId3, 11L));  // copy finished successfully RemoteLogSegmentId segmentId4 = new RemoteLogSegmentId(tpId, Uuid.randomUuid()); epochState.handleSegmentWithCopySegmentFinishedState(9L, segmentId4, 150L); segmentIdToMetadataMap.put(segmentId4, createRemoteLogSegmentMetadata(segmentId4, 9L));  // segments should be sorted by start-offset List<RemoteLogSegmentId> expectedList = Arrays.asList(segmentId1, segmentId2, segmentId4, segmentId3); List<RemoteLogSegmentId> actualList = new ArrayList<>(); epochState.listAllRemoteLogSegments(segmentIdToMetadataMap) .forEachRemaining(metadata -> actualList.add(metadata.remoteLogSegmentId())); "<AssertPlaceHolder>"; }
listAllRemoteLogSegments(Map<RemoteLogSegmentId, RemoteLogSegmentMetadata> idToSegmentMetadata) throws RemoteResourceNotFoundException { // Return all the segments including unreferenced metadata. int size = offsetToId.size() + unreferencedSegmentIds.size(); if (size == 0) { return Collections.emptyIterator(); }  ArrayList<RemoteLogSegmentMetadata> metadataList = new ArrayList<>(size); collectConvertedIdToMetadata(offsetToId.values(), idToSegmentMetadata, metadataList);  if (!unreferencedSegmentIds.isEmpty()) { collectConvertedIdToMetadata(unreferencedSegmentIds, idToSegmentMetadata, metadataList);  // Sort only when unreferenced entries exist as they are already sorted in offsetToId. metadataList.sort(Comparator.comparingLong(RemoteLogSegmentMetadata::startOffset)); }  return metadataList.iterator(); }
[*] target: assertEquals(expectedList, actualList)
[-] pred: org. junit. Assert. assertEquals ( expectedList, actualList )
************************************
************************************
[+] input: testRemoteLogSegmentMetadataTransform() { RemoteLogSegmentMetadataTransform metadataTransform = new RemoteLogSegmentMetadataTransform();  RemoteLogSegmentMetadata metadata = createRemoteLogSegmentMetadata(); ApiMessageAndVersion apiMessageAndVersion = metadataTransform.toApiMessageAndVersion(metadata); RemoteLogSegmentMetadata remoteLogSegmentMetadataFromRecord = metadataTransform .fromApiMessageAndVersion(apiMessageAndVersion);  Assertions."<AssertPlaceHolder>"; }
fromApiMessageAndVersion(ApiMessageAndVersion apiMessageAndVersion);
[*] target: assertEquals(metadata, remoteLogSegmentMetadataFromRecord)
[-] pred: org. junit. Assert. assertEquals ( metadata, remoteLogSegmentMetadataFromRecord )
************************************
************************************
[+] input: testTimeWindowSerdeFrom() { final Windowed<Integer> timeWindowed = new Windowed<>(10, new TimeWindow(0, Long.MAX_VALUE)); final Serde<Windowed<Integer>> timeWindowedSerde = WindowedSerdes.timeWindowedSerdeFrom(Integer.class, Long.MAX_VALUE); final byte[] bytes = timeWindowedSerde.serializer().serialize(topic, timeWindowed); final Windowed<Integer> windowed = timeWindowedSerde.deserializer().deserialize(topic, bytes); "<AssertPlaceHolder>"; }
timeWindowedSerdeFrom(final Class<T> type, final long windowSize) { return new TimeWindowedSerde<>(Serdes.serdeFrom(type), windowSize); }
[*] target: assertEquals(timeWindowed, windowed)
[-] pred: org. junit. Assert. assertEquals ( timeWindowed, windowed )
************************************
************************************
[+] input: shouldParseSingleKeyValuePairString() { final Map<String, String> expectedSinglePairMap = new HashMap<>(); expectedSinglePairMap.put("foo", "bar"); final String singleValueString = "foo=bar"; final Map<String, String> parsedMap = SystemTestUtil.parseConfigs(singleValueString); "<AssertPlaceHolder>"; }
parseConfigs(final String formattedConfigs) { Objects.requireNonNull(formattedConfigs, "Formatted config String can't be null");  if (formattedConfigs.indexOf('=') == -1) { throw new IllegalStateException(String.format("Provided string [ %s ] does not have expected key-value separator of '='", formattedConfigs)); }  final String[] parts = formattedConfigs.split(","); final Map<String, String> configs = new HashMap<>(); for (final String part : parts) { final String[] keyValue = part.split("="); if (keyValue.length > 2) { throw new IllegalStateException( String.format("Provided string [ %s ] does not have expected key-value pair separator of ','", formattedConfigs)); } configs.put(keyValue[KEY], keyValue[VALUE]); } return configs; }
[*] target: assertEquals(expectedSinglePairMap, parsedMap)
[-] pred: org. junit. Assert. assertEquals ( expectedSinglePairMap, parsedMap )
************************************
************************************
[+] input: parseS3UrlValFromArgs() { String s3Url = "s3://s3.cn-northwest-1.amazonaws.com.cn?s3-access-key=xxx&s3-secret-key=yyy&s3-region=cn-northwest-1&s3-endpoint-protocol=https&s3-data-bucket=wanshao-test&s3-ops-bucket=automq-ops-bucket&cluster-id=fZGPJht6Rf-o7WgrUakLxQ"; String[] args = Arrays.asList("--s3-url=" + s3Url, "--controller-list="192.168.123.234:9093"").toArray(new String[0]); String s3urlVal = S3Url.parseS3UrlValFromArgs(args); Assertions."<AssertPlaceHolder>"; }
parseS3UrlValFromArgs(String[] args) { for (String arg : args) { if (arg.startsWith("--s3-url=")) { return arg.substring("--s3-url=".length()); } } return null; }
[*] target: assertEquals(s3Url, s3urlVal)
[-] pred: org. junit. Assert. assertEquals ( s3Url, s3urlVal )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) { CoordinatorClient coordinatorClient = cluster.coordinatorClient();  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); coordinatorClient.createTask(new CreateTaskRequest("foo", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("foo").taskState(new TaskPending(fooSpec)).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("foo")); "<AssertPlaceHolder>";   time.sleep(2); new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskRunning(fooSpec, 2, new TextNode("active"))). workerState(new WorkerRunning("foo", fooSpec, 2, new TextNode("active"))). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); time.sleep(550); // coordinator heartbeat sees that the agent is back up, re-schedules the task but the agent expires it new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). workerState(new WorkerDone("foo", fooSpec, 552, 552, null, "worker expired")). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); // coordinator heartbeat sees that the agent is back up but does not re-schedule the task as it is DONE new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). // no worker states build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02")); } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); time.sleep(552);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); NoOpTaskSpec updatedSpec = new NoOpTaskSpec(552, 500); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskRunning(updatedSpec, 552, new TextNode("receiving")) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1000, 500); time.sleep(999);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskPending(fooSpec) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: givenValidPhoneNumber_whenUserExistsByPhoneNumber_thenReturnTrue() {  // Given AysPhoneNumber mockPhoneNumber = new AysPhoneNumberBuilder() .withValidValues() .build();  // When Mockito.when(userRepository.existsByCountryCodeAndLineNumber(mockPhoneNumber.getCountryCode(), mockPhoneNumber.getLineNumber())) .thenReturn(true);  // Then boolean isUserExists = userAdapter.existsByPhoneNumber(mockPhoneNumber);  Assertions."<AssertPlaceHolder>";  // Verify Mockito.verify(userRepository, Mockito.times(1)) .existsByCountryCodeAndLineNumber(mockPhoneNumber.getCountryCode(), mockPhoneNumber.getLineNumber()); }
existsByPhoneNumber(final AysPhoneNumber phoneNumber) { return userRepository.existsByCountryCodeAndLineNumber( phoneNumber.getCountryCode(), phoneNumber.getLineNumber() ); }
[*] target: assertTrue(isUserExists)
[-] pred: org. junit. Assert. assertTrue ( isUserExists )
************************************
************************************
[+] input: givenValidPhoneNumber_whenUserNotExistsByPhoneNumber_thenReturnFalse() {  // Given AysPhoneNumber mockPhoneNumber = new AysPhoneNumberBuilder() .withValidValues() .build();  // When Mockito.when(userRepository.existsByCountryCodeAndLineNumber(mockPhoneNumber.getCountryCode(), mockPhoneNumber.getLineNumber())) .thenReturn(false);  // Then boolean isUserExists = userAdapter.existsByPhoneNumber(mockPhoneNumber);  Assertions."<AssertPlaceHolder>";  // Verify Mockito.verify(userRepository, Mockito.times(1)) .existsByCountryCodeAndLineNumber(mockPhoneNumber.getCountryCode(), mockPhoneNumber.getLineNumber()); }
existsByPhoneNumber(final AysPhoneNumber phoneNumber) { return userRepository.existsByCountryCodeAndLineNumber( phoneNumber.getCountryCode(), phoneNumber.getLineNumber() ); }
[*] target: assertFalse(isUserExists)
[-] pred: org. junit. Assert. assertFalse ( isUserExists )
************************************
************************************
[+] input: givenValidId_whenActiveInstitutionExist_thenReturnTrue() { // Given String mockId = AysRandomUtil.generateUUID();  // When InstitutionStatus mockStatus = InstitutionStatus.ACTIVE; Mockito.when(institutionRepository.existsByIdAndStatus(mockId, mockStatus)) .thenReturn(true);  // Then boolean isInstitutionExist = institutionAdapter.existsByIdAndIsStatusActive(mockId);  Assertions."<AssertPlaceHolder>";  Mockito.verify(institutionRepository, Mockito.times(1)) .existsByIdAndStatus(mockId, mockStatus); }
existsByIdAndIsStatusActive(final String id) { return institutionRepository.existsByIdAndStatus(id, InstitutionStatus.ACTIVE); }
[*] target: assertTrue(isInstitutionExist)
[-] pred: org. junit. Assert. assertTrue ( isInstitutionExist )
************************************
************************************
[+] input: givenValidId_whenActiveInstitutionNotExist_thenReturnFalse() { // Given String mockId = AysRandomUtil.generateUUID();  // When InstitutionStatus mockStatus = InstitutionStatus.ACTIVE; Mockito.when(institutionRepository.existsByIdAndStatus(mockId, mockStatus)) .thenReturn(false);  // Then boolean isInstitutionExist = institutionAdapter.existsByIdAndIsStatusActive(mockId);  Assertions."<AssertPlaceHolder>";  Mockito.verify(institutionRepository, Mockito.times(1)) .existsByIdAndStatus(mockId, mockStatus); }
existsByIdAndIsStatusActive(final String id) { return institutionRepository.existsByIdAndStatus(id, InstitutionStatus.ACTIVE); }
[*] target: assertFalse(isInstitutionExist)
[-] pred: org. junit. Assert. assertFalse ( isInstitutionExist )
************************************
************************************
[+] input: testMavenCompilerSourceSetterWhenValueIsNotNull() { var publishProperties = new PublishProperties(); Integer testValue = 15; publishProperties.mavenCompilerSource(testValue); Integer actualValue = Integer.parseInt(publishProperties.get("maven.compiler.source")); "<AssertPlaceHolder>"; }
mavenCompilerSource(Integer value) { if (value == null) { remove(MAVEN_COMPILER_SOURCE); } else { put(MAVEN_COMPILER_SOURCE, String.valueOf(value)); } return this; }
[*] target: assertEquals(testValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( testValue, actualValue )
************************************
************************************
[+] input: testMavenCompilerTargetDefaultValue() { var publishProperties = new PublishProperties(); var actualValue = publishProperties.mavenCompilerTarget(); "<AssertPlaceHolder>"; }
mavenCompilerTarget() { var value = get(MAVEN_COMPILER_TARGET); if (value == null) { return null; } return Integer.parseInt(value); }
[*] target: assertNull(actualValue)
[-] pred: org. junit. Assert. assertNull ( actualValue )
************************************
************************************
[+] input: testMavenCompilerTargetSetterWhenValueIsNotNull() { var publishProperties = new PublishProperties(); Integer testValue = 15; publishProperties.mavenCompilerTarget(testValue); Integer actualValue = Integer.parseInt(publishProperties.get("maven.compiler.target")); "<AssertPlaceHolder>"; }
mavenCompilerTarget(Integer value) { if (value == null) { remove(MAVEN_COMPILER_TARGET); } else { put(MAVEN_COMPILER_TARGET, String.valueOf(value)); } return this; }
[*] target: assertEquals(testValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( testValue, actualValue )
************************************
************************************
[+] input: testMavenCompilerTargetGetterWhenValueIsNotNull() { var publishProperties = new PublishProperties(); Integer testValue = 8; publishProperties.put("maven.compiler.target", String.valueOf(testValue)); var actualValue = publishProperties.mavenCompilerTarget(); "<AssertPlaceHolder>"; }
mavenCompilerTarget() { var value = get(MAVEN_COMPILER_TARGET); if (value == null) { return null; } return Integer.parseInt(value); }
[*] target: assertEquals(testValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( testValue, actualValue )
************************************
************************************
[+] input: testMavenCompilerTargetGetterWhenValueIsNull() { var publishProperties = new PublishProperties(); publishProperties.put("maven.compiler.target", null); var actualValue = publishProperties.mavenCompilerTarget(); "<AssertPlaceHolder>"; }
mavenCompilerTarget() { var value = get(MAVEN_COMPILER_TARGET); if (value == null) { return null; } return Integer.parseInt(value); }
[*] target: assertNull(actualValue)
[-] pred: org. junit. Assert. assertNull ( actualValue )
************************************
************************************
[+] input: 키워드가_존재하는지_조회한다() { // given final String query = "민수";  // when boolean exists = popularSearchRepository.existsByKeyword(query);  // then "<AssertPlaceHolder>"; }
existsByKeyword(final String query) { return popularSearchRepository.existsByKeyword(query); }
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
************************************
[+] input: testPrepareSendFrameChecksum() {  // GIVEN // - the expected output frame bytes for command 0x85 final byte[] frameBytes = new byte[] { (byte) 0x4E, (byte) 0x57, (byte) 0x00, (byte) 0x13, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x06, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x68, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x29 };  // WHEN // - preparing a send frame for command 0x85 final ByteBuffer sendFrame = processor.prepareSendFrame();  // THEN // - the created send frame bytes should match Assertions."<AssertPlaceHolder>"; }
prepareSendFrame() { final ByteBuffer sendFrame = ByteBuffer.allocate(21).order(ByteOrder.LITTLE_ENDIAN); sendFrame.put((byte) 0x4E); // Start flag sendFrame.put((byte) 0x57); // Additional start flag or part of a combined flag sendFrame.put((byte) 0x00); // Frame Length Byte 1 sendFrame.put((byte) 0x13); // Frame Length Byte 2 sendFrame.put((byte) 0x00); // Terminal Number Byte 1 sendFrame.put((byte) 0x00); // Terminal Number Byte 2 sendFrame.put((byte) 0x00); // Terminal Number Byte 3 sendFrame.put((byte) 0x00); // Terminal Number Byte 4 sendFrame.put((byte) 0x06); // command id (0x01 - activation instruction, 0x02 - write // instruction, 0x03 - read identifier data, 0x05 - pair code // 0x06, - read all data sendFrame.put((byte) 0x03); // frame source id (0x00 - BMS, 0x01- BT, 0x02-GPS, 0x03 - PC) sendFrame.put((byte) 0x00); // 0.Read data, 1.Answer frame 2.Data box active upload sendFrame.put((byte) 0x00); // Read a single data reference (5.1 table);Read all data and // fill // in 0x00 sendFrame.putInt(0x00000000); // record number - 4 bytes (1st random, 2-4 recorde number) sendFrame.put((byte) 0x68); // End Identity  int sum = 0; for (int i = 0; i < sendFrame.array().length; i++) { sum += sendFrame.array()[i] & 0xFF; // Ensure the byte is treated as unsigned } sendFrame.put((byte) 0x00); // Checksum Byte 1 sendFrame.put((byte) 0x00); // Checksum Byte 2 sendFrame.put((byte) (sum >> 8 & 0xFF)); // Checksum Byte 3 sendFrame.put((byte) (sum & 0xFF)); // Checksum Byte 4  return sendFrame; }
[*] target: assertArrayEquals(frameBytes, sendFrame.array())
[-] pred: org. junit. Assert. assertArrayEquals ( frameBytes, sendFrame. array ( ) )
************************************
************************************
[+] input: givenValidBookCreateRequest_whenBookCreated_returnBook() {  // Given BookCreateRequest mockCreateRequest = BookCreateRequest.builder() .name("Name") .authorFullName("Author Full Name") .isbn("1234567890") .stock(123) .price(BigDecimal.TEN) .build();  Book mockBook = new BookBuilder().withValidFields().build();  BookDTO mockBookDTO = BookMapper.toDTO(mockBook);  // When when(bookRepository.save(any(Book.class))).thenReturn(mockBook);  // Then BookDTO response = bookService.createBook(mockCreateRequest);  "<AssertPlaceHolder>";  verify(bookRepository, times(1)).save(any(Book.class)); }
createBook(BookCreateRequest request) {  final Book bookEntityToBeSaved = BookMapper.mapForSaving(request);  return BookMapper.toDTO(bookRepository.save(bookEntityToBeSaved)); }
[*] target: assertEquals(mockBookDTO, response)
[-] pred: org. junit. Assert. assertEquals ( mockBookDTO, response )
************************************
************************************
[+] input: givenBookDtoAndAmount_whenBookDtoStockGreaterThanAmount_thenReturnTrue() {  // Given int amount = 50; BookDTO mockBookDTO = BookDTO.builder().stock(amount + 1).build();  // Then boolean response = bookService.isStockAvailable(mockBookDTO, amount);  Assertions."<AssertPlaceHolder>"; }
isStockAvailable(BookDTO bookDTO, int amount) { if (bookDTO.getStock() < amount) { throw new NoAvailableStockException(amount); } else { return true; }  }
[*] target: assertTrue(response)
[-] pred: org. junit. Assert. assertTrue ( response )
************************************
************************************
[+] input: givenValidCreateCustomerRequest_whenSuccess_thenReturnUserDto() {  // Given CustomerCreateRequest mockRequest = CustomerCreateRequest.builder() .email(RandomUtil.generateRandomString().concat("@bookdelivery.com")) .password(RandomUtil.generateRandomString()) .fullName(RandomUtil.generateRandomString()) .username(RandomUtil.generateRandomString()) .build();  User user = User.builder() .id(1L) .email(mockRequest.getEmail()) .fullName(mockRequest.getFullName()) .username(mockRequest.getUsername()) .role(Role.ROLE_CUSTOMER) .password(mockRequest.getPassword()) .build();  UserDTO userDTO = UserMapper.toDTO(user);  // When Mockito.when(userRepository.existsByEmail(mockRequest.getEmail())).thenReturn(false); Mockito.when(userRepository.save(Mockito.any(User.class))).thenReturn(user);  // Then UserDTO response = customerService.createCustomer(mockRequest);  Assertions."<AssertPlaceHolder>"; Mockito.verify(userRepository, Mockito.times(1)).existsByEmail(Mockito.anyString()); Mockito.verify(userRepository, Mockito.times(1)).save(Mockito.any(User.class)); Mockito.verify(passwordEncoder, Mockito.times(1)).encode(Mockito.anyString()); }
createCustomer(CustomerCreateRequest request) {  if (userRepository.existsByEmail(request.getEmail())) { throw new EmailAlreadyExistsException(request.getEmail()); }  User user = User.builder() .email(request.getEmail()) .fullName(request.getFullName()) .username(request.getUsername()) .password(passwordEncoder.encode(request.getPassword())) .role(Role.ROLE_CUSTOMER) .build();  return UserMapper.toDTO(userRepository.save(user));  }
[*] target: assertEquals(userDTO, response)
[-] pred: org. junit. Assert. assertEquals ( userDTO, response )
************************************
************************************
[+] input: givenValidCreateOrderRequest_whenOrderCreated_thenReturnOrderDTO() {  // Given String bookId1 = RandomUtil.generateUUID(); String bookId2 = RandomUtil.generateUUID();  User user = new UserBuilder().customer().build(); CustomUserDetails userDetails = new CustomUserDetails(user);  OrderItemRequest mockOrderItemRequest1 = OrderItemRequest.builder() .bookId(bookId1) .amount(RandomUtil.generateRandomInteger(0, 5)) .build();  OrderItem orderItem1 = OrderItem.builder() .id(1L) .book(new BookBuilder().withValidFields().build()) .build(); OrderItemDTO orderItemDTO1 = OrderItemMapper.toDTO(orderItem1);  OrderItemRequest mockOrderItemRequest2 = OrderItemRequest.builder() .bookId(bookId2) .amount(RandomUtil.generateRandomInteger(0, 5)) .build();  OrderItem orderItem2 = OrderItem.builder() .id(2L) .book(new BookBuilder().withValidFields().build()) .build(); OrderItemDTO orderItemDTO2 = OrderItemMapper.toDTO(orderItem2);  CreateOrderRequest mockCreateOrderRequest = CreateOrderRequest.builder() .orderDetailSet(new LinkedHashSet<>(List.of(mockOrderItemRequest1, mockOrderItemRequest2))) .build();  Order order = Order.builder() .id(1L) .user(user) .orderItems(List.of(orderItem1, orderItem2)) .build();  OrderDTO expected = OrderMapper.toOrderDTO(order);  // When Mockito.when(identity.getCustomUserDetails()).thenReturn(userDetails); Mockito.when(userService.findByEmail(Mockito.anyString())).thenReturn(Optional.of(user)); Mockito.when(orderItemService.createOrderItem(mockOrderItemRequest1)).thenReturn(orderItemDTO1); Mockito.when(orderItemService.createOrderItem(mockOrderItemRequest2)).thenReturn(orderItemDTO2); Mockito.when(orderRepository.save(Mockito.any(Order.class))).thenReturn(order);  // Then OrderDTO response = orderSaveService.createOrder(mockCreateOrderRequest);  Assertions."<AssertPlaceHolder>"; Mockito.verify(identity, Mockito.times(1)).getCustomUserDetails(); Mockito.verify(orderItemService, Mockito.times(2)).createOrderItem(Mockito.any(OrderItemRequest.class)); Mockito.verify(orderRepository, Mockito.times(1)).save(Mockito.any(Order.class)); }
createOrder(CreateOrderRequest createOrderRequest) {  CustomUserDetails customUserDetails = identity.getCustomUserDetails();  User user = userService.findByEmail(customUserDetails.getEmail()) .orElseThrow(() -> new UserNotFoundException(customUserDetails.getId()));  List<OrderItemDTO> orderItemDTOs = createOrderRequest .getOrderDetailSet() .stream() .map(orderItemService::createOrderItem) .toList();  Order order = Order.builder() .user(user) .build();  order.setOrderItems(OrderItemMapper.toOrderItem(orderItemDTOs));  return OrderMapper.toOrderDTO(orderRepository.save(order));  }
[*] target: assertEquals(expected, response)
[-] pred: org. junit. Assert. assertEquals ( expected, response )
************************************
************************************
[+] input: IpRangeFormatException { String inputRange = "192.168.0.1-192.168.0.10"; NormalizeRangeHost normalizeRangeHost = new NormalizeRangeHost(inputRange);  String expectedNormalizedRange = "[192.168.0.1 TO 192.168.0.10]"; String actualNormalizedRange = normalizeRangeHost.normalize();  "<AssertPlaceHolder>"; }
normalize() throws IpRangeFormatException { String normalizedRange; final Matcher matcher = getIpRangeMatcher(); final Matcher subnetMatcher = getSubnetMatcher();  if (matcher.find()) { normalizedRange = processIpRange(matcher); } else if (subnetMatcher.find()) { normalizedRange = processSubnet(subnetMatcher); } else { throw new IpRangeFormatException("Invalid IP range format: " + range); }  return normalizedRange; }
[*] target: assertEquals(expectedNormalizedRange, actualNormalizedRange)
[-] pred: org. junit. Assert. assertEquals ( expectedNormalizedRange, actualNormalizedRange )
************************************
************************************
[+] input: IpRangeFormatException { String inputRange = "192.168.0.1 - 192.168.0.10"; NormalizeRangeHost normalizeRangeHost = new NormalizeRangeHost(inputRange);  String expectedNormalizedRange = "[192.168.0.1 TO 192.168.0.10]"; String actualNormalizedRange = normalizeRangeHost.normalize();  "<AssertPlaceHolder>"; }
normalize() throws IpRangeFormatException { String normalizedRange; final Matcher matcher = getIpRangeMatcher(); final Matcher subnetMatcher = getSubnetMatcher();  if (matcher.find()) { normalizedRange = processIpRange(matcher); } else if (subnetMatcher.find()) { normalizedRange = processSubnet(subnetMatcher); } else { throw new IpRangeFormatException("Invalid IP range format: " + range); }  return normalizedRange; }
[*] target: assertEquals(expectedNormalizedRange, actualNormalizedRange)
[-] pred: org. junit. Assert. assertEquals ( expectedNormalizedRange, actualNormalizedRange )
************************************
************************************
[+] input: IpRangeFormatException { String inputRange = "192.168.0.1,192.168.0.10"; NormalizeRangeHost normalizeRangeHost = new NormalizeRangeHost(inputRange);  String expectedNormalizedRange = "[192.168.0.1 TO 192.168.0.10]"; String actualNormalizedRange = normalizeRangeHost.normalize();  "<AssertPlaceHolder>"; }
normalize() throws IpRangeFormatException { String normalizedRange; final Matcher matcher = getIpRangeMatcher(); final Matcher subnetMatcher = getSubnetMatcher();  if (matcher.find()) { normalizedRange = processIpRange(matcher); } else if (subnetMatcher.find()) { normalizedRange = processSubnet(subnetMatcher); } else { throw new IpRangeFormatException("Invalid IP range format: " + range); }  return normalizedRange; }
[*] target: assertEquals(expectedNormalizedRange, actualNormalizedRange)
[-] pred: org. junit. Assert. assertEquals ( expectedNormalizedRange, actualNormalizedRange )
************************************
************************************
[+] input: IpRangeFormatException { String inputRange = "192.168.0.1/24"; NormalizeRangeHost normalizeRangeHost = new NormalizeRangeHost(inputRange);  String expectedNormalizedRange = ""192.168.0.1/24""; String actualNormalizedRange = normalizeRangeHost.normalize();  "<AssertPlaceHolder>"; }
normalize() throws IpRangeFormatException { String normalizedRange; final Matcher matcher = getIpRangeMatcher(); final Matcher subnetMatcher = getSubnetMatcher();  if (matcher.find()) { normalizedRange = processIpRange(matcher); } else if (subnetMatcher.find()) { normalizedRange = processSubnet(subnetMatcher); } else { throw new IpRangeFormatException("Invalid IP range format: " + range); }  return normalizedRange; }
[*] target: assertEquals(expectedNormalizedRange, actualNormalizedRange)
[-] pred: org. junit. Assert. assertEquals ( expectedNormalizedRange, actualNormalizedRange )
************************************
************************************
[+] input: testBuild() { List<String> list = new ArrayList<>(Arrays.asList("value1", "value2", "value3")); ListBuilder builder = new ListBuilder("field", list); builder.setSeparator(" AND ");  String expected = "(field:"value1" AND field:"value2" AND field:"value3")"; String actual = builder.build();  "<AssertPlaceHolder>"; }
build() { if (list == null) { return ""; } final int min = 1; final String query = generate(value, list).toString(); if (list.size() > min) { return String.format("(%s)", query); } return query; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testBuildWithNullList() { ListBuilder builder = new ListBuilder("field", null); builder.setSeparator(" OR ");  String expected = ""; String actual = builder.build();  "<AssertPlaceHolder>"; }
build() { if (list == null) { return ""; } final int min = 1; final String query = generate(value, list).toString(); if (list.size() > min) { return String.format("(%s)", query); } return query; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testSetSeparator() { ListBuilder builder = new ListBuilder("field", new ArrayList<>()); builder.setSeparator(" OR ");  String expected = " OR "; String actual = builder.getSeparator();  "<AssertPlaceHolder>"; }
getSeparator() { return separator; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testUpdateWithPermission() { userLoginIdentity(false, 1L); //        userLoginIdentity(true, 4L);  ChartUpdateParam chartUpdateParam = new ChartUpdateParam(); Optional.of(chartUpdateParam).ifPresent(param -> { param.setId(1L); param.setName("chat2db"); param.setSchema("test"); param.setDataSourceId(1L); param.setType("DM"); param.setDatabaseName("chat2db"); param.setSchemaName("ali_dbhub"); param.setDdl("test"); });  ActionResult actionResult = chartService.updateWithPermission(chartUpdateParam); "<AssertPlaceHolder>"; }
updateWithPermission(ChartUpdateParam param);
[*] target: assertNotNull(actionResult)
[-] pred: org. junit. Assert. assertNotNull ( actionResult )
************************************
************************************
[+] input: testListQuery() { userLoginIdentity(false, 8L); //        userLoginIdentity(true, 10L);  ChartListQueryParam param = new ChartListQueryParam(); param.setIdList(Arrays.asList(4L, 5L, 6L)); param.setUserId(1L);  ListResult<Chart> listQuery = chartService.listQuery(param); "<AssertPlaceHolder>";  }
listQuery(@NotNull ChartListQueryParam param);
[*] target: assertNotNull(listQuery)
[-] pred: org. junit. Assert. assertNotNull ( listQuery )
************************************
************************************
[+] input: testDeleteWithPermission() { userLoginIdentity(false, 10L); //        userLoginIdentity(true, 12L);  ActionResult actionResult = chartService.deleteWithPermission(3L); "<AssertPlaceHolder>"; }
deleteWithPermission(@NotNull Long id);
[*] target: assertNotNull(actionResult)
[-] pred: org. junit. Assert. assertNotNull ( actionResult )
************************************
************************************
[+] input: testCreate() { userLoginIdentity(true, 1L); //        userLoginIdentity(false, 2L);  SystemConfigParam systemConfigParam = new SystemConfigParam(); Optional.ofNullable(systemConfigParam).ifPresent(param -> { param.setCode(RandomCodeGenerator.generateRandomCode(6)); param.setContent(RandomCodeGenerator.generateRandomCode(6)); param.setSummary(RandomCodeGenerator.generateRandomCode(6)); });  ActionResult actionResult = configService.create(systemConfigParam); "<AssertPlaceHolder>"; }
create(SystemConfigParam param);
[*] target: assertNotNull(actionResult)
[-] pred: org. junit. Assert. assertNotNull ( actionResult )
************************************
************************************
[+] input: testUpdate() { userLoginIdentity(true, 4L); //        userLoginIdentity(false, 5L);  SystemConfigParam systemConfigParam = new SystemConfigParam(); systemConfigParam.setCode(RandomCodeGenerator.generateRandomCode(6)); systemConfigParam.setContent(RandomCodeGenerator.generateRandomCode(6)); systemConfigParam.setSummary(RandomCodeGenerator.generateRandomCode(6));  ActionResult update = configService.update(systemConfigParam); "<AssertPlaceHolder>";  }
update(SystemConfigParam param);
[*] target: assertNotNull(update)
[-] pred: org. junit. Assert. assertNotNull ( update )
************************************
************************************
[+] input: testDelete() { userLoginIdentity(true, 11L); //        userLoginIdentity(false, 12L);  ActionResult result = configService.delete("4TxfzW"); "<AssertPlaceHolder>"; }
delete(@NotNull String code);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDeleteDatabase() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  DatabaseCreateParam param = new DatabaseCreateParam(); param.setName("test");  ActionResult actionResult = databaseService.deleteDatabase(param); "<AssertPlaceHolder>"; } }
deleteDatabase(DatabaseCreateParam param);
[*] target: assertNotNull(actionResult)
[-] pred: org. junit. Assert. assertNotNull ( actionResult )
************************************
************************************
[+] input: testCreateDatabase() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  Database database = new Database(); DataResult<Sql> database1 = databaseService.createDatabase(database); "<AssertPlaceHolder>"; } }
createDatabase(Database param);
[*] target: assertNotNull(database1)
[-] pred: org. junit. Assert. assertNotNull ( database1 )
************************************
************************************
[+] input: testModifyDatabase() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  DatabaseCreateParam databaseCreateParam = new DatabaseCreateParam(); databaseCreateParam.setName("test" + TestUtils.nextLong());  ActionResult actionResult = databaseService.modifyDatabase(databaseCreateParam); "<AssertPlaceHolder>";  } }
modifyDatabase( DatabaseCreateParam param) ;
[*] target: assertNotNull(actionResult)
[-] pred: org. junit. Assert. assertNotNull ( actionResult )
************************************
************************************
[+] input: testDeleteSchema() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  SchemaOperationParam operationParam = new SchemaOperationParam(); operationParam.setDatabaseName(dialectProperties.getDatabaseName()); operationParam.setSchemaName("test" + TestUtils.nextLong());  ActionResult actionResult = databaseService.deleteSchema(operationParam); "<AssertPlaceHolder>"; } }
deleteSchema(SchemaOperationParam param) ;
[*] target: assertNotNull(actionResult)
[-] pred: org. junit. Assert. assertNotNull ( actionResult )
************************************
************************************
[+] input: testCreateSchema() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  Schema schema = new Schema(); DataResult<Sql> result = databaseService.createSchema(schema); "<AssertPlaceHolder>"; } }
createSchema(Schema schema);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testModifySchema() { for (DialectProperties dialectProperties : dialectPropertiesList) { Long dataSourceId = TestUtils.nextLong(); Long consoleId = TestUtils.nextLong(); TestUtils.buildContext(dialectProperties, dataSourceId, consoleId);  SchemaOperationParam schemaOperationParam = new SchemaOperationParam(); schemaOperationParam.setDatabaseName(dialectProperties.getDatabaseName()); schemaOperationParam.setSchemaName("test" + TestUtils.nextLong()); schemaOperationParam.setNewSchemaName("test" + TestUtils.nextLong());  ActionResult actionResult = databaseService.modifySchema(schemaOperationParam); "<AssertPlaceHolder>"; } }
modifySchema( SchemaOperationParam request);
[*] target: assertNotNull(actionResult)
[-] pred: org. junit. Assert. assertNotNull ( actionResult )
************************************
************************************
[+] input: testPageQuery() { //        userLoginIdentity(true,5L); userLoginIdentity(false, 2L);   DataSourceAccessPageQueryParam queryParam = new DataSourceAccessPageQueryParam(); queryParam.setDataSourceId(TestUtils.nextLong()); //        queryParam.setAccessObjectType("TEAM"); queryParam.setAccessObjectType("USER"); queryParam.setAccessObjectId(TestUtils.nextLong()); queryParam.setPageNo(3); queryParam.setPageSize(5);  // Returns false by default queryParam.setEnableReturnCount(true);   DataSourceAccessSelector accessSelector = new DataSourceAccessSelector(); accessSelector.setAccessObject(true); accessSelector.setDataSource(true); accessSelector.setDataSourceSelector(new DataSourceSelector(true));  PageResult<DataSourceAccess> result = dataSourceAccessService.pageQuery(queryParam, accessSelector); "<AssertPlaceHolder>";  }
pageQuery(DataSourceAccessPageQueryParam param, DataSourceAccessSelector selector);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testComprehensivePageQuery() {  userLoginIdentity(false, 2L); //        userLoginIdentity(true,5L);  DataSourceAccessComprehensivePageQueryParam param = new DataSourceAccessComprehensivePageQueryParam(); param.setPageNo(1); param.setPageSize(10); param.setEnableReturnCount(true); param.setDataSourceId(TestUtils.nextLong()); param.setAccessObjectType("USER"); //        param.setAccessObjectType("TEAM"); param.setAccessObjectId(TestUtils.nextLong()); param.setUserOrTeamSearchKey("test"); param.setDataSourceSearchKey("m");  DataSourceAccessSelector selector = new DataSourceAccessSelector(); selector.setAccessObject(true); selector.setDataSource(true); selector.setDataSourceSelector(new DataSourceSelector(true));  PageResult<DataSourceAccess> result = dataSourceAccessService.comprehensivePageQuery(param, selector); "<AssertPlaceHolder>"; }
comprehensivePageQuery(DataSourceAccessComprehensivePageQueryParam param, DataSourceAccessSelector selector);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { ChatCompletionRequest request = ChatCompletionRequest.of("What's Java Language?"); request.setFunctionCall("hello_java"); String expected = """ { "messages" : [ { "role" : "user", "content" : "What's Java Language?" } ], "function_call" : { "name" : "hello_java" } }"""; String actual = GPTFunctionUtils.objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(request);  System.out.println(expected); System.out.println(actual); "<AssertPlaceHolder>"; }
setFunctionCall(Object functionCall) { if (functionCall.equals("auto") || functionCall.equals("none")) { this.functionCall = functionCall; } else if (functionCall instanceof String) { this.functionCall = Map.of("name", functionCall); } else { this.functionCall = functionCall; } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { // Arrange var bits = "0101"; // 5 var i = BitConverter.bitsToInt(bits);  // Act var bits2 = BitConverter.intToBits(i);   // Assert "<AssertPlaceHolder>";  }
intToBits(int value) { return intToBits(value, 0); }
[*] target: assertEquals(bits,bits2)
[-] pred: org. junit. Assert. assertEquals ( bits, bits2 )
************************************
************************************
[+] input: IOException { // Arrange var bits = "00011111"; // 31 var i = BitConverter.bitsToInt(bits);  // Act var bits2 = BitConverter.intToBits(i);   // Assert "<AssertPlaceHolder>";  }
intToBits(int value) { return intToBits(value, 0); }
[*] target: assertEquals(bits,bits2)
[-] pred: org. junit. Assert. assertEquals ( bits, bits2 )
************************************
************************************
[+] input: IOException { // Arrange var bits = "000111110001111100011111"; // 2039583 var i = BitConverter.bitsToInt(bits);  // Act var bits2 = BitConverter.intToBits(i);   // Assert "<AssertPlaceHolder>";  }
intToBits(int value) { return intToBits(value, 0); }
[*] target: assertEquals(bits,bits2)
[-] pred: org. junit. Assert. assertEquals ( bits, bits2 )
************************************
************************************
[+] input: IOException { // Arrange var compare = "HE"; var bits = BitConverter.alphaNumericStringToBits(compare);  // Act var str = BitConverter.bitsToAlphaNumericString(bits);  // Assert "<AssertPlaceHolder>";  }
bitsToAlphaNumericString(String value) { var builder = new StringBuilder(); var i = 0; while (i < value.length()) { if (value.length() - i == 6) { var bits6 = value.substring(i, i+6); i += 6; } else { var bits11 = value.substring(i, i+11); var charCombined = Integer.parseUnsignedInt(bits11, 2); var ch1 = charCombined / 45; var ch2 = charCombined % 45; builder.append(ALPHA_ENCODING_TO_CHAR[ch1]).append(ALPHA_ENCODING_TO_CHAR[ch2]); i += 11; } } return builder.toString(); }
[*] target: assertEquals(compare, str)
[-] pred: org. junit. Assert. assertEquals ( compare, str )
************************************
************************************
[+] input: equalComparisonTest() { SemVer testSemVer1 = new SemVer(0, 0, 0, "", ""); SemVer testSemVer2 = new SemVer(0, 0, 0, "", ""); int compareResult = testSemVer1.compareTo(testSemVer2); "<AssertPlaceHolder>"; }
compareTo(SemVer other) { if (other == null) { return 1; } if (major != other.major) { return Integer.compare(major, other.major); } if (minor != other.minor) { return Integer.compare(minor, other.minor); } if (patch != other.patch) { return Integer.compare(patch, other.patch); } if (preRelease == null && other.preRelease == null) { return 0; } if (preRelease == null) { return 1; } if (other.preRelease == null) { return -1; } return preRelease.compareTo(other.preRelease); }
[*] target: assertEquals(0, compareResult)
[-] pred: org. junit. Assert. assertEquals ( 0, compareResult )
************************************
************************************
[+] input: testMapToObjectNull() { Map<String, String> map = null; BranchDO branchDO = (BranchDO) BeanUtils.mapToObject(map, BranchDO.class); Assertions."<AssertPlaceHolder>"; }
mapToObject(Map<String, String> map, Class<?> clazz) { if (CollectionUtils.isEmpty(map)) { return null; } try { Object instance = clazz.newInstance(); Field[] fields = instance.getClass().getDeclaredFields(); for (Field field : fields) { int modifiers = field.getModifiers(); if (Modifier.isStatic(modifiers) || Modifier.isFinal(modifiers)) { continue; } boolean accessible = field.isAccessible(); field.setAccessible(true); Class<?> type = field.getType(); if (type == Date.class) { if (!StringUtils.isEmpty(map.get(field.getName()))) { field.set(instance, new Date(Long.valueOf(map.get(field.getName())))); } } else if (type == Long.class) { if (!StringUtils.isEmpty(map.get(field.getName()))) { field.set(instance, Long.valueOf(map.get(field.getName()))); } } else if (type == Integer.class) { if (!StringUtils.isEmpty(map.get(field.getName()))) { field.set(instance, Integer.valueOf(map.get(field.getName()))); } } else if (type == Double.class) { if (!StringUtils.isEmpty(map.get(field.getName()))) { field.set(instance, Double.valueOf(map.get(field.getName()))); } } else if (type == String.class) { if (!StringUtils.isEmpty(map.get(field.getName()))) { field.set(instance, map.get(field.getName())); } } field.setAccessible(accessible); } return instance; } catch (IllegalAccessException e) { throw new NotSupportYetException( "map to " + clazz.toString() + " failed:" + e.getMessage(), e); } catch (InstantiationException e) { throw new NotSupportYetException( "map to " + clazz.toString() + " failed:" + e.getMessage(), e); } }
[*] target: assertNull(branchDO)
[-] pred: org. junit. Assert. assertNull ( branchDO )
************************************
************************************
[+] input: testObjectToMapNull() { BranchDO branchDO = null; Map<String, String> map = BeanUtils.objectToMap(branchDO); Assertions."<AssertPlaceHolder>"; }
objectToMap(Object object) { if (object == null) { return null; } Map<String, String> map = new HashMap<>(16); Field[] fields = object.getClass().getDeclaredFields(); try { for (Field field : fields) { boolean accessible = field.isAccessible(); field.setAccessible(true); if (field.getType() == Date.class) { Date date = (Date) field.get(object); if (date != null) { map.put(field.getName(), String.valueOf(date.getTime())); } } else { map.put(field.getName(), field.get(object) == null ? "" : field.get(object).toString()); } field.setAccessible(accessible); } } catch (IllegalAccessException e) { throw new NotSupportYetException( "object " + object.getClass().toString() + " to map failed:" + e.getMessage()); } return map; }
[*] target: assertNull(map)
[-] pred: org. junit. Assert. assertNull ( map )
************************************
************************************
[+] input: run() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  // trigger data final TriggerParam triggerParam = new TriggerParam(); triggerParam.setJobId(1); triggerParam.setExecutorHandler("demoJobHandler"); triggerParam.setExecutorParams(null); triggerParam.setExecutorBlockStrategy(ExecutorBlockStrategyEnum.COVER_EARLY.name()); triggerParam.setGlueType(GlueTypeEnum.BEAN.name()); triggerParam.setGlueSource(null); triggerParam.setGlueUpdatetime(System.currentTimeMillis()); triggerParam.setLogId(1); triggerParam.setLogDateTime(System.currentTimeMillis());  // Act final ReturnT<String> retval = executorBiz.run(triggerParam);  // Assert result Assertions."<AssertPlaceHolder>"; }
run(TriggerParam triggerParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: getProductsByCategory_shouldReturnProductPage() { // Given Pageable pageable = PageRequest.of(0, 10); List<Product> productList = new ArrayList<>(List.of(new Product(), new Product())); Page<Product> productPage = new PageImpl<>(productList);  // When when(productRepository.findAllByCategory_Id(1L, pageable)).thenReturn(productPage); Page<Product> result = serviceTest.getProductsByCategory(1L, pageable);  // Then verify(productRepository).findAllByCategory_Id(1L, pageable); "<AssertPlaceHolder>"; }
getProductsByCategory(Long categoryId, Pageable pageable) { return productRepository.findAllByCategory_Id(categoryId, pageable); }
[*] target: assertEquals(productPage, result)
[-] pred: org. junit. Assert. assertEquals ( productPage, result )
************************************
************************************
[+] input: getById_shouldReturnCustomerById() { // Given Customer customer = new Customer(); customer.setId(1L);  when(customerRepository.findById(anyLong())).thenReturn(java.util.Optional.of(customer));  // When Customer result = serviceTest.getById(1L);  // Then verify(customerRepository).findById(1L); "<AssertPlaceHolder>"; }
getById(Long id) { return customerRepository.findById(id).orElseThrow(() -> new NotFoundException("Customer not found")); }
[*] target: assertEquals(customer, result)
[-] pred: org. junit. Assert. assertEquals ( customer, result )
************************************
************************************
[+] input: testAddMatrices() { Matrix a = new Matrix(2, 3, (index) -> index); Matrix b = new Matrix(2, 3, (index) -> index * 2); Matrix expected = a.apply((index, value) -> value + b.getData()[index]);  Matrix result = a.add(b);  "<AssertPlaceHolder>"; }
add(Matrix other) { // Überprüfen, ob die andere Matrix eine Spaltenmatrix ist, die als Bias verwendet werden kann if (this.cols != other.cols && other.cols != 1) { throw new IllegalArgumentException( "Für die Addition muss die zweite Matrix entweder dieselbe Größe haben oder eine Spaltenmatrix sein."); }  Matrix result = new Matrix(rows, cols); for (int row = 0; row < this.rows; row++) { for (int col = 0; col < this.cols; col++) { if (other.cols == 1) { // Addiere den Bias, wenn die zweite Matrix eine Spaltenmatrix ist result.data[row * cols + col] = this.data[row * cols + col] + other.data[row]; } else { // Normale elementweise Addition, wenn die zweite Matrix dieselbe Größe hat result.data[row * cols + col] = this.data[row * cols + col] + other.data[row * cols + col]; } } }  return result; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: shouldCalculateAverageColumn() { int rows = 3; int cols = 4; Matrix m = new Matrix(rows, cols, i -> 2 * i - 3); double averageIndex = (cols - 1) / 2.0;  Matrix expected = new Matrix(rows, 1); expected.modify((row, col, value) -> 2 * (row * cols + averageIndex) - 3);  Matrix result = m.averageColumn(); "<AssertPlaceHolder>";  }
averageColumn() { Matrix result = new Matrix(rows, 1); forEach((row, col, value) -> result.data[row] += value / cols); return result; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: right() { Either<String, Integer> stringIntegerEither = Either.right(5); "<AssertPlaceHolder>"; }
right(R1 right) { return new Either<>(null, right); }
[*] target: assertNotNull(stringIntegerEither)
[-] pred: org. junit. Assert. assertNotNull ( stringIntegerEither )
************************************
************************************
[+] input: GetInstance_returns_sameReference() { PubSubService reference1 = PubSubService.getInstance(); PubSubService reference2 = PubSubService.getInstance();  "<AssertPlaceHolder>"; }
getInstance() { return INSTANCE; }
[*] target: assertEquals(reference1, reference2)
[-] pred: org. junit. Assert. assertEquals ( reference1, reference2 )
************************************
************************************
[+] input: IOException { ImportObject.MemoryImport expected = new ImportObject.MemoryImport(WasmSectionUtils.ENV_MODULE_NAME, 24, false);  ImportObject.MemoryImport result = WasmSectionUtils.parseMemoryFromBinary( getTestWasmBytes(WASM_FILE_WITH_EXPORT));  "<AssertPlaceHolder>"; }
parseMemoryFromBinary(byte[] wasmBinary) { Module moduleWithSections = toModuleWithSections(wasmBinary, SectionId.IMPORT, SectionId.MEMORY, SectionId.EXPORT); Integer initialPagesLimit = null; boolean isShared = false;  // Per Runtime spec only one memory should be available for each module. if (isMemorySectionValid(moduleWithSections.memorySection()) && isExportSectionValid(moduleWithSections.exportSection())) { MemoryLimits limits = moduleWithSections.memorySection().getMemory(0).memoryLimits(); initialPagesLimit = limits.initialPages(); isShared = limits.shared(); } else if (moduleWithSections.importSection() != null) { Optional<Import> parsedMemoryImport = moduleWithSections.importSection().stream().filter(i -> i.name().equals(MEMORY_IMPORT_NAME)) .findFirst(); if (parsedMemoryImport.isPresent()) { MemoryLimits limits = ((MemoryImport) parsedMemoryImport.get()).limits(); initialPagesLimit = limits.initialPages(); isShared = limits.shared(); } }  return initialPagesLimit != null ? new ImportObject.MemoryImport(ENV_MODULE_NAME, initialPagesLimit, isShared) : null; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { ImportObject.MemoryImport expected = new ImportObject.MemoryImport(WasmSectionUtils.ENV_MODULE_NAME, 83, false);  ImportObject.MemoryImport result = WasmSectionUtils.parseMemoryFromBinary( getTestWasmBytes(WASM_FILE_WITH_IMPORT));  "<AssertPlaceHolder>"; }
parseMemoryFromBinary(byte[] wasmBinary) { Module moduleWithSections = toModuleWithSections(wasmBinary, SectionId.IMPORT, SectionId.MEMORY, SectionId.EXPORT); Integer initialPagesLimit = null; boolean isShared = false;  // Per Runtime spec only one memory should be available for each module. if (isMemorySectionValid(moduleWithSections.memorySection()) && isExportSectionValid(moduleWithSections.exportSection())) { MemoryLimits limits = moduleWithSections.memorySection().getMemory(0).memoryLimits(); initialPagesLimit = limits.initialPages(); isShared = limits.shared(); } else if (moduleWithSections.importSection() != null) { Optional<Import> parsedMemoryImport = moduleWithSections.importSection().stream().filter(i -> i.name().equals(MEMORY_IMPORT_NAME)) .findFirst(); if (parsedMemoryImport.isPresent()) { MemoryLimits limits = ((MemoryImport) parsedMemoryImport.get()).limits(); initialPagesLimit = limits.initialPages(); isShared = limits.shared(); } }  return initialPagesLimit != null ? new ImportObject.MemoryImport(ENV_MODULE_NAME, initialPagesLimit, isShared) : null; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: allocateWhenOrderHasNextPointerShouldReturnRuntimePointerToBlock() { int headerPointer = 134; int size = 12; int orderSize = 16; RuntimePointerSize expected = new RuntimePointerSize(headerPointer + HEADER_SIZE, size); when(orders.get(anyInt())).thenReturn(order); when(order.getValue()).thenReturn(ORDER_VALUE); when(order.getBlockSize()).thenReturn(orderSize); when(order.popFreeHeaderPointer(any())).thenReturn(Optional.of(headerPointer));  RuntimePointerSize result = freeingBumpHeapAllocator.allocate(size, memory);  "<AssertPlaceHolder>"; }
allocate(int size, Memory memory) { log.finer("Allocating memory... size=" + size); verifyMemorySize(memory); Order order = getOrderForSize(size); int headerPointer = nextFreeHeaderPointer(order, memory); writeOccupiedHeader(headerPointer, order.getValue(), memory); stats.allocated(order.getBlockSize() + HEADER_SIZE, bumper - originalHeapBase); log.finer("Allocated " + stats.getBytesAllocated() + " bytes successfully"); log.finer("Total Allocated Memory: " + stats.getBytesAllocatedSum().toString()); return new RuntimePointerSize(headerPointer + HEADER_SIZE, size);  }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: extAllocatorMallocVersion1() { int size = 123; int pointer = 777; RuntimePointerSize runtimePointerSize = mock(RuntimePointerSize.class); when(sharedMemory.allocate(size)).thenReturn(runtimePointerSize); when(runtimePointerSize.pointer()).thenReturn(pointer);  int result = allocatorHostFunctions.extAllocatorMallocVersion1(size);  "<AssertPlaceHolder>"; }
extAllocatorMallocVersion1(int size) { log.finest("extAllocatorMallocVersion1"); return sharedMemory.allocate(size).pointer();  }
[*] target: assertEquals(pointer, result)
[-] pred: org. junit. Assert. assertEquals ( pointer, result )
************************************
************************************
[+] input: extStorageExistsVersion1() { when(sharedMemory.readData(childStorageKeyPointer)).thenReturn(childStorageKeyBytes); when(sharedMemory.readData(keyPointer)).thenReturn(keyBytes); when(repository.getChildTrie(childStorageKey)).thenReturn(childTrieAccessor); when(childTrieAccessor.findStorageValue(key)).thenReturn(Optional.of(valueBytes));  int result = childStorageHostFunctions.extDefaultChildStorageExistsVersion1( childStorageKeyPointer, keyPointer);  "<AssertPlaceHolder>"; }
extDefaultChildStorageExistsVersion1(RuntimePointerSize childStorageKeyPointer, RuntimePointerSize keyPointer) { log.fine("extDefaultChildStorageExistsVersion1");  Nibbles childStorageKey = Nibbles.fromBytes(sharedMemory.readData(childStorageKeyPointer)); Nibbles key = Nibbles.fromBytes(sharedMemory.readData(keyPointer));  TrieAccessor childTrie = trieAccessor.getChildTrie(childStorageKey); return childTrie.findStorageValue(key).isPresent() ? 1 : 0; }
[*] target: assertEquals(1, result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: extStorageExistsVersion1WhenNonExistent() { when(sharedMemory.readData(childStorageKeyPointer)).thenReturn(childStorageKeyBytes); when(sharedMemory.readData(keyPointer)).thenReturn(keyBytes); when(repository.getChildTrie(childStorageKey)).thenReturn(childTrieAccessor); when(childTrieAccessor.findStorageValue(key)).thenReturn(Optional.empty());  int result = childStorageHostFunctions .extDefaultChildStorageExistsVersion1(childStorageKeyPointer, keyPointer);  "<AssertPlaceHolder>"; }
extDefaultChildStorageExistsVersion1(RuntimePointerSize childStorageKeyPointer, RuntimePointerSize keyPointer) { log.fine("extDefaultChildStorageExistsVersion1");  Nibbles childStorageKey = Nibbles.fromBytes(sharedMemory.readData(childStorageKeyPointer)); Nibbles key = Nibbles.fromBytes(sharedMemory.readData(keyPointer));  TrieAccessor childTrie = trieAccessor.getChildTrie(childStorageKey); return childTrie.findStorageValue(key).isPresent() ? 1 : 0; }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 0, result )
************************************
************************************
[+] input: testGetNextKey() { Nibbles prefix = Nibbles.fromBytes("nextKe".getBytes()); Nibbles actualKey = Nibbles.fromBytes("nextKey".getBytes());  // Setup a mock TrieNodeData that represents the next key TrieNodeData nextKeyNode = new TrieNodeData( false, actualKey, new ArrayList<>(), "nextValue".getBytes(), new byte[0], (byte) 0);  // Assuming the database returns the mock TrieNodeData for the next key when(db.find(anyString())).thenReturn(Optional.of(nextKeyNode));  // Action byte[] blockStateRoot = Hash256.from(ROOT_HASH).getBytes(); Nibbles result = trieStorage.getNextKeyByMerkleValue(blockStateRoot, prefix);  // Assert "<AssertPlaceHolder>"; }
getNextKeyByMerkleValue(byte[] merkleValue, Nibbles prefix) { TrieNodeData rootNode = getTrieNodeFromMerkleValue(merkleValue); if (rootNode == null) { return null; }  return findNextKey(rootNode, prefix); }
[*] target: assertEquals(actualKey, result)
[-] pred: org. junit. Assert. assertEquals ( actualKey, result )
************************************
************************************
[+] input: testIteratorOverElements() { Slab<String> slab = new Slab<>(); List<String> addedElements = new ArrayList<>();  addedElements.add("test1"); slab.add("test1"); addedElements.add("test2"); slab.add("test2");  slab.remove(0); addedElements.remove(0);  List<String> iteratedElements = new ArrayList<>(); for (Pair<Integer, String> pair : slab) { iteratedElements.add(pair.getValue1()); }  "<AssertPlaceHolder>"; }
add(@NotNull T element) { int index; if (freeIndices.isEmpty()) { index = newIndex; storage.add(element); newIndex++; } else { index = freeIndices.poll(); storage.set(index, element); } size++; return index; }
[*] target: assertEquals(addedElements, iteratedElements)
[-] pred: org. junit. Assert. assertEquals ( addedElements, iteratedElements )
************************************
************************************
[+] input: generateSignVerify() { Pair<PrivKey, PubKey> keyPair = EcdsaUtils.generateKeyPair(); byte[] signed = EcdsaUtils.signMessage(keyPair.getFirst().raw(), hashedMessage);  VerifySignature signature = new VerifySignature(signed, hashedMessage, keyPair.getSecond().raw(), Key.ECDSA); boolean verified = EcdsaUtils.verifySignature(signature);  "<AssertPlaceHolder>"; }
verifySignature(final VerifySignature sig) { if (sig.getPublicKeyData() == null) return false; byte[] publicKey = recoverPublicKeyFromSignature(sig.getSignatureData(), sig.getMessageData(), true);  return Arrays.equals(publicKey, sig.getPublicKeyData()); }
[*] target: assertTrue(verified)
[-] pred: org. junit. Assert. assertTrue ( verified )
************************************
************************************
[+] input: generateSignVerify() { Ed25519PrivateKey privKey = Ed25519Utils.generateKeyPair();  byte[] signed = Ed25519Utils.signMessage(privKey.raw(), hashedMessage);  VerifySignature signature = new VerifySignature(signed, hashedMessage, privKey.publicKey().raw(), Key.ED25519); boolean verified = Ed25519Utils.verifySignature(signature);  "<AssertPlaceHolder>"; }
verifySignature(final VerifySignature signature) { if (signature.getPublicKeyData() == null) return false; PubKey pubKey = Ed25519Kt.unmarshalEd25519PublicKey(signature.getPublicKeyData()); return pubKey.verify(signature.getMessageData(), signature.getSignatureData()); }
[*] target: assertTrue(verified)
[-] pred: org. junit. Assert. assertTrue ( verified )
************************************
************************************
[+] input: generateSignVerify() { Schnorrkel.KeyPair keyPair = Sr25519Utils.generateKeyPair();  byte[] signed = Sr25519Utils.signMessage(keyPair.getPublicKey(), keyPair.getSecretKey(), hashedMessage);  VerifySignature signature = new VerifySignature(signed, hashedMessage, keyPair.getPublicKey(), Key.ED25519); boolean verified = Sr25519Utils.verifySignature(signature);  "<AssertPlaceHolder>"; }
verifySignature(final VerifySignature signature) { try { Schnorrkel schnorrkel = Schnorrkel.getInstance(); Schnorrkel.PublicKey publicKey = new Schnorrkel.PublicKey(signature.getPublicKeyData()); return schnorrkel.verify(signature.getSignatureData(), signature.getMessageData(), publicKey); } catch (SchnorrkelException e) { log.log(Level.WARNING, e.getMessage(), e); return false; } }
[*] target: assertTrue(verified)
[-] pred: org. junit. Assert. assertTrue ( verified )
************************************
************************************
[+] input: testDeletion() { boolean deleted = this.kdTree.delete("2"); Assertions."<AssertPlaceHolder>"; }
delete(T id) { return Optional.ofNullable(this.map.get(id)).map(node -> { deleteNode(node); this.map.remove(id); return true; }).orElse(false); }
[*] target: assertTrue(deleted)
[-] pred: org. junit. Assert. assertTrue ( deleted )
************************************
************************************
[+] input: InterruptedException { Timer timer = getTimer("a.timer"); for (int i = 0; i < 100; i++) { Timer.Context context = timer.time(); try { // no ops } finally { context.stop(); } } long v = metricsSystem .getMetricRegistry() .timer(TEST_METRICS_SOURCE + ".a.timer") .getSnapshot() .size(); // it's hard to check timer values, we just check the num Assertions."<AssertPlaceHolder>"; }
getMetricRegistry() { return metricRegistry; }
[*] target: assertEquals(100, v)
[-] pred: org. junit. Assert. assertEquals ( 100, v )
************************************
************************************
[+] input: getUiSchemaForAdapter_whenNoneIsPresent_thenBackoffTpDefault() { ProtocolAdapterInformation protocolAdapterInformation = mock(); final JsonNode uiSchemaForAdapter = ProtocolAdapterApiUtils.getUiSchemaForAdapter(new ObjectMapper(), protocolAdapterInformation); "<AssertPlaceHolder>"; }
getUiSchemaForAdapter( @NotNull ObjectMapper objectMapper, @NotNull ProtocolAdapterInformation info) { final String uiSchemaAsString = info.getUiSchema(); if (uiSchemaAsString != null) { try { return objectMapper.readTree(uiSchemaAsString); } catch (JsonProcessingException e) { LOG.warn("Ui schema for adapter '{}' is not parsable, the default zu schema will be applied. ", info.getDisplayName(), e); // fall through to parsing the DEFAULT SCHEMA } }  try { return objectMapper.readTree(Objects.requireNonNullElse(uiSchemaAsString, DEFAULT_SCHEMA)); } catch (JsonProcessingException e) { LOG.error("Exception during parsing of default zu schema: ", e); // this should never happen as we control the input (default schema) throw new RuntimeException(e); } }
[*] target: assertNotNull(uiSchemaForAdapter)
[-] pred: org. junit. Assert. assertNotNull ( uiSchemaForAdapter )
************************************
************************************
[+] input: testSimplePartitionedTable() { StructType tableSchema = getSchemaWithFields(Arrays.asList("id", "firstName", "gender", "birthDate")); StructType partitionSchema = getSchemaWithFields(Arrays.asList("gender")); InternalSchema internalSchema = deltaSchemaExtractor.toInternalSchema(tableSchema); List<InternalPartitionField> expectedInternalPartitionFields = Arrays.asList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("gender") .schema( InternalSchema.builder() .name("string") .dataType(InternalType.STRING) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build()); List<InternalPartitionField> internalPartitionFields = deltaPartitionExtractor.convertFromDeltaPartitionFormat(internalSchema, partitionSchema); "<AssertPlaceHolder>"; }
convertFromDeltaPartitionFormat( InternalSchema internalSchema, StructType partitionSchema) { if (partitionSchema.isEmpty()) { return Collections.emptyList(); } return getInternalPartitionFields(partitionSchema, internalSchema); }
[*] target: assertEquals(expectedInternalPartitionFields, internalPartitionFields)
[-] pred: org. junit. Assert. assertEquals ( expectedInternalPartitionFields, internalPartitionFields )
************************************
************************************
[+] input: yearAndSimpleCombinedPartitionedGeneratedColumnsTable() { StructType tableSchema = getSchemaWithFields(Arrays.asList("id", "firstName", "gender", "birthDate", "yearOfBirth")); StructType partitionSchema = getSchemaWithFields(Arrays.asList("yearOfBirth", "id")); InternalSchema internalSchema = deltaSchemaExtractor.toInternalSchema(tableSchema); List<InternalPartitionField> expectedInternalPartitionFields = Arrays.asList( InternalPartitionField.builder() .sourceField( InternalField.builder().name("birthDate").schema(TIMESTAMP_SCHEMA).build()) .transformType(PartitionTransformType.YEAR) .partitionFieldNames(Collections.singletonList("yearOfBirth")) .build(), InternalPartitionField.builder() .sourceField( InternalField.builder() .name("id") .schema( InternalSchema.builder() .name("integer") .dataType(InternalType.INT) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build()); List<InternalPartitionField> internalPartitionFields = deltaPartitionExtractor.convertFromDeltaPartitionFormat(internalSchema, partitionSchema); "<AssertPlaceHolder>"; }
convertFromDeltaPartitionFormat( InternalSchema internalSchema, StructType partitionSchema) { if (partitionSchema.isEmpty()) { return Collections.emptyList(); } return getInternalPartitionFields(partitionSchema, internalSchema); }
[*] target: assertEquals(expectedInternalPartitionFields, internalPartitionFields)
[-] pred: org. junit. Assert. assertEquals ( expectedInternalPartitionFields, internalPartitionFields )
************************************
************************************
[+] input: testCombinationOfPlainAndGeneratedColumns() { StructType tableSchema = getSchemaWithFields(Arrays.asList("id", "firstName", "gender", "birthDate", "dateFmt")); StructType partitionSchema = getSchemaWithFields(Arrays.asList("id", "dateFmt", "gender", "dateOfBirth")); InternalSchema internalSchema = deltaSchemaExtractor.toInternalSchema(tableSchema); List<InternalPartitionField> expectedInternalPartitionFields = Arrays.asList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("id") .schema( InternalSchema.builder() .name("integer") .dataType(InternalType.INT) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build(), InternalPartitionField.builder() .sourceField( InternalField.builder().name("birthDate").schema(TIMESTAMP_SCHEMA).build()) .transformType(PartitionTransformType.HOUR) .partitionFieldNames(Collections.singletonList("dateFmt")) .build(), InternalPartitionField.builder() .sourceField( InternalField.builder() .name("gender") .schema( InternalSchema.builder() .name("string") .dataType(InternalType.STRING) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build(), InternalPartitionField.builder() .sourceField( InternalField.builder().name("birthDate").schema(TIMESTAMP_SCHEMA).build()) .transformType(PartitionTransformType.DAY) .partitionFieldNames(Collections.singletonList("dateOfBirth")) .build()); List<InternalPartitionField> internalPartitionFields = deltaPartitionExtractor.convertFromDeltaPartitionFormat(internalSchema, partitionSchema); "<AssertPlaceHolder>"; }
convertFromDeltaPartitionFormat( InternalSchema internalSchema, StructType partitionSchema) { if (partitionSchema.isEmpty()) { return Collections.emptyList(); } return getInternalPartitionFields(partitionSchema, internalSchema); }
[*] target: assertEquals(expectedInternalPartitionFields, internalPartitionFields)
[-] pred: org. junit. Assert. assertEquals ( expectedInternalPartitionFields, internalPartitionFields )
************************************
************************************
[+] input: testSingleColumn() { InternalPartitionField column = InternalPartitionField.builder() .sourceField( InternalField.builder() .name("column1") .schema( InternalSchema.builder() .name("string") .dataType(InternalType.STRING) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build();  List<PartitionValue> expected = Collections.singletonList( PartitionValue.builder().partitionField(column).range(Range.scalar("foo")).build());  List<PartitionValue> actual = new HudiPartitionValuesExtractor(Collections.emptyMap()) .extractPartitionValues(Collections.singletonList(column), "foo"); Assertions."<AssertPlaceHolder>"; }
extractPartitionValues( List<InternalPartitionField> partitionColumns, String partitionPath) { if (partitionColumns == null) { return Collections.emptyList(); } int totalNumberOfPartitions = partitionColumns.size(); List<PartitionValue> result = new ArrayList<>(totalNumberOfPartitions); String remainingPartitionPath = partitionPath; for (InternalPartitionField partitionField : partitionColumns) { String sourceFieldName = partitionField.getSourceField().getName(); if (remainingPartitionPath.startsWith(sourceFieldName + "=")) { // Strip off hive style partitioning remainingPartitionPath = remainingPartitionPath.substring(sourceFieldName.length() + 1); } // handle hive default partition case PartialResult valueAndRemainingPath; if (remainingPartitionPath.startsWith(HIVE_DEFAULT_PARTITION)) { String remaining = remainingPartitionPath.length() > HIVE_DEFAULT_PARTITION.length() ? remainingPartitionPath.substring(HIVE_DEFAULT_PARTITION.length() + 1) : ""; valueAndRemainingPath = new PartialResult(null, remaining); } else { valueAndRemainingPath = parsePartitionPath(partitionField, remainingPartitionPath, totalNumberOfPartitions); } result.add( PartitionValue.builder() .partitionField(partitionField) .range(Range.scalar(valueAndRemainingPath.getValue())) .build()); remainingPartitionPath = valueAndRemainingPath.getRemainingPath(); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testSingleColumnValueWithSlashes() { InternalPartitionField column = InternalPartitionField.builder() .sourceField( InternalField.builder() .name("column1") .schema( InternalSchema.builder() .name("string") .dataType(InternalType.STRING) .build()) .build()) .transformType(PartitionTransformType.VALUE) .build();  List<PartitionValue> expected = Collections.singletonList( PartitionValue.builder().partitionField(column).range(Range.scalar("foo/bar")).build());  List<PartitionValue> actual = new HudiPartitionValuesExtractor(Collections.emptyMap()) .extractPartitionValues(Collections.singletonList(column), "foo/bar"); Assertions."<AssertPlaceHolder>"; }
extractPartitionValues( List<InternalPartitionField> partitionColumns, String partitionPath) { if (partitionColumns == null) { return Collections.emptyList(); } int totalNumberOfPartitions = partitionColumns.size(); List<PartitionValue> result = new ArrayList<>(totalNumberOfPartitions); String remainingPartitionPath = partitionPath; for (InternalPartitionField partitionField : partitionColumns) { String sourceFieldName = partitionField.getSourceField().getName(); if (remainingPartitionPath.startsWith(sourceFieldName + "=")) { // Strip off hive style partitioning remainingPartitionPath = remainingPartitionPath.substring(sourceFieldName.length() + 1); } // handle hive default partition case PartialResult valueAndRemainingPath; if (remainingPartitionPath.startsWith(HIVE_DEFAULT_PARTITION)) { String remaining = remainingPartitionPath.length() > HIVE_DEFAULT_PARTITION.length() ? remainingPartitionPath.substring(HIVE_DEFAULT_PARTITION.length() + 1) : ""; valueAndRemainingPath = new PartialResult(null, remaining); } else { valueAndRemainingPath = parsePartitionPath(partitionField, remainingPartitionPath, totalNumberOfPartitions); } result.add( PartitionValue.builder() .partitionField(partitionField) .range(Range.scalar(valueAndRemainingPath.getValue())) .build()); remainingPartitionPath = valueAndRemainingPath.getRemainingPath(); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testUnpartitioned() { Schema icebergSchema = new Schema(Types.NestedField.required(0, "timestamp", Types.TimestampType.withZone())); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(null, icebergSchema); PartitionSpec expected = PartitionSpec.unpartitioned(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testMultiplePartitions() { List<InternalPartitionField> partitionFieldList = Arrays.asList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("timestamp_hour") .schema(InternalSchema.builder().dataType(InternalType.TIMESTAMP).build()) .build()) .transformType(PartitionTransformType.HOUR) .build(), InternalPartitionField.builder() .sourceField( InternalField.builder() .name("string_field") .schema(InternalSchema.builder().dataType(InternalType.STRING).build()) .build()) .transformType(PartitionTransformType.VALUE) .build()); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, TEST_SCHEMA); PartitionSpec expected = PartitionSpec.builderFor(TEST_SCHEMA) .hour("timestamp_hour") .identity("string_field") .build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testYearPartitioning() { List<InternalPartitionField> partitionFieldList = Collections.singletonList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("timestamp_year") .schema( InternalSchema.builder().dataType(InternalType.TIMESTAMP_NTZ).build()) .build()) .transformType(PartitionTransformType.YEAR) .build()); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, TEST_SCHEMA); PartitionSpec expected = PartitionSpec.builderFor(TEST_SCHEMA).year("timestamp_year").build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testMonthPartitioning() { List<InternalPartitionField> partitionFieldList = Collections.singletonList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("timestamp_month") .schema( InternalSchema.builder().dataType(InternalType.TIMESTAMP_NTZ).build()) .build()) .transformType(PartitionTransformType.MONTH) .build()); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, TEST_SCHEMA); PartitionSpec expected = PartitionSpec.builderFor(TEST_SCHEMA).month("timestamp_month").build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testDayPartitioning() { List<InternalPartitionField> partitionFieldList = Collections.singletonList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("timestamp_day") .schema( InternalSchema.builder().dataType(InternalType.TIMESTAMP_NTZ).build()) .build()) .transformType(PartitionTransformType.DAY) .build()); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, TEST_SCHEMA); PartitionSpec expected = PartitionSpec.builderFor(TEST_SCHEMA).day("timestamp_day").build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testHourPartitioning() { List<InternalPartitionField> partitionFieldList = Collections.singletonList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("timestamp_hour") .schema( InternalSchema.builder().dataType(InternalType.TIMESTAMP_NTZ).build()) .build()) .transformType(PartitionTransformType.HOUR) .build()); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, TEST_SCHEMA); PartitionSpec expected = PartitionSpec.builderFor(TEST_SCHEMA).hour("timestamp_hour").build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testNestedPartitionField() { List<InternalPartitionField> partitionFieldList = Collections.singletonList( InternalPartitionField.builder() .sourceField( InternalField.builder() .name("nested") .parentPath("data") .schema(InternalSchema.builder().dataType(InternalType.STRING).build()) .build()) .transformType(PartitionTransformType.VALUE) .build()); Schema icebergSchema = new Schema( Types.NestedField.required( 0, "data", Types.StructType.of( Types.NestedField.required(1, "nested", Types.StringType.get())))); PartitionSpec actual = IcebergPartitionSpecExtractor.getInstance().toIceberg(partitionFieldList, icebergSchema); PartitionSpec expected = PartitionSpec.builderFor(icebergSchema).identity("data.nested").build(); Assertions."<AssertPlaceHolder>"; }
toIceberg(List<InternalPartitionField> partitionFields, Schema tableSchema) { if (partitionFields == null || partitionFields.isEmpty()) { return PartitionSpec.unpartitioned(); } PartitionSpec.Builder partitionSpecBuilder = PartitionSpec.builderFor(tableSchema); for (InternalPartitionField partitioningField : partitionFields) { String fieldPath = partitioningField.getSourceField().getPath(); switch (partitioningField.getTransformType()) { case YEAR: partitionSpecBuilder.year(fieldPath); break; case MONTH: partitionSpecBuilder.month(fieldPath); break; case DAY: partitionSpecBuilder.day(fieldPath); break; case HOUR: partitionSpecBuilder.hour(fieldPath); break; case VALUE: partitionSpecBuilder.identity(fieldPath); break; default: throw new IllegalArgumentException( "Unsupported type: " + partitioningField.getTransformType()); } } return partitionSpecBuilder.build(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: catalogGetTable() { String catalogName = "catalog1"; StubCatalog.registerMock(catalogName, mockCatalog); IcebergCatalogConfig catalogConfig = IcebergCatalogConfig.builder() .catalogImpl(StubCatalog.class.getName()) .catalogName(catalogName) .catalogOptions(OPTIONS) .build(); Table mockTable = mock(Table.class); when(mockCatalog.loadTable(IDENTIFIER)).thenReturn(mockTable);  IcebergTableManager tableManager = IcebergTableManager.of(CONFIGURATION); Table actual = tableManager.getTable(catalogConfig, IDENTIFIER, BASE_PATH); "<AssertPlaceHolder>"; verify(mockCatalog).initialize(catalogName, OPTIONS); }
getTable( IcebergCatalogConfig catalogConfig, TableIdentifier tableIdentifier, String basePath) { return getCatalog(catalogConfig) .map(catalog -> catalog.loadTable(tableIdentifier)) .orElseGet(() -> getHadoopTables().load(basePath)); }
[*] target: assertEquals(mockTable, actual)
[-] pred: org. junit. Assert. assertEquals ( mockTable, actual )
************************************
************************************
[+] input: catalogGetOrCreateWithExistingTable() { String catalogName = "catalog2"; StubCatalog.registerMock(catalogName, mockCatalog); IcebergCatalogConfig catalogConfig = IcebergCatalogConfig.builder() .catalogImpl(StubCatalog.class.getName()) .catalogName(catalogName) .catalogOptions(OPTIONS) .build(); Table mockTable = mock(Table.class); when(mockCatalog.tableExists(IDENTIFIER)).thenReturn(true); when(mockCatalog.loadTable(IDENTIFIER)).thenReturn(mockTable);  IcebergTableManager tableManager = IcebergTableManager.of(CONFIGURATION); Schema schema = new Schema(); PartitionSpec partitionSpec = PartitionSpec.unpartitioned(); Table actual = tableManager.getOrCreateTable(catalogConfig, IDENTIFIER, BASE_PATH, schema, partitionSpec); "<AssertPlaceHolder>"; verify(mockCatalog).initialize(catalogName, OPTIONS); verify(mockCatalog, never()).createTable(any(), any(), any(), any()); }
getOrCreateTable( IcebergCatalogConfig catalogConfig, TableIdentifier tableIdentifier, String basePath, Schema schema, PartitionSpec partitionSpec) { if (tableExists(catalogConfig, tableIdentifier, basePath)) { return getTable(catalogConfig, tableIdentifier, basePath); } else { try { return getCatalog(catalogConfig) .map( catalog -> catalog.createTable( tableIdentifier, schema, partitionSpec, basePath, getDefaultMappingProperties(schema))) .orElseGet( () -> getHadoopTables() .create( schema, partitionSpec, SortOrder.unsorted(), getDefaultMappingProperties(schema), basePath)); } catch (AlreadyExistsException ex) { log.info("Table {} not created since it already exists", tableIdentifier); return getTable(catalogConfig, tableIdentifier, basePath); } } }
[*] target: assertEquals(mockTable, actual)
[-] pred: org. junit. Assert. assertEquals ( mockTable, actual )
************************************
************************************
[+] input: catalogGetOrCreateWithRaceConditionOnCreation() { String catalogName = "catalog4"; StubCatalog.registerMock(catalogName, mockCatalog); IcebergCatalogConfig catalogConfig = IcebergCatalogConfig.builder() .catalogImpl(StubCatalog.class.getName()) .catalogName(catalogName) .catalogOptions(OPTIONS) .build(); Table mockTable = mock(Table.class); when(mockCatalog.tableExists(IDENTIFIER)).thenReturn(false); Schema schema = new Schema(); PartitionSpec partitionSpec = PartitionSpec.unpartitioned(); when(mockCatalog.createTable( IDENTIFIER, schema, partitionSpec, BASE_PATH, Collections.singletonMap( TableProperties.DEFAULT_NAME_MAPPING, NameMappingParser.toJson(MappingUtil.create(schema))))) .thenThrow(new AlreadyExistsException("Table already exists")); when(mockCatalog.loadTable(IDENTIFIER)).thenReturn(mockTable);  IcebergTableManager tableManager = IcebergTableManager.of(CONFIGURATION);  Table actual = tableManager.getOrCreateTable(catalogConfig, IDENTIFIER, BASE_PATH, schema, partitionSpec); "<AssertPlaceHolder>"; verify(mockCatalog).initialize(catalogName, OPTIONS); }
getOrCreateTable( IcebergCatalogConfig catalogConfig, TableIdentifier tableIdentifier, String basePath, Schema schema, PartitionSpec partitionSpec) { if (tableExists(catalogConfig, tableIdentifier, basePath)) { return getTable(catalogConfig, tableIdentifier, basePath); } else { try { return getCatalog(catalogConfig) .map( catalog -> catalog.createTable( tableIdentifier, schema, partitionSpec, basePath, getDefaultMappingProperties(schema))) .orElseGet( () -> getHadoopTables() .create( schema, partitionSpec, SortOrder.unsorted(), getDefaultMappingProperties(schema), basePath)); } catch (AlreadyExistsException ex) { log.info("Table {} not created since it already exists", tableIdentifier); return getTable(catalogConfig, tableIdentifier, basePath); } } }
[*] target: assertEquals(mockTable, actual)
[-] pred: org. junit. Assert. assertEquals ( mockTable, actual )
************************************
************************************
[+] input: testIdTrackingAddMetaFields() { // create initial schema with a meta field manually specified Schema initial = Schema.createRecord( "test1", null, "hudi", false, Arrays.asList( new Schema.Field("_hoodie_commit_time", Schema.create(Schema.Type.STRING)), new Schema.Field("field1", Schema.create(Schema.Type.STRING)))); Schema initialWithIdTracking = idTracker.addIdTracking(initial, Option.empty(), false); // add all meta fields and ensure IDs are properly assigned Schema withMetaFields = Schema.createRecord( "test2", null, "hudi", false, Arrays.asList( new Schema.Field("_hoodie_commit_time", Schema.create(Schema.Type.STRING)), new Schema.Field("field1", Schema.create(Schema.Type.STRING)))); Schema withMetaFieldsAndIdTracking = idTracker.addIdTracking(withMetaFields, Option.of(initialWithIdTracking), true); IdTracking actual = idTracker.getIdTracking(withMetaFieldsAndIdTracking).get(); IdTracking expected = new IdTracking( Arrays.asList( new IdMapping("_hoodie_commit_time", 1), new IdMapping("field1", 2), new IdMapping("_hoodie_commit_seqno", 3), new IdMapping("_hoodie_record_key", 4), new IdMapping("_hoodie_partition_path", 5), new IdMapping("_hoodie_file_name", 6)), 6); "<AssertPlaceHolder>"; }
getIdTracking(Schema schema) { try { Object propValue = schema.getObjectProp(ID_TRACKING); if (propValue == null) { return Option.empty(); } return Option.of( ID_TRACKING_READER.readValue((JsonNode) OBJECT_MAPPER.valueToTree(propValue))); } catch (IOException ex) { throw new UncheckedIOException(ex); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testPrepare() { // Arrange Map<Attribute, String> attributes = new HashMap<>(); attributes.put(Attributes.FGA_CLIENT_REQUEST_CLIENT_ID, "client-id-value"); Metric metric = mock(Metric.class);  TelemetryConfiguration telemetryConfiguration = mock(TelemetryConfiguration.class); Map<Metric, Map<Attribute, Optional<Object>>> metricsMap = new HashMap<>(); Map<Attribute, Optional<Object>> attributeMap = new HashMap<>(); attributeMap.put(Attributes.FGA_CLIENT_REQUEST_CLIENT_ID, Optional.of("config-value")); metricsMap.put(metric, attributeMap); when(telemetryConfiguration.metrics()).thenReturn(metricsMap);  Configuration configuration = mock(Configuration.class); when(configuration.getTelemetryConfiguration()).thenReturn(telemetryConfiguration);  // Act io.opentelemetry.api.common.Attributes result = Attributes.prepare(attributes, metric, configuration);  // Assert AttributesBuilder builder = io.opentelemetry.api.common.Attributes.builder(); builder.put(AttributeKey.stringKey(Attributes.FGA_CLIENT_REQUEST_CLIENT_ID.getName()), "client-id-value"); io.opentelemetry.api.common.Attributes expected = builder.build();  "<AssertPlaceHolder>"; }
prepare( Map<Attribute, String> attributes, Metric metric, Configuration configuration) { if (attributes == null || attributes.isEmpty() || configuration == null || configuration.getTelemetryConfiguration() == null || configuration.getTelemetryConfiguration().metrics() == null || configuration.getTelemetryConfiguration().metrics().isEmpty() || !configuration.getTelemetryConfiguration().metrics().containsKey(metric) || configuration .getTelemetryConfiguration() .metrics() .get(metric) .isEmpty()) { return io.opentelemetry.api.common.Attributes.empty(); }  Map<Attribute, Optional<Object>> configAllowedAttributes = configuration.getTelemetryConfiguration().metrics().get(metric);  io.opentelemetry.api.common.AttributesBuilder builder = io.opentelemetry.api.common.Attributes.builder();  for (Map.Entry<Attribute, Optional<Object>> configAllowedAttr : configAllowedAttributes.entrySet()) { Attribute attr = configAllowedAttr.getKey();  if (!attributes.containsKey(attr)) { continue; }  String attrVal = attributes.getOrDefault(attr, "");  if (!isNullOrWhitespace(attrVal)) { builder.put(AttributeKey.stringKey(attr.getName()), attrVal); } }  return builder.build(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testFromHttpResponse() { // Arrange HttpResponse<?> response = mock(HttpResponse.class); HttpHeaders headers = mock(HttpHeaders.class); when(response.headers()).thenReturn(headers); when(headers.firstValue("openfga-authorization-model-id")).thenReturn(Optional.of("model-id-value")); when(response.statusCode()).thenReturn(200);  Credentials credentials = mock(Credentials.class); ClientCredentials clientCredentials = mock(ClientCredentials.class); when(credentials.getCredentialsMethod()).thenReturn(CredentialsMethod.CLIENT_CREDENTIALS); when(credentials.getClientCredentials()).thenReturn(clientCredentials); when(clientCredentials.getClientId()).thenReturn("client-id-value");  // Act Map<Attribute, String> result = Attributes.fromHttpResponse(response, credentials);  // Assert Map<Attribute, String> expected = new HashMap<>(); expected.put(Attributes.HTTP_RESPONSE_STATUS_CODE, "200"); expected.put(Attributes.FGA_CLIENT_RESPONSE_MODEL_ID, "model-id-value"); expected.put(Attributes.FGA_CLIENT_REQUEST_CLIENT_ID, "client-id-value");  "<AssertPlaceHolder>"; }
fromHttpResponse(HttpResponse<?> response, Credentials credentials) { Map<Attribute, String> attributes = new HashMap<>();  if (response != null) { attributes.put(HTTP_RESPONSE_STATUS_CODE, String.valueOf(response.statusCode()));  String responseModelId = response.headers() .firstValue("openfga-authorization-model-id") .orElse(null);  if (!isNullOrWhitespace(responseModelId)) { attributes.put(FGA_CLIENT_RESPONSE_MODEL_ID, responseModelId); } }  if (credentials != null && credentials.getCredentialsMethod() == CredentialsMethod.CLIENT_CREDENTIALS) { if (!isNullOrWhitespace(credentials.getClientCredentials().getClientId())) { attributes.put( FGA_CLIENT_REQUEST_CLIENT_ID, credentials.getClientCredentials().getClientId()); } }  return attributes; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testFromApiResponse() { // Arrange ApiResponse<?> response = mock(ApiResponse.class); Map<String, List<String>> headers = new HashMap<>(); headers.put("openfga-authorization-model-id", Collections.singletonList("model-id-value")); when(response.getHeaders()).thenReturn(headers); when(response.getStatusCode()).thenReturn(200);  Credentials credentials = mock(Credentials.class); ClientCredentials clientCredentials = mock(ClientCredentials.class); when(credentials.getCredentialsMethod()).thenReturn(CredentialsMethod.CLIENT_CREDENTIALS); when(credentials.getClientCredentials()).thenReturn(clientCredentials); when(clientCredentials.getClientId()).thenReturn("client-id-value");  // Act Map<Attribute, String> result = Attributes.fromApiResponse(response, credentials);  // Assert Map<Attribute, String> expected = new HashMap<>(); expected.put(Attributes.HTTP_RESPONSE_STATUS_CODE, "200"); expected.put(Attributes.FGA_CLIENT_RESPONSE_MODEL_ID, "model-id-value"); expected.put(Attributes.FGA_CLIENT_REQUEST_CLIENT_ID, "client-id-value");  "<AssertPlaceHolder>"; }
fromApiResponse(ApiResponse<?> response, Credentials credentials) { Map<Attribute, String> attributes = new HashMap<>();  if (response != null) { attributes.put(HTTP_RESPONSE_STATUS_CODE, String.valueOf(response.getStatusCode()));  List<String> responseModelIdList = response.getHeaders().getOrDefault("openfga-authorization-model-id", null); String responseModelId = responseModelIdList != null ? responseModelIdList.get(0) : null;  if (!isNullOrWhitespace(responseModelId)) { attributes.put(FGA_CLIENT_RESPONSE_MODEL_ID, responseModelId); } }  if (credentials != null && credentials.getCredentialsMethod() == CredentialsMethod.CLIENT_CREDENTIALS) { if (!isNullOrWhitespace(credentials.getClientCredentials().getClientId())) { attributes.put( FGA_CLIENT_REQUEST_CLIENT_ID, credentials.getClientCredentials().getClientId()); } }  return attributes; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: givenServerHttpRequestAndServerHttpResponseAndWebSocketHandlerAndMapAttributes_whenBeforeHandshake_thenInValidToken() { // Given when(request.getURI()).thenReturn(URI.create("/websocket/invalidToken")); when(jwtTokenProvider.validateToken("invalidToken", false)).thenReturn(false);  // When Map<String, Object> attributes = new HashMap<>(); boolean result = webSocketInterceptor.beforeHandshake(request, response, wsHandler, attributes);  // Then "<AssertPlaceHolder>"; }
beforeHandshake(@NonNull ServerHttpRequest request, @NonNull ServerHttpResponse response, @NonNull WebSocketHandler wsHandler, @NonNull Map<String, Object> attributes) { log.debug("Received an incoming websocket channel request"); String token = getTokenFromPath(request.getURI().getPath()); if (token == null || !jwtTokenProvider.validateToken(token, false)) { log.error("Invalid token or token not present in WebSocket request"); return false; } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: spanFlow() { Span subject = TestHelper.spanTest("root", "root", 0) .enter("x.A", "x", "A", 0) .enter("x.AA", "x", "AA", 0) .leave(1) .enter("x.AB", "x", "AB", 1) .leave(2) .leave(2) .enter("x.B", "x", "B", 2) .enter("x.BA", "x", "BA", 2) .leave(3) .enter("x.BB", "x", "BB", 3) .leave(4);  Span expected = TestHelper.spanTest("root", "root", 0, of( TestHelper.spanTest("x.A", "A", 0, 2, of( TestHelper.spanTest("x.AA", "AA", 0, 1), TestHelper.spanTest("x.AB", "AB", 1, 2) )), TestHelper.spanTest("x.B", "B", 2, 4, of( TestHelper.spanTest("x.BA", "BA", 2, 3), TestHelper.spanTest("x.BB", "BB", 3, 4) )) ));  Span root = subject.getRoot(); "<AssertPlaceHolder>"; }
getRoot(){ Span root = this; while(root.parent != null){ root = root.parent; } return root; }
[*] target: assertEquals(expected, root)
[-] pred: org. junit. Assert. assertEquals ( expected, root )
************************************
************************************
[+] input: testClear() { Deck deck = new Deck(); deck.clear(); "<AssertPlaceHolder>"; }
getSize() { return cards.size(); }
[*] target: assertEquals(0, deck.getSize())
[-] pred: org. junit. Assert. assertEquals ( 0, deck. getSize() )
************************************
************************************
[+] input: testSort() { hand.addCard(kingOfHearts); hand.addCard(aceOfSpades);  hand.sort();  List<Card> expectedCards = new ArrayList<>(); expectedCards.add(aceOfSpades); expectedCards.add(kingOfHearts);  "<AssertPlaceHolder>"; }
getCards() { return cards; }
[*] target: assertEquals(expectedCards, hand.getCards())
[-] pred: org. junit. Assert. assertEquals ( expectedCards, hand. getCards() )
************************************
************************************
[+] input: likedTest() { SaveAndLikeModel model = new SaveAndLikeModel(); model.setLiked(true); "<AssertPlaceHolder>"; }
isLiked() { return liked; }
[*] target: assertTrue(model.isLiked())
[-] pred: org. junit. Assert. assertTrue ( model. isLiked() )
************************************
************************************
[+] input: niceJson() {  String niceJson = "[{ 'name': 'John Doe', 'age': 98 }, { 'name': 'Jane `nDoe', 'age': 89 }]"; String expectedJson = niceJson.replace('`', '\').replace(''', '"'); String validJson = Json.niceJson(niceJson); "<AssertPlaceHolder>";  }
niceJson(String json) { char[] chars = json.toCharArray(); StringBuilder sb = new StringBuilder(chars.length); for (char c : chars) { if (c == ''') { sb.append('"'); } else if (c == '`') { sb.append('\'); } else { sb.append(c); } } return sb.toString(); }
[*] target: assertEquals(expectedJson, validJson)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, validJson )
************************************
************************************
[+] input: testIsKey() { IndexPathNode indexPathNode = new IndexPathNode(token, charSource); "<AssertPlaceHolder>"; }
isKey() { return false; }
[*] target: assertFalse(indexPathNode.isKey())
[-] pred: org. junit. Assert. assertFalse ( indexPathNode. isKey() )
************************************
************************************
[+] input: testLoadStuffChain() { var chain = SummarizeUtils.loadStuffChain(llm); var actual = chain.run(docs);  var expected = "The article discusses the concept of building autonomous agents powered by large language models " + "(LLMs). It explores the components of such agents, including planning, memory, and tool " + "use. The article provides case studies and proof-of-concept examples of LLM-powered agents, " + "as well as challenges and limitations associated with their development."; "<AssertPlaceHolder>"; }
loadStuffChain(BaseLanguageModel llm) { return loadStuffChain(llm, StuffPrompt.PROMPT, "text", "\n\n"); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testChatGLM() { var llm = ChatGLM.builder().build().init(); var actual = llm.predict("Say foo:");  var expected = "Foo."; "<AssertPlaceHolder>"; }
init() { Map<String, String> headers = Map.of("Content-Type", "application/json"); this.requestsWrapper = new TextRequestsWrapper(headers); return this; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testOllama() { var llm = Ollama.builder() .baseUrl("http://localhost:11434") .model("llama2") .temperature(0f) .build() .init();  var actual = llm.predict("Say foo:");  var expected = " Foo!"; "<AssertPlaceHolder>"; }
init() { Map<String, String> headers = Map.of("Content-Type", "application/json"); this.requestsWrapper = new TextRequestsWrapper(headers); return this; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testParse() { var responseSchemas = List.of( new ResponseSchema("name", "desc"), new ResponseSchema("age", "desc")); var parser = StructuredOutputParser.fromResponseSchemas(responseSchemas);  var text = "```json\n{"name": "John", "age": 30}\n```"; var result = parser.parse(text);  var expectedResult = Map.of("name", "John", "age", 30); "<AssertPlaceHolder>"; }
parse(String text) { var expectedKeys = responseSchemas.stream() .map(ResponseSchema::getName) .toList(); return parseAndCheckJsonMarkdown(text, expectedKeys); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testPromptWithNoInputVariables() { PromptTemplate noInputPrompt = new PromptTemplate(List.of(), "Tell me a joke.");  String actual = noInputPrompt.format(Map.of()); String expected = "Tell me a joke."; "<AssertPlaceHolder>"; }
format(Map<String, Object> kwargs) { kwargs = mergePartialAndUserVariables(kwargs); return formatTemplate(template, kwargs); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testFormatTemplate() { String template = "{{\n{format}\n}}"; Map<String, Object> kwargs = Map.of("format", "value");  String expected = "{\nvalue\n}"; String actual = formatTemplate(template, kwargs);  "<AssertPlaceHolder>"; }
formatTemplate(String template, Map<String, Object> kwargs) { // In Python format() method, the curly braces '{{}}' are used to represent the output '{}'. String result = template.replace("{{", "{").replace("}}", "}"); for (Map.Entry<String, Object> entry : kwargs.entrySet()) { String placeholder = "{" + entry.getKey() + "}"; String value = entry.getValue().toString(); result = result.replace(placeholder, value); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testFormatTemplateWithValidTemplate() { String template = "Hello, {name}! Today is {day}."; Map<String, Object> kwargs = Map.of( "name", "John", "day", "Monday");  String expected = "Hello, John! Today is Monday."; String actual = formatTemplate(template, kwargs);  "<AssertPlaceHolder>"; }
formatTemplate(String template, Map<String, Object> kwargs) { // In Python format() method, the curly braces '{{}}' are used to represent the output '{}'. String result = template.replace("{{", "{").replace("}}", "}"); for (Map.Entry<String, Object> entry : kwargs.entrySet()) { String placeholder = "{" + entry.getKey() + "}"; String value = entry.getValue().toString(); result = result.replace(placeholder, value); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testFormatTemplateWithInvalidTemplate() { String template = "Hello, {name}! Today is {day}."; Map<String, Object> kwargs = Map.of("name", "John");  String expected = "Hello, John! Today is {day}."; String actual = formatTemplate(template, kwargs);  "<AssertPlaceHolder>"; }
formatTemplate(String template, Map<String, Object> kwargs) { // In Python format() method, the curly braces '{{}}' are used to represent the output '{}'. String result = template.replace("{{", "{").replace("}}", "}"); for (Map.Entry<String, Object> entry : kwargs.entrySet()) { String placeholder = "{" + entry.getKey() + "}"; String value = entry.getValue().toString(); result = result.replace(placeholder, value); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testFormatTemplateWithDoubleCurlyBraces() { String template = "Hello, {{{name}}}!"; Map<String, Object> kwargs = Map.of("name", "John");  // but python is 'Hello, {John}!' String expected = "Hello, {John}!"; String actual = formatTemplate(template, kwargs); "<AssertPlaceHolder>"; }
formatTemplate(String template, Map<String, Object> kwargs) { // In Python format() method, the curly braces '{{}}' are used to represent the output '{}'. String result = template.replace("{{", "{").replace("}}", "}"); for (Map.Entry<String, Object> entry : kwargs.entrySet()) { String placeholder = "{" + entry.getKey() + "}"; String value = entry.getValue().toString(); result = result.replace(placeholder, value); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testFormatTemplateWithQuadrupleCurlyBraces() { String template = "Hello, {{{{name}}}}!"; Map<String, Object> kwargs = Map.of("name", "John");  // python is 'Hello, {{name}}!' String expected = "Hello, {John}!"; String actual = formatTemplate(template, kwargs); "<AssertPlaceHolder>"; }
formatTemplate(String template, Map<String, Object> kwargs) { // In Python format() method, the curly braces '{{}}' are used to represent the output '{}'. String result = template.replace("{{", "{").replace("}}", "}"); for (Map.Entry<String, Object> entry : kwargs.entrySet()) { String placeholder = "{" + entry.getKey() + "}"; String value = entry.getValue().toString(); result = result.replace(placeholder, value); } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetTableDdl() { var actual = database.getTableDdl("students"); var expected = """  CREATE TABLE students ( id INTEGER(32), name CHARACTER VARYING(64), score INTEGER(32) COMMENT 'math score', teacher_note CHARACTER VARYING(256) ) COMMENT 'student score table'  """; "<AssertPlaceHolder>"; }
getTableDdl(String tableName) { StringBuilder builder = new StringBuilder(); DatabaseMetaData metaData = connection.getMetaData(); ResultSet resultSet = metaData.getTables(connection.getCatalog(), connection.getSchema(), tableName, new String[]{"TABLE"});  while (resultSet.next()) { ResultSet columnsResultSet = metaData.getColumns(connection.getCatalog(), connection.getSchema(), tableName, "%"); builder.append("\nCREATE TABLE ").append(tableName).append(" (");  while (columnsResultSet.next()) { String columnName = columnsResultSet.getString("COLUMN_NAME"); String columnType = columnsResultSet.getString("TYPE_NAME"); int columnSize = columnsResultSet.getInt("COLUMN_SIZE"); int decimalDigits = columnsResultSet.getInt("DECIMAL_DIGITS"); boolean isNullable = columnsResultSet.getBoolean("NULLABLE"); String defaultValue = columnsResultSet.getString("COLUMN_DEF"); String columnComment = columnsResultSet.getString("REMARKS");  builder.append("\n\t").append(columnName).append(" ").append(columnType); if (columnSize > 0) { builder.append("(").append(columnSize); if (decimalDigits > 0) { builder.append(",").append(decimalDigits); } builder.append(")"); } if (!isNullable) { builder.append(" NOT NULL"); } if (defaultValue != null) { builder.append(" DEFAULT ").append(defaultValue); } if (StringUtils.isNotEmpty(columnComment)) { builder.append(" COMMENT '").append(columnComment).append("'"); } builder.append(","); } // Remove the last comma if (builder.charAt(builder.length() - 1) == ',') { builder.deleteCharAt(builder.length() - 1); } String tableComment = resultSet.getString("REMARKS"); if (StringUtils.isNotEmpty(tableComment)) { builder.append("\n) COMMENT '").append(tableComment).append("'\n\n"); } else { builder.append("\n)\n\n"); } } return builder.toString(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetSampleRows() { var actual = database.getSampleRows("students"); var expected = """ 3 rows from students table: id	name	score	teacher_note 1	Alex	100	Alex did perfectly every day in the class. 2	Alice	70	Alice needs a lot of improvements. 3	Jack	75	Event it is not the best, Jack has already improved."""; "<AssertPlaceHolder>"; }
getSampleRows(String tableName) { // Build the select command String command = "SELECT * FROM " + tableName + " LIMIT " + sampleRowsInTableInfo; String result = run(command, true); // Save the sample rows in string format return String.format("%d rows from %s table:\n%s", sampleRowsInTableInfo, tableName, result); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetTableInfo() { var actual = database.getTableInfo(null); var expected = """  CREATE TABLE parents ( id INTEGER(32), student_name CHARACTER VARYING(64), parent_name CHARACTER VARYING(64), parent_mobile CHARACTER VARYING(16) )  /* 3 rows from parents table: id	student_name	parent_name	parent_mobile 1	Alex	Barry	088121 2	Alice	Jessica	088122 3	Jack	Simon	088123 */   CREATE TABLE students ( id INTEGER(32), name CHARACTER VARYING(64), score INTEGER(32) COMMENT 'math score', teacher_note CHARACTER VARYING(256) ) COMMENT 'student score table'  /* 3 rows from students table: id	name	score	teacher_note 1	Alex	100	Alex did perfectly every day in the class. 2	Alice	70	Alice needs a lot of improvements. 3	Jack	75	Event it is not the best, Jack has already improved. */"""; "<AssertPlaceHolder>"; }
getTableInfo(List<String> tableNames) { List<String> allTableNames = getUsableTableNames();  if (tableNames != null) { List<String> missingTables = new ArrayList<>(tableNames); missingTables.removeAll(allTableNames); if (!missingTables.isEmpty()) { throw new IllegalArgumentException("tableNames " + missingTables + " not found in database"); } allTableNames = tableNames; }  List<String> tables = new ArrayList<>(); for (String tableName : allTableNames) { String createTable = getTableDdl(tableName); String tableInfo = createTable.replaceAll("\\n+$", "");  boolean hasExtraInfo = indexesInTableInfo || sampleRowsInTableInfo > 0; if (hasExtraInfo) { tableInfo += "\n\n/*"; } if (indexesInTableInfo) { tableInfo += "\n" + getTableIndexes(tableName) + "\n"; } if (sampleRowsInTableInfo > 0) { tableInfo += "\n" + getSampleRows(tableName) + "\n"; } if (hasExtraInfo) { tableInfo += "*/"; } tables.add(tableInfo); } return String.join("\n\n", tables); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { AgentSource agentSource = buildAgentSource("timer://test", Map.of("period", 1, "repeatCount", 1)); Awaitility.await() .untilAsserted( () -> { List<Record> read = agentSource.read(); "<AssertPlaceHolder>"; }); }
read() throws Exception { CamelRecord poll = records.poll(1, TimeUnit.SECONDS); if (poll != null) { processed(0, 1); return List.of(poll); } else { return List.of(); } }
[*] target: assertEquals(1, read.size())
[-] pred: org. junit. Assert. assertEquals ( 1, read. size ( ) )
************************************
************************************
[+] input: getValue() { counter.click(); "<AssertPlaceHolder>"; }
getValue() { return value; }
[*] target: assertEquals(1, counter.getValue())
[-] pred: org. junit. Assert. assertEquals ( 1, counter. getValue() )
************************************
************************************
[+] input: testSend() {  //        // params //        final SendRequest sendRequest = new SendRequest("send", 1L, //                new MessageParam("13711111111", new HashMap<>(), new HashMap<>())); // //        // predict result //        final ProcessContext<SendTaskModel> processContext = new ProcessContext<>(sendRequest.getCode(), new SendTaskModel(), false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")); //        final SendResponse expectedResult = new SendResponse(processContext.getResponse().getStatus(), processContext.getResponse().getMsg()); // // //        // stub //        Map<String, ProcessTemplate> templateConfig = new HashMap<>(4); //        processTemplate.setProcessList(Arrays.asList(businessProcess)); //        templateConfig.put(BusinessCode.COMMON_SEND.getCode(), processTemplate); // //        processController.setTemplateConfig(templateConfig); // // //        // Run the test //        final SendResponse result = sendServiceImplUnderTest.send(sendRequest); // //        // Verify the results //        "<AssertPlaceHolder>"; }
send(SendRequest sendRequest) {  SendTaskModel sendTaskModel = SendTaskModel.builder() .messageTemplateId(sendRequest.getMessageTemplateId()) .messageParamList(Collections.singletonList(sendRequest.getMessageParam())) .build();  ProcessContext context = ProcessContext.builder() .code(sendRequest.getCode()) .processModel(sendTaskModel) .needBreak(false) .response(BasicResultVO.success()).build();  ProcessContext process = processController.process(context);  return new SendResponse(process.getResponse().getStatus(), process.getResponse().getMsg()); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testBatchSend() { //        // Setup //        final BatchSendRequest batchSendRequest = new BatchSendRequest("code", 0L, //                Arrays.asList(new MessageParam("receiver", new HashMap<>(), new HashMap<>()))); //        final SendResponse expectedResult = new SendResponse("status", "msg"); // //        // Configure ProcessController.process(...). //        final ProcessContext processContext = new ProcessContext<>("code", null, false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")); //        when(processController.process(new ProcessContext<>("code", null, false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")))).thenReturn(processContext); // //        // Run the test //        final SendResponse result = sendServiceImplUnderTest.batchSend(batchSendRequest); // //        // Verify the results //        "<AssertPlaceHolder>"; }
batchSend(BatchSendRequest batchSendRequest) { SendTaskModel sendTaskModel = SendTaskModel.builder() .messageTemplateId(batchSendRequest.getMessageTemplateId()) .messageParamList(batchSendRequest.getMessageParamList()) .build();  ProcessContext context = ProcessContext.builder() .code(batchSendRequest.getCode()) .processModel(sendTaskModel) .needBreak(false) .response(BasicResultVO.success()).build();  ProcessContext process = processController.process(context);  return new SendResponse(process.getResponse().getStatus(), process.getResponse().getMsg()); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: should_equal() { IdTree idTree = new IdTree("111"); idTree.addNode("111", "222"); idTree.addNode("111", "333"); idTree.addNode("222", "444");  IdTree idTree2 = new IdTree("111"); idTree2.addNode("111", "222"); idTree2.addNode("111", "333"); idTree2.addNode("222", "444"); "<AssertPlaceHolder>"; }
addNode(String parentNodeId, String nodeId) { requireNonBlank(nodeId, "Node ID must not be blank.");  if (isBlank(parentNodeId)) { this.nodes.add(0, new IdNode(nodeId)); return; }  IdNode parent = nodeById(parentNodeId); if (parent == null) { throw new IdNodeNotFoundException("ID node [" + parentNodeId + "] not found."); }  parent.addChild(nodeId); }
[*] target: assertEquals(idTree, idTree2)
[-] pred: org. junit. Assert. assertEquals ( idTree, idTree2 )
************************************
************************************
[+] input: should_silently_remove_none_exist_node() { IdTree idTree = new IdTree("111"); idTree.addNode("111", "222"); idTree.addNode("111", "333"); idTree.addNode("222", "444"); idTree.addNode(null, "555");  idTree.removeNode("whatever"); IdTree idTree2 = new IdTree("111"); idTree2.addNode("111", "222"); idTree2.addNode("111", "333"); idTree2.addNode("222", "444"); idTree2.addNode(null, "555"); "<AssertPlaceHolder>"; }
addNode(String parentNodeId, String nodeId) { requireNonBlank(nodeId, "Node ID must not be blank.");  if (isBlank(parentNodeId)) { this.nodes.add(0, new IdNode(nodeId)); return; }  IdNode parent = nodeById(parentNodeId); if (parent == null) { throw new IdNodeNotFoundException("ID node [" + parentNodeId + "] not found."); }  parent.addChild(nodeId); }
[*] target: assertEquals(idTree, idTree2)
[-] pred: org. junit. Assert. assertEquals ( idTree, idTree2 )
************************************
************************************
[+] input: FEEDBACK_SUMMARY_FIND_SERVICE_SUCCESS_TEST() {  Long surveyId = 1L; long expectedCount = 10L; when(surveyExistCheckPort.isExistSurveyBySurveyId(surveyId)).thenReturn(true); when(totalFeedbackCountPort.getTotalFeedbackCountBySurveyId(surveyId)).thenReturn(expectedCount);  long actualCount = feedbackSummaryFindService.getTotalFeedbackCount(surveyId);  "<AssertPlaceHolder>"; verify(totalFeedbackCountPort).getTotalFeedbackCountBySurveyId(surveyId); }
getTotalFeedbackCount(Long surveyId) { throwIfSurveyDoesNotExist(surveyId); return totalFeedbackCountPort.getTotalFeedbackCountBySurveyId(surveyId); }
[*] target: assertEquals(expectedCount, actualCount)
[-] pred: org. junit. Assert. assertEquals ( expectedCount, actualCount )
************************************
************************************
[+] input: testCheckerFilter() { CheckConfiguration checkConfiguration = new CheckConfiguration(); ControllerMethodsCache methodsCache = Mockito.mock(ControllerMethodsCache.class); ParamCheckerFilter checkerFilter = checkConfiguration.checkerFilter(methodsCache); "<AssertPlaceHolder>"; }
checkerFilter(ControllerMethodsCache methodsCache) { return new ParamCheckerFilter(methodsCache); }
[*] target: assertNotNull(checkerFilter)
[-] pred: org. junit. Assert. assertNotNull ( checkerFilter )
************************************
************************************
[+] input: searchFromEs() { PostQueryRequest postQueryRequest = new PostQueryRequest(); postQueryRequest.setUserId(1L); Page<Post> postPage = postService.searchFromEs(postQueryRequest); Assertions."<AssertPlaceHolder>"; }
searchFromEs(PostQueryRequest postQueryRequest);
[*] target: assertNotNull(postPage)
[-] pred: org. junit. Assert. assertNotNull ( postPage )
************************************
************************************
[+] input: expectAllNodesInList() { //given Node node1 = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), 0, 0); Node node2 = new Node("def", "456", "Office", 2, 100, new Coordinates(0, 0, 0), 0, 0); List<Node> expected = List.of(node1, node2); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); when(nodeRepo.findAll()).thenReturn(expected); List<Node> actual = nodeService.list(); //then "<AssertPlaceHolder>"; verify(nodeRepo).findAll(); }
list() { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); return this.nodeRepo.findAll().stream().filter(node -> node.ownerId().equals(player.id()) || getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) <= 25000).toList(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: expectNodeWhenNodeDataIsAdded() { //given; NodeData nodeData = new NodeData("Home", new Coordinates(1, 1, 1)); Node expected = new Node("abc", null, "Home", 0, 100, new Coordinates(1, 1, 1), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(adminName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(idService.generateId()).thenReturn("abc"); when(nodeRepo.insert(expected)).thenReturn(expected); when(mongoUserService.getUserByUsername(adminName)).thenReturn(admin); Node actual = nodeService.add(nodeData); //then "<AssertPlaceHolder>"; verify(idService).generateId(); verify(nodeRepo).insert(expected); verify(mongoUserService).getUserByUsername(adminName); }
add(NodeData nodeData) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); MongoUser user = this.mongoUserService.getUserByUsername(username); if (user.role().equals(Role.ADMIN)) { Node node = new Node( this.idService.generateId(), null, nodeData.name(), 0, 100, nodeData.coordinates(), Instant.now().getEpochSecond(), 0 ); this.nodeRepo.insert(node); return node; } else { throw new WrongRoleException("You are not an admin"); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: expectNodeWithIncreasedLevelWhenNodeIsHacked() { //given Node node = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), 0, 0); Node expected = new Node("abc", "123", "Home", 2, 100, new Coordinates(0, 0, 0), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(expected)).thenReturn(expected); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.HACK); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(nodeRepo).save(expected); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: expectNodeWithDecreasedLevelWhenNodeIsAbandoned() { //given Node node = new Node("abc", "123", "Home", 2, 100, new Coordinates(0, 0, 0), 0, 0); Node expected = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(any())).thenReturn(expected); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.ABANDON); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(nodeRepo).save(expected); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: expectUnchangedNodeWhenNodeIsAbandonedAndHasNoOwner() { //given Node node = new Node("abc", null, "Home", 1, 100, new Coordinates(0, 0, 0), 0, 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(node)).thenReturn(node); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.ABANDON); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(playerService).getPlayer(playerName);  }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(node, actual)
[-] pred: org. junit. Assert. assertEquals ( node, actual )
************************************
************************************
[+] input: expectNodeWithoutOwnerWhenNodeIsAbandonedAtLevel1() { //given Node node = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), 0, 0); Node expected = new Node("abc", null, "Home", 0, 100, new Coordinates(0, 0, 0), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(expected)).thenReturn(expected); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.ABANDON); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(nodeRepo).save(expected); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: expectNodeWithOwnerWhenNodeWithoutOwnerIsHacked() { //given Node node = new Node("abc", null, "Home", 0, 100, new Coordinates(0, 0, 0), 0, 0); Node expected = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(expected)).thenReturn(expected); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.HACK); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(nodeRepo).save(expected); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: expectListWithoutNodeWhenNodeIsDeleted() { //given Node node1 = new Node("def", "456", "Office", 2, 100, new Coordinates(0, 0, 0), 0, 0); List<Node> expected = List.of(node1); //when when(authentication.getName()).thenReturn(adminName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(mongoUserService.getUserByUsername(adminName)).thenReturn(admin); when(playerService.getPlayer(adminName)).thenReturn(adminPlayer); when(nodeRepo.findAll()).thenReturn(List.of(node1)); nodeService.delete("abc"); List<Node> actual = nodeService.list(); //then "<AssertPlaceHolder>"; verify(nodeRepo).deleteById("abc"); verify(nodeRepo).findAll(); verify(mongoUserService).getUserByUsername(adminName); }
list() { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); return this.nodeRepo.findAll().stream().filter(node -> node.ownerId().equals(player.id()) || getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) <= 25000).toList(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: expectUnchangedNodeWhenPlayerIsTooFarAway() { //given Node node = new Node("abc", "123", "Home", 1, 100, new Coordinates(55, 55, 0), 0, 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(node)).thenReturn(node); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.HACK); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(node, actual)
[-] pred: org. junit. Assert. assertEquals ( node, actual )
************************************
************************************
[+] input: expectUnchangedNodeWhenHackingBeforeCooldownIsOver() { //given Node node = new Node("abc", "123", "Home", 1, 100, new Coordinates(0, 0, 0), Instant.now().getEpochSecond(), 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(node)).thenReturn(node); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.HACK); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(node, actual)
[-] pred: org. junit. Assert. assertEquals ( node, actual )
************************************
************************************
[+] input: expectUnchangedNodeWhenAttackingOtherPlayerNodeBeforeCooldownIsOver() { //given Node node = new Node("abc", "456", "Home", 1, 100, new Coordinates(0, 0, 0), 0, Instant.now().getEpochSecond()); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); when(nodeRepo.save(node)).thenReturn(node); Node actual = nodeService.edit("abc", ActionType.HACK); //then verify(nodeRepo).findById("abc"); verify(playerService).getPlayer(playerName); verify(nodeRepo).save(node); "<AssertPlaceHolder>"; }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(node, actual)
[-] pred: org. junit. Assert. assertEquals ( node, actual )
************************************
************************************
[+] input: expectUnchangedNodeWhenAbandoningOtherPlayerNode() { //given Node node = new Node("abc", "456", "Home", 1, 100, new Coordinates(0, 0, 0), 0, 0); //when when(authentication.getName()).thenReturn(playerName); when(securityContext.getAuthentication()).thenReturn(authentication); SecurityContextHolder.setContext(securityContext); when(nodeRepo.findById("abc")).thenReturn(Optional.of(node)); when(nodeRepo.save(node)).thenReturn(node); when(playerService.getPlayer(playerName)).thenReturn(playerunknown); Node actual = nodeService.edit("abc", ActionType.ABANDON); //then "<AssertPlaceHolder>"; verify(nodeRepo).findById("abc"); verify(playerService).getPlayer(playerName); }
edit(String id, ActionType actionType) { String username = SecurityContextHolder.getContext().getAuthentication().getName(); Player player = this.playerService.getPlayer(username); Node node = this.nodeRepo.findById(id).orElseThrow(); Node newNode; if (getDistance(player.coordinates().latitude(), player.coordinates().longitude(), node.coordinates().latitude(), node.coordinates().longitude()) > MAX_DISTANCE) { return node; } if (!hasOwner(node) || node.health() == 0) { newNode = handleNonOwnedNode(player, node, actionType); } else if (isOwner(player, node)) { newNode = handleOwnedNode(player, node, actionType); } else { newNode = handleAttackedNode(player, node, actionType); } return this.nodeRepo.save(newNode); }
[*] target: assertEquals(node, actual)
[-] pred: org. junit. Assert. assertEquals ( node, actual )
************************************
************************************
[+] input: IOException { // Write a string to the file String content = "This is a test"; textHelper.writeStringToFile(content);  // Read the contents of the file and check if it matches the expected string BufferedReader reader = new BufferedReader(new FileReader(testFilePath)); String line = reader.readLine(); reader.close();  Assertions."<AssertPlaceHolder>"; }
writeStringToFile(String content) { try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) { writer.write(content); } catch (IOException e) { logger.log(Level.SEVERE, "An error occurred: ", e); } }
[*] target: assertEquals(content, line)
[-] pred: org. junit. Assert. assertEquals ( content, line )
************************************
************************************
[+] input: IOException { // Append a string to the file String content = "This is a test"; textHelper.appendStringToFile(content);  // Read the contents of the file and check if it matches the expected string BufferedReader reader = new BufferedReader(new FileReader(testFilePath)); String line = reader.readLine(); reader.close();  Assertions."<AssertPlaceHolder>"; }
appendStringToFile(String content) { try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath, true))) { writer.write(content); } catch (IOException e) { logger.log(Level.SEVERE, "An error occurred: ", e); } }
[*] target: assertEquals(content, line)
[-] pred: org. junit. Assert. assertEquals ( content, line )
************************************
************************************
[+] input: Exception { String responseJson = getAmsterdamWeatherJson(); WeatherResponse response = objectMapper.readValue(responseJson, WeatherResponse.class); WeatherEntity savedEntity = getSavedWeatherEntity(response.location().localtime());  WeatherDto expected = new WeatherDto(savedEntity.getCityName(), savedEntity.getCountry(), savedEntity.getTemperature(), savedEntity.getUpdatedTime());  when(weatherRepository.findFirstByRequestedCityNameOrderByUpdatedTimeDesc(requestedCity)).thenReturn(Optional.of(savedEntity));  WeatherDto result = weatherService.getWeather(requestedCity);  "<AssertPlaceHolder>";  verifyNoInteractions(restTemplate); verify(weatherRepository).findFirstByRequestedCityNameOrderByUpdatedTimeDesc(requestedCity); verifyNoMoreInteractions(weatherRepository); }
getWeather(String city) {  Optional<WeatherEntity> weatherEntityOptional = weatherRepository.findFirstByRequestedCityNameOrderByUpdatedTimeDesc(city);  return weatherEntityOptional.map(weather -> { if (weather.getUpdatedTime().isBefore(getLocalDateTimeNow().minusMinutes(API_CALL_LIMIT))) { logger.info(String.format("Creating a new city weather from weather stack api for %s due to the current one is not up-to-date", city)); return createCityWeather(city); } logger.info(String.format("Getting weather from database for %s due to it is already up-to-date", city)); return WeatherDto.convert(weather); }).orElseGet(() -> createCityWeather(city)); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: Exception { String responseJson = getAmsterdamWeatherJson(); WeatherResponse response = objectMapper.readValue(responseJson, WeatherResponse.class); WeatherEntity oldEntity = new WeatherEntity("id", requestedCity, "Amsterdam", "Netherlands", 2, LocalDateTime.parse("2023-03-05 12:35",formatter), LocalDateTime.parse(response.location().localtime(), formatter));  WeatherEntity toSaveEntity = getToSavdWeatherEntity(response.location().localtime()); WeatherEntity savedEntity = getSavedWeatherEntity(response.location().localtime());  WeatherDto expected = new WeatherDto(savedEntity.getCityName(), savedEntity.getCountry(), savedEntity.getTemperature(), savedEntity.getUpdatedTime());  when(weatherRepository.findFirstByRequestedCityNameOrderByUpdatedTimeDesc(requestedCity)).thenReturn(Optional.of(oldEntity)); when(restTemplate.getForEntity(WEATHER_STACK_API_URL+requestedCity, String.class)).thenReturn(ResponseEntity.ok(responseJson)); when(weatherRepository.save(toSaveEntity)).thenReturn(savedEntity);  WeatherDto result = weatherService.getWeather(requestedCity);  "<AssertPlaceHolder>";  verify(restTemplate).getForEntity(WEATHER_STACK_API_URL+requestedCity, String.class); verify(weatherRepository).save(toSaveEntity); }
getWeather(String city) {  Optional<WeatherEntity> weatherEntityOptional = weatherRepository.findFirstByRequestedCityNameOrderByUpdatedTimeDesc(city);  return weatherEntityOptional.map(weather -> { if (weather.getUpdatedTime().isBefore(getLocalDateTimeNow().minusMinutes(API_CALL_LIMIT))) { logger.info(String.format("Creating a new city weather from weather stack api for %s due to the current one is not up-to-date", city)); return createCityWeather(city); } logger.info(String.format("Getting weather from database for %s due to it is already up-to-date", city)); return WeatherDto.convert(weather); }).orElseGet(() -> createCityWeather(city)); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: listCachedContents() { CachedContentResponse cachedContentResponse = geminiInterface.listCachedContents(); "<AssertPlaceHolder>"; cachedContentResponse.cachedContents() .forEach(cachedContent -> System.out.println(cachedContent.name())); }
listCachedContents();  @GetExchange("cachedContents/{id}
[*] target: assertNotNull(cachedContentResponse)
[-] pred: org. junit. Assert. assertNotNull ( cachedContentResponse )
************************************
************************************
[+] input: Exception { String text = service.getCompletionWithImage( "Describe this image", "A_cheerful_robot.png"); "<AssertPlaceHolder>"; System.out.println(text); }
getCompletionWithImage(String text, String imageFileName) throws IOException { GeminiResponse response = getCompletionWithImage( new GeminiRequest(List.of(new Content(List.of( new TextPart(text), new InlineDataPart(new InlineData("image/png", Base64.getEncoder().encodeToString(Files.readAllBytes( Path.of("src/main/resources/", imageFileName)))))), "user" )), null)); System.out.println(response); return response.candidates().getFirst().content().parts().getFirst().text(); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: getModels() { ModelList models = service.getModels(); "<AssertPlaceHolder>"; models.models().stream() .map(Model::name) .sorted() .forEach(System.out::println); }
getModels() { return geminiInterface.getModels(); }
[*] target: assertNotNull(models)
[-] pred: org. junit. Assert. assertNotNull ( models )
************************************
************************************
[+] input: doFullBackup_nullParam() { //        given   //        when boolean result = backupService.doFullBackup(null);  //        then "<AssertPlaceHolder>"; }
doFullBackup(ScheduledSchedulerDto eventParameter) { return isBackupEvent(eventParameter) && doBackup(); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: doFullBackup_badParam() { //        given ScheduledSchedulerDto consumerParam = new ScheduledSchedulerDto("", "badParamWhichIsNotEqualBackup", -1L,false, LocalDateTime.now());  //        when boolean result = backupService.doFullBackup(consumerParam);  //        then "<AssertPlaceHolder>"; }
doFullBackup(ScheduledSchedulerDto eventParameter) { return isBackupEvent(eventParameter) && doBackup(); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: checkNameExistsTrue() { //        given FrontendResource frontendResource = mock(FrontendResource.class); BindingResult br = mock(BindingResult.class);  //        when when(frontendResourceRepository.findByName(anyString())).thenReturn(frontendResource); boolean result = frontendResourceService.checkNameExists(FRONTEND_RESOURCE_NAME, br);  //        then "<AssertPlaceHolder>"; }
checkNameExists(String name, BindingResult br) { debug("[checkNameExists] {}", name); boolean exists = repositories.unsecure.frontendResource.findByName(name) != null; if (exists && br != null) { br.rejectValue("dto.name", "name.exists"); } return exists; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: checkNameExistsFalse() { //        given BindingResult br = mock(BindingResult.class);  //        when when(frontendResourceRepository.findByName(anyString())).thenReturn(null); boolean result = frontendResourceService.checkNameExists(FRONTEND_RESOURCE_NAME, br);  //        then "<AssertPlaceHolder>"; }
checkNameExists(String name, BindingResult br) { debug("[checkNameExists] {}", name); boolean exists = repositories.unsecure.frontendResource.findByName(name) != null; if (exists && br != null) { br.rejectValue("dto.name", "name.exists"); } return exists; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: createNewRoleByTypeAnyTest() { //        given mockAndAuthenticateUser(1l, "test@openkoda.com", "TEST", "(canManageBackend)"); //        when Mockito.when(globalRoleRepository.findByName(anyString())) .thenReturn(null); Mockito.when(organizationRoleRepository.findByName(anyString())) .thenReturn(null);  Role result = roleService.createRole(StringUtils.EMPTY, RoleService.ROLE_TYPE_GLOBAL, ROLE_PRIVILEGES_EMPTY);  //        then "<AssertPlaceHolder>"; }
createRole(String name, String type, Set<PrivilegeBase> privileges) { debug("[createRole] Creating role {} of type {} and privileges {}", name, type, privileges); if (type.equals(ROLE_TYPE_GLOBAL)) { return createOrUpdateGlobalRole(name, privileges, true); } else if (type.equals(ROLE_TYPE_ORG)) { return createOrUpdateOrgRole(name, privileges, true); } else if (type.equals(ROLE_TYPE_GLOBAL_ORG)) { return createOrUpdateGlobalOrgRole(name, privileges, true); } return null; }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: checkIfRoleNameNotExistsTest() { //        given BindingResult br = mock(BindingResult.class);  //        when Mockito.when(globalRoleRepository.findByName(anyString())) .thenReturn(null); Mockito.when(organizationRoleRepository.findByName(anyString())) .thenReturn(null);  boolean result = roleService.checkIfRoleNameAlreadyExists(ROLE_NAME, RoleService.ROLE_TYPE_GLOBAL, br);  //        then "<AssertPlaceHolder>"; }
checkIfRoleNameAlreadyExists(String name, String type, BindingResult br) { debug("[checkIfRoleNameAlreadyExists]"); boolean roleExists = false; if (type.equals(ROLE_TYPE_GLOBAL)) { roleExists = repositories.unsecure.globalRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_ORG)) { roleExists = repositories.unsecure.organizationRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_GLOBAL_ORG)) { roleExists = repositories.unsecure.globalOrganizationRole.findByName(name) != null; } if (roleExists) { debug("[checkIfRoleNameAlreadyExists] role with name {} and type {} already exists", name, type); br.rejectValue("name", "name.exists"); } return roleExists; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: checkIfRoleNameExistsOrgTest() { //        given BindingResult br = mock(BindingResult.class); OrganizationRole role = new OrganizationRole();  //        when Mockito.when(globalRoleRepository.findByName(anyString())) .thenReturn(null); Mockito.when(organizationRoleRepository.findByName(anyString())) .thenReturn(role);  boolean result = roleService.checkIfRoleNameAlreadyExists(ROLE_NAME, RoleService.ROLE_TYPE_ORG, br);  //        then "<AssertPlaceHolder>"; verify(br, times(1)).rejectValue(anyString(), anyString()); }
checkIfRoleNameAlreadyExists(String name, String type, BindingResult br) { debug("[checkIfRoleNameAlreadyExists]"); boolean roleExists = false; if (type.equals(ROLE_TYPE_GLOBAL)) { roleExists = repositories.unsecure.globalRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_ORG)) { roleExists = repositories.unsecure.organizationRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_GLOBAL_ORG)) { roleExists = repositories.unsecure.globalOrganizationRole.findByName(name) != null; } if (roleExists) { debug("[checkIfRoleNameAlreadyExists] role with name {} and type {} already exists", name, type); br.rejectValue("name", "name.exists"); } return roleExists; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: checkIfRoleNameExistsGlobalTest() { //        given BindingResult br = mock(BindingResult.class); GlobalRole role = new GlobalRole();  //        when Mockito.when(globalRoleRepository.findByName(anyString())) .thenReturn(role); Mockito.when(organizationRoleRepository.findByName(anyString())) .thenReturn(null);  boolean result = roleService.checkIfRoleNameAlreadyExists(ROLE_NAME, RoleService.ROLE_TYPE_GLOBAL, br);  //        then "<AssertPlaceHolder>"; verify(br, times(1)).rejectValue(anyString(), anyString()); }
checkIfRoleNameAlreadyExists(String name, String type, BindingResult br) { debug("[checkIfRoleNameAlreadyExists]"); boolean roleExists = false; if (type.equals(ROLE_TYPE_GLOBAL)) { roleExists = repositories.unsecure.globalRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_ORG)) { roleExists = repositories.unsecure.organizationRole.findByName(name) != null; } else if (type.equals(ROLE_TYPE_GLOBAL_ORG)) { roleExists = repositories.unsecure.globalOrganizationRole.findByName(name) != null; } if (roleExists) { debug("[checkIfRoleNameAlreadyExists] role with name {} and type {} already exists", name, type); br.rejectValue("name", "name.exists"); } return roleExists; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testFullResource() { ApplicationInfo appInfo = new ApplicationInfo(); appInfo.labelRes = 12345;  when(app.getApplicationContext().getApplicationInfo()).thenReturn(appInfo); when(app.getApplicationContext().getString(appInfo.labelRes)).thenReturn(appName);  Resource expected = Resource.getDefault() .merge( Resource.builder() .put(SERVICE_NAME, appName) .put(RUM_SDK_VERSION, rumSdkVersion) .put(DEVICE_MODEL_NAME, Build.MODEL) .put(DEVICE_MODEL_IDENTIFIER, Build.MODEL) .put(DEVICE_MANUFACTURER, Build.MANUFACTURER) .put(OS_NAME, "Android") .put(OS_TYPE, "linux") .put(OS_VERSION, Build.VERSION.RELEASE) .put(OS_DESCRIPTION, osDescription) .build());  Resource result = AndroidResource.createDefault(app); "<AssertPlaceHolder>"; }
createDefault(Application application) { String appName = readAppName(application); ResourceBuilder resourceBuilder = Resource.getDefault().toBuilder().put(SERVICE_NAME, appName);  return resourceBuilder .put(RUM_SDK_VERSION, BuildConfig.OTEL_ANDROID_VERSION) .put(DEVICE_MODEL_NAME, Build.MODEL) .put(DEVICE_MODEL_IDENTIFIER, Build.MODEL) .put(DEVICE_MANUFACTURER, Build.MANUFACTURER) .put(OS_NAME, "Android") .put(OS_TYPE, "linux") .put(OS_VERSION, Build.VERSION.RELEASE) .put(OS_DESCRIPTION, getOSDescription()) .build(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testProblematicContext() { when(app.getApplicationContext().getApplicationInfo()) .thenThrow(new SecurityException("cannot do that")); when(app.getApplicationContext().getResources()).thenThrow(new SecurityException("boom"));  Resource expected = Resource.getDefault() .merge( Resource.builder() .put(SERVICE_NAME, "unknown_service:android") .put(RUM_SDK_VERSION, rumSdkVersion) .put(DEVICE_MODEL_NAME, Build.MODEL) .put(DEVICE_MODEL_IDENTIFIER, Build.MODEL) .put(DEVICE_MANUFACTURER, Build.MANUFACTURER) .put(OS_NAME, "Android") .put(OS_TYPE, "linux") .put(OS_VERSION, Build.VERSION.RELEASE) .put(OS_DESCRIPTION, osDescription) .build());  Resource result = AndroidResource.createDefault(app); "<AssertPlaceHolder>"; }
createDefault(Application application) { String appName = readAppName(application); ResourceBuilder resourceBuilder = Resource.getDefault().toBuilder().put(SERVICE_NAME, appName);  return resourceBuilder .put(RUM_SDK_VERSION, BuildConfig.OTEL_ANDROID_VERSION) .put(DEVICE_MODEL_NAME, Build.MODEL) .put(DEVICE_MODEL_IDENTIFIER, Build.MODEL) .put(DEVICE_MANUFACTURER, Build.MANUFACTURER) .put(OS_NAME, "Android") .put(OS_TYPE, "linux") .put(OS_VERSION, Build.VERSION.RELEASE) .put(OS_DESCRIPTION, getOSDescription()) .build(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testLock() { String keyName = "ditributedLockKey1"; DistributedLock lock = lockFactory.newLock(keyName); // 加锁 Boolean isLocked = lock.tryLock(); if (isLocked) { LOG.infov("acquire lock success, keyName:{0}", keyName); try { // 这里写需要处理业务的业务代码 LOG.info("do something."); } finally { // 释放锁 lock.unlock(); LOG.infov("release lock success, keyName:{0}", keyName); } } else { LOG.infov("acquire lock fail, keyName:{0}", keyName); } Assertions."<AssertPlaceHolder>"; }
unlock();
[*] target: assertTrue(isLocked)
[-] pred: org. junit. Assert. assertTrue ( isLocked )
************************************
************************************
[+] input: testLock() { String keyName = "distributedLockKey1"; DistributedLock lock = lockFactory.newLock(keyName, LockType.MySQLReentrantLock); // 加锁 Boolean isLocked = lock.tryLock(); if (isLocked) { LOG.infov("acquire lock success, keyName:{0}", keyName); try { // 这里写需要处理业务的业务代码 LOG.info("do something."); } finally { // 释放锁 lock.unlock(); LOG.infov("release lock success, keyName:{0}", keyName); } } else { LOG.infov("acquire lock fail, keyName:{0}", keyName); } Assertions."<AssertPlaceHolder>"; }
unlock() { lockService.releaseLock(keyName, lockValue, timeout); }
[*] target: assertTrue(isLocked)
[-] pred: org. junit. Assert. assertTrue ( isLocked )
************************************
************************************
[+] input: addPostLike() { // given long postId = 1L; long userId = 1L;  signUpMapper.addUser("no-reply@test.com", "username", "password", LoginType.NORMAL);  AddBasicPostRequest basicPost = AddBasicPostRequest.builder() .postId(postId) .content("content") .hashTagNames(Set.of("hashtag")) .build(); postMapper.save(postId, basicPost);  // when postLikeMapper.addPostLike(postId, userId);  // then boolean hasLike = postLikeMapper.hasLike(postId, userId); Assertions."<AssertPlaceHolder>"; }
hasLike(@Param("postId") long postId, @Param("userId") long userId);
[*] target: assertTrue(hasLike)
[-] pred: org. junit. Assert. assertTrue ( hasLike )
************************************
************************************
[+] input: existsByEmail() { //given String email = "no-reply@test.com"; signUpMapper.addUser(email, "username1", "password", LoginType.NORMAL);  //when boolean exists = userMapper.existsByEmail(email);  //then "<AssertPlaceHolder>"; }
existsByEmail(String email);
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
************************************
[+] input: reflectedRowNumIsBiggerThanZeroThenReturnTrue() { // given given(userMapper.updateProfileImage(anyLong(), anyString())) .willReturn(1);  // when boolean isSuccess = userService.updateProfileImage(1L, "https://profileImgUrlToUpload.com");  // then "<AssertPlaceHolder>"; }
updateProfileImage(long userId, String profileImgUrl) { int NumberOfAffectedRow = userMapper.updateProfileImage(userId, profileImgUrl);  return NumberOfAffectedRow == 1; }
[*] target: assertTrue(isSuccess)
[-] pred: org. junit. Assert. assertTrue ( isSuccess )
************************************
************************************
[+] input: testWriteCharArray() { StringBuilder sb = new StringBuilder(); try (var w = Internal.StringBuilderPrintWriter.of(sb)) { w.write("hello".toCharArray(), 0, 4); w.flush(); } String expected = "hell"; // hell is testing bullshit like this. String actual = sb.toString(); "<AssertPlaceHolder>"; }
flush() { }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testStringPringWriter() { StringBuilder sb = new StringBuilder(); try (var w = Internal.StringBuilderPrintWriter.of(sb)) { w.write("hello", 0, 4); w.flush(); } String expected = "hell"; String actual = sb.toString(); "<AssertPlaceHolder>"; }
flush() { }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testStringPringWriterAppendChar() { StringBuilder sb = new StringBuilder(); try (var w = Internal.StringBuilderPrintWriter.of(sb)) { w.append('h'); w.flush(); } String expected = "h"; String actual = sb.toString(); "<AssertPlaceHolder>"; }
flush() { }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testStringPringWriterAppend() { StringBuilder sb = new StringBuilder(); try (var w = Internal.StringBuilderPrintWriter.of(sb)) { w.append("hello"); w.flush(); } String expected = "hello"; String actual = sb.toString(); "<AssertPlaceHolder>"; }
flush() { }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testStringPringWriterAppendRange() { StringBuilder sb = new StringBuilder(); try (var w = Internal.StringBuilderPrintWriter.of(sb)) { w.append("hello", 0, 4); w.flush(); } String expected = "hell"; String actual = sb.toString(); "<AssertPlaceHolder>"; }
flush() { }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testMatchesMethodWithCorrectCredentials() { // given String rawPassword = "TestPassword"; String encodedPassword = sut.encode(rawPassword);  // when boolean result = sut.matches(rawPassword, encodedPassword);  // then "<AssertPlaceHolder>"; }
matches(String rawPassword, String encodedPassword) { return passwordEncoder.matches(rawPassword, encodedPassword); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testMatchesMethodWithIncorrectCredentials() { // given String rawPassword = "TestPassword"; String wrongRawPassword = "WrongPassword"; String encodedPassword = sut.encode(rawPassword);  // when boolean result = sut.matches(wrongRawPassword, encodedPassword);  // then "<AssertPlaceHolder>"; }
matches(String rawPassword, String encodedPassword) { return passwordEncoder.matches(rawPassword, encodedPassword); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: getArticles_AllValid_ReturnsArticles() { // given ArticleFacets facets = new ArticleFacets(1, 10); Article article = new Article(testUser1, "title", "bef", "content"); ArticleDetails articleDetails = ArticleDetails.unauthenticated(article, 0); List<ArticleDetails> expectedArticleDetailsList = List.of(articleDetails); when(articleRepository.findAll(facets)).thenReturn(List.of(article)); when(articleRepository.findArticleDetails(article)).thenReturn(articleDetails);  // when List<ArticleDetails> actualArticleDetailsList = sut.getArticles(facets);  // then "<AssertPlaceHolder>"; verify(articleRepository).findAll(facets); verify(articleRepository).findArticleDetails(article); }
getArticles(ArticleFacets facets) { return articleRepository.findAll(facets).stream() .map(articleRepository::findArticleDetails) .toList(); }
[*] target: assertEquals(expectedArticleDetailsList, actualArticleDetailsList)
[-] pred: org. junit. Assert. assertEquals ( expectedArticleDetailsList, actualArticleDetailsList )
************************************
************************************
[+] input: testIsFavorite_favoriteExists_returnTrue() { // given Article article = new Article(testUser1, "title1", "desc1", "content1"); when(articleFavoriteRepository.existsBy(testUser1, article)).thenReturn(true);  // when boolean isFavorite = sut.isFavorite(testUser1, article);  // then "<AssertPlaceHolder>"; verify(articleFavoriteRepository).existsBy(testUser1, article); }
isFavorite(User requester, Article article) { return articleFavoriteRepository.existsBy(requester, article); }
[*] target: assertTrue(isFavorite)
[-] pred: org. junit. Assert. assertTrue ( isFavorite )
************************************
************************************
[+] input: testIsFavorite_favoriteDoesNotExist_returnFalse() { // given Article article = new Article(testUser1, "title1", "desc1", "content1"); when(articleFavoriteRepository.existsBy(testUser1, article)).thenReturn(false);  // when boolean isFavorite = sut.isFavorite(testUser1, article);  // then "<AssertPlaceHolder>"; verify(articleFavoriteRepository).existsBy(testUser1, article); }
isFavorite(User requester, Article article) { return articleFavoriteRepository.existsBy(requester, article); }
[*] target: assertFalse(isFavorite)
[-] pred: org. junit. Assert. assertFalse ( isFavorite )
************************************
************************************
[+] input: testGetArticleDetails_LoggedInUser_successful() { // given User requester = new User("requesterEmail", "requesterUsername", "requesterPassword"); Article article = new Article(testUser1, "title", "desc", "content"); ArticleDetails expectedDetails = ArticleDetails.unauthenticated(article, 0); when(articleRepository.findArticleDetails(requester, article)).thenReturn(expectedDetails);  // when ArticleDetails actualArticleDetails = sut.getArticleDetails(requester, article);  // then "<AssertPlaceHolder>"; verify(articleRepository).findArticleDetails(requester, article); }
getArticleDetails(User requester, Article article) { return articleRepository.findArticleDetails(requester, article); }
[*] target: assertEquals(expectedDetails, actualArticleDetails)
[-] pred: org. junit. Assert. assertEquals ( expectedDetails, actualArticleDetails )
************************************
************************************
[+] input: updateUserDetailsSuccessScenario() { // given UUID testUuid = UUID.randomUUID(); String testEmail = "testEmail"; String testUsername = "testUsername"; String testPassword = "testPassword"; String testBio = "testBio"; String testImageUrl = "testImageUrl";  User initialUser = new User(testEmail, testUsername, testPassword); initialUser.setBio(testBio); initialUser.setImageUrl(testImageUrl);  when(userRepository.updateUserDetails(any(), any(), any(), any(), any(), any(), any())) .thenReturn(initialUser);  // when User result = sut.updateUserDetails(testUuid, testEmail, testUsername, testPassword, testBio, testImageUrl);  // then "<AssertPlaceHolder>"; }
updateUserDetails( UUID userId, String email, String username, String password, String bio, String imageUrl) { if (userId == null) { throw new IllegalArgumentException("user id is required."); }  return userRepository.updateUserDetails(userId, passwordEncoder, email, username, password, bio, imageUrl); }
[*] target: assertEquals(initialUser, result)
[-] pred: org. junit. Assert. assertEquals ( initialUser, result )
************************************
************************************
[+] input: deserializeWithValidBytes() { // Given byte[] bytes = "10.50".getBytes(); BigDecimal expectedValue = new BigDecimal("10.50");  // When Object result = serializer.deserialize(bytes);  // Then "<AssertPlaceHolder>"; }
deserialize(byte[] bytes) throws SerializationException { if (bytes == null) { return null; }  try { return new BigDecimal(new String(bytes, StandardCharsets.UTF_8)); } catch (NumberFormatException e) { return jsonSerializer.deserialize(bytes); } }
[*] target: assertEquals(expectedValue, result)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, result )
************************************
************************************
[+] input: deserializeWithInvalidBytes() { // Given byte[] bytes = "invalid".getBytes(); Object expectedValue = "deserialized"; when(jsonSerializer.deserialize(bytes)).thenReturn(expectedValue);  // When Object result = serializer.deserialize(bytes);  // Then "<AssertPlaceHolder>"; }
deserialize(byte[] bytes) throws SerializationException { if (bytes == null) { return null; }  try { return new BigDecimal(new String(bytes, StandardCharsets.UTF_8)); } catch (NumberFormatException e) { return jsonSerializer.deserialize(bytes); } }
[*] target: assertEquals(expectedValue, result)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, result )
************************************
************************************
[+] input: testFindByAssetCodeIn() { // Given List<String> assetCodes = Arrays.asList("78231", "24722"); List<Asset> expectedAssets = Arrays.asList( new Asset(1L, "78231", "a", 25400), new Asset(2L, "24722", "b", 52000) );  // When when(assetManagementRepository.findByAssetCodeIn(assetCodes)).thenReturn(expectedAssets); List<Asset> actualAssets = assetManagementRepository.findByAssetCodeIn(assetCodes);  // Then "<AssertPlaceHolder>"; }
findByAssetCodeIn(List<String> assetCode);
[*] target: assertEquals(expectedAssets, actualAssets)
[-] pred: org. junit. Assert. assertEquals ( expectedAssets, actualAssets )
************************************
************************************
[+] input: Exception { BankIDRequirements requirements = new BankIDRequirements(); requirements.setCertificatePolicies(Collections.singletonList("1.2.752.78.1.5"));  // Act ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(requirements);  // Verify String expectedJson = "{"certificatePolicies":["1.2.752.78.1.5"]}"; Assertions."<AssertPlaceHolder>"; }
setCertificatePolicies(List<String> certificatePolicies) { this.certificatePolicies = certificatePolicies; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: JsonProcessingException { String expected = "{"endUserIp":"1.2.3.4","returnRisk":true," + ""requirement":{" + ""cardReader":"class1"," + ""certificatePolicies":["1.2.3.4.5"]" + "}" + "}";  BankIDRequirements requirements = new BankIDRequirements(); requirements.setCardReader("class1"); requirements.setCertificatePolicies(Collections.singletonList("1.2.3.4.5"));  StartAuthenticationRequest request = new StartAuthenticationRequest("1.2.3.4"); request.setRequirement(requirements);  ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(request);  Assertions."<AssertPlaceHolder>"; }
setRequirement(BankIDRequirements requirement) { this.requirement = requirement; }
[*] target: assertEquals(expected, json)
[-] pred: org. junit. Assert. assertEquals ( expected, json )
************************************
************************************
[+] input: JsonProcessingException { String expected = "{"endUserIp":"1.2.3.4"," + ""userVisibleData":"dmlzaWJsZQ=="," + ""userVisibleDataFormat":"simpleMarkdownV1"," + ""returnRisk":true}";  StartAuthenticationRequest request = new StartAuthenticationRequest("1.2.3.4"); request.setUserVisibleData(new Base64String(this.visibleData)); request.setUserVisibleDataFormat("simpleMarkdownV1");  ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(request);  Assertions."<AssertPlaceHolder>"; }
setUserVisibleDataFormat(String userVisibleDataFormat) { if (userVisibleDataFormat != null && !userVisibleDataFormat.equals("simpleMarkdownV1")) { throw new IllegalArgumentException("Only null or simpleMarkdownV1 accepted."); }  this.userVisibleDataFormat = userVisibleDataFormat; }
[*] target: assertEquals(expected, json)
[-] pred: org. junit. Assert. assertEquals ( expected, json )
************************************
************************************
[+] input: JsonProcessingException { String expected = "{"endUserIp":"1.2.3.4","userNonVisibleData":"aW52aXNpYmxl","returnRisk":true}";  StartAuthenticationRequest request = new StartAuthenticationRequest("1.2.3.4"); request.setUserNonVisibleData(new Base64String(this.nonVisibleData));  ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(request);  Assertions."<AssertPlaceHolder>"; }
setUserNonVisibleData(Base64String userNonVisibleData) { this.userNonVisibleData = userNonVisibleData.getValue(); }
[*] target: assertEquals(expected, json)
[-] pred: org. junit. Assert. assertEquals ( expected, json )
************************************
************************************
[+] input: JsonProcessingException { String expected = "{"endUserIp":"1.2.3.4"}";  StartAuthenticationRequest request = new StartAuthenticationRequest("1.2.3.4"); request.setReturnRisk(null);  ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(request);  Assertions."<AssertPlaceHolder>"; }
setReturnRisk(Boolean returnRisk) { this.returnRisk = returnRisk; }
[*] target: assertEquals(expected, json)
[-] pred: org. junit. Assert. assertEquals ( expected, json )
************************************
************************************
[+] input: JsonProcessingException { String expected = "{"endUserIp":"1.2.3.4"," + ""returnRisk":true," + ""web":{" + ""referringDomain":"localhost"," + ""userAgent":"agent"," + ""deviceIdentifier":"did"" + "}}";  StartAuthenticationRequest request = new StartAuthenticationRequest("1.2.3.4"); AdditionalWebData webData = new AdditionalWebData("localhost", "agent", "did"); request.setWeb(webData);  ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(request);  Assertions."<AssertPlaceHolder>"; }
setWeb(AdditionalWebData web) { this.web = web; }
[*] target: assertEquals(expected, json)
[-] pred: org. junit. Assert. assertEquals ( expected, json )
************************************
************************************
[+] input: validateInvalidVisibleLength() { // Arrange AuthenticationRequest request = new AuthenticationRequest(); request.setUserVisibleData(TestUtils.generateString(1501));  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { // Check user visible data String userVisibleData = this.getUserVisibleData(); if (userVisibleData != null && !userVisibleData.isEmpty()) { // Max length if (base64Encode(userVisibleData).length() > AUTH_VISIBLE_MAX_LENGTH) { return false; } }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > AUTH_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertFalse(valid)
[-] pred: org. junit. Assert. assertFalse ( valid )
************************************
************************************
[+] input: validateInvalidNonVisibleLength() { // Arrange AuthenticationRequest request = new AuthenticationRequest(); request.setUserNonVisibleData(TestUtils.generateString(1501));  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { // Check user visible data String userVisibleData = this.getUserVisibleData(); if (userVisibleData != null && !userVisibleData.isEmpty()) { // Max length if (base64Encode(userVisibleData).length() > AUTH_VISIBLE_MAX_LENGTH) { return false; } }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > AUTH_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertFalse(valid)
[-] pred: org. junit. Assert. assertFalse ( valid )
************************************
************************************
[+] input: validateWithData() { // Arrange AuthenticationRequest request = new AuthenticationRequest(); request.setUserVisibleData(TestUtils.generateString(200)); request.setUserNonVisibleData(TestUtils.generateString(200));  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { // Check user visible data String userVisibleData = this.getUserVisibleData(); if (userVisibleData != null && !userVisibleData.isEmpty()) { // Max length if (base64Encode(userVisibleData).length() > AUTH_VISIBLE_MAX_LENGTH) { return false; } }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > AUTH_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: validateWithData() { // Arrange SignRequest request = new SignRequest(); request.setUserVisibleData(TestUtils.generateString(200)); request.setUserNonVisibleData(TestUtils.generateString(200));  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { String userVisibleData = this.getUserVisibleData(); if (userVisibleData == null || userVisibleData.isEmpty()) { return false; }  // Max length visible data if (base64Encode(userVisibleData).length() > SIGN_VISIBLE_MAX_LENGTH) { return false; }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > SIGN_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: signRequestEmpty() { // Arrange SignRequest request = new SignRequest();  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { String userVisibleData = this.getUserVisibleData(); if (userVisibleData == null || userVisibleData.isEmpty()) { return false; }  // Max length visible data if (base64Encode(userVisibleData).length() > SIGN_VISIBLE_MAX_LENGTH) { return false; }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > SIGN_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertFalse(valid)
[-] pred: org. junit. Assert. assertFalse ( valid )
************************************
************************************
[+] input: signInvalidVisibleLength() { // Arrange SignRequest request = new SignRequest(); request.setUserVisibleData(TestUtils.generateString(40001));  // Act boolean valid = request.validate();  // Assert "<AssertPlaceHolder>"; }
validate() { String userVisibleData = this.getUserVisibleData(); if (userVisibleData == null || userVisibleData.isEmpty()) { return false; }  // Max length visible data if (base64Encode(userVisibleData).length() > SIGN_VISIBLE_MAX_LENGTH) { return false; }  // Check user non visible data String userNonVisibleData = this.getUserNonVisibleData(); if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { // Max length if (base64Encode(userNonVisibleData).length() > SIGN_NON_VISIBLE_MAX_LENGTH) { return false; } }  return true; }
[*] target: assertFalse(valid)
[-] pred: org. junit. Assert. assertFalse ( valid )
************************************
************************************
[+] input: signingFailed() { when(this.rpApi.startSignature(Mockito.any(StartSignatureRequest.class))).thenReturn(null); when(this.bankIDRelyingPartyConfig.getSigningRequirements()).thenReturn(new BankIDRequirements()); when(this.appConfig.getDomain()).thenReturn("localhost");  BankIDTransaction response = this.bankIDService.signing(CLIENT_IP, "Sign this data", null, null, null, "curl", "id-123");  "<AssertPlaceHolder>"; }
signing( String clientIp, String userVisibleData, UserVisibleDataFormat userVisibleDataFormat, String userNonVisibleData, Boolean pinCode, String userAgent, String deviceIdentifier ) { StartSignatureRequest signatureRequest = new StartSignatureRequest(clientIp, new Base64String(base64Encode(userVisibleData)));  // Include additional web data AdditionalWebData webData = new AdditionalWebData(this.appConfig.getDomain(), userAgent, deviceIdentifier); signatureRequest.setWeb(webData);  BankIDRequirements bankIDRequirements = this.bankIDRelyingPartyConfig.getSigningRequirements(); if (bankIDRequirements == null) { bankIDRequirements = new BankIDRequirements(); }  // Only allow transactions with classified with risk low bankIDRequirements.setRisk(RiskRequirement.LOW);  bankIDRequirements.setPinCode(pinCode);  signatureRequest.setRequirement(bankIDRequirements);  if (userVisibleDataFormat != null) { signatureRequest.setUserVisibleDataFormat(userVisibleDataFormat.getValue()); }  if (userNonVisibleData != null && !userNonVisibleData.isEmpty()) { signatureRequest.setUserNonVisibleData(new Base64String(base64Encode(userNonVisibleData))); }  StartTransactionResponse startTransaction = this.rpApi.startSignature(signatureRequest);  if (startTransaction == null) { this.logger.info("Failed to start signing."); return null; }  return new BankIDTransaction( startTransaction.getOrderRef(), startTransaction.getQrStartToken(), startTransaction.getQrStartSecret(), startTransaction.getAutoStartToken(), Instant.now(this.clock) ); }
[*] target: assertNull(response)
[-] pred: org. junit. Assert. assertNull ( response )
************************************
************************************
[+] input: SignatureParseException { when(this.rpApi.collect(Mockito.anyString())).thenReturn(null);  BankIDTransaction transaction = new BankIDTransaction( "orderInfo123", "67df3917-fa0d-44e5-b327-edcc928297f8", "d28db9a7-4cde-429e-a983-359be676944c", "autoStartToken", Instant.now() );  CollectResult response = this.bankIDService.collect(transaction);  "<AssertPlaceHolder>"; }
collect(BankIDTransaction transaction) throws SignatureParseException { CollectResponse collectResponse;  if (shouldCallBankIDCollect(transaction)) { collectResponse = this.rpApi.collect(transaction.getOrderRef()); // Failed to collect if (collectResponse == null) { return null; }  Status status = Status.fromString(collectResponse.getStatus());  // Store collectResponse if status is complete future references/compliance/audit. if (status == Status.COMPLETE) { this.auditService.logCollectResponse(collectResponse); }  transaction.setLastCollectResponse(collectResponse); transaction.setLastCollect(Instant.now(this.clock)); transaction.setStatus(status); } else { collectResponse = transaction.getLastCollectResponse(); }  CollectResult collectModel = new CollectResult( transaction, collectResponse.getStatus(), collectResponse.getHintCode() );  // Only generate qr-code for pending transaction with hintCode outstandingTransaction if (collectModel.getStatus() == Status.PENDING && "outstandingTransaction".equals(collectModel.getHintCode())) { collectModel.setQrCode(createQRData(transaction)); }  if (collectModel.getStatus() == Status.COMPLETE) { String name = collectResponse.getCompletionData().getUser().getName(); String personalNumber = collectResponse.getCompletionData().getUser().getPersonalNumber();  Base64String xmlSigB64 = new Base64String(collectResponse.getCompletionData().getSignature());  // Parse the digital signature to retrieve more information. DigitalSignature digSig = new DigitalSignature(xmlSigB64);  String visibleData = null;  // Visible data may be empty if (digSig.getUserVisibleData() != null && !digSig.getUserVisibleData().isEmpty()) { visibleData = new String(Base64.getDecoder().decode(digSig.getUserVisibleData()), StandardCharsets.UTF_8); }  // Return a completion result collectModel.setCompletionResult( new CompletionResult(name, personalNumber, visibleData) ); }  return collectModel; }
[*] target: assertNull(response)
[-] pred: org. junit. Assert. assertNull ( response )
************************************
************************************
[+] input: testEncode() { byte[] bytes = "Hello world".getBytes(); String expected = "SGVsbG8gd29ybGQ="; String actual = Base64Utils.encode(bytes); Assertions."<AssertPlaceHolder>"; }
encode(byte[] bytes) { return new String(Base64.encodeBase64(bytes)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testCreate() { AbstractKusciaServingManager servingManager = new AbstractKusciaServingManager() { @Override public Serving.CreateServingResponse create(Serving.CreateServingRequest request) { return super.create(request); } }; servingManager.setKusciaGrpcClientAdapter(kusciaGrpcClientAdapter); servingManager.setApplicationEventPublisher(applicationEventPublisher); Serving.CreateServingRequest request = Serving.CreateServingRequest.newBuilder() .setServingId("serving1") .build(); Serving.CreateServingResponse response = Serving.CreateServingResponse.newBuilder() .setStatus(Common.Status.newBuilder().setCode(0)) .build(); when(kusciaGrpcClientAdapter.createServing(request)).thenReturn(response); Serving.CreateServingResponse result = servingManager.create(request); "<AssertPlaceHolder>"; verify(applicationEventPublisher).publishEvent(any(AbstractKusciaServingManager.KusciaServingEvent.class)); }
create(Serving.CreateServingRequest request) { log.debug("kuscia serving create request: {}", request); Serving.CreateServingResponse response = kusciaGrpcClientAdapter.createServing(request); if (response.getStatus().getCode() == 0) { publishEvent(request.getServingId(), ServingConstants.CREATE); } log.debug("kuscia serving create response: {}", response); return response; }
[*] target: assertEquals(response, result)
[-] pred: org. junit. Assert. assertEquals ( response, result )
************************************
************************************
[+] input: testDelete_WithValidRequest_ReturnsResponse() { AbstractKusciaServingManager servingManager = new AbstractKusciaServingManager() { @Override public Serving.CreateServingResponse create(Serving.CreateServingRequest request) { return super.create(request); } }; servingManager.setKusciaGrpcClientAdapter(kusciaGrpcClientAdapter); servingManager.setApplicationEventPublisher(applicationEventPublisher); Serving.DeleteServingRequest request = Serving.DeleteServingRequest.newBuilder() .setServingId("serving123") .build(); Serving.DeleteServingResponse response = Serving.DeleteServingResponse.newBuilder() .setStatus(Common.Status.newBuilder().setCode(0)) .build(); when(kusciaGrpcClientAdapter.deleteServing(request)).thenReturn(response); Serving.DeleteServingResponse result = servingManager.delete(request); "<AssertPlaceHolder>"; verify(kusciaGrpcClientAdapter).deleteServing(request); }
delete(Serving.DeleteServingRequest request) { log.debug("kuscia serving delete request: {}", request); Serving.DeleteServingResponse response = kusciaGrpcClientAdapter.deleteServing(request); if (response.getStatus().getCode() == 0) { publishEvent(request.getServingId(), ServingConstants.DELETE); } log.debug("kuscia serving delete response: {}", response); return response; }
[*] target: assertEquals(response, result)
[-] pred: org. junit. Assert. assertEquals ( response, result )
************************************
************************************
[+] input: testDelete_WithInvalidRequest_ReturnsResponse() { AbstractKusciaServingManager servingManager = new AbstractKusciaServingManager() { @Override public Serving.CreateServingResponse create(Serving.CreateServingRequest request) { return super.create(request); } }; servingManager.setKusciaGrpcClientAdapter(kusciaGrpcClientAdapter); servingManager.setApplicationEventPublisher(applicationEventPublisher); Serving.DeleteServingRequest request = Serving.DeleteServingRequest.newBuilder() .setServingId("") .build(); Serving.DeleteServingResponse response = Serving.DeleteServingResponse.newBuilder() .setStatus(Common.Status.newBuilder().setCode(1)) .build(); when(kusciaGrpcClientAdapter.deleteServing(request)).thenReturn(response); Serving.DeleteServingResponse result = servingManager.delete(request); "<AssertPlaceHolder>"; verify(kusciaGrpcClientAdapter).deleteServing(request); }
delete(Serving.DeleteServingRequest request) { log.debug("kuscia serving delete request: {}", request); Serving.DeleteServingResponse response = kusciaGrpcClientAdapter.deleteServing(request); if (response.getStatus().getCode() == 0) { publishEvent(request.getServingId(), ServingConstants.DELETE); } log.debug("kuscia serving delete response: {}", response); return response; }
[*] target: assertEquals(response, result)
[-] pred: org. junit. Assert. assertEquals ( response, result )
************************************
************************************
[+] input: testUpdate() { AbstractKusciaServingManager servingManager = new AbstractKusciaServingManager() { @Override public Serving.CreateServingResponse create(Serving.CreateServingRequest request) { return super.create(request); } }; servingManager.setKusciaGrpcClientAdapter(kusciaGrpcClientAdapter); servingManager.setApplicationEventPublisher(applicationEventPublisher); Serving.UpdateServingRequest request = Serving.UpdateServingRequest.newBuilder().build(); Serving.UpdateServingResponse expectedResponse = Serving.UpdateServingResponse.newBuilder().build(); when(kusciaGrpcClientAdapter.updateServing(request)).thenReturn(expectedResponse); Serving.UpdateServingResponse actualResponse = servingManager.update(request); "<AssertPlaceHolder>"; verify(applicationEventPublisher, times(1)).publishEvent(any(AbstractKusciaServingManager.KusciaServingEvent.class)); }
update(Serving.UpdateServingRequest request) { log.debug("kuscia serving update request: {}", request); Serving.UpdateServingResponse response = kusciaGrpcClientAdapter.updateServing(request); if (response.getStatus().getCode() == 0) { publishEvent(request.getServingId(), ServingConstants.UPDATE); } log.debug("kuscia serving update response: {}", response); return response; }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: isPasswordAndPasswordConfirmMatches_ShouldReturnTrue_WhenPasswordsMatch() { // when boolean result = underTestAuthenticationService.isPasswordAndPasswordConfirmMatches(USER_REGISTER_REQUEST);  // then "<AssertPlaceHolder>"; }
isPasswordAndPasswordConfirmMatches(RegisterRequest registerRequest) { // checks if the password and password confirm are the same return registerRequest.password().equals(registerRequest.confirmPassword()); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: isTokenValid_ShouldReturnTrueForValidToken() { // Given String username = "testuser"; String token = generateToken(username, 3600000L); when(userDetails.getUsername()).thenReturn(username);  // When boolean isValid = jwtService.isTokenValid(token, userDetails);  // Then "<AssertPlaceHolder>"; }
isTokenValid(String token, UserDetails userDetails) { final String username = extractUsername(token); return (username.equals(userDetails.getUsername())) && !isTokenExpired(token); }
[*] target: assertTrue(isValid)
[-] pred: org. junit. Assert. assertTrue ( isValid )
************************************
************************************
[+] input: isTokenValid_ShouldReturnFalseForInvalidUsername() { // Given String token = generateToken("testuser", 3600000L); when(userDetails.getUsername()).thenReturn("anotheruser");  // When boolean isValid = jwtService.isTokenValid(token, userDetails);  // Then "<AssertPlaceHolder>"; }
isTokenValid(String token, UserDetails userDetails) { final String username = extractUsername(token); return (username.equals(userDetails.getUsername())) && !isTokenExpired(token); }
[*] target: assertFalse(isValid)
[-] pred: org. junit. Assert. assertFalse ( isValid )
************************************
************************************
[+] input: isTokenValid_shouldReturnFalseIfTokenIsExpired() { // given String token = "expired-token"; Token storedToken = new Token(); storedToken.setExpired(true); when(tokenRepository.findByToken(token)).thenReturn(Optional.of(storedToken));  // when boolean isValid = underTestTokenService.isTokenValid(token);  // then "<AssertPlaceHolder>"; }
isTokenValid(String jwt) { return tokenRepository .findByToken(jwt) // Retrieve the token from the database .map(t -> !t.isExpired() && !t.isRevoked()) // Check if the token is not expired and not revoked .orElse(false); // If the token is not found in the database, return false }
[*] target: assertFalse(isValid)
[-] pred: org. junit. Assert. assertFalse ( isValid )
************************************
************************************
[+] input: isTokenValid_shouldReturnFalseIfTokenIsRevoked() { // given String token = "revoked-token"; Token storedToken = new Token(); storedToken.setRevoked(true); when(tokenRepository.findByToken(token)).thenReturn(Optional.of(storedToken));  // when boolean isValid = underTestTokenService.isTokenValid(token);  // then "<AssertPlaceHolder>"; }
isTokenValid(String jwt) { return tokenRepository .findByToken(jwt) // Retrieve the token from the database .map(t -> !t.isExpired() && !t.isRevoked()) // Check if the token is not expired and not revoked .orElse(false); // If the token is not found in the database, return false }
[*] target: assertFalse(isValid)
[-] pred: org. junit. Assert. assertFalse ( isValid )
************************************
************************************
[+] input: isTokenValid_shouldReturnFalseIfTokenNotFound() { // given String token = "non-existent-token"; when(tokenRepository.findByToken(token)).thenReturn(Optional.empty());  // when boolean isValid = underTestTokenService.isTokenValid(token);  // then "<AssertPlaceHolder>"; }
isTokenValid(String jwt) { return tokenRepository .findByToken(jwt) // Retrieve the token from the database .map(t -> !t.isExpired() && !t.isRevoked()) // Check if the token is not expired and not revoked .orElse(false); // If the token is not found in the database, return false }
[*] target: assertFalse(isValid)
[-] pred: org. junit. Assert. assertFalse ( isValid )
************************************
************************************
[+] input: shouldGenerateFullJsonSchemaWhenClassHasSomeFields() { var actualJsonSchema = schemaConverter.convert(TestClass.class).toString(); var expectedJsonSchema = "{"type":"object","properties":{"first":{"type":"string","myCustomProperty":true},"second":{"type":"integer","myCustomProperty":true}},"required":["first"],"myCustomProperty":true}"; "<AssertPlaceHolder>"; }
convert(Class<?> clazz) { JsonNode jsonSchema; try { jsonSchema = schemaGenerator.generateSchema(clazz); if (jsonSchema.get("properties") == null) { jsonSchema = objectMapper.readTree(JSON_EMPTY_CLASS); }  } catch (Exception e) { throw new SimpleUncheckedException("Cannot generate the Json Schema for the class {0}.", clazz.getName(), e); } return jsonSchema; }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )
************************************
************************************
[+] input: shouldGenerateEmptyJsonSchemaWhenClassHasNoFields() { var actualJsonSchema = schemaConverter.convert(EmptyClass.class).toString(); var expectedJsonSchema = JSON_EMPTY_CLASS; "<AssertPlaceHolder>"; }
convert(Class<?> clazz) { JsonNode jsonSchema; try { jsonSchema = schemaGenerator.generateSchema(clazz); if (jsonSchema.get("properties") == null) { jsonSchema = objectMapper.readTree(JSON_EMPTY_CLASS); }  } catch (Exception e) { throw new SimpleUncheckedException("Cannot generate the Json Schema for the class {0}.", clazz.getName(), e); } return jsonSchema; }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )
************************************
************************************
[+] input: shouldGenerateOrderedJsonSchemaWhenClassHasJsonPropertyOrderAnnotation() { var actualJsonSchema = schemaConverter.convert(OrderedTestClass.class).toString(); var expectedJsonSchema = "{"type":"object","properties":{"first":{"type":"string","myCustomProperty":true},"second":{"type":"integer","myCustomProperty":true},"third":{"type":"string","myCustomProperty":true}},"required":["first"],"myCustomProperty":true}"; "<AssertPlaceHolder>"; }
convert(Class<?> clazz) { JsonNode jsonSchema; try { jsonSchema = schemaGenerator.generateSchema(clazz); if (jsonSchema.get("properties") == null) { jsonSchema = objectMapper.readTree(JSON_EMPTY_CLASS); }  } catch (Exception e) { throw new SimpleUncheckedException("Cannot generate the Json Schema for the class {0}.", clazz.getName(), e); } return jsonSchema; }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )
************************************
************************************
[+] input: shouldGenerateFullJsonSchemaWhenClassHasSomeFields() { var actualJsonSchema = JsonSchemaUtil.classToJsonSchema(TestClass.class).toString(); var expectedJsonSchema = "{"type":"object","properties":{"first":{"type":"string"}," + ""second":{"type":"integer"}},"required":["first"],"additionalProperties":false}"; "<AssertPlaceHolder>"; }
classToJsonSchema(Class<?> clazz) { return defaultConverter.convert(clazz); }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )
************************************
************************************
[+] input: shouldGenerateEmptyJsonSchemaWhenClassHasNoFields() { var actualJsonSchema = JsonSchemaUtil.classToJsonSchema(EmptyClass.class).toString(); var expectedJsonSchema = JSON_EMPTY_CLASS; "<AssertPlaceHolder>"; }
classToJsonSchema(Class<?> clazz) { return defaultConverter.convert(clazz); }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )
************************************
************************************
[+] input: shouldGenerateOrderedJsonSchemaWhenClassHasJsonPropertyOrderAnnotation() { var actualJsonSchema = JsonSchemaUtil.classToJsonSchema(OrderedTestClass.class).toString(); var expectedJsonSchema = "{"type":"object","properties":{"first":{"type":"string"}," + ""second":{"type":"integer"}," + ""third":{"type":"string"}}," + ""required":["first"],"additionalProperties":false}"; "<AssertPlaceHolder>"; }
classToJsonSchema(Class<?> clazz) { return defaultConverter.convert(clazz); }
[*] target: assertEquals(expectedJsonSchema, actualJsonSchema)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonSchema, actualJsonSchema )
************************************
************************************
[+] input: IOException { URL url = new URL(URL_BASE + "one.txt");  SortedMap<String, Integer> expected = new TreeMap<>(); expected.put("forrrrr", 2); expected.put("scorrrrre", 2); expected.put("annnnnd", 1); expected.put("sevvvvin", 3);  SortedMap<String, Integer> actual = checker.check(url); Assertions."<AssertPlaceHolder>"; }
check(URL url) throws IOException {  // download the document content URLFetcher fetcher = new URLFetcher(); String content = fetcher.fetch(url);  // extract words from the content WordExtractor extractor = new WordExtractor(); List<String> words = extractor.extract(content);  // find spelling mistakes Dictionary dictionary = new Dictionary("dict.txt"); SortedMap<String, Integer> mistakes = new TreeMap<>();  for (String word : words) { if (!dictionary.isValidWord(word)) { if (mistakes.containsKey(word)) { int oldCount = mistakes.get(word); mistakes.put(word, oldCount + 1); } else { mistakes.put(word, 1); } } }  return mistakes; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testOneShortWord() { String content = "a";  expected.add("a");  List<String> actual = extractor.extract(content); Assertions."<AssertPlaceHolder>"; }
extract(String content) {  content = content.toLowerCase();  List<String> words = new ArrayList<>();  Pattern wordPattern = Pattern.compile("\\p{Alpha}+"); Pattern delimiterPattern = Pattern.compile("[^\\p{Alpha}]+");  Scanner scanner = new Scanner(content); scanner.useDelimiter(delimiterPattern);  while (scanner.hasNext(wordPattern)) { String word = scanner.next(wordPattern); words.add(word); }  return words; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testOneLongWord() { String content = "thisisareallylongword";  expected.add("thisisareallylongword");  List<String> actual = extractor.extract(content); Assertions."<AssertPlaceHolder>"; }
extract(String content) {  content = content.toLowerCase();  List<String> words = new ArrayList<>();  Pattern wordPattern = Pattern.compile("\\p{Alpha}+"); Pattern delimiterPattern = Pattern.compile("[^\\p{Alpha}]+");  Scanner scanner = new Scanner(content); scanner.useDelimiter(delimiterPattern);  while (scanner.hasNext(wordPattern)) { String word = scanner.next(wordPattern); words.add(word); }  return words; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testOneShortWordWithSurroundingWhitespace() { String content = " \t\n\ra \t\n\r";  expected.add("a");  List<String> actual = extractor.extract(content); Assertions."<AssertPlaceHolder>"; }
extract(String content) {  content = content.toLowerCase();  List<String> words = new ArrayList<>();  Pattern wordPattern = Pattern.compile("\\p{Alpha}+"); Pattern delimiterPattern = Pattern.compile("[^\\p{Alpha}]+");  Scanner scanner = new Scanner(content); scanner.useDelimiter(delimiterPattern);  while (scanner.hasNext(wordPattern)) { String word = scanner.next(wordPattern); words.add(word); }  return words; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testOneLongWordWithSurroundingWhitespace() { String content = " \t\n\rthisisareallylongword \t\n\r";  expected.add("thisisareallylongword");  List<String> actual = extractor.extract(content); Assertions."<AssertPlaceHolder>"; }
extract(String content) {  content = content.toLowerCase();  List<String> words = new ArrayList<>();  Pattern wordPattern = Pattern.compile("\\p{Alpha}+"); Pattern delimiterPattern = Pattern.compile("[^\\p{Alpha}]+");  Scanner scanner = new Scanner(content); scanner.useDelimiter(delimiterPattern);  while (scanner.hasNext(wordPattern)) { String word = scanner.next(wordPattern); words.add(word); }  return words; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testRenderWithHyphen() { Map<String, Object> model = Map.of("key-1", "value1"); String template = "This is a {key-1}"; PromptTemplate promptTemplate = new PromptTemplate(template, model);  String expected = "This is a value1"; String result = promptTemplate.render();  "<AssertPlaceHolder>"; }
render() { validate(this.dynamicModel); return st.render(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testRenderResource() { Map<String, Object> model = createTestMap(); InputStream inputStream = new ByteArrayInputStream( "key1's value is {key1} and key2's value is {key2}".getBytes(Charset.defaultCharset())); Resource resource = new InputStreamResource(inputStream); PromptTemplate promptTemplate = new PromptTemplate(resource, model); String expected = "key1's value is value1 and key2's value is true"; String result = promptTemplate.render(); "<AssertPlaceHolder>"; }
render() { validate(this.dynamicModel); return st.render(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: Exception { Map<String, Object> model = createTestMap();  // Create an input stream for the resource InputStream inputStream = new ByteArrayInputStream("it costs 100".getBytes(Charset.defaultCharset())); Resource resource = new InputStreamResource(inputStream);  model.put("key3", resource);  // Create a simple template with placeholders for keys in the generative String template = "{key1}, {key2}, {key3}"; PromptTemplate promptTemplate = new PromptTemplate(template, model);  // The expected result after rendering the template with the generative String expected = "value1, true, it costs 100"; String result = promptTemplate.render();  // Check that the rendered string matches the expected result "<AssertPlaceHolder>"; }
render() { validate(this.dynamicModel); return st.render(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: existsByUsernameIgnoreCase_givenExistingUsername_returnTrue() { boolean exists = userRepository.existsByUsernameIgnoreCase(user1.getUsername()); "<AssertPlaceHolder>"; }
existsByUsernameIgnoreCase(String username);
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
************************************
[+] input: existsByUsernameIgnoreCase_givenNonExistingUsername_returnFalse() { boolean exists = userRepository.existsByUsernameIgnoreCase("non-existing-username"); "<AssertPlaceHolder>"; }
existsByUsernameIgnoreCase(String username);
[*] target: assertFalse(exists)
[-] pred: org. junit. Assert. assertFalse ( exists )
************************************
************************************
[+] input: existsById_givenExistingId_returnTrue() { boolean exists = userRepository.existsById(user1.getId()); "<AssertPlaceHolder>"; }
existsById(Long id);
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
************************************
[+] input: existsById_givenNonExistingId_returnFalse() { boolean exists = userRepository.existsById(-1L); "<AssertPlaceHolder>"; }
existsById(Long id);
[*] target: assertFalse(exists)
[-] pred: org. junit. Assert. assertFalse ( exists )
************************************
************************************
[+] input: update_givenExistingUser_returnUpdatedUser() { UserRequest userRequest = UserRequest.builder() .id(user1.getId()) .username("username_will_not_update") .name("Updated User") .email("updated@test.com") .build(); User updatedUser = new User(); updatedUser.setEmail(userRequest.getEmail()); updatedUser.setName(userRequest.getName()); UserDTO updatedUserDto = new UserDTO(); BeanUtils.copyProperties(updatedUser, updatedUserDto);  when(userRepository.existsById(any())).thenReturn(true); when(userRepository.findById(any())).thenReturn(Optional.of(user1)); when(userRepository.save(any())).thenReturn(updatedUser); when(userConverter.mapToDTO(updatedUser)).thenReturn(updatedUserDto);  UserDTO actual = userService.update(userRequest); "<AssertPlaceHolder>"; }
update(UserRequest userRequest);
[*] target: assertEquals(updatedUserDto, actual)
[-] pred: org. junit. Assert. assertEquals ( updatedUserDto, actual )
************************************
************************************
[+] input: getUserNamesListWithLengthGreaterThan_givenLength_returnUsernames() { int length = 8; List<UsernameLengthProjection> expectedList = Arrays.asList( getUsernameLengthProjection( user1.getId(), user1.getUsername(), user1.getEmail(), user1.getUsername().length()), getUsernameLengthProjection( user2.getId(), user2.getUsername(), user2.getEmail(), user2.getUsername().length()));  when(userRepository.getUserNamesListWithLengthGreaterThan(length)).thenReturn(expectedList);  List<UsernameLengthProjection> result = userService.getUserNamesListWithLengthGreaterThan(length);  "<AssertPlaceHolder>"; }
getUserNamesListWithLengthGreaterThan(Integer length);
[*] target: assertEquals(expectedList, result)
[-] pred: org. junit. Assert. assertEquals ( expectedList, result )
************************************
************************************
[+] input: getMailAndUsernames_givenNoCondition_returnMailAndUsernames() { List<MailUserNameProjection> expectedList = Arrays.asList( getMailUsernameProjection(user1.getEmail(), user1.getUsername()), getMailUsernameProjection(user2.getEmail(), user2.getUsername())); when(userRepository.findAllMailAndUserName()).thenReturn(expectedList);  List<MailUserNameProjection> result = userService.getMailAndUsernames();  "<AssertPlaceHolder>"; }
getMailAndUsernames();
[*] target: assertEquals(expectedList, result)
[-] pred: org. junit. Assert. assertEquals ( expectedList, result )
************************************
************************************
[+] input: IOException { PDDocument document = Mockito.mock(PDDocument.class); Mockito.when(document.getDocumentInformation()).thenReturn(Mockito.mock(org.apache.pdfbox.pdmodel.PDDocumentInformation.class)); PdfMetadata metadata = PdfUtils.extractMetadataFromPdf(document);  "<AssertPlaceHolder>"; }
extractMetadataFromPdf(PDDocument pdf) { return PdfMetadata.builder() .author(pdf.getDocumentInformation().getAuthor()) .producer(pdf.getDocumentInformation().getProducer()) .title(pdf.getDocumentInformation().getTitle()) .creator(pdf.getDocumentInformation().getCreator()) .subject(pdf.getDocumentInformation().getSubject()) .keywords(pdf.getDocumentInformation().getKeywords()) .creationDate(pdf.getDocumentInformation().getCreationDate()) .modificationDate(pdf.getDocumentInformation().getModificationDate()) .build(); }
[*] target: assertNotNull(metadata)
[-] pred: org. junit. Assert. assertNotNull ( metadata )
************************************
************************************
[+] input: testCourseBaseInfoService() { //query condition QueryCourseParamsDto queryCourseParamsDto = new QueryCourseParamsDto(); queryCourseParamsDto.setCourseName("java"); queryCourseParamsDto.setAuditStatus("202004"); queryCourseParamsDto.setPublishStatus("203001");  //Pagination parameters PageParams pageParams = new PageParams(1L, 10L); Long companyId = 12345678L; PageResult<CourseBase> courseBasePageResult = courseBaseInfoService.queryCourseBaseInfoList(pageParams, queryCourseParamsDto,companyId); Assertions."<AssertPlaceHolder>"; }
queryCourseBaseInfoList(PageParams pageParams,QueryCourseParamsDto queryCourseParams,Long companyId);
[*] target: assertNotNull(courseBasePageResult)
[-] pred: org. junit. Assert. assertNotNull ( courseBasePageResult )
************************************
************************************
[+] input: testCourseCategoryWhenSuccess() { List<CourseCategoryTreeDto> childrenNodes = courseCategoryService.queryTreeNodes("1"); Assertions."<AssertPlaceHolder>"; }
queryTreeNodes(String id);
[*] target: assertNotNull(childrenNodes)
[-] pred: org. junit. Assert. assertNotNull ( childrenNodes )
************************************
************************************
[+] input: Exception { ModelRepository modelRepository = Mockito.mock(ModelRepository.class); ModelService modelService = mockModelService(modelRepository); ModelResp actualModelResp = modelService.createModel( mockModelReq(), User.getFakeUser()); ModelResp expectedModelResp = buildExpectedModelResp(); Assertions."<AssertPlaceHolder>"; }
createModel(ModelReq modelReq, User user) throws Exception { checkParams(modelReq); ModelDO modelDO = ModelConverter.convert(modelReq, user); modelRepository.createModel(modelDO); batchCreateDimension(modelDO, user); batchCreateMetric(modelDO, user); return ModelConverter.convert(modelDO); }
[*] target: assertEquals(expectedModelResp, actualModelResp)
[-] pred: org. junit. Assert. assertEquals ( expectedModelResp, actualModelResp )
************************************
************************************
[+] input: testParseSql_defaultVariableValue() { String sql = "select * from t_$interval$ where id = $id$ and name = $name$"; List<SqlVariable> variables = Lists.newArrayList(mockNumSqlVariable(), mockExprSqlVariable(), mockStrSqlVariable()); String actualSql = SqlVariableParseUtils.parse(sql, variables, Lists.newArrayList()); String expectedSql = "select * from t_d where id = 1 and name = 'tom'"; Assertions."<AssertPlaceHolder>"; }
parse(String sql, List<SqlVariable> sqlVariables, List<Param> params) { Map<String, Object> variables = new HashMap<>(); if (CollectionUtils.isEmpty(sqlVariables)) { return sql; } //1. handle default variable value sqlVariables.forEach(variable -> { variables.put(variable.getName().trim(), getValues(variable.getValueType(), variable.getDefaultValues())); });  //override by variable param if (!CollectionUtils.isEmpty(params)) { Map<String, List<SqlVariable>> map = sqlVariables.stream().collect(Collectors.groupingBy(SqlVariable::getName)); params.forEach(p -> { if (map.containsKey(p.getName())) { List<SqlVariable> list = map.get(p.getName()); if (!CollectionUtils.isEmpty(list)) { SqlVariable v = list.get(list.size() - 1); variables.put(p.getName().trim(), getValue(v.getValueType(), p.getValue())); } } }); }  variables.forEach((k, v) -> { if (v instanceof List && ((List) v).size() > 0) { v = ((List) v).stream().collect(Collectors.joining(COMMA)).toString(); } variables.put(k, v); }); return parse(sql, variables); }
[*] target: assertEquals(expectedSql, actualSql)
[-] pred: org. junit. Assert. assertEquals ( expectedSql, actualSql )
************************************
************************************
[+] input: testParseSql() { String sql = "select * from t_$interval$ where id = $id$ and name = $name$"; List<SqlVariable> variables = Lists.newArrayList(mockNumSqlVariable(), mockExprSqlVariable(), mockStrSqlVariable()); List<Param> params = Lists.newArrayList(mockIdParam(), mockNameParam(), mockIntervalParam()); String actualSql = SqlVariableParseUtils.parse(sql, variables, params); String expectedSql = "select * from t_wk where id = 2 and name = 'alice'"; Assertions."<AssertPlaceHolder>"; }
parse(String sql, List<SqlVariable> sqlVariables, List<Param> params) { Map<String, Object> variables = new HashMap<>(); if (CollectionUtils.isEmpty(sqlVariables)) { return sql; } //1. handle default variable value sqlVariables.forEach(variable -> { variables.put(variable.getName().trim(), getValues(variable.getValueType(), variable.getDefaultValues())); });  //override by variable param if (!CollectionUtils.isEmpty(params)) { Map<String, List<SqlVariable>> map = sqlVariables.stream().collect(Collectors.groupingBy(SqlVariable::getName)); params.forEach(p -> { if (map.containsKey(p.getName())) { List<SqlVariable> list = map.get(p.getName()); if (!CollectionUtils.isEmpty(list)) { SqlVariable v = list.get(list.size() - 1); variables.put(p.getName().trim(), getValue(v.getValueType(), p.getValue())); } } }); }  variables.forEach((k, v) -> { if (v instanceof List && ((List) v).size() > 0) { v = ((List) v).stream().collect(Collectors.joining(COMMA)).toString(); } variables.put(k, v); }); return parse(sql, variables); }
[*] target: assertEquals(expectedSql, actualSql)
[-] pred: org. junit. Assert. assertEquals ( expectedSql, actualSql )
************************************
************************************
[+] input: convertNullTest() { ASTTransformer transformer = new ASTTransformer();  Resource result = transformer.convertResource(null, new ResourceSetImpl());  "<AssertPlaceHolder>"; }
convertResource(final InputStream input, final ResourceSet resourceSet) { Resource result = null; if (input != null) { final JsonNode astJson = this.readAst(input); if (astJson != null) { this.logger.info("Create the Root eObject containment structure"); final List<EObject> rootSysmlObjects = this.astTreeParser.parseAst(astJson); result = new JSONResourceFactory().createResource(new JSONResourceFactory().createResourceURI(null)); resourceSet.getResources().add(result); result.getContents().addAll(rootSysmlObjects); this.logger.info("End of create the Root eObject containment structure"); this.logger.info("Try to resolve Imports"); this.astTreeParser.resolveAllImport(result); this.logger.info("End of import resolving"); this.logger.info("Try to resolve all references"); this.astTreeParser.resolveAllReference(result); this.logger.info("End of references resolving"); } } return result; }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: isTaskOwner() { Long userId = 1L; Long taskId = 1L; Mockito.when(userRepository.isTaskOwner(userId, taskId)) .thenReturn(true); boolean isOwner = userService.isTaskOwner(userId, taskId); Mockito.verify(userRepository).isTaskOwner(userId, taskId); Assertions."<AssertPlaceHolder>"; }
isTaskOwner( final Long userId, final Long taskId ) { return userRepository.isTaskOwner(userId, taskId); }
[*] target: assertTrue(isOwner)
[-] pred: org. junit. Assert. assertTrue ( isOwner )
************************************
************************************
[+] input: isTaskOwnerWithFalse() { Long userId = 1L; Long taskId = 1L; Mockito.when(userRepository.isTaskOwner(userId, taskId)) .thenReturn(false); boolean isOwner = userService.isTaskOwner(userId, taskId); Mockito.verify(userRepository).isTaskOwner(userId, taskId); Assertions."<AssertPlaceHolder>"; }
isTaskOwner( final Long userId, final Long taskId ) { return userRepository.isTaskOwner(userId, taskId); }
[*] target: assertFalse(isOwner)
[-] pred: org. junit. Assert. assertFalse ( isOwner )
************************************
************************************
[+] input: testBadHead() { boolean a = false; try { TestSuite.IRIS_DATASET.head(0); } catch (IllegalArgumentException i) { a = true; } finally { "<AssertPlaceHolder>"; } }
head(int numRows) { System.out.println(TABLE_FORMATTER.format(buildHead(numRows))); }
[*] target: assertTrue(a)
[-] pred: org. junit. Assert. assertTrue ( a )
************************************
************************************
[+] input: shouldFindUrlByShortUrl() { //given String shortUrl = "abc123"; //when Optional<Url> optionalActual = this.urlRepository.findByShortUrl("abc123"); String actual = optionalActual.get().getOriginalUrl(); //then String expected = "https://www.linkedin.com/in/cami-la/"; Assertions."<AssertPlaceHolder>"; }
findByShortUrl(String shortUrl);
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldfindUrlByOriginalUrl() { //given String originalUrl = "https://github.com/cami-la"; //when Optional<Url> optionalActual = this.urlRepository.findByOriginalUrl(originalUrl); String actual = optionalActual.get().getShortUrl(); //then String expected = "xyz123"; Assertions."<AssertPlaceHolder>"; }
findByOriginalUrl(String originalUrl);
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: searchFromEs() { PostQueryRequest postQueryRequest = new PostQueryRequest(); postQueryRequest.setUserId(1L); Page<Post> postPage = postService.searchFromEs(postQueryRequest); Assertions."<AssertPlaceHolder>"; }
searchFromEs(PostQueryRequest postQueryRequest);  /** * 获取帖子封装 * * @param post  * @return */ PostVO getPostVO(Post post);  /** * 分页获取帖子封装 * * @param postPage  * @return */ Page<PostVO> getPostVOPage(Page<Post> postPage);  /** * 文章列表voby页面 * * @param postQueryRequest 查询请求后 请求 * @return {@link Page}
[*] target: assertNotNull(postPage)
[-] pred: org. junit. Assert. assertNotNull ( postPage )
************************************
************************************
[+] input: checkCardOwner_Fail() { // given int nonExistentCardId = 999; when(cardBoardRepository.findCardBoardByUserId(userId)).thenReturn(cardBoard);  // when boolean result = cardBoardUseCase.checkCardOwner(userId, nonExistentCardId);  // then "<AssertPlaceHolder>"; verify(cardBoardRepository, times(1)).findCardBoardByUserId(userId); }
checkCardOwner(int userId, int cardId) { CardBoard cardBoard = cardBoardRepository.findCardBoardByUserId(userId); isCardBoardNotFound(cardBoard); return cardBoard.isCardOwner(userId, cardId); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: JsonProcessingException { var serialized = jsonProvider.getMapper().writerWithDefaultPrettyPrinter().writeValueAsString(subject); for (int i = 0; i < 1000; i++) { HubContent other = new HubContent(); other.setDemo(subject.getDemo()); var entities = subject.getAll(); other.setErrors(subject.getErrors()); List<Object> entityList = new ArrayList<>(entities); Collections.shuffle(entityList); other.putAll(entityList); var otherSerialized = jsonProvider.getMapper().writerWithDefaultPrettyPrinter().writeValueAsString(other); "<AssertPlaceHolder>"; } }
putAll(Collection<?> entity) { for (Object e : entity) put(e); }
[*] target: assertEquals(serialized, otherSerialized)
[-] pred: org. junit. Assert. assertEquals ( serialized, otherSerialized )
************************************
************************************
[+] input: getInstrumentsOfLibraryId() { var result = subject.getInstrumentsOfLibrary(library1.getId());  "<AssertPlaceHolder>"; }
size() { return store.values().stream() .mapToInt(Map::size) .sum(); }
[*] target: assertEquals(2, result.size())
[-] pred: org. junit. Assert. assertEquals ( 2, result. size() )
************************************
************************************
[+] input: createCompletion() { CreateCompletionRequest request = new CreateCompletionRequest(); request.setModel("text-davinci-003"); request.setPrompt("我的提问"); CreateCompletionResponse response = openAiApi.createCompletion(request, OPENAI_API_KEY); Assertions."<AssertPlaceHolder>"; }
createCompletion(CreateCompletionRequest request, String openAiApiKey) { if (StringUtils.isBlank(openAiApiKey)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, "未传 openAiApiKey"); } String url = "https://api.openai.com/v1/completions"; String json = JSONUtil.toJsonStr(request); String result = HttpRequest.post(url) .header("Authorization", "Bearer " + openAiApiKey) .body(json) .execute() .body(); return JSONUtil.toBean(result, CreateCompletionResponse.class); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: listTopics() { ListTopicsRequest request = new ListTopicsRequest(); request.setScope("unanswered_questions"); request.setCount(30); request.setGroupId("知识星球id"); ListTopicsResponse listTopicsResponse = zsxqApi.listTopics(request, COOKIE); Assertions."<AssertPlaceHolder>"; }
listTopics(ListTopicsRequest request, String cookie) { String groupId = request.getGroupId(); if (StringUtils.isBlank(groupId)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, "未传 groupId"); } if (StringUtils.isBlank(cookie)) { throw new BusinessException(ErrorCode.PARAMS_ERROR, "未传 cookie"); } String url = String.format("https://api.zsxq.com/v2/groups/%s/topics", groupId); Map<String, Object> stringObjectMap = BeanUtil.beanToMap(request); String query = URLUtil.buildQuery(stringObjectMap, StandardCharsets.UTF_8); String result = HttpRequest.get(url) .header("cookie", cookie) .header("user-agent", USER_AGENT) .body(query) .execute() .body(); return JSONUtil.toBean(result, ListTopicsResponse.class); }
[*] target: assertNotNull(listTopicsResponse)
[-] pred: org. junit. Assert. assertNotNull ( listTopicsResponse )
************************************
************************************
[+] input: invokeCount() { boolean b = userInterfaceInfoService.invokeCount(1L, 1L); Assertions."<AssertPlaceHolder>"; }
invokeCount(long interfaceInfoId, long userId);
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
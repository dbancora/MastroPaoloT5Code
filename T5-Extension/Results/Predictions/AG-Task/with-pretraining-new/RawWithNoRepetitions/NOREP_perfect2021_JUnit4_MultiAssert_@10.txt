[+] input: testRangeMergeOnly() {  AckRangeSet set = new AckRangeSet(); set.add(0, 1); set.add(1, 101); set.add(101, 201); set.add(201, 301); set.add(301, 401); set.add(201, 301); set.add(501, 601);  List<AckRange> rangesList = convertToOrderedList(set.getRanges()); "<AssertPlaceHolder>"; assertRangeEquals(0, 401, rangesList.get(0)); assertRangeEquals(501, 601, rangesList.get(1));  }
getRanges() { return ranges; }
[*] target: assertEquals(2, rangesList.size())
[-] pred: org. junit. Assert. assertEquals ( 2, rangesList. size ( ) )
************************************
************************************
[+] input: testRangeMergeAbove() {  AckRangeSet set = new AckRangeSet(); set.add(0, 1); set.add(1, 101); set.add(201, 301); set.add(101, 201); set.add(401, 501);  List<AckRange> rangesList = convertToOrderedList(set.getRanges()); "<AssertPlaceHolder>"; assertRangeEquals(0, 301, rangesList.get(0)); assertRangeEquals(401, 501, rangesList.get(1));  }
getRanges() { return ranges; }
[*] target: assertEquals(2, rangesList.size())
[-] pred: org. junit. Assert. assertEquals ( 2, rangesList. size ( ) )
************************************
************************************
[+] input: Exception { CollectorFormatter minF = new CollectorFormatter("{7}", (Formatter) null, (Comparator<LogRecord>) null);  tickMilli(); //Make sure the max not equal to the start time.  final String min = minF.getTail((Handler) null); NumberFormat.getIntegerInstance().parse(min); tickMilli();  //Next min is not old min. String next = minF.getTail((Handler) null); assertFalse(min + ' ' + next, min.equals(next));  //All mins start at the init time. CollectorFormatter initF = new CollectorFormatter("{10}", (Formatter) null, (Comparator<LogRecord>) null);  next = initF.getTail((Handler) null); "<AssertPlaceHolder>"; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }
[*] target: assertEquals(min, next)
[-] pred: org. junit. Assert. assertEquals ( min, next )
************************************
************************************
[+] input: Exception { final String p = CollectorFormatter.class.getName(); Properties props = new Properties(); final String expect = CollectorFormatterTest.class.getName(); props.put(p.concat(".format"), expect); LogManager manager = LogManager.getLogManager(); try { read(manager, props); CollectorFormatter cf = new CollectorFormatter(); LogRecord first = new LogRecord(Level.SEVERE, Level.SEVERE.getName()); assertEquals("", cf.format(first)); String result = cf.getTail((Handler) null); "<AssertPlaceHolder>"; } finally { manager.reset(); } }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }
[*] target: assertEquals(expect, result)
[-] pred: org. junit. Assert. assertEquals ( expect, result )
************************************
************************************
[+] input: Exception { LogRecord record = new LogRecord(Level.SEVERE, ""); try { long expected = 10L; if (Thread.currentThread().getId() == expected) { ++expected; } setLongThreadID(record, expected); assertNotEquals(expected, Thread.currentThread().getId());  CompactFormatter cf = new CompactFormatter("%10$d"); String output = cf.format(record); String expect = Long.toString(expected); assertEquals(expect, output);  setLongThreadID(record, -1L); output = cf.format(record); expect = Long.toString(-1L); assertEquals(expect, output);  //Test that downcast works right. Number id = cf.formatThreadID(record); assertEquals(-1, id.intValue()); assertEquals(expect, Long.toString(id.longValue()));  setLongThreadID(record, Long.MAX_VALUE >>> 1L); output = cf.format(record); expect = Long.toString(Long.MAX_VALUE >>> 1L); "<AssertPlaceHolder>";  int tid = getIntThreadID(record); assertTrue(String.valueOf(tid), tid < 0); } catch (NoSuchMethodException JDK8245302) { try { Method m = LogRecord.class.getMethod("getLongThreadID"); fail(m.toString()); } catch (NoSuchMethodException expect) { assertNull(LogManagerProperties.getLongThreadID(record)); } } }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }
[*] target: assertEquals(expect, output)
[-] pred: org. junit. Assert. assertEquals ( expect, output )
************************************
************************************
[+] input: Exception { String prefix = LogManagerPropertiesTest.class.getName(); Properties parent = new Properties(); LogManagerProperties mp = new LogManagerProperties(parent, prefix); String key = "key"; Object value = TimeUnit.MILLISECONDS; assertNull(mp.put(key, value)); Object newValue = TimeUnit.NANOSECONDS; assertEquals(value, mp.put(key, newValue)); "<AssertPlaceHolder>"; }
get(final Object key) { Object value; if (key instanceof String) { value = getProperty((String) key); } else { value = null; }  //Search for non-string value. if (value == null) { value = defaults.get(key); if (value == null && !defaults.containsKey(key)) { value = super.get(key); } } return value; }
[*] target: assertEquals(newValue, mp.get(key))
[-] pred: org. junit. Assert. assertEquals ( newValue, mp. get( key ) )
************************************
************************************
[+] input: testEquals() { MailHandler h = new MailHandler(); assertFalse(h.equals((Object) null)); assertNotEquals(h, new MailHandler()); "<AssertPlaceHolder>"; }
equals(Object o) { if (o instanceof TailNameFormatter) { return name.equals(((TailNameFormatter) o).name); } return false; }
[*] target: assertTrue(h.equals(h))
[-] pred: org. junit. Assert. assertTrue ( h. equals(h ) )
************************************
************************************
[+] input: testLevelAfterClose() { MailHandler instance = new MailHandler(createInitProperties("")); InternalErrorManager em = new InternalErrorManager(); instance.setErrorManager(em);  instance.setLevel(Level.WARNING); instance.setFormatter(new LevelCheckingFormatter(Level.OFF)); instance.publish(new CloseLogRecord(Level.SEVERE, "", instance)); assertEquals(Level.OFF, instance.getLevel());  instance.close(); boolean failed = false; for (Exception exception : em.exceptions) { Throwable t = exception; if (t instanceof MessagingException) { if (!isConnectOrTimeout(t)) { dump(t); failed = true; } } else { dump(t); failed = true; } } "<AssertPlaceHolder>"; assertFalse(em.exceptions.isEmpty()); }
close() { checkAccess(); try { Message msg = null; synchronized (this) { try { msg = writeLogRecords(ErrorManager.CLOSE_FAILURE); } finally {  //Change level after formatting. this.logLevel = Level.OFF; this.disabledLevel = null; //free reference /** * The sign bit of the capacity is set to ensure that * records that have passed isLoggable, but have yet to be * added to the internal buffer, are immediately pushed as * an email. */ if (this.capacity > 0) { this.capacity = -this.capacity; }  //Only need room for one record after closed //Ensure not inside a push. if (size == 0 && data.length != 1) { initLogRecords(1); } } }  if (msg != null) { send(msg, false, ErrorManager.CLOSE_FAILURE); } } catch (final LinkageError JDK8152515) { reportLinkageError(JDK8152515, ErrorManager.CLOSE_FAILURE); } catch (final ServiceConfigurationError sce) { reportConfigurationError(sce, ErrorManager.CLOSE_FAILURE); } }
[*] target: assertFalse(failed)
[-] pred: org. junit. Assert. assertFalse ( failed )
************************************
************************************
[+] input: Exception { Properties props = new Properties(); MailHandler instance = new MailHandler(); InternalErrorManager em = new InternalErrorManager(); instance.setErrorManager(em);  assertNotNull(instance.getMailProperties()); assertEquals(Properties.class, instance.getMailProperties().getClass());   instance.setMailProperties((Properties) null); assertTrue(instance.getMailProperties().isEmpty());  instance.setMailProperties(props); Properties stored = instance.getMailProperties();  assertNotNull(stored); assertNotSame(props, stored); assertEquals(props.getClass(), stored.getClass());  assertEquals(true, em.exceptions.isEmpty()); instance.close();  instance = createHandlerWithRecords(); props = instance.getMailProperties(); em = new InternalErrorManager(); instance.setErrorManager(em);  props.setProperty("mail.from", "localhost@localdomain"); props.setProperty("mail.to", "localhost@localdomain"); instance.setMailProperties(props); instance.flush(); boolean failed = false; for (Exception exception : em.exceptions) { final Throwable t = exception; if (!isConnectOrTimeout(t)) { dump(t); failed = true; } } assertFalse(failed); assertFalse(em.exceptions.isEmpty());  props.setProperty("mail.from", "localhost@localdomain"); props.setProperty("mail.to", "::1@@"); instance.setMailProperties(props);  em = new InternalErrorManager(); instance.setErrorManager(em);  instance.publish(new LogRecord(Level.SEVERE, "test")); instance.close(); failed = false; for (Exception exception : em.exceptions) { final Throwable t = exception; if (t instanceof AddressException || isConnectOrTimeout(t)) { continue; } dump(t); failed = true; } "<AssertPlaceHolder>"; assertFalse(em.exceptions.isEmpty()); }
close() { checkAccess(); try { Message msg = null; synchronized (this) { try { msg = writeLogRecords(ErrorManager.CLOSE_FAILURE); } finally {  //Change level after formatting. this.logLevel = Level.OFF; this.disabledLevel = null; //free reference /** * The sign bit of the capacity is set to ensure that * records that have passed isLoggable, but have yet to be * added to the internal buffer, are immediately pushed as * an email. */ if (this.capacity > 0) { this.capacity = -this.capacity; }  //Only need room for one record after closed //Ensure not inside a push. if (size == 0 && data.length != 1) { initLogRecords(1); } } }  if (msg != null) { send(msg, false, ErrorManager.CLOSE_FAILURE); } } catch (final LinkageError JDK8152515) { reportLinkageError(JDK8152515, ErrorManager.CLOSE_FAILURE); } catch (final ServiceConfigurationError sce) { reportConfigurationError(sce, ErrorManager.CLOSE_FAILURE); } }
[*] target: assertFalse(failed)
[-] pred: org. junit. Assert. assertFalse ( failed )
************************************
************************************
[+] input: testHashCode() { final SeverityComparator a = new SeverityComparator(); final SeverityComparator b = new SeverityComparator(); assertNotSame(a, b);  assertTrue(a.equals(b)); assertTrue(b.equals(a));  "<AssertPlaceHolder>"; }
hashCode() { return 31 * getClass().hashCode(); }
[*] target: assertEquals(a.hashCode(), b.hashCode())
[-] pred: org. junit. Assert. assertEquals ( a. hashCode(), b. hashCode() )
************************************
************************************
[+] input: Exception { final SeverityComparator a = new SeverityComparator(); final SeverityComparator b = serialClone(a);  assertTrue(a.equals(b)); assertTrue(b.equals(a));  "<AssertPlaceHolder>"; }
hashCode() { return 31 * getClass().hashCode(); }
[*] target: assertEquals(a.hashCode(), b.hashCode())
[-] pred: org. junit. Assert. assertEquals ( a. hashCode ( ), b. hashCode ( ) )
************************************
************************************
[+] input: test() { byte[] content = "hi there".getBytes(StandardCharsets.UTF_8); Map<String, List<String>> headers = new HashMap<>(); headers.put("x-amz-meta-color", Collections.singletonList("red")); headers.put("x-amz-meta-thing", Collections.singletonList("under")); headers.put("blah", Collections.singletonList("stuff")); Response r = new Response(headers, content, 200); assertEquals("hi there", r.contentUtf8()); assertTrue(r.isOk()); assertEquals("red", r.metadata("color").get()); assertEquals("under", r.metadata("thing").get()); assertEquals(2, r.metadata().entrySet().size()); assertEquals(3, r.headers().size()); "<AssertPlaceHolder>"; }
statusCode() { return statusCode; }
[*] target: assertEquals(200, r.statusCode())
[-] pred: org. junit. Assert. assertEquals ( 200, r. statusCode() )
************************************
************************************
[+] input: IOException { HttpURLConnection connection = Mockito.mock(HttpURLConnection.class); when(connection.getInputStream()).thenReturn(null); when(connection.getOutputStream()).thenReturn(new ByteArrayOutputStream()); when(connection.getResponseCode()).thenReturn(200); try (ResponseInputStream response = HttpClientDefault.request(connection, new byte[0])) { "<AssertPlaceHolder>"; assertEquals(-1, response.read()); assertTrue(response.headers().isEmpty()); } }
request(HttpURLConnection connection, byte[] requestBody) { int responseCode; Map<String, List<String>> responseHeaders; InputStream is; try { if (requestBody != null) { OutputStream out = connection.getOutputStream(); out.write(requestBody); out.flush(); } responseHeaders = connection.getHeaderFields(); responseCode = connection.getResponseCode(); if (isOk(responseCode)) { is = connection.getInputStream(); } else { is = connection.getErrorStream(); } if (is == null) { is = Util.emptyInputStream(); } } catch (IOException e) { try { connection.disconnect(); } catch (Throwable e2) { // ignore } throw new UncheckedIOException(e); } return new ResponseInputStream(connection, responseCode, responseHeaders, is); }
[*] target: assertEquals(200, response.statusCode())
[-] pred: org. junit. Assert. assertEquals ( 200, response. statusCode ( ) )
************************************
************************************
[+] input: Exception { Properties properties = new Properties(); properties.put(DataSourceFactory.JDBC_DATABASE_NAME, "db"); properties.put("currentSchema", "schema"); DataSource dataSource = dataSourceFactory.createDataSource(properties); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dataSource instanceof SimpleDataSource); SimpleDataSource simpleDataSource = (SimpleDataSource) dataSource; Assert.assertEquals("db", simpleDataSource.getDatabaseName()); Assert.assertEquals("schema", simpleDataSource.getCurrentSchema()); }
createDataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); if (props.containsKey(JDBC_INITIAL_POOL_SIZE) || props.containsKey(JDBC_MIN_POOL_SIZE) || props.containsKey(JDBC_MAX_POOL_SIZE) || props.containsKey(JDBC_MAX_IDLE_TIME) || props.containsKey(JDBC_MAX_STATEMENTS)) { return createPoolingDataSource(props); } else { return createSimpleDataSource(props); } }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: Exception { Properties properties = new Properties(); properties.put(DataSourceFactory.JDBC_DATABASE_NAME, "db"); properties.put(DataSourceFactory.JDBC_INITIAL_POOL_SIZE, "5"); properties.put(DataSourceFactory.JDBC_MAX_POOL_SIZE, "10"); DataSource dataSource = dataSourceFactory.createDataSource(properties); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dataSource instanceof PoolingDataSource); PoolingDataSource poolingDataSource = (PoolingDataSource) dataSource; Assert.assertEquals("db", poolingDataSource.getDatabaseName()); Assert.assertEquals(5, poolingDataSource.getInitialConnections()); Assert.assertEquals(10, poolingDataSource.getMaxConnections()); }
createDataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); if (props.containsKey(JDBC_INITIAL_POOL_SIZE) || props.containsKey(JDBC_MIN_POOL_SIZE) || props.containsKey(JDBC_MAX_POOL_SIZE) || props.containsKey(JDBC_MAX_IDLE_TIME) || props.containsKey(JDBC_MAX_STATEMENTS)) { return createPoolingDataSource(props); } else { return createSimpleDataSource(props); } }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: Exception { Properties properties = new Properties(); properties.put(DataSourceFactory.JDBC_DATABASE_NAME, "db"); ConnectionPoolDataSource dataSource = dataSourceFactory.createConnectionPoolDataSource(properties); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dataSource instanceof ConnectionPool); ConnectionPool connectionPoolDataSource = (ConnectionPool) dataSource; Assert.assertEquals("db", connectionPoolDataSource.getDatabaseName()); }
createConnectionPoolDataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); ConnectionPool dataSource = new ConnectionPool(); configureBaseDataSource(dataSource, props); return dataSource; }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: Exception { Properties properties = new Properties(); properties.put(DataSourceFactory.JDBC_DATABASE_NAME, "db"); XADataSource dataSource = dataSourceFactory.createXADataSource(properties); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dataSource instanceof PGXADataSource); PGXADataSource xaDataSource = (PGXADataSource) dataSource; Assert.assertEquals("db", xaDataSource.getDatabaseName()); }
createXADataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); PGXADataSource dataSource = new PGXADataSource(); configureBaseDataSource(dataSource, props); return dataSource; }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: testUpdateActionsFromPaths_basic() { Set<UpdateAction> expectedActions = EnumSet.of(UpdateAction.CLIENT, UpdateAction.FUNCTIONS); List<Path> changedPaths = List.of( Path.of("client/web/src/App.js"), Path.of("functions/onboarding-app-stack-listener/pom.xml")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(changedPaths); "<AssertPlaceHolder>"; actualActions.forEach(action -> { if (action == UpdateAction.FUNCTIONS) { assertEquals(1, action.getTargets().size()); assertEquals(1, UpdateAction.FUNCTIONS.getTargets().size()); assertTrue(action.getTargets().contains("onboarding-app-stack-listener")); } }); }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: testUpdateActionsFromPaths_layersFirst() { Set<UpdateAction> expectedActions = EnumSet.of(UpdateAction.LAYERS, UpdateAction.CLIENT, UpdateAction.FUNCTIONS); List<Path> changedPaths = List.of( Path.of("client/web/src/App.js"), Path.of("functions/onboarding-app-stack-listener/pom.xml"), Path.of("layers/apigw-helper/pom.xml")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(changedPaths); "<AssertPlaceHolder>"; // the first item in the set iterator should always be LAYERS // (meaning we update layers first) regardless of changedPath ordering assertTrue(actualActions.iterator().next().name().equals("LAYERS")); }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: testUpdateActionsFromPaths_customResourcesPath() { Set<UpdateAction> expectedActions = EnumSet.of(UpdateAction.CUSTOM_RESOURCES, UpdateAction.RESOURCES); List<Path> changedPaths = List.of( Path.of("resources/saas-boost.yaml"), Path.of("resources/custom-resources/app-services-macro/pom.xml")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(changedPaths); "<AssertPlaceHolder>"; actualActions.forEach(action -> { if (action == UpdateAction.RESOURCES) { assertEquals(1, action.getTargets().size()); assertTrue(action.getTargets().contains("saas-boost.yaml")); } if (action == UpdateAction.CUSTOM_RESOURCES) { assertEquals(1, action.getTargets().size()); assertTrue(action.getTargets().contains("app-services-macro")); } }); }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: testUpdateActionsFromPaths_newPath() { Path newResource = Path.of("resources/saas-boost-newtemplate.yaml"); createFile(newResource); Set<UpdateAction> expectedActions = EnumSet.of(UpdateAction.RESOURCES); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(List.of(newResource)); "<AssertPlaceHolder>"; actualActions.forEach(action -> { if (action == UpdateAction.RESOURCES) { assertEquals(1, action.getTargets().size()); assertTrue(action.getTargets().contains("saas-boost-newtemplate.yaml")); } }); }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: testResourceName() { String serviceName = "foo"; String expected = "foo"; String actual = ApplicationServicesMacro.ecrResourceName(serviceName); assertEquals(expected, actual);  serviceName = "Foo"; expected = "Foo"; actual = ApplicationServicesMacro.ecrResourceName(serviceName); assertEquals(expected, actual);  serviceName = "Foo Bar"; expected = "FooBar"; actual = ApplicationServicesMacro.ecrResourceName(serviceName); assertEquals(expected, actual);  serviceName = "Foo_Bar"; expected = "FooBar"; actual = ApplicationServicesMacro.ecrResourceName(serviceName); assertEquals(expected, actual);  serviceName = "Foo-Bar"; expected = "FooBar"; actual = ApplicationServicesMacro.ecrResourceName(serviceName); "<AssertPlaceHolder>"; }
ecrResourceName(String serviceName) { if (Utils.isBlank(serviceName)) { throw new IllegalArgumentException("service name cannot be blank"); } return cloudFormationResourceName(serviceName); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************

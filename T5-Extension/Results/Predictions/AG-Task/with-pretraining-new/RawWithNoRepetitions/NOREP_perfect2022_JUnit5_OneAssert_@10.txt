[+] input: parse_ShouldParseTextAndReturnAsNumber() { String valueAsString = "10"; Integer expected = TypeCodecs.INT.parse(valueAsString); Integer result = codec.parse(valueAsString); Assertions."<AssertPlaceHolder>"; }
parse(String value) { return value == null ? null : Integer.parseInt(value); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: shouldReturnSalaryWithIncrement() { //given double percentualIncrement = 10; //when BigDecimal actual = this.employee.incremetSalary(percentualIncrement); //then BigDecimal expected = BigDecimal.valueOf(110.0); Assertions."<AssertPlaceHolder>"; }
incremetSalary(double percentageIncrease) { BigDecimal percentagemIncreaseBigDecimal = BigDecimal.valueOf(1 + (percentageIncrease / 100)); return this.salary.multiply(percentagemIncreaseBigDecimal); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testAListIsNull() { when(a.getAgentIds()).thenReturn(null); when(b.getAgentIds()).thenReturn(mock(List.class)); int count = agentGroupUtil.sortAgentGroup(a, b); Assertions."<AssertPlaceHolder>"; }
sortAgentGroup(AgentGroupEntity a, AgentGroupEntity b) { List<String> agentIdsOfA = a.getAgentIds(); List<String> agentIdsOfB = b.getAgentIds(); if (null == agentIdsOfA && null == agentIdsOfB) { return 0; } if (null == agentIdsOfA) { return 1; } if (null == agentIdsOfB) { return -1; } return agentIdsOfB.size() - agentIdsOfA.size(); }
[*] target: assertEquals(1, count)
[-] pred: org. junit. Assert. assertEquals ( 1, count )
************************************
************************************
[+] input: testUpdate() { User user = new User(); user.setName("李四"); user.setAge(17); user.setId(1L); int update = commonDao.update(user); Assertions."<AssertPlaceHolder>"; }
update(T params);  /** * 根据主键选择一个对象 * * @param id  关键字 * @param cls 指定一个实体 * @return result */ @SelectProvider(type = SqlBuilder.class, method = "select") <T> Map<?,?> select(@Param("id") T id, Class<?> cls);  /** * 查询列表条数跟 selectList 配对使用 * * @param params param * @param <T> param type * @return count */ @SelectProvider(type = SqlBuilder.class, method = "selectCount") <T> long selectCount(T params);  /** * 查询列表 * * @param params param * @return result */ @SelectProvider(type = SqlBuilder.class, method = "selectList") <T> List<Map<?,?>> selectList(T params);   /** * 自定义查询列表结果 * * @param params param * @return result */ @Select(" ${selfSQL}
[*] target: assertEquals(1, update)
[-] pred: org. junit. Assert. assertEquals ( 1, update )
************************************
************************************
[+] input: IOException { DynamicKafkaSourceSplitSerializer serializer = new DynamicKafkaSourceSplitSerializer(); DynamicKafkaSourceSplit dynamicKafkaSourceSplit = new DynamicKafkaSourceSplit( "test-cluster", new KafkaPartitionSplit(new TopicPartition("test-topic", 3), 1)); DynamicKafkaSourceSplit dynamicKafkaSourceSplitAfterSerde = serializer.deserialize(1, serializer.serialize(dynamicKafkaSourceSplit)); "<AssertPlaceHolder>"; }
serialize(DynamicKafkaSourceSplit split) throws IOException { try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); DataOutputStream out = new DataOutputStream(baos)) { out.writeUTF(split.getKafkaClusterId()); out.writeInt(kafkaPartitionSplitSerializer.getVersion()); out.write(kafkaPartitionSplitSerializer.serialize(split.getKafkaPartitionSplit())); out.flush(); return baos.toByteArray(); } }
[*] target: assertEquals(dynamicKafkaSourceSplit, dynamicKafkaSourceSplitAfterSerde)
[-] pred: org. junit. Assert. assertEquals ( dynamicKafkaSourceSplit, dynamicKafkaSourceSplitAfterSerde )
************************************
************************************
[+] input: testEnabled() { NotificationRule rule = new NotificationRule(); rule.setEnabled(true); Assertions."<AssertPlaceHolder>"; }
isEnabled() { return enabled; }
[*] target: assertTrue(rule.isEnabled())
[-] pred: org. junit. Assert. assertTrue ( rule. isEnabled() )
************************************
************************************
[+] input: testInsertBatch() { List<User> userList = new ArrayList<>(); { User user = new User(); user.setName("张三") .setAge(18) .setCreateTime(LocalDateTime.now()); userList.add(user); } { User user = new User(); user.setName("李四") .setAge(17) .setCreateTime(LocalDateTime.now()); userList.add(user); } int insert = commonDaoWrap.insertBatch(userList); Assertions."<AssertPlaceHolder>"; }
insertBatch(List<E> list) {  if (CollectionUtils.isEmpty(list)) { throw new NonTransientDataAccessResourceException("The list cannot be empty !!!"); } return dao.insertBatch(list); }
[*] target: assertEquals(2, insert)
[-] pred: org. junit. Assert. assertEquals ( 2, insert )
************************************
************************************
[+] input: testMaskFixedFormatNoChange() { DefaultMaskingConfiguration configuration = new DefaultMaskingConfiguration(); configuration.setValue("datetime.format.fixed", "dd-MM-yyyy HH:mm:ss"); configuration.setValue("datetime.year.mask", false); configuration.setValue("datetime.month.mask", false); configuration.setValue("datetime.day.mask", false); configuration.setValue("datetime.hour.mask", false); configuration.setValue("datetime.minutes.mask", false); configuration.setValue("datetime.seconds.mask", false);  DateTimeMaskingProvider maskingProvider = new DateTimeMaskingProvider(configuration); String originalDateTime = "08-12-1981 00:00:00"; String maskedDateTime = maskingProvider.mask(originalDateTime); "<AssertPlaceHolder>"; }
mask(String identifier) { final DateTimeFormatter dateTimeFormatter; final Date date;  if (fixedDateFormat == null) { Tuple<DateTimeFormatter, TemporalAccessor> matchingFormat = dateTimeIdentifier.matchingFormat(identifier); if (matchingFormat == null) { if (dateTimeIdentifier.isTemporal(identifier)) { return temporalMaskingProvider.mask(identifier); }  if (returnOriginalOnUnknownFormat) { return identifier; }  return handleError(identifier, defaultDateFormat); }  dateTimeFormatter = matchingFormat.getFirst(); date = Date.from(Instant.from(matchingFormat.getSecond())); } else { dateTimeFormatter = buildFormatter(this.fixedDateFormat);  try { TemporalAccessor t = dateTimeFormatter.withZone(ZoneOffset.systemDefault()).parse(identifier); date = Date.from(Instant.from(t)); } catch (DateTimeParseException e) { return handleError(identifier, dateTimeFormatter); } }  Calendar cal = Calendar.getInstance(); cal.setTime(date); Calendar originalCal = (Calendar) cal.clone();  if (shiftDate) { cal.add(Calendar.SECOND, this.shiftSeconds); return dateTimeFormatter.withZone(ZoneOffset.systemDefault()).format(cal.getTime().toInstant()); }  if (generalizeWeekYear) { int originalYear = cal.get(Calendar.YEAR); int originalWeek = cal.get(Calendar.WEEK_OF_YEAR); return String.format("%02d/%d", originalWeek, originalYear);  }  if (generalizeMonthYear) { int originalYear = cal.get(Calendar.YEAR); int originalMonth = cal.get(Calendar.MONTH); return String.format("%02d/%d", originalMonth + 1, originalYear);  }  if (generalizeQuarterYear) { int originalYear = cal.get(Calendar.YEAR); int originalMonth = cal.get(Calendar.MONTH);  int quarter = originalMonth / 3; return String.format("%02d/%d", quarter + 1, originalYear);  }  if (generalizeYear) { int originalYear = cal.get(Calendar.YEAR); return Integer.toString(originalYear); }  if (generalizeNYearInterval) { int nValue = this.generalizeNYearIntervalValue; int originalYear = cal.get(Calendar.YEAR); int base = originalYear - (originalYear % nValue); return String.format("%d-%d", base, base + nValue); }  if (replaceDaySameClass) { int day = cal.get(Calendar.DAY_OF_WEEK); if (day >= Calendar.MONDAY && day <= Calendar.FRIDAY) { int randomWeekday = Calendar.MONDAY + random.nextInt(5); int diff = randomWeekday - day; cal.add(Calendar.DAY_OF_MONTH, diff); } else { boolean flip = random.nextBoolean(); if (flip) { int diff = day == Calendar.SATURDAY ? 1 : -1; cal.add(Calendar.DAY_OF_MONTH, diff); } }  return dateTimeFormatter.withZone(ZoneOffset.systemDefault()).format(cal.getTime().toInstant()); }  if (yearMask) { int originalYear = cal.get(Calendar.YEAR); int randomYear = RandomGenerators.randomWithinRange(originalYear, yearRangeDown, yearRangeUp); cal.add(Calendar.YEAR, randomYear - originalYear); }  if (monthMask) { int originalMonth = cal.get(Calendar.MONTH); int randomMonth = RandomGenerators.randomWithinRange(originalMonth, monthRangeDown, monthRangeUp); cal.add(Calendar.MONTH, randomMonth - originalMonth); }  if (dayMask) { int originalDay = cal.get(Calendar.DAY_OF_MONTH); int randomDay = RandomGenerators.randomWithinRange(originalDay, dayRangeDown, dayRangeUp); cal.add(Calendar.DAY_OF_MONTH, randomDay - originalDay); }  if (hourMask) { int originalHour = cal.get(Calendar.HOUR_OF_DAY); int randomHour = RandomGenerators.randomWithinRange(originalHour, hourRangeDown, hourRangeUp); cal.add(Calendar.HOUR_OF_DAY, randomHour - originalHour); }  if (minutesMask) { int originalMinutes = cal.get(Calendar.MINUTE); int randomMinutes = RandomGenerators.randomWithinRange(originalMinutes, minutesRangeDown, minutesRangeUp); cal.add(Calendar.MINUTE, randomMinutes - originalMinutes); }  if (secondsMask) { int originalSeconds = cal.get(Calendar.SECOND); int randomSeconds = RandomGenerators.randomWithinRange(originalSeconds, secondsRangeDown, secondsRangeUp); cal.add(Calendar.SECOND, randomSeconds - originalSeconds); }  if (!yearMask) { cal.set(Calendar.YEAR, originalCal.get(Calendar.YEAR)); } if (!monthMask) { cal.set(Calendar.MONTH, originalCal.get(Calendar.MONTH)); } if (!dayMask) { cal.set(Calendar.DAY_OF_MONTH, originalCal.get(Calendar.DAY_OF_MONTH)); } if (!hourMask) { cal.set(Calendar.HOUR_OF_DAY, originalCal.get(Calendar.HOUR_OF_DAY)); } if (!minutesMask) { cal.set(Calendar.MINUTE, originalCal.get(Calendar.MINUTE)); } if (!secondsMask) { cal.set(Calendar.SECOND, originalCal.get(Calendar.SECOND)); }  if (trimTimeToHourInterval) { cal.set(Calendar.HOUR_OF_DAY, toInterval(originalCal.get(Calendar.HOUR_OF_DAY), numberOfHourIntervals)); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); }  LocalDateTime givenDate = LocalDateTime.ofInstant(cal.toInstant(), ZoneId.systemDefault()); return givenDate.format(dateTimeFormatter); }
[*] target: assertEquals(originalDateTime, maskedDateTime)
[-] pred: org. junit. Assert. assertEquals ( originalDateTime, maskedDateTime )
************************************
************************************
[+] input: whenObjectAreSame_ThenEqualsReturnsTrue() { GroupKey id1 = new GroupKey("group-1");  "<AssertPlaceHolder>"; }
equals(@Nullable Object o) { if (this == o) { return true; }  if (o == null || getClass() != o.getClass()) { return false; }  GroupKey other = (GroupKey) o; return this.id.equals(other.id); }
[*] target: assertTrue(id1.equals(id1))
[-] pred: org. junit. Assert. assertTrue ( id1. equals ( id1 ) )
************************************
************************************
[+] input: testGetAlertConverge() {  long convergeId = 1L; AlertConverge alertConverge = new AlertConverge(); when(alertConvergeDao.findById(convergeId)).thenReturn(Optional.of(alertConverge)); AlertConverge result = alertConvergeService.getAlertConverge(convergeId);  verify(alertConvergeDao, times(1)).findById(convergeId); "<AssertPlaceHolder>"; }
getAlertConverge(long convergeId) throws RuntimeException;
[*] target: assertEquals(alertConverge, result)
[-] pred: org. junit. Assert. assertEquals ( alertConverge, result )
************************************
************************************
[+] input: Exception { KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("SM2", PROVIDER); KeyPair keyPair = keyPairGen.generateKeyPair(); ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic(); ECPoint pubKeyPoint = pubKey.getW(); boolean onCurve = checkPointOnCurve(pubKeyPoint); Assertions."<AssertPlaceHolder>"; }
generateKeyPair() { if (random == null) { random = JCAUtil.getSecureRandom(); }  if (keyPairGen == null) { keyPairGen = new ECKeyPairGenerator();  try { keyPairGen.initialize(SM2ParameterSpec.instance(), random); } catch (InvalidAlgorithmParameterException e) { // Unlikely happen throw new IllegalArgumentException(e); } }  KeyPair keyPair = keyPairGen.generateKeyPair(); ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic(); ECPrivateKey priKey = (ECPrivateKey) keyPair.getPrivate(); return new KeyPair( new SM2PublicKey(pubKey.getW()), new SM2PrivateKey(priKey.getS())); }
[*] target: assertTrue(onCurve)
[-] pred: org. junit. Assert. assertTrue ( onCurve )
************************************
************************************
[+] input: testMd5() { Component component = new Component(); String hash = "299189766eddf8b5fea4954f0a63d4b1"; component.setMd5(hash); Assertions."<AssertPlaceHolder>"; }
getMd5() { return md5; }
[*] target: assertEquals(hash, component.getMd5())
[-] pred: org. junit. Assert. assertEquals ( hash, component. getMd5() )
************************************
************************************
[+] input: proxy() { interface InterfaceA {} interface InterfaceB {}  Object proxyObject = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] {InterfaceA.class, InterfaceB.class}, new SerializableInvocationHandler());  byte[] actualData = SerialBuilder.startSerializableObject() .beginDescriptorHierarchy() .proxyDescriptor(InterfaceA.class, InterfaceB.class) .beginDescriptor() .typeWithUid(Proxy.class) .flags(SC_SERIALIZABLE) .beginObjectFieldDescriptors() .objectField("h", InvocationHandler.class) .endObjectFieldDescriptors() .endDescriptor() .endDescriptorHierarchy() .beginSlots() .beginSlot() .beginObjectFields() .beginSerializableObject() .beginDescriptorHierarchy() .beginDescriptor() .type(SerializableInvocationHandler.class) .uid(SerializableInvocationHandler.serialVersionUID) .flags(SC_SERIALIZABLE) .endDescriptor() .endDescriptorHierarchy() .endObject() .endObjectFields() .endSlot() .beginSlot() .endSlot() .endSlots() .endObject();  byte[] expectedData = serialize((Serializable) proxyObject); "<AssertPlaceHolder>"; }
startSerializableObject() { return startSerializableObject(new Handle()); }
[*] target: assertArrayEquals(expectedData, actualData)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedData, actualData )
************************************
************************************
[+] input: testSaveServiceRoleHostMapping() { // Setup final ServiceRoleHostMapping serviceRoleHostMapping = new ServiceRoleHostMapping(); serviceRoleHostMapping.setServiceRole("serviceRole"); serviceRoleHostMapping.setHosts(Arrays.asList("value")); final List<ServiceRoleHostMapping> list = Arrays.asList(serviceRoleHostMapping); final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  // Configure ClusterInfoService.getById(...). final ClusterInfoEntity clusterInfoEntity = new ClusterInfoEntity(); clusterInfoEntity.setId(0); clusterInfoEntity.setCreateBy("createBy"); clusterInfoEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterInfoEntity.setClusterName("clusterName"); clusterInfoEntity.setClusterCode("clusterCode"); clusterInfoEntity.setClusterFrame("clusterFrame"); clusterInfoEntity.setFrameVersion("frameVersion"); clusterInfoEntity.setClusterState(ClusterState.RUNNING); clusterInfoEntity.setFrameId(0); final UserInfoEntity userInfoEntity = new UserInfoEntity(); userInfoEntity.setId(0); userInfoEntity.setUsername("username"); userInfoEntity.setPassword("password"); userInfoEntity.setEmail("email"); userInfoEntity.setPhone("phone"); clusterInfoEntity.setClusterManagerList(Arrays.asList(userInfoEntity)); when(mockClusterInfoService.getById(0)).thenReturn(clusterInfoEntity);  // Run the test final Result result = serviceInstallServiceImplUnderTest.saveServiceRoleHostMapping(0, list);  // Verify the results "<AssertPlaceHolder>"; }
saveServiceRoleHostMapping(Integer clusterId, List<ServiceRoleHostMapping> list) {  checkOnSameNode(clusterId, list);  ClusterInfoEntity clusterInfo = clusterInfoService.getById(clusterId); String hostMapKey = clusterInfo.getClusterCode() + Constants.UNDERLINE + Constants.SERVICE_ROLE_HOST_MAPPING; HashMap<String, List<String>> map = new HashMap<>(); if (CacheUtils.constainsKey(hostMapKey)) { map = (HashMap<String, List<String>>) CacheUtils.get(hostMapKey); }  for (ServiceRoleHostMapping serviceRoleHostMapping : list) { serviceValidation(serviceRoleHostMapping);  map.put(serviceRoleHostMapping.getServiceRole(), serviceRoleHostMapping.getHosts());  ServiceRoleStrategy serviceRoleHandler = ServiceRoleStrategyContext.getServiceRoleHandler( serviceRoleHostMapping.getServiceRole()); String serviceName = ServiceRoleStrategyContext.getServiceName( serviceRoleHostMapping.getServiceRole()); if (Objects.nonNull(serviceRoleHandler)) { serviceRoleHandler.handler(clusterId, serviceRoleHostMapping.getHosts(), serviceName); } }  CacheUtils.put( clusterInfo.getClusterCode() + Constants.UNDERLINE + Constants.SERVICE_ROLE_HOST_MAPPING, map); return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: setProperty_Boolean() { Boolean value = true; Boolean setValue = (Boolean) helper.setProperty(KnownProperties.TEST_BOOLEAN, value); "<AssertPlaceHolder>"; }
setProperty(String propertyName, Object propertyValue) { if (null == propertyName || null == propertyValue) return null; PropertyType expectedType = getType(propertyName); if (null == expectedType) { return null; }  boolean typesMatch = validateType(expectedType, propertyValue); if (!typesMatch) return null;  synchronized (PropertyHelper.class) { propertyMap.put(propertyName, propertyValue); } return propertyValue; }
[*] target: assertEquals(value, setValue)
[-] pred: org. junit. Assert. assertEquals ( value, setValue )
************************************
************************************
[+] input: 종목토론방_댓글_생성하기() { // given Discussion expected = Discussion.builder() .userId(MEMBER_ID) .webtoonId(WEBTOON_ID) .content(CONTENT) .build();  Mockito.when(discussionRepository.save(any())) .thenReturn(expected);  // when var actual = discussionService.save(MEMBER_ID, WEBTOON_ID, CONTENT);  // then "<AssertPlaceHolder>"; }
save(Long userId, Long webtoonId, String content) { return discussionRepository.save( Discussion.builder() .userId(userId) .webtoonId(webtoonId) .content(content) .build() ); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { var channel = seekableByteChannelForRead(); channel.close(); "<AssertPlaceHolder>"; }
isOpen() { synchronized (this) { return !this.closed; } }
[*] target: assertFalse(channel.isOpen())
[-] pred: org. junit. Assert. assertFalse ( channel. isOpen() )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismEmptyNodeList() { when(nodeList.size()).thenReturn(0); boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(0)).get(0); verify(nodeList, times(0)).get(1); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: createAddress_validDate_Success() { generateTestData(); AddressPostVm addressPostVm = AddressPostVm.builder() .contactName("update-address") .districtId(district.getId()) .countryId(country.getId()) .stateOrProvinceId(stateOrProvince.getId()) .build(); AddressGetVm addressGetVm = addressService.createAddress(addressPostVm); "<AssertPlaceHolder>"; }
createAddress(AddressPostVm dto) { Address address = AddressPostVm.fromModel(dto); stateOrProvinceRepository.findById(dto.stateOrProvinceId()).ifPresent(address::setStateOrProvince); Country country = countryRepository.findById(dto.countryId()) .orElseThrow(() -> new NotFoundException(Constants.ErrorCode.COUNTRY_NOT_FOUND, dto.countryId())); address.setCountry(country); districtRepository.findById(dto.districtId()).ifPresent(address::setDistrict); return AddressGetVm.fromModel(addressRepository.save(address)); }
[*] target: assertNotNull(addressGetVm)
[-] pred: org. junit. Assert. assertNotNull ( addressGetVm )
************************************
************************************
[+] input: testReturnSubstringWithCodon3() { String expectedResult = this.expectedCodon3; String actualSubstringResult = returnSubstring(this.testInput, this.testCodon3); "<AssertPlaceHolder>"; }
returnSubstring(String dnaString, int index) { return dnaString.substring(index, index + 3).toUpperCase(); }
[*] target: assertEquals(expectedResult, actualSubstringResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualSubstringResult )
************************************
************************************
[+] input: 인물_관계_TOP30_조회() { // given var expected = new ArrayList<Character>(); for(int i = 0; i < 30; i++) { expected.add(Character.builder() .name("디프만 1번 출구") .type(CharacterType.PERSONA) .webtoonId(1L) .build() ); }  Mockito.when(characterRepository.findTop30ByTypeOrderByCoinAmountDesc(any())) .thenReturn(expected);  // when List<Character> actual = characterService.getCharactersByTopUpper(CharacterType.PERSONA); // then "<AssertPlaceHolder>"; }
getCharactersByTopUpper(CharacterType type) { return characterRepository.findTop30ByTypeOrderByCoinAmountDesc(type); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: GettingAMissingValueShouldReturnNull() { ImmutableStructure structure = new ImmutableStructure(); Object value = structure.getValue("missing"); "<AssertPlaceHolder>"; }
getValue(String key) { Value value = this.attributes.get(key); return value != null ? value.clone() : null; }
[*] target: assertNull(value)
[-] pred: org. junit. Assert. assertNull ( value )
************************************
************************************
[+] input: buildCodonMapBrcaMethodsFrame3Tests() { Path projectPath = Path.of(""); Path brcaPath = projectPath.resolve("assets/dna/real/brca1.fa");  String brcaDnaString = readFile(brcaPath.toFile()); Map<String, Integer> expectedResults = brca1ExpectedFrame3CodonCounts; CodonFrame testCodonFrame = new CodonFrame(brcaDnaString, (short) 3, 1, 20000); ReadingFrames testReadingFrame = new ReadingFrames(testCodonFrame); Map<String, Integer> actualResults = testReadingFrame.getCodonCounts();  "<AssertPlaceHolder>"; }
getCodonCounts() { if (this.codonCounts == null || this.codonCounts.isEmpty()) { this.buildCodonMap(codonFrame.getDna()); } return codonCounts; }
[*] target: assertEquals(expectedResults, actualResults)
[-] pred: org. junit. Assert. assertEquals ( expectedResults, actualResults )
************************************
************************************
[+] input: testCollectFilteredFiles() { List<Path> collectedFiles = new ArrayList<>(); MavenProjectInput.walkDirectoryFiles( Paths.get("src/test/resources/test-folder"), collectedFiles, DEFAULT_GLOB, it -> it.getFileName() .toString() .endsWith("pom.xml")); "<AssertPlaceHolder>"; // pom is filtered out by the "mustBeSkipped" predicate }
walkDirectoryFiles(Path dir, List<Path> collectedFiles, String glob, Predicate<Path> mustBeSkipped) { if (!Files.isDirectory(dir)) { return; }  try { try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, glob)) { for (Path entry : stream) { if (mustBeSkipped.test(entry)) { continue; } File file = entry.toFile(); if (file.isFile() && !isHidden(entry) && isReadable(entry)) { collectedFiles.add(entry); } } } } catch (IOException e) { throw new RuntimeException("Cannot process directory: " + dir, e); } }
[*] target: assertEquals(0, collectedFiles.size())
[-] pred: org. junit. Assert. assertEquals ( 0, collectedFiles. size ( ) )
************************************
************************************
[+] input: testSkipNullCreateSourceInField() { when(field.getCreateSource()).thenReturn(null); boolean skip = skipDetector.skip(field); Assertions."<AssertPlaceHolder>"; verify(field, times(0)).getCreateSource(); }
skip(TapField field) { return false; //是否同构，不是同构就就返回false继续执行codec, 是同构就继续下面的判断 //        if (!isomorphism) return false; //是同构，如果这个字段是手动修改改过表结构的结果就返回false需要走codec, 否则不走codec //        return !(null != field && null != field.getCreateSource() && Field.SOURCE_MANUAL.equalsIgnoreCase(field.getCreateSource())); }
[*] target: assertFalse(skip)
[-] pred: org. junit. Assert. assertFalse ( skip )
************************************
************************************
[+] input: validateGivenMethodWithNoSharedTypeConstructorBetweenLeftInputParameterAndReturnType() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter()), Optional.of(COMPLETABLE_FUTURE.with(V)), "myFunction", asList( Parameter.of(LIST.with(T), "left"), Parameter.of(OPTIONAL.with(U), "right"), Parameter.of(BI_FUNCTION.with(T.asType().contravariant(), U.asType().contravariant(), V.asType().covariant()), "compose") ) );  Validated<String, AccumulatorValidator.Result> expected = Validated.invalid("No shared type constructor between first parameter (java.util.List<T>) and result (java.util.concurrent.CompletableFuture<V>)"); Validated<String, AccumulatorValidator.Result> toVerify = AccumulatorValidator.validate(toValidate, new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
validate(Method method, ParametersAndTypeParametersValidator parametersAndTypeParametersValidator) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages); ParametersAndTypeParametersValidator.Result parametersAndTypeParameters = verifyParametersAndTypeParameters(method, parametersAndTypeParametersValidator, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  // Assign a meaningful name to each of the (three) type parameters: TypeParameter leftInputTypeConstructorArgument = parametersAndTypeParameters.getLeftInputTypeConstructorArgument(); TypeParameter rightInputTypeConstructorArgument = parametersAndTypeParameters.getRightInputTypeConstructorArgument(); TypeParameter returnTypeConstructorArgument = parametersAndTypeParameters.getReturnTypeConstructorArgument();  // Assign a meaningful name to the left and right parameters: Type leftParameterType = parametersAndTypeParameters.getLeftParameterType(); Type rightParameterType = parametersAndTypeParameters.getRightParameterType();  String name = method.getName();  TypeConstructor accumulatedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(returnTypeConstructorArgument.getName()); TypeConstructor partiallyAccumulatedTypeConstructor = leftParameterType.asTypeConstructorWithPlaceholderFor(leftInputTypeConstructorArgument.getName()); TypeConstructor inputTypeConstructor = rightParameterType.asTypeConstructorWithPlaceholderFor(rightInputTypeConstructorArgument.getName());  if (!partiallyAccumulatedTypeConstructor.canAccept(accumulatedTypeConstructor)) { // Tweak the error message to not confuse people using the simple case where // parameter types and result type should be identical: if (Objects.equals(partiallyAccumulatedTypeConstructor, inputTypeConstructor)) { return Validated.invalid("No shared type constructor between parameters (" + generateFrom(leftParameterType) + " and " + generateFrom(rightParameterType) + ") and result (" + generateFrom(returnType) + ")"); } else { return Validated.invalid("No shared type constructor between first parameter (" + generateFrom(leftParameterType) + ") and result (" + generateFrom(returnType) + ")"); } }  verifyNoCrossReferences(method.getTypeParameters(), leftParameterType, partiallyAccumulatedTypeConstructor, "type of the first parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), rightParameterType, inputTypeConstructor, "type of the second parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), returnType, accumulatedTypeConstructor, "return type", errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  return Validated.valid( AccumulatorValidator.Result.of( name, inputTypeConstructor, partiallyAccumulatedTypeConstructor, accumulatedTypeConstructor, leftParameterType, rightParameterType, returnType ) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: deleteEmployee() { Employee employee = new Employee(); employee.setName("John"); employee.setSalary(20000); Employee savedEmployee = employeeRepositoryService.createEmployee(employee);  employeeRepositoryService.deleteEmployee(savedEmployee.getEmployeeId());  Employee fetchedEmployee = employeeRepositoryService.getEmployee(savedEmployee.getEmployeeId()); "<AssertPlaceHolder>"; }
getEmployee(String employeeId) { Optional<Employee> employeeOptional = employeeRepository.findById(employeeId); return employeeOptional.orElse(null); }
[*] target: assertNull(fetchedEmployee)
[-] pred: org. junit. Assert. assertNull ( fetchedEmployee )
************************************
************************************
[+] input: testCheckIsCronOrPlanTaskWithFalseCronTask() { TaskRepository repository = mock(TaskRepository.class); taskService = spy(new TaskServiceImpl(repository)); TaskDto taskDto = new TaskDto(); taskDto.setCrontabExpressionFlag(false); boolean result = taskService.checkIsCronOrPlanTask(taskDto); "<AssertPlaceHolder>"; }
checkIsCronOrPlanTask(TaskDto task);  public abstract List<MutiResponseMessage> batchStop(List<ObjectId> taskIds, UserDetail user, HttpServletRequest request, HttpServletResponse response);  public abstract List<MutiResponseMessage> batchDelete(List<ObjectId> taskIds, UserDetail user, HttpServletRequest request, HttpServletResponse response);  public abstract List<MutiResponseMessage> batchRenew(List<ObjectId> taskIds, UserDetail user, HttpServletRequest request, HttpServletResponse response);  public abstract Page<TaskDto> scanTask(Filter filter, UserDetail userDetail);  public Page<TaskDto> find(Filter filter, UserDetail userDetail){ return super.find(filter, userDetail); }
[*] target: assertEquals(false, result)
[-] pred: org. junit. Assert. assertEquals ( false, result )
************************************
************************************
[+] input: decode_ShouldDecodeByteBufferToValueAndReturnAsString() { String valueAsString = "220412215715"; Instant value = LocalDateTime.parse(valueAsString, formatter).toInstant(zoneOffset); ByteBuffer byteBuffer = TypeCodecs.TIMESTAMP.encode(value, CqlConversion.PROTOCOL_VERSION);  String result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { Instant instantValue = TypeCodecs.TIMESTAMP.decode(bytes, protocolVersion); LocalDateTime localDateTime = LocalDateTime.ofInstant(instantValue, zoneOffset); return formatter.format(localDateTime); }
[*] target: assertEquals(valueAsString, result)
[-] pred: org. junit. Assert. assertEquals ( valueAsString, result )
************************************
************************************
[+] input: sholudCalculateLengthOfCG() { int expected = 50001033; int actual = Properties.calculateLengthOfCG(dnaString); "<AssertPlaceHolder>"; }
calculateLengthOfCG(String dna) { int gcLength = 0; char[] dnaCharArray = dna.toCharArray();  for (char letter : dnaCharArray) { if (letterIsCorG(letter)) { gcLength++; } }  return gcLength; }
[*] target: assertEquals(expected, actual)
[-] pred: assertEquals ( expected, actual )
************************************
************************************
[+] input: testMultipleRows() { AsciiTable tablePrinter = new AsciiTable(Arrays.asList("TYPE", "NAME", "STATUS", "URL")); tablePrinter.addRow("Type1", "Name1", "Status1", "http://url1.com"); tablePrinter.addRow("Type2", "Name2", "Status2", "http://url2.com"); tablePrinter.addRow("Type3", "Name3", "Status3", "http://url3.com"); String expected = "+-------+-------+---------+-----------------+\n" + "| TYPE  | NAME  | STATUS  | URL             |\n" + "+-------+-------+---------+-----------------+\n" + "| Type1 | Name1 | Status1 | http://url1.com |\n" + "| Type2 | Name2 | Status2 | http://url2.com |\n" + "| Type3 | Name3 | Status3 | http://url3.com |\n" + "+-------+-------+---------+-----------------+\n"; "<AssertPlaceHolder>"; }
printTable() { StringBuilder table = new StringBuilder(); int[] columnWidths = new int[headers.size()];  // Calculate the width of each column for (int i = 0; i < headers.size(); i++) { columnWidths[i] = headers.get(i).length(); }  for (List<String> row : rows) { for (int i = 0; i < row.size(); i++) { columnWidths[i] = Math.max(columnWidths[i], row.get(i).length()); } }  // Append the headers table.append(printSeparator(columnWidths)); table.append(printRow(headers, columnWidths)); table.append(printSeparator(columnWidths));  // Append the rows for (List<String> row : rows) { table.append(printRow(row, columnWidths)); } table.append(printSeparator(columnWidths));  return table.toString(); }
[*] target: assertEquals(expected, tablePrinter.printTable())
[-] pred: org. junit. Assert. assertEquals ( expected, tablePrinter. printTable ( ) )
************************************
************************************
[+] input: testAddTaskOptionWithInexistentTaskId() { var taskoption = new TaskOption(); taskoption.setTaskId(0); taskoption.setName("name"); taskoption.setValue("value");  var scheduler = new Scheduler(new MemoryTasks(), new MemoryTaskOptions()); var manager = scheduler.getTaskOptionManager(); try { manager.addTaskOption(taskoption); fail(); } catch (InexistentTaskIdException e) { "<AssertPlaceHolder>"; } catch (TaskOptionManagerException e) { fail(ExceptionUtils.getExceptionStackTrace(e)); } }
addTaskOption(TaskOption taskOption) throws TaskOptionManagerException { if (null == taskOption) throw new IllegalArgumentException("taskOption can't be null."); if (taskOption.getTaskId() < 0) throw new IllegalArgumentException("the task id is required.");  synchronized (this) { TaskOption cloned_taskoption = null; try { cloned_taskoption = taskOption.clone(); } catch (CloneNotSupportedException e) { throw new AddTaskOptionErrorException(cloned_taskoption, e); }  // check if the task id exists try { if (null == getScheduler().getTaskManager().getTask(cloned_taskoption.getTaskId())) { throw new InexistentTaskIdException(cloned_taskoption.getTaskId()); } } catch (TaskManagerException e) { throw new AddTaskOptionErrorException(cloned_taskoption, e); }  // get the task options list for the same task id var task_id = cloned_taskoption.getTaskId(); var task_options = taskOptionsMapping_.get(task_id); if (null == task_options) { // no list exists, create one task_options = new ArrayList<>(); taskOptionsMapping_.put(cloned_taskoption.getTaskId(), task_options); } else { // list exists, check if the same task option isn't already present // and throw an exception if that is the case for (var task_option_to_check : task_options) { if (task_option_to_check.getName().equals(cloned_taskoption.getName())) { throw new DuplicateTaskOptionException(cloned_taskoption.getTaskId(), cloned_taskoption.getName()); } } }  task_options.add(cloned_taskoption);  return true; } }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: shouldReturnCurrentAge() { //given LocalDate birthDay = LocalDate.of(1994, Month.JANUARY, 13); client.setBirthDate(birthDay); //when int actual = client.calculateAge(); //then int expected = 28; Assertions."<AssertPlaceHolder>"; }
calculateAge() { //age = actualDate - bithDate; return Period.between(birthDate, LocalDate.now()).getYears(); }
[*] target: assertEquals(actual, expected)
[-] pred: org. junit. Assert. assertEquals ( actual, expected )
************************************
************************************
[+] input: testSelectCount() { User user = new User(); user.setAge(18); long count = commonDaoWrap.selectCount(user); Assertions."<AssertPlaceHolder>"; }
selectCount(T params) { return dao.selectCount(params); }
[*] target: assertEquals(2, count)
[-] pred: org. junit. Assert. assertEquals ( 2, count )
************************************
************************************
[+] input: whenObjectIsNull_ThenEqualsReturnsFalse() { SampleEntitlementId id1 = new SampleEntitlementId("cat", "jit-1");  "<AssertPlaceHolder>"; }
equals(@Nullable Object o) { if (this == o) { return true; }  if (o == null || getClass() != o.getClass()) { return false; }  var that = (EntitlementId) o; return this.catalog().equals(that.catalog()) && this.id().equals(that.id()); }
[*] target: assertFalse(id1.equals(null))
[-] pred: org. junit. Assert. assertFalse ( id1. equals ( null ) )
************************************
************************************
[+] input: testCategorization2Sections() {  UISchemaBuilder builder = new UISchemaBuilder(Layout.CATEGORIZATION);  builder.addCategory("Cat-1"). // addLayout(Layout.HORIZONTAL). // addElements("color", "rule"). // addCategory("Cat-2"). // addLayout(Layout.HORIZONTAL). // addElements("firstName", "lastName", "role");  String json = builder.build();  "<AssertPlaceHolder>";  logger.info(json);  }
build() {  // close current controllsBuilder.... if (controlsArrayBuilder != null && layoutContext != null) { layoutContext.add("elements", controlsArrayBuilder.build()); }  if (groupArrayBuilder != null) {  // close current layoutContext.... if (layoutsArrayBuilder != null && layoutContext != null) { this.layoutsArrayBuilder.add(layoutContext.build()); }  // close current gourpContext if (groupContext != null) { groupContext.add("elements", layoutsArrayBuilder.build()); groupArrayBuilder.add(groupContext); }  rootLayoutBuilder.add("elements", groupArrayBuilder.build()); }  // write result JsonObject jsonObject = rootLayoutBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: testSkipNullField() { when(field.getCreateSource()).thenReturn(Field.SOURCE_JOB_ANALYZE); boolean skip = skipDetector.skip(null); Assertions."<AssertPlaceHolder>"; verify(field, times(0)).getCreateSource(); }
skip(TapField field) { return false; //是否同构，不是同构就就返回false继续执行codec, 是同构就继续下面的判断 //        if (!isomorphism) return false; //是同构，如果这个字段是手动修改改过表结构的结果就返回false需要走codec, 否则不走codec //        return !(null != field && null != field.getCreateSource() && Field.SOURCE_MANUAL.equalsIgnoreCase(field.getCreateSource())); }
[*] target: assertFalse(skip)
[-] pred: org. junit. Assert. assertFalse ( skip )
************************************
************************************
[+] input: testConvertWhenConversionTypeIsNone() { //        CqlConversion.Type conversionType = CqlConversion.Type.NONE; //        List<CqlConversion.Type> conversionTypeList = Collections.singletonList(conversionType); // //        CqlConversion cqlConversion = spy(new CqlConversion(fromDataType, toDataType, codecRegistry)); //        doReturn(conversionTypeList).when(cqlConversion).getConversionTypeList(); // //        Object inputData = new Object(); //        Object result = cqlConversion.convert(inputData); // //        "<AssertPlaceHolder>"; //    }
convert(Object inputData) { if (null==conversionTypeList || conversionTypeList.isEmpty()) return inputData;  if (logger.isTraceEnabled()) logger.trace("convert() - inputData: {}, converter: {}",inputData,this);  // The first element on the conversionTypeList tells us what conversion the top-level object requires Type conversionType = conversionTypeList.get(0); switch (conversionType) { case NONE: case UNSUPPORTED: return inputData; case CODEC: case UDT: return convert_ONE(conversionType, inputData, fromDataTypeList.get(0), toDataTypeList.get(0), codecRegistry); case LIST: case SET: case MAP: return convert_COLLECTION(conversionType, inputData, conversionTypeList.subList(1,conversionTypeList.size()), fromDataTypeList, toDataTypeList, codecRegistry); } logger.warn("Conversion.convert() - Unknown conversion type: {}", conversionType); return inputData; }
[*] target: assertSame(inputData, result)
[-] pred: org. junit. Assert. assertSame ( inputData, result )
************************************
************************************
[+] input: testStreamSource() { final FilterableTreeItem<String> root = buildTree();  final long sourceItems = root.streamSource().count();  Assertions."<AssertPlaceHolder>"; }
streamSource() { return streamSourceItems().map(TreeItem::getValue); }
[*] target: assertEquals(4, sourceItems)
[-] pred: org. junit. Assert. assertEquals ( 4, sourceItems )
************************************
************************************
[+] input: testFilterConverge_IgnoreTag() {  testAlert.getTags().put(CommonConstants.IGNORE, "true"); boolean result = alarmConvergeReduce.filterConverge(testAlert);  "<AssertPlaceHolder>"; }
filterConverge(Alert currentAlert) { // ignore monitor status auto recover notice if ((currentAlert.getTags() != null && currentAlert.getTags().containsKey(CommonConstants.IGNORE)) || currentAlert.getStatus() == CommonConstants.ALERT_STATUS_CODE_RESTORED) { // restored alert boolean isHasIgnore = false; Map<String, String> tags = currentAlert.getTags(); if (Objects.requireNonNull(tags).containsKey(CommonConstants.IGNORE)) { isHasIgnore = true; tags.remove(CommonConstants.IGNORE); } int alertHash = Objects.hash(CommonConstants.ALERT_PRIORITY_CODE_CRITICAL) + Arrays.hashCode(tags.keySet().toArray(new String[0])) + Arrays.hashCode(tags.values().toArray(new String[0])); converageAlertMap.remove(alertHash); alertHash = Objects.hash(CommonConstants.ALERT_PRIORITY_CODE_EMERGENCY) + Arrays.hashCode(tags.keySet().toArray(new String[0])) + Arrays.hashCode(tags.values().toArray(new String[0])); converageAlertMap.remove(alertHash); alertHash = Objects.hash(CommonConstants.ALERT_PRIORITY_CODE_WARNING) + Arrays.hashCode(tags.keySet().toArray(new String[0])) + Arrays.hashCode(tags.values().toArray(new String[0])); converageAlertMap.remove(alertHash); if (isHasIgnore) { tags.put(CommonConstants.IGNORE, CommonConstants.IGNORE); } return true; }  CommonCacheService<String, Object> convergeCache = CacheFactory.getAlertConvergeCache(); List<AlertConverge> alertConvergeList = (List<AlertConverge>) convergeCache.get(CommonConstants.CACHE_ALERT_CONVERGE); if (alertConvergeList == null) { alertConvergeList = alertConvergeDao.findAll(); // matchAll is in the last alertConvergeList.sort((item1, item2) -> { if (item1.isMatchAll()) { return 1; } else if (item2.isMatchAll()) { return -1; } else { return 0; } }); convergeCache.put(CommonConstants.CACHE_ALERT_CONVERGE, alertConvergeList); } for (AlertConverge alertConverge : alertConvergeList) { if (!alertConverge.isEnable()) { continue; } boolean match = alertConverge.isMatchAll(); if (!match) { List<TagItem> tags = alertConverge.getTags(); if (currentAlert.getTags() != null && !currentAlert.getTags().isEmpty()) { Map<String, String> alertTagMap = currentAlert.getTags(); match = tags.stream().anyMatch(item -> { if (alertTagMap.containsKey(item.getName())) { String tagValue = alertTagMap.get(item.getName()); if (tagValue == null && item.getValue() == null) { return true; } else { return tagValue != null && tagValue.equals(item.getValue()); } } else { return false; } }); } else { match = true; } if (match && alertConverge.getPriorities() != null && !alertConverge.getPriorities().isEmpty()) { match = alertConverge.getPriorities().stream().anyMatch(item -> item != null && item == currentAlert.getPriority()); } } if (match) { long evalInterval = alertConverge.getEvalInterval() * 1000L; long now = System.currentTimeMillis(); if (evalInterval <= 0) { return true; } int alertHash = Objects.hash(currentAlert.getPriority()) + Arrays.hashCode(currentAlert.getTags().keySet().toArray(new String[0])) + Arrays.hashCode(currentAlert.getTags().values().toArray(new String[0])); Alert preAlert = converageAlertMap.get(alertHash); if (preAlert == null) { currentAlert.setTimes(1); currentAlert.setFirstAlarmTime(now); currentAlert.setLastAlarmTime(now); converageAlertMap.put(alertHash, currentAlert.clone()); return true; } else { if (now - preAlert.getFirstAlarmTime() < evalInterval) { preAlert.setTimes(preAlert.getTimes() + 1); preAlert.setLastAlarmTime(now); return false; } else { currentAlert.setTimes(preAlert.getTimes()); if (preAlert.getTimes() == 1) { currentAlert.setFirstAlarmTime(now); } else { currentAlert.setFirstAlarmTime(preAlert.getFirstAlarmTime()); } currentAlert.setLastAlarmTime(now); preAlert.setFirstAlarmTime(now); preAlert.setLastAlarmTime(now); preAlert.setTimes(1); return true; } } } } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testSimple() {  DataBuilder builder = new DataBuilder(). // addData("name", "John"). // addData("description", "Hello World");  String json = builder.build();  "<AssertPlaceHolder>";  logger.info(json);  }
build() { closeArray(); // write result JsonObject jsonObject = rootBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: test_deduceSchema() { TaskDto taskDto = new TaskDto(); taskDto.setSyncType("deduceSchema"); when(dataProcessorContext.getTaskDto()).thenReturn(taskDto); DatabaseNode databaseNode = new DatabaseNode(); databaseNode.setTableNames(Arrays.asList("test1")); doCallRealMethod().when(node).getSourceTables(any(),anyList()); List<String> result = node.getSourceTables(databaseNode,new ArrayList<>()); Assertions."<AssertPlaceHolder>"; }
getSourceTables(Node node,List<String> tables) { if (StringUtils.equalsAnyIgnoreCase(dataProcessorContext.getTaskDto().getSyncType(), TaskDto.SYNC_TYPE_TEST_RUN)){ return ((DatabaseNode) node).getTableNames(); } return tables; }
[*] target: assertEquals(0,result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: testInsert() { User user = new User(); user.setName("张三"); user.setAge(18); user.setCreateTime(LocalDateTime.now().plusYears(-18)); int insert = commonDao.insert(user); Assertions."<AssertPlaceHolder>"; }
insert(T params);  /** * 删除一个对象 * * @param id  主键 * @param cls 指定一个实体类型 * @return delete line count */ @DeleteProvider(type = SqlBuilder.class, method = "delete") <T> int delete(@Param("id") T id, Class<?> cls);  /** * 修改对象，必须有主键 * * @param params param * @param <T> type * @return update line count */ @UpdateProvider(type = SqlBuilder.class, method = "update") <T> int update(T params);  /** * 根据主键选择一个对象 * * @param id  关键字 * @param cls 指定一个实体 * @return result */ @SelectProvider(type = SqlBuilder.class, method = "select") <T> Map<?,?> select(@Param("id") T id, Class<?> cls);  /** * 查询列表条数跟 selectList 配对使用 * * @param params param * @param <T> param type * @return count */ @SelectProvider(type = SqlBuilder.class, method = "selectCount") <T> long selectCount(T params);  /** * 查询列表 * * @param params param * @return result */ @SelectProvider(type = SqlBuilder.class, method = "selectList") <T> List<Map<?,?>> selectList(T params);   /** * 自定义查询列表结果 * * @param params param * @return result */ @Select(" ${selfSQL}
[*] target: assertEquals(1, insert)
[-] pred: org. junit. Assert. assertEquals ( 1, insert )
************************************
************************************
[+] input: generateGivenInvariant() { String expected = "java.lang.String"; String toVerify = new TypeArgumentGenerator(STRING.invariant()).generate();  "<AssertPlaceHolder>"; }
generate() { String generatedType = TypeGenerator.generateFrom(typeArgument.getType()); switch (typeArgument.getVariance()) { case INVARIANT: return generatedType; case COVARIANT: return String.join(SPACE, QUESTION_MARK, EXTENDS, generatedType); case CONTRAVARIANT: return String.join(SPACE, QUESTION_MARK, SUPER, generatedType); default: throw new RuntimeException("Not implemented"); } }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: InterruptedException { // GIVEN var asset = new Asset(new AssetId(UUID.randomUUID())); var expectedCustomerId = new CustomerId(UUID.randomUUID()); asset.setCustomerId(expectedCustomerId);  when(ctxMock.getAssetService()).thenReturn(assetServiceMock); doReturn(Futures.immediateFuture(asset)).when(assetServiceMock).findAssetByIdAsync(any(), any()); when(ctxMock.getDbCallbackExecutor()).thenReturn(DB_EXECUTOR);  // WHEN var actualCustomerId = EntitiesCustomerIdAsyncLoader.findEntityIdAsync(ctxMock, asset.getId()).get();  // THEN "<AssertPlaceHolder>"; }
findEntityIdAsync(TbContext ctx, EntityId originator) { switch (originator.getEntityType()) { case CUSTOMER: return Futures.immediateFuture((CustomerId) originator); case USER: return toCustomerIdAsync(ctx, ctx.getUserService().findUserByIdAsync(ctx.getTenantId(), (UserId) originator)); case ASSET: return toCustomerIdAsync(ctx, ctx.getAssetService().findAssetByIdAsync(ctx.getTenantId(), (AssetId) originator)); case DEVICE: return toCustomerIdAsync(ctx, Futures.immediateFuture(ctx.getDeviceService().findDeviceById(ctx.getTenantId(), (DeviceId) originator))); default: return Futures.immediateFailedFuture(new TbNodeException("Unexpected originator EntityType: " + originator.getEntityType())); } }
[*] target: assertEquals(expectedCustomerId, actualCustomerId)
[-] pred: org. junit. Assert. assertEquals ( expectedCustomerId, actualCustomerId )
************************************
************************************
[+] input: castToJavaBean1() { Map map = new HashMap<>(); map.put("cCountry", Locale.US.getCountry()); map.put("language", Locale.US.getLanguage()); Locale element = TypeUtils.castToJavaBean(map, Locale.class, ParserConfig.global); "<AssertPlaceHolder>"; }
castToJavaBean(Map<String, Object> map, Class<T> clazz, ParserConfig config) { try { if (clazz == StackTraceElement.class) { String declaringClass = (String) map.get("className"); String methodName = (String) map.get("methodName"); String fileName = (String) map.get("fileName"); int lineNumber; { Number value = (Number) map.get("lineNumber"); if (value == null) { lineNumber = 0; } else if (value instanceof BigDecimal) { lineNumber = ((BigDecimal) value).intValueExact(); } else { lineNumber = value.intValue(); } } return (T) new StackTraceElement(declaringClass, methodName, fileName, lineNumber); }  { Object iClassObject = map.get(JSON.DEFAULT_TYPE_KEY); if (iClassObject instanceof String) { String className = (String) iClassObject; Class<?> loadClazz; if (config == null) { config = ParserConfig.global; } //                    loadClazz = config.checkAutoType(className, null); //                    if(loadClazz == null){ //                        throw new ClassNotFoundException(className + " not found"); //                    } //                    if(!loadClazz.equals(clazz)){ //                        return (T) castToJavaBean(map, loadClazz, config); //                    } throw new JSONException("TODO"); // TODO : castToJavaBean } }  if (clazz.isInterface()) { JSONObject object; if (map instanceof JSONObject) { object = (JSONObject) map; } else { object = new JSONObject(map); } if (config == null) { config = ParserConfig.getGlobalInstance(); } //                ObjectDeserializer deserializer = config.getDeserializers().get(clazz); //                if(deserializer != null){ //                    String json = JSON.toJSONString(object); //                    return (T) JSON.parseObject(json, clazz); //                } //                return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), //                        new Class<?>[]{clazz}, object); throw new JSONException("TODO"); // TODO : castToJavaBean }  if (clazz == Locale.class) { Object arg0 = map.get("language"); Object arg1 = map.get("country"); if (arg0 instanceof String) { String language = (String) arg0; if (arg1 instanceof String) { String country = (String) arg1; return (T) new Locale(language, country); } else if (arg1 == null) { return (T) new Locale(language); } } }  if (clazz == String.class && map instanceof JSONObject) { return (T) map.toString(); }  if (clazz == LinkedHashMap.class && map instanceof JSONObject) { JSONObject jsonObject = (JSONObject) map; Map innerMap = jsonObject.getInnerMap(); if (innerMap instanceof LinkedHashMap) { return (T) innerMap; } else { LinkedHashMap linkedHashMap = new LinkedHashMap(); linkedHashMap.putAll(innerMap); } }  ObjectReader objectReader = JSONFactory.getDefaultObjectReaderProvider().getObjectReader(clazz); return (T) objectReader.createInstance(map, 0L); } catch (Exception e) { throw new JSONException(e.getMessage(), e); } }
[*] target: assertNotNull(element)
[-] pred: org. junit. Assert. assertNotNull ( element )
************************************
************************************
[+] input: bind_withTTL() { when(writetimeTTLFeature.isEnabled()).thenReturn(true); when(writetimeTTLFeature.hasTTLColumns()).thenReturn(true); targetInsertStatement = new TargetInsertStatement(propertyHelper, targetSession);  BoundStatement result = targetInsertStatement.bind(originRow, targetRow, 3600,null,null,null); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size()+1)).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { if (null == originRow) throw new RuntimeException("Origin row is null"); if (usingCounter) throw new RuntimeException("Cannot INSERT onto a counter table, use UPDATE instead");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue); BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; Object bindValue = null;  if (logDebug) logger.debug("bind using conversions: {}",cqlTable.getOtherCqlTable().getConversions()); for (int targetIndex = 0; targetIndex < targetColumnTypes.size(); targetIndex++) { if (!bindColumnIndexes.contains(targetIndex)) { // this happens with constant columns, for example continue; } try { if (targetIndex== explodeMapKeyIndex) { bindValue = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValue = explodeMapValue; } else { int originIndex = cqlTable.getCorrespondingIndex(targetIndex); if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValue = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValue, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValue + " of class:" +(null==bindValue?"unknown":bindValue.getClass().getName())+ " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex)+ "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex + " and bind index: "+ (currentBindIndex-1) + " of statement:" + this.getCQL()); throw e; } }  if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: shouldLetterIsCorGReturnFalse() { boolean actual = Properties.letterIsCorG('b'); "<AssertPlaceHolder>"; }
letterIsCorG(char aLetter) { return (aLetter == 'c') || (aLetter == 'g'); }
[*] target: assertFalse(actual)
[-] pred: org. junit. Assert. assertFalse ( actual )
************************************
************************************
[+] input: setTopBit() { final int i = Integer.MAX_VALUE - 1; set.set(i); final int ret = set.previousSetBit(i);  "<AssertPlaceHolder>"; }
previousSetBit(int fromIndex);  /** * Returns the index of the nearest bit that is set to {@code false}
[*] target: assertEquals(i, ret)
[-] pred: org. junit. Assert. assertEquals ( i, ret )
************************************
************************************
[+] input: isDone() { ResponseFutureWrapper responseFutureWrapper = new ResponseFutureWrapper("Test"); "<AssertPlaceHolder>"; }
isDone() { return true; }
[*] target: assertTrue(responseFutureWrapper.isDone())
[-] pred: org. junit. Assert. assertTrue ( responseFutureWrapper. isDone() )
************************************
************************************
[+] input: decode_ShouldDecodeTextByteBufferAndReturnAsInstant() { String valueAsString = "1681333035000"; Instant value = Instant.ofEpochMilli(Long.parseLong(valueAsString)); ByteBuffer byteBuffer = TypeCodecs.TEXT.encode(valueAsString, CqlConversion.PROTOCOL_VERSION);  Instant result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { String stringValue = TypeCodecs.TEXT.decode(bytes, protocolVersion); return Instant.ofEpochMilli(Long.parseLong(stringValue)); }
[*] target: assertEquals(value, result)
[-] pred: org. junit. Assert. assertEquals ( value, result )
************************************
************************************
[+] input: testCheckWhenIsSameDept() { DeptTreeDataPermissionChecker checker = new DeptTreeDataPermissionChecker(deptService);  when(deptService.isChildOfTheDept(any(), any())).thenReturn(false); when(loginUser.getDeptId()).thenReturn(1L); DataCondition dataCondition = new DataCondition(); dataCondition.setTargetDeptId(1L);  boolean check = checker.check(loginUser, dataCondition);  "<AssertPlaceHolder>"; }
check(SystemLoginUser loginUser, DataCondition condition) { if (condition == null || loginUser == null) { return false; }  if (loginUser.getDeptId() == null || condition.getTargetDeptId() == null) { return false; }  Long currentDeptId = loginUser.getDeptId(); Long targetDeptId = condition.getTargetDeptId();  boolean isContainsTargetDept = deptService.isChildOfTheDept(loginUser.getDeptId(), targetDeptId); boolean isSameDept = Objects.equals(currentDeptId, targetDeptId);  return isContainsTargetDept || isSameDept; }
[*] target: assertTrue(check)
[-] pred: org. junit. Assert. assertTrue ( check )
************************************
************************************
[+] input: validateGivenStaticInnerClassAsContainingClass() { ContainingClass toValidate = PackageName.of("nl.wernerdegroot.applicatives") .asPackage() .containingClass(modifiers(), ClassName.of("Outer"), A, B) .containingClass(modifiers(STATIC), ClassName.of("Inner"), C, D);  Validated<String, ClassValidator.Result> expected = Validated.valid(ClassValidator.Result.of(asList(C, D))); Validated<String, ClassValidator.Result> toVerify = ClassValidator.validate(toValidate);  "<AssertPlaceHolder>"; }
validate(ContainingClass containingClass) {  // We check whether we're dealing with an outer class or a static inner class. // Why is this required? Consider the following scenario: // //   class Outer<A extends B, B> { //     class Inner<B> { //       ... //     } //   } // // It is impossible to collapse these three type parameters of these two classes into a // single list of type parameters without carefully renaming some of them to avoid shadowing. // Instead of going through all that effort for this extreme edge-case, I'm just going avoid // it completely. If we'd like to be more sophisticated we could try: // //  * To support only a single class with type parameters in the hierarchy //  * Only support multiple classes with type parameters if their names don't conflict //  * Only support conflicts if the type parameter that is shadowed can be removed //    completely (isn't used as upper bound for any of the other type parameters) if (!containingClass.isOuterClass() && !containingClass.isStaticInnerClass()) { return Validated.invalid("Only outer classes and static inner classes are currently supported"); } List<TypeParameter> typeParameters = containingClass.getTypeParameters();  return Validated.valid(Result.of(typeParameters)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: whenObjectIsNull_ThenEqualsReturnsFalse() { GroupId id1 = new GroupId("group@example.com");  "<AssertPlaceHolder>"; }
equals(@Nullable Object o) { if (this == o) { return true; }  if (o == null || getClass() != o.getClass()) { return false; }  GroupId groupId = (GroupId) o; return email.equals(groupId.email); }
[*] target: assertFalse(id1.equals(null))
[-] pred: org. junit. Assert. assertFalse ( id1. equals ( null ) )
************************************
************************************
[+] input: isCancelled() { ResponseFutureWrapper responseFutureWrapper = new ResponseFutureWrapper("Test"); "<AssertPlaceHolder>"; }
isCancelled() { return false; }
[*] target: assertFalse(responseFutureWrapper.isCancelled())
[-] pred: org. junit. Assert. assertFalse ( responseFutureWrapper. isCancelled() )
************************************
************************************
[+] input: testOfferWhenTapdataEventIsNull() { boolean actual = mockHazelcastBaseNode.offer(null); "<AssertPlaceHolder>"; }
offer(TapdataEvent dataEvent) { if (dataEvent != null) { if (processorBaseContext.getNode() != null) { dataEvent.addNodeId(processorBaseContext.getNode().getId()); } Outbox outbox = getOutboxAndCheckNullable(); int bucketCount = outbox.bucketCount(); if (!tryEmit(dataEvent, bucketCount)) return false; } bucketIndex = 0; // reset to 0 of return true return true; }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: testInterceptAspectTest0() { AspectInterceptResult aspect = observableAspectTask.onInterceptAspect(new Aspect() {}); Assertions."<AssertPlaceHolder>"; }
onInterceptAspect(Aspect aspect) { return null; }
[*] target: assertNull(aspect)
[-] pred: org. junit. Assert. assertNull ( aspect )
************************************
************************************
[+] input: testStripQuotesAtStartAndEndNoQuotes() { String input = "/home/user/file.txt"; String expected = input; String result = PathUtil.stripQuotesAtStartAndEnd(input);  "<AssertPlaceHolder>"; }
stripQuotesAtStartAndEnd(String path) { if (path.startsWith(""") && path.endsWith(""")) { return path.substring(1, path.length() - 1); }  return path; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: setEvaluationContextShouldAllowChaining() { OpenFeatureClient client = new OpenFeatureClient(api, "name", "version"); EvaluationContext ctx = new ImmutableContext("targeting key", new HashMap<>()); OpenFeatureClient result = client.setEvaluationContext(ctx); "<AssertPlaceHolder>"; }
setEvaluationContext(EvaluationContext evaluationContext) { try (AutoCloseableLock __ = lock.writeLockAutoCloseable()) { this.evaluationContext = evaluationContext; } return this; }
[*] target: assertEquals(client, result)
[-] pred: org. junit. Assert. assertEquals ( client, result )
************************************
************************************
[+] input: testAgentIdsIsEmpty() { when(agentIds.isEmpty()).thenReturn(true); List<WorkerDto> allAgent = agentGroupService.findAllAgent(agentIds, userDetail); Assertions."<AssertPlaceHolder>"; verify(workerServiceImpl, times(0)).findAllDto(any(Query.class), any(UserDetail.class)); }
findAllAgent(Collection<String> agentIds, UserDetail loginUser) { if (CollectionUtils.isEmpty(agentIds)) { return Lists.newArrayList(); } Criteria criteria = Criteria.where(AgentGroupTag.TAG_PROCESS_ID).in(agentIds) .and(AgentGroupTag.TAG_WORKER_TYPE).is(AgentGroupTag.TAG_CONNECTOR); return workerServiceImpl.findAllDto(Query.query(criteria), loginUser); }
[*] target: assertNotNull(allAgent)
[-] pred: org. junit. Assert. assertNotNull ( allAgent )
************************************
************************************
[+] input: writeStringLatin1() { byte[] bytes = new byte[256]; for (int i = 0; i < bytes.length; i++) { bytes[i] = (byte) i; } JSONWriter jsonWriter = new JSONWriterUTF16(JSONFactory.createWriteContext()); jsonWriter.writeStringLatin1(bytes); String json = jsonWriter.toString(); String str = new String(bytes, 0, bytes.length, StandardCharsets.ISO_8859_1); Object parse = JSON.parse(json); "<AssertPlaceHolder>"; }
toString() { return new String(chars, 0, off); }
[*] target: assertEquals(str, parse)
[-] pred: org. junit. Assert. assertEquals ( str, parse )
************************************
************************************
[+] input: testIsValidWithNullValue() { DoesNotContain doesNotContain = mock(DoesNotContain.class); when(doesNotContain.chars()).thenReturn(new String[]{"@", "#"}); validator.initialize(doesNotContain);  String value = null; boolean result = validator.isValid(value, context);  "<AssertPlaceHolder>"; }
isValid(String value, ConstraintValidatorContext context) { if (value == null) { return true; } for (String c : chars) { if (value.contains(c)) { return false; } } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: decode_ShouldDecodeTextByteBufferAndReturnAsNumber() { String valueAsString = "10"; Integer value = Integer.valueOf(valueAsString); ByteBuffer byteBuffer = TypeCodecs.TEXT.encode(valueAsString, CqlConversion.PROTOCOL_VERSION);  Integer result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { String stringValue = TypeCodecs.TEXT.decode(bytes, protocolVersion); return Integer.parseInt(stringValue); }
[*] target: assertEquals(value, result)
[-] pred: org. junit. Assert. assertEquals ( value, result )
************************************
************************************
[+] input: testSaveClusterGroup_ClusterHostServiceReturnsNoItems() { // Setup final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  when(mockHostService.getHostListByClusterId(0)).thenReturn(Collections.emptyList());  // Run the test final Result result = clusterGroupServiceImplUnderTest.saveClusterGroup(0, "groupName");  // Verify the results "<AssertPlaceHolder>"; }
saveClusterGroup(Integer clusterId, String groupName) { if (hasRepeatGroupName(clusterId, groupName)) { return Result.error(Status.GROUP_NAME_DUPLICATION.getMsg()); } ClusterGroup clusterGroup = new ClusterGroup(); clusterGroup.setClusterId(clusterId); clusterGroup.setGroupName(groupName); this.save(clusterGroup);  List<ClusterHostDO> hostList = hostService.getHostListByClusterId(clusterId); for (ClusterHostDO clusterHost : hostList) { ActorRef unixGroupActor = ActorUtils.getRemoteActor(clusterHost.getHostname(), "unixGroupActor"); CreateUnixGroupCommand createUnixGroupCommand = new CreateUnixGroupCommand(); createUnixGroupCommand.setGroupName(groupName); Timeout timeout = new Timeout(Duration.create(180, TimeUnit.SECONDS)); Future<Object> execFuture = Patterns.ask(unixGroupActor, createUnixGroupCommand, timeout); ExecResult execResult = null; try { execResult = (ExecResult) Await.result(execFuture, timeout.duration()); if (execResult.getExecResult()) { logger.info("create unix group success at {}", clusterHost.getHostname()); } else { logger.info(execResult.getExecOut()); throw new ServiceException(500, "create unix group " + groupName + " failed at " + clusterHost.getHostname()); } } catch (Exception e) { throw new ServiceException(500, "create unix group " + groupName + " failed at " + clusterHost.getHostname()); } }  return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testMessage2TapEventNullMessageEntity() { TapRecordEvent actual = hazelcastBaseNode.message2TapEvent(null); "<AssertPlaceHolder>"; }
message2TapEvent(MessageEntity messageEntity) { if (null == messageEntity) return null; TapRecordEvent tapRecordEvent; String op = messageEntity.getOp(); OperationType operationType = OperationType.fromOp(op); if (operationType == null) { throw new IllegalArgumentException(String.format("Unrecognized op type: %s", op)); } switch (operationType) { case INSERT: tapRecordEvent = new TapInsertRecordEvent(); ((TapInsertRecordEvent) tapRecordEvent).setAfter(messageEntity.getAfter()); break; case UPDATE: tapRecordEvent = new TapUpdateRecordEvent(); ((TapUpdateRecordEvent) tapRecordEvent).setBefore(messageEntity.getBefore()); ((TapUpdateRecordEvent) tapRecordEvent).setAfter(messageEntity.getAfter()); break; case DELETE: tapRecordEvent = new TapDeleteRecordEvent(); ((TapDeleteRecordEvent) tapRecordEvent).setBefore(messageEntity.getBefore()); break; default: tapRecordEvent = null; break; } if (null != tapRecordEvent) { tapRecordEvent.setTableId(messageEntity.getTableName()); tapRecordEvent.setReferenceTime(messageEntity.getTimestamp()); tapRecordEvent.setTime(messageEntity.getTime()); tapRecordEvent.setInfo(messageEntity.getInfo()); } return tapRecordEvent; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: fipeTabelasPass() { FipeTabela[] fipeTabelas = BrasilAPI.fipeTabelas(); "<AssertPlaceHolder>"; }
fipeTabelas() { FipeTabela[] obj = (FipeTabela[]) api(FipeTabela[].class, "fipe/tabelas/v1", ""); return obj != null ? (FipeTabela[]) obj.clone() : null; }
[*] target: assertNotNull(fipeTabelas)
[-] pred: org. junit. Assert. assertNotNull ( fipeTabelas )
************************************
************************************
[+] input: test() { JSONReader.Context ctx = JSONFactory.createReadContext(); String str = "abcdef1234567890中国©®£\uD83D\uDE0D\uD83D\uDC81\uD83D\uDC4C\uD83C\uDF8D\uD83D\uDE0D"; String json = JSON.toJSONString(str); byte[] bytes = json.getBytes(StandardCharsets.UTF_8); JSONReaderUTF8Vector jsonReader = new JSONReaderUTF8Vector(ctx, json, bytes, 0, bytes.length); String parsed = jsonReader.readString(); "<AssertPlaceHolder>"; }
readString() { if (ch == '"' || ch == ''') { final byte[] bytes = this.bytes; char quote = this.ch; int valueLength; int offset = this.offset; final int start = offset, end = this.end; boolean ascii = true; valueEscape = false;  { int i = 0; Vector<Byte> v_quote = quote == '"' ? V_BYTE_64_DOUBLE_QUOTE : V_BYTE_64_SINGLE_QUOTE; for (; offset + 8 < end; offset += 8, i += 8) { ByteVector v = (ByteVector) ByteVector.SPECIES_64.fromArray(bytes, offset); if (v.eq(V_BYTE_64_SLASH).or(v.eq(v_quote).or(v.lt(V_BYTE_64_ZERO))).anyTrue()) { break; } }  for (; ; ++i) { if (offset >= end) { throw new JSONException("invalid escape character EOI"); }  int c = bytes[offset]; if (c == '\') { valueEscape = true; c = bytes[offset + 1]; offset += (c == 'u' ? 6 : (c == 'x' ? 4 : 2)); continue; }  if (c >= 0) { if (c == quote) { valueLength = i; break; } offset++; } else { ascii = false; switch ((c & 0xFF) >> 4) { case 12: case 13: { /* 110x xxxx   10xx xxxx*/ offset += 2; break; } case 14: { offset += 3; break; } default: { /* 10xx xxxx,  1111 xxxx */ if ((c >> 3) == -2) { offset += 4; i++; break; }  throw new JSONException("malformed input around byte " + offset); } } } } }  String str; if (valueEscape) { char[] chars = new char[valueLength]; offset = start; for (int i = 0; ; ++i) { int ch = bytes[offset]; if (ch == '\') { ch = bytes[++offset]; switch (ch) { case 'u': { ch = char4(bytes[offset + 1], bytes[offset + 2], bytes[offset + 3], bytes[offset + 4]); offset += 4; break; } case 'x': { ch = char2(bytes[offset + 1], bytes[offset + 2]); offset += 2; break; } case '\': case '"': break; default: ch = char1(ch); break; } chars[i] = (char) ch; offset++; } else if (ch == '"') { break; } else { if (ch >= 0) { chars[i] = (char) ch; offset++; } else { switch ((ch & 0xFF) >> 4) { case 12: case 13: { /* 110x xxxx   10xx xxxx*/ chars[i] = (char) (((ch & 0x1F) << 6) | (bytes[offset + 1] & 0x3F)); offset += 2; break; } case 14: { chars[i] = (char) (((ch & 0x0F) << 12) | ((bytes[offset + 1] & 0x3F) << 6) | ((bytes[offset + 2] & 0x3F) << 0)); offset += 3; break; } default: { /* 10xx xxxx,  1111 xxxx */ char2_utf8(bytes, offset, ch, chars, i); offset += 4; i++; } } } } }  str = new String(chars); } else if (ascii) { int strlen = offset - start; if (strlen == 1) { str = TypeUtils.toString((char) (bytes[start] & 0xff)); } else if (strlen == 2) { str = TypeUtils.toString( (char) (bytes[start] & 0xff), (char) (bytes[start + 1] & 0xff) ); } else if (STRING_CREATOR_JDK11 != null) { str = STRING_CREATOR_JDK11.apply( Arrays.copyOfRange(this.bytes, this.offset, offset), LATIN1); } else { str = new String(bytes, start, offset - start, StandardCharsets.US_ASCII); } } else { str = new String(bytes, start, offset - start, StandardCharsets.UTF_8); }  if ((context.features & Feature.TrimString.mask) != 0) { str = str.trim(); }  int ch = ++offset == end ? EOI : bytes[offset++]; while (ch <= ' ' && (1L << ch & SPACE) != 0) { ch = offset == end ? EOI : bytes[offset++]; }  if (comma = ch == ',') { ch = offset == end ? EOI : bytes[offset++]; while (ch <= ' ' && (1L << ch & SPACE) != 0) { ch = offset == end ? EOI : bytes[offset++]; } }  this.ch = (char) ch; this.offset = offset; return str; }  switch (ch) { case '[': return toString( readArray()); case '{': return toString( readObject()); case '-': case '+': case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': readNumber0(); Number number = getNumber(); return number.toString(); case 't': case 'f': boolValue = readBoolValue(); return boolValue ? "true" : "false"; case 'n': { readNull(); return null; } default: throw new JSONException("TODO : " + ch); } }  public static class Factory implements JSONFactory.JSONReaderUTF8Creator { @Override public JSONReader create(Context ctx, String str, byte[] bytes, int offset, int length) { return new JSONReaderUTF8Vector(ctx, str, bytes, offset, length); } } }
[*] target: assertEquals(str, parsed)
[-] pred: org. junit. Assert. assertEquals ( str, parsed )
************************************
************************************
[+] input: testEncodeKey() {  String key = "testKey"; ByteBuffer encodedKey = codec.encodeKey(key); String decodedKey = StandardCharsets.UTF_8.decode(encodedKey).toString();  "<AssertPlaceHolder>"; }
encodeKey(String s) { return ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8)); }
[*] target: assertEquals(key, decodedKey)
[-] pred: org. junit. Assert. assertEquals ( key, decodedKey )
************************************
************************************
[+] input: testNormal() { GoogleAnalyticsPlatform platform = new GoogleAnalyticsPlatform(); CloseableHttpClient client = platform.getClient(); "<AssertPlaceHolder>"; try { client.close(); } catch (IOException e) { } }
getClient() { return client; }
[*] target: assertNotNull(client)
[-] pred: org. junit. Assert. assertNotNull ( client )
************************************
************************************
[+] input: testDelete() { int delete = commonDao.delete(1L, User.class); Assertions."<AssertPlaceHolder>"; }
delete(@Param("id") T id, Class<?> cls);  /** * 修改对象，必须有主键 * * @param params param * @param <T> type * @return update line count */ @UpdateProvider(type = SqlBuilder.class, method = "update") <T> int update(T params);  /** * 根据主键选择一个对象 * * @param id  关键字 * @param cls 指定一个实体 * @return result */ @SelectProvider(type = SqlBuilder.class, method = "select") <T> Map<?,?> select(@Param("id") T id, Class<?> cls);  /** * 查询列表条数跟 selectList 配对使用 * * @param params param * @param <T> param type * @return count */ @SelectProvider(type = SqlBuilder.class, method = "selectCount") <T> long selectCount(T params);  /** * 查询列表 * * @param params param * @return result */ @SelectProvider(type = SqlBuilder.class, method = "selectList") <T> List<Map<?,?>> selectList(T params);   /** * 自定义查询列表结果 * * @param params param * @return result */ @Select(" ${selfSQL}
[*] target: assertEquals(1, delete)
[-] pred: org. junit. Assert. assertEquals ( 1, delete )
************************************
************************************
[+] input: testDefaultPublisher() { NotificationPublisher publisher = new NotificationPublisher(); publisher.setDefaultPublisher(true); Assertions."<AssertPlaceHolder>"; }
isDefaultPublisher() { return defaultPublisher; }
[*] target: assertTrue(publisher.isDefaultPublisher())
[-] pred: org. junit. Assert. assertTrue ( publisher. isDefaultPublisher() )
************************************
************************************
[+] input: testUpdated() { Date date = new Date(); Vulnerability vuln = new Vulnerability(); vuln.setUpdated(date); Assertions."<AssertPlaceHolder>"; }
getUpdated() { return updated; }
[*] target: assertEquals(date, vuln.getUpdated())
[-] pred: org. junit. Assert. assertEquals ( date, vuln. getUpdated() )
************************************
************************************
[+] input: canAddPawn() { ChessBoard board = new ChessBoard(); Pawn pawn = new Pawn(WHITE); board.add(pawn, "a2"); Pawn foundPawn = (Pawn) board.getPieceAtCoords("a2"); "<AssertPlaceHolder>"; }
getPieceAtCoords(String chessCoords) { Coordinates coords = new Coordinates(chessCoords); return internalBoard[coords.getX()][coords.getY()]; }
[*] target: assertEquals(pawn, foundPawn)
[-] pred: org. junit. Assert. assertEquals ( pawn, foundPawn )
************************************
************************************
[+] input: abort() { ResponseFutureWrapper responseFutureWrapper = new ResponseFutureWrapper("Test"); responseFutureWrapper.abort(new Throwable()); "<AssertPlaceHolder>"; }
isDone() { return true; }
[*] target: assertTrue(responseFutureWrapper.isDone())
[-] pred: org. junit. Assert. assertTrue ( responseFutureWrapper. isDone() )
************************************
************************************
[+] input: asTypeConstructorWithPlaceHolderForGivenNeedleThatMatchesElementType() { TypeConstructor expected = new ArrayTypeConstructor(new PlaceholderTypeConstructor()); TypeConstructor toVerify = new ArrayType(new GenericType(T)).asTypeConstructorWithPlaceholderFor(T);  "<AssertPlaceHolder>"; }
asTypeConstructorWithPlaceholderFor(TypeParameterName needle) { return TypeConstructor.array(type.asTypeConstructorWithPlaceholderFor(needle)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: IOException { Path fontPath = Paths.get("src/test/resources/font_13132_0_edit.ttf"); TTFDataStream dataStream = new MemoryTTFDataStream(Files.newInputStream(fontPath)); final TrueTypeFont trueTypeFont = new TrueTypeFont().parse(dataStream);  final GlyphData glyph = trueTypeFont.getUnicodeGlyph('/'); GlyphDescription description = glyph.getDescription(); int count = description.getPointCount(); "<AssertPlaceHolder>"; }
getUnicodeGlyph(int code) throws IOException { int gid; if (cmaps == null || cmaps.length == 0) { // 没有cmap的情况直接返回第一个字符也就是空白字符 gid = 0; } else { gid = getUnicodeCmapLookup().getGlyphId(code); } return getGlyph(gid); }
[*] target: assertEquals(4, count)
[-] pred: org. junit. Assert. assertEquals ( 4, count )
************************************
************************************
[+] input: givenGenericType() { String toVerify = toTest() .withType(T.asType()) .getObjectPathOrTypeGenerator() .generate();  String expected = "T";  "<AssertPlaceHolder>"; }
generate() { Optional<String> optionalObjectPathAsString = optionalObjectPathGenerator.map(ObjectPathGenerator::generate); Optional<String> optionalConcreteTypeAsString = optionalConcreteType.map(FullyQualifiedName::raw); Optional<String> optionalGenericTypeAsString = optionalGenericType.map(TypeParameterName::raw); return optionalObjectPathAsString .map(Optional::of).orElse(optionalConcreteTypeAsString) .map(Optional::of).orElse(optionalGenericTypeAsString) .orElseThrow(NullPointerException::new); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testGenerateJarDir() { var sessionJob = TestUtils.buildSessionJob(); String baseDir = artifactManager.generateJarDir(sessionJob.getMetadata(), sessionJob.getSpec()); String expected = tempDir.toString() + File.separator + TestUtils.TEST_NAMESPACE + File.separator + TestUtils.TEST_DEPLOYMENT_NAME + File.separator + TestUtils.TEST_SESSION_JOB_NAME; Assertions."<AssertPlaceHolder>"; }
generateJarDir(ObjectMeta meta, FlinkSessionJobSpec spec) { return String.join( File.separator, new String[] { new File(configManager.getOperatorConfiguration().getArtifactsBaseDir()) .getAbsolutePath(), meta.getNamespace(), spec.getDeploymentName(), meta.getName() }); }
[*] target: assertEquals(expected, baseDir)
[-] pred: org. junit. Assert. assertEquals ( expected, baseDir )
************************************
************************************
[+] input: test_type_expression_tableExpression_isNull() { doCallRealMethod().when(taskNodeService).getMigrateTableNames(any(),any()); DatabaseNode databaseNode = new DatabaseNode(); databaseNode.setMigrateTableSelectType("expression"); taskNodeService.getMigrateTableNames(databaseNode,mock(UserDetail.class)); MetadataInstancesDto metadataInstancesDto1 = new MetadataInstancesDto(); metadataInstancesDto1.setOriginalName("test1"); MetadataInstancesDto metadataInstancesDto2 = new MetadataInstancesDto(); metadataInstancesDto2.setOriginalName("test2"); MetadataInstancesDto metadataInstancesDto3 = new MetadataInstancesDto(); when(metadataInstancesService.findSourceSchemaBySourceId(any(),any(),any(),any())).thenReturn(Arrays.asList(metadataInstancesDto1,metadataInstancesDto2,metadataInstancesDto3)); List<String> result = taskNodeService.getMigrateTableNames(databaseNode,mock(UserDetail.class)); Assertions."<AssertPlaceHolder>"; }
getMigrateTableNames(DatabaseNode sourceNode, UserDetail userDetail){ if (StringUtils.equals("expression", sourceNode.getMigrateTableSelectType())) { List<MetadataInstancesDto> metaInstances = metadataInstancesService.findSourceSchemaBySourceId(sourceNode.getConnectionId(), null, userDetail, "original_name"); return MetadataInstancesFilterUtil.getFilteredOriginalNames(metaInstances,sourceNode); }else{ return sourceNode.getTableNames(); } }
[*] target: assertEquals(0,result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: givenObjectPath() { String toVerify = toTest() .withObjectPath("this") .withObjectPath("property") .withObjectPath("current") .getObjectPathOrTypeGenerator() .generate();  String expected = "this.property.current";  "<AssertPlaceHolder>"; }
generate() { Optional<String> optionalObjectPathAsString = optionalObjectPathGenerator.map(ObjectPathGenerator::generate); Optional<String> optionalConcreteTypeAsString = optionalConcreteType.map(FullyQualifiedName::raw); Optional<String> optionalGenericTypeAsString = optionalGenericType.map(TypeParameterName::raw); return optionalObjectPathAsString .map(Optional::of).orElse(optionalConcreteTypeAsString) .map(Optional::of).orElse(optionalGenericTypeAsString) .orElseThrow(NullPointerException::new); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testReturnSubstringWithCodon5() { String expectedResult = this.expectedCodon5; String actualSubstringResult = returnSubstring(this.testInput, this.testCodon5); "<AssertPlaceHolder>"; }
returnSubstring(String dnaString, int index) { return dnaString.substring(index, index + 3).toUpperCase(); }
[*] target: assertEquals(expectedResult, actualSubstringResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualSubstringResult )
************************************
************************************
[+] input: parseDateTime6() { LocalDateTime localDateTime = LocalDateTime.of(2022, 1, 1, 0, 0, 0); String str1 = "2022 ";  LocalDateTime localDateTime1 = ExcelDateParseUtils.parseDateTime(str1);  Assertions."<AssertPlaceHolder>";  }
parseDateTime(String str) { return parseDateTimeWithPosition(str.replaceAll("\\s+", " ").trim()); }
[*] target: assertEquals(localDateTime, localDateTime1)
[-] pred: org. junit. Assert. assertEquals ( localDateTime, localDateTime1 )
************************************
************************************
[+] input: decode_ShouldDecodeByteBufferToValueAndReturnAsString() { String valueAsString = "10"; Integer value = Integer.valueOf(valueAsString); ByteBuffer byteBuffer = TypeCodecs.INT.encode(value, CqlConversion.PROTOCOL_VERSION);  String result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { Integer intValue = TypeCodecs.INT.decode(bytes, protocolVersion); return intValue.toString(); }
[*] target: assertEquals(valueAsString, result)
[-] pred: org. junit. Assert. assertEquals ( valueAsString, result )
************************************
************************************
[+] input: applyGivenTypeConstructorWithPlaceholder() { ConcreteType expected = Type.concrete(ERUDITE, STRING_TYPE.invariant(), BOOLEAN_TYPE.covariant(), INTEGER_TYPE.contravariant()); ConcreteType toVerify = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.invariant(), placeholder().covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant()).apply(BOOLEAN_TYPE);  "<AssertPlaceHolder>"; }
apply(Type toApplyTo) { List<TypeArgument> typeArguments = typeConstructorArguments .stream() .map(typeArgument -> typeArgument.apply(toApplyTo)) .collect(toList());  return Type.concrete(fullyQualifiedName, typeArguments); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(String value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } else { double doubleValue = Double.parseDouble(value); return TypeCodecs.DOUBLE.encode(doubleValue, protocolVersion); } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: parseObject3() { DefaultJSONParser parser = new DefaultJSONParser("null"); JSONObject object = parser.parseObject(); "<AssertPlaceHolder>"; }
parseObject() { if (reader.nextIfNull()) { return null; }  JSONObject object = new JSONObject(lexer.isOrderedField()); reader.read(object, 0L); return object; }
[*] target: assertNull(object)
[-] pred: org. junit. Assert. assertNull ( object )
************************************
************************************
[+] input: IOException {  String mockData = "some metric data"; InputStream inputStream = new ByteArrayInputStream(mockData.getBytes()); List<Metric> mockMetrics = Collections.singletonList(new Metric());  prometheusUtilMock.when( () -> PrometheusUtil.parseMetrics(any(InputStream.class)) ).thenReturn(mockMetrics);  boolean result = pushGatewayService.pushMetricsData(inputStream);  "<AssertPlaceHolder>"; prometheusUtilMock.verify( () -> PrometheusUtil.parseMetrics(any(InputStream.class)), times(1) ); }
pushMetricsData(InputStream inputStream) throws IOException;
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: replaceAllTypeParameterNamesGivenMappingThatContainsElementTypeConstructor() { Map<TypeParameterName, TypeParameterName> mapping = new HashMap<>(); mapping.put(T, A); mapping.put(U, B);  ConcreteTypeConstructor expected = new ConcreteTypeConstructor( ERUDITE, asList( STRING_TYPE_CONSTRUCTOR.invariant(), TypeConstructor.generic(A).covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant() ) );  ConcreteTypeConstructor toVerify = new ConcreteTypeConstructor( ERUDITE, asList( STRING_TYPE_CONSTRUCTOR.invariant(), TypeConstructor.generic(T).covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant() ) ).replaceTypeParameterNames(mapping);  "<AssertPlaceHolder>"; }
replaceTypeParameterNames(Map<TypeParameterName, TypeParameterName> replacement) { List<TypeConstructorArgument> replacedTypeConstructorArguments = typeConstructorArguments .stream() .map(typeConstructorArgument -> typeConstructorArgument.replaceAllTypeParameterNames(replacement)) .collect(toList());  return TypeConstructor.concrete(fullyQualifiedName, replacedTypeConstructorArguments); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: test_getJSONObject2() { JSONObject object = new JSONObject().fluentPut("values", new HashMap<>()); HashMap map = object.getJSONObject("values"); "<AssertPlaceHolder>"; }
size() { return map.size(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size ( ) )
************************************
************************************
[+] input: IOException { BilibiliResponse<UserNav> response = client.nav(); Assertions."<AssertPlaceHolder>"; logger.info(response.getMessage()); }
nav() throws IOException { checkBuVid3BuVid4(); return httpJsonClient.getJson(ApiUrlContainer.USER_NAV, new TypeReference<BilibiliResponse<UserNav>>() { }, requestHeader); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: decode_ShouldDecodeTextByteBufferAndReturnAsNumber() { String valueAsString = "12345.6789"; BigDecimal value = new BigDecimal(valueAsString); ByteBuffer byteBuffer = TypeCodecs.TEXT.encode(valueAsString, CqlConversion.PROTOCOL_VERSION);  BigDecimal result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { String stringValue = TypeCodecs.TEXT.decode(bytes, protocolVersion); return new BigDecimal(stringValue); }
[*] target: assertEquals(value, result)
[-] pred: org. junit. Assert. assertEquals ( value, result )
************************************
************************************
[+] input: bind_withTTLAndWritetime() { when(writetimeTTLFeature.isEnabled()).thenReturn(true); when(writetimeTTLFeature.hasTTLColumns()).thenReturn(true); when(writetimeTTLFeature.hasWritetimeColumns()).thenReturn(true); targetUpdateStatement = new TargetUpdateStatement(propertyHelper, targetSession);  BoundStatement result = targetUpdateStatement.bind(originRow, targetRow, 3600,10000L,null,null); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size()+2)).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { // We reference the originRow and convert it to the target type. // We need the targetRow if (null == originRow) throw new RuntimeException("originRow is null");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue);  BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  Object originValue, targetValue; Object bindValueTarget = null; for (int targetIndex : columnIndexesToBind) { int originIndex = cqlTable.getCorrespondingIndex(targetIndex);  try { if (usingCounter && counterIndexes.contains(targetIndex)) { originValue = cqlTable.getOtherCqlTable().getData(originIndex, originRow); if (null == originValue) { currentBindIndex++; continue; } targetValue = (null == targetRow ? 0L : cqlTable.getData(targetIndex, targetRow)); bindValueTarget = ((Long) originValue - (null == targetValue ? 0L : (Long) targetValue)); } else if (targetIndex== explodeMapKeyIndex) { bindValueTarget = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValueTarget = explodeMapValue; } else { if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValueTarget = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValueTarget, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValueTarget + " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex) + "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex); throw e; } }  PKFactory pkFactory = session.getPKFactory(); EnhancedPK pk = pkFactory.getTargetPK(originRow); boundStatement = pkFactory.bindWhereClause(PKFactory.Side.TARGET, pk, boundStatement, currentBindIndex);  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: whenObjectIsNull_ThenEqualsReturnsFalse() { GroupKey id1 = new GroupKey("group-1");  "<AssertPlaceHolder>"; }
equals(@Nullable Object o) { if (this == o) { return true; }  if (o == null || getClass() != o.getClass()) { return false; }  GroupKey other = (GroupKey) o; return this.id.equals(other.id); }
[*] target: assertFalse(id1.equals(null))
[-] pred: org. junit. Assert. assertFalse ( id1. equals ( null ) )
************************************
************************************
[+] input: returnsNullWhenNodeIsNotInstanceOfMergeTableNode() { String nodeId = "testNodeId"; DAG dag = mock(DAG.class); when(dag.getNode(nodeId)).thenReturn(null);  MergeTableNode result = mergeNodeCleaner.getMergeTableNode(dag, nodeId);  "<AssertPlaceHolder>"; }
getMergeTableNode(DAG dag, String nodeId) { Node<?> node = dag.getNode(nodeId); if (node instanceof MergeTableNode) { return (MergeTableNode) node; } return null; }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testCheckWhenFailed() { DeptTreeDataPermissionChecker checker = new DeptTreeDataPermissionChecker(deptService);  when(deptService.isChildOfTheDept(any(), any())).thenReturn(false); when(loginUser.getDeptId()).thenReturn(1L); DataCondition dataCondition = new DataCondition(); dataCondition.setTargetDeptId(2L);  boolean check = checker.check(loginUser, dataCondition);  "<AssertPlaceHolder>"; }
check(SystemLoginUser loginUser, DataCondition condition) { if (condition == null || loginUser == null) { return false; }  if (loginUser.getDeptId() == null || condition.getTargetDeptId() == null) { return false; }  Long currentDeptId = loginUser.getDeptId(); Long targetDeptId = condition.getTargetDeptId();  boolean isContainsTargetDept = deptService.isChildOfTheDept(loginUser.getDeptId(), targetDeptId); boolean isSameDept = Objects.equals(currentDeptId, targetDeptId);  return isContainsTargetDept || isSameDept; }
[*] target: assertFalse(check)
[-] pred: org. junit. Assert. assertFalse ( check )
************************************
************************************
[+] input: isEmptyTest() { // 这是jdk11 Optional中的新函数，直接照搬了过来 // 判断包裹内元素是否为空，注意并没有判断空字符串的情况 final boolean isEmpty = Opp.empty().isEmpty(); Assertions."<AssertPlaceHolder>"; }
isEmpty() { return value == null; }
[*] target: assertTrue(isEmpty)
[-] pred: org. junit. Assert. assertTrue ( isEmpty )
************************************
************************************
[+] input: testNeedSkipNormalNotName() { File f = mock(File.class); when(f.exists()).thenReturn(true); when(f.isFile()).thenReturn(true); when(f.getName()).thenReturn("install.py"); boolean needSkip = utils.needSkip(f); Assertions."<AssertPlaceHolder>"; }
needSkip(File f) { if (null == f) return true; if (!f.exists()) return true; if (!f.isFile()) return true; return !f.getName().contains(PACKAGE_COMPILATION_FILE); }
[*] target: assertTrue(needSkip)
[-] pred: org. junit. Assert. assertTrue ( needSkip )
************************************
************************************
[+] input: testCheckIsCronOrPlanTaskWithFalsePlanTask() { TaskRepository repository = mock(TaskRepository.class); taskService = spy(new TaskServiceImpl(repository)); TaskDto taskDto = new TaskDto(); taskDto.setPlanStartDateFlag(false); boolean result = taskService.checkIsCronOrPlanTask(taskDto); "<AssertPlaceHolder>"; }
checkIsCronOrPlanTask(TaskDto task);  public abstract List<MutiResponseMessage> batchStop(List<ObjectId> taskIds, UserDetail user, HttpServletRequest request, HttpServletResponse response);  public abstract List<MutiResponseMessage> batchDelete(List<ObjectId> taskIds, UserDetail user, HttpServletRequest request, HttpServletResponse response);  public abstract List<MutiResponseMessage> batchRenew(List<ObjectId> taskIds, UserDetail user, HttpServletRequest request, HttpServletResponse response);  public abstract Page<TaskDto> scanTask(Filter filter, UserDetail userDetail);  public Page<TaskDto> find(Filter filter, UserDetail userDetail){ return super.find(filter, userDetail); }
[*] target: assertEquals(false, result)
[-] pred: org. junit. Assert. assertEquals ( false, result )
************************************
************************************
[+] input: testTryEmitTwoBucketSuccess() { when(mockOutBox.offer(anyInt(), any(TapdataEvent.class))).thenReturn(true); boolean actual = hazelcastBaseNode.tryEmit(tapdataEvent, 2); "<AssertPlaceHolder>"; }
tryEmit(TapdataEvent dataEvent, int bucketCount) { if (null == dataEvent) { return true; } if (bucketCount > 1) { for (bucketIndex = Math.min(bucketIndex, bucketCount); bucketIndex < bucketCount; bucketIndex++) { TapdataEvent cloneEvent = (TapdataEvent) dataEvent.clone(); if (!tryEmit(bucketIndex, cloneEvent)) { return false; } } } else { return tryEmit(dataEvent); } return true; }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(String value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } Instant instantValue = LocalDateTime.parse(value, formatter).toInstant(zoneOffset); return TypeCodecs.TIMESTAMP.encode(instantValue, protocolVersion); }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: covariantConcreteTypeConstructorCanAcceptGivenEquivalentCovariantConcreteTypeConstructor() { ConcreteTypeConstructor target = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.covariant()); ConcreteTypeConstructor source = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.covariant());  "<AssertPlaceHolder>"; }
canAccept(TypeConstructor typeConstructor) { if (typeConstructor instanceof ConcreteTypeConstructor) { ConcreteTypeConstructor that = (ConcreteTypeConstructor) typeConstructor;  return this.fullyQualifiedNameEqualToThatOf(that) && this.typeArgumentsCanAccept(that); } else { return false; } }
[*] target: assertTrue(target.canAccept(source))
[-] pred: org. junit. Assert. assertTrue ( target. canAccept ( source ) )
************************************
************************************
[+] input: testGetLocationByName() { StringValue locationName = StringValue.newBuilder().setValue("locationName").build(); MonitoringLocationDTO expectedLocation = MonitoringLocationDTO.newBuilder().build(); when(tenantLookup.lookupTenantId(any())).thenReturn(Optional.of(TENANT_ID)); when(service.findByLocationAndTenantId(anyString(), anyString())).thenReturn(Optional.of(expectedLocation));  grpcService.getLocationByName(locationName, getResponseObserver);  verify(getResponseObserver).onNext(getResponseCaptor.capture()); verify(getResponseObserver).onCompleted(); MonitoringLocationDTO response = getResponseCaptor.getValue(); "<AssertPlaceHolder>"; }
getLocationByName(StringValue locationName, StreamObserver<MonitoringLocationDTO> responseObserver) { Optional<MonitoringLocationDTO> location = tenantLookup .lookupTenantId(Context.current()) .map(tenantId -> service.findByLocationAndTenantId(locationName.getValue(), tenantId)) .orElseThrow(); if (location.isPresent()) { responseObserver.onNext(location.get()); responseObserver.onCompleted(); } else { Status status = Status.newBuilder() .setCode(Code.NOT_FOUND_VALUE) .setMessage("Location with name: " + locationName.getValue() + " doesn't exist") .build(); responseObserver.onError(StatusProto.toStatusRuntimeException(status)); } }
[*] target: assertEquals(expectedLocation, response)
[-] pred: org. junit. Assert. assertEquals ( expectedLocation, response )
************************************
************************************
[+] input: testNeedSkipNormalNullFile() { boolean needSkip = utils.needSkip(null); Assertions."<AssertPlaceHolder>"; }
needSkip(File f) { if (null == f) return true; if (!f.exists()) return true; if (!f.isFile()) return true; return !f.getName().contains(PACKAGE_COMPILATION_FILE); }
[*] target: assertTrue(needSkip)
[-] pred: org. junit. Assert. assertTrue ( needSkip )
************************************
************************************
[+] input: execute() { Executor executor = DirectExecutor.INSTANCE; final boolean[] ran = {false}; executor.execute(() -> ran[0] = true); "<AssertPlaceHolder>"; }
execute(Runnable command) { command.run(); }
[*] target: assertTrue(ran[0])
[-] pred: org. junit. Assert. assertTrue ( ran[0] )
************************************
************************************
[+] input: marshalNullDataPreserveNullsFalseTest() { final byte[] hmacText = fingerprintTransformer.marshal(null, context); "<AssertPlaceHolder>"; }
marshal(final byte[] cleartext, final EncryptionContext encryptionContext) { if (encryptionContext == null) { throw new C3rIllegalArgumentException("An EncryptionContext must be provided when marshaling."); } if (encryptionContext.getClientDataType() == null) { throw new C3rIllegalArgumentException("EncryptionContext missing ClientDataType when encrypting data for column `" + encryptionContext.getColumnLabel() + "`."); } if (!encryptionContext.getClientDataType().supportsFingerprintColumns()) { throw new C3rIllegalArgumentException(encryptionContext.getClientDataType() + " is not a type supported by " + "fingerprint columns."); } if (!encryptionContext.getClientDataType().isEquivalenceClassRepresentativeType()) { throw new C3rIllegalArgumentException(encryptionContext.getClientDataType() + " is not the parent type of its equivalence " + "class. Expected parent type is " + encryptionContext.getClientDataType().getRepresentativeType() + "."); }  // Check if a plain null value should be used if (cleartext == null) { if (clientSettings.isPreserveNulls()) { return null; } }  final byte[] key; if (clientSettings.isAllowJoinsOnColumnsWithDifferentNames()) { key = hkdf.deriveKey(HKDF_INFO_BYTES, HMAC_KEY_SIZE); } else { final byte[] hkdfKeyInfo = (KeyUtil.HKDF_COLUMN_BASED_INFO + encryptionContext.getColumnLabel()) .getBytes(StandardCharsets.UTF_8); key = hkdf.deriveKey(hkdfKeyInfo, HMAC_KEY_SIZE); } final SecretKeySpec secretKeySpec = new SecretKeySpec(key, mac.getAlgorithm()); Arrays.fill(key, (byte) 0); // Safe to zero here. SecretKeySpec takes a clone on instantiation. try { mac.init(secretKeySpec); } catch (InvalidKeyException e) { throw new C3rRuntimeException("Initialization of hmac failed for target column `" + encryptionContext.getColumnLabel() + "`.", e); } final byte[] hmacBase64 = Base64.getEncoder().encode(mac.doFinal(cleartext)); final byte[] marshalledBytes = ByteBuffer.allocate(DESCRIPTOR_PREFIX.length + hmacBase64.length) .put(DESCRIPTOR_PREFIX) .put(hmacBase64) .array(); validateMarshalledByteLength(marshalledBytes); return marshalledBytes; }
[*] target: assertNotNull(hmacText)
[-] pred: org. junit. Assert. assertNotNull ( hmacText )
************************************
************************************
[+] input: shouldIsRandomDNAReturnTrue() { boolean actual = Properties.isRandomDNA(dnaString); "<AssertPlaceHolder>"; }
isRandomDNA(final String dna) { long[] nucleotideCount = countBasePairs(dna); int[] percentages = Arrays.stream(nucleotideCount).mapToInt(c -> nucleotidePercentage(c, dna)).toArray();  int a = percentages[BasePairIndex.ADENINE]; int t = percentages[BasePairIndex.THYMINE]; int g = percentages[BasePairIndex.GUANINE]; int c = percentages[BasePairIndex.CYTOSINE];  IntStream diffs = IntStream.of( Math.abs(a - t), Math.abs(a - g), Math.abs(a - c), Math.abs(t - g), Math.abs(t - c), Math.abs(g - c));  return diffs.allMatch(diff -> diff <= 2); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: registroBRPass() { RegistroBR registroBR = BrasilAPI.registroBR("savio.pw"); "<AssertPlaceHolder>"; }
registroBR(String domain) { RegistroBR obj = (RegistroBR) api(RegistroBR.class, "registrobr/v1/", domain); return obj != null ? (RegistroBR) obj.clone() : null; }
[*] target: assertNotNull(registroBR)
[-] pred: org. junit. Assert. assertNotNull ( registroBR )
************************************
************************************
[+] input: of() { GenericType expected = new GenericType(T); GenericType toVerify = GenericType.of(T);  "<AssertPlaceHolder>"; }
of(TypeParameterName name) { return new GenericType(name); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: format_ShouldFormatValueAsString() { String valueAsString = "123.456"; BigDecimal value = new BigDecimal(valueAsString); String expected = TypeCodecs.DECIMAL.format(value);  String result = codec.format(valueAsString); Assertions."<AssertPlaceHolder>"; }
format(String value) { BigDecimal decimalValue = new BigDecimal(value); return TypeCodecs.DECIMAL.format(decimalValue); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testIsAvailableTerm() { //        //given //        given(couponCampaign.getValidTerm()).willReturn(validTerm); //        //LocalDateTime localDateTime = Mockito.mock(new // TypeToken<IssuedCoupon>(){}.getCreatedAt()); //        given(issuedCoupon.getCreatedAt()).willReturn(createdAt); //        //when //        Boolean result = issuedCoupon.isAvailableTerm(); //        //then //        "<AssertPlaceHolder>"; //    }
isAvailableTerm() { return !LocalDateTime.now() .isAfter(this.getCreatedAt().plusDays(this.getCouponCampaign().getValidTerm())); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testSaveServiceConfig_ClusterHostServiceReturnsNoItems() { // Setup final ServiceConfig serviceConfig = new ServiceConfig(); serviceConfig.setName("name"); serviceConfig.setValue("value"); serviceConfig.setLabel("label"); serviceConfig.setDescription("description"); serviceConfig.setRequired(false); serviceConfig.setType("type"); serviceConfig.setConfigurableInWizard(false); serviceConfig.setDefaultValue("defaultValue"); serviceConfig.setMinValue(0); serviceConfig.setMaxValue(0); serviceConfig.setUnit("unit"); serviceConfig.setHidden(false); serviceConfig.setSelectValue(Arrays.asList("value")); serviceConfig.setConfigType("configType"); final List<ServiceConfig> list = Arrays.asList(serviceConfig); final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  // Configure ClusterInfoService.getById(...). final ClusterInfoEntity clusterInfoEntity = new ClusterInfoEntity(); clusterInfoEntity.setId(0); clusterInfoEntity.setCreateBy("createBy"); clusterInfoEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterInfoEntity.setClusterName("clusterName"); clusterInfoEntity.setClusterCode("clusterCode"); clusterInfoEntity.setClusterFrame("clusterFrame"); clusterInfoEntity.setFrameVersion("frameVersion"); clusterInfoEntity.setClusterState(ClusterState.RUNNING); clusterInfoEntity.setFrameId(0); final UserInfoEntity userInfoEntity = new UserInfoEntity(); userInfoEntity.setId(0); userInfoEntity.setUsername("username"); userInfoEntity.setPassword("password"); userInfoEntity.setEmail("email"); userInfoEntity.setPhone("phone"); clusterInfoEntity.setClusterManagerList(Arrays.asList(userInfoEntity)); when(mockClusterInfoService.getById(0)).thenReturn(clusterInfoEntity);  // Configure FrameServiceService.getServiceByFrameCodeAndServiceName(...). final FrameServiceEntity frameServiceEntity = new FrameServiceEntity(); frameServiceEntity.setId(0); frameServiceEntity.setFrameId(0); frameServiceEntity.setServiceName("serviceName"); frameServiceEntity.setLabel("label"); frameServiceEntity.setServiceVersion("serviceVersion"); frameServiceEntity.setServiceDesc("serviceDesc"); frameServiceEntity.setPackageName("packageName"); frameServiceEntity.setDependencies("dependencies"); frameServiceEntity.setServiceJson("serviceJson"); frameServiceEntity.setServiceJsonMd5("serviceJsonMd5"); frameServiceEntity.setServiceConfig("serviceConfig"); frameServiceEntity.setFrameCode("frameCode"); frameServiceEntity.setConfigFileJson("configFileJson"); frameServiceEntity.setConfigFileJsonMd5("configFileJsonMd5"); frameServiceEntity.setSortNum(0); when(mockFrameService.getServiceByFrameCodeAndServiceName("clusterFrame", "serviceName")).thenReturn( frameServiceEntity);  // Configure ClusterVariableService.getVariableByVariableName(...). final ClusterVariable clusterVariable = new ClusterVariable(); clusterVariable.setId(0); clusterVariable.setClusterId(0); clusterVariable.setVariableName("variableName"); clusterVariable.setVariableValue("variableValue"); when(mockVariableService.getVariableByVariableName("variableName", 0)).thenReturn(clusterVariable);  when(mockVariableService.updateById(new ClusterVariable())).thenReturn(false); when(mockVariableService.save(new ClusterVariable())).thenReturn(false); when(mockHostService.list(any(QueryWrapper.class))).thenReturn(Collections.emptyList());  // Configure ClusterServiceInstanceService.getServiceInstanceByClusterIdAndServiceName(...). final ClusterServiceInstanceEntity clusterServiceInstanceEntity = new ClusterServiceInstanceEntity(); clusterServiceInstanceEntity.setId(0); clusterServiceInstanceEntity.setClusterId(0); clusterServiceInstanceEntity.setServiceName("serviceName"); clusterServiceInstanceEntity.setLabel("label"); clusterServiceInstanceEntity.setServiceState(ServiceState.WAIT_INSTALL); clusterServiceInstanceEntity.setServiceStateCode(0); clusterServiceInstanceEntity.setUpdateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceInstanceEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceInstanceEntity.setNeedRestart(NeedRestart.NO); clusterServiceInstanceEntity.setFrameServiceId(0); clusterServiceInstanceEntity.setDashboardUrl("dashboardUrl"); clusterServiceInstanceEntity.setAlertNum(0); clusterServiceInstanceEntity.setSortNum(0); when(mockServiceInstanceService.getServiceInstanceByClusterIdAndServiceName(0, "serviceName")).thenReturn( clusterServiceInstanceEntity);  when(mockServiceInstanceService.save(new ClusterServiceInstanceEntity())).thenReturn(false); when(mockRoleGroupService.save(new ClusterServiceInstanceRoleGroup())).thenReturn(false); when(mockGroupConfigService.save(new ClusterServiceRoleGroupConfig())).thenReturn(false);  // Configure ClusterServiceInstanceRoleGroupService.getRoleGroupByServiceInstanceId(...). final ClusterServiceInstanceRoleGroup clusterServiceInstanceRoleGroup = new ClusterServiceInstanceRoleGroup(); clusterServiceInstanceRoleGroup.setId(0); clusterServiceInstanceRoleGroup.setRoleGroupName("默认角色组"); clusterServiceInstanceRoleGroup.setServiceInstanceId(0); clusterServiceInstanceRoleGroup.setServiceName("serviceName"); clusterServiceInstanceRoleGroup.setClusterId(0); clusterServiceInstanceRoleGroup.setRoleGroupType("auto"); when(mockRoleGroupService.getRoleGroupByServiceInstanceId(0)).thenReturn(clusterServiceInstanceRoleGroup);  // Configure ClusterServiceRoleGroupConfigService.getConfigByRoleGroupId(...). final ClusterServiceRoleGroupConfig clusterServiceRoleGroupConfig = new ClusterServiceRoleGroupConfig(); clusterServiceRoleGroupConfig.setId(0); clusterServiceRoleGroupConfig.setRoleGroupId(0); clusterServiceRoleGroupConfig.setConfigJson("configJson"); clusterServiceRoleGroupConfig.setConfigJsonMd5("configJsonMd5"); clusterServiceRoleGroupConfig.setConfigVersion(0); clusterServiceRoleGroupConfig.setConfigFileJson("configFileJson"); clusterServiceRoleGroupConfig.setConfigFileJsonMd5("configFileJsonMd5"); clusterServiceRoleGroupConfig.setClusterId(0); clusterServiceRoleGroupConfig.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceRoleGroupConfig.setUpdateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceRoleGroupConfig.setServiceName("serviceName"); when(mockGroupConfigService.getConfigByRoleGroupId(0)).thenReturn(clusterServiceRoleGroupConfig);  when(mockRoleGroupService.count(any(QueryWrapper.class))).thenReturn(0); when(mockServiceInstanceService.updateById(new ClusterServiceInstanceEntity())).thenReturn(false);  // Run the test final Result result = serviceInstallServiceImplUnderTest.saveServiceConfig(0, "serviceName", list, 0);  // Verify the results "<AssertPlaceHolder>"; verify(mockVariableService).updateById(new ClusterVariable()); verify(mockVariableService).save(new ClusterVariable()); verify(mockServiceInstanceService).save(new ClusterServiceInstanceEntity()); verify(mockRoleGroupService).save(new ClusterServiceInstanceRoleGroup()); verify(mockGroupConfigService).save(new ClusterServiceRoleGroupConfig()); verify(mockRoleInstanceService).updateToNeedRestart(0); verify(mockServiceInstanceService).updateById(new ClusterServiceInstanceEntity()); }
saveServiceConfig( Integer clusterId, String serviceName, List<ServiceConfig> list, Integer roleGroupId) { ClusterInfoEntity clusterInfo = clusterInfoService.getById(clusterId); ServiceConfigMap.put( clusterInfo.getClusterCode() + Constants.UNDERLINE + serviceName + Constants.CONFIG, list); HashMap<String, ServiceConfig> map = new HashMap<>(); Map<String, String> globalVariables = GlobalVariables.get(clusterId); // handler config ServiceRoleStrategy serviceRoleHandler = ServiceRoleStrategyContext.getServiceRoleHandler(serviceName); if (Objects.nonNull(serviceRoleHandler)) { serviceRoleHandler.handlerConfig(clusterId, list, ServiceRoleStrategyContext.getServiceName(serviceName)); } // add variable FrameServiceEntity frameServiceEntity = frameService.getServiceByFrameCodeAndServiceName( clusterInfo.getClusterFrame(), serviceName); Boolean configUpdate = false; for (ServiceConfig serviceConfig : list) { String configName = serviceConfig.getName(); String variableName = "${" + configName + "}"; String variableValue = String.valueOf(serviceConfig.getValue()); // add to global variable if (Constants.INPUT.equals(serviceConfig.getType())) { addToGlobalVariable(clusterId, serviceName, variableName, variableValue); } globalVariables.put(variableName, variableValue); map.put(serviceConfig.getName(), serviceConfig); } // update config-file HashMap<Generators, List<ServiceConfig>> configFileMap = new HashMap<>(); buildConfigFileMap(serviceName, clusterInfo, map, configFileMap); if (PROMETHEUS.equals(serviceName.toLowerCase())) { logger.info("add worker and node to prometheus"); // add host node to prometheus addHostNodeToPrometheus(clusterId, configFileMap); } ClusterServiceInstanceEntity serviceInstanceEntity = serviceInstanceService.getServiceInstanceByClusterIdAndServiceName( clusterId, serviceName); if (Objects.isNull(serviceInstanceEntity)) { serviceInstanceEntity = saveServiceInstance(clusterId, serviceName, frameServiceEntity); ClusterServiceInstanceRoleGroup clusterServiceInstanceRoleGroup = saveServiceInstanceRoleGroup(clusterId, serviceName, serviceInstanceEntity); saveServiceRoleGroupConfig( clusterId, serviceName, list, configFileMap, clusterServiceInstanceRoleGroup); CacheUtils.put( "UseRoleGroup_" + serviceInstanceEntity.getId(), clusterServiceInstanceRoleGroup.getId()); } else { configUpdate = isConfigNeedUpdate(serviceInstanceEntity, list); ClusterServiceRoleGroupConfig roleGroupConfig; if (Objects.isNull(roleGroupId)) { ClusterServiceInstanceRoleGroup roleGroup = roleGroupService.getRoleGroupByServiceInstanceId( serviceInstanceEntity.getId()); roleGroupConfig = groupConfigService.getConfigByRoleGroupId(roleGroup.getId()); } else { roleGroupConfig = groupConfigService.getConfigByRoleGroupId(roleGroupId); } CacheUtils.put( "UseRoleGroup_" + serviceInstanceEntity.getId(), roleGroupConfig.getRoleGroupId()); if (configUpdate) { ClusterServiceRoleGroupConfig newRoleGroupConfig = new ClusterServiceRoleGroupConfig(); if (Objects.isNull(roleGroupId)) { ClusterServiceInstanceRoleGroup roleGroup = saveNewRoleGroup(serviceInstanceEntity); newRoleGroupConfig.setConfigVersion(1); newRoleGroupConfig.setRoleGroupId(roleGroup.getId()); CacheUtils.put( "UseRoleGroup_" + serviceInstanceEntity.getId(), roleGroup.getId()); } else { newRoleGroupConfig.setConfigVersion(roleGroupConfig.getConfigVersion() + 1); newRoleGroupConfig.setRoleGroupId(roleGroupConfig.getRoleGroupId()); roleInstanceService.updateToNeedRestart(roleGroupId); roleGroupService.updateToNeedRestart(roleGroupId); serviceInstanceEntity.setNeedRestart(NeedRestart.YES); } newRoleGroupConfig.setClusterId(clusterId); newRoleGroupConfig.setCreateTime(new Date()); newRoleGroupConfig.setUpdateTime(new Date()); newRoleGroupConfig.setServiceName(serviceInstanceEntity.getServiceName()); buildConfig(list, configFileMap, newRoleGroupConfig); groupConfigService.save(newRoleGroupConfig); } // update service instance serviceInstanceEntity.setUpdateTime(new Date()); serviceInstanceEntity.setLabel(frameServiceEntity.getLabel()); serviceInstanceService.updateById(serviceInstanceEntity); } return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismTwoNodeButNotAllNodeAreDataParentNode0() { when(nodeList.size()).thenReturn(2); JsProcessorNode node2 = mock(JsProcessorNode.class); when(nodeList.get(0)).thenReturn(node2);  DataParentNode node1 = mock(DataParentNode.class); when(node1.getDatabaseType()).thenReturn("mock-type"); when(nodeList.get(1)).thenReturn(node1); boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(1)).get(0); verify(nodeList, times(0)).get(1); verify(node1, times(0)).getDatabaseType(); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: decode_ShouldDecodeByteBufferToValueAndReturnAsString() { String valueAsString = "9223372036854775807"; Long value = Long.parseLong(valueAsString); ByteBuffer byteBuffer = TypeCodecs.BIGINT.encode(value, CqlConversion.PROTOCOL_VERSION);  String result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { Long longValue = TypeCodecs.BIGINT.decode(bytes, protocolVersion); return longValue.toString(); }
[*] target: assertEquals(valueAsString, result)
[-] pred: org. junit. Assert. assertEquals ( valueAsString, result )
************************************
************************************
[+] input: testSubCronOrPlanNum() { taskEntity.setCrontabExpressionFlag(true); try (MockedStatic<DataPermissionHelper> dataPermissionHelperMockedStatic = mockStatic(DataPermissionHelper.class)) { int result = taskService.subCronOrPlanNum(taskDto, 3); "<AssertPlaceHolder>"; } }
subCronOrPlanNum(TaskDto task, int runningNum);  public abstract boolean checkIsCronOrPlanTask(TaskDto task);  public abstract List<MutiResponseMessage> batchStop(List<ObjectId> taskIds, UserDetail user, HttpServletRequest request, HttpServletResponse response);  public abstract List<MutiResponseMessage> batchDelete(List<ObjectId> taskIds, UserDetail user, HttpServletRequest request, HttpServletResponse response);  public abstract List<MutiResponseMessage> batchRenew(List<ObjectId> taskIds, UserDetail user, HttpServletRequest request, HttpServletResponse response);  public abstract Page<TaskDto> scanTask(Filter filter, UserDetail userDetail);  public Page<TaskDto> find(Filter filter, UserDetail userDetail){ return super.find(filter, userDetail); }
[*] target: assertEquals(2, result)
[-] pred: org. junit. Assert. assertEquals ( 2, result )
************************************
************************************
[+] input: testReturnSubstringWithCodon7() { String expectedResult = this.expectedCodon7; String actualSubstringResult = returnSubstring(this.testInput, this.testCodon7); "<AssertPlaceHolder>"; }
returnSubstring(String dnaString, int index) { return dnaString.substring(index, index + 3).toUpperCase(); }
[*] target: assertEquals(expectedResult, actualSubstringResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualSubstringResult )
************************************
************************************
[+] input: testHorizontalLayoutWithLabel() {  UISchemaBuilder builder = new UISchemaBuilder(Layout.HORIZONTAL); builder.addElement("firstName", "First Name", null). // addElements("lastName", "role");  String json = builder.build();  "<AssertPlaceHolder>";  logger.info(json);  }
build() {  // close current controllsBuilder.... if (controlsArrayBuilder != null && layoutContext != null) { layoutContext.add("elements", controlsArrayBuilder.build()); }  if (groupArrayBuilder != null) {  // close current layoutContext.... if (layoutsArrayBuilder != null && layoutContext != null) { this.layoutsArrayBuilder.add(layoutContext.build()); }  // close current gourpContext if (groupContext != null) { groupContext.add("elements", layoutsArrayBuilder.build()); groupArrayBuilder.add(groupContext); }  rootLayoutBuilder.add("elements", groupArrayBuilder.build()); }  // write result JsonObject jsonObject = rootLayoutBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: applyGivenTypeConstructorWithoutPlaceholder() { ArrayType expected = new ArrayType(STRING_TYPE); ArrayType toVerify = new ArrayTypeConstructor(STRING_TYPE_CONSTRUCTOR).apply(INTEGER_TYPE);  "<AssertPlaceHolder>"; }
apply(Type toApplyTo) { return Type.array(type.apply(toApplyTo)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: 인물_관계_탑승하기() { // given var expected = new CharacterHistory( CHARACTER_ID, USER_ID );  Mockito.when(characterHistoryRepository.save(any())) .thenReturn(expected); // when var actual = characterHistoryService.save(CHARACTER_ID, USER_ID); // then "<AssertPlaceHolder>"; }
save(Long characterId, Long userId) { var characterHistory = new CharacterHistory(characterId, userId); return characterHistoryRepository.save(characterHistory); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldTriggerAutomaticSnapshot_EmptyExpression() { boolean shouldTrigger = shouldTriggerAutomaticSnapshot( CHECKPOINT, "", Instant.now().minus(Duration.ofDays(365))); "<AssertPlaceHolder>"; }
shouldTriggerAutomaticSnapshot( SnapshotType snapshotType, String automaticTriggerExpression, Instant lastTrigger) { if (StringUtils.isBlank(automaticTriggerExpression)) { return false; } // automaticTriggerExpression was configured by the user  Optional<Duration> interval = interpretAsInterval(automaticTriggerExpression); Optional<CronExpression> cron = interpretAsCron(automaticTriggerExpression);  // This should never happen. The string cannot be both a valid Duration and a cron // expression at the same time. if (interval.isPresent() && cron.isPresent()) { LOG.error( "Something went wrong with the automatic {} trigger expression {}. This setting cannot be simultaneously a valid Duration and a cron expression.", snapshotType, automaticTriggerExpression); return false; }  if (interval.isPresent()) { return shouldTriggerIntervalBasedSnapshot(snapshotType, interval.get(), lastTrigger); } else if (cron.isPresent()) { return shouldTriggerCronBasedSnapshot( snapshotType, cron.get(), lastTrigger, Instant.now()); } else { LOG.warn( "Automatic {} triggering is configured, but the trigger expression '{}' is neither a valid Duration, nor a cron expression.", snapshotType, automaticTriggerExpression); return false; } }
[*] target: assertFalse(shouldTrigger)
[-] pred: org. junit. Assert. assertFalse ( shouldTrigger )
************************************
************************************
[+] input: testRunningTaskNumWithProcessId() { TaskRepository taskRepository = mock(TaskRepository.class); taskService = new TaskServiceImpl(taskRepository); long except = 5L; UserDetail userDetail = mock(UserDetail.class); when(taskRepository.count(Query.query(Criteria.where("agentId").is("111") .and("is_deleted").ne(true).and("syncType").in(TaskDto.SYNC_TYPE_SYNC, TaskDto.SYNC_TYPE_MIGRATE) .and("status").nin(TaskDto.STATUS_DELETE_FAILED, TaskDto.STATUS_DELETING) .orOperator(Criteria.where("status").in(TaskDto.STATUS_RUNNING, TaskDto.STATUS_SCHEDULING, TaskDto.STATUS_WAIT_RUN), Criteria.where("planStartDateFlag").is(true), Criteria.where("crontabExpressionFlag").is(true) )), userDetail)).thenReturn(except); long result = taskService.runningTaskNum("111", userDetail); "<AssertPlaceHolder>"; }
runningTaskNum(String processId, UserDetail userDetail);  public abstract TaskEntity convertToEntity(Class entityClass, BaseDto dto, String... ignoreProperties);  public <T extends BaseDto> T convertToDto(TaskEntity entity, Class<T> dtoClass, String... ignoreProperties){ return super.convertToDto(entity, dtoClass, ignoreProperties); }
[*] target: assertEquals(except, result)
[-] pred: org. junit. Assert. assertEquals ( except, result )
************************************
************************************
[+] input: getMonitorDto() { long id = 1L; Monitor monitor = Monitor.builder().jobId(id).intervals(1).app("app").name("memory").host("host").id(id).build(); when(monitorDao.findById(id)).thenReturn(Optional.of(monitor)); List<Param> params = Collections.singletonList(new Param()); when(paramDao.findParamsByMonitorId(id)).thenReturn(params); Job job = new Job(); job.setMetrics(new ArrayList<>()); when(appService.getAppDefine(monitor.getApp())).thenReturn(job); MonitorDto monitorDto = monitorService.getMonitorDto(id); "<AssertPlaceHolder>"; }
getMonitorDto(long id) throws RuntimeException;
[*] target: assertNotNull(monitorDto)
[-] pred: org. junit. Assert. assertNotNull ( monitorDto )
************************************
************************************
[+] input: testRunningTaskNumWithProcessId() { TaskRepository taskRepository = mock(TaskRepository.class); taskService = new TaskServiceImpl(taskRepository); long except = 5L; UserDetail userDetail = mock(UserDetail.class); when(taskRepository.count(Query.query(Criteria.where("agentId").is("111") .and("is_deleted").ne(true).and("syncType").in(TaskDto.SYNC_TYPE_SYNC, TaskDto.SYNC_TYPE_MIGRATE) .and("status").nin(TaskDto.STATUS_DELETE_FAILED,TaskDto.STATUS_DELETING) .orOperator(Criteria.where("status").in(TaskDto.STATUS_RUNNING, TaskDto.STATUS_SCHEDULING, TaskDto.STATUS_WAIT_RUN), Criteria.where("planStartDateFlag").is(true), Criteria.where("crontabExpressionFlag").is(true) )), userDetail)).thenReturn(except); long result = taskService.runningTaskNum("111", userDetail); "<AssertPlaceHolder>"; }
runningTaskNum(String processId, UserDetail userDetail) { long workNum = count(Query.query(Criteria.where(AGENT_ID).is(processId) .and(IS_DELETED).ne(true).and(SYNC_TYPE).in(TaskDto.SYNC_TYPE_SYNC, TaskDto.SYNC_TYPE_MIGRATE) .and(STATUS).nin(TaskDto.STATUS_DELETE_FAILED,TaskDto.STATUS_DELETING) .orOperator(Criteria.where(STATUS).in(TaskDto.STATUS_RUNNING, TaskDto.STATUS_SCHEDULING, TaskDto.STATUS_WAIT_RUN), Criteria.where(PLAN_START_DATE_FLAG).is(true), Criteria.where(CRONTAB_EXPRESSION_FLAG).is(true) )), userDetail); return (int) workNum; }
[*] target: assertEquals(except,result)
[-] pred: org. junit. Assert. assertEquals ( except, result )
************************************
************************************
[+] input: MessagingException { when(mu.connectSMTP(any(Session.class))).thenCallRealMethod(); doCallRealMethod().when(mu).closeTransport(any(Transport.class)); doNothing().when(transport).connect(anyString(), anyInt(), anyString(), anyString()); doNothing().when(mu).initMailConfig(); doNothing().when(transport).close(); doNothing().when(transport).sendMessage(any(MimeMessage.class), any(Address[].class)); Session session = mock(Session.class); InternetAddress[] internetAddressList = new InternetAddress[0]; Address[] addresses = new Address[0];  doNothing().when(session).setDebug(true); when(session.getTransport("smtp")).thenReturn(transport); try(MockedStatic<Session> s = mockStatic(Session.class); MockedConstruction<InternetAddress> i = mockConstruction(InternetAddress.class, (ic, c) -> {}); MockedConstruction<MimeMessage> m = mockConstruction(MimeMessage.class, (mk,c) -> { doNothing().when(mk).setFrom(any(InternetAddress.class)); doNothing().when(mk).setRecipients(Message.RecipientType.TO, internetAddressList); doNothing().when(mk).setContent(anyString(), anyString()); doNothing().when(mk).setSentDate(any(Date.class)); doNothing().when(mk).saveChanges(); when(mk.getAllRecipients()).thenReturn(addresses); })) { s.when(() -> Session.getDefaultInstance(any(Properties.class))).thenReturn(session); SendStatus sendStatus = mu.sendValidateCodeForResetPWD("", "", ""); Assertions."<AssertPlaceHolder>"; } }
sendValidateCodeForResetPWD(String to, String username, String validateCode) { SendStatus sendStatus = new SendStatus(SEND_STATUS_FALSE, ""); String html = readHtmlToString("resetPasswordTemplate.html"); Document doc = Jsoup.parse(html); doc.getElementById(USER_NAME).html(username); doc.getElementById("code").html(validateCode); doc.getElementById("account").html(to); doc.getElementById("validateTimes").html("5"); sendEmail(doc, sendStatus, Lists.newArrayList(to), "修改密码-验证码", "Send validate code email failed before reset password"); return sendStatus; }
[*] target: assertNotNull(sendStatus)
[-] pred: org. junit. Assert. assertNotNull ( sendStatus )
************************************
************************************
[+] input: InterruptedException { // when you get a forbidden response from HeadBucket when(mockClient.headBucket(anyConsumer())).thenReturn( CompletableFuture.failedFuture(S3Exception.builder().statusCode(403).build()) );  // you should fall back to a get bucket location attempt from the universal client var mockUniversalClient = mock(S3AsyncClient.class); provider.universalClient(mockUniversalClient); when(mockUniversalClient.getBucketLocation(anyConsumer())).thenReturn(CompletableFuture.completedFuture( GetBucketLocationResponse.builder() .locationConstraint("us-west-2") .build() ));  // which should get you a client final var s3Client = provider.generateClient("test-bucket", mockClient); "<AssertPlaceHolder>";  final var inOrder = inOrder(mockClient, mockUniversalClient); inOrder.verify(mockClient).headBucket(anyConsumer()); inOrder.verify(mockUniversalClient).getBucketLocation(anyConsumer()); inOrder.verifyNoMoreInteractions(); }
generateClient(String bucketName, S3AsyncClient locationClient) throws ExecutionException, InterruptedException { logger.debug("generating client for bucket: '{}'", bucketName);  String bucketLocation = null; if (configuration.endpointUri() == null) { // we try to locate a bucket only if no endpoint is provided, which means we are dealing with AWS S3 buckets bucketLocation = getBucketLocation(bucketName, locationClient);  if (bucketLocation == null) { // if here, no S3 nor other client has been created yet, and we do not // have a location; we'll let it figure out from the profile region logger.warn("Unable to determine the region of bucket: '{}'. Generating a client for the profile region.", bucketName); } }  var client = bucketClientCache.getIfPresent(bucketName); if (client != null && !client.isClosed()) { return client; } else { if (client != null && client.isClosed()) { bucketClientCache.invalidate(bucketName);    // remove the closed client from the cache } String r = Optional.ofNullable(bucketLocation).orElse(configuration.getRegion()); return bucketClientCache.get(bucketName, b -> new CacheableS3Client(configureCrtClientForRegion(r))); } }
[*] target: assertNotNull(s3Client)
[-] pred: org. junit. Assert. assertNotNull ( s3Client )
************************************
************************************
[+] input: shouldSetAndGetRightClickSelectsWord() { options.setRightClickSelectsWord(false); "<AssertPlaceHolder>"; }
isRightClickSelectsWord() { return rightClickSelectsWord; }
[*] target: assertFalse(options.isRightClickSelectsWord())
[-] pred: org. junit. Assert. assertFalse ( options. isRightClickSelectsWord() )
************************************
************************************
[+] input: generateGenericUriWithPublicId() { var publicId = UUID.randomUUID().toString(); var genericUri = WebUtils.getGenericUri(SignUpConstants.SIGN_UP_VERIFY_MAPPING, publicId);  var expected = String.format("%s?%s=%s", SignUpConstants.SIGN_UP_VERIFY_MAPPING, WebUtils.TOKEN, publicId); Assertions."<AssertPlaceHolder>"; }
getGenericUri(String path, String publicUserId) {  return ServletUriComponentsBuilder.fromCurrentContextPath() .path(path) .queryParam(TOKEN, publicUserId) .build() .toUriString(); }
[*] target: assertEquals(expected, genericUri)
[-] pred: org. junit. Assert. assertEquals ( expected, genericUri )
************************************
************************************
[+] input: BBjException { busyIndicator.setBackdropVisible(true);  verify(mockIndicator, atLeast(1)).setAttribute("no-backdrop", "false");  when(mockIndicator.getAttribute("no-backdrop")).thenReturn("false"); "<AssertPlaceHolder>"; }
isBackdropVisible() { String attribute = getAttribute(ATTR_NO_BACKDROP); return attribute == null || attribute.equals(FALSE); }
[*] target: assertTrue(busyIndicator.isBackdropVisible())
[-] pred: org. junit. Assert. assertTrue ( busyIndicator. isBackdropVisible ( ) )
************************************
************************************
[+] input: testEmptyKeys() { keys = new String[0]; when(scheduleUtil.whereForSettings(keys)).thenCallRealMethod(); Query query = scheduleUtil.whereForSettings(keys); Assertions."<AssertPlaceHolder>"; }
whereForSettings(String[] keys) { if (null == keys || keys.length == 0) return new Query(); return new Query(Criteria.where("key").in(keys)); }
[*] target: assertNotNull(query)
[-] pred: org. junit. Assert. assertNotNull ( query )
************************************
************************************
[+] input: withoutUpperBounds() { TypeParameter typeParameter = T.asTypeParameter(); String toVerify = generateFrom(typeParameter); String expected = "T"; "<AssertPlaceHolder>"; }
generateFrom(TypeParameter typeParameter) { return typeParameter(typeParameter).generate(); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testCheckSupplyAmount_withValidSupply() { Money supply = Money.wons(60000L); Long discount = discountAmount; Long minimum = minimumCost;  Money expectedDiscountAmount = Money.wons(10000L); Money actualDiscountAmount = issuedCoupon.checkSupplyAmount(supply, discount, minimum);  "<AssertPlaceHolder>"; }
checkSupplyAmount(Money supply, Long discount, Long minimum) { if (supply.isLessThan(Money.wons(discount))) { throw SupplyLessThenDiscountException.EXCEPTION; } if (supply.isLessThan(Money.wons(minimum))) { throw SupplyLessThenMinimumException.EXCEPTION; } return Money.wons(discount); }
[*] target: assertEquals(expectedDiscountAmount, actualDiscountAmount)
[-] pred: org. junit. Assert. assertEquals ( expectedDiscountAmount, actualDiscountAmount )
************************************
************************************
[+] input: generateReport_UnauthorizedUser() { TeamOverview teamOverview = UtilMethods.getDummyTeamOverview();  List<TeamOverview> listTeamsOverview = List.of(teamOverview); Topic topic = UtilMethods.getDummyTopic(); Acl acl = UtilMethods.getDummyAcl();  loginMock(); Mockito.when(commonUtilsService.getCurrentUserName()).thenReturn(TestConstants.USERNAME); Mockito.when(commonUtilsService.getTenantId(TestConstants.USERNAME)) .thenReturn(TestConstants.TENANT_ID); Mockito.when( manageDatabase.getKwPropertyValue( KwConstants.KW_REPORTS_TMP_LOCATION_KEY, TestConstants.TENANT_ID)) .thenReturn(TestConstants.KW_REPORTS_LOCATION); Mockito.doReturn(listTeamsOverview) .when(analyticsControllerService) .getTeamsOverview(null, NUMBER_OF_DAYS); Mockito.when(commonUtilsService.getEnvsFromUserId(any())) .thenReturn(Set.of(TestConstants.ENV_ID)); Mockito.doReturn(TestConstants.ENV_NAME) .when(analyticsControllerService) .getEnvName(TestConstants.ENV_ID); Mockito.when( commonUtilsService.isNotAuthorizedUser(any(), eq(PermissionType.ALL_TEAMS_REPORTS))) .thenReturn(true); Mockito.when(commonUtilsService.getTeamId(TestConstants.USERNAME)) .thenReturn(TestConstants.TEAM_ID); Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when( handleDbRequestsJdbc.getTopicsforTeam(TestConstants.TEAM_ID, TestConstants.TENANT_ID)) .thenReturn(List.of(topic)); Mockito.when( handleDbRequestsJdbc.getConsumerGroupsforTeam( TestConstants.TEAM_ID, TestConstants.TENANT_ID)) .thenReturn(List.of(acl));  File actual = analyticsControllerService.generateReport(NUMBER_OF_DAYS); Assertions."<AssertPlaceHolder>"; actual.deleteOnExit(); }
generateReport(int numberOfDays) { int tenantId = commonUtilsService.getTenantId(getCurrentUserName()); String kwReportsLocation = manageDatabase.getKwPropertyValue(KwConstants.KW_REPORTS_TMP_LOCATION_KEY, tenantId);  List<TeamOverview> totalOverviewList = getTeamsOverview(null, numberOfDays); final Map<String, List<String>> topicNames = getTopicNames(tenantId); final Map<String, List<String>> consumerGroups = getConsumerGroups(tenantId); File zipFile = new File( kwReportsLocation + "KwReport" + DATE_TIME_FORMATTER.format(Instant.now()) + ".zip"); ZipOutputStream zipOutputStream = null; try { zipOutputStream = new ZipOutputStream(new FileOutputStream(zipFile)); } catch (FileNotFoundException e) { log.error("Exception:", e); }  String actualFileName; List<File> reportFilesOfTenants = new ArrayList<>(); for (TeamOverview totalOverview : totalOverviewList) { if (totalOverview.getTenantName() != null) { actualFileName = "Klaw-" + totalOverview.getTenantName() + ".xlsx"; } else { actualFileName = "KlawReport" + ".xlsx"; }  String fileName = kwReportsLocation + actualFileName; File reportFile = new File(fileName); reportFilesOfTenants.add(reportFile);  XSSFWorkbook workbook = new XSSFWorkbook();  generateReportPerView(totalOverview.getTopicsPerEnvOverview(), workbook, reportFile); generateReportPerView(totalOverview.getPartitionsPerEnvOverview(), workbook, reportFile); generateReportPerView(totalOverview.getTopicsPerTeamsOverview(), workbook, reportFile); generateReportPerView(totalOverview.getAclsPerEnvOverview(), workbook, reportFile); generateReportPerView(totalOverview.getProducerAclsPerTeamsOverview(), workbook, reportFile); generateReportPerView(totalOverview.getConsumerAclsPerTeamsOverview(), workbook, reportFile); generateReportPerView(totalOverview.getActivityLogOverview(), workbook, reportFile);  addTopicNamesPerEnvToReport(topicNames, workbook, reportFile, "Topics"); addTopicNamesPerEnvToReport(consumerGroups, workbook, reportFile, "ConsumerGroups");  log.info("Report generated"); if (zipOutputStream != null) { writeToZipFile(zipOutputStream, fileName, actualFileName); } }  try { if (zipOutputStream != null) { zipOutputStream.close(); // delete xlsx report file after writing to zip file. for (File reportFilesOfTenant : reportFilesOfTenants) { reportFilesOfTenant.delete(); } } } catch (IOException e) { log.error("Exception:", e); }  return zipFile; }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: testMessage2TapEventWhenNotDmlOp() { MessageEntity messageEntity = new MessageEntity(OperationType.DDL.getOp(), MOCK_DATA, TABLE_NAME); TapRecordEvent tapRecordEvent = hazelcastBaseNode.message2TapEvent(messageEntity); "<AssertPlaceHolder>"; }
message2TapEvent(MessageEntity messageEntity) { if (null == messageEntity) return null; TapRecordEvent tapRecordEvent; String op = messageEntity.getOp(); OperationType operationType = OperationType.fromOp(op); if (operationType == null) { throw new IllegalArgumentException(String.format("Unrecognized op type: %s", op)); } switch (operationType) { case INSERT: tapRecordEvent = new TapInsertRecordEvent(); ((TapInsertRecordEvent) tapRecordEvent).setAfter(messageEntity.getAfter()); break; case UPDATE: tapRecordEvent = new TapUpdateRecordEvent(); ((TapUpdateRecordEvent) tapRecordEvent).setBefore(messageEntity.getBefore()); ((TapUpdateRecordEvent) tapRecordEvent).setAfter(messageEntity.getAfter()); break; case DELETE: tapRecordEvent = new TapDeleteRecordEvent(); ((TapDeleteRecordEvent) tapRecordEvent).setBefore(messageEntity.getBefore()); break; default: tapRecordEvent = null; break; } if (null != tapRecordEvent) { tapRecordEvent.setTableId(messageEntity.getTableName()); tapRecordEvent.setReferenceTime(messageEntity.getTimestamp()); tapRecordEvent.setTime(messageEntity.getTime()); tapRecordEvent.setInfo(messageEntity.getInfo()); } return tapRecordEvent; }
[*] target: assertNull(tapRecordEvent)
[-] pred: org. junit. Assert. assertNull ( tapRecordEvent )
************************************
************************************
[+] input: testArray() {  DataBuilder builder = new DataBuilder(). // addData("name", "John"). // addData("description", "Hello World");  builder.addArray("comments");  // add first object builder.addObject(); builder.addData("language", "javascript"); builder.addData("script", "1+1");  // add second object builder.addObject(); builder.addData("language", "java"); builder.addData("script", "2+2");  String json = builder.build();  "<AssertPlaceHolder>";  logger.info(json);  }
build() { closeArray(); // write result JsonObject jsonObject = rootBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: format_ShouldFormatNumberValueAsText() { BigDecimal value = new BigDecimal("12345.6789");; String expectedValue = TypeCodecs.DECIMAL.format(value); String result = codec.format(value); Assertions."<AssertPlaceHolder>"; }
format(BigDecimal value) { return TypeCodecs.DECIMAL.format(value); }
[*] target: assertEquals(expectedValue, result)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, result )
************************************
************************************
[+] input: isValid() { ValidationResult result = ValidationResult.valid(); "<AssertPlaceHolder>"; }
isValid() { return !hasErrors(); }
[*] target: assertTrue(result.isValid())
[-] pred: org. junit. Assert. assertTrue ( result. isValid ( ) )
************************************
************************************
[+] input: asTypeConstructor() { GenericTypeConstructor expected = new GenericTypeConstructor(T); GenericTypeConstructor toVerify = new GenericType(T).asTypeConstructor();  "<AssertPlaceHolder>"; }
asTypeConstructor() { return TypeConstructor.generic(name); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testRemoveNonExistingTask() { TaskManager manager = new MemoryTasks(); var task_nonexisting_id = 0; try { "<AssertPlaceHolder>"; } catch (TaskManagerException e) { fail(ExceptionUtils.getExceptionStackTrace(e)); } }
removeTask(int id) throws TaskManagerException { if (id < 0) throw new IllegalArgumentException("the task id can't be negative.");  synchronized (this) { return null != taskMapping_.remove(id); } }
[*] target: assertFalse(manager.removeTask(task_nonexisting_id))
[-] pred: org. junit. Assert. assertFalse ( manager. removeTask ( task_nonexisting_id ) )
************************************
************************************
[+] input: testGenerateCommandHostEntity() { // Setup final ClusterServiceCommandHostEntity expectedResult = new ClusterServiceCommandHostEntity(); expectedResult.setCommandHostId("commandHostId"); expectedResult.setHostname("hostname"); expectedResult.setCommandState(CommandState.WAIT); expectedResult.setCommandStateCode(0); expectedResult.setCommandProgress(0); expectedResult.setCommandId("commandId"); expectedResult.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime());  // Run the test final ClusterServiceCommandHostEntity result = ProcessUtils.generateCommandHostEntity("commandId", "hostname");  // Verify the results "<AssertPlaceHolder>"; }
generateCommandHostEntity(String commandId, String hostname) { ClusterServiceCommandHostEntity commandHost = new ClusterServiceCommandHostEntity(); String commandHostId = IdUtil.simpleUUID(); commandHost.setCommandHostId(commandHostId); commandHost.setCommandId(commandId); commandHost.setHostname(hostname); commandHost.setCommandState(CommandState.RUNNING); commandHost.setCommandProgress(0); commandHost.setCreateTime(new Date());  return commandHost; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: TypeParserTest {  @ParameterizedTest @MethodSource("me.darknet.assembler.TypeParserTest#provideMemberInfo") public void testParseMemberInfo(String input) { String[] args = input.split(" "); String name = args[0]; String descriptor = args[1]; MemberInfo memberInfo = TypeParser.parseMemberInfo(name, descriptor); Assertions."<AssertPlaceHolder>"; }  public String[] provideMemberInfo() { return new String[] { "java/lang/String.toString ()Ljava/lang/String;", "java/lang/String.value [C", "name Ljava/lang/String;" }; }  }
parseMemberInfo(String name, String descriptor) { String owner = null; if (name.contains(".")) { String[] split = name.split("\\."); owner = split[0]; name = split[1]; } if (descriptor.startsWith("(")) { return new MethodInfo(owner, name, descriptor); } else { return new FieldInfo(owner, name, descriptor); } }
[*] target: assertNotNull(memberInfo)
[-] pred: org. junit. Assert. assertNotNull ( memberInfo )
************************************
************************************
[+] input: LocationNotFoundException { // Mock data MonitoringLocationDTO monitoringLocationDTO = MonitoringLocationDTO.newBuilder().build(); MonitoringLocation monitoringLocation = new MonitoringLocation(); monitoringLocation.setAddress("address"); when(mapper.dtoToModel(any(MonitoringLocationDTO.class))).thenReturn(monitoringLocation); when(modelRepo.save(monitoringLocation)).thenReturn(monitoringLocation); when(mapper.modelToDTO(any(MonitoringLocation.class))).thenReturn(monitoringLocationDTO);  // Test MonitoringLocationDTO result = monitoringLocationService.upsert(monitoringLocationDTO);  // Assertions "<AssertPlaceHolder>"; verify(mapper, times(1)).dtoToModel(any(MonitoringLocationDTO.class)); verify(modelRepo, times(1)).save(monitoringLocation); verify(mapper, times(1)).modelToDTO(any(MonitoringLocation.class)); }
upsert(MonitoringLocationDTO dto) throws LocationNotFoundException { if (dto.hasField(MonitoringLocationDTO.getDescriptor().findFieldByNumber(MonitoringLocationDTO.ID_FIELD_NUMBER)) && modelRepo.findByIdAndTenantId(dto.getId(), dto.getTenantId()).isEmpty()) { throw new LocationNotFoundException("Location not found with ID " + dto.getId()); } if (dto.hasField( MonitoringLocationDTO.getDescriptor().findFieldByNumber(MonitoringLocationDTO.LOCATION_FIELD_NUMBER))) { if (StringUtils.isBlank(dto.getLocation())) { throw new InventoryRuntimeException("Location is Blank"); } var location = modelRepo.findByLocationAndTenantId(dto.getLocation().trim(), dto.getTenantId()); if (location.isPresent() && location.get().getId() != dto.getId()) { throw new InventoryRuntimeException("Duplicate Location found with name " + dto.getLocation()); } }  MonitoringLocation model = mapper.dtoToModel(dto); return mapper.modelToDTO(modelRepo.save(model)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: bind_explodeMap_withStandardInput() { commonSetup(true,false,false); targetUpdateStatement = new TargetUpdateStatement(propertyHelper, targetSession); BoundStatement result = targetUpdateStatement.bind(originRow, targetRow, null,null,getSampleData(explodeMapKeyType),getSampleData(explodeMapValueType)); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size())).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { // We reference the originRow and convert it to the target type. // We need the targetRow if (null == originRow) throw new RuntimeException("originRow is null");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue);  BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  Object originValue, targetValue; Object bindValueTarget = null; for (int targetIndex : columnIndexesToBind) { int originIndex = cqlTable.getCorrespondingIndex(targetIndex);  try { if (usingCounter && counterIndexes.contains(targetIndex)) { originValue = cqlTable.getOtherCqlTable().getData(originIndex, originRow); if (null == originValue) { currentBindIndex++; continue; } targetValue = (null == targetRow ? 0L : cqlTable.getData(targetIndex, targetRow)); bindValueTarget = ((Long) originValue - (null == targetValue ? 0L : (Long) targetValue)); } else if (targetIndex== explodeMapKeyIndex) { bindValueTarget = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValueTarget = explodeMapValue; } else { if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValueTarget = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValueTarget, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValueTarget + " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex) + "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex); throw e; } }  PKFactory pkFactory = session.getPKFactory(); EnhancedPK pk = pkFactory.getTargetPK(originRow); boundStatement = pkFactory.bindWhereClause(PKFactory.Side.TARGET, pk, boundStatement, currentBindIndex);  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: validateGivenMethodWithAccumulatedTypeConstructorThatIsAssignableToPartiallyAccumulatedTypeConstructor() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter()), Optional.of(FUNCTION.with(P, V)), "myFunction", asList( Parameter.of(FUNCTION.with(P.asType().contravariant(), T.asType().covariant()), "left"), Parameter.of(FUNCTION.with(P.asType().contravariant(), U.asType().covariant()), "right"), Parameter.of(BI_FUNCTION.with(T.asType().contravariant(), U.asType().contravariant(), V.asType().covariant()), "compose") ) );  Validated<String, AccumulatorValidator.Result> expected = Validated.valid( AccumulatorValidator.Result.of( "myFunction", FUNCTION.with(P.asTypeConstructor().contravariant(), placeholder().covariant()), FUNCTION.with(P.asTypeConstructor().contravariant(), placeholder().covariant()), FUNCTION.with(P.asTypeConstructor().invariant(), placeholder().invariant()), FUNCTION.with(P.asType().contravariant(), T.asType().covariant()), FUNCTION.with(P.asType().contravariant(), U.asType().covariant()), FUNCTION.with(P.asType().invariant(), V.asType().invariant()) ) ); Validated<String, AccumulatorValidator.Result> toVerify = AccumulatorValidator.validate(toValidate, new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
validate(Method method, ParametersAndTypeParametersValidator parametersAndTypeParametersValidator) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages); ParametersAndTypeParametersValidator.Result parametersAndTypeParameters = verifyParametersAndTypeParameters(method, parametersAndTypeParametersValidator, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  // Assign a meaningful name to each of the (three) type parameters: TypeParameter leftInputTypeConstructorArgument = parametersAndTypeParameters.getLeftInputTypeConstructorArgument(); TypeParameter rightInputTypeConstructorArgument = parametersAndTypeParameters.getRightInputTypeConstructorArgument(); TypeParameter returnTypeConstructorArgument = parametersAndTypeParameters.getReturnTypeConstructorArgument();  // Assign a meaningful name to the left and right parameters: Type leftParameterType = parametersAndTypeParameters.getLeftParameterType(); Type rightParameterType = parametersAndTypeParameters.getRightParameterType();  String name = method.getName();  TypeConstructor accumulatedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(returnTypeConstructorArgument.getName()); TypeConstructor partiallyAccumulatedTypeConstructor = leftParameterType.asTypeConstructorWithPlaceholderFor(leftInputTypeConstructorArgument.getName()); TypeConstructor inputTypeConstructor = rightParameterType.asTypeConstructorWithPlaceholderFor(rightInputTypeConstructorArgument.getName());  if (!partiallyAccumulatedTypeConstructor.canAccept(accumulatedTypeConstructor)) { // Tweak the error message to not confuse people using the simple case where // parameter types and result type should be identical: if (Objects.equals(partiallyAccumulatedTypeConstructor, inputTypeConstructor)) { return Validated.invalid("No shared type constructor between parameters (" + generateFrom(leftParameterType) + " and " + generateFrom(rightParameterType) + ") and result (" + generateFrom(returnType) + ")"); } else { return Validated.invalid("No shared type constructor between first parameter (" + generateFrom(leftParameterType) + ") and result (" + generateFrom(returnType) + ")"); } }  verifyNoCrossReferences(method.getTypeParameters(), leftParameterType, partiallyAccumulatedTypeConstructor, "type of the first parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), rightParameterType, inputTypeConstructor, "type of the second parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), returnType, accumulatedTypeConstructor, "return type", errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  return Validated.valid( AccumulatorValidator.Result.of( name, inputTypeConstructor, partiallyAccumulatedTypeConstructor, accumulatedTypeConstructor, leftParameterType, rightParameterType, returnType ) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: asTypeConstructorWithPlaceHolderForGivenNeedleThatMatchesOneOfTheTypeArguments() { TypeConstructor expected = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.invariant(), TypeConstructor.placeholder().covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant()); TypeConstructor toVerify = Type.concrete(ERUDITE, STRING_TYPE.invariant(), T_TYPE.covariant(), INTEGER_TYPE.contravariant()).asTypeConstructorWithPlaceholderFor(T);  "<AssertPlaceHolder>"; }
asTypeConstructorWithPlaceholderFor(TypeParameterName needle) { return TypeConstructor.concrete( fullyQualifiedName, typeArguments.stream().map(typeArgument -> typeArgument.asTypeConstructorArgumentWithPlaceholderFor(needle)).collect(toList()) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testNeedSkipNormalNotExist() { File f = mock(File.class); when(f.exists()).thenReturn(false); when(f.isFile()).thenReturn(true); when(f.getName()).thenReturn("setup.py"); boolean needSkip = utils.needSkip(f); Assertions."<AssertPlaceHolder>"; }
needSkip(File f) { if (null == f) return true; if (!f.exists()) return true; if (!f.isFile()) return true; return !f.getName().contains(PACKAGE_COMPILATION_FILE); }
[*] target: assertTrue(needSkip)
[-] pred: org. junit. Assert. assertTrue ( needSkip )
************************************
************************************
[+] input: testSerializeWithHeaders() {  Alert alert = Alert.builder() .content("test") .target("test") .build(); byte[] expectedBytes = ("{"id":null,"target":"test","alertDefineId":null,"priority":0,"content":" + ""test","status":0,"times":null,"firstAlarmTime":null,"lastAlarmTime":null,"triggerTimes" + "":null,"tags":null,"creator":null,"modifier":null,"gmtCreate":null,"gmtUpdate":null}").getBytes();  byte[] bytes = alertSerializer.serialize("alerts", headers, alert);  "<AssertPlaceHolder>"; }
serialize(String topic, Headers headers, Alert data) { return Serializer.super.serialize(topic, headers, data); }
[*] target: assertArrayEquals(expectedBytes, bytes)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedBytes, bytes )
************************************
************************************
[+] input: testInterceptAspects() { List<Class<? extends Aspect>> list = observableAspectTask.interceptAspects(); Assertions."<AssertPlaceHolder>"; }
interceptAspects() { return null; }
[*] target: assertNull(list)
[-] pred: org. junit. Assert. assertNull ( list )
************************************
************************************
[+] input: shouldReturnValueProvider() { Function<String, Integer> valueProvider = String::length; OrderCriteria<String, Integer> orderCriteria = new OrderCriteria<>(valueProvider, OrderCriteria.Direction.ASC);  "<AssertPlaceHolder>"; }
getValueProvider() { return valueProvider; }
[*] target: assertEquals(valueProvider, orderCriteria.getValueProvider())
[-] pred: org. junit. Assert. assertEquals ( valueProvider, orderCriteria. getValueProvider() )
************************************
************************************
[+] input: testConvertWhenConversionTypeIsCodec() { //        CqlConversion.Type conversionType = CqlConversion.Type.CODEC; //        List<CqlConversion.Type> conversionTypeList = Collections.singletonList(conversionType); // //        CqlConversion cqlConversion = spy(new CqlConversion(fromDataType, toDataType, codecRegistry)); //        doReturn(conversionTypeList).when(cqlConversion).getConversionTypeList(); //        doReturn(Collections.singletonList(fromDataType)).when(cqlConversion).getFromDataTypeList(); //        doReturn(Collections.singletonList(toDataType)).when(cqlConversion).getToDataTypeList(); // //        Object inputData = new Object(); //        Object expectedResult = new Object(); // //        // Stub the convert_ONE() method to return expectedResult when called with specific arguments //        doReturn(expectedResult).when(cqlConversion).convert_ONE(conversionType, inputData, fromDataType, toDataType, codecRegistry); // //        Object result = cqlConversion.convert(inputData); // //        // Verify that convert_ONE() was called with the expected arguments //        verify(cqlConversion).convert_ONE(conversionType, inputData, fromDataType, toDataType, codecRegistry); // //        "<AssertPlaceHolder>"; //    }
convert_ONE(Type conversionType, Object inputData, DataType fromDataType, DataType toDataType, CodecRegistry codecRegistry) { if (logger.isDebugEnabled()) logger.debug("convert_ONE conversionType {} inputData {} fromDataType {} toDataType {}",conversionType,inputData,fromDataType,toDataType); switch (conversionType) { case NONE: case UNSUPPORTED: return inputData; case CODEC: return convert_CODEC(inputData, fromDataType, toDataType, codecRegistry); case UDT: return convert_UDT((UdtValue) inputData, (UserDefinedType) fromDataType, (UserDefinedType) toDataType); } return inputData; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testInsertBatch() { List<User> userList = new ArrayList<>(); { User user = new User(); user.setName("张三") .setAge(18) .setCreateTime(LocalDateTime.now()); userList.add(user); } { User user = new User(); user.setName("李四") .setAge(17) .setCreateTime(LocalDateTime.now()); userList.add(user); } int insert = commonDao.insertBatch(userList); Assertions."<AssertPlaceHolder>"; }
insertBatch(@Param("list") List<E> list);
[*] target: assertEquals(2, insert)
[-] pred: org. junit. Assert. assertEquals ( 2, insert )
************************************
************************************
[+] input: shouldRemoveTheFoodOnStomach_WhenStomochDoesntEmpty() { //given monkey.toEat(Fruit.APPLE); //when this.monkey.toDigest(); boolean actual = this.monkey.getStomach().isEmpty(); //then boolean expected = true; Assertions."<AssertPlaceHolder>"; }
getStomach() { return stomach; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: format_ShouldFormatInstantValueAsText() { String valueAsString = "220412215715"; Instant value = LocalDateTime.parse(valueAsString, formatter).toInstant(zoneOffset); String result = codec.format(value); Assertions."<AssertPlaceHolder>"; }
format(Instant value) { LocalDateTime localDateTime = LocalDateTime.ofInstant(value, zoneOffset); return formatter.format(localDateTime); }
[*] target: assertEquals(valueAsString, result)
[-] pred: org. junit. Assert. assertEquals ( valueAsString, result )
************************************
************************************
[+] input: shouldMaskDateTime() { try (MockedStatic<Environment> mockedEnvironment = mockStatic(Environment.class)) { mockedEnvironment.when(Environment::getCurrent).thenReturn(env); when(env.getWebforjHelper()).thenReturn(bridge);  LocalDateTime input = LocalDateTime.of(2023, 6, 12, 14, 30, 15); String mask = "%Dz-%Mz-%Yl %Hz:%mz:%s"; String expected = "12-06-2023 14:30:15";  JulianLocaleDateTransformer dateTransformer = new JulianLocaleDateTransformer(); HoursLocalTimeTransformer timeTransformer = new HoursLocalTimeTransformer(); int julian = dateTransformer.transformToComponent(input.toLocalDate()); double hms = timeTransformer.transformToComponent(input.toLocalTime()); when(bridge.maskDateTime(julian, hms, mask)).thenReturn(expected);  String result = MaskDecorator.forDateTime(input, mask);  "<AssertPlaceHolder>"; } }
forDateTime(LocalDateTime input, String mask) { Objects.requireNonNull(input, INPUT_CANNOT_BE_NULL); Objects.requireNonNull(mask, MASK_CANNOT_BE_NULL);  Environment env = Environment.getCurrent(); JulianLocaleDateTransformer dateTransformer = new JulianLocaleDateTransformer(); HoursLocalTimeTransformer timeTransformer = new HoursLocalTimeTransformer(); int julian = dateTransformer.transformToComponent(input.toLocalDate()); double hms = timeTransformer.transformToComponent(input.toLocalTime());  return env.getWebforjHelper().maskDateTime(julian, hms, mask); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: isValidUrl_Null_IsNotValidUrl() { final String candidate = null; final var isValidUrl = subject.isValidUrl(candidate);  "<AssertPlaceHolder>"; }
isValidUrl(String url) { if (url == null) { return false; } try { new URL(url); return true; } catch (MalformedURLException e) { return false; } }
[*] target: assertFalse(isValidUrl)
[-] pred: org. junit. Assert. assertFalse ( isValidUrl )
************************************
************************************
[+] input: testNoInitialUsers() { var users = new MemoryUsers();  "<AssertPlaceHolder>"; }
countUsers() { readLock_.lock(); try { return users_.size(); } finally { readLock_.unlock(); } }
[*] target: assertEquals(0, users.countUsers())
[-] pred: org. junit. Assert. assertEquals ( 0, users. countUsers ( ) )
************************************
************************************
[+] input: parseInt() { final EditorHelper editorHelper = new EditorHelper();  final Object result = editorHelper.edit("int", "5"); Assertions."<AssertPlaceHolder>"; }
edit(String type, String newValue) { try { final Class<?> klass = parseType(type); return new Gson().fromJson(newValue, klass); } catch (Exception e) { log.warn("Failed to edit value: {}, {}", type, newValue, e); return null; } }
[*] target: assertEquals(5, result)
[-] pred: org. junit. Assert. assertEquals ( 5, result )
************************************
************************************
[+] input: Exception { MaskingConfiguration maskingConfiguration = new DefaultMaskingConfiguration(); maskingConfiguration.setValue("hashing.normalize", true);  HashMaskingProvider hashMaskingProvider = new HashMaskingProvider(maskingConfiguration);  String value = "Joe"; String maskedValue1 = hashMaskingProvider.mask(value);  String value2 = "JOE"; String maskedValue2 = hashMaskingProvider.mask(value2);  "<AssertPlaceHolder>"; }
mask(String identifier) { return maskWithKey(identifier, this.salt); }
[*] target: assertEquals(maskedValue1, maskedValue2)
[-] pred: org. junit. Assert. assertEquals ( maskedValue1, maskedValue2 )
************************************
************************************
[+] input: redisMultiKey() { RedisExtractor.RedisMultiKey redisMultiKey = new RedisExtractor.RedisMultiKey(); redisMultiKey.setKey("mock"); redisMultiKey.getKey(); redisMultiKey.setField("mock"); "<AssertPlaceHolder>"; }
getField() { return field; }
[*] target: assertNotNull(redisMultiKey.getField())
[-] pred: org. junit. Assert. assertNotNull ( redisMultiKey. getField() )
************************************
************************************
[+] input: buildCodonMapBrcaMethodsFrame2Tests() { Path projectPath = Path.of(""); Path brcaPath = projectPath.resolve("assets/dna/real/brca1.fa");  String brcaDnaString = readFile(brcaPath.toFile()); Map<String, Integer> expectedResults = brca1ExpectedFrame2CodonCounts; CodonFrame testCodonFrame = new CodonFrame(brcaDnaString, (short) 2, 1, 20000); ReadingFrames testReadingFrame = new ReadingFrames(testCodonFrame); Map<String, Integer> actualResults = testReadingFrame.getCodonCounts();  "<AssertPlaceHolder>"; }
getCodonCounts() { if (this.codonCounts == null || this.codonCounts.isEmpty()) { this.buildCodonMap(codonFrame.getDna()); } return codonCounts; }
[*] target: assertEquals(expectedResults, actualResults)
[-] pred: org. junit. Assert. assertEquals ( expectedResults, actualResults )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismLessThanTwoNode() { when(nodeList.size()).thenReturn(1); boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(0)).get(0); verify(nodeList, times(0)).get(1); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: of() { ArrayType expected = new ArrayType(STRING); ArrayType toVerify = ArrayType.of(STRING);  "<AssertPlaceHolder>"; }
of(Type type) { return new ArrayType(type); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: calculateCodonStartIndicesUsingDnaSequenceWithLengthTwentyTwoFrame3Test() { int[] expectedResult = {2, 5, 8, 11, 14, 17}; String testSequence = DNA_SEQUENCE_WITH_LENGTH_TWENTY_TWO; CodonFrame temp = new CodonFrame(testSequence, (short) 3, 1, 100); ReadingFrames readingFrameTest = new ReadingFrames(temp); int[] result = readingFrameTest.calculateCodonStartIndices(testSequence); "<AssertPlaceHolder>"; }
calculateCodonStartIndices(final String dna) { int[] codonStartIndices; // calculate max total codons possible final int maxTotalCodons = dna.length() / 3; // reading frame is 1-index based. Calculate offset for 0-index array. final int offset = this.codonFrame.getReadingFrame() - 1; int[] indexArray = IntStream.range(0, maxTotalCodons).map(index -> (index * 3 + offset)).toArray();  // if the last codon index is not 3 positions away from end, remove last index. if (dna.length() - indexArray[indexArray.length - 1] < 3) { codonStartIndices = Arrays.stream(indexArray).limit(indexArray.length - 1).toArray(); } else { codonStartIndices = indexArray; }  return codonStartIndices; }
[*] target: assertArrayEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedResult, result )
************************************
************************************
[+] input: testPseudorandom() {  MaskingConfiguration maskingConfiguration = new DefaultMaskingConfiguration(); maskingConfiguration.setValue("county.mask.pseudorandom", true);  MaskingProvider maskingProvider = new CountyMaskingProvider(maskingConfiguration);  String originalCity = "Italy"; String firstMask = maskingProvider.mask(originalCity);  for(int i = 0; i < 100; i++) { String maskedCity = maskingProvider.mask(originalCity); "<AssertPlaceHolder>"; }  }
mask(String identifier) {  if (this.getPseudorandom) { return countyManager.getPseudorandom(identifier); }  County county = countyManager.getKey(identifier); if (county == null) { return countyManager.getRandomKey(); }  return countyManager.getRandomKey(county.getNameCountryCode()); }
[*] target: assertEquals(firstMask, maskedCity)
[-] pred: org. junit. Assert. assertEquals ( firstMask, maskedCity )
************************************
************************************
[+] input: testNormal() { Query query = scheduleUtil.whereForSettings(keys); Assertions."<AssertPlaceHolder>"; }
whereForSettings(String[] keys) { if (null == keys || keys.length == 0) return new Query(); return new Query(Criteria.where("key").in(keys)); }
[*] target: assertNotNull(query)
[-] pred: org. junit. Assert. assertNotNull ( query )
************************************
************************************
[+] input: testUpdateSql() { User user = new User(); user.setName("张三"); user.setId(1L); Map<String, Object> params = BeanUtil.beanToMap(user); params.put("selfSQL", "update user set name = #{name} where id = #{id}"); long update = commonDao.updateSql(params); Assertions."<AssertPlaceHolder>"; }
updateSql(Map<String, Object> params);  /** * delete * @param params 参数 * @return result */ @Update(" ${selfSQL}
[*] target: assertEquals(1, update)
[-] pred: org. junit. Assert. assertEquals ( 1, update )
************************************
************************************
[+] input: testDelete() { int delete = commonDaoWrap.delete(1L, User.class); Assertions."<AssertPlaceHolder>"; }
delete(@Param("id") T id, Class<?> cls) { return dao.delete(id, cls); }
[*] target: assertEquals(1, delete)
[-] pred: org. junit. Assert. assertEquals ( 1, delete )
************************************
************************************
[+] input: sholudCalculateLengthOfCGAsZero() { String testEmptyString = ""; int expected = 0; int actual = Properties.calculateLengthOfCG(testEmptyString); "<AssertPlaceHolder>"; }
calculateLengthOfCG(String dna) { int gcLength = 0; char[] dnaCharArray = dna.toCharArray();  for (char letter : dnaCharArray) { if (letterIsCorG(letter)) { gcLength++; } }  return gcLength; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismTwoNodeButNotAllNodeAreNull() { when(nodeList.size()).thenReturn(2); when(nodeList.get(0)).thenReturn(null);  JsProcessorNode node2 = mock(JsProcessorNode.class); when(nodeList.get(1)).thenReturn(node2); boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(1)).get(0); verify(nodeList, times(0)).get(1); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: replaceAllTypeParameterNamesGivenMappingThatContainsElementType() { Map<TypeParameterName, TypeParameterName> mapping = new HashMap<>(); mapping.put(T, A); mapping.put(U, B);  ArrayType expected = new ArrayType(new GenericType(A)); ArrayType toVerify = new ArrayType(new GenericType(T)).replaceAllTypeParameterNames(mapping);  "<AssertPlaceHolder>"; }
replaceAllTypeParameterNames(Map<TypeParameterName, TypeParameterName> replacement) { return Type.array(type.replaceAllTypeParameterNames(replacement)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: 아이템에_가격이_있으면_결제가_필요한_오더라인이다() { // given given(orderItem.getPrice()).willReturn(money3000); given(orderOptionAnswer1.getAdditionalPrice()).willReturn(Money.ZERO); given(orderOptionAnswer2.getAdditionalPrice()).willReturn(Money.ZERO); // when Boolean needPayment = orderLineItem.isNeedPaid();  "<AssertPlaceHolder>"; }
isNeedPaid() { Money totalOrderLinePrice = getTotalOrderLinePrice(); // 0 < totalOrderLinePrice return Money.ZERO.isLessThan(totalOrderLinePrice); }
[*] target: assertTrue(needPayment)
[-] pred: org. junit. Assert. assertTrue ( needPayment )
************************************
************************************
[+] input: testPseudorandom() {  MaskingConfiguration maskingConfiguration = new DefaultMaskingConfiguration(); maskingConfiguration.setValue("city.mask.pseudorandom", true);  MaskingProvider maskingProvider = new CityMaskingProvider(maskingConfiguration);  String originalCity = "Dublin"; String maskedCity = maskingProvider.mask(originalCity);  String firstMask = maskedCity;  for(int i = 0; i < 100; i++) { maskedCity = maskingProvider.mask(originalCity); "<AssertPlaceHolder>"; }  }
mask(String identifier) {  if (getPseudorandom) { return cityManager.getPseudorandom(identifier); }  if (getClosest) { return cityManager.getClosestCity(identifier, this.closestK); }  City city = cityManager.getKey(identifier); if (city == null) { return cityManager.getRandomKey(); }  return cityManager.getRandomKey(city.getNameCountryCode()); }
[*] target: assertEquals(firstMask, maskedCity)
[-] pred: org. junit. Assert. assertEquals ( firstMask, maskedCity )
************************************
************************************
[+] input: ParseException { SchedJob job = new SchedJob(); job.setJobId(idGenerator.generateId()); job.setGroup("default"); job.setJobName(RandomStringUtils.randomAlphanumeric(5)); job.setJobExecutor("cn.ponfee.disjob.test.executor.NoopJobExecutor"); job.setJobState(JobState.DISABLED.value());  job.setJobParam("test"); job.setJobType(JobType.GENERAL.value());  job.setRetryType(RetryType.NONE.value()); job.setRetryCount(0); job.setRetryInterval(0); job.setStartTime(null); job.setEndTime(null); job.setTriggerType(TriggerType.ONCE.value());  String date = "2022-06-17 18:02:00"; job.setTriggerValue(date); job.setNextTriggerTime(JavaUtilDateFormat.DEFAULT.parse(date).getTime()); job.setExecuteTimeout(3600000); job.setMisfireStrategy(MisfireStrategy.LAST.value()); job.setCollidedStrategy(CollidedStrategy.CONCURRENT.value()); job.setRouteStrategy(RouteStrategy.ROUND_ROBIN.value()); job.setRedeployStrategy(RedeployStrategy.RESUME.value()); job.setRemark("test remark"); job.setLastTriggerTime(null); job.setNextTriggerTime(TriggerTimeUtils.computeNextTriggerTime(job, new Date())); job.setUpdatedBy("0"); job.setCreatedBy("0"); job.setUpdatedAt(new Date()); job.setCreatedAt(new Date());  int insert = bean.insert(job); Assertions."<AssertPlaceHolder>"; }
insert(SchedJob job);
[*] target: assertEquals(1, insert)
[-] pred: org. junit. Assert. assertEquals ( 1, insert )
************************************
************************************
[+] input: shouldMaskNumber() { try (MockedStatic<Environment> mockedEnvironment = mockStatic(Environment.class)) { mockedEnvironment.when(Environment::getCurrent).thenReturn(env); when(env.getWebforjHelper()).thenReturn(bridge); float input = 12345; String mask = "##,###,###.00"; String expected = "12,345.00";  when(bridge.maskNumber(input, mask)).thenReturn(expected);  String result = MaskDecorator.forNumber(input, mask);  "<AssertPlaceHolder>"; } }
forNumber(double input, String mask) { Objects.requireNonNull(mask, MASK_CANNOT_BE_NULL);  Environment env = Environment.getCurrent(); return env.getWebforjHelper().maskNumber(input, mask); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testToJSONBBytes() { JSONObject object = JSONObject.of("id", null); byte[] jsonbBytes = object.toJSONBBytes(JSONWriter.Feature.WriteNulls); JSONObject object2 = JSONB.parseObject(jsonbBytes); "<AssertPlaceHolder>"; }
parseObject(String text) { return JSON.parseObject(text); }
[*] target: assertEquals(object, object2)
[-] pred: org. junit. Assert. assertEquals ( object, object2 )
************************************
************************************
[+] input: shouldGetIndex() { int index = repository.getIndex("item2"); "<AssertPlaceHolder>"; }
getIndex(T entity) { return new ArrayList<>(items).indexOf(entity); }
[*] target: assertEquals(1, index)
[-] pred: org. junit. Assert. assertEquals ( 1, index )
************************************
************************************
[+] input: schedule() { ScheduledFuture<?> scheduleTest = TimerService.schedule(() -> System.out.println("schedule test"), 0, TimeUnit.MILLISECONDS); Assertions."<AssertPlaceHolder>"; scheduleTest.cancel(true); }
schedule(Runnable command, long delay, TimeUnit unit) { return SCHEDULER.schedule(command, delay, unit); }
[*] target: assertNotNull(scheduleTest)
[-] pred: org. junit. Assert. assertNotNull ( scheduleTest )
************************************
************************************
[+] input: setProperty_StringList_oneValue() { List<String> value = Arrays.asList("a"); List<String> setValue = (List<String>) helper.setProperty(KnownProperties.TEST_STRING_LIST, value); "<AssertPlaceHolder>"; }
setProperty(String propertyName, Object propertyValue) { if (null == propertyName || null == propertyValue) return null; PropertyType expectedType = getType(propertyName); if (null == expectedType) { return null; }  boolean typesMatch = validateType(expectedType, propertyValue); if (!typesMatch) return null;  synchronized (PropertyHelper.class) { propertyMap.put(propertyName, propertyValue); } return propertyValue; }
[*] target: assertEquals(value, setValue)
[-] pred: org. junit. Assert. assertEquals ( value, setValue )
************************************
************************************
[+] input: test_error4() { Exception error = null; try { DefaultJSONParser parser = new DefaultJSONParser("]"); parser.parse(); } catch (Exception ex) { error = ex; } "<AssertPlaceHolder>"; }
parse() { return reader.readAny(); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: instrumentationTypes() { TimeMachineModuleInstrumentation inst = new TimeMachineModuleInstrumentation(); "<AssertPlaceHolder>"; }
instrumentationTypes() { List<TypeInstrumentation> typeInstList = new ArrayList<>(); typeInstList.add(new DateTimeInstrumentation("java.time.Clock")); typeInstList.add(new DateTimeInstrumentation("java.util.Date")); typeInstList.add(new DateTimeInstrumentation("java.util.Calendar")); typeInstList.add(new DateTimeInstrumentation("org.joda.time.DateTimeUtils")); return typeInstList; }
[*] target: assertEquals(4, inst.instrumentationTypes().size())
[-] pred: org. junit. Assert. assertEquals ( 4, inst. instrumentationTypes(). size ( ) )
************************************
************************************
[+] input: concreteGivenFullyQualifiedNameAndTypeArguments() { ConcreteType expected = new ConcreteType(ERUDITE, asList(STRING_TYPE.invariant(), T_TYPE.covariant(), INTEGER_TYPE.contravariant())); ConcreteType toVerify = Type.concrete(ERUDITE, STRING_TYPE.invariant(), T_TYPE.covariant(), INTEGER_TYPE.contravariant());  "<AssertPlaceHolder>"; }
contravariant() { return TypeArgument.of(CONTRAVARIANT, this); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: parse_ShouldParseStringToInstantValueAndReturnAsString() { String valueAsString = "1681333035000"; Instant value = Instant.ofEpochMilli(Long.parseLong(valueAsString)); String result = codec.parse(TypeCodecs.TIMESTAMP.format(value)); Assertions."<AssertPlaceHolder>"; }
format(String value) { Instant instantValue = Instant.ofEpochMilli(Long.parseLong(value)); return TypeCodecs.TIMESTAMP.format(instantValue); }
[*] target: assertEquals(valueAsString, result)
[-] pred: org. junit. Assert. assertEquals ( valueAsString, result )
************************************
************************************
[+] input: MessagingException { when(mu.connectSMTP(any(Session.class))).thenCallRealMethod(); doCallRealMethod().when(mu).closeTransport(any(Transport.class)); ReflectionTestUtils.setField(mu, "port", null); doNothing().when(transport).connect(anyString(), anyString(), anyString()); doNothing().when(mu).initMailConfig(); doNothing().when(transport).close(); doNothing().when(transport).sendMessage(any(MimeMessage.class), any(Address[].class)); Session session = mock(Session.class); InternetAddress[] internetAddressList = new InternetAddress[0]; Address[] addresses = new Address[0];  doNothing().when(session).setDebug(true); when(session.getTransport("smtp")).thenReturn(transport); try(MockedStatic<Session> s = mockStatic(Session.class); MockedConstruction<InternetAddress> i = mockConstruction(InternetAddress.class, (ic, c) -> {}); MockedConstruction<MimeMessage> m = mockConstruction(MimeMessage.class, (mk,c) -> { doNothing().when(mk).setFrom(any(InternetAddress.class)); doNothing().when(mk).setRecipients(Message.RecipientType.TO, internetAddressList); doNothing().when(mk).setContent(anyString(), anyString()); doNothing().when(mk).setSentDate(any(Date.class)); doNothing().when(mk).saveChanges(); when(mk.getAllRecipients()).thenReturn(addresses); })) { s.when(() -> Session.getDefaultInstance(any(Properties.class))).thenReturn(session); SendStatus sendStatus = mu.sendValidateCodeForResetPWD("", "", ""); Assertions."<AssertPlaceHolder>"; } }
sendValidateCodeForResetPWD(String to, String username, String validateCode) { SendStatus sendStatus = new SendStatus(SEND_STATUS_FALSE, ""); String html = readHtmlToString("resetPasswordTemplate.html"); Document doc = Jsoup.parse(html); doc.getElementById(USER_NAME).html(username); doc.getElementById("code").html(validateCode); doc.getElementById("account").html(to); doc.getElementById("validateTimes").html("5"); sendEmail(doc, sendStatus, Lists.newArrayList(to), "修改密码-验证码", "Send validate code email failed before reset password"); return sendStatus; }
[*] target: assertNotNull(sendStatus)
[-] pred: org. junit. Assert. assertNotNull ( sendStatus )
************************************
************************************
[+] input: getActivityLogForTeamOverview() { ChartsJsOverview chartsJsOverview = new ChartsJsOverview(); TeamOverview expected = new TeamOverview(); expected.setTopicsPerTeamPerEnvOverview(chartsJsOverview); expected.setActivityLogOverview(chartsJsOverview);  Mockito.when(commonUtilsService.getCurrentUserName()).thenReturn(TestConstants.USERNAME); Mockito.when(commonUtilsService.getTenantId(TestConstants.USERNAME)) .thenReturn(TestConstants.TENANT_ID); Mockito.when(commonUtilsService.getTeamId(TestConstants.USERNAME)) .thenReturn(TestConstants.TEAM_ID); Mockito.doReturn(chartsJsOverview) .when(analyticsControllerService) .getTopicsPerTeamEnvOverview(TestConstants.TENANT_ID); Mockito.doReturn(chartsJsOverview) .when(analyticsControllerService) .getActivityLogOverview(TestConstants.TEAM_ID, 101, NUMBER_OF_DAYS);  TeamOverview actual = analyticsControllerService.getActivityLogForTeamOverview("true", NUMBER_OF_DAYS); Assertions."<AssertPlaceHolder>"; }
getActivityLogForTeamOverview(String forTeam, int numberOfDays) { TeamOverview teamOverview = new TeamOverview(); final String currentUserName = getCurrentUserName(); Integer userTeamId = commonUtilsService.getTeamId(currentUserName);  teamOverview.setTopicsPerTeamPerEnvOverview( getTopicsPerTeamEnvOverview(commonUtilsService.getTenantId(currentUserName))); if (forTeam != null && forTeam.equals("true")) { teamOverview.setActivityLogOverview(getActivityLogOverview(userTeamId, 101, numberOfDays)); }  return teamOverview; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testIsValidWithInvalidValue() { DoesNotContain doesNotContain = mock(DoesNotContain.class); when(doesNotContain.chars()).thenReturn(new String[]{"@", "#"}); validator.initialize(doesNotContain);  String value = "abc@de"; boolean result = validator.isValid(value, context);  "<AssertPlaceHolder>"; }
isValid(String value, ConstraintValidatorContext context) { if (value == null) { return true; } for (String c : chars) { if (value.contains(c)) { return false; } } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenFullyQualifiedName() { String toVerify = toTest() .withType(BIG_DECIMAL.getFullyQualifiedName()) .getObjectPathOrTypeGenerator() .generate();  String expected = "java.math.BigDecimal";  "<AssertPlaceHolder>"; }
generate() { Optional<String> optionalObjectPathAsString = optionalObjectPathGenerator.map(ObjectPathGenerator::generate); Optional<String> optionalConcreteTypeAsString = optionalConcreteType.map(FullyQualifiedName::raw); Optional<String> optionalGenericTypeAsString = optionalGenericType.map(TypeParameterName::raw); return optionalObjectPathAsString .map(Optional::of).orElse(optionalConcreteTypeAsString) .map(Optional::of).orElse(optionalGenericTypeAsString) .orElseThrow(NullPointerException::new); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: getAll() { final List<Branch> branches = branchService.getAll(); "<AssertPlaceHolder>"; }
getAll() { return branchRepository.findAll(); }
[*] target: assertFalse(branches.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( branches. isEmpty ( ) )
************************************
************************************
[+] input: test_error2() { Exception error = null; try { DefaultJSONParser parser = new DefaultJSONParser("ttr"); parser.parse(); } catch (Exception ex) { error = ex; } "<AssertPlaceHolder>"; }
parse() { return reader.readAny(); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: validateGivenMethodWithTypeParametersThatHaveNoUpperBound() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter(), U.extending(OBJECT), V.asTypeParameter()), Optional.of(OPTIONAL.with(V)), "myFunction", asList( Parameter.of(OPTIONAL.with(T), "left"), Parameter.of(OPTIONAL.with(U), "right"), Parameter.of(BI_FUNCTION.with(T.asType().contravariant(), U.asType().contravariant(), V.asType().covariant()), "compose") ) );  Validated<String, AccumulatorValidator.Result> expected = Validated.valid( AccumulatorValidator.Result.of( "myFunction", OPTIONAL.asTypeConstructor(), OPTIONAL.asTypeConstructor(), OPTIONAL.asTypeConstructor(), OPTIONAL.with(T), OPTIONAL.with(U), OPTIONAL.with(V) ) ); Validated<String, AccumulatorValidator.Result> toVerify = AccumulatorValidator.validate(toValidate, new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
validate(Method method, ParametersAndTypeParametersValidator parametersAndTypeParametersValidator) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages); ParametersAndTypeParametersValidator.Result parametersAndTypeParameters = verifyParametersAndTypeParameters(method, parametersAndTypeParametersValidator, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  // Assign a meaningful name to each of the (three) type parameters: TypeParameter leftInputTypeConstructorArgument = parametersAndTypeParameters.getLeftInputTypeConstructorArgument(); TypeParameter rightInputTypeConstructorArgument = parametersAndTypeParameters.getRightInputTypeConstructorArgument(); TypeParameter returnTypeConstructorArgument = parametersAndTypeParameters.getReturnTypeConstructorArgument();  // Assign a meaningful name to the left and right parameters: Type leftParameterType = parametersAndTypeParameters.getLeftParameterType(); Type rightParameterType = parametersAndTypeParameters.getRightParameterType();  String name = method.getName();  TypeConstructor accumulatedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(returnTypeConstructorArgument.getName()); TypeConstructor partiallyAccumulatedTypeConstructor = leftParameterType.asTypeConstructorWithPlaceholderFor(leftInputTypeConstructorArgument.getName()); TypeConstructor inputTypeConstructor = rightParameterType.asTypeConstructorWithPlaceholderFor(rightInputTypeConstructorArgument.getName());  if (!partiallyAccumulatedTypeConstructor.canAccept(accumulatedTypeConstructor)) { // Tweak the error message to not confuse people using the simple case where // parameter types and result type should be identical: if (Objects.equals(partiallyAccumulatedTypeConstructor, inputTypeConstructor)) { return Validated.invalid("No shared type constructor between parameters (" + generateFrom(leftParameterType) + " and " + generateFrom(rightParameterType) + ") and result (" + generateFrom(returnType) + ")"); } else { return Validated.invalid("No shared type constructor between first parameter (" + generateFrom(leftParameterType) + ") and result (" + generateFrom(returnType) + ")"); } }  verifyNoCrossReferences(method.getTypeParameters(), leftParameterType, partiallyAccumulatedTypeConstructor, "type of the first parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), rightParameterType, inputTypeConstructor, "type of the second parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), returnType, accumulatedTypeConstructor, "return type", errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  return Validated.valid( AccumulatorValidator.Result.of( name, inputTypeConstructor, partiallyAccumulatedTypeConstructor, accumulatedTypeConstructor, leftParameterType, rightParameterType, returnType ) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testEncryptDecrypt() { ReflectionTestUtils.setField( converter, ENCRYPTION_KEY_FIELD, RandomStringUtils.randomAlphabetic(VALID_KEY_LENGTH)); List<String> plaintextStrings = new ArrayList<>(); for (int index = 0; index < 10; index++) { plaintextStrings.add(RandomStringUtils.randomAlphanumeric(RandomUtils.nextInt(5, 30))); }  List<String> encryptedStrings = new ArrayList<>(); for (String plainText : plaintextStrings) { encryptedStrings.add(converter.convertToDatabaseColumn(plainText)); }  for (int index = 0; index < 10; index++) { String plaintext = plaintextStrings.get(index); String decryptedText = converter.convertToEntityAttribute(encryptedStrings.get(index)); "<AssertPlaceHolder>"; } }
convertToEntityAttribute(String cipherMessage) { Cipher cipher = getCipher(); Key key = getSecretKey(); byte[] cipherMessageBytes = Base64.getDecoder().decode(cipherMessage); try { AlgorithmParameterSpec paramSpec = new GCMParameterSpec(AUTH_TAG_LENGTH, cipherMessageBytes, 0, GCM_IV_LENGTH); cipher.init(Cipher.DECRYPT_MODE, key, paramSpec); byte[] plainText = cipher.doFinal(cipherMessageBytes, GCM_IV_LENGTH, cipherMessageBytes.length - GCM_IV_LENGTH); return new String(plainText, StandardCharsets.UTF_8); } catch (InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | IllegalArgumentException | BadPaddingException e) { log.error("Failed to convert to entity attribute, reading encrypted value...", e); return cipherMessage; } }
[*] target: assertEquals(plaintext, decryptedText)
[-] pred: org. junit. Assert. assertEquals ( plaintext, decryptedText )
************************************
************************************
[+] input: apply() { GenericType expected = new GenericType(T); GenericType toVerify = new GenericTypeConstructor(T).apply(STRING_TYPE);  "<AssertPlaceHolder>"; }
apply(Type toApplyTo) { return Type.generic(name); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: mixedVarianceConcreteTypeConstructorCanAcceptGivenEquivalentInvariantConcreteTypeConstructor() { ConcreteTypeConstructor target = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.invariant(), INTEGER_TYPE_CONSTRUCTOR.covariant(), BOOLEAN_TYPE_CONSTRUCTOR.contravariant()); ConcreteTypeConstructor source = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.invariant(), INTEGER_TYPE_CONSTRUCTOR.invariant(), BOOLEAN_TYPE_CONSTRUCTOR.invariant());  "<AssertPlaceHolder>"; }
canAccept(TypeConstructor typeConstructor) { if (typeConstructor instanceof ConcreteTypeConstructor) { ConcreteTypeConstructor that = (ConcreteTypeConstructor) typeConstructor;  return this.fullyQualifiedNameEqualToThatOf(that) && this.typeArgumentsCanAccept(that); } else { return false; } }
[*] target: assertTrue(target.canAccept(source))
[-] pred: org. junit. Assert. assertTrue ( target. canAccept ( source ) )
************************************
************************************
[+] input: bind_withExplodeMap() { commonSetup(true,false,false); targetInsertStatement = new TargetInsertStatement(propertyHelper, targetSession);  BoundStatement result = targetInsertStatement.bind(originRow, targetRow, null,null,getSampleData(explodeMapKeyType),getSampleData(explodeMapValueType)); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size())).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { if (null == originRow) throw new RuntimeException("Origin row is null"); if (usingCounter) throw new RuntimeException("Cannot INSERT onto a counter table, use UPDATE instead");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue); BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; Object bindValue = null;  if (logDebug) logger.debug("bind using conversions: {}",cqlTable.getOtherCqlTable().getConversions()); for (int targetIndex = 0; targetIndex < targetColumnTypes.size(); targetIndex++) { if (!bindColumnIndexes.contains(targetIndex)) { // this happens with constant columns, for example continue; } try { if (targetIndex== explodeMapKeyIndex) { bindValue = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValue = explodeMapValue; } else { int originIndex = cqlTable.getCorrespondingIndex(targetIndex); if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValue = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValue, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValue + " of class:" +(null==bindValue?"unknown":bindValue.getClass().getName())+ " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex)+ "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex + " and bind index: "+ (currentBindIndex-1) + " of statement:" + this.getCQL()); throw e; } }  if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: setProperty_NumberList() { List<Integer> value = Arrays.asList(1,2,3,4); List<Integer> setValue = (List<Integer>) helper.setProperty(KnownProperties.TEST_NUMBER_LIST, value); "<AssertPlaceHolder>"; }
setProperty(String propertyName, Object propertyValue) { if (null == propertyName || null == propertyValue) return null; PropertyType expectedType = getType(propertyName); if (null == expectedType) { return null; }  boolean typesMatch = validateType(expectedType, propertyValue); if (!typesMatch) return null;  synchronized (PropertyHelper.class) { propertyMap.put(propertyName, propertyValue); } return propertyValue; }
[*] target: assertEquals(value, setValue)
[-] pred: org. junit. Assert. assertEquals ( value, setValue )
************************************
************************************
[+] input: testTlsConfig() { ConfigDef confDef = QuestDBSinkConnectorConfig.conf(); Map<String, String> config = baseConnectorProps(); config.put("client.conf.string", "http::addr=localhost;tls=true"); config.put("tls", "true"); QuestDBSinkConnectorConfig sinkConnectorConfig = new QuestDBSinkConnectorConfig(confDef, config);  "<AssertPlaceHolder>"; }
isTls() { return getBoolean(TLS); }
[*] target: assertTrue(sinkConnectorConfig.isTls())
[-] pred: org. junit. Assert. assertTrue ( sinkConnectorConfig. isTls() )
************************************
************************************
[+] input: givenInstanceMethod() { String toVerify = methodReference() .withObjectPath("this") .withMethodName("toString") .generate();  String expected = "this::toString";  "<AssertPlaceHolder>"; }
generate() { return objectPathOrTypeGenerator.generate() + DOUBLE_COLON + methodName; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: replay() { WebClientWrapper target = new WebClientWrapper(clientRequest, strategies); MockResult mockResult = target.replay(); "<AssertPlaceHolder>"; }
replay() { try (TraceTransmitter tm = traceTransmitter2.transmit()) { convertRequest(); return extractor.replay(); } }
[*] target: assertNull(mockResult)
[-] pred: org. junit. Assert. assertNull ( mockResult )
************************************
************************************
[+] input: testGetBundle() { ResourceBundle resourceBundle = PropertyResourceBundleUtils.getBundle("META-INF.test", "UTF-8"); String expected = "测试名称"; String value = resourceBundle.getString("name"); "<AssertPlaceHolder>"; }
getBundle(String baseName, String encoding) { return getBundle(baseName, Locale.getDefault(), encoding); }
[*] target: assertEquals(expected, value)
[-] pred: org. junit. Assert. assertEquals ( expected, value )
************************************
************************************
[+] input: decode_ShouldDecodeByteBufferToValueAndReturnAsString() { String valueAsString = "21474836470.7"; Double value = Double.parseDouble(valueAsString); ByteBuffer byteBuffer = TypeCodecs.DOUBLE.encode(value, CqlConversion.PROTOCOL_VERSION);  String result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { Double doubleValue = TypeCodecs.DOUBLE.decode(bytes, protocolVersion); return doubleValue == null ? null : decimalFormat.format(doubleValue); }
[*] target: assertEquals(valueAsString, result)
[-] pred: org. junit. Assert. assertEquals ( valueAsString, result )
************************************
************************************
[+] input: parse_ShouldParseTextAndReturnAsNumber() { String valueAsString = "12345.6789"; BigDecimal expected = TypeCodecs.DECIMAL.parse(valueAsString); BigDecimal result = codec.parse(valueAsString); Assertions."<AssertPlaceHolder>"; }
parse(String value) { return value == null ? null : new BigDecimal(value); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismTwoNodeButAllNodeAreNull() { when(nodeList.size()).thenReturn(2); when(nodeList.get(0)).thenReturn(null); when(nodeList.get(1)).thenReturn(null); boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(1)).get(0); verify(nodeList, times(0)).get(1); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: testHandleCommandResult() { // Setup final ClusterServiceCommandHostCommandEntity expectedResult = new ClusterServiceCommandHostCommandEntity(); expectedResult.setHostCommandId("hostCommandId"); expectedResult.setCommandName("commandName"); expectedResult.setCommandState(CommandState.WAIT); expectedResult.setCommandStateCode(0); expectedResult.setCommandProgress(0); expectedResult.setCommandHostId("commandHostId"); expectedResult.setCommandId("commandId"); expectedResult.setHostname("hostname"); expectedResult.setServiceRoleName("serviceRoleName"); expectedResult.setServiceRoleType(RoleType.MASTER); expectedResult.setResultMsg("execOut"); expectedResult.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); expectedResult.setCommandType(0);  // Run the test final ClusterServiceCommandHostCommandEntity result = ProcessUtils.handleCommandResult("hostCommandId", false, "execOut");  // Verify the results "<AssertPlaceHolder>"; }
handleCommandResult(String hostCommandId, Boolean execResult, String execOut) { ClusterServiceCommandHostCommandService service = SpringTool.getApplicationContext().getBean(ClusterServiceCommandHostCommandService.class);  ClusterServiceCommandHostCommandEntity hostCommand = service.getByHostCommandId(hostCommandId); hostCommand.setCommandProgress(100); if (execResult) { hostCommand.setCommandState(CommandState.SUCCESS); hostCommand.setResultMsg("success"); logger.info("{} in {} success", hostCommand.getCommandName(), hostCommand.getHostname()); } else { hostCommand.setCommandState(CommandState.FAILED); hostCommand.setResultMsg(execOut); logger.info("{} in {} failed", hostCommand.getCommandName(), hostCommand.getHostname()); } service.updateByHostCommandId(hostCommand); // 更新command host进度 // 更新command进度 UpdateCommandHostMessage message = new UpdateCommandHostMessage(); message.setExecResult(execResult); message.setCommandId(hostCommand.getCommandId()); message.setCommandHostId(hostCommand.getCommandHostId()); message.setHostname(hostCommand.getHostname()); if (hostCommand.getServiceRoleType() == RoleType.MASTER) { message.setServiceRoleType(ServiceRoleType.MASTER); } else { message.setServiceRoleType(ServiceRoleType.WORKER); }  ActorRef commandActor = ActorUtils.getLocalActor(ServiceCommandActor.class, "commandActor"); ActorUtils.actorSystem.scheduler().scheduleOnce(FiniteDuration.apply( 1L, TimeUnit.SECONDS), commandActor, message, ActorUtils.actorSystem.dispatcher(), ActorRef.noSender());  return hostCommand; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: generateReport_AuthorizedUser() { TeamOverview teamOverview = UtilMethods.getDummyTeamOverview();  List<TeamOverview> listTeamsOverview = List.of(teamOverview); Topic topic = UtilMethods.getDummyTopic(); Acl acl = UtilMethods.getDummyAcl();  loginMock(); Mockito.when(commonUtilsService.getCurrentUserName()).thenReturn(TestConstants.USERNAME); Mockito.when(commonUtilsService.getTenantId(TestConstants.USERNAME)) .thenReturn(TestConstants.TENANT_ID); Mockito.when( manageDatabase.getKwPropertyValue( KwConstants.KW_REPORTS_TMP_LOCATION_KEY, TestConstants.TENANT_ID)) .thenReturn(TestConstants.KW_REPORTS_LOCATION); Mockito.doReturn(listTeamsOverview) .when(analyticsControllerService) .getTeamsOverview(null, NUMBER_OF_DAYS); Mockito.when(commonUtilsService.getEnvsFromUserId(any())) .thenReturn(Set.of(TestConstants.ENV_ID)); Mockito.doReturn(TestConstants.ENV_NAME) .when(analyticsControllerService) .getEnvName(TestConstants.ENV_ID); Mockito.when( commonUtilsService.isNotAuthorizedUser(any(), eq(PermissionType.ALL_TEAMS_REPORTS))) .thenReturn(false); Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when(handleDbRequestsJdbc.getAllTopics(TestConstants.TENANT_ID)) .thenReturn(List.of(topic)); Mockito.when(handleDbRequestsJdbc.getAllConsumerGroups(TestConstants.TENANT_ID)) .thenReturn(List.of(acl));  File actual = analyticsControllerService.generateReport(NUMBER_OF_DAYS); Assertions."<AssertPlaceHolder>"; actual.deleteOnExit(); }
generateReport(int numberOfDays) { int tenantId = commonUtilsService.getTenantId(getCurrentUserName()); String kwReportsLocation = manageDatabase.getKwPropertyValue(KwConstants.KW_REPORTS_TMP_LOCATION_KEY, tenantId);  List<TeamOverview> totalOverviewList = getTeamsOverview(null, numberOfDays); final Map<String, List<String>> topicNames = getTopicNames(tenantId); final Map<String, List<String>> consumerGroups = getConsumerGroups(tenantId); File zipFile = new File( kwReportsLocation + "KwReport" + DATE_TIME_FORMATTER.format(Instant.now()) + ".zip"); ZipOutputStream zipOutputStream = null; try { zipOutputStream = new ZipOutputStream(new FileOutputStream(zipFile)); } catch (FileNotFoundException e) { log.error("Exception:", e); }  String actualFileName; List<File> reportFilesOfTenants = new ArrayList<>(); for (TeamOverview totalOverview : totalOverviewList) { if (totalOverview.getTenantName() != null) { actualFileName = "Klaw-" + totalOverview.getTenantName() + ".xlsx"; } else { actualFileName = "KlawReport" + ".xlsx"; }  String fileName = kwReportsLocation + actualFileName; File reportFile = new File(fileName); reportFilesOfTenants.add(reportFile);  XSSFWorkbook workbook = new XSSFWorkbook();  generateReportPerView(totalOverview.getTopicsPerEnvOverview(), workbook, reportFile); generateReportPerView(totalOverview.getPartitionsPerEnvOverview(), workbook, reportFile); generateReportPerView(totalOverview.getTopicsPerTeamsOverview(), workbook, reportFile); generateReportPerView(totalOverview.getAclsPerEnvOverview(), workbook, reportFile); generateReportPerView(totalOverview.getProducerAclsPerTeamsOverview(), workbook, reportFile); generateReportPerView(totalOverview.getConsumerAclsPerTeamsOverview(), workbook, reportFile); generateReportPerView(totalOverview.getActivityLogOverview(), workbook, reportFile);  addTopicNamesPerEnvToReport(topicNames, workbook, reportFile, "Topics"); addTopicNamesPerEnvToReport(consumerGroups, workbook, reportFile, "ConsumerGroups");  log.info("Report generated"); if (zipOutputStream != null) { writeToZipFile(zipOutputStream, fileName, actualFileName); } }  try { if (zipOutputStream != null) { zipOutputStream.close(); // delete xlsx report file after writing to zip file. for (File reportFilesOfTenant : reportFilesOfTenants) { reportFilesOfTenant.delete(); } } } catch (IOException e) { log.error("Exception:", e); }  return zipFile; }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: testReOpenAll() { List<WebHookInfoVo> mock = mock(List.class); when(webHookController.success(mock)).thenReturn(mock(ResponseMessage.class)); String[] ids = new String[]{"id"}; when(webHookService.reOpen(ids, user)).thenReturn(mock); when(webHookController.reOpenAll(ids)).thenCallRealMethod(); ResponseMessage<List<WebHookInfoVo>> hook = webHookController.reOpenAll(ids); Assertions."<AssertPlaceHolder>"; verify(webHookController).success(mock); verify(webHookService).reOpen(ids, user); }
reOpenAll(@RequestParam(value = "ids") String[] ids) { return success(webHookService.reOpen(ids, getLoginUser())); }
[*] target: assertNotNull(hook)
[-] pred: org. junit. Assert. assertNotNull ( hook )
************************************
************************************
[+] input: testGetDiscountAmount_withAmountDiscountType() { given(couponCampaign.getDiscountType()).willReturn(DiscountType.AMOUNT); given(couponCampaign.getDiscountAmount()).willReturn(discountAmount); given(couponCampaign.getMinimumCost()).willReturn(minimumCost);  Money supplyAmount = Money.wons(60000L); Money expectedDiscountAmount = Money.wons(10000L); Money actualDiscountAmount = issuedCoupon.getDiscountAmount(supplyAmount);  "<AssertPlaceHolder>"; }
getDiscountAmount(Money supplyAmount) { if (couponCampaign.getDiscountType().equals(DiscountType.AMOUNT)) { // 정액 할인 return checkSupplyAmount( supplyAmount, couponCampaign.getDiscountAmount(), couponCampaign.getMinimumCost()); } // 정률 할인 Long discountAmount = supplyAmount.getDiscountAmountByPercentage( supplyAmount, couponCampaign.getDiscountAmount()); return checkSupplyAmount(supplyAmount, discountAmount, couponCampaign.getMinimumCost()); }
[*] target: assertEquals(expectedDiscountAmount, actualDiscountAmount)
[-] pred: org. junit. Assert. assertEquals ( expectedDiscountAmount, actualDiscountAmount )
************************************
************************************
[+] input: testReturnsTaskDto() { try (MockedStatic<BeanUtil> beanUtilMockedStatic = mockStatic(BeanUtil.class)) { String taskId = "testTaskId"; TaskDto expectedTaskDto = new TaskDto(); when(clientMongoOperator.findOne(any(Query.class), anyString(), eq(TaskDto.class))).thenReturn(expectedTaskDto); beanUtilMockedStatic.when(() -> BeanUtil.getBean(ClientMongoOperator.class)).thenReturn(clientMongoOperator);  TaskDto result = mergeNodeCleaner.findTaskById(taskId);  "<AssertPlaceHolder>"; verify(clientMongoOperator, times(1)).findOne(any(Query.class), anyString(), eq(TaskDto.class)); } }
findTaskById(String taskId) { ClientMongoOperator clientMongoOperator = BeanUtil.getBean(ClientMongoOperator.class); Query query = new Query(Criteria.where("_id").is(taskId)); query.fields().include("dag"); return clientMongoOperator.findOne(query, ConnectorConstant.TASK_COLLECTION, TaskDto.class); }
[*] target: assertEquals(expectedTaskDto, result)
[-] pred: org. junit. Assert. assertEquals ( expectedTaskDto, result )
************************************
************************************
[+] input: testDeterminePage01() { ValidatorForm validatorForm = new ValidatorForm(); ActionMapping mapping = new ActionMapping();  mapping.setAcceptPage(null); validatorForm.setPage(-1); int page = validatorForm.determinePage(mapping, null);  "<AssertPlaceHolder>"; }
determinePage(ActionMapping mapping, HttpServletRequest request) { Integer acceptPage = mapping.getAcceptPage(); return acceptPage != null ? Math.max(acceptPage.intValue(), getPage()) : Integer.MAX_VALUE; }
[*] target: assertEquals(Integer.MAX_VALUE, page)
[-] pred: org. junit. Assert. assertEquals ( Integer. MAX_VALUE, page )
************************************
************************************
[+] input: topBit() { final int i = Integer.MAX_VALUE - 1; final int ret = set.previousClearBit(i);  "<AssertPlaceHolder>"; }
previousClearBit(int fromIndex);  // ------------------------------------------------------------------------ // bulk operations // ------------------------------------------------------------------------  /** * Returns {@code true}
[*] target: assertEquals(i, ret)
[-] pred: org. junit. Assert. assertEquals ( i, ret )
************************************
************************************
[+] input: format_ShouldFormatValueAsString() { String valueAsString = "1681333035000"; Instant value = Instant.ofEpochMilli(Long.parseLong(valueAsString)); String expected = TypeCodecs.TIMESTAMP.format(value);  String result = codec.format(valueAsString); Assertions."<AssertPlaceHolder>"; }
format(String value) { Instant instantValue = Instant.ofEpochMilli(Long.parseLong(value)); return TypeCodecs.TIMESTAMP.format(instantValue); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: should_fetch_populars() { // given final List<Movie> movies = List.of(MovieFactory.MOVIE_POJO); when(moviesProvider.getPopulars()).thenReturn(movies); // when final List<Movie> result = moviesService.getPopulars(); // then "<AssertPlaceHolder>";  }
getPopulars();
[*] target: assertEquals(movies, result)
[-] pred: org. junit. Assert. assertEquals ( movies, result )
************************************
************************************
[+] input: asTypeConstructorWithPlaceholderForGivenNeedleThatMatches() { TypeConstructor expected = new PlaceholderTypeConstructor(); TypeConstructor toVerify = new GenericType(T).asTypeConstructorWithPlaceholderFor(T);  "<AssertPlaceHolder>"; }
asTypeConstructorWithPlaceholderFor(TypeParameterName needle) { if (Objects.equals(name, needle)) { return TypeConstructor.placeholder(); } else { return TypeConstructor.generic(name); } }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: 오더라인_총_가격_조회_검증() { // given Money optionAnswerPrice1 = Money.wons(1000L); given(orderOptionAnswer1.getAdditionalPrice()).willReturn(optionAnswerPrice1); Money optionAnswerPrice2 = Money.wons(2000L); given(orderOptionAnswer2.getAdditionalPrice()).willReturn(optionAnswerPrice2); given(orderItem.getPrice()).willReturn(money3000); // when Money totalOrderLinePrice = orderLineItem.getTotalOrderLinePrice(); // then Money total = optionAnswerPrice1.plus(optionAnswerPrice2).plus(money3000).times(quantity); "<AssertPlaceHolder>"; }
getTotalOrderLinePrice() { return getItemPrice().plus(getOptionAnswersPrice()).times(quantity); }
[*] target: assertEquals(totalOrderLinePrice, total)
[-] pred: org. junit. Assert. assertEquals ( totalOrderLinePrice, total )
************************************
************************************
[+] input: testCityNeighbors() { CityManager manager = CityManager.getInstance(); System.out.println("++++ " + manager.getClosestCity("Boston", 1)); List<String> expected = Arrays.asList("Boston", "South Boston", "Worcester", "Providence", "Springfield"); List<String> found = manager.getKey("Boston").getNeighbors().stream().limit(5).map(City::getName).collect(Collectors.toList()); System.out.println("++++ Found: " + found); System.out.println("++++ Expected: " + expected); "<AssertPlaceHolder>"; }
getClosestCity(String city, int k) { String key = city.toUpperCase(); City lookup = getKey(key);  if (lookup == null) { return getRandomKey(); }  List<City> neighbors = lookup.getNeighbors(); if (neighbors == null) { return getRandomKey(lookup.getNameCountryCode()); }  if (k > neighbors.size()) { k = neighbors.size(); }  return (neighbors.get(random.nextInt(k))).getName(); }
[*] target: assertEquals(expected, found)
[-] pred: org. junit. Assert. assertEquals ( expected, found )
************************************
************************************
[+] input: getTopicsTeamsOverview() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when( handleDbRequestsJdbc.getTopicsCountByTeams( TestConstants.TEAM_ID, TestConstants.TENANT_ID)) .thenReturn(Collections.emptyList()); Mockito.when( manageDatabase.getTeamNameFromTeamId(TestConstants.TENANT_ID, TestConstants.TEAM_ID)) .thenReturn(TestConstants.TEAM_NAME); Mockito.when( commonUtilsService.getChartsJsOverview( eq(Collections.emptyList()), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getTopicsTeamsOverview( TestConstants.TEAM_ID, TestConstants.TENANT_ID);  Assertions."<AssertPlaceHolder>"; }
getTopicsTeamsOverview(Integer teamId, Integer tenantId) {  List<CommonUtilsService.ChartsOverviewItem<Integer, Integer>> teamCountList = manageDatabase.getHandleDbRequests().getTopicsCountByTeams(teamId, tenantId); String title = ANALYTICS_103; if (teamId != null) { title += " (" + manageDatabase.getTeamNameFromTeamId(tenantId, teamId) + ")"; } else { title += " (all teams)"; }  return commonUtilsService.getChartsJsOverview( teamCountList, title, "teamid", "Teams", "Topics", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { ObjectMapper mapper = new ObjectMapper();  for (ProviderType type : ProviderType.publicValues()) { String s = mapper.writeValueAsString(type);  "<AssertPlaceHolder>"; } }
publicValues() { Collection<ProviderType> providerTypes = new ArrayList<>();  for (ProviderType p : registeredTypes.values()) { if (!p.isForInternalPurposes()) { providerTypes.add(p); } }  return providerTypes; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: testNull() { Long l = HashUtils.longFromHash(null); "<AssertPlaceHolder>"; }
longFromHash(String value) { return longFromHash(value, "SHA-512"); }
[*] target: assertNotNull(l)
[-] pred: org. junit. Assert. assertNotNull ( l )
************************************
************************************
[+] input: IOException {  String mockData = "some metric data"; InputStream inputStream = new ByteArrayInputStream(mockData.getBytes());  prometheusUtilMock.when(() -> PrometheusUtil.parseMetrics(any(InputStream.class))).thenReturn(null);  boolean result = pushGatewayService.pushMetricsData(inputStream);  "<AssertPlaceHolder>"; prometheusUtilMock.verify( () -> PrometheusUtil.parseMetrics(any(InputStream.class)), times(1) ); }
pushMetricsData(InputStream inputStream) throws IOException;
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testCollectSyncJobData() {  Job job = mock(Job.class); List<CollectRep.MetricsData> metricsDataList = List.of(CollectRep.MetricsData.newBuilder().build()); CountDownLatch latch = new CountDownLatch(1);  doAnswer(invocation -> { CollectResponseEventListener listener = invocation.getArgument(1); listener.response(metricsDataList); latch.countDown(); return null; }).when(timerDispatch).addJob(any(Job.class), any(CollectResponseEventListener.class));  List<CollectRep.MetricsData> result = collectJobService.collectSyncJobData(job);  "<AssertPlaceHolder>"; }
collectSyncJobData(Job job) { final List<CollectRep.MetricsData> metricsData = new LinkedList<>(); final CountDownLatch countDownLatch = new CountDownLatch(1); CollectResponseEventListener listener = new CollectResponseEventListener() { @Override public void response(List<CollectRep.MetricsData> responseMetrics) { if (responseMetrics != null) { metricsData.addAll(responseMetrics); } countDownLatch.countDown(); } }; timerDispatch.addJob(job, listener); try { countDownLatch.await(120, TimeUnit.SECONDS); } catch (Exception e) { log.info("The sync task runs for 120 seconds with no response and returns"); } return metricsData; }
[*] target: assertEquals(metricsDataList, result)
[-] pred: org. junit. Assert. assertEquals ( metricsDataList, result )
************************************
************************************
[+] input: test2() { processorBaseContext.getTaskDto().setType(SyncTypeEnum.INITIAL_SYNC.getSyncType()); when(mockHazelcastMergeNode.isSubTableFirstMode()).thenReturn(true); mockHazelcastMergeNode.initMergeCache(); Map<String, ConstructIMap<Document>> cacheMap = (Map<String, ConstructIMap<Document>>) ReflectionTestUtils.getField(mockHazelcastMergeNode, "mergeCacheMap"); boolean mapIsNull = cacheMap != null; "<AssertPlaceHolder>"; }
initMergeCache() { if (isInitialSyncTask() && !isSubTableFirstMode()) return; this.mergeCacheMap = new HashMap<>(); if (MapUtils.isEmpty(this.lookupMap)) { return; } for (List<MergeTableProperties> lookupList : this.lookupMap.values()) { for (MergeTableProperties mergeProperty : lookupList) { String cacheName; try { cacheName = getMergeCacheName(mergeProperty.getId(), mergeProperty.getTableName()); } catch (Exception e) { throw new TapCodeException(TaskMergeProcessorExCode_16.INIT_MERGE_CACHE_GET_CACHE_NAME_FAILED, e); } if (StringUtils.isBlank(cacheName)) { break; } int mergeCacheInMemSize = CommonUtils.getPropertyInt(MERGE_CACHE_IN_MEM_SIZE_PROP_KEY, DEFAULT_MERGE_CACHE_IN_MEM_SIZE); ExternalStorageDto externalStorageDtoCopy = copyExternalStorage(mergeCacheInMemSize); ConstructIMap<Document> hazelcastConstruct = buildConstructIMap(jetContext.hazelcastInstance(), TAG, cacheName, externalStorageDtoCopy); this.mergeCacheMap.put(mergeProperty.getId(), hazelcastConstruct); obsLogger.info("Create merge cache imap name: {}, external storage: {}", cacheName, externalStorageDtoCopy); } } }
[*] target: assertEquals(true, mapIsNull)
[-] pred: org. junit. Assert. assertEquals ( true, mapIsNull )
************************************
************************************
[+] input: SQLException { final Statement statement = mock(Statement.class); when(statement.enquoteIdentifier(anyString(), anyBoolean())).thenAnswer((Answer<String>) invocation -> { final Object[] args = invocation.getArguments(); return """ + args[0] + """; // enquote the column names }); final String insertStatement = SqlRowReader.getSelectStatementSql(statement, columnNames, NONCE_HEADER_DEFAULT); final String expectedInsertStatement = "SELECT "firstname","lastname","address","city","state","phonenumber"" + ","title","level","notes","" + NONCE_HEADER_DEFAULT + "" FROM " + TableGenerator.DEFAULT_TABLE_NAME + " ORDER BY "" + NONCE_HEADER_DEFAULT + """; "<AssertPlaceHolder>"; }
getSelectStatementSql(final Statement statement, final List<ColumnHeader> columnNames, final ColumnHeader nonceHeader) { final StringBuilder sb = new StringBuilder(); sb.append("SELECT "); // Append all the escaped column names sb.append(columnNames.stream().map(column -> { try { return statement.enquoteIdentifier(column.toString(), true); } catch (SQLException e) { throw new C3rRuntimeException("Could not prepare internal statement for temporary database. Failed to escape column " + "header: " + column, e); } }).collect(Collectors.joining(","))); try { final String nonce = statement.enquoteIdentifier(nonceHeader.toString(), true); sb.append(",").append(nonce).append(" FROM ").append(TableGenerator.DEFAULT_TABLE_NAME); sb.append(" ORDER BY ").append(nonce); return sb.toString(); } catch (SQLException e) { throw new C3rRuntimeException("Invalid SQL identifier encountered.", e); } }
[*] target: assertEquals(expectedInsertStatement, insertStatement)
[-] pred: org. junit. Assert. assertEquals ( expectedInsertStatement, insertStatement )
************************************
************************************
[+] input: testIsAllowedExtensionWhenNull() { String[] imageTypes = null;  boolean isAllow = FileUploadUtils.isExtensionAllowed("img", imageTypes);  Assertions."<AssertPlaceHolder>"; }
isExtensionAllowed(String extension, String[] allowedExtension) { if (allowedExtension == null || allowedExtension.length == 0) { return true; } return StrUtil.containsAnyIgnoreCase(extension, allowedExtension); }
[*] target: assertTrue(isAllow)
[-] pred: org. junit. Assert. assertTrue ( isAllow )
************************************
************************************
[+] input: testShouldTriggerCronBasedSnapshot_NoNextValidTime() { String cronExpressionString = "0 0 0 29 2 ? 1999"; // An impossible time (Feb 29, 1999 was not a leap year) CronExpression cronExpression = SnapshotUtils.interpretAsCron(cronExpressionString).get();  Instant now = Instant.now(); Instant lastTrigger = now.minus(Duration.ofDays(365));  boolean result = SnapshotUtils.shouldTriggerCronBasedSnapshot( CHECKPOINT, cronExpression, lastTrigger, now);  "<AssertPlaceHolder>"; }
shouldTriggerCronBasedSnapshot( SnapshotType snapshotType, CronExpression cronExpression, Instant lastTriggerDateInstant, Instant nowInstant) { Date now = Date.from(nowInstant); Date lastTrigger = Date.from(lastTriggerDateInstant);  Date nextValidTimeAfterLastTrigger = cronExpression.getNextValidTimeAfter(lastTrigger);  if (nextValidTimeAfterLastTrigger != null && nextValidTimeAfterLastTrigger.before(now)) { LOG.info( "Triggering new automatic {} based on cron schedule '{}' due at {}", snapshotType.toString().toLowerCase(), cronExpression.toString(), nextValidTimeAfterLastTrigger); return true; } else { return false; } }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testSerializeWithNullMetricsData() {  byte[] bytes = serializer.serialize("", null);  "<AssertPlaceHolder>"; }
serialize(String s, CollectRep.MetricsData metricsData) {  if (metricsData == null) { log.error("metricsData is null"); return null; }  return metricsData.toByteArray(); }
[*] target: assertNull(bytes)
[-] pred: org. junit. Assert. assertNull ( bytes )
************************************
************************************
[+] input: validateGivenMethodThatDoesNotReturnAnything() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter()), Optional.empty(), "myFunction", asList( Parameter.of(OPTIONAL.with(T), "left"), Parameter.of(OPTIONAL.with(U), "right"), Parameter.of(BI_FUNCTION.with(T.asType().contravariant(), U.asType().contravariant(), V.asType().covariant()), "compose") ) );  Validated<String, AccumulatorValidator.Result> expected = Validated.invalid("Method needs to return something"); Validated<String, AccumulatorValidator.Result> toVerify = AccumulatorValidator.validate(toValidate, new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
validate(Method method, ParametersAndTypeParametersValidator parametersAndTypeParametersValidator) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages); ParametersAndTypeParametersValidator.Result parametersAndTypeParameters = verifyParametersAndTypeParameters(method, parametersAndTypeParametersValidator, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  // Assign a meaningful name to each of the (three) type parameters: TypeParameter leftInputTypeConstructorArgument = parametersAndTypeParameters.getLeftInputTypeConstructorArgument(); TypeParameter rightInputTypeConstructorArgument = parametersAndTypeParameters.getRightInputTypeConstructorArgument(); TypeParameter returnTypeConstructorArgument = parametersAndTypeParameters.getReturnTypeConstructorArgument();  // Assign a meaningful name to the left and right parameters: Type leftParameterType = parametersAndTypeParameters.getLeftParameterType(); Type rightParameterType = parametersAndTypeParameters.getRightParameterType();  String name = method.getName();  TypeConstructor accumulatedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(returnTypeConstructorArgument.getName()); TypeConstructor partiallyAccumulatedTypeConstructor = leftParameterType.asTypeConstructorWithPlaceholderFor(leftInputTypeConstructorArgument.getName()); TypeConstructor inputTypeConstructor = rightParameterType.asTypeConstructorWithPlaceholderFor(rightInputTypeConstructorArgument.getName());  if (!partiallyAccumulatedTypeConstructor.canAccept(accumulatedTypeConstructor)) { // Tweak the error message to not confuse people using the simple case where // parameter types and result type should be identical: if (Objects.equals(partiallyAccumulatedTypeConstructor, inputTypeConstructor)) { return Validated.invalid("No shared type constructor between parameters (" + generateFrom(leftParameterType) + " and " + generateFrom(rightParameterType) + ") and result (" + generateFrom(returnType) + ")"); } else { return Validated.invalid("No shared type constructor between first parameter (" + generateFrom(leftParameterType) + ") and result (" + generateFrom(returnType) + ")"); } }  verifyNoCrossReferences(method.getTypeParameters(), leftParameterType, partiallyAccumulatedTypeConstructor, "type of the first parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), rightParameterType, inputTypeConstructor, "type of the second parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), returnType, accumulatedTypeConstructor, "return type", errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  return Validated.valid( AccumulatorValidator.Result.of( name, inputTypeConstructor, partiallyAccumulatedTypeConstructor, accumulatedTypeConstructor, leftParameterType, rightParameterType, returnType ) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: Exception { URL resourceURL = ClassLoaderUtils.getClassResource(classLoader, Nonnull.class); JarFile jarFile = toJarFile(resourceURL); "<AssertPlaceHolder>"; }
toJarFile(URL jarURL) throws IOException { JarFile jarFile = null; final String jarAbsolutePath = resolveJarAbsolutePath(jarURL); if (jarAbsolutePath == null) return null; jarFile = new JarFile(jarAbsolutePath); return jarFile; }
[*] target: assertNotNull(jarFile)
[-] pred: org. junit. Assert. assertNotNull ( jarFile )
************************************
************************************
[+] input: testFindByIdsNormal() { TaskRepository repository = mock(TaskRepository.class); taskService = spy(new TaskServiceImpl(repository)); List<ObjectId> idList = new ArrayList<>(); ObjectId id = mock(ObjectId.class); idList.add(id); List<TaskEntity> taskEntityList = new ArrayList<>(); taskEntityList.add(mock(TaskEntity.class)); MongoTemplate template = mock(MongoTemplate.class); when(repository.getMongoOperations()).thenReturn(template); when(template.find(any(Query.class),any(Class.class))).thenReturn(taskEntityList); List<TaskEntity> actual = taskService.findByIds(idList); "<AssertPlaceHolder>"; }
findByIds(List<ObjectId> idList) { List<TaskEntity> taskEntityList = new ArrayList<>(); Query query = Query.query(Criteria.where("id").in(idList)); query.fields().exclude("dag"); taskEntityList = repository.getMongoOperations().find(query, TaskEntity.class); return taskEntityList; }
[*] target: assertEquals(taskEntityList,actual)
[-] pred: org. junit. Assert. assertEquals ( taskEntityList, actual )
************************************
************************************
[+] input: LocationNotFoundException { // Mock data MonitoringLocationDTO monitoringLocationDTO = MonitoringLocationDTO.newBuilder().setTenantId(TENANT_ID).build(); MonitoringLocation monitoringLocation = new MonitoringLocation(); monitoringLocation.setTenantId(TENANT_ID); when(mapper.dtoToModel(any(MonitoringLocationDTO.class))).thenReturn(monitoringLocation); when(modelRepo.save(monitoringLocation)).thenReturn(monitoringLocation); when(mapper.modelToDTO(any(MonitoringLocation.class))).thenReturn(monitoringLocationDTO);  // Test MonitoringLocationDTO result = monitoringLocationService.upsert(monitoringLocationDTO);  // Assertions "<AssertPlaceHolder>"; verify(mapper, times(1)).dtoToModel(any(MonitoringLocationDTO.class)); verify(modelRepo, times(1)).save(monitoringLocation); verify(mapper, times(1)).modelToDTO(any(MonitoringLocation.class)); }
upsert(MonitoringLocationDTO dto) throws LocationNotFoundException { if (dto.hasField(MonitoringLocationDTO.getDescriptor().findFieldByNumber(MonitoringLocationDTO.ID_FIELD_NUMBER)) && modelRepo.findByIdAndTenantId(dto.getId(), dto.getTenantId()).isEmpty()) { throw new LocationNotFoundException("Location not found with ID " + dto.getId()); } if (dto.hasField( MonitoringLocationDTO.getDescriptor().findFieldByNumber(MonitoringLocationDTO.LOCATION_FIELD_NUMBER))) { if (StringUtils.isBlank(dto.getLocation())) { throw new InventoryRuntimeException("Location is Blank"); } var location = modelRepo.findByLocationAndTenantId(dto.getLocation().trim(), dto.getTenantId()); if (location.isPresent() && location.get().getId() != dto.getId()) { throw new InventoryRuntimeException("Duplicate Location found with name " + dto.getLocation()); } }  MonitoringLocation model = mapper.dtoToModel(dto); return mapper.modelToDTO(modelRepo.save(model)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: generateGivenContravariant() { String expected = "? super java.lang.Boolean"; String toVerify = new TypeArgumentGenerator(BOOLEAN.contravariant()).generate();  "<AssertPlaceHolder>"; }
generate() { String generatedType = TypeGenerator.generateFrom(typeArgument.getType()); switch (typeArgument.getVariance()) { case INVARIANT: return generatedType; case COVARIANT: return String.join(SPACE, QUESTION_MARK, EXTENDS, generatedType); case CONTRAVARIANT: return String.join(SPACE, QUESTION_MARK, SUPER, generatedType); default: throw new RuntimeException("Not implemented"); } }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testDeleteUserGroup_ClusterHostServiceReturnsNoItems() { // Setup final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  when(mockUserGroupService.countGroupUserNum(0)).thenReturn(0); when(mockHostService.getHostListByClusterId(0)).thenReturn(Collections.emptyList());  // Run the test final Result result = clusterGroupServiceImplUnderTest.deleteUserGroup(0);  // Verify the results "<AssertPlaceHolder>"; }
deleteUserGroup(Integer id) { ClusterGroup clusterGroup = this.getById(id); Integer num = userGroupService.countGroupUserNum(id); if (num > 0) { return Result.error(Status.USER_GROUP_TIPS_ONE.getMsg()); } this.removeById(id); List<ClusterHostDO> hostList = hostService.getHostListByClusterId(clusterGroup.getClusterId()); for (ClusterHostDO clusterHost : hostList) { ActorRef unixGroupActor = ActorUtils.getRemoteActor(clusterHost.getHostname(), "unixGroupActor"); DelUnixGroupCommand delUnixGroupCommand = new DelUnixGroupCommand(); delUnixGroupCommand.setGroupName(clusterGroup.getGroupName()); Timeout timeout = new Timeout(Duration.create(180, TimeUnit.SECONDS)); Future<Object> execFuture = Patterns.ask(unixGroupActor, delUnixGroupCommand, timeout); ExecResult execResult = null; try { execResult = (ExecResult) Await.result(execFuture, timeout.duration()); if (execResult.getExecResult()) { logger.info("del unix group success at {}", clusterHost.getHostname()); } else { logger.info("del unix group failed at {}", clusterHost.getHostname()); } } catch (Exception e) { logger.info("del unix group failed at {}", clusterHost.getHostname()); } } return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: test() { String str = "abcdef1234567890中国©®£\uD83D\uDE0D\uD83D\uDC81\uD83D\uDC4C\uD83C\uDF8D\uD83D\uDE0D"; String json = JSON.toJSONString(str); byte[] bytes = json.getBytes(StandardCharsets.UTF_8); JSONReader jsonReader = JSONReader.of(bytes, 0, bytes.length, StandardCharsets.UTF_8); String parsed = jsonReader.readString(); "<AssertPlaceHolder>"; }
readString() { final byte[] bytes = this.bytes; if (ch == '"' || ch == ''') { char quote = this.ch; int valueLength; int offset = this.offset; final int start = offset, end = this.end; boolean ascii = true; valueEscape = false;  for (int i = 0; ; ++i) { if (offset >= end) { throw new JSONException("invalid escape character EOI"); }  int ch = bytes[offset]; if (ch == '\') { valueEscape = true; ch = bytes[offset + 1]; offset += (ch == 'u' ? 6 : (ch == 'x' ? 4 : 2)); continue; }  if (ch >= 0) { if (ch == quote) { valueLength = i; break; } offset++; } else { ascii = false; switch ((ch & 0xFF) >> 4) { case 12: case 13: { /* 110x xxxx   10xx xxxx*/ offset += 2; break; } case 14: { offset += 3; break; } default: { /* 10xx xxxx,  1111 xxxx */ if ((ch >> 3) == -2) { offset += 4; i++; break; }  throw new JSONException("malformed input around byte " + offset); } } } }  String str; if (valueEscape) { char[] chars = new char[valueLength]; offset = start; for (int i = 0; ; ++i) { int ch = bytes[offset]; if (ch == '\') { ch = bytes[++offset]; switch (ch) { case 'u': { ch = DIGITS2[bytes[offset + 1]] * 0x1000 + DIGITS2[bytes[offset + 2]] * 0x100 + DIGITS2[bytes[offset + 3]] * 0x10 + DIGITS2[bytes[offset + 4]]; offset += 4; break; } case 'x': { ch = DIGITS2[bytes[offset + 1]] * 0x10 + DIGITS2[bytes[offset + 2]]; offset += 2; break; } case '\': case '"': break; case 'b': ch = '\b'; break; case 't': ch = '\t'; break; case 'n': ch = '\n'; break; case 'f': ch = '\f'; break; case 'r': ch = '\r'; break; default: ch = char1(ch); break; } chars[i] = (char) ch; offset++; } else if (ch == quote) { break; } else { if (ch >= 0) { chars[i] = (char) ch; offset++; } else { switch ((ch & 0xFF) >> 4) { case 0b1100: case 0b1101: { /* 110x xxxx   10xx xxxx*/ int c2 = bytes[offset + 1]; chars[i] = (char) ( ((ch & 0x1F) << 6) | (c2 & 0x3F)); offset += 2; break; } case 0b1110: { chars[i] = (char) (((ch & 0x0F) << 12) | ((bytes[offset + 1] & 0x3F) << 6) | ((bytes[offset + 2] & 0x3F))); offset += 3; break; } default: { char2_utf8(bytes, offset, ch, chars, i); offset += 4; i++; } } } } }  str = new String(chars); } else if (ascii) { int strlen = offset - start; if (strlen == 1) { str = TypeUtils.toString((char) (bytes[start] & 0xff)); } else if (strlen == 2) { str = TypeUtils.toString( (char) (bytes[start] & 0xff), (char) (bytes[start + 1] & 0xff) ); } else if (STRING_CREATOR_JDK8 != null) { char[] chars = new char[strlen]; for (int i = 0; i < strlen; ++i) { chars[i] = (char) bytes[start + i]; }  str = STRING_CREATOR_JDK8.apply(chars, Boolean.TRUE); } else if (STRING_CREATOR_JDK11 != null) { byte[] buf = Arrays.copyOfRange(bytes, start, offset); str = STRING_CREATOR_JDK11.apply(buf, LATIN1); } else if (ANDROID) { str = getLatin1String(start, offset - start); } else { str = new String(bytes, start, offset - start, ISO_8859_1); } } else { str = new String(bytes, start, offset - start, UTF_8); }  if ((context.features & Feature.TrimString.mask) != 0) { str = str.trim(); } // empty string to null if (str.isEmpty() && (context.features & Feature.EmptyStringAsNull.mask) != 0) { str = null; }  int ch = ++offset == end ? EOI : bytes[offset++]; while (ch <= ' ' && (1L << ch & SPACE) != 0) { ch = offset == end ? EOI : bytes[offset++]; }  if (comma = ch == ',') { ch = offset == end ? EOI : bytes[offset++]; while (ch <= ' ' && (1L << ch & SPACE) != 0) { ch = offset == end ? EOI : bytes[offset++]; } }  this.ch = (char) ch; this.offset = offset; return str; }  return readStringNotMatch(); }
[*] target: assertEquals(str, parsed)
[-] pred: org. junit. Assert. assertEquals ( str, parsed )
************************************
************************************
[+] input: connectTest_error() { try(MockedStatic<WorkerSingletonLock> mockedStatic = Mockito.mockStatic(WorkerSingletonLock.class); MockedStatic<Version> versionMockedStatic = Mockito.mockStatic(Version.class)){ mockedStatic.when(()->WorkerSingletonLock.addTag2WsUrl(anyString())).thenReturn("ws://test:8080/ws/agent?agentId=test&access_token=test"); versionMockedStatic.when(Version::get).thenReturn("test"); managementWebsocketHandlerTest.connect("http://test:8080/api/"); ListenableFuture<WebSocketSession> listenableFuture = (ListenableFuture<WebSocketSession>) ReflectionTestUtils.getField(managementWebsocketHandlerTest,"listenableFuture"); Assertions."<AssertPlaceHolder>"; } }
connect(String baseURL) { currentWsUrl = null; try { if (StringUtils.startsWithIgnoreCase(baseURL, "http://")) { currentWsUrl = baseURL.replace("http://", URL_PREFIX); } else if (StringUtils.startsWithIgnoreCase(baseURL, "https://")) { currentWsUrl = baseURL.replace("https://", URL_PREFIX_FOR_SSL); } else { throw new RuntimeException("Connect web socket failed, invalid base url: " + baseURL); } currentWsUrl = currentWsUrl.replace("/api/", URL_SUFFIX + DESTINATION + "?agentId={agentId}&access_token={access_token}");   WebSocketClient client = new StandardWebSocketClient();  currentWsUrl = UriComponentsBuilder.fromUriString(currentWsUrl) .buildAndExpand(agentId, configCenter.getConfig(ConfigurationCenter.TOKEN)).encode().toUri().toString();  currentWsUrl = WorkerSingletonLock.addTag2WsUrl(currentWsUrl); if (CloudSignUtil.isNeedSign()) { currentWsUrl = CloudSignUtil.getQueryStr("", currentWsUrl); }  String version = Version.get(); if (org.apache.commons.lang3.StringUtils.isNotEmpty(version)) { WebSocketHttpHeaders webSocketHttpHeaders = new WebSocketHttpHeaders(); webSocketHttpHeaders.add(HttpHeaders.USER_AGENT, version); this.listenableFuture = client.doHandshake(this, webSocketHttpHeaders, URI.create(currentWsUrl)); } else { this.listenableFuture = client.doHandshake(this, UriUtils.decode(currentWsUrl, StandardCharsets.UTF_8)); }  session.setSession(listenableFuture.get()); logger.info("Connect to web socket server success, url {}", currentWsUrl); } catch (Exception e) { logger.error("Create web socket by url {} connection failed {}", currentWsUrl, e.getMessage(), e); Thread.currentThread().interrupt(); } }
[*] target: assertNotNull(listenableFuture)
[-] pred: org. junit. Assert. assertNotNull ( listenableFuture )
************************************
************************************
[+] input: validateGivenMethodWithThirdParameterThatIsBiFunctionWithWrongTypeArguments() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter()), Optional.of(OPTIONAL.with(V)), "myFunction", asList( Parameter.of(OPTIONAL.with(T), "left"), Parameter.of(OPTIONAL.with(U), "right"), Parameter.of(BI_FUNCTION.with(W, W, W), "compose") ) );  Validated<String, AccumulatorValidator.Result> expected = Validated.invalid("Expected third argument to be a java.util.function.BiFunction<? super T, ? super U, ? extends V> but was java.util.function.BiFunction<W, W, W>"); Validated<String, AccumulatorValidator.Result> toVerify = AccumulatorValidator.validate(toValidate, new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
validate(Method method, ParametersAndTypeParametersValidator parametersAndTypeParametersValidator) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages); ParametersAndTypeParametersValidator.Result parametersAndTypeParameters = verifyParametersAndTypeParameters(method, parametersAndTypeParametersValidator, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  // Assign a meaningful name to each of the (three) type parameters: TypeParameter leftInputTypeConstructorArgument = parametersAndTypeParameters.getLeftInputTypeConstructorArgument(); TypeParameter rightInputTypeConstructorArgument = parametersAndTypeParameters.getRightInputTypeConstructorArgument(); TypeParameter returnTypeConstructorArgument = parametersAndTypeParameters.getReturnTypeConstructorArgument();  // Assign a meaningful name to the left and right parameters: Type leftParameterType = parametersAndTypeParameters.getLeftParameterType(); Type rightParameterType = parametersAndTypeParameters.getRightParameterType();  String name = method.getName();  TypeConstructor accumulatedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(returnTypeConstructorArgument.getName()); TypeConstructor partiallyAccumulatedTypeConstructor = leftParameterType.asTypeConstructorWithPlaceholderFor(leftInputTypeConstructorArgument.getName()); TypeConstructor inputTypeConstructor = rightParameterType.asTypeConstructorWithPlaceholderFor(rightInputTypeConstructorArgument.getName());  if (!partiallyAccumulatedTypeConstructor.canAccept(accumulatedTypeConstructor)) { // Tweak the error message to not confuse people using the simple case where // parameter types and result type should be identical: if (Objects.equals(partiallyAccumulatedTypeConstructor, inputTypeConstructor)) { return Validated.invalid("No shared type constructor between parameters (" + generateFrom(leftParameterType) + " and " + generateFrom(rightParameterType) + ") and result (" + generateFrom(returnType) + ")"); } else { return Validated.invalid("No shared type constructor between first parameter (" + generateFrom(leftParameterType) + ") and result (" + generateFrom(returnType) + ")"); } }  verifyNoCrossReferences(method.getTypeParameters(), leftParameterType, partiallyAccumulatedTypeConstructor, "type of the first parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), rightParameterType, inputTypeConstructor, "type of the second parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), returnType, accumulatedTypeConstructor, "return type", errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  return Validated.valid( AccumulatorValidator.Result.of( name, inputTypeConstructor, partiallyAccumulatedTypeConstructor, accumulatedTypeConstructor, leftParameterType, rightParameterType, returnType ) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: bind_nonCounter_withExtraColumn() { commonSetup(false,false,false); targetColumnNames.add("extraColumn"); targetColumnTypes.add(DataTypes.TEXT); targetUpdateStatement = new TargetUpdateStatement(propertyHelper, targetSession);  BoundStatement result = targetUpdateStatement.bind(originRow, targetRow, null,null,null,null); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size()-1)).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { // We reference the originRow and convert it to the target type. // We need the targetRow if (null == originRow) throw new RuntimeException("originRow is null");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue);  BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  Object originValue, targetValue; Object bindValueTarget = null; for (int targetIndex : columnIndexesToBind) { int originIndex = cqlTable.getCorrespondingIndex(targetIndex);  try { if (usingCounter && counterIndexes.contains(targetIndex)) { originValue = cqlTable.getOtherCqlTable().getData(originIndex, originRow); if (null == originValue) { currentBindIndex++; continue; } targetValue = (null == targetRow ? 0L : cqlTable.getData(targetIndex, targetRow)); bindValueTarget = ((Long) originValue - (null == targetValue ? 0L : (Long) targetValue)); } else if (targetIndex== explodeMapKeyIndex) { bindValueTarget = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValueTarget = explodeMapValue; } else { if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValueTarget = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValueTarget, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValueTarget + " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex) + "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex); throw e; } }  PKFactory pkFactory = session.getPKFactory(); EnhancedPK pk = pkFactory.getTargetPK(originRow); boundStatement = pkFactory.bindWhereClause(PKFactory.Side.TARGET, pk, boundStatement, currentBindIndex);  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: 커플_TOP30_조회() { // given var couples = new ArrayList<Character>(); var responses = new ArrayList<CharacterResponse.CharacterDetailResponse>(); for(int i = 0; i < 30; i++) { var couple = Character.builder() .name("디프만 1번 출구") .type(CharacterType.COUPLE) .webtoonId(1L) .build(); couples.add(couple); responses.add(new CharacterResponse.CharacterDetailResponse( couple, "테스트1.png,테스트2.png", "테스트", false )); }  var webtoon = Webtoon.builder() .title("테스트") .content("테스트") .webtoonUrl("http://테스트") .thumbnail("테스트.png") .platform(Platform.KAKAO) .build();  var mockCharacterImage = CharacterImage.builder() .characterId(1L) .type(CharacterImageType.COUPLE) .imageUrl("테스트1.png,테스트2.png") .build();  AuthInfo mockInfo = new AuthInfo(USER_ID, List.of(Role.USER));  Mockito.when(characterService.getCharactersByTopUpper(any())) .thenReturn(couples);  Mockito.when(webtoonService.findById(anyLong())) .thenReturn(webtoon);  Mockito.when(characterImageService.findByCharacterIdAndType(any(), any())) .thenReturn(mockCharacterImage);  Mockito.when(characterHistoryService.isUserJoin(any(), any())) .thenReturn(false);  var expected = new CharacterResponse(responses); // when var actual = characterFacade.getTopUpper("COUPLE",mockInfo); // then "<AssertPlaceHolder>"; }
getTopUpper(String type, AuthInfo info) { var responses = characterService.getCharactersByTopUpper(CharacterType.valueOf(type)) .stream() .map(character -> { var webtoon = webtoonService.findById(character.getWebtoonId()); var characterImage = characterImageService.findByCharacterIdAndType( character.getId(), CharacterImageType.valueOf(type) );  return new CharacterResponse.CharacterDetailResponse( character, characterImage.getImageUrl(), webtoon.getTitle(), characterHistoryService.isUserJoin(character.getId(), info) ); }).toList();  return new CharacterResponse(responses); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testLocalNode() { DiscoveryExtensionNode expectedLocalNode = extensionsRunner.getExtensionNode(); DiscoveryExtensionNode localNode = sdkClusterService.localNode(); "<AssertPlaceHolder>"; }
localNode() { return extensionsRunner.getExtensionNode(); }
[*] target: assertEquals(expectedLocalNode, localNode)
[-] pred: org. junit. Assert. assertEquals ( expectedLocalNode, localNode )
************************************
************************************
[+] input: givenAbstractMethodWithReturnType() { List<String> toVerify = method() .withModifiers(PUBLIC, ABSTRACT) .withTypeParameters(T.extending(OBJECT), U.asTypeParameter()) .withReturnType(OPTIONAL.with(U)) .withName("map") .withParameter(OPTIONAL.with(T), "optional") .withParameter(FUNCTION.with(T, U), "fn") .lines();  List<String> expected = singletonList( "public abstract <T, U> java.util.Optional<U> map(java.util.Optional<T> optional, java.util.function.Function<T, U> fn);" );  "<AssertPlaceHolder>"; }
lines() { List<String> components = new ArrayList<>(); if (!modifiersGenerator.isEmpty()) { components.add(modifiersGenerator.generate()); } if (!typeParametersGenerator.isEmpty()) { components.add(typeParametersGenerator.generate()); } components.add(optionalReturnType.map(TypeGenerator::generateFrom).orElse(VOID)); components.add(name + parametersGenerator.generate()); String methodDeclaration = components.stream().collect(joining(SPACE));  return optionalBodyGenerator .map(bodyGenerator -> { List<String> result = new ArrayList<>(); result.add(methodDeclaration + SPACE + OPEN_BRACE); result.addAll(bodyGenerator.indent().lines()); result.add(CLOSE_BRACE); return result; }) .orElse(asList(methodDeclaration + SEMICOLON)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testSerializeWithHeaders() {  CollectRep.MetricsData metricsData = CollectRep.MetricsData.newBuilder() .setMetrics("someValue") .setApp("linux") .build(); byte[] expectedBytes = metricsData.toByteArray(); byte[] bytes = serializer.serialize("topic", headers, metricsData);  "<AssertPlaceHolder>"; }
serialize(String topic, Headers headers, CollectRep.MetricsData data) { return Serializer.super.serialize(topic, headers, data); }
[*] target: assertArrayEquals(expectedBytes, bytes)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedBytes, bytes )
************************************
************************************
[+] input: givenManyModifiers() { String toVerify = toTest() .withModifiers(PUBLIC, STATIC, ABSTRACT) .withModifiers(PRIVATE, DEFAULT) .getModifiersGenerator() .generate();  String expected = "public private abstract default static";  "<AssertPlaceHolder>"; }
generate() { return modifiers .stream() .sorted(comparing(Modifier::ordinal)) .map(Modifier::toString) .collect(joining(SPACE)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: givenNestedClass() { ContainingClass containingClass = ContainingClass.of( ContainingClass.of( ContainingClass.of( ContainingPackage.of(PackageName.of("nl.wernerdegroot")), modifiers(PUBLIC), ClassName.of("OuterClass"), asList(A.asTypeParameter()) ), modifiers(PRIVATE, STATIC), ClassName.of("StaticInnerClass"), asList(B.asTypeParameter(), C.extending(SERIALIZABLE)) ), modifiers(), ClassName.of("InnerClass"), emptyList() );  String expected = "nl.wernerdegroot.OuterClass<A>.StaticInnerClass<B, C extends java.io.Serializable>.InnerClass"; String toVerify = ContainingClassGenerator.generateFrom(containingClass);  "<AssertPlaceHolder>"; }
generateFrom(ContainingClass containingClass) { return new ContainingClassGenerator(containingClass).generate(); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testStartInstallService_ClusterServiceCommandHostCommandServiceReturnsNoItems() { // Setup final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  // Configure ClusterServiceCommandService.listByIds(...). final ClusterServiceCommandEntity clusterServiceCommandEntity = new ClusterServiceCommandEntity(); clusterServiceCommandEntity.setCommandId("commandId"); clusterServiceCommandEntity.setCreateBy("createBy"); clusterServiceCommandEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceCommandEntity.setCommandName("commandName"); clusterServiceCommandEntity.setCommandState(CommandState.WAIT); clusterServiceCommandEntity.setCommandStateCode(0); clusterServiceCommandEntity.setCommandProgress(0); clusterServiceCommandEntity.setClusterId(0); clusterServiceCommandEntity.setServiceName("parentName"); clusterServiceCommandEntity.setCommandType(0); clusterServiceCommandEntity.setDurationTime("durationTime"); clusterServiceCommandEntity.setEndTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceCommandEntity.setServiceInstanceId(0); final Collection<ClusterServiceCommandEntity> clusterServiceCommandEntities = Arrays.asList( clusterServiceCommandEntity); when(mockCommandService.listByIds(Arrays.asList("value"))).thenReturn(clusterServiceCommandEntities);  // Configure ClusterInfoService.getById(...). final ClusterInfoEntity clusterInfoEntity = new ClusterInfoEntity(); clusterInfoEntity.setId(0); clusterInfoEntity.setCreateBy("createBy"); clusterInfoEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterInfoEntity.setClusterName("clusterName"); clusterInfoEntity.setClusterCode("clusterCode"); clusterInfoEntity.setClusterFrame("clusterFrame"); clusterInfoEntity.setFrameVersion("frameVersion"); clusterInfoEntity.setClusterState(ClusterState.RUNNING); clusterInfoEntity.setFrameId(0); final UserInfoEntity userInfoEntity = new UserInfoEntity(); userInfoEntity.setId(0); userInfoEntity.setUsername("username"); userInfoEntity.setPassword("password"); userInfoEntity.setEmail("email"); userInfoEntity.setPhone("phone"); clusterInfoEntity.setClusterManagerList(Arrays.asList(userInfoEntity)); when(mockClusterInfoService.getById(0)).thenReturn(clusterInfoEntity);  when(mockHostCommandService.getHostCommandListByCommandId("commandId")).thenReturn(Collections.emptyList());  // Run the test final Result result = serviceInstallServiceImplUnderTest.startInstallService(0, Arrays.asList("value"));  // Verify the results "<AssertPlaceHolder>"; }
startInstallService(Integer clusterId, List<String> commandIds) { Collection<ClusterServiceCommandEntity> commands = commandService.listByIds(commandIds); ClusterInfoEntity clusterInfo = clusterInfoService.getById(clusterId); DAG<String, ServiceNode, ServiceNodeEdge> dag = new DAG<>(); for (ClusterServiceCommandEntity command : commands) { List<ClusterServiceCommandHostCommandEntity> commandHostList = hostCommandService.getHostCommandListByCommandId(command.getCommandId()); List<ServiceRoleInfo> masterRoles = new ArrayList<>(); List<ServiceRoleInfo> elseRoles = new ArrayList<>(); ServiceNode serviceNode = new ServiceNode(); String serviceKey = clusterInfo.getClusterFrame() + Constants.UNDERLINE + command.getServiceName(); ServiceInfo serviceInfo = ServiceInfoMap.get(serviceKey); for (ClusterServiceCommandHostCommandEntity hostCommand : commandHostList) { String key = clusterInfo.getClusterFrame() + Constants.UNDERLINE + command.getServiceName() + Constants.UNDERLINE + hostCommand.getServiceRoleName(); ServiceRoleInfo serviceRoleInfo = ServiceRoleMap.get(key); serviceRoleInfo.setHostname(hostCommand.getHostname()); serviceRoleInfo.setHostCommandId(hostCommand.getHostCommandId()); serviceRoleInfo.setClusterId(clusterId); serviceRoleInfo.setParentName(command.getServiceName()); if (Constants.MASTER.equals(serviceRoleInfo.getRoleType())) { masterRoles.add(serviceRoleInfo); } else { elseRoles.add(serviceRoleInfo); } } serviceNode.setMasterRoles(masterRoles); serviceNode.setElseRoles(elseRoles); dag.addNode(command.getServiceName(), serviceNode); if (serviceInfo.getDependencies().size() > 0) { for (String dependency : serviceInfo.getDependencies()) { dag.addEdge(dependency, command.getServiceName()); } } } return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: format_ShouldFormatInstantValueAsText() { String valueAsString = "1681333035000"; Instant value = Instant.ofEpochMilli(Long.parseLong(valueAsString)); String result = codec.format(value); Assertions."<AssertPlaceHolder>"; }
format(Instant value) { return String.valueOf(value.toEpochMilli()); }
[*] target: assertEquals(valueAsString, result)
[-] pred: org. junit. Assert. assertEquals ( valueAsString, result )
************************************
************************************
[+] input: testEmptyList() { List<VulnerableSoftware> vsList = vulnerableSoftwareRepository.getAllVulnerableSoftware(null, null, null, null); Assertions."<AssertPlaceHolder>"; }
getAllVulnerableSoftware(final String cpePart, final String cpeVendor, final String cpeProduct, final PackageURL purl) { var queryFilterParts = new ArrayList<String>(); var queryParams = new HashMap<String, Object>();  if (cpePart != null && cpeVendor != null && cpeProduct != null) { final var cpeQueryFilterParts = new ArrayList<String>();  // The query composition below represents a partial implementation of the CPE // matching logic. It makes references to table 6-2 of the CPE name matching // specification: https://nvlpubs.nist.gov/nistpubs/Legacy/IR/nistir7696.pdf // // In CPE matching terms, the parameters of this method represent the target, // and the `VulnerableSoftware`s in the database represent the source. // // While the source *can* contain wildcards ("*", "?"), there is currently (Oct. 2023) // no occurrence of part, vendor, or product with wildcards in the NVD database. // Evaluating wildcards in the source can only be done in-memory. If we wanted to do that, // we'd have to fetch *all* records, which is not practical.  if (!"*".equals(cpePart) && !"-".equals(cpePart)) { // | No. | Source A-V      | Target A-V | Relation             | // | :-- | :-------------- | :--------- | :------------------- | // | 3   | ANY             | i          | SUPERSET             | // | 7   | NA              | i          | DISJOINT             | // | 9   | i               | i          | EQUAL                | // | 10  | i               | k          | DISJOINT             | // | 14  | m1 + wild cards | m2         | SUPERSET or DISJOINT | // TODO: Filter should use equalsIgnoreCase as CPE matching is case-insensitive. //   Can't currently do this as it would require an index on UPPER("PART"), //   which we cannot add through JDO annotations. cpeQueryFilterParts.add("(part = '*' or part = :part)"); queryParams.put("part", cpePart);  // NOTE: Target *could* include wildcard, but the relation // for those cases is undefined: // // | No. | Source A-V      | Target A-V      | Relation   | // | :-- | :-------------- | :-------------- | :--------- | // | 4   | ANY             | m + wild cards  | undefined  | // | 8   | NA              | m + wild cards  | undefined  | // | 11  | i               | m + wild cards  | undefined  | // | 17  | m1 + wild cards | m2 + wild cards | undefined  | } else if ("-".equals(cpePart)) { // | No. | Source A-V     | Target A-V | Relation | // | :-- | :------------- | :--------- | :------- | // | 2   | ANY            | NA         | SUPERSET | // | 6   | NA             | NA         | EQUAL    | // | 12  | i              | NA         | DISJOINT | // | 16  | m + wild cards | NA         | DISJOINT | cpeQueryFilterParts.add("(part = '*' or part = '-')"); } else { // | No. | Source A-V     | Target A-V | Relation | // | :-- | :------------- | :--------- | :------- | // | 1   | ANY            | ANY        | EQUAL    | // | 5   | NA             | ANY        | SUBSET   | // | 13  | i              | ANY        | SUBSET   | // | 15  | m + wild cards | ANY        | SUBSET   | cpeQueryFilterParts.add("part is not null"); }  if (!"*".equals(cpeVendor) && !"-".equals(cpeVendor)) { // TODO: Filter should use equalsIgnoreCase as CPE matching is case-insensitive. //   Can't currently do this as it would require an index on UPPER("VENDOR"), //   which we cannot add through JDO annotations. cpeQueryFilterParts.add("(vendor = '*' or vendor = :vendor)"); queryParams.put("vendor", cpeVendor); } else if ("-".equals(cpeVendor)) { cpeQueryFilterParts.add("(vendor = '*' or vendor = '-')"); } else { cpeQueryFilterParts.add("vendor is not null"); }  if (!"*".equals(cpeProduct) && !"-".equals(cpeProduct)) { // TODO: Filter should use equalsIgnoreCase as CPE matching is case-insensitive. //   Can't currently do this as it would require an index on UPPER("PRODUCT"), //   which we cannot add through JDO annotations. cpeQueryFilterParts.add("(product = '*' or product = :product)"); queryParams.put("product", cpeProduct); } else if ("-".equals(cpeProduct)) { cpeQueryFilterParts.add("(product = '*' or product = '-')"); } else { cpeQueryFilterParts.add("product is not null"); }  queryFilterParts.add("(%s)".formatted(String.join(" and ", cpeQueryFilterParts))); }  if (purl != null) { final var purlFilterParts = new ArrayList<String>();  if (purl.getType() != null) { purlFilterParts.add("purlType = :purlType"); queryParams.put("purlType", purl.getType()); } else { purlFilterParts.add("purlType is null"); }  if (purl.getNamespace() != null) { purlFilterParts.add("purlNamespace = :purlNamespace"); queryParams.put("purlNamespace", purl.getNamespace()); } else { purlFilterParts.add("purlNamespace is null"); }  if (purl.getName() != null) { purlFilterParts.add("purlName = :purlName"); queryParams.put("purlName", purl.getName()); } else { purlFilterParts.add("purlName is null"); }  queryFilterParts.add("(%s)".formatted(String.join(" and ", purlFilterParts))); }  if (queryFilterParts.isEmpty()) { return emptyList(); }  return find(String.join(" or ", queryFilterParts), queryParams) .withHint(HINT_READ_ONLY, true) .list(); }
[*] target: assertEquals(0, vsList.size())
[-] pred: org. junit. Assert. assertEquals ( 0, vsList. size ( ) )
************************************
************************************
[+] input: testListServers() { List<Server> servers = serverDAO.listServers(ServerStatusEnum.OK.getStatus()); Assertions."<AssertPlaceHolder>"; }
listServers(Integer status);
[*] target: assertNotNull(servers)
[-] pred: org. junit. Assert. assertNotNull ( servers )
************************************
************************************
[+] input: noneBelow() { set.set(1); final int ret = set.previousClearBit(1);  "<AssertPlaceHolder>"; }
previousClearBit(int fromIndex);  // ------------------------------------------------------------------------ // bulk operations // ------------------------------------------------------------------------  /** * Returns {@code true}
[*] target: assertEquals(0, ret)
[-] pred: org. junit. Assert. assertEquals ( 0, ret )
************************************
************************************
[+] input: testQueryWorkerByProcessIdWithId() { String processId = "111"; WorkerDto workerDto = mock(WorkerDto.class); Query query = Query.query(Criteria.where("process_id").is(processId).and("worker_type").is("connector")); doReturn(workerDto).when(workerService).findOne(query); WorkerDto actual = workerService.queryWorkerByProcessId(processId); "<AssertPlaceHolder>"; }
queryWorkerByProcessId(String processId);
[*] target: assertEquals(workerDto,actual)
[-] pred: org. junit. Assert. assertEquals ( workerDto, actual )
************************************
************************************
[+] input: testPublished() { Date date = new Date(); Vulnerability vuln = new Vulnerability(); vuln.setPublished(date); Assertions."<AssertPlaceHolder>"; }
getPublished() { return published; }
[*] target: assertEquals(date, vuln.getPublished())
[-] pred: org. junit. Assert. assertEquals ( date, vuln. getPublished() )
************************************
************************************
[+] input: decode_ShouldDecodeByteBufferToValueAndReturnAsString() { String valueAsString = "1681333035000"; Instant value = Instant.ofEpochMilli(Long.parseLong(valueAsString)); ByteBuffer byteBuffer = TypeCodecs.TIMESTAMP.encode(value, CqlConversion.PROTOCOL_VERSION);  String result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { Instant instantValue = TypeCodecs.TIMESTAMP.decode(bytes, protocolVersion); return instantValue == null ? null : String.valueOf(instantValue.toEpochMilli()); }
[*] target: assertEquals(valueAsString, result)
[-] pred: org. junit. Assert. assertEquals ( valueAsString, result )
************************************
************************************
[+] input: loadSparkConf_withRequired() { setValidSparkConf(); helper.initializeSparkConf(validSparkConf); "<AssertPlaceHolder>"; }
isSparkConfFullyLoaded() { return sparkConfFullyLoaded; }
[*] target: assertTrue(helper.isSparkConfFullyLoaded())
[-] pred: org. junit. Assert. assertTrue ( helper. isSparkConfFullyLoaded() )
************************************
************************************
[+] input: MalformedURLException { ClassLoader classLoader = ClassLoader.getSystemClassLoader(); URL resourceURL = ClassLoaderUtils.getClassResource(classLoader, Nonnull.class); String expectedPath = "javax/annotation/Nonnull.class"; String relativePath = resolveArchiveEntryPath(resourceURL); "<AssertPlaceHolder>"; }
resolveArchiveEntryPath(URL archiveFileURL) throws NullPointerException { // NPE check return doResolveArchiveEntryPath(archiveFileURL.getPath()); }
[*] target: assertEquals(expectedPath, relativePath)
[-] pred: org. junit. Assert. assertEquals ( expectedPath, relativePath )
************************************
************************************
[+] input: withoutTypeParameters() { ContainingClass expected = new ContainingClass( containingPackage, modifiers(PUBLIC), new ClassName("Erudite"), emptyList() );  ContainingClass toVerify = ContainingClass.of( packageName, new ClassName("Erudite") );  "<AssertPlaceHolder>"; }
of(PackageName packageName, ClassName className) { return ContainingClass.of(packageName, className, emptyList()); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: Exception { when(mockClient.headBucket(anyConsumer())) .thenReturn(CompletableFuture.completedFuture( HeadBucketResponse.builder().bucketRegion("us-west-2").build())); final var s3Client = provider.generateClient("test-bucket", mockClient); final var s3Client2 = provider.generateClient("test-bucket", mockClient); "<AssertPlaceHolder>"; }
generateClient(String bucketName, S3AsyncClient locationClient) throws ExecutionException, InterruptedException { logger.debug("generating client for bucket: '{}'", bucketName);  String bucketLocation = null; if (configuration.endpointUri() == null) { // we try to locate a bucket only if no endpoint is provided, which means we are dealing with AWS S3 buckets bucketLocation = getBucketLocation(bucketName, locationClient);  if (bucketLocation == null) { // if here, no S3 nor other client has been created yet, and we do not // have a location; we'll let it figure out from the profile region logger.warn("Unable to determine the region of bucket: '{}'. Generating a client for the profile region.", bucketName); } }  var client = bucketClientCache.getIfPresent(bucketName); if (client != null && !client.isClosed()) { return client; } else { if (client != null && client.isClosed()) { bucketClientCache.invalidate(bucketName);    // remove the closed client from the cache } String r = Optional.ofNullable(bucketLocation).orElse(configuration.getRegion()); return bucketClientCache.get(bucketName, b -> new CacheableS3Client(configureCrtClientForRegion(r))); } }
[*] target: assertSame(s3Client, s3Client2)
[-] pred: org. junit. Assert. assertSame ( s3Client, s3Client2 )
************************************
************************************
[+] input: testSelectCount() { User user = new User(); user.setAge(18); long count = commonDao.selectCount(user); Assertions."<AssertPlaceHolder>"; }
selectCount(T params);  /** * 查询列表 * * @param params param * @return result */ @SelectProvider(type = SqlBuilder.class, method = "selectList") <T> List<Map<?,?>> selectList(T params);   /** * 自定义查询列表结果 * * @param params param * @return result */ @Select(" ${selfSQL}
[*] target: assertEquals(2, count)
[-] pred: org. junit. Assert. assertEquals ( 2, count )
************************************
************************************
[+] input: givenConcreteTypeWithTypeParameters() { Type type = FUNCTION.with( STRING.contravariant(), OBJECT.covariant() ); String toVerify = type(type).generate(); String expected = "java.util.function.Function<? super java.lang.String, ? extends java.lang.Object>"; "<AssertPlaceHolder>"; }
generate() { return type.match( generic -> generic.getName().raw(),  concrete -> { List<TypeArgument> typeArguments = concrete.getTypeArguments(); if (typeArguments.isEmpty()) { return concrete.getFullyQualifiedName().raw(); } else { return concrete.getFullyQualifiedName().raw() + OPEN_ANGULAR_BRACKET + typeArguments.stream().map(TypeArgumentGenerator::generateFrom).collect(joining(SEPARATOR)) + CLOSE_ANGULAR_BRACKET; } },  array -> type(array.getType()).generate() + OPEN_SQUARE_BRACKET + CLOSE_SQUARE_BRACKET ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: castToJavaBean() { Map map = new HashMap<>(); map.put("className", Bean.class.getName()); map.put("methodName", "m"); StackTraceElement element = TypeUtils.castToJavaBean(map, StackTraceElement.class, ParserConfig.global); "<AssertPlaceHolder>"; }
castToJavaBean(Map<String, Object> map, Class<T> clazz, ParserConfig config) { try { if (clazz == StackTraceElement.class) { String declaringClass = (String) map.get("className"); String methodName = (String) map.get("methodName"); String fileName = (String) map.get("fileName"); int lineNumber; { Number value = (Number) map.get("lineNumber"); if (value == null) { lineNumber = 0; } else if (value instanceof BigDecimal) { lineNumber = ((BigDecimal) value).intValueExact(); } else { lineNumber = value.intValue(); } } return (T) new StackTraceElement(declaringClass, methodName, fileName, lineNumber); }  { Object iClassObject = map.get(JSON.DEFAULT_TYPE_KEY); if (iClassObject instanceof String) { String className = (String) iClassObject; Class<?> loadClazz; if (config == null) { config = ParserConfig.global; } //                    loadClazz = config.checkAutoType(className, null); //                    if(loadClazz == null){ //                        throw new ClassNotFoundException(className + " not found"); //                    } //                    if(!loadClazz.equals(clazz)){ //                        return (T) castToJavaBean(map, loadClazz, config); //                    } throw new JSONException("TODO"); // TODO : castToJavaBean } }  if (clazz.isInterface()) { JSONObject object; if (map instanceof JSONObject) { object = (JSONObject) map; } else { object = new JSONObject(map); } if (config == null) { config = ParserConfig.getGlobalInstance(); } //                ObjectDeserializer deserializer = config.getDeserializers().get(clazz); //                if(deserializer != null){ //                    String json = JSON.toJSONString(object); //                    return (T) JSON.parseObject(json, clazz); //                } //                return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), //                        new Class<?>[]{clazz}, object); throw new JSONException("TODO"); // TODO : castToJavaBean }  if (clazz == Locale.class) { Object arg0 = map.get("language"); Object arg1 = map.get("country"); if (arg0 instanceof String) { String language = (String) arg0; if (arg1 instanceof String) { String country = (String) arg1; return (T) new Locale(language, country); } else if (arg1 == null) { return (T) new Locale(language); } } }  if (clazz == String.class && map instanceof JSONObject) { return (T) map.toString(); }  if (clazz == LinkedHashMap.class && map instanceof JSONObject) { JSONObject jsonObject = (JSONObject) map; Map innerMap = jsonObject.getInnerMap(); if (innerMap instanceof LinkedHashMap) { return (T) innerMap; } else { LinkedHashMap linkedHashMap = new LinkedHashMap(); linkedHashMap.putAll(innerMap); } }  ObjectReader objectReader = JSONFactory.getDefaultObjectReaderProvider().getObjectReader(clazz); return (T) objectReader.createInstance(map, 0L); } catch (Exception e) { throw new JSONException(e.getMessage(), e); } }
[*] target: assertNotNull(element)
[-] pred: org. junit. Assert. assertNotNull ( element )
************************************
************************************
[+] input: testDeleteUserGroup() { // Setup final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  when(mockUserGroupService.countGroupUserNum(0)).thenReturn(0);  // Configure ClusterHostService.getHostListByClusterId(...). final ClusterHostEntity clusterHostEntity = new ClusterHostEntity(); clusterHostEntity.setId(0); clusterHostEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterHostEntity.setHostname("hostname"); clusterHostEntity.setIp("ip"); clusterHostEntity.setRack("rack"); clusterHostEntity.setCoreNum(0); clusterHostEntity.setTotalMem(0); clusterHostEntity.setTotalDisk(0); clusterHostEntity.setUsedMem(0); clusterHostEntity.setUsedDisk(0); clusterHostEntity.setAverageLoad("averageLoad"); clusterHostEntity.setCheckTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterHostEntity.setClusterId(0); clusterHostEntity.setHostState(0); clusterHostEntity.setManaged(MANAGED.YES); final List<ClusterHostEntity> clusterHostEntities = Arrays.asList(clusterHostEntity); when(mockHostService.getHostListByClusterId(0)).thenReturn(clusterHostEntities);  // Run the test final Result result = clusterGroupServiceImplUnderTest.deleteUserGroup(0);  // Verify the results "<AssertPlaceHolder>"; }
deleteUserGroup(Integer id) { ClusterGroup clusterGroup = this.getById(id); Integer num = userGroupService.countGroupUserNum(id); if (num > 0) { return Result.error(Status.USER_GROUP_TIPS_ONE.getMsg()); } this.removeById(id); List<ClusterHostDO> hostList = hostService.getHostListByClusterId(clusterGroup.getClusterId()); for (ClusterHostDO clusterHost : hostList) { ActorRef unixGroupActor = ActorUtils.getRemoteActor(clusterHost.getHostname(), "unixGroupActor"); DelUnixGroupCommand delUnixGroupCommand = new DelUnixGroupCommand(); delUnixGroupCommand.setGroupName(clusterGroup.getGroupName()); Timeout timeout = new Timeout(Duration.create(180, TimeUnit.SECONDS)); Future<Object> execFuture = Patterns.ask(unixGroupActor, delUnixGroupCommand, timeout); ExecResult execResult = null; try { execResult = (ExecResult) Await.result(execFuture, timeout.duration()); if (execResult.getExecResult()) { logger.info("del unix group success at {}", clusterHost.getHostname()); } else { logger.info("del unix group failed at {}", clusterHost.getHostname()); } } catch (Exception e) { logger.info("del unix group failed at {}", clusterHost.getHostname()); } } return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: asTypeConstructor() { ArrayTypeConstructor expected = new ArrayTypeConstructor(STRING_TYPE_CONSTRUCTOR); ArrayTypeConstructor toVerify = new ArrayType(STRING_TYPE).asTypeConstructor();  "<AssertPlaceHolder>"; }
asTypeConstructor() { return TypeConstructor.array(type.asTypeConstructor()); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: givenValidClassAndMethodsContainingValidAccumulatorAndValidFinalizer() { ContainingClass containingClass = getValidContainingClass();  Method accumulator = getAccumulator( withAnnotations(ACCUMULATOR_FULLY_QUALIFIED_NAME), withModifiers(PUBLIC), withInputTypeConstructor(LIST.with(placeholder().covariant())), withPartiallyAccumulatedTypeConstructor(ARRAY_LIST.with(placeholder().covariant())), withAccumulatedTypeConstructor(ARRAY_LIST.with(placeholder().invariant())) );  Method finalizer = getFinalizer( withAnnotations(FINALIZER_FULLY_QUALIFIED_NAME), withModifiers(PUBLIC), withToFinalizeTypeConstructor(ARRAY_LIST.with(placeholder().covariant())), withFinalizedTypeConstructor(LIST.with(placeholder().invariant())) );  Validated<Log, Validator.Result> expected = Validated.valid( Validator.Result.of( containingClass.getTypeParameters(), Optional.empty(), Accumulator.of( accumulator.getName(), LIST.with(placeholder().covariant()), ARRAY_LIST.with(placeholder().covariant()), ARRAY_LIST.with(placeholder().invariant()) ), Optional.of(Finalizer.of(finalizer.getName(), ARRAY_LIST.with(placeholder().covariant()), LIST.with(placeholder().invariant()))) ) );  Validated<Log, Validator.Result> toVerify = Validator.validate(containingClass, asList(accumulator, finalizer), new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
of(List<TypeParameter> classTypeParameters, Optional<Initializer> optionalInitializer, Accumulator accumulator, Optional<Finalizer> optionalFinalizer) { return new Result(classTypeParameters, optionalInitializer, accumulator, optionalFinalizer); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: separateBuildingMethods() { byte[] actualData = SerialBuilder.startSerializableObject() .descriptorHierarchy(SerialBuilderTest::writeDescriptorHierarchy) .beginSlots() .slot(SerialBuilderTest::writeSlot) .endSlots() .endObject();  byte[] expectedData = serialize(new ClassWithNested(new ClassWithNested.NestedSerializable(3), new ClassWithNested.NestedExternalizable(), new int[] {1, 2})); "<AssertPlaceHolder>"; }
startSerializableObject() { return startSerializableObject(new Handle()); }
[*] target: assertArrayEquals(expectedData, actualData)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedData, actualData )
************************************
************************************
[+] input: validateGivenMethodThatDoesNotReturnAnything() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter()), Optional.empty(), "myFunction", asList(Parameter.of(ARRAY_LIST.with(T), "value")) );  Validated<String, InitializerOrFinalizerValidator.Result> expected = Validated.invalid("Method needs to return something"); Validated<String, InitializerOrFinalizerValidator.Result> toVerify = InitializerOrFinalizerValidator.validate(toValidate);  "<AssertPlaceHolder>"; }
validate(Method method) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyParameterCount(method.getParameters(), 1, errorMessages); verifyTypeParameterCount(method.getTypeParameters(), 1, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  TypeParameter typeParameter = method.getTypeParameters().get(0);  String name = method.getName();  Parameter parameter = method.getParameters().get(0);  // Extract the type constructor from the single parameter: TypeConstructor toInitializeOrFinalizeTypeConstructor = parameter.getType().asTypeConstructorWithPlaceholderFor(typeParameter.getName());  // Extract the type constructor from the return type: TypeConstructor initializedOrFinalizedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(typeParameter.getName());  return Validated.valid(Result.of(name, parameter.getType(), toInitializeOrFinalizeTypeConstructor, returnType, initializedOrFinalizedTypeConstructor)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testTransformFromTapValueNullTapEvent() { TapdataEvent tapdataEvent = new TapdataEvent(); HazelcastBaseNode.TapValueTransform actual = hazelcastBaseNode.transformFromTapValue(tapdataEvent); "<AssertPlaceHolder>"; }
transformFromTapValue(TapdataEvent tapdataEvent) { if (null == tapdataEvent) return null; if (null == tapdataEvent.getTapEvent()) return null; TapEvent tapEvent = tapdataEvent.getTapEvent(); TapValueTransform tapValueTransform = TapValueTransform.create(); Map<String, Object> before = TapEventUtil.getBefore(tapEvent); if (MapUtils.isNotEmpty(before)) { tapValueTransform.before(codecsFilterManager.transformFromTapValueMap(before)); } Map<String, Object> after = TapEventUtil.getAfter(tapEvent); if (MapUtils.isNotEmpty(after)) { tapValueTransform.after(codecsFilterManager.transformFromTapValueMap(after)); } return tapValueTransform; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: givenMultipleLines() { List<String> toVerify = toTest() .withBody("Line 1", "Line 2") .withBody(asList("Line 3", "Line 4")) .withBody("Line 5") .getBodyGenerator() .lines();  List<String> expected = asList( "Line 1", "Line 2", "Line 3", "Line 4", "Line 5" );  "<AssertPlaceHolder>"; }
lines() { return lines; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: bind_withTTLAndWritetime() { when(writetimeTTLFeature.isEnabled()).thenReturn(true); when(writetimeTTLFeature.hasTTLColumns()).thenReturn(true); when(writetimeTTLFeature.hasWritetimeColumns()).thenReturn(true); targetInsertStatement = new TargetInsertStatement(propertyHelper, targetSession);  BoundStatement result = targetInsertStatement.bind(originRow, targetRow, 3600,10000L,null,null); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size()+2)).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { if (null == originRow) throw new RuntimeException("Origin row is null"); if (usingCounter) throw new RuntimeException("Cannot INSERT onto a counter table, use UPDATE instead");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue); BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; Object bindValue = null;  if (logDebug) logger.debug("bind using conversions: {}",cqlTable.getOtherCqlTable().getConversions()); for (int targetIndex = 0; targetIndex < targetColumnTypes.size(); targetIndex++) { if (!bindColumnIndexes.contains(targetIndex)) { // this happens with constant columns, for example continue; } try { if (targetIndex== explodeMapKeyIndex) { bindValue = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValue = explodeMapValue; } else { int originIndex = cqlTable.getCorrespondingIndex(targetIndex); if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValue = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValue, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValue + " of class:" +(null==bindValue?"unknown":bindValue.getClass().getName())+ " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex)+ "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex + " and bind index: "+ (currentBindIndex-1) + " of statement:" + this.getCQL()); throw e; } }  if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: getAll() { final List<Stock> stocks = stockService.getAll(); "<AssertPlaceHolder>"; }
getAll() { return stockRepository.findAll(); }
[*] target: assertFalse(stocks.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( stocks. isEmpty ( ) )
************************************
************************************
[+] input: isLocalFileSystem_whenDefaultMethodCalled_thenReturnsFalseBecauseItIsVirtual() { FileTreeNode sut = new FileTreeNode(new HomeFilePath(new HomeFolderPath(UserDomainIdentity.DEFAULT_DATA_DOMAIN), "file.txt"), new FileContent("old"), FileTreeNodeStatus.NEW); Assertions."<AssertPlaceHolder>"; }
isLocalFileSystem() { return false; }
[*] target: assertFalse(sut.isLocalFileSystem())
[-] pred: org. junit. Assert. assertFalse ( sut. isLocalFileSystem() )
************************************
************************************
[+] input: test_isCloudLimitNotReached() { ObjectId taskId = MongoUtils.toObjectId("632454d5287a904778c40f8d"); Query query = new Query(Criteria.where("_id").is(taskId)); query.fields().include("id","agentId","agentTags"); TaskEntity mockTask = new TaskEntity(); mockTask.setCrontabExpressionFlag(false); mockTask.setId(MongoUtils.toObjectId("632454d5287a904778c40f8d")); try (MockedStatic<DataPermissionService> serviceMockedStatic = Mockito.mockStatic(DataPermissionService.class)) { serviceMockedStatic.when(DataPermissionService::isCloud).thenReturn(true); when(settingsService.isCloud()).thenReturn(true); when(taskRepository.findOne(query)).thenReturn(Optional.of(mockTask)); TaskDto mockTaskDto = new TaskDto(); BeanUtils.copyProperties(mockTask,mockTaskDto); CalculationEngineVo mockEngineVo = new CalculationEngineVo(); mockEngineVo.setTaskLimit(5); mockEngineVo.setRunningNum(4); when(workerService.calculationEngine(mockTaskDto,user,null)).thenReturn(mockEngineVo); Query mockQuery = new Query(Criteria.where("_id").is(taskId)); mockQuery.fields().include("planStartDateFlag", "crontabExpressionFlag"); when(taskRepository.findOne(mockQuery)).thenReturn(Optional.of(mockTask)); boolean result = taskService.checkCloudTaskLimit(taskId,user,true); "<AssertPlaceHolder>"; } }
checkCloudTaskLimit(ObjectId taskId,UserDetail user,boolean checkCurrentTask){ if (settingsService.isCloud()) { TaskDto task = findByTaskId(taskId,"id",AGENT_ID,"agentTags"); CalculationEngineVo calculationEngineVo = workerService.calculationEngine(task, user, null); int runningNum; if(checkCurrentTask){ runningNum  = subCronOrPlanNum(task, calculationEngineVo.getRunningNum()); }else{ runningNum = calculationEngineVo.getRunningNum(); } if (runningNum >= calculationEngineVo.getTaskLimit()) { return false; } } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: validateGivenValidMethod() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter()), Optional.of(LIST.with(T)), "myFunction", asList(Parameter.of(ARRAY_LIST.with(T), "value")) );  Validated<String, InitializerOrFinalizerValidator.Result> expected = Validated.valid(InitializerOrFinalizerValidator.Result.of("myFunction", ARRAY_LIST.with(T), ARRAY_LIST.asTypeConstructor(), LIST.with(T), LIST.asTypeConstructor())); Validated<String, InitializerOrFinalizerValidator.Result> toVerify = InitializerOrFinalizerValidator.validate(toValidate);  "<AssertPlaceHolder>"; }
validate(Method method) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyParameterCount(method.getParameters(), 1, errorMessages); verifyTypeParameterCount(method.getTypeParameters(), 1, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  TypeParameter typeParameter = method.getTypeParameters().get(0);  String name = method.getName();  Parameter parameter = method.getParameters().get(0);  // Extract the type constructor from the single parameter: TypeConstructor toInitializeOrFinalizeTypeConstructor = parameter.getType().asTypeConstructorWithPlaceholderFor(typeParameter.getName());  // Extract the type constructor from the return type: TypeConstructor initializedOrFinalizedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(typeParameter.getName());  return Validated.valid(Result.of(name, parameter.getType(), toInitializeOrFinalizeTypeConstructor, returnType, initializedOrFinalizedTypeConstructor)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: test1() { processorBaseContext.getTaskDto().setType(SyncTypeEnum.INITIAL_SYNC.getSyncType()); TapdataEvent tapdataEvent = new TapdataEvent(); tapdataEvent.addNodeId("123"); TapUpdateRecordEvent tapUpdateRecordEvent = TapUpdateRecordEvent.create().init(); tapdataEvent.setTapEvent(tapUpdateRecordEvent); when(mockHazelcastMergeNode.isSubTableFirstMode()).thenReturn(false); boolean result = mockHazelcastMergeNode.needLookup(tapdataEvent); "<AssertPlaceHolder>"; }
needLookup(TapdataEvent tapdataEvent) { if (isInitialSyncTask() && !isSubTableFirstMode()) return false; SyncStage syncStage = tapdataEvent.getSyncStage(); if (isInvalidOperation(tapdataEvent)) return false; String op = getOp(tapdataEvent); if (op.equals(OperationType.DELETE.getOp())) { return false; } String preNodeId = getPreNodeId(tapdataEvent); EnableUpdateJoinKey enableUpdateJoinKey = enableUpdateJoinKeyMap.get(preNodeId); if (op.equals(OperationType.UPDATE.getOp()) && Boolean.FALSE.equals(enableUpdateJoinKey.isEnableChildren())) { return false; } boolean existsInLookupMap = this.lookupMap.containsKey(preNodeId); if (existsInLookupMap && SyncStage.INITIAL_SYNC.equals(syncStage) && (isMainTableFirstMode() || (isSubTableFirstMode() && !isFirstMergeLevel(preNodeId)))) { return false; } return existsInLookupMap; }
[*] target: assertEquals(false, result)
[-] pred: org. junit. Assert. assertEquals ( false, result )
************************************
************************************
[+] input: testCheckWhenIsChildOfDept() { DeptTreeDataPermissionChecker checker = new DeptTreeDataPermissionChecker(deptService);  when(deptService.isChildOfTheDept(any(), any())).thenReturn(true); when(loginUser.getDeptId()).thenReturn(1L);  DataCondition dataCondition = new DataCondition(); dataCondition.setTargetDeptId(2L);  boolean check = checker.check(loginUser, dataCondition);  "<AssertPlaceHolder>"; }
check(SystemLoginUser loginUser, DataCondition condition) { if (condition == null || loginUser == null) { return false; }  if (loginUser.getDeptId() == null || condition.getTargetDeptId() == null) { return false; }  Long currentDeptId = loginUser.getDeptId(); Long targetDeptId = condition.getTargetDeptId();  boolean isContainsTargetDept = deptService.isChildOfTheDept(loginUser.getDeptId(), targetDeptId); boolean isSameDept = Objects.equals(currentDeptId, targetDeptId);  return isContainsTargetDept || isSameDept; }
[*] target: assertTrue(check)
[-] pred: org. junit. Assert. assertTrue ( check )
************************************
************************************
[+] input: arrayGivenElementTypeConstructor() { ArrayTypeConstructor expected = new ArrayTypeConstructor(STRING_TYPE_CONSTRUCTOR); ArrayTypeConstructor toVerify = TypeConstructor.array(STRING_TYPE_CONSTRUCTOR);  "<AssertPlaceHolder>"; }
array(TypeConstructor type) { return new ArrayTypeConstructor(type); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: collectingWithSingleLines() { List<String> expected = asList("1", "1"); List<String> toVerify = Stream.of(1).collect(collectingIntegers());  "<AssertPlaceHolder>"; }
of(List<String> initialLines) { return new Lines(initialLines); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testHashCode() { ConcurrentHashSet<String> set1 = new ConcurrentHashSet<>();  ConcurrentHashSet<String> set2 = new ConcurrentHashSet<>();  "<AssertPlaceHolder>"; }
hashCode() { int result = super.hashCode(); result = 31 * result + delegate.hashCode(); return result; }
[*] target: assertEquals(set1.hashCode(), set2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( set1. hashCode ( ), set2. hashCode ( ) )
************************************
************************************
[+] input: testDecryptInvalidKeyLength() { ReflectionTestUtils.setField( converter, ENCRYPTION_KEY_FIELD, RandomStringUtils.randomAlphabetic(INVALID_KEY_LENGTH)); String encryptedText = RandomStringUtils.randomAlphanumeric(10); String converted = converter.convertToEntityAttribute(encryptedText); "<AssertPlaceHolder>"; }
convertToEntityAttribute(String cipherMessage) { Cipher cipher = getCipher(); Key key = getSecretKey(); byte[] cipherMessageBytes = Base64.getDecoder().decode(cipherMessage); try { AlgorithmParameterSpec paramSpec = new GCMParameterSpec(AUTH_TAG_LENGTH, cipherMessageBytes, 0, GCM_IV_LENGTH); cipher.init(Cipher.DECRYPT_MODE, key, paramSpec); byte[] plainText = cipher.doFinal(cipherMessageBytes, GCM_IV_LENGTH, cipherMessageBytes.length - GCM_IV_LENGTH); return new String(plainText, StandardCharsets.UTF_8); } catch (InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | IllegalArgumentException | BadPaddingException e) { log.error("Failed to convert to entity attribute, reading encrypted value...", e); return cipherMessage; } }
[*] target: assertEquals(encryptedText, converted)
[-] pred: org. junit. Assert. assertEquals ( encryptedText, converted )
************************************
************************************
[+] input: test_isCloudLimitNotReached() { ObjectId taskId = MongoUtils.toObjectId("632454d5287a904778c40f8d"); Query query = new Query(Criteria.where("_id").is(taskId)); query.fields().include("id", "agentId", "agentTags"); TaskEntity mockTask = new TaskEntity(); mockTask.setCrontabExpressionFlag(false); mockTask.setId(MongoUtils.toObjectId("632454d5287a904778c40f8d")); try (MockedStatic<DataPermissionService> serviceMockedStatic = Mockito.mockStatic(DataPermissionService.class)) { serviceMockedStatic.when(DataPermissionService::isCloud).thenReturn(true); when(settingsService.isCloud()).thenReturn(true); when(taskRepository.findOne(query)).thenReturn(Optional.of(mockTask)); TaskDto mockTaskDto = new TaskDto(); BeanUtils.copyProperties(mockTask, mockTaskDto); CalculationEngineVo mockEngineVo = new CalculationEngineVo(); mockEngineVo.setTaskLimit(5); mockEngineVo.setRunningNum(4); when(workerService.calculationEngine(mockTaskDto, user, null)).thenReturn(mockEngineVo); Query mockQuery = new Query(Criteria.where("_id").is(taskId)); mockQuery.fields().include("planStartDateFlag", "crontabExpressionFlag"); when(taskRepository.findOne(mockQuery)).thenReturn(Optional.of(mockTask)); boolean result = taskService.checkCloudTaskLimit(taskId, user, true); "<AssertPlaceHolder>"; } }
checkCloudTaskLimit(ObjectId taskId, UserDetail user, boolean checkCurrentTask); public abstract void updateDelayTime(ObjectId taskId, long delayTime); public abstract void refreshSchemas(TaskDto taskDto, String nodeIds, String keys, UserDetail userDetail); public abstract void checkSourceTimeDifference(TaskDto taskDto,UserDetail userDetail);  @Data @AllArgsConstructor @NoArgsConstructor public static class Char1Group { private String _id; private long count; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: pixParticipantesPass() { PIX[] pix = BrasilAPI.pixParticipantes(); "<AssertPlaceHolder>"; }
pixParticipantes() { PIX[] obj = (PIX[]) api(PIX[].class, "pix/v1/participants", ""); return obj != null ? (PIX[]) obj.clone() : null; }
[*] target: assertNotNull(pix)
[-] pred: org. junit. Assert. assertNotNull ( pix )
************************************
************************************
[+] input: IOException { final AgentPreparer agentPreparer = new AgentPreparer(); final String output = agentPreparer.loadAgentOnFileSystem("agents/agent.jar");  Assertions."<AssertPlaceHolder>";  Files.delete(Path.of(output)); // Verify file exists and clean up at same time }
loadAgentOnFileSystem(String agentResourcePath) { return tempAgentFiles.computeIfAbsent(agentResourcePath, k -> { try { final Path tempFile = Files.createTempFile("agent", ".jar"); tempFile.toFile().deleteOnExit(); final InputStream inputStream = AgentPreparer.class.getClassLoader() .getResourceAsStream(agentResourcePath); if (inputStream == null) { throw new IOException("Failed to find input stream for agent"); } final byte[] agentBytes = inputStream.readAllBytes(); Files.write(tempFile, agentBytes); final String localPath = tempFile.toAbsolutePath().toString(); log.debug("Loaded agent into temp file: {}", localPath); return localPath; } catch (IOException e) { log.warn("Failed to load agent into file", e); throw new UncheckedIOException(e); } });  }
[*] target: assertNotNull(output)
[-] pred: org. junit. Assert. assertNotNull ( output )
************************************
************************************
[+] input: BBjException { String restoreValue = "restoreValue"; component.setRestoreValue(restoreValue); "<AssertPlaceHolder>";  verify(control).setRestore(restoreValue); }
getRestoreValue() { return restoreValue; }
[*] target: assertEquals(restoreValue, component.getRestoreValue())
[-] pred: org. junit. Assert. assertEquals ( restoreValue, component. getRestoreValue() )
************************************
************************************
[+] input: Exception {  String alertJson = "{"id":"1","content":"Test Alert"}"; Alert expectedAlert = Alert.builder().id(1L).content("Test Alert").build();  when(syncCommands.rpop(anyString())).thenReturn(alertJson); Alert actualAlert = redisCommonDataQueue.pollAlertsData(); "<AssertPlaceHolder>"; }
pollAlertsData() {  try { String alertJson = syncCommands.rpop(alertsDataQueueName); if (alertJson != null) { return JsonUtil.fromJson(alertJson, Alert.class); } } catch (Exception e) { log.error("please config common.queue.redis props correctly", e); throw new RuntimeException(e); } return null; }
[*] target: assertEquals(expectedAlert, actualAlert)
[-] pred: org. junit. Assert. assertEquals ( expectedAlert, actualAlert )
************************************
************************************
[+] input: MessagingException { doNothing().when(log).error(anyString(), any(Exception.class)); doCallRealMethod().when(mu).closeTransport(null); doNothing().when(mu).initMailConfig(); Session session = mock(Session.class); InternetAddress[] internetAddressList = new InternetAddress[0]; Address[] addresses = new Address[0]; doNothing().when(session).setDebug(true); try(MockedStatic<Session> s = mockStatic(Session.class); MockedConstruction<InternetAddress> i = mockConstruction(InternetAddress.class, (ic, c) -> {}); MockedConstruction<MimeMessage> m = mockConstruction(MimeMessage.class, (mk,c) -> { doNothing().when(mk).setFrom(any(InternetAddress.class)); doNothing().when(mk).setRecipients(Message.RecipientType.TO, internetAddressList); doNothing().when(mk).setContent(anyString(), anyString()); doNothing().when(mk).setSentDate(any(Date.class)); doAnswer(a -> { throw new MessagingException(""); }).when(mk).saveChanges(); when(mk.getAllRecipients()).thenReturn(addresses); })) { s.when(() -> Session.getDefaultInstance(any(Properties.class))).thenReturn(session); SendStatus sendStatus = mu.sendValidateCodeForResetPWD("", "", ""); Assertions."<AssertPlaceHolder>"; } }
sendValidateCodeForResetPWD(String to, String username, String validateCode) { SendStatus sendStatus = new SendStatus(SEND_STATUS_FALSE, ""); String html = readHtmlToString("resetPasswordTemplate.html"); Document doc = Jsoup.parse(html); doc.getElementById(USER_NAME).html(username); doc.getElementById("code").html(validateCode); doc.getElementById("account").html(to); doc.getElementById("validateTimes").html("5"); sendEmail(doc, sendStatus, Lists.newArrayList(to), "修改密码-验证码", "Send validate code email failed before reset password"); return sendStatus; }
[*] target: assertNotNull(sendStatus)
[-] pred: org. junit. Assert. assertNotNull ( sendStatus )
************************************
************************************
[+] input: testDeleteFileOfDirectory() { //            File file = new File("temp"); //            if (file.mkdir() && file.exists()) { //                utils.deleteFile(file, new TapLog()); //            } //            Assertions."<AssertPlaceHolder>"; //        }
deleteFile(File file, Log logger) { if (file.exists()) { try { if (file.isDirectory()) { FileUtils.deleteDirectory(file); } else { FileUtils.delete(file); } } catch (Exception e){ logger.info("file not be delete, file: {}, message: {}", file.getAbsolutePath(), e.getMessage()); } } }
[*] target: assertFalse(file.exists())
[-] pred: org. junit. Assert. assertFalse ( file. exists ( ) )
************************************
************************************
[+] input: parse_ShouldReturnNull_WhenValueIsNull() { String value = null; String result = codec.parse(value); Assertions."<AssertPlaceHolder>"; }
parse(String value) { Double doubleValue = TypeCodecs.DOUBLE.parse(value); return doubleValue == null ? null : decimalFormat.format(doubleValue); }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: MalformedURLException { URL baseURL = new URL("http://localhost:80/myServlet?myKey=myValue");  URL expectedURL = new URL("http://localhost:80/myServlet/with/custom/path?myKey=myValue&anotherKey=anotherValue"); URL actualURL = URLBuilder.fromURL(baseURL).withPath("with", "custom", "path").withQuery("anotherKey", "anotherValue").build(); "<AssertPlaceHolder>"; }
build() {  URL extendedURL = baseURL;  extendedURL = extendQuery(extendedURL, queries); extendedURL = extendPath(extendedURL, paths);  log.info("Built URL: " + extendedURL.toString());  return extendedURL; }
[*] target: assertEquals(expectedURL, actualURL)
[-] pred: org. junit. Assert. assertEquals ( expectedURL, actualURL )
************************************
************************************
[+] input: isNotBlank_CandidateContainsNullValueString_ReturnsFalse() { final var candidate = "null";  "<AssertPlaceHolder>"; }
isNotBlank(final String candidate) { return StringUtils.isNotBlank(candidate) && !StringUtils.equals("null", candidate); }
[*] target: assertFalse(subject.isNotBlank(candidate))
[-] pred: org. junit. Assert. assertFalse ( subject. isNotBlank( candidate ) )
************************************
************************************
[+] input: validateGivenMethodWithMoreThanOneTypeParameters() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter(), U.asTypeParameter()), Optional.of(LIST.with(T)), "myFunction", asList(Parameter.of(ARRAY_LIST.with(T), "value")) );  Validated<String, InitializerOrFinalizerValidator.Result> expected = Validated.invalid("Method requires exactly 1 type parameters, but found 2"); Validated<String, InitializerOrFinalizerValidator.Result> toVerify = InitializerOrFinalizerValidator.validate(toValidate);  "<AssertPlaceHolder>"; }
validate(Method method) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyParameterCount(method.getParameters(), 1, errorMessages); verifyTypeParameterCount(method.getTypeParameters(), 1, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  TypeParameter typeParameter = method.getTypeParameters().get(0);  String name = method.getName();  Parameter parameter = method.getParameters().get(0);  // Extract the type constructor from the single parameter: TypeConstructor toInitializeOrFinalizeTypeConstructor = parameter.getType().asTypeConstructorWithPlaceholderFor(typeParameter.getName());  // Extract the type constructor from the return type: TypeConstructor initializedOrFinalizedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(typeParameter.getName());  return Validated.valid(Result.of(name, parameter.getType(), toInitializeOrFinalizeTypeConstructor, returnType, initializedOrFinalizedTypeConstructor)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: test_isDass() { when(settingsService.isCloud()).thenReturn(false); ObjectId taskId = MongoUtils.toObjectId("632454d5287a904778c40f8d"); boolean result = taskService.checkCloudTaskLimit(taskId, user, true); "<AssertPlaceHolder>"; }
checkCloudTaskLimit(ObjectId taskId, UserDetail user, boolean checkCurrentTask); public abstract void updateDelayTime(ObjectId taskId, long delayTime); public abstract void refreshSchemas(TaskDto taskDto, String nodeIds, String keys, UserDetail userDetail); public abstract void checkSourceTimeDifference(TaskDto taskDto,UserDetail userDetail);  @Data @AllArgsConstructor @NoArgsConstructor public static class Char1Group { private String _id; private long count; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testCloseWebHookByHookIds() { List<WebHookInfoVo> mock = mock(List.class); when(webHookController.success(mock)).thenReturn(mock(ResponseMessage.class)); String[] ids = new String[]{"id"}; when(webHookService.close(ids, user)).thenReturn(mock); when(webHookController.closeWebHookByHookIds(ids)).thenCallRealMethod(); ResponseMessage<List<WebHookInfoVo>> hook = webHookController.closeWebHookByHookIds(ids); Assertions."<AssertPlaceHolder>"; verify(webHookController).success(mock); verify(webHookService).close(ids, user); }
closeWebHookByHookIds(@RequestParam(value = "ids") String[] ids) { return success(webHookService.close(ids, getLoginUser())); }
[*] target: assertNotNull(hook)
[-] pred: org. junit. Assert. assertNotNull ( hook )
************************************
************************************
[+] input: parse_ShouldParseTextAndReturnAsInstant() { String valueAsString = "220412215715"; Instant value = LocalDateTime.parse(valueAsString, formatter).toInstant(zoneOffset); Instant result = codec.parse(valueAsString); Assertions."<AssertPlaceHolder>"; }
parse(String value) { LocalDateTime localDateTime = LocalDateTime.parse(value, formatter); return localDateTime.toInstant(zoneOffset); }
[*] target: assertEquals(value,result)
[-] pred: org. junit. Assert. assertEquals ( value, result )
************************************
************************************
[+] input: requiresPreprocessingAllowDuplicatesTest() { final ColumnSchema columnSchema = GeneralTestUtility.fingerprintColumn("source"); "<AssertPlaceHolder>"; }
requiresPreprocessing() { boolean requiresPreprocessing = pad != null && pad.requiresPreprocessing(); requiresPreprocessing |= type != ColumnType.CLEARTEXT; return requiresPreprocessing; }
[*] target: assertTrue(columnSchema.requiresPreprocessing())
[-] pred: org. junit. Assert. assertTrue ( columnSchema. requiresPreprocessing() )
************************************
************************************
[+] input: calculateCodonStartIndicesUsingDnaSequenceWithLengthTwentyTwoFrame2Test() { int[] expectedResult = {1, 4, 7, 10, 13, 16, 19}; String testSequence = DNA_SEQUENCE_WITH_LENGTH_TWENTY_TWO; CodonFrame temp = new CodonFrame(testSequence, (short) 2, 1, 100); ReadingFrames readingFrameTest = new ReadingFrames(temp); int[] result = readingFrameTest.calculateCodonStartIndices(testSequence); "<AssertPlaceHolder>"; }
calculateCodonStartIndices(final String dna) { int[] codonStartIndices; // calculate max total codons possible final int maxTotalCodons = dna.length() / 3; // reading frame is 1-index based. Calculate offset for 0-index array. final int offset = this.codonFrame.getReadingFrame() - 1; int[] indexArray = IntStream.range(0, maxTotalCodons).map(index -> (index * 3 + offset)).toArray();  // if the last codon index is not 3 positions away from end, remove last index. if (dna.length() - indexArray[indexArray.length - 1] < 3) { codonStartIndices = Arrays.stream(indexArray).limit(indexArray.length - 1).toArray(); } else { codonStartIndices = indexArray; }  return codonStartIndices; }
[*] target: assertArrayEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedResult, result )
************************************
************************************
[+] input: filter() { try { oneWayImplementation.filter(new ArrayList<>(List.of(new String[]{"root"}))); } catch (NullPointerException ex) { fail("Exception was thrown when not expected"); } try { oneWayImplementation.filter(null); fail("Exception was not thrown when expected"); } catch (NullPointerException ex) { "<AssertPlaceHolder>"; } }
filter(ArrayList<String> tokens) throws NullPointerException {  if (tokens==null || tokens.isEmpty())throw new NullPointerException("No tokens have been give"); int length= tokens.size();  LinkedList<Item> items; for (int i = 0; i < length; i++) { try { items = (this.itemCatalog.oneWaySynonymStrings(tokens.get(i)));  for (Item item : items) { if (!tokens.contains(item.getName())) { tokens.add(item.getName()); } } } catch (notFoundException e) { System.out.println(e.getMessage()); } } return tokens; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: asTypeConstructorWithPlaceholderForGivenNeedleThatDoesNotMatch() { TypeConstructor expected = new GenericTypeConstructor(U); TypeConstructor toVerify = new GenericType(U).asTypeConstructorWithPlaceholderFor(T);  "<AssertPlaceHolder>"; }
asTypeConstructorWithPlaceholderFor(TypeParameterName needle) { if (Objects.equals(name, needle)) { return TypeConstructor.placeholder(); } else { return TypeConstructor.generic(name); } }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testRunningTaskNum() { long except = 5L; when(taskRepository.count(Query.query(Criteria.where("is_deleted").ne(true) .and("syncType").in(TaskDto.SYNC_TYPE_SYNC, TaskDto.SYNC_TYPE_MIGRATE) .and("status").nin(TaskDto.STATUS_DELETE_FAILED, TaskDto.STATUS_DELETING) .orOperator(Criteria.where("status").in(TaskDto.STATUS_RUNNING, TaskDto.STATUS_SCHEDULING, TaskDto.STATUS_WAIT_RUN), Criteria.where("planStartDateFlag").is(true), Criteria.where("crontabExpressionFlag").is(true) )), user)).thenReturn(except); long result = taskService.runningTaskNum(user); "<AssertPlaceHolder>"; }
runningTaskNum(UserDetail userDetail);  public abstract boolean checkCloudTaskLimit(ObjectId taskId, UserDetail user, boolean checkCurrentTask); public abstract void updateDelayTime(ObjectId taskId, long delayTime); public abstract void refreshSchemas(TaskDto taskDto, String nodeIds, String keys, UserDetail userDetail); public abstract void checkSourceTimeDifference(TaskDto taskDto,UserDetail userDetail);  @Data @AllArgsConstructor @NoArgsConstructor public static class Char1Group { private String _id; private long count; }
[*] target: assertEquals(except, result)
[-] pred: org. junit. Assert. assertEquals ( except, result )
************************************
************************************
[+] input: givenConcreteType() { String toVerify = toTest() .withType(BIG_DECIMAL) .getObjectPathOrTypeGenerator() .generate();  String expected = "java.math.BigDecimal";  "<AssertPlaceHolder>"; }
generate() { Optional<String> optionalObjectPathAsString = optionalObjectPathGenerator.map(ObjectPathGenerator::generate); Optional<String> optionalConcreteTypeAsString = optionalConcreteType.map(FullyQualifiedName::raw); Optional<String> optionalGenericTypeAsString = optionalGenericType.map(TypeParameterName::raw); return optionalObjectPathAsString .map(Optional::of).orElse(optionalConcreteTypeAsString) .map(Optional::of).orElse(optionalGenericTypeAsString) .orElseThrow(NullPointerException::new); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(BigDecimal value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } else { String stringValue = value.toString(); return TypeCodecs.TEXT.encode(stringValue, protocolVersion); } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: LocationNotFoundException { MonitoringLocationCreateDTO request = MonitoringLocationCreateDTO.newBuilder().build(); MonitoringLocationDTO expectedLocation = MonitoringLocationDTO.newBuilder().build(); when(tenantLookup.lookupTenantId(any())).thenReturn(Optional.of(TENANT_ID)); when(service.upsert(any())).thenReturn(expectedLocation);  grpcService.createLocation(request, getResponseObserver);  verify(getResponseObserver).onNext(getResponseCaptor.capture()); verify(getResponseObserver).onCompleted(); MonitoringLocationDTO response = getResponseCaptor.getValue(); "<AssertPlaceHolder>"; }
createLocation( MonitoringLocationCreateDTO request, StreamObserver<MonitoringLocationDTO> responseObserver) { tenantLookup.lookupTenantId(Context.current()).ifPresent(tenantId -> { try { responseObserver.onNext(service.upsert(getMonitoringLocationDTO(tenantId, request))); responseObserver.onCompleted(); } catch (Exception e) { LOG.error("Error while creating location with name {}", request.getLocation(), e); Status status = handleException(e); responseObserver.onError(StatusProto.toStatusRuntimeException(status)); } }); }
[*] target: assertEquals(expectedLocation, response)
[-] pred: org. junit. Assert. assertEquals ( expectedLocation, response )
************************************
************************************
[+] input: testCheckLicenseEngineLimitWithCloud() { connectorManager = mock(ConnectorManager.class); CheckEngineValidResultDto actual = connectorManager.checkLicenseEngineLimit(); "<AssertPlaceHolder>"; }
checkLicenseEngineLimit() { CheckEngineValidResultDto resultDto = null; if (!AppType.currentType().isCloud()) { try { Map<String, Object> processId = new HashMap<>(); processId.put("processId", instanceNo); resultDto = clientMongoOperator.findOne(processId, ConnectorConstant.LICENSE_COLLECTION + "/checkEngineValid", CheckEngineValidResultDto.class); } catch (Exception e) { Throwable cause = CommonUtils.matchThrowable(e, HttpClientErrorException.class); if (cause instanceof HttpClientErrorException && ((HttpClientErrorException) cause).getRawStatusCode() == 404){ return null; } } } return resultDto; }
[*] target: assertEquals(null,actual)
[-] pred: org. junit. Assert. assertEquals ( null, actual )
************************************
************************************
[+] input: of() { GenericTypeConstructor expected = new GenericTypeConstructor(T); GenericTypeConstructor toVerify = GenericTypeConstructor.of(T);  "<AssertPlaceHolder>"; }
of(TypeParameterName name) { return new GenericTypeConstructor(name); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testToCollection() { HashSet<Integer> list = Steam.of(1, 2, 3, 4, 5).parallel().collect(Collective.toCollection(HashSet::new)); Assertions."<AssertPlaceHolder>"; }
size() { return 2; }
[*] target: assertEquals(5, list.size())
[-] pred: org. junit. Assert. assertEquals ( 5, list. size() )
************************************
************************************
[+] input: asTypeConstructorWithPlaceHolderForGivenNeedleThatDoesNotMatchAnyOfTheTypeArguments() { TypeConstructor expected = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.invariant(), U_TYPE_CONSTRUCTOR.covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant()); TypeConstructor toVerify = Type.concrete(ERUDITE, STRING_TYPE.invariant(), U_TYPE.covariant(), INTEGER_TYPE.contravariant()).asTypeConstructorWithPlaceholderFor(T);  "<AssertPlaceHolder>"; }
asTypeConstructorWithPlaceholderFor(TypeParameterName needle) { return TypeConstructor.concrete( fullyQualifiedName, typeArguments.stream().map(typeArgument -> typeArgument.asTypeConstructorArgumentWithPlaceholderFor(needle)).collect(toList()) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testNeedSkipNormalNormal() { File f = mock(File.class); when(f.exists()).thenReturn(true); when(f.isFile()).thenReturn(true); when(f.getName()).thenReturn("setup.py"); boolean needSkip = utils.needSkip(f); Assertions."<AssertPlaceHolder>"; }
needSkip(File f) { if (null == f) return true; if (!f.exists()) return true; if (!f.isFile()) return true; return !f.getName().contains(PACKAGE_COMPILATION_FILE); }
[*] target: assertFalse(needSkip)
[-] pred: org. junit. Assert. assertFalse ( needSkip )
************************************
************************************
[+] input: getProducerAclsTeamsOverview() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when( handleDbRequestsJdbc.getAclsCountByTeams( AclType.PRODUCER.value, TestConstants.TEAM_ID, TestConstants.TENANT_ID)) .thenReturn(Collections.emptyList()); Mockito.when( manageDatabase.getTeamNameFromTeamId(TestConstants.TENANT_ID, TestConstants.TEAM_ID)) .thenReturn(TestConstants.TEAM_NAME); Mockito.when( commonUtilsService.getChartsJsOverview( eq(Collections.emptyList()), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getProducerAclsTeamsOverview( TestConstants.TEAM_ID, TestConstants.TENANT_ID);  Assertions."<AssertPlaceHolder>"; }
getProducerAclsTeamsOverview(Integer teamId, Integer tenantId) { List<CommonUtilsService.ChartsOverviewItem<Integer, Integer>> producerAclsPerTeamList = manageDatabase .getHandleDbRequests() .getAclsCountByTeams(AclType.PRODUCER.value, teamId, tenantId);  String title = ANALYTICS_101; if (teamId != null) { title += " (" + manageDatabase.getTeamNameFromTeamId(tenantId, teamId) + ")"; } else { title += " (all teams)"; }  return commonUtilsService.getChartsJsOverview( producerAclsPerTeamList, title, "teamid", "Teams", "Producer Acls", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generateGivenCovariant() { String expected = "? extends java.lang.Integer"; String toVerify = new TypeArgumentGenerator(INTEGER.covariant()).generate();  "<AssertPlaceHolder>"; }
generate() { String generatedType = TypeGenerator.generateFrom(typeArgument.getType()); switch (typeArgument.getVariance()) { case INVARIANT: return generatedType; case COVARIANT: return String.join(SPACE, QUESTION_MARK, EXTENDS, generatedType); case CONTRAVARIANT: return String.join(SPACE, QUESTION_MARK, SUPER, generatedType); default: throw new RuntimeException("Not implemented"); } }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: LocationNotFoundException { // Mock data MonitoringLocationDTO monitoringLocationDTO = MonitoringLocationDTO.newBuilder().build(); MonitoringLocation monitoringLocation = new MonitoringLocation(); when(mapper.dtoToModel(any(MonitoringLocationDTO.class))).thenReturn(monitoringLocation); when(modelRepo.save(monitoringLocation)).thenReturn(monitoringLocation); when(mapper.modelToDTO(any(MonitoringLocation.class))).thenReturn(monitoringLocationDTO);  // Test MonitoringLocationDTO result = monitoringLocationService.upsert(monitoringLocationDTO);  // Assertions "<AssertPlaceHolder>"; verify(mapper, times(1)).dtoToModel(any(MonitoringLocationDTO.class)); verify(modelRepo, times(1)).save(monitoringLocation); verify(mapper, times(1)).modelToDTO(any(MonitoringLocation.class)); }
upsert(MonitoringLocationDTO dto) throws LocationNotFoundException { if (dto.hasField(MonitoringLocationDTO.getDescriptor().findFieldByNumber(MonitoringLocationDTO.ID_FIELD_NUMBER)) && modelRepo.findByIdAndTenantId(dto.getId(), dto.getTenantId()).isEmpty()) { throw new LocationNotFoundException("Location not found with ID " + dto.getId()); } if (dto.hasField( MonitoringLocationDTO.getDescriptor().findFieldByNumber(MonitoringLocationDTO.LOCATION_FIELD_NUMBER))) { if (StringUtils.isBlank(dto.getLocation())) { throw new InventoryRuntimeException("Location is Blank"); } var location = modelRepo.findByLocationAndTenantId(dto.getLocation().trim(), dto.getTenantId()); if (location.isPresent() && location.get().getId() != dto.getId()) { throw new InventoryRuntimeException("Duplicate Location found with name " + dto.getLocation()); } }  MonitoringLocation model = mapper.dtoToModel(dto); return mapper.modelToDTO(modelRepo.save(model)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: setProperty_StringList() { List<String> value = Arrays.asList("a","b", "c"); List<String> setValue = (List<String>) helper.setProperty(KnownProperties.TEST_STRING_LIST, value); "<AssertPlaceHolder>"; }
setProperty(String propertyName, Object propertyValue) { if (null == propertyName || null == propertyValue) return null; PropertyType expectedType = getType(propertyName); if (null == expectedType) { return null; }  boolean typesMatch = validateType(expectedType, propertyValue); if (!typesMatch) return null;  synchronized (PropertyHelper.class) { propertyMap.put(propertyName, propertyValue); } return propertyValue; }
[*] target: assertEquals(value, setValue)
[-] pred: org. junit. Assert. assertEquals ( value, setValue )
************************************
************************************
[+] input: shouldSetAndGetRestricted() { component = new FileChooserDialog(); component.setRestricted(true); "<AssertPlaceHolder>"; }
isRestricted() { return restricted; }
[*] target: assertTrue(component.isRestricted())
[-] pred: org. junit. Assert. assertTrue ( component. isRestricted() )
************************************
************************************
[+] input: testDeleteSql() { Map<String, Object> params = new HashMap<>(2); params.put("id", 1); params.put("selfSQL", "delete from user where id = #{id}"); long delete = commonDao.deleteSql(params); Assertions."<AssertPlaceHolder>"; }
deleteSql(Map<String, Object> params);
[*] target: assertEquals(1, delete)
[-] pred: org. junit. Assert. assertEquals ( 1, delete )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(String value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } else { Instant instantValue = Instant.ofEpochMilli(Long.parseLong(value)); return TypeCodecs.TIMESTAMP.encode(instantValue, protocolVersion); } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: validateGivenMethodWithTypeParameterWithUpperBoundOtherThanObject() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter(), U.extending(COMPARABLE.with(U)), V.asTypeParameter()), Optional.of(OPTIONAL.with(V)), "myFunction", asList( Parameter.of(OPTIONAL.with(T), "left"), Parameter.of(OPTIONAL.with(U), "right"), Parameter.of(BI_FUNCTION.with(T.asType().contravariant(), U.asType().contravariant(), V.asType().covariant()), "compose") ) );  Validated<String, AccumulatorValidator.Result> expected = Validated.invalid("The type parameters need to be unbounded"); Validated<String, AccumulatorValidator.Result> toVerify = AccumulatorValidator.validate(toValidate, new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
validate(Method method, ParametersAndTypeParametersValidator parametersAndTypeParametersValidator) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages); ParametersAndTypeParametersValidator.Result parametersAndTypeParameters = verifyParametersAndTypeParameters(method, parametersAndTypeParametersValidator, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  // Assign a meaningful name to each of the (three) type parameters: TypeParameter leftInputTypeConstructorArgument = parametersAndTypeParameters.getLeftInputTypeConstructorArgument(); TypeParameter rightInputTypeConstructorArgument = parametersAndTypeParameters.getRightInputTypeConstructorArgument(); TypeParameter returnTypeConstructorArgument = parametersAndTypeParameters.getReturnTypeConstructorArgument();  // Assign a meaningful name to the left and right parameters: Type leftParameterType = parametersAndTypeParameters.getLeftParameterType(); Type rightParameterType = parametersAndTypeParameters.getRightParameterType();  String name = method.getName();  TypeConstructor accumulatedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(returnTypeConstructorArgument.getName()); TypeConstructor partiallyAccumulatedTypeConstructor = leftParameterType.asTypeConstructorWithPlaceholderFor(leftInputTypeConstructorArgument.getName()); TypeConstructor inputTypeConstructor = rightParameterType.asTypeConstructorWithPlaceholderFor(rightInputTypeConstructorArgument.getName());  if (!partiallyAccumulatedTypeConstructor.canAccept(accumulatedTypeConstructor)) { // Tweak the error message to not confuse people using the simple case where // parameter types and result type should be identical: if (Objects.equals(partiallyAccumulatedTypeConstructor, inputTypeConstructor)) { return Validated.invalid("No shared type constructor between parameters (" + generateFrom(leftParameterType) + " and " + generateFrom(rightParameterType) + ") and result (" + generateFrom(returnType) + ")"); } else { return Validated.invalid("No shared type constructor between first parameter (" + generateFrom(leftParameterType) + ") and result (" + generateFrom(returnType) + ")"); } }  verifyNoCrossReferences(method.getTypeParameters(), leftParameterType, partiallyAccumulatedTypeConstructor, "type of the first parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), rightParameterType, inputTypeConstructor, "type of the second parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), returnType, accumulatedTypeConstructor, "return type", errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  return Validated.valid( AccumulatorValidator.Result.of( name, inputTypeConstructor, partiallyAccumulatedTypeConstructor, accumulatedTypeConstructor, leftParameterType, rightParameterType, returnType ) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testEncryptInvalidKeyLength() { ReflectionTestUtils.setField( converter, ENCRYPTION_KEY_FIELD, RandomStringUtils.randomAlphabetic(INVALID_KEY_LENGTH)); String plainText = RandomStringUtils.randomAlphanumeric(10); String converted = converter.convertToDatabaseColumn(plainText); "<AssertPlaceHolder>"; }
convertToDatabaseColumn(String plainText) { Cipher cipher = getCipher(); SecretKey key = getSecretKey(); GCMParameterSpec paramSpec = getNewRandomParamSpec(); try { cipher.init(Cipher.ENCRYPT_MODE, key, paramSpec); byte[] cipherText = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8)); ByteBuffer byteBuffer = ByteBuffer.allocate(paramSpec.getIV().length + cipherText.length); byteBuffer.put(paramSpec.getIV()); byteBuffer.put(cipherText); return Base64.getEncoder().encodeToString(byteBuffer.array()); } catch (IllegalBlockSizeException | BadPaddingException | InvalidKeyException | InvalidAlgorithmParameterException e) { log.error("Failed to convert to database column, writing in cleartext...", e); return plainText; } }
[*] target: assertEquals(plainText, converted)
[-] pred: org. junit. Assert. assertEquals ( plainText, converted )
************************************
************************************
[+] input: testSortByType() { // given: TastableHofundConnectionsProvider provider = new TastableHofundConnectionsProvider(); HofundConnectionsTable table = new HofundConnectionsTable(Collections.singletonList(provider)); String expected = "+----------+---------+--------+------+\n" + "| TYPE     | NAME    | STATUS | URL  |\n" + "+----------+---------+--------+------+\n" + "| HTTP     | target1 | UP     | fake |\n" + "| HTTP     | target3 | UP     | fake |\n" + "| DATABASE | target2 | UP     | fake |\n" + "| DATABASE | target4 | UP     | fake |\n" + "+----------+---------+--------+------+\n";  // when: String result = table.print();  // then: "<AssertPlaceHolder>"; }
print() { AsciiTable table = new AsciiTable(HEADERS);  for (HofundConnection connection : connections) { table.addRow( connection.getType().name(), connection.getTarget(), connection.getFun().get().getStatus().getName(), connection.getUrl() ); }  return table.printTable(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: withName() { Parameter expected = new Parameter(STRING_TYPE, "s"); Parameter toVerify = STRING_TYPE.withName("s");  "<AssertPlaceHolder>"; }
withName(String name) { return Parameter.of(this, name); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testAddAll() { // Setup final ServiceConfig serviceConfig = new ServiceConfig(); serviceConfig.setName("configName"); serviceConfig.setValue("configValue"); serviceConfig.setLabel("label"); serviceConfig.setDescription("description"); serviceConfig.setRequired(false); serviceConfig.setType("input"); serviceConfig.setConfigurableInWizard(false); serviceConfig.setDefaultValue("defaultValue"); serviceConfig.setMinValue(0); serviceConfig.setMaxValue(0); serviceConfig.setUnit("unit"); serviceConfig.setHidden(false); serviceConfig.setSelectValue(Arrays.asList("value")); serviceConfig.setConfigType("configType"); final List<ServiceConfig> left = Arrays.asList(serviceConfig); final ServiceConfig serviceConfig1 = new ServiceConfig(); serviceConfig1.setName("configName"); serviceConfig1.setValue("configValue"); serviceConfig1.setLabel("label"); serviceConfig1.setDescription("description"); serviceConfig1.setRequired(false); serviceConfig1.setType("input"); serviceConfig1.setConfigurableInWizard(false); serviceConfig1.setDefaultValue("defaultValue"); serviceConfig1.setMinValue(0); serviceConfig1.setMaxValue(0); serviceConfig1.setUnit("unit"); serviceConfig1.setHidden(false); serviceConfig1.setSelectValue(Arrays.asList("value")); serviceConfig1.setConfigType("configType"); final List<ServiceConfig> right = Arrays.asList(serviceConfig1); final ServiceConfig serviceConfig2 = new ServiceConfig(); serviceConfig2.setName("configName"); serviceConfig2.setValue("configValue"); serviceConfig2.setLabel("label"); serviceConfig2.setDescription("description"); serviceConfig2.setRequired(false); serviceConfig2.setType("input"); serviceConfig2.setConfigurableInWizard(false); serviceConfig2.setDefaultValue("defaultValue"); serviceConfig2.setMinValue(0); serviceConfig2.setMaxValue(0); serviceConfig2.setUnit("unit"); serviceConfig2.setHidden(false); serviceConfig2.setSelectValue(Arrays.asList("value")); serviceConfig2.setConfigType("configType"); final List<ServiceConfig> expectedResult = Arrays.asList(serviceConfig2);  // Run the test final List<ServiceConfig> result = ProcessUtils.addAll(left, right);  // Verify the results "<AssertPlaceHolder>"; }
addAll(List<ServiceConfig> left, List<ServiceConfig> right) { if (left == null) { return null; } if (right == null) { return left; } // 使用LinkedList方便插入和删除 List<ServiceConfig> res = new LinkedList<>(right); Set<String> set = new HashSet<>(); // for (ServiceConfig item : left) { set.add(item.getName()); } // 迭代器遍历listA for (ServiceConfig item : res) { // 如果set中包含id则remove if (!set.contains(item.getName())) { left.add(item); } } return left; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: apply() { Type expected = STRING_TYPE; Type toVerify = new PlaceholderTypeConstructor().apply(STRING_TYPE);  "<AssertPlaceHolder>"; }
apply(Type toApplyTo) { return toApplyTo; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismTwoNodeButNotAllNodeAreDataParentNode() { when(nodeList.size()).thenReturn(2); JsProcessorNode node1 = mock(JsProcessorNode.class); when(nodeList.get(0)).thenReturn(node1);  DataParentNode node2 = mock(DataParentNode.class); when(node2.getDatabaseType()).thenReturn("mock-type"); when(nodeList.get(1)).thenReturn(node2); boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(1)).get(0); verify(nodeList, times(0)).get(1); verify(node2, times(0)).getDatabaseType(); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: testGetDiscountAmount_withPercentageDiscountType() { given(couponCampaign.getDiscountType()).willReturn(DiscountType.PERCENTAGE); given(couponCampaign.getDiscountAmount()).willReturn(discountPercentage); given(couponCampaign.getMinimumCost()).willReturn(minimumCost);  Money supplyAmount = Money.wons(60000L); Money expectedDiscountAmount = Money.wons(18000L); Money actualDiscountAmount = issuedCoupon.getDiscountAmount(supplyAmount);  "<AssertPlaceHolder>"; }
getDiscountAmount(Money supplyAmount) { if (couponCampaign.getDiscountType().equals(DiscountType.AMOUNT)) { // 정액 할인 return checkSupplyAmount( supplyAmount, couponCampaign.getDiscountAmount(), couponCampaign.getMinimumCost()); } // 정률 할인 Long discountAmount = supplyAmount.getDiscountAmountByPercentage( supplyAmount, couponCampaign.getDiscountAmount()); return checkSupplyAmount(supplyAmount, discountAmount, couponCampaign.getMinimumCost()); }
[*] target: assertEquals(expectedDiscountAmount, actualDiscountAmount)
[-] pred: org. junit. Assert. assertEquals ( expectedDiscountAmount, actualDiscountAmount )
************************************
************************************
[+] input: givenConcreteMethod() { List<String> toVerify = method() .withModifiers(PRIVATE, STATIC) .withName("notify") .withBody("System.out.println("Consider yourself notified!");") .lines();  List<String> expected = asList( "private static void notify() {", "    System.out.println("Consider yourself notified!");", "}" );  "<AssertPlaceHolder>"; }
lines() { List<String> components = new ArrayList<>(); if (!modifiersGenerator.isEmpty()) { components.add(modifiersGenerator.generate()); } if (!typeParametersGenerator.isEmpty()) { components.add(typeParametersGenerator.generate()); } components.add(optionalReturnType.map(TypeGenerator::generateFrom).orElse(VOID)); components.add(name + parametersGenerator.generate()); String methodDeclaration = components.stream().collect(joining(SPACE));  return optionalBodyGenerator .map(bodyGenerator -> { List<String> result = new ArrayList<>(); result.add(methodDeclaration + SPACE + OPEN_BRACE); result.addAll(bodyGenerator.indent().lines()); result.add(CLOSE_BRACE); return result; }) .orElse(asList(methodDeclaration + SEMICOLON)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testReplace() { User user = new User(); user.setId(1L) .setName("张三") .setAge(18) .setCreateTime(LocalDateTime.now()); int replace = commonDaoWrap.replace(user); Assertions."<AssertPlaceHolder>"; }
replace(T params) { return dao.replace(params); }
[*] target: assertEquals(2, replace)
[-] pred: org. junit. Assert. assertEquals ( 2, replace )
************************************
************************************
[+] input: givenValidClassAndMethodsContainingValidAccumulatorAndValidInitializer() { ContainingClass containingClass = getValidContainingClass();  Method initializer = getInitializer( withAnnotations(INITIALIZER_FULLY_QUALIFIED_NAME), withModifiers(PUBLIC), withToInitializeTypeConstructor(LIST.with(placeholder().covariant())), withToInitializeTypeConstructor(ARRAY_LIST.with(placeholder().invariant())) );  Method accumulator = getAccumulator( withAnnotations(ACCUMULATOR_FULLY_QUALIFIED_NAME), withModifiers(PUBLIC), withInputTypeConstructor(LIST.with(placeholder().covariant())), withPartiallyAccumulatedTypeConstructor(ARRAY_LIST.with(placeholder().covariant())), withAccumulatedTypeConstructor(ARRAY_LIST.with(placeholder().invariant())) );  Validated<Log, Validator.Result> expected = Validated.valid( Validator.Result.of( containingClass.getTypeParameters(), Optional.of(Initializer.of(initializer.getName(), LIST.with(placeholder().covariant()), ARRAY_LIST.with(placeholder().invariant()))), Accumulator.of( accumulator.getName(), LIST.with(placeholder().covariant()), ARRAY_LIST.with(placeholder().covariant()), ARRAY_LIST.with(placeholder().invariant()) ), Optional.empty() ) );  Validated<Log, Validator.Result> toVerify = Validator.validate(containingClass, asList(accumulator, initializer), new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
of(List<TypeParameter> classTypeParameters, Optional<Initializer> optionalInitializer, Accumulator accumulator, Optional<Finalizer> optionalFinalizer) { return new Result(classTypeParameters, optionalInitializer, accumulator, optionalFinalizer); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: shouldSetAndGetScrollOnUserInput() { options.setScrollOnUserInput(false); "<AssertPlaceHolder>"; }
isScrollOnUserInput() { return scrollOnUserInput; }
[*] target: assertFalse(options.isScrollOnUserInput())
[-] pred: org. junit. Assert. assertFalse ( options. isScrollOnUserInput() )
************************************
************************************
[+] input: calculateCodonStartIndicesFrame1Test() { int[] expectedResult = {0, 3, 6, 9, 12, 15, 18, 21}; CodonFrame temp = new CodonFrame(TEST_SEQUENCE, (short) 1, 1, 100); ReadingFrames readingFrameTest = new ReadingFrames(temp);  int[] result = readingFrameTest.calculateCodonStartIndices(TEST_SEQUENCE);  "<AssertPlaceHolder>"; }
calculateCodonStartIndices(final String dna) { int[] codonStartIndices; // calculate max total codons possible final int maxTotalCodons = dna.length() / 3; // reading frame is 1-index based. Calculate offset for 0-index array. final int offset = this.codonFrame.getReadingFrame() - 1; int[] indexArray = IntStream.range(0, maxTotalCodons).map(index -> (index * 3 + offset)).toArray();  // if the last codon index is not 3 positions away from end, remove last index. if (dna.length() - indexArray[indexArray.length - 1] < 3) { codonStartIndices = Arrays.stream(indexArray).limit(indexArray.length - 1).toArray(); } else { codonStartIndices = indexArray; }  return codonStartIndices; }
[*] target: assertArrayEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedResult, result )
************************************
************************************
[+] input: testNormal() { user = mock(UserDetail.class); String newName = "test_name"; ObjectId id = mock(ObjectId.class); when(taskService.count(any(Query.class),any(UserDetail.class))).thenReturn(1L); doCallRealMethod().when(taskService).checkTaskNameNotError(newName,user,id); boolean actual = taskService.checkTaskNameNotError(newName, user, id); "<AssertPlaceHolder>"; }
checkTaskNameNotError(String newName, UserDetail user, ObjectId id) {  Criteria criteria = Criteria.where("name").is(newName).and(IS_DELETED).ne(true); if (id != null) { criteria.and("_id").ne(id); } Query query = new Query(criteria); long count = count(query, user); return count > 0; }
[*] target: assertEquals(true,actual)
[-] pred: org. junit. Assert. assertEquals ( true, actual )
************************************
************************************
[+] input: saveRole() { Mockito.when(roleEntityRepository.merge(roleEntity)).thenReturn(roleEntity);  Role storedRoleDetails = roleService.save(this.roleEntity); Assertions."<AssertPlaceHolder>"; }
save(final Role role);
[*] target: assertNotNull(storedRoleDetails)
[-] pred: org. junit. Assert. assertNotNull ( storedRoleDetails )
************************************
************************************
[+] input: testForLong() { Object value = 1L; Object actual = FieldProcessUtil.handleDateTime(value); "<AssertPlaceHolder>"; }
handleDateTime(Object value) { if (value instanceof DateTime) { value = ((DateTime) value).toEpochMilli(); } return value; }
[*] target: assertEquals(value, actual)
[-] pred: org. junit. Assert. assertEquals ( value, actual )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismMoreThanTwoNode() { when(nodeList.size()).thenReturn(100); boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(0)).get(0); verify(nodeList, times(0)).get(1); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: test_newModelLastUpdateIsNull() { try (MockedStatic<MetaDataBuilderUtils> mockedStatic = Mockito.mockStatic(MetaDataBuilderUtils.class)){ mockedStatic.when(()->MetaDataBuilderUtils.generateQualifiedName(any(),any(DataSourceConnectionDto.class),any())).thenReturn("test-qualified"); List<MetadataInstancesDto> input = new ArrayList<>(); MetadataInstancesDto metadataInstancesDto = new MetadataInstancesDto(); metadataInstancesDto.setMetaType("test"); metadataInstancesDto.setOriginalName("test"); metadataInstancesDto.setLastUpdate(null); input.add(metadataInstancesDto); List<MetadataInstancesDto> oldMetadataInstances = new ArrayList<>(); MetadataInstancesDto old = new MetadataInstancesDto(); old.setQualifiedName("test-qualified"); old.setMetaType("test"); old.setOriginalName("test"); old.setLastUpdate(1L); oldMetadataInstances.add(old); when(metadataInstancesService.findAllDto(any(),any())).thenReturn(oldMetadataInstances); List<MetadataInstancesDto> result = metadataUtil.modelNext(input,mock(DataSourceConnectionDto.class),"test",mock(UserDetail.class),false); Assertions."<AssertPlaceHolder>"; } }
modelNext(List<MetadataInstancesDto> newModels, DataSourceConnectionDto connection, String databaseId, UserDetail user,Boolean partLoad) { if (newModels == null || connection == null) { log.info("Finished update new models, newModels = {}, connection = {}", newModels == null ? "" : newModels.size(), connection); return Lists.newArrayList(); }   Map<String, String> newModelMap = newModels.stream().collect(Collectors.toMap(MetadataInstancesDto::getOriginalName , m -> MetaDataBuilderUtils.generateQualifiedName(m.getMetaType(), connection, m.getOriginalName()))); Criteria criteria = Criteria.where("qualified_name").in(newModelMap.values()); List<MetadataInstancesDto> metadataInstancesDtos = metadataInstancesService.findAllDto(new Query(criteria), user);  Map<String, MetadataInstancesDto> oldModeMap = metadataInstancesDtos.stream().collect(Collectors.toMap(MetadataInstancesDto::getQualifiedName, m -> m));   List<MetadataInstancesDto> newModelList = new ArrayList<>(); for (MetadataInstancesDto newModel : newModels) {  MetadataInstancesDto oldModel = oldModeMap.get(newModelMap.get(newModel.getOriginalName()));  if (oldModel != null && CollectionUtils.isNotEmpty(oldModel.getFields()) && CollectionUtils.isNotEmpty(newModel.getFields())) { newModel.setName(StringUtils.isNotBlank(oldModel.getName()) ? oldModel.getName() : ""); //newModel.setComment(StringUtils.isNotBlank(oldModel.getComment()) ? oldModel.getComment() : ""); oldModel.setVersionTime(new Date());  newModel.setHistories(oldModel.getHistories()); addHistory(oldModel.getId(), newModel, oldModel, user, false);  }  if (CollectionUtils.isNotEmpty(newModel.getFields())) { for (Field field : newModel.getFields()) { if (field.getIsAutoAllowed() == null) { field.setIsAutoAllowed(true); } if (field.getSource() == null) { field.setSource("auto"); } } }  if (oldModel != null && CollectionUtils.isNotEmpty(oldModel.getFields())) { for (Field field : oldModel.getFields()) { if (field.getIsAutoAllowed() == null) { field.setIsAutoAllowed(true); } if (field.getSource() == null) { field.setSource("auto"); } } } if(partLoad || null == oldModel || (newModel.getLastUpdate() != null && oldModel.getLastUpdate() != null && newModel.getLastUpdate() >= oldModel.getLastUpdate())){ newModel = MetaDataBuilderUtils.build(newModel.getMetaType(), connection, user.getUserId(), user.getUsername(), newModel.getOriginalName(), newModel, oldModel, databaseId, null, newModelMap); newModelList.add(newModel); } }  return newModelList; }
[*] target: assertEquals(0,result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: Exception {  RemotePreferenceStore.setMockRemoteServer(); HelpPlugin.getTocManager().clearCache(); boolean hasDuplicates=hasDuplicateContributions(HelpPlugin.getTocManager().getTocContributions("en")); "<AssertPlaceHolder>"; }
getTocContributions(String locale) { return getAndCacheTocContributions(locale, tocContributionsByLocale); }
[*] target: assertFalse(hasDuplicates)
[-] pred: org. junit. Assert. assertFalse ( hasDuplicates )
************************************
************************************
[+] input: createCustomer() { //given Customer customer = new Customer(); customer.setId("1"); customer.setCustomerFullName("John"); customer.setCustomerType("ACTIVE");  CustomerEntity customerEntity = new CustomerEntity(); customerEntity.setId("1"); customerEntity.setCustomerType("ACTIVE"); customerEntity.setCustomerFullName("John");  //when when(customerMapper.toEntity(customer)).thenReturn(customerEntity); when(customerRepository.save(any())).thenReturn(customerEntity); when(customerMapper.toDto(customerEntity)).thenReturn(customer);  Customer customer2 = customerService.createCustomer(customer);  //then verify(customerRepository, times(1)).save(any()); "<AssertPlaceHolder>"; }
createCustomer(Customer customer);  /** * return all customer ref instances in the database * * @return List<CustomerRef>. Please, see the {@link evrentan.examples.springbootprojectexample.dto.CustomerRef}
[*] target: assertEquals(customer, customer2)
[-] pred: org. junit. Assert. assertEquals ( customer, customer2 )
************************************
************************************
[+] input: Exception { /* we test that if we turn the flag off the user information is preserved */ MaskingConfiguration configuration = new DefaultMaskingConfiguration(); configuration.setValue("url.mask.usernamePassword", false); configuration.setValue("url.mask.port", true); configuration.setValue("url.preserve.domains", 0); MaskingProvider urlMaskingProvider = new URLMaskingProvider(configuration, new MaskingProviderFactory(new ConfigurationManager(), Collections.emptyMap())); String url = "http://user1:pass1@www.nba.com"; String maskedResult = urlMaskingProvider.mask(url); String originalUserInfo = new URL(url).getUserInfo(); String maskedUserInfo = new URL(maskedResult).getUserInfo(); "<AssertPlaceHolder>"; }
mask(String identifier) { try { URL url = new URL(identifier); return maskURL(url); } catch (MalformedURLException e) { return RandomGenerators.generateRandomURL(); } }
[*] target: assertEquals(originalUserInfo, maskedUserInfo)
[-] pred: org. junit. Assert. assertEquals ( originalUserInfo, maskedUserInfo )
************************************
************************************
[+] input: testStartInstallService() { // Setup final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  // Configure ClusterServiceCommandService.listByIds(...). final ClusterServiceCommandEntity clusterServiceCommandEntity = new ClusterServiceCommandEntity(); clusterServiceCommandEntity.setCommandId("commandId"); clusterServiceCommandEntity.setCreateBy("createBy"); clusterServiceCommandEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceCommandEntity.setCommandName("commandName"); clusterServiceCommandEntity.setCommandState(CommandState.WAIT); clusterServiceCommandEntity.setCommandStateCode(0); clusterServiceCommandEntity.setCommandProgress(0); clusterServiceCommandEntity.setClusterId(0); clusterServiceCommandEntity.setServiceName("parentName"); clusterServiceCommandEntity.setCommandType(0); clusterServiceCommandEntity.setDurationTime("durationTime"); clusterServiceCommandEntity.setEndTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceCommandEntity.setServiceInstanceId(0); final Collection<ClusterServiceCommandEntity> clusterServiceCommandEntities = Arrays.asList( clusterServiceCommandEntity); when(mockCommandService.listByIds(Arrays.asList("value"))).thenReturn(clusterServiceCommandEntities);  // Configure ClusterInfoService.getById(...). final ClusterInfoEntity clusterInfoEntity = new ClusterInfoEntity(); clusterInfoEntity.setId(0); clusterInfoEntity.setCreateBy("createBy"); clusterInfoEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterInfoEntity.setClusterName("clusterName"); clusterInfoEntity.setClusterCode("clusterCode"); clusterInfoEntity.setClusterFrame("clusterFrame"); clusterInfoEntity.setFrameVersion("frameVersion"); clusterInfoEntity.setClusterState(ClusterState.RUNNING); clusterInfoEntity.setFrameId(0); final UserInfoEntity userInfoEntity = new UserInfoEntity(); userInfoEntity.setId(0); userInfoEntity.setUsername("username"); userInfoEntity.setPassword("password"); userInfoEntity.setEmail("email"); userInfoEntity.setPhone("phone"); clusterInfoEntity.setClusterManagerList(Arrays.asList(userInfoEntity)); when(mockClusterInfoService.getById(0)).thenReturn(clusterInfoEntity);  // Configure ClusterServiceCommandHostCommandService.getHostCommandListByCommandId(...). final ClusterServiceCommandHostCommandEntity clusterServiceCommandHostCommandEntity = new ClusterServiceCommandHostCommandEntity(); clusterServiceCommandHostCommandEntity.setHostCommandId("hostCommandId"); clusterServiceCommandHostCommandEntity.setCommandName("commandName"); clusterServiceCommandHostCommandEntity.setCommandState(CommandState.WAIT); clusterServiceCommandHostCommandEntity.setCommandStateCode(0); clusterServiceCommandHostCommandEntity.setCommandProgress(0); clusterServiceCommandHostCommandEntity.setCommandHostId("commandHostId"); clusterServiceCommandHostCommandEntity.setCommandId("commandId"); clusterServiceCommandHostCommandEntity.setHostname("hostname"); clusterServiceCommandHostCommandEntity.setServiceRoleName("serviceRoleName"); clusterServiceCommandHostCommandEntity.setServiceRoleType(RoleType.MASTER); clusterServiceCommandHostCommandEntity.setResultMsg("resultMsg"); clusterServiceCommandHostCommandEntity.setCreateTime( new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceCommandHostCommandEntity.setCommandType(0); final List<ClusterServiceCommandHostCommandEntity> clusterServiceCommandHostCommandEntities = Arrays.asList( clusterServiceCommandHostCommandEntity); when(mockHostCommandService.getHostCommandListByCommandId("commandId")).thenReturn( clusterServiceCommandHostCommandEntities);  // Run the test final Result result = serviceInstallServiceImplUnderTest.startInstallService(0, Arrays.asList("value"));  // Verify the results "<AssertPlaceHolder>"; }
startInstallService(Integer clusterId, List<String> commandIds) { Collection<ClusterServiceCommandEntity> commands = commandService.listByIds(commandIds); ClusterInfoEntity clusterInfo = clusterInfoService.getById(clusterId); DAG<String, ServiceNode, ServiceNodeEdge> dag = new DAG<>(); for (ClusterServiceCommandEntity command : commands) { List<ClusterServiceCommandHostCommandEntity> commandHostList = hostCommandService.getHostCommandListByCommandId(command.getCommandId()); List<ServiceRoleInfo> masterRoles = new ArrayList<>(); List<ServiceRoleInfo> elseRoles = new ArrayList<>(); ServiceNode serviceNode = new ServiceNode(); String serviceKey = clusterInfo.getClusterFrame() + Constants.UNDERLINE + command.getServiceName(); ServiceInfo serviceInfo = ServiceInfoMap.get(serviceKey); for (ClusterServiceCommandHostCommandEntity hostCommand : commandHostList) { String key = clusterInfo.getClusterFrame() + Constants.UNDERLINE + command.getServiceName() + Constants.UNDERLINE + hostCommand.getServiceRoleName(); ServiceRoleInfo serviceRoleInfo = ServiceRoleMap.get(key); serviceRoleInfo.setHostname(hostCommand.getHostname()); serviceRoleInfo.setHostCommandId(hostCommand.getHostCommandId()); serviceRoleInfo.setClusterId(clusterId); serviceRoleInfo.setParentName(command.getServiceName()); if (Constants.MASTER.equals(serviceRoleInfo.getRoleType())) { masterRoles.add(serviceRoleInfo); } else { elseRoles.add(serviceRoleInfo); } } serviceNode.setMasterRoles(masterRoles); serviceNode.setElseRoles(elseRoles); dag.addNode(command.getServiceName(), serviceNode); if (serviceInfo.getDependencies().size() > 0) { for (String dependency : serviceInfo.getDependencies()) { dag.addEdge(dependency, command.getServiceName()); } } } return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: calculateCodonStartIndicesFrame2Test() { int[] expectedResult = {1, 4, 7, 10, 13, 16, 19}; CodonFrame temp = new CodonFrame(TEST_SEQUENCE, (short) 2, 1, 100); ReadingFrames readingFrameTest = new ReadingFrames(temp);  int[] result = readingFrameTest.calculateCodonStartIndices(TEST_SEQUENCE);  "<AssertPlaceHolder>"; }
calculateCodonStartIndices(final String dna) { int[] codonStartIndices; // calculate max total codons possible final int maxTotalCodons = dna.length() / 3; // reading frame is 1-index based. Calculate offset for 0-index array. final int offset = this.codonFrame.getReadingFrame() - 1; int[] indexArray = IntStream.range(0, maxTotalCodons).map(index -> (index * 3 + offset)).toArray();  // if the last codon index is not 3 positions away from end, remove last index. if (dna.length() - indexArray[indexArray.length - 1] < 3) { codonStartIndices = Arrays.stream(indexArray).limit(indexArray.length - 1).toArray(); } else { codonStartIndices = indexArray; }  return codonStartIndices; }
[*] target: assertArrayEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedResult, result )
************************************
************************************
[+] input: testIsValidWithValidValue() { DoesNotContain doesNotContain = mock(DoesNotContain.class); when(doesNotContain.chars()).thenReturn(new String[]{"@", "#"}); validator.initialize(doesNotContain);  String value = "abcde"; boolean result = validator.isValid(value, context);  "<AssertPlaceHolder>"; }
isValid(String value, ConstraintValidatorContext context) { if (value == null) { return true; } for (String c : chars) { if (value.contains(c)) { return false; } } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testCompatible() { String oldCompressString = "KLUv/QBYJAgAltE3JDCLOAcQDrWkTCPhBm9L2vigBeJYVw+ES3bvwu/pHjBwMDDAASsAMQAtAAzxS6NLBfbeBg8o7tWvx5hO8bSXSw2cXV/" + "uI+wqUQ6KYaSdz5dz07JD7ZG7OKMoAIimCVASSbMsidMsCYNIlCVJWDQEzg4xIIaPMoNKJyl/VTpxsy+MjVN6UCG106Nxd1IQfDzC3lGnBm20Rpz91TiM4jiMg1i" + "cxMKurzkWtk7l50th79W3kBsk1WNzrhXoa45eZZ6ew9OOFEIasErwq3q0kOAQbbpDQnLhv8aFUqycm7ajdgwARRmAwGN29RL2nXEYEDb8ug9tmqh5KPj4mTh9ehy1EAUBAAA="; final byte[] oldCompressBytes = Base64.getDecoder().decode(oldCompressString); final String newDeCompressString = CompressUtil.zstdDecompress(oldCompressBytes, StandardCharsets.UTF_8); final byte[] newCompressBytes = CompressUtil.zstdCompress(newDeCompressString, StandardCharsets.UTF_8); String newCompressString = Base64.getEncoder().encodeToString(newCompressBytes); "<AssertPlaceHolder>"; }
zstdCompress(String original, Charset charsetName) { return zstdCompress(original.getBytes(charsetName)); }
[*] target: assertEquals(oldCompressString, newCompressString)
[-] pred: org. junit. Assert. assertEquals ( oldCompressString, newCompressString )
************************************
************************************
[+] input: getProducerAclsTeamsOverview_TeamIdNull() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when( handleDbRequestsJdbc.getAclsCountByTeams( AclType.PRODUCER.value, null, TestConstants.TENANT_ID)) .thenReturn(Collections.emptyList()); Mockito.when( commonUtilsService.getChartsJsOverview( eq(Collections.emptyList()), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getProducerAclsTeamsOverview(null, TestConstants.TENANT_ID);  Assertions."<AssertPlaceHolder>"; }
getProducerAclsTeamsOverview(Integer teamId, Integer tenantId) { List<CommonUtilsService.ChartsOverviewItem<Integer, Integer>> producerAclsPerTeamList = manageDatabase .getHandleDbRequests() .getAclsCountByTeams(AclType.PRODUCER.value, teamId, tenantId);  String title = ANALYTICS_101; if (teamId != null) { title += " (" + manageDatabase.getTeamNameFromTeamId(tenantId, teamId) + ")"; } else { title += " (all teams)"; }  return commonUtilsService.getChartsJsOverview( producerAclsPerTeamList, title, "teamid", "Teams", "Producer Acls", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: requiresPreprocessingFalseTest() { final ColumnSchema columnSchema = GeneralTestUtility.cleartextColumn("source"); "<AssertPlaceHolder>"; }
requiresPreprocessing() { boolean requiresPreprocessing = pad != null && pad.requiresPreprocessing(); requiresPreprocessing |= type != ColumnType.CLEARTEXT; return requiresPreprocessing; }
[*] target: assertFalse(columnSchema.requiresPreprocessing())
[-] pred: org. junit. Assert. assertFalse ( columnSchema. requiresPreprocessing() )
************************************
************************************
[+] input: Exception { FormatProcessor processor = new FormatProcessor() { @Override public boolean supportsStreams() { return true; }  @Override protected Iterable<Record> extractRecords(InputStream dataset, DatasetOptions datasetOptions, int firstN) { return Collections.emptyList(); } };  try ( InputStream input = new ByteArrayInputStream( new byte[0] ); ByteArrayOutputStream output = new ByteArrayOutputStream(); PrintStream print = new PrintStream(output) ) { MaskingProviderFactory factory = new MaskingProviderFactory(new ConfigurationManager(), Collections.emptyMap()); processor.maskStream( input, print, factory, new DataMaskingOptions( DataTypeFormat.CSV, DataTypeFormat.CSV, Collections.emptyMap(), false, Collections.emptyMap(), new CSVDatasetOptions(false, ',', '"', false) ), Collections.emptySet(), Collections.emptyMap());  String result = output.toString(); "<AssertPlaceHolder>"; } }
extractRecords(InputStream dataset, DatasetOptions dataOptions, int firstN) throws IOException;  protected void updateCounter(Map<String, Counter> columnTypes, String type) { Counter counter = columnTypes.computeIfAbsent(type, ignored -> new Counter(0L));  counter.counter += 1; }
[*] target: assertTrue(result.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( result. isEmpty ( ) )
************************************
************************************
[+] input: test_isDass() { when(settingsService.isCloud()).thenReturn(false); ObjectId taskId = MongoUtils.toObjectId("632454d5287a904778c40f8d"); boolean result = taskService.checkCloudTaskLimit(taskId,user,true); "<AssertPlaceHolder>"; }
checkCloudTaskLimit(ObjectId taskId,UserDetail user,boolean checkCurrentTask){ if (settingsService.isCloud()) { TaskDto task = findByTaskId(taskId,"id",AGENT_ID,"agentTags"); CalculationEngineVo calculationEngineVo = workerService.calculationEngine(task, user, null); int runningNum; if(checkCurrentTask){ runningNum  = subCronOrPlanNum(task, calculationEngineVo.getRunningNum()); }else{ runningNum = calculationEngineVo.getRunningNum(); } if (runningNum >= calculationEngineVo.getTaskLimit()) { return false; } } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: parseBoolean() { final EditorHelper editorHelper = new EditorHelper();  final Object result = editorHelper.edit("boolean", "true"); Assertions."<AssertPlaceHolder>"; }
edit(String type, String newValue) { try { final Class<?> klass = parseType(type); return new Gson().fromJson(newValue, klass); } catch (Exception e) { log.warn("Failed to edit value: {}, {}", type, newValue, e); return null; } }
[*] target: assertEquals(true, result)
[-] pred: org. junit. Assert. assertEquals ( true, result )
************************************
************************************
[+] input: testModifyByIdNormal() { ObjectId id = mock(ObjectId.class); MetadataInstancesDto record = new MetadataInstancesDto(); MetadataInstancesEntity entity = new MetadataInstancesEntity(); doReturn(entity).when(metadataInstancesRepository).save(any(MetadataInstancesEntity.class),any(UserDetail.class)); MetadataInstancesDto actual = metadataInstancesService.modifyById(id, record, userDetail); verify(metadataInstancesService,new Times(2)).beforeCreateOrUpdate(record,userDetail); verify(metadataInstancesService,new Times(1)).beforeUpdateById(id,record); verify(metadataInstancesService,new Times(1)).save(record,userDetail); verify(metadataInstancesService,new Times(1)).afterUpdateById(id,record); "<AssertPlaceHolder>"; }
afterUpdateById(ObjectId id, MetadataInstancesDto data) { }
[*] target: assertEquals(null,actual)
[-] pred: org. junit. Assert. assertEquals ( null, actual )
************************************
************************************
[+] input: decode_ShouldDecodeByteBufferToValueAndReturnAsString() { String valueAsString = "123.456"; BigDecimal value = new BigDecimal(valueAsString); ByteBuffer byteBuffer = TypeCodecs.DECIMAL.encode(value, CqlConversion.PROTOCOL_VERSION);  String result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { BigDecimal decimalValue = TypeCodecs.DECIMAL.decode(bytes, protocolVersion); return decimalValue.toString(); }
[*] target: assertEquals(valueAsString, result)
[-] pred: org. junit. Assert. assertEquals ( valueAsString, result )
************************************
************************************
[+] input: IOException { BilibiliResponse<DynamicFlow> response = client.dynamicNew(Collections.singletonList(8)); Assertions."<AssertPlaceHolder>"; // 需要Cookie }
dynamicNew(List<Integer> typeList) throws IOException { checkBuVid3BuVid4(); String mid = getCookie(BilibiliApiContainer.COOKIE_KEY_USER_ID); String url = ApiUtil.fillUrl(ApiUrlContainer.DYNAMIC_NEW, Long.parseLong(mid), typeList.stream() .map(Object::toString).collect(Collectors.joining(","))); return httpJsonClient.getJson(url, new TypeReference<BilibiliResponse<DynamicFlow>>() { }, requestHeader); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: getCustomerById() { //given Customer customer = new Customer(); customer.setId("1"); customer.setCustomerFullName("John"); customer.setCustomerType("ACTIVE");  CustomerEntity customerEntity = new CustomerEntity(); customerEntity.setId("1"); customerEntity.setCustomerType("ACTIVE"); customerEntity.setCustomerFullName("John");  //when when(customerMapper.toEntity(customer)).thenReturn(customerEntity); when(customerRepository.save(any())).thenReturn(customerEntity); when(customerMapper.toDto(customerEntity)).thenReturn(customer);  Customer customer2 = customerService.createCustomer(customer);  when(customerMapper.toDto(any())).thenReturn(customer); when(customerRepository.findById(anyString())).thenReturn(Optional.of(customerEntity));  Customer customerExample = customerService.getCustomerById("1");  verify(customerRepository, times(1)).findById(anyString());  "<AssertPlaceHolder>"; }
getCustomerById(String id);  /** * update a customer instance in the database * * @param id customer id to be patched. * @param customer customer instance to be updated. Please, see the {@link evrentan.examples.springbootprojectexample.dto.Customer}
[*] target: assertEquals(customerExample, customer2)
[-] pred: org. junit. Assert. assertEquals ( customerExample, customer2 )
************************************
************************************
[+] input: setProperty_String() { String value = "test_value"; String setValue = (String) helper.setProperty(KnownProperties.TEST_STRING, value); "<AssertPlaceHolder>"; }
setProperty(String propertyName, Object propertyValue) { if (null == propertyName || null == propertyValue) return null; PropertyType expectedType = getType(propertyName); if (null == expectedType) { return null; }  boolean typesMatch = validateType(expectedType, propertyValue); if (!typesMatch) return null;  synchronized (PropertyHelper.class) { propertyMap.put(propertyName, propertyValue); } return propertyValue; }
[*] target: assertEquals(value, setValue)
[-] pred: org. junit. Assert. assertEquals ( value, setValue )
************************************
************************************
[+] input: testReplaceBatch() { User user = new User(); user.setId(1L) .setName("张三") .setAge(18) .setCreateTime(LocalDateTime.now()); int replace = commonDaoWrap.replaceBatch(Collections.singletonList(user)); Assertions."<AssertPlaceHolder>"; }
replaceBatch(List<E> list) { if (CollectionUtils.isEmpty(list)) { throw new NonTransientDataAccessResourceException("The list cannot be empty !!!"); } return dao.replaceBatch(list); }
[*] target: assertEquals(2, replace)
[-] pred: org. junit. Assert. assertEquals ( 2, replace )
************************************
************************************
[+] input: givenMultipleEmtpyAndNonEmptyLinesToIndent() { List<String> toVerify = toTest() .withBody("Line 1", "", "Line 2") .getBodyGenerator() .indent() .indent() .lines();  List<String> expected = asList( "        Line 1", "", "        Line 2" );  "<AssertPlaceHolder>"; }
lines() { return lines; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testAListSizeLessThanAbListSize() { List<String> mockA = mock(List.class); when(mockA.size()).thenReturn(1); List<String> mockB = mock(List.class); when(mockB.size()).thenReturn(2); when(b.getAgentIds()).thenReturn(mockB); when(a.getAgentIds()).thenReturn(mockA); int count = agentGroupUtil.sortAgentGroup(a, b); Assertions."<AssertPlaceHolder>"; }
sortAgentGroup(AgentGroupEntity a, AgentGroupEntity b) { List<String> agentIdsOfA = a.getAgentIds(); List<String> agentIdsOfB = b.getAgentIds(); if (null == agentIdsOfA && null == agentIdsOfB) { return 0; } if (null == agentIdsOfA) { return 1; } if (null == agentIdsOfB) { return -1; } return agentIdsOfB.size() - agentIdsOfA.size(); }
[*] target: assertEquals(1, count)
[-] pred: org. junit. Assert. assertEquals ( 1, count )
************************************
************************************
[+] input: testNullKeys() { when(scheduleUtil.whereForSettings(null)).thenCallRealMethod(); Query query = scheduleUtil.whereForSettings(null); Assertions."<AssertPlaceHolder>"; }
whereForSettings(String[] keys) { if (null == keys || keys.length == 0) return new Query(); return new Query(Criteria.where("key").in(keys)); }
[*] target: assertNotNull(query)
[-] pred: org. junit. Assert. assertNotNull ( query )
************************************
************************************
[+] input: testPrepareSyncGetMemorySizeHandler() { SyncGetMemorySizeHandler handler = observableAspectTask.prepareSyncGetMemorySizeHandler(); Assertions."<AssertPlaceHolder>"; }
prepareSyncGetMemorySizeHandler() { return new SyncGetMemorySizeHandler(new AtomicLong(-1)); }
[*] target: assertNotNull(handler)
[-] pred: org. junit. Assert. assertNotNull ( handler )
************************************
************************************
[+] input: testCategorization2SectionsMixed() {  UISchemaBuilder builder = new UISchemaBuilder(Layout.CATEGORIZATION);  Map<String, String> multilineOption = new HashMap<>(); multilineOption.put("multi", "true"); builder. // addCategory("General"). // addLayout(Layout.HORIZONTAL). // addElements("name"). // addElement("documentation", "Documentation", multilineOption). //  addLayout(Layout.VERTICAL). // addElements(new String[] { "age", "city" }). //  addCategory("Event"). // addLayout(Layout.VERTICAL). // addElements(new String[] { "a", "b" }). //  addCategory("Workflow"). // addLayout(Layout.HORIZONTAL);  String json = builder.build();  "<AssertPlaceHolder>";  logger.info(json);  }
build() {  // close current controllsBuilder.... if (controlsArrayBuilder != null && layoutContext != null) { layoutContext.add("elements", controlsArrayBuilder.build()); }  if (groupArrayBuilder != null) {  // close current layoutContext.... if (layoutsArrayBuilder != null && layoutContext != null) { this.layoutsArrayBuilder.add(layoutContext.build()); }  // close current gourpContext if (groupContext != null) { groupContext.add("elements", layoutsArrayBuilder.build()); groupArrayBuilder.add(groupContext); }  rootLayoutBuilder.add("elements", groupArrayBuilder.build()); }  // write result JsonObject jsonObject = rootLayoutBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: testDeserializeWithHeaders() {  CollectRep.MetricsData expectedMetricsData = CollectRep.MetricsData.newBuilder() .setMetrics("someValue") .setApp("linux") .build(); byte[] bytes = expectedMetricsData.toByteArray();  CollectRep.MetricsData actualMetricsData = deserializer.deserialize("topic", headers, bytes);  "<AssertPlaceHolder>"; }
deserialize(String topic, Headers headers, byte[] data) { return Deserializer.super.deserialize(topic, headers, data); }
[*] target: assertEquals(expectedMetricsData, actualMetricsData)
[-] pred: org. junit. Assert. assertEquals ( expectedMetricsData, actualMetricsData )
************************************
************************************
[+] input: getUriTest() { when(request.url()).thenReturn(HttpUrl.get("http://localhost")); URI actResult = okHttpClientAdapter.getUri(); Assertions."<AssertPlaceHolder>"; }
getUri() { return this.httpRequest.url().uri(); }
[*] target: assertNotNull(actResult)
[-] pred: org. junit. Assert. assertNotNull ( actResult )
************************************
************************************
[+] input: testCreated() { Date date = new Date(); Vulnerability vuln = new Vulnerability(); vuln.setCreated(date); Assertions."<AssertPlaceHolder>"; }
getCreated() { return created; }
[*] target: assertEquals(date, vuln.getCreated())
[-] pred: org. junit. Assert. assertEquals ( date, vuln. getCreated() )
************************************
************************************
[+] input: givenTypeParameterName() { String toVerify = toTest() .withType(T) .getObjectPathOrTypeGenerator() .generate();  String expected = "T";  "<AssertPlaceHolder>"; }
generate() { Optional<String> optionalObjectPathAsString = optionalObjectPathGenerator.map(ObjectPathGenerator::generate); Optional<String> optionalConcreteTypeAsString = optionalConcreteType.map(FullyQualifiedName::raw); Optional<String> optionalGenericTypeAsString = optionalGenericType.map(TypeParameterName::raw); return optionalObjectPathAsString .map(Optional::of).orElse(optionalConcreteTypeAsString) .map(Optional::of).orElse(optionalGenericTypeAsString) .orElseThrow(NullPointerException::new); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testSaveHostServiceRoleMapping() { // Setup final HostServiceRoleMapping hostServiceRoleMapping = new HostServiceRoleMapping(); hostServiceRoleMapping.setHost("host"); hostServiceRoleMapping.setServiceRoles(Arrays.asList("value")); final List<HostServiceRoleMapping> list = Arrays.asList(hostServiceRoleMapping); final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  // Configure ClusterInfoService.getById(...). final ClusterInfoEntity clusterInfoEntity = new ClusterInfoEntity(); clusterInfoEntity.setId(0); clusterInfoEntity.setCreateBy("createBy"); clusterInfoEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterInfoEntity.setClusterName("clusterName"); clusterInfoEntity.setClusterCode("clusterCode"); clusterInfoEntity.setClusterFrame("clusterFrame"); clusterInfoEntity.setFrameVersion("frameVersion"); clusterInfoEntity.setClusterState(ClusterState.RUNNING); clusterInfoEntity.setFrameId(0); final UserInfoEntity userInfoEntity = new UserInfoEntity(); userInfoEntity.setId(0); userInfoEntity.setUsername("username"); userInfoEntity.setPassword("password"); userInfoEntity.setEmail("email"); userInfoEntity.setPhone("phone"); clusterInfoEntity.setClusterManagerList(Arrays.asList(userInfoEntity)); when(mockClusterInfoService.getById(0)).thenReturn(clusterInfoEntity);  // Run the test final Result result = serviceInstallServiceImplUnderTest.saveHostServiceRoleMapping(0, list);  // Verify the results "<AssertPlaceHolder>"; }
saveHostServiceRoleMapping(Integer clusterId, List<HostServiceRoleMapping> list) { ClusterInfoEntity clusterInfo = clusterInfoService.getById(clusterId); HashMap<String, List<String>> map = new HashMap<>(); for (HostServiceRoleMapping hostServiceRoleMapping : list) { map.put(hostServiceRoleMapping.getHost(), hostServiceRoleMapping.getServiceRoles()); } CacheUtils.put( clusterInfo.getClusterCode() + Constants.UNDERLINE + Constants.HOST_SERVICE_ROLE_MAPPING, map); return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testReplay() { Mockito.when(httpClientExtractor.replay()).thenReturn(MockResult.success("mock")); MockResult result = okHttpCallbackWrapper.replay(); "<AssertPlaceHolder>"; }
replay() { return extractor.replay(); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testResolveArchiveFile() { ClassLoader classLoader = ClassLoader.getSystemClassLoader(); URL resourceURL = ClassLoaderUtils.getClassResource(classLoader, Nonnull.class); File archiveFile = URLUtils.resolveArchiveFile(resourceURL); "<AssertPlaceHolder>"; }
resolveArchiveFile(URL resourceURL) throws NullPointerException { String protocol = resourceURL.getProtocol(); if (FILE_PROTOCOL.equals(protocol)) { return resolveArchiveDirectory(resourceURL); } else { return doResolveArchiveFile(resourceURL); } }
[*] target: assertTrue(archiveFile.exists())
[-] pred: org. junit. Assert. assertTrue ( archiveFile. exists ( ) )
************************************
************************************
[+] input: getWorkbook() {  WorkbookContext workbookContext = this.getWorkbookContext(); Assertions."<AssertPlaceHolder>"; }
getWorkbook() { if (workbook == null) { this.workbook = this.createWorkbook(); } return workbook; }
[*] target: assertNotNull(workbookContext.getWorkbook())
[-] pred: org. junit. Assert. assertNotNull ( workbookContext. getWorkbook() )
************************************
************************************
[+] input: 피드백_생성() { AuthInfo authInfo = new AuthInfo(1L, List.of(Role.USER));  FeedbackRequest request = new FeedbackRequest("피드백 본문", 1); Long useerId = 1L;  UserDetailResponse user = new UserDetailResponse( 1L, "테스트", "test@gmail.com", "aslkdjalsdj", 1 );  Feedback feedback = Feedback.builder() .content("피드백 본문") .score(Score.ONE_STAR) .userId(1L) .build();  Mockito.when(userService.findById(authInfo.userId())) .thenReturn(user);  Mockito.when(feedbackService.create(request, useerId)) .thenReturn(feedback);  FeedbackResponse expected = new FeedbackResponse(feedback, user);  FeedbackResponse actual = feedbackFacade.create(request, authInfo);  "<AssertPlaceHolder>"; }
create(FeedbackRequest request, AuthInfo info) { var user = userService.findById(info.userId());  var feedback = feedbackService.create(request, info.userId());  var feedbackResponse = new FeedbackResponse(feedback, user);  var response = new SlackCruiserResponse.FeedbackStaticsResponse(feedbackResponse);  cruiser.send(new CruiserRequest(response.message()));  return feedbackResponse; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: getConsumerAclsTeamsOverview() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when( handleDbRequestsJdbc.getAclsCountByTeams( AclType.CONSUMER.value, TestConstants.TEAM_ID, TestConstants.TENANT_ID)) .thenReturn(Collections.emptyList()); Mockito.when( manageDatabase.getTeamNameFromTeamId(TestConstants.TENANT_ID, TestConstants.TEAM_ID)) .thenReturn(TestConstants.TEAM_NAME); Mockito.when( commonUtilsService.getChartsJsOverview( eq(Collections.emptyList()), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getConsumerAclsTeamsOverview( TestConstants.TEAM_ID, TestConstants.TENANT_ID);  Assertions."<AssertPlaceHolder>"; }
getConsumerAclsTeamsOverview(Integer teamId, Integer tenantId) { List<CommonUtilsService.ChartsOverviewItem<Integer, Integer>> consumerAclsPerTeamList = manageDatabase .getHandleDbRequests() .getAclsCountByTeams(AclType.CONSUMER.value, teamId, tenantId);  String title = ANALYTICS_102; if (teamId != null) { title += " (" + manageDatabase.getTeamNameFromTeamId(tenantId, teamId) + ")"; } else { title += " (all teams)"; }  return commonUtilsService.getChartsJsOverview( consumerAclsPerTeamList, title, "teamid", "Teams", "Consumer Acls", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: lambdaWithSingleExpressionAsMultipleLines() { List<String> toVerify = lambda() .withParameterNames("capacity", "hasPower") .withExpression("new Device(capacity, hasPower)") .multiline();  List<String> expected = asList( "(capacity, hasPower) ->", "        new Device(capacity, hasPower)" );  "<AssertPlaceHolder>"; }
multiline() { return asList( generateParameterList() + SPACE + ARROW, INDENT + INDENT + expression ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: loadSchemaTest() { List<Schema> schemaList = migrateProcessorNode.loadSchema(null); "<AssertPlaceHolder>"; }
loadSchema(List<String> includes) { return null; }
[*] target: assertEquals(null,schemaList)
[-] pred: org. junit. Assert. assertEquals ( null, schemaList )
************************************
************************************
[+] input: shouldFindCreditCardActivityBetweenDates() {  CrdCreditCardActivity crdCreditCardActivity = mock(CrdCreditCardActivity.class); List<CrdCreditCardActivity> crdCreditCardActivityList = new ArrayList<>(); crdCreditCardActivityList.add(crdCreditCardActivity);  Long id =1L; LocalDateTime startDate =LocalDateTime.now().minusDays(1); LocalDateTime endDate =LocalDateTime.now().plusMonths(1);  when(crdCreditCardActivityEntityService.findCreditCardActivityBetweenDates( id,startDate,endDate) ).thenReturn(crdCreditCardActivityList);  List<CrdCreditCardActivityDto> result = crdCreditCardService.findCreditCardActivityBetweenDates( id,LocalDate.now(),LocalDate.now().plusMonths(24));  "<AssertPlaceHolder>"; }
findCreditCardActivityBetweenDates(Long creditCardId, LocalDate startDate, LocalDate endDate) {  LocalDateTime startDateTime = startDate.atStartOfDay(); LocalDateTime endDateTime   = endDate.atStartOfDay();  List<CrdCreditCardActivity> crdCreditCardActivityList;  crdCreditCardActivityList = crdCreditCardActivityEntityService .findCreditCardActivityBetweenDates(creditCardId,startDateTime,endDateTime);   List<CrdCreditCardActivityDto> crdCreditCardActivityDtoList = CrdCreditCardMapper.INSTANCE.convertToCrdCreditCardActivityDtoList(crdCreditCardActivityList);  return crdCreditCardActivityDtoList; }
[*] target: assertEquals(1, result.size())
[-] pred: org. junit. Assert. assertEquals ( 1, result. size ( ) )
************************************
************************************
[+] input: array() { ArrayType expected = new ArrayType(STRING_TYPE); ArrayType toVerify = STRING_TYPE.array();  "<AssertPlaceHolder>"; }
array() { return array(this); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: calculateCodonStartIndicesFrame3Test() { int[] expectedResult = {2, 5, 8, 11, 14, 17, 20}; CodonFrame temp = new CodonFrame(TEST_SEQUENCE, (short) 3, 1, 100); ReadingFrames readingFrameTest = new ReadingFrames(temp); int[] result = readingFrameTest.calculateCodonStartIndices(TEST_SEQUENCE); "<AssertPlaceHolder>"; }
calculateCodonStartIndices(final String dna) { int[] codonStartIndices; // calculate max total codons possible final int maxTotalCodons = dna.length() / 3; // reading frame is 1-index based. Calculate offset for 0-index array. final int offset = this.codonFrame.getReadingFrame() - 1; int[] indexArray = IntStream.range(0, maxTotalCodons).map(index -> (index * 3 + offset)).toArray();  // if the last codon index is not 3 positions away from end, remove last index. if (dna.length() - indexArray[indexArray.length - 1] < 3) { codonStartIndices = Arrays.stream(indexArray).limit(indexArray.length - 1).toArray(); } else { codonStartIndices = indexArray; }  return codonStartIndices; }
[*] target: assertArrayEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedResult, result )
************************************
************************************
[+] input: isPositive_AllGood_IsPositive() { final var candidate = 10; final var isPositive = subject.isPositive(candidate);  "<AssertPlaceHolder>"; }
isPositive(final Integer candidate) { return candidate != null && candidate > 0; }
[*] target: assertTrue(isPositive)
[-] pred: org. junit. Assert. assertTrue ( isPositive )
************************************
************************************
[+] input: 인물_TOP30_조회() { // given var characters = new ArrayList<Character>(); var responses = new ArrayList<CharacterResponse.CharacterDetailResponse>(); for(int i = 0; i < 30; i++) { var character = Character.builder() .name("디프만 1번 출구") .type(CharacterType.PERSONA) .webtoonId(1L) .build(); characters.add(character); responses.add(new CharacterResponse.CharacterDetailResponse( character, "테스트.png", "테스트", false )); }  var webtoon = Webtoon.builder() .title("테스트") .content("테스트") .webtoonUrl("http://테스트") .thumbnail("테스트.png") .platform(Platform.KAKAO) .build();  var mockCharacterImage = CharacterImage.builder() .characterId(1L) .type(CharacterImageType.PERSONA) .imageUrl("테스트.png") .build();  AuthInfo mockInfo = new AuthInfo(USER_ID, List.of(Role.USER));  Mockito.when(characterService.getCharactersByTopUpper(any())) .thenReturn(characters);  Mockito.when(webtoonService.findById(anyLong())) .thenReturn(webtoon);  Mockito.when(characterImageService.findByCharacterIdAndType(any(), any())) .thenReturn(mockCharacterImage);  Mockito.when(characterHistoryService.isUserJoin(any(), any())) .thenReturn(false);  var expected = new CharacterResponse(responses); // when var actual = characterFacade.getTopUpper("PERSONA", mockInfo); // then "<AssertPlaceHolder>"; }
getTopUpper(String type, AuthInfo info) { var responses = characterService.getCharactersByTopUpper(CharacterType.valueOf(type)) .stream() .map(character -> { var webtoon = webtoonService.findById(character.getWebtoonId()); var characterImage = characterImageService.findByCharacterIdAndType( character.getId(), CharacterImageType.valueOf(type) );  return new CharacterResponse.CharacterDetailResponse( character, characterImage.getImageUrl(), webtoon.getTitle(), characterHistoryService.isUserJoin(character.getId(), info) ); }).toList();  return new CharacterResponse(responses); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: largePrimitiveData() { final int MAX_BLOCK_SIZE = 1024; byte[] primitiveData = new byte[MAX_BLOCK_SIZE + 10]; // Generate some test data for (int i = 0; i < primitiveData.length; i++) { primitiveData[i] = (byte) i; }  byte[] actualData = SerialBuilder.startSerializableObject() .beginDescriptorHierarchy() .beginDescriptor() .typeWithUid(ClassWithWriteObjectWritingPrimitiveArray.class) .flags(SC_SERIALIZABLE | SC_WRITE_METHOD) .endDescriptor() .endDescriptorHierarchy() .beginSlots() .beginSlot() .writeObjectWith(writer -> { // Create copy of array to prevent accidental modification writer.write(primitiveData.clone()); }) .endSlot() .endSlots() .endObject();  byte[] expectedData = serialize(new ClassWithWriteObjectWritingPrimitiveArray(primitiveData)); "<AssertPlaceHolder>"; }
startSerializableObject() { return startSerializableObject(new Handle()); }
[*] target: assertArrayEquals(expectedData, actualData)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedData, actualData )
************************************
************************************
[+] input: testTransformFromTapValueNullTapdataEvent() { HazelcastBaseNode.TapValueTransform actual = hazelcastBaseNode.transformFromTapValue(null); "<AssertPlaceHolder>"; }
transformFromTapValue(TapdataEvent tapdataEvent) { if (null == tapdataEvent) return null; if (null == tapdataEvent.getTapEvent()) return null; TapEvent tapEvent = tapdataEvent.getTapEvent(); TapValueTransform tapValueTransform = TapValueTransform.create(); Map<String, Object> before = TapEventUtil.getBefore(tapEvent); if (MapUtils.isNotEmpty(before)) { tapValueTransform.before(codecsFilterManager.transformFromTapValueMap(before)); } Map<String, Object> after = TapEventUtil.getAfter(tapEvent); if (MapUtils.isNotEmpty(after)) { tapValueTransform.after(codecsFilterManager.transformFromTapValueMap(after)); } return tapValueTransform; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: try { Object innerValue = 1; Value value = new Value(innerValue); "<AssertPlaceHolder>"; } catch (Exception e) { fail("No exception expected."); }
asInteger() { if (this.isNumber() && !this.isNull()) { return ((Number)this.innerObject).intValue(); } return null; }
[*] target: assertEquals(innerValue, value.asInteger())
[-] pred: org. junit. Assert. assertEquals ( innerValue, value. asInteger ( ) )
************************************
************************************
[+] input: Exception {  RemotePreferenceStore.setTwoMockRemoteServers(); HelpPlugin.getTocManager().clearCache(); boolean hasDuplicates=hasDuplicateContributions(HelpPlugin.getTocManager().getTocContributions("en")); "<AssertPlaceHolder>"; }
getTocContributions(String locale) { return getAndCacheTocContributions(locale, tocContributionsByLocale); }
[*] target: assertFalse(hasDuplicates)
[-] pred: org. junit. Assert. assertFalse ( hasDuplicates )
************************************
************************************
[+] input: arrayGivenElementType() { ArrayType expected = new ArrayType(STRING_TYPE); ArrayType toVerify = Type.array(STRING_TYPE);  "<AssertPlaceHolder>"; }
array(Type type) { return ArrayType.of(type); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testCloseOneWebHookByHookId() { WebHookInfoVo vo = new WebHookInfoVo(); when(webHookController.success(vo)).thenReturn(mock(ResponseMessage.class)); List mock = mock(List.class); when(mock.isEmpty()).thenReturn(false); when(mock.get(0)).thenReturn(vo); when(webHookService.reOpen(any(String[].class), any(UserDetail.class))).thenReturn(mock); when(webHookController.reOpenOne("id")).thenCallRealMethod(); ResponseMessage<WebHookInfoVo> hook = webHookController.reOpenOne("id"); Assertions."<AssertPlaceHolder>"; verify(webHookController).success(vo); verify(webHookService).reOpen(any(String[].class), any(UserDetail.class)); }
reOpenOne(@PathVariable(value = "id") String hookId) { List<WebHookInfoVo> closed = webHookService.reOpen(new String[]{hookId}, getLoginUser()); if (closed.isEmpty()) { return failed("webhook.reOpen.failed"); } return success(closed.get(0)); }
[*] target: assertNotNull(hook)
[-] pred: org. junit. Assert. assertNotNull ( hook )
************************************
************************************
[+] input: validateGivenPrivateMethod() { Method toValidate = Method.of( emptySet(), modifiers(PRIVATE), asList(T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter()), Optional.of(OPTIONAL.with(V)), "myFunction", asList( Parameter.of(OPTIONAL.with(T), "left"), Parameter.of(OPTIONAL.with(U), "right"), Parameter.of(BI_FUNCTION.with(T.asType().contravariant(), U.asType().contravariant(), V.asType().covariant()), "compose") ) );  Validated<String, AccumulatorValidator.Result> expected = Validated.invalid("Method needs to be public to implement an abstract method"); Validated<String, AccumulatorValidator.Result> toVerify = AccumulatorValidator.validate(toValidate, new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
validate(Method method, ParametersAndTypeParametersValidator parametersAndTypeParametersValidator) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages); ParametersAndTypeParametersValidator.Result parametersAndTypeParameters = verifyParametersAndTypeParameters(method, parametersAndTypeParametersValidator, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  // Assign a meaningful name to each of the (three) type parameters: TypeParameter leftInputTypeConstructorArgument = parametersAndTypeParameters.getLeftInputTypeConstructorArgument(); TypeParameter rightInputTypeConstructorArgument = parametersAndTypeParameters.getRightInputTypeConstructorArgument(); TypeParameter returnTypeConstructorArgument = parametersAndTypeParameters.getReturnTypeConstructorArgument();  // Assign a meaningful name to the left and right parameters: Type leftParameterType = parametersAndTypeParameters.getLeftParameterType(); Type rightParameterType = parametersAndTypeParameters.getRightParameterType();  String name = method.getName();  TypeConstructor accumulatedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(returnTypeConstructorArgument.getName()); TypeConstructor partiallyAccumulatedTypeConstructor = leftParameterType.asTypeConstructorWithPlaceholderFor(leftInputTypeConstructorArgument.getName()); TypeConstructor inputTypeConstructor = rightParameterType.asTypeConstructorWithPlaceholderFor(rightInputTypeConstructorArgument.getName());  if (!partiallyAccumulatedTypeConstructor.canAccept(accumulatedTypeConstructor)) { // Tweak the error message to not confuse people using the simple case where // parameter types and result type should be identical: if (Objects.equals(partiallyAccumulatedTypeConstructor, inputTypeConstructor)) { return Validated.invalid("No shared type constructor between parameters (" + generateFrom(leftParameterType) + " and " + generateFrom(rightParameterType) + ") and result (" + generateFrom(returnType) + ")"); } else { return Validated.invalid("No shared type constructor between first parameter (" + generateFrom(leftParameterType) + ") and result (" + generateFrom(returnType) + ")"); } }  verifyNoCrossReferences(method.getTypeParameters(), leftParameterType, partiallyAccumulatedTypeConstructor, "type of the first parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), rightParameterType, inputTypeConstructor, "type of the second parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), returnType, accumulatedTypeConstructor, "return type", errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  return Validated.valid( AccumulatorValidator.Result.of( name, inputTypeConstructor, partiallyAccumulatedTypeConstructor, accumulatedTypeConstructor, leftParameterType, rightParameterType, returnType ) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testContinueUnknownSession() { var sessions = new MemorySessions();  var auth_id = "unknown"; try { "<AssertPlaceHolder>"; } catch (SessionManagerException e) { fail(ExceptionUtils.getExceptionStackTrace(e)); } }
continueSession(String authId) throws SessionManagerException { if (null == authId || authId.isEmpty()) { return false; }  return null != sessions_.computeIfPresent(authId, (s, session) -> { session.setStart(System.currentTimeMillis()); return session; }); }
[*] target: assertFalse(sessions.continueSession(auth_id))
[-] pred: org. junit. Assert. assertFalse ( sessions. continueSession ( auth_id ) )
************************************
************************************
[+] input: 좋아요_숫자_카운팅_UP() { discussion.updateLikeCount(true); int actual = discussion.getLikeCount();  "<AssertPlaceHolder>"; }
updateLikeCount(Boolean flag) { if (flag) { this.likeCount += 1; } else if (likeCount > 0) { this.likeCount -= 1; } }
[*] target: assertEquals(1, actual)
[-] pred: org. junit. Assert. assertEquals ( 1, actual )
************************************
************************************
[+] input: test11() { String str = "中国"; byte[] utf16 = str.getBytes(StandardCharsets.UTF_16LE); JSONWriter jsonWriter = JSONWriter.ofJSONB(); jsonWriter.writeStringUTF16(utf16); byte[] jsonb = jsonWriter.getBytes(); Object parsed = JSONB.parse(jsonb); "<AssertPlaceHolder>"; }
getBytes();  public abstract byte[] getBytes(Charset charset);  public void flushTo(java.io.Writer to) { try { String json = this.toString(); to.write(json); off = 0; } catch (IOException e) { throw new JSONException("flushTo error", e); } }
[*] target: assertEquals(str, parsed)
[-] pred: org. junit. Assert. assertEquals ( str, parsed )
************************************
************************************
[+] input: setOneBelow() { set.set(1); final int ret = set.previousSetBit(2);  "<AssertPlaceHolder>"; }
previousSetBit(int fromIndex);  /** * Returns the index of the nearest bit that is set to {@code false}
[*] target: assertEquals(1, ret)
[-] pred: org. junit. Assert. assertEquals ( 1, ret )
************************************
************************************
[+] input: testQueryMonitorMetricsData() {  Long monitorId = 1L; List<CollectRep.MetricsData> expectedData = Collections.emptyList();  when(realTimeDataStorage.isServerAvailable()).thenReturn(true); when(realTimeDataStorage.getCurrentMetricsData(monitorId)).thenReturn(expectedData);  List<CollectRep.MetricsData> result = warehouseService.queryMonitorMetricsData(monitorId);  "<AssertPlaceHolder>"; verify(realTimeDataStorage, never()).isServerAvailable(); }
queryMonitorMetricsData(Long monitorId);
[*] target: assertEquals(expectedData, result)
[-] pred: org. junit. Assert. assertEquals ( expectedData, result )
************************************
************************************
[+] input: parse_ShouldParseStringToBigDecimalValue() { String stringValue = "12345.6789"; BigDecimal expectedValue = TypeCodecs.DECIMAL.parse(stringValue); BigDecimal result = codec.parse(stringValue); Assertions."<AssertPlaceHolder>"; }
parse(String value) { return value == null ? null : new BigDecimal(value); }
[*] target: assertEquals(expectedValue, result)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, result )
************************************
************************************
[+] input: getTopicsEnvOverview() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when(handleDbRequestsJdbc.getTopicsCountByEnv(TestConstants.TENANT_ID)) .thenReturn(TestConstants.TOPICS_COUNT_STRING_BY_ENV_ID_INT); Mockito.when(commonUtilsService.getEnvsFromUserId(any())) .thenReturn(Set.of(TestConstants.ENV_ID)); Mockito.when( commonUtilsService.getChartsJsOverview( anyList(), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getTopicsEnvOverview( TestConstants.TENANT_ID, Mockito.mock(PermissionType.class));  Assertions."<AssertPlaceHolder>"; }
getTopicsEnvOverview(Integer tenantId, PermissionType permissionType) { List<CommonUtilsService.ChartsOverviewItem<String, Integer>> teamCountList = manageDatabase.getHandleDbRequests().getTopicsCountByEnv(tenantId);  // tenant filtering try { final Set<String> allowedEnvIdSet = commonUtilsService.getEnvsFromUserId(getCurrentUserName()); if (teamCountList != null) { teamCountList = teamCountList.stream() .filter(mapObj -> allowedEnvIdSet.contains(mapObj.getxValue())) .collect(Collectors.toList()); teamCountList = teamCountList.stream() .map(item -> item.transformX(this::getEnvName)) .collect(Collectors.toList()); } } catch (Exception e) { log.error("No environments/clusters found.", e); teamCountList = new ArrayList<>(); }  return commonUtilsService.getChartsJsOverview( teamCountList, ANALYTICS_104, MapConstants.CLUSTER_KEY, "Clusters", "Topics", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testTryEmit() { when(mockOutBox.offer(any(TapdataEvent.class))).thenReturn(true); boolean actual = hazelcastBaseNode.tryEmit(tapdataEvent, 1); "<AssertPlaceHolder>"; }
tryEmit(TapdataEvent dataEvent, int bucketCount) { if (null == dataEvent) { return true; } if (bucketCount > 1) { for (bucketIndex = Math.min(bucketIndex, bucketCount); bucketIndex < bucketCount; bucketIndex++) { TapdataEvent cloneEvent = (TapdataEvent) dataEvent.clone(); if (!tryEmit(bucketIndex, cloneEvent)) { return false; } } } else { return tryEmit(dataEvent); } return true; }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: MessagingException { when(mu.connectSMTP(any(Session.class))).thenCallRealMethod(); doCallRealMethod().when(mu).closeTransport(any(Transport.class)); doNothing().when(transport).connect(anyString(), anyInt(), anyString(), anyString()); doNothing().when(mu).initMailConfig(); doAnswer(a -> { throw new MessagingException(""); }).when(transport).close(); doNothing().when(transport).sendMessage(any(MimeMessage.class), any(Address[].class)); Session session = mock(Session.class); InternetAddress[] internetAddressList = new InternetAddress[0]; Address[] addresses = new Address[0]; doNothing().when(session).setDebug(true); when(session.getTransport("smtp")).thenReturn(transport); try(MockedStatic<Session> s = mockStatic(Session.class); MockedConstruction<InternetAddress> i = mockConstruction(InternetAddress.class, (ic, c) -> {}); MockedConstruction<MimeMessage> m = mockConstruction(MimeMessage.class, (mk,c) -> { doNothing().when(mk).setFrom(any(InternetAddress.class)); doNothing().when(mk).setRecipients(Message.RecipientType.TO, internetAddressList); doNothing().when(mk).setContent(anyString(), anyString()); doNothing().when(mk).setSentDate(any(Date.class)); doNothing().when(mk).saveChanges(); when(mk.getAllRecipients()).thenReturn(addresses); })) { s.when(() -> Session.getDefaultInstance(any(Properties.class))).thenReturn(session); SendStatus sendStatus = mu.sendValidateCodeForResetPWD("", "", ""); Assertions."<AssertPlaceHolder>"; } }
sendValidateCodeForResetPWD(String to, String username, String validateCode) { SendStatus sendStatus = new SendStatus(SEND_STATUS_FALSE, ""); String html = readHtmlToString("resetPasswordTemplate.html"); Document doc = Jsoup.parse(html); doc.getElementById(USER_NAME).html(username); doc.getElementById("code").html(validateCode); doc.getElementById("account").html(to); doc.getElementById("validateTimes").html("5"); sendEmail(doc, sendStatus, Lists.newArrayList(to), "修改密码-验证码", "Send validate code email failed before reset password"); return sendStatus; }
[*] target: assertNotNull(sendStatus)
[-] pred: org. junit. Assert. assertNotNull ( sendStatus )
************************************
************************************
[+] input: calculateCodonStartIndicesUsingDnaSequenceWithLengthTwentyThreeFrame3Test() { int[] expectedResult = {2, 5, 8, 11, 14, 17, 20}; String testSequence = DNA_SEQUENCE_WITH_LENGTH_TWENTY_THREE; CodonFrame temp = new CodonFrame(testSequence, (short) 3, 1, 100); ReadingFrames readingFrameTest = new ReadingFrames(temp); int[] result = readingFrameTest.calculateCodonStartIndices(testSequence); "<AssertPlaceHolder>"; }
calculateCodonStartIndices(final String dna) { int[] codonStartIndices; // calculate max total codons possible final int maxTotalCodons = dna.length() / 3; // reading frame is 1-index based. Calculate offset for 0-index array. final int offset = this.codonFrame.getReadingFrame() - 1; int[] indexArray = IntStream.range(0, maxTotalCodons).map(index -> (index * 3 + offset)).toArray();  // if the last codon index is not 3 positions away from end, remove last index. if (dna.length() - indexArray[indexArray.length - 1] < 3) { codonStartIndices = Arrays.stream(indexArray).limit(indexArray.length - 1).toArray(); } else { codonStartIndices = indexArray; }  return codonStartIndices; }
[*] target: assertArrayEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedResult, result )
************************************
************************************
[+] input: bind_withWritetime() { when(writetimeTTLFeature.isEnabled()).thenReturn(true); when(writetimeTTLFeature.hasWritetimeColumns()).thenReturn(true); targetUpdateStatement = new TargetUpdateStatement(propertyHelper, targetSession);  BoundStatement result = targetUpdateStatement.bind(originRow, targetRow, null,10000L,null,null); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size()+1)).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { // We reference the originRow and convert it to the target type. // We need the targetRow if (null == originRow) throw new RuntimeException("originRow is null");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue);  BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  Object originValue, targetValue; Object bindValueTarget = null; for (int targetIndex : columnIndexesToBind) { int originIndex = cqlTable.getCorrespondingIndex(targetIndex);  try { if (usingCounter && counterIndexes.contains(targetIndex)) { originValue = cqlTable.getOtherCqlTable().getData(originIndex, originRow); if (null == originValue) { currentBindIndex++; continue; } targetValue = (null == targetRow ? 0L : cqlTable.getData(targetIndex, targetRow)); bindValueTarget = ((Long) originValue - (null == targetValue ? 0L : (Long) targetValue)); } else if (targetIndex== explodeMapKeyIndex) { bindValueTarget = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValueTarget = explodeMapValue; } else { if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValueTarget = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValueTarget, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValueTarget + " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex) + "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex); throw e; } }  PKFactory pkFactory = session.getPKFactory(); EnhancedPK pk = pkFactory.getTargetPK(originRow); boundStatement = pkFactory.bindWhereClause(PKFactory.Side.TARGET, pk, boundStatement, currentBindIndex);  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: oneWaySynonymStrings() { LinkedList<Item> expected = new LinkedList<>(Arrays.asList(item3, item4, item5)); LinkedList<Item> actual = null; try { actual = itemCatalog.oneWaySynonymStrings("Vehicle"); } catch (notFoundException e) { fail(); } boolean equals = true;  for (int i =0; i<expected.size(); i++){ if (expected.get(i)!=actual.get(i)){ equals = false; } }  "<AssertPlaceHolder>"; }
oneWaySynonymStrings(String string) throws notFoundException { LinkedList<Item> subItems = new LinkedList<>(); for(Item item : catalog) { if(item.getName().equalsIgnoreCase(string)){ subItems.addAll(item.getSubItems()); } } if (subItems.size()!=0){ return subItems; } throw new notFoundException("Item not found in database."); }
[*] target: assertTrue(equals)
[-] pred: org. junit. Assert. assertTrue ( equals )
************************************
************************************
[+] input: shouldMaskTime() { try (MockedStatic<Environment> mockedEnvironment = mockStatic(Environment.class)) { mockedEnvironment.when(Environment::getCurrent).thenReturn(env); when(env.getWebforjHelper()).thenReturn(bridge);  LocalTime input = LocalTime.of(14, 30, 15); String mask = "%Hz:%mz:%sz"; String expected = "14:30:15";  double hms = new HoursLocalTimeTransformer().transformToComponent(input); when(bridge.maskDateTime(0, hms, mask)).thenReturn(expected);  String result = MaskDecorator.forTime(input, mask);  "<AssertPlaceHolder>"; } }
forTime(LocalTime input, String mask) { Objects.requireNonNull(input, INPUT_CANNOT_BE_NULL); Objects.requireNonNull(mask, MASK_CANNOT_BE_NULL);  Environment env = Environment.getCurrent(); HoursLocalTimeTransformer transformer = new HoursLocalTimeTransformer(); double hms = transformer.transformToComponent(input);  return env.getWebforjHelper().maskDateTime(0, hms, mask); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testSendNoticeMsgReceiverNull() {  Alert alert = mock(Alert.class); boolean result = dispatcherAlarm.sendNoticeMsg(null, null, alert); "<AssertPlaceHolder>"; }
sendNoticeMsg(NoticeReceiver receiver, NoticeTemplate noticeTemplate, Alert alert) { if (receiver == null || receiver.getType() == null) { log.warn("DispatcherAlarm-sendNoticeMsg params is empty alert:[{}], receiver:[{}]", alert, receiver); return false; } byte type = receiver.getType(); if (alertNotifyHandlerMap.containsKey(type)) { AlertNotifyHandler alertNotifyHandler = alertNotifyHandlerMap.get(type); if (noticeTemplate == null) { noticeTemplate = noticeConfigService.getDefaultNoticeTemplateByType(alertNotifyHandler.type()); } if (noticeTemplate == null) { log.error("alert does not have mapping default notice template. type: {}.", alertNotifyHandler.type()); throw new NullPointerException(alertNotifyHandler.type() + " does not have mapping default notice template"); } alertNotifyHandler.send(receiver, noticeTemplate, alert); return true; } return false; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: shouldSetTitle() { String title = "Test Title"; component.setTitle(title); "<AssertPlaceHolder>"; }
getTitle() { return title; }
[*] target: assertEquals(title, component.getTitle())
[-] pred: org. junit. Assert. assertEquals ( title, component. getTitle() )
************************************
************************************
[+] input: testCreateDir() { // Setup final ClientSession session = null;  // Run the test final boolean result = MinaUtils.createDir(session, "path");  // Verify the results "<AssertPlaceHolder>"; }
createDir(ClientSession session, String path) { SftpFileSystem sftp = null; try { sftp = SftpClientFactory.instance().createSftpFileSystem(session); Path remoteRoot = sftp.getDefaultDir().resolve(path); if (!Files.exists(remoteRoot)) { Files.createDirectories(remoteRoot); return true; } } catch (IOException e) { throw new RuntimeException(e); } return false; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: format_ShouldFormatNumberValueAsText() { Double value = 21474836470.7; String expected = TypeCodecs.DOUBLE.format(value); String result = codec.format(value); Assertions."<AssertPlaceHolder>"; }
format(Double value) { return TypeCodecs.DOUBLE.format(value); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: bind_withTTL() { when(writetimeTTLFeature.isEnabled()).thenReturn(true); when(writetimeTTLFeature.hasTTLColumns()).thenReturn(true); targetUpdateStatement = new TargetUpdateStatement(propertyHelper, targetSession);  BoundStatement result = targetUpdateStatement.bind(originRow, targetRow, 3600,null,null,null); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size()+1)).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { // We reference the originRow and convert it to the target type. // We need the targetRow if (null == originRow) throw new RuntimeException("originRow is null");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue);  BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  Object originValue, targetValue; Object bindValueTarget = null; for (int targetIndex : columnIndexesToBind) { int originIndex = cqlTable.getCorrespondingIndex(targetIndex);  try { if (usingCounter && counterIndexes.contains(targetIndex)) { originValue = cqlTable.getOtherCqlTable().getData(originIndex, originRow); if (null == originValue) { currentBindIndex++; continue; } targetValue = (null == targetRow ? 0L : cqlTable.getData(targetIndex, targetRow)); bindValueTarget = ((Long) originValue - (null == targetValue ? 0L : (Long) targetValue)); } else if (targetIndex== explodeMapKeyIndex) { bindValueTarget = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValueTarget = explodeMapValue; } else { if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValueTarget = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValueTarget, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValueTarget + " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex) + "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex); throw e; } }  PKFactory pkFactory = session.getPKFactory(); EnhancedPK pk = pkFactory.getTargetPK(originRow); boundStatement = pkFactory.bindWhereClause(PKFactory.Side.TARGET, pk, boundStatement, currentBindIndex);  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: getActivityLogOverview_TeamIdNull() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when(manageDatabase.getEnvsOfTenantsMap()) .thenReturn(Map.of(TestConstants.TENANT_ID, List.of(TestConstants.ENV_ID))); Mockito.when( handleDbRequestsJdbc.getActivityLogForLastDays( eq(NUMBER_OF_DAYS), any(), eq(TestConstants.TENANT_ID))) .thenReturn(List.of()); Mockito.when( commonUtilsService.getChartsJsOverview( anyList(), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getActivityLogOverview( null, TestConstants.TENANT_ID, NUMBER_OF_DAYS);  Assertions."<AssertPlaceHolder>"; }
getActivityLogOverview( Integer teamId, Integer tenantId, int numberOfDays) {  List<CommonUtilsService.ChartsOverviewItem<String, Integer>> activityCountList; String title = ANALYTICS_107;  if (teamId != null) { activityCountList = manageDatabase.getHandleDbRequests().getActivityLogByTeam(teamId, numberOfDays, tenantId); title = title + " (" + manageDatabase.getTeamNameFromTeamId(tenantId, teamId) + ")"; } else { // tenant filtering List<String> allowedEnvIdList = manageDatabase.getEnvsOfTenantsMap().get(tenantId);  try { activityCountList = manageDatabase .getHandleDbRequests() .getActivityLogForLastDays( numberOfDays, allowedEnvIdList.toArray(new String[0]), tenantId); } catch (Exception e) { log.error("No environments/clusters found.", e); activityCountList = new ArrayList<>(); } }  return commonUtilsService.getChartsJsOverview( activityCountList, title, "dateofactivity", "Days", "Activities", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(Double value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } else { String stringValue = decimalFormat.format(value); return TypeCodecs.TEXT.encode(stringValue, protocolVersion); } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: from() { JSONArray array = JSONArray.from(Collections.emptyList(), JSONWriter.Feature.NotWriteEmptyArray); "<AssertPlaceHolder>"; }
size() { return list.size(); }
[*] target: assertEquals(0, array.size())
[-] pred: org. junit. Assert. assertEquals ( 0, array. size ( ) )
************************************
************************************
[+] input: isValidUrl_InvalidUrl_IsNotValidUrl() { final var candidate = "abc"; final var isValidUrl = subject.isValidUrl(candidate);  "<AssertPlaceHolder>"; }
isValidUrl(String url) { if (url == null) { return false; } try { new URL(url); return true; } catch (MalformedURLException e) { return false; } }
[*] target: assertFalse(isValidUrl)
[-] pred: org. junit. Assert. assertFalse ( isValidUrl )
************************************
************************************
[+] input: oneSourceToMultipleTargetsTest() { final String tableSchema = TableGenerator.getTableSchemaFromConfig( statement, schema, new ColumnHeader("nonce")); final StringBuilder expectedSchema = new StringBuilder("CREATE TABLE c3rTmp (\n"nonce" TEXT"); for (ColumnSchema column : schema.getColumns()) { expectedSchema.append(",\n"").append(column.getInternalHeader()).append("" TEXT"); } expectedSchema.append(")"); "<AssertPlaceHolder>"; }
getTableSchemaFromConfig(final Statement stmt, final TableSchema schema, final ColumnHeader nonceHeader) { try { final StringBuilder sb = new StringBuilder(); // NOTE: we do not declare the nonce column to be a PRIMARY KEY up front to increase performance // for large numbers of inserts, and instead we later make a UNIQUE INDEX on the nonce // _after_ all the data is loaded. (See `getIndexStatement` in this file). sb.append("CREATE TABLE ").append(DEFAULT_TABLE_NAME) .append(" (\n") .append(stmt.enquoteIdentifier(nonceHeader.toString(), false)) .append(" TEXT"); for (ColumnSchema columnSchema : schema.getColumns()) { sb.append(",\n").append(stmt.enquoteIdentifier(columnSchema.getInternalHeader().toString(), true)).append(" TEXT"); } sb.append(")"); return sb.toString(); } catch (SQLException e) { throw new C3rRuntimeException("Invalid SQL identifier encountered.", e); } }
[*] target: assertEquals(expectedSchema.toString(), tableSchema)
[-] pred: org. junit. Assert. assertEquals ( expectedSchema. toString ( ), tableSchema )
************************************
************************************
[+] input: testSerializeWithNullAlert() {  byte[] bytes = alertSerializer.serialize("", null); "<AssertPlaceHolder>"; }
serialize(String s, Alert alert) { if (alert == null){ return null; } return JsonUtil.toJson(alert).getBytes(); }
[*] target: assertNull(bytes)
[-] pred: org. junit. Assert. assertNull ( bytes )
************************************
************************************
[+] input: testInvalidNextDate() { try { var calendar = Calendar.getInstance(RifeConfig.tools().getDefaultTimeZone(), Localization.getLocale()); calendar.set(2002, Calendar.SEPTEMBER, 1, 10, 0); var calendar_time = calendar.getTimeInMillis(); Frequency frequency = null;  frequency = new Frequency("* * 31 2 *"); try { frequency.getNextTimestamp(calendar_time); fail(); } catch (FrequencyException e) { "<AssertPlaceHolder>"; } } catch (FrequencyException e) { fail(ExceptionUtils.getExceptionStackTrace(e)); } }
getNextTimestamp(long start) throws FrequencyException { if (start < 0) throw new IllegalArgumentException("start should be positive");  var calendar = RifeConfig.tools().getCalendarInstance(); calendar.setTimeInMillis(start);  var minute = calendar.get(Calendar.MINUTE); var hour = calendar.get(Calendar.HOUR_OF_DAY); var date = calendar.get(Calendar.DATE); var month = calendar.get(Calendar.MONTH) + 1; var year = calendar.get(Calendar.YEAR);  // got to next valid time minute++; if (-1 == (minute = getNextValidMinute(minute)) || -1 == hours_[hour] || -1 == months_[month - 1] || -1 == getDates(month, year)[date - 1]) { hour++; if (-1 == (hour = getNextValidHour(hour)) || -1 == months_[month - 1] || -1 == getDates(month, year)[date - 1]) { date++; hour = getFirstValidHour(); } minute = getFirstValidMinute(); }  // got to next valid date while (year < MAX_YEAR) { if (-1 == (date = getNextValidDate(date, month, year)) || -1 == months_[month - 1]) { month++; if (-1 == (month = getNextValidMonth(month))) { year++; month = getFirstValidMonth(); } date = getFirstValidDate(month, year); if (-1 == date) { date = 1; continue; } }  calendar.set(year, month - 1, date, hour, minute);  if (year == calendar.get(Calendar.YEAR) && month == calendar.get(Calendar.MONTH) + 1) { var weekday = calendar.get(Calendar.DAY_OF_WEEK) - 2; if (-1 == weekday) { weekday = 6; }  if (weekdays_[weekday] != -1) { return calendar.getTimeInMillis(); } }  date++; }  throw new FrequencyException("no valid next date available"); }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: testBuildTaskRetryConfigNormal() { TaskConfig taskConfig = mock(TaskConfig.class); doCallRealMethod().when(tapTableMap).buildTaskRetryConfig(taskConfig); tapTableMap.buildTaskRetryConfig(taskConfig); Object actual = ReflectionTestUtils.getField(tapTableMap, "taskConfig"); "<AssertPlaceHolder>"; }
buildTaskRetryConfig(TaskConfig taskConfig){ this.taskConfig = taskConfig; }
[*] target: assertEquals(taskConfig,actual)
[-] pred: org. junit. Assert. assertEquals ( taskConfig, actual )
************************************
************************************
[+] input: ibgeUfsPass() { IBGEUF[] ibgeUfs = BrasilAPI.ibgeUf(); "<AssertPlaceHolder>"; }
ibgeUf() { IBGEUF[] obj = (IBGEUF[]) api(IBGEUF[].class, "ibge/uf/v1", ""); return obj != null ? (IBGEUF[]) obj.clone() : null; }
[*] target: assertNotNull(ibgeUfs)
[-] pred: org. junit. Assert. assertNotNull ( ibgeUfs )
************************************
************************************
[+] input: testHashCode() { PartitionRange partitionRange1 = new PartitionRange(1, 2); PartitionRange partitionRange2 = new PartitionRange(1, 2); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(start, end); }
[*] target: assertEquals(partitionRange1.hashCode(), partitionRange2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( partitionRange1. hashCode(), partitionRange2. hashCode() )
************************************
************************************
[+] input: testShouldTriggerCronBasedSnapshot_NextValidTimeBeforeCurrent() { String cronExpressionString = "0 */10 * * * ?"; // Every 10th minute CronExpression cronExpression = SnapshotUtils.interpretAsCron(cronExpressionString).get();  Calendar calendar = Calendar.getInstance(); calendar.set(2022, Calendar.JUNE, 5, 11, 5); // 11:05  Instant now = calendar.getTime().toInstant(); Instant lastTrigger = now.minus(Duration.ofMinutes(10)); // 10:05, should have fired at 11:00  boolean result = SnapshotUtils.shouldTriggerCronBasedSnapshot( CHECKPOINT, cronExpression, lastTrigger, now);  "<AssertPlaceHolder>"; }
shouldTriggerCronBasedSnapshot( SnapshotType snapshotType, CronExpression cronExpression, Instant lastTriggerDateInstant, Instant nowInstant) { Date now = Date.from(nowInstant); Date lastTrigger = Date.from(lastTriggerDateInstant);  Date nextValidTimeAfterLastTrigger = cronExpression.getNextValidTimeAfter(lastTrigger);  if (nextValidTimeAfterLastTrigger != null && nextValidTimeAfterLastTrigger.before(now)) { LOG.info( "Triggering new automatic {} based on cron schedule '{}' due at {}", snapshotType.toString().toLowerCase(), cronExpression.toString(), nextValidTimeAfterLastTrigger); return true; } else { return false; } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: whenObjectAreSame_ThenEqualsReturnsTrue() { SampleEntitlementId id1 = new SampleEntitlementId("cat", "jit-1");  "<AssertPlaceHolder>"; }
equals(@Nullable Object o) { if (this == o) { return true; }  if (o == null || getClass() != o.getClass()) { return false; }  var that = (EntitlementId) o; return this.catalog().equals(that.catalog()) && this.id().equals(that.id()); }
[*] target: assertTrue(id1.equals(id1))
[-] pred: org. junit. Assert. assertTrue ( id1. equals ( id1 ) )
************************************
************************************
[+] input: testIsUnwindProcess() { hazelcastTargetPdkBaseNode.unwindProcess = true; TapTable tapTable = mock(TapTable.class); AtomicBoolean atomicBoolean = new AtomicBoolean(false); doCallRealMethod().when(hazelcastTargetPdkBaseNode).createTable(tapTable, atomicBoolean,true); TableNode node = new TableNode(); node.setDisabled(false); when(hazelcastTargetPdkBaseNode.getNode()).thenReturn((Node) node); ConnectorNode connectorNode = mock(ConnectorNode.class); when(hazelcastTargetPdkBaseNode.getConnectorNode()).thenReturn(connectorNode); ConnectorFunctions connectorFunctions = mock(ConnectorFunctions.class); when(connectorNode.getConnectorFunctions()).thenReturn(connectorFunctions); when(connectorFunctions.getCreateTableFunction()).thenReturn(null); when(connectorFunctions.getCreateTableV2Function()).thenReturn(mock(CreateTableV2Function.class)); Connections connections = new Connections(); connections.setId("test"); when(dataProcessorContext.getTargetConn()).thenReturn(connections); boolean result = hazelcastTargetPdkBaseNode.createTable(tapTable, atomicBoolean,true); Assertions."<AssertPlaceHolder>"; }
createTable(TapTable tapTable, AtomicBoolean succeed,boolean init) { if (getNode().disabledNode()) { obsLogger.info("Target node has been disabled, task will skip: create table"); return false; } AtomicReference<TapCreateTableEvent> tapCreateTableEvent = new AtomicReference<>(); boolean createdTable; try { CreateTableFunction createTableFunction = getConnectorNode().getConnectorFunctions().getCreateTableFunction(); CreateTableV2Function createTableV2Function = getConnectorNode().getConnectorFunctions().getCreateTableV2Function(); createdTable = createTableV2Function != null || createTableFunction != null; TapTable finalTapTable = new TapTable(); if (createdTable) { handleTapTablePrimaryKeys(tapTable); BeanUtil.copyProperties(tapTable,finalTapTable); if(unwindProcess){ ignorePksAndIndices(finalTapTable, null); } tapCreateTableEvent.set(createTableEvent(finalTapTable)); executeDataFuncAspect(CreateTableFuncAspect.class, () -> new CreateTableFuncAspect() .createTableEvent(tapCreateTableEvent.get()) .setInit(init) .connectorContext(getConnectorNode().getConnectorContext()) .dataProcessorContext(dataProcessorContext) .start(), (createTableFuncAspect -> PDKInvocationMonitor.invoke(getConnectorNode(), PDKMethod.TARGET_CREATE_TABLE, () -> { if (createTableV2Function != null) { CreateTableOptions createTableOptions = createTableV2Function.createTable(getConnectorNode().getConnectorContext(), tapCreateTableEvent.get()); succeed.set(!createTableOptions.getTableExists()); if (createTableFuncAspect != null) createTableFuncAspect.createTableOptions(createTableOptions); } else { createTableFunction.createTable(getConnectorNode().getConnectorContext(), tapCreateTableEvent.get()); } }, TAG,buildErrorConsumer(tapCreateTableEvent.get().getTableId())))); clientMongoOperator.insertOne(Collections.singletonList(finalTapTable), ConnectorConstant.CONNECTION_COLLECTION + "/load/part/tables/" + dataProcessorContext.getTargetConn().getId()); } else { // only execute start function aspect so that it would be cheated as input AspectUtils.executeAspect(new CreateTableFuncAspect() .createTableEvent(tapCreateTableEvent.get()) .setInit(init) .connectorContext(getConnectorNode().getConnectorContext()) .dataProcessorContext(dataProcessorContext).state(NewFieldFuncAspect.STATE_START)); clientMongoOperator.insertOne(Collections.singletonList(tapTable), ConnectorConstant.CONNECTION_COLLECTION + "/load/part/tables/" + dataProcessorContext.getTargetConn().getId()); }  } catch (Throwable throwable) { Throwable matched = CommonUtils.matchThrowable(throwable, TapCodeException.class); if (null != matched) { throw (TapCodeException) matched; }else { throw new TapEventException(TaskTargetProcessorExCode_15.CREATE_TABLE_FAILED, "Table model: " + tapTable, throwable) .addEvent(tapCreateTableEvent.get()); } } return createdTable; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: shouldTriggerAutomaticSnapshot_InvalidExpression() { boolean shouldTrigger = shouldTriggerAutomaticSnapshot( CHECKPOINT, "-1", Instant.now().minus(Duration.ofDays(365))); "<AssertPlaceHolder>"; }
shouldTriggerAutomaticSnapshot( SnapshotType snapshotType, String automaticTriggerExpression, Instant lastTrigger) { if (StringUtils.isBlank(automaticTriggerExpression)) { return false; } // automaticTriggerExpression was configured by the user  Optional<Duration> interval = interpretAsInterval(automaticTriggerExpression); Optional<CronExpression> cron = interpretAsCron(automaticTriggerExpression);  // This should never happen. The string cannot be both a valid Duration and a cron // expression at the same time. if (interval.isPresent() && cron.isPresent()) { LOG.error( "Something went wrong with the automatic {} trigger expression {}. This setting cannot be simultaneously a valid Duration and a cron expression.", snapshotType, automaticTriggerExpression); return false; }  if (interval.isPresent()) { return shouldTriggerIntervalBasedSnapshot(snapshotType, interval.get(), lastTrigger); } else if (cron.isPresent()) { return shouldTriggerCronBasedSnapshot( snapshotType, cron.get(), lastTrigger, Instant.now()); } else { LOG.warn( "Automatic {} triggering is configured, but the trigger expression '{}' is neither a valid Duration, nor a cron expression.", snapshotType, automaticTriggerExpression); return false; } }
[*] target: assertFalse(shouldTrigger)
[-] pred: org. junit. Assert. assertFalse ( shouldTrigger )
************************************
************************************
[+] input: testConcatToFileNormal() { File file = utils.concatToFile("mock-path", new String[]{"sub-path"}); Assertions."<AssertPlaceHolder>"; }
concatToFile(String path, String ...paths) { return new File(concat(path, paths)); }
[*] target: assertNotNull(file)
[-] pred: org. junit. Assert. assertNotNull ( file )
************************************
************************************
[+] input: testStripQuotes() { String input = ""/home/user/file.txt""; Path expected = Paths.get("/home/user/file.txt"); Path result = PathUtil.stripQuotes(input);  "<AssertPlaceHolder>"; }
stripQuotes(String path) { return Paths.get(stripQuotesAtStartAndEnd(path)); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: shouldReturnListOfTodos() { this.server .expect(requestTo("/todos")) .andRespond(withSuccess("[{" + ""id": 1," + ""userId": 42, " + ""title":"Learn Testing Spring Boot Applications", " + ""completed": false" + "}]", MediaType.APPLICATION_JSON));  List<Todo> result = todosClient.fetchAllTodos();  "<AssertPlaceHolder>"; }
fetchAllTodos() { return this.restTemplate .exchange("/todos", HttpMethod.GET, null,  new ParameterizedTypeReference<List<Todo>>() {}) .getBody(); }
[*] target: assertEquals(1, result.size())
[-] pred: org. junit. Assert. assertEquals ( 1, result. size ( ) )
************************************
************************************
[+] input: shouldSetAndGetMacOptionIsMeta() { options.setMacOptionIsMeta(true); "<AssertPlaceHolder>"; }
isMacOptionIsMeta() { return macOptionIsMeta; }
[*] target: assertTrue(options.isMacOptionIsMeta())
[-] pred: org. junit. Assert. assertTrue ( options. isMacOptionIsMeta() )
************************************
************************************
[+] input: withUpperBound() { TypeParameter typeParameter = T.extending(COMPARABLE.with(T)); String toVerify = generateFrom(typeParameter); String expected = "T extends java.lang.Comparable<T>"; "<AssertPlaceHolder>"; }
generateFrom(TypeParameter typeParameter) { return typeParameter(typeParameter).generate(); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: using() { Type expected = Type.concrete(ERUDITE, STRING_TYPE.invariant(), T_TYPE.covariant(), INTEGER_TYPE.contravariant()); Type toVerify = Type.generic(T).using(TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.invariant(), TypeConstructor.placeholder().covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant()));  "<AssertPlaceHolder>"; }
contravariant() { return TypeArgument.of(CONTRAVARIANT, this); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testReturnSubstringWithCodon6() { String expectedResult = this.expectedCodon6; String actualSubstringResult = returnSubstring(this.testInput, this.testCodon6); "<AssertPlaceHolder>"; }
returnSubstring(String dnaString, int index) { return dnaString.substring(index, index + 3).toUpperCase(); }
[*] target: assertEquals(expectedResult, actualSubstringResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualSubstringResult )
************************************
************************************
[+] input: initTableFileTest() { final File dbFile = TableGenerator.initTableFile(FileUtil.CURRENT_DIR); "<AssertPlaceHolder>"; }
initTableFile(@NonNull final String tempDir) { try { final File tempDbFile = File.createTempFile("c3rTmp", ".db", new File(tempDir)); // Set 600 file permissions FileUtil.setOwnerReadWriteOnlyPermissions(tempDbFile); // Ensure file is cleaned up when JVM is closed. tempDbFile.deleteOnExit(); return tempDbFile; } catch (InvalidPathException | IOException e) { throw new C3rRuntimeException("The temporary database used for processing could not be created in the temp directory. " + "Directory: " + tempDir, e); } }
[*] target: assertTrue(dbFile.exists())
[-] pred: org. junit. Assert. assertTrue ( dbFile. exists ( ) )
************************************
************************************
[+] input: IllegalAccessException { final List<ColumnSchema> columnSchemas = List.of( GeneralTestUtility.cleartextColumn("s1", "t1"), GeneralTestUtility.cleartextColumn("s1", "t2"), GeneralTestUtility.cleartextColumn("s2", "t3") ); final var tableSchema = generateMockTableSchema(false, columnSchemas); doCallRealMethod().when(tableSchema).getSourceAndTargetHeaders();  final Set<ColumnHeader> knownValid = Set.of( new ColumnHeader("s1"), new ColumnHeader("s2"), new ColumnHeader("t1"), new ColumnHeader("t2"), new ColumnHeader("t3") ); final var results = tableSchema.getSourceAndTargetHeaders(); "<AssertPlaceHolder>"; }
getSourceAndTargetHeaders() { return getColumns().stream() .flatMap(c -> Stream.of(c.getSourceHeader(), c.getTargetHeader())) .collect(Collectors.toSet()); }
[*] target: assertEquals(knownValid, results)
[-] pred: org. junit. Assert. assertEquals ( knownValid, results )
************************************
************************************
[+] input: contravariantConcreteTypeConstructorCanAcceptGivenEquivalentContravariantConcreteTypeConstructor() { ConcreteTypeConstructor target = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.contravariant()); ConcreteTypeConstructor source = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.contravariant());  "<AssertPlaceHolder>"; }
canAccept(TypeConstructor typeConstructor) { if (typeConstructor instanceof ConcreteTypeConstructor) { ConcreteTypeConstructor that = (ConcreteTypeConstructor) typeConstructor;  return this.fullyQualifiedNameEqualToThatOf(that) && this.typeArgumentsCanAccept(that); } else { return false; } }
[*] target: assertTrue(target.canAccept(source))
[-] pred: org. junit. Assert. assertTrue ( target. canAccept ( source ) )
************************************
************************************
[+] input: testNormal() { AccessNodeInfo accessNodeInfo = agentGroupUtil.mappingAccessNodeInfo(group, infoMap); Assertions."<AssertPlaceHolder>"; verify(group, times(1)).getAgentIds(); verify(group, times(1)).getGroupId(); verify(group, times(1)).getName(); verify(infoMap, times(1)).get(anyString()); }
mappingAccessNodeInfo(AgentGroupEntity group, Map<String, AccessNodeInfo> infoMap) { List<String> agentIds = group.getAgentIds(); List<AccessNodeInfo> agentInfos = null == agentIds ? new ArrayList<>() : agentIds.stream().map(infoMap::get).filter(Objects::nonNull).collect(Collectors.toList()); AccessNodeInfo item = new AccessNodeInfo(); item.setProcessId(group.getGroupId()); item.setAccessNodeName(group.getName()); item.setAccessNodeType(AccessNodeTypeEnum.MANUALLY_SPECIFIED_BY_THE_USER_AGENT_GROUP.name()); item.setAccessNodes(agentInfos); return item; }
[*] target: assertNotNull(accessNodeInfo)
[-] pred: org. junit. Assert. assertNotNull ( accessNodeInfo )
************************************
************************************
[+] input: shouldAddNewPhysicalAssessmentToClient() { //given Client client = new Client(); this.physicalAssessment.setClient(client); //when physicalAssessment.addPhysicalAssessment(); int actual = client.getPhysicalAssessmentList().size(); //then int expected = 1; Assertions."<AssertPlaceHolder>"; }
addPhysicalAssessment() { this.client.getPhysicalAssessmentList().add(this); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: bind_withStandardInput() { BoundStatement result = targetInsertStatement.bind(originRow, targetRow, null,null,null,null); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size())).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { if (null == originRow) throw new RuntimeException("Origin row is null"); if (usingCounter) throw new RuntimeException("Cannot INSERT onto a counter table, use UPDATE instead");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue); BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; Object bindValue = null;  if (logDebug) logger.debug("bind using conversions: {}",cqlTable.getOtherCqlTable().getConversions()); for (int targetIndex = 0; targetIndex < targetColumnTypes.size(); targetIndex++) { if (!bindColumnIndexes.contains(targetIndex)) { // this happens with constant columns, for example continue; } try { if (targetIndex== explodeMapKeyIndex) { bindValue = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValue = explodeMapValue; } else { int originIndex = cqlTable.getCorrespondingIndex(targetIndex); if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValue = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValue, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValue + " of class:" +(null==bindValue?"unknown":bindValue.getClass().getName())+ " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex)+ "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex + " and bind index: "+ (currentBindIndex-1) + " of statement:" + this.getCQL()); throw e; } }  if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: shouldTriggerAutomaticSnapshot_ValidCronExpression() { boolean shouldTrigger = shouldTriggerAutomaticSnapshot( CHECKPOINT, "0 */10 * * * ?", Instant.now().minus(Duration.ofDays(365))); "<AssertPlaceHolder>"; }
shouldTriggerAutomaticSnapshot( SnapshotType snapshotType, String automaticTriggerExpression, Instant lastTrigger) { if (StringUtils.isBlank(automaticTriggerExpression)) { return false; } // automaticTriggerExpression was configured by the user  Optional<Duration> interval = interpretAsInterval(automaticTriggerExpression); Optional<CronExpression> cron = interpretAsCron(automaticTriggerExpression);  // This should never happen. The string cannot be both a valid Duration and a cron // expression at the same time. if (interval.isPresent() && cron.isPresent()) { LOG.error( "Something went wrong with the automatic {} trigger expression {}. This setting cannot be simultaneously a valid Duration and a cron expression.", snapshotType, automaticTriggerExpression); return false; }  if (interval.isPresent()) { return shouldTriggerIntervalBasedSnapshot(snapshotType, interval.get(), lastTrigger); } else if (cron.isPresent()) { return shouldTriggerCronBasedSnapshot( snapshotType, cron.get(), lastTrigger, Instant.now()); } else { LOG.warn( "Automatic {} triggering is configured, but the trigger expression '{}' is neither a valid Duration, nor a cron expression.", snapshotType, automaticTriggerExpression); return false; } }
[*] target: assertTrue(shouldTrigger)
[-] pred: org. junit. Assert. assertTrue ( shouldTrigger )
************************************
************************************
[+] input: givenInterfaceWithoutModifiersButWithTypeParameters() { List<String> toVerify = classOrInterface() .asInterface() .withName("Pair") .withTypeParameters(A.extending(OBJECT)) .withTypeParameters(B) .withBody( "A getLeft();", "B getRight();" ) .lines();  List<String> expected = asList( "interface Pair<A, B> {", "", "    A getLeft();", "    B getRight();", "", "}" );  "<AssertPlaceHolder>"; }
lines() { List<String> result = new ArrayList<>(); result.add( String.join( SPACE, modifiersGenerator.isEmpty() ? type.toString() : modifiersGenerator.generate() + SPACE + type.toString(), name + typeParametersGenerator.generate(), OPEN_BRACE ) ); result.add(EMPTY_LINE); result.addAll(bodyGenerator.indent().lines()); result.add(EMPTY_LINE); result.add(CLOSE_BRACE); return result; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testDecodeKey() {  String key = "testKey"; ByteBuffer buffer = ByteBuffer.wrap(key.getBytes(StandardCharsets.UTF_8)); String decodedKey = codec.decodeKey(buffer);  "<AssertPlaceHolder>"; }
decodeKey(ByteBuffer byteBuffer) { return StandardCharsets.UTF_8.decode(byteBuffer).toString(); }
[*] target: assertEquals(key, decodedKey)
[-] pred: org. junit. Assert. assertEquals ( key, decodedKey )
************************************
************************************
[+] input: serviceWithInit_Inspect_ReturnNull() { PerformanceInspectionResult inspectionResult = PerformanceInspectionService.getInstance() .inspect(PerformanceInspection.createAndroidBatteryInfoInspection( "appId", "deviceIdentifier", "custom description")); Assertions."<AssertPlaceHolder>"; }
getInstance() { return INSTANCE; }
[*] target: assertNull(inspectionResult)
[-] pred: org. junit. Assert. assertNull ( inspectionResult )
************************************
************************************
[+] input: validateGivenMethodWithMoreThanOneParameter() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter()), Optional.of(LIST.with(T)), "myFunction", asList(Parameter.of(ARRAY_LIST.with(T), "left"), Parameter.of(ARRAY_LIST.with(T), "right")) );  Validated<String, InitializerOrFinalizerValidator.Result> expected = Validated.invalid("Method requires exactly 1 parameters, but found 2"); Validated<String, InitializerOrFinalizerValidator.Result> toVerify = InitializerOrFinalizerValidator.validate(toValidate);  "<AssertPlaceHolder>"; }
validate(Method method) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyParameterCount(method.getParameters(), 1, errorMessages); verifyTypeParameterCount(method.getTypeParameters(), 1, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  TypeParameter typeParameter = method.getTypeParameters().get(0);  String name = method.getName();  Parameter parameter = method.getParameters().get(0);  // Extract the type constructor from the single parameter: TypeConstructor toInitializeOrFinalizeTypeConstructor = parameter.getType().asTypeConstructorWithPlaceholderFor(typeParameter.getName());  // Extract the type constructor from the return type: TypeConstructor initializedOrFinalizedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(typeParameter.getName());  return Validated.valid(Result.of(name, parameter.getType(), toInitializeOrFinalizeTypeConstructor, returnType, initializedOrFinalizedTypeConstructor)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testResolveRelativePath() { URL resourceURL = ClassLoaderUtils.getClassResource(classLoader, Nonnull.class); String relativePath = resolveRelativePath(resourceURL); String expectedPath = "javax/annotation/Nonnull.class"; "<AssertPlaceHolder>"; }
resolveRelativePath(URL jarURL) throws NullPointerException, IllegalArgumentException { assertJarURLProtocol(jarURL); String form = jarURL.toExternalForm(); String relativePath = substringAfter(form, ARCHIVE_ENTRY_SEPARATOR); relativePath = normalizePath(relativePath); return decode(relativePath); }
[*] target: assertEquals(expectedPath, relativePath)
[-] pred: org. junit. Assert. assertEquals ( expectedPath, relativePath )
************************************
************************************
[+] input: testNoExceedCloudTaskLimitNum() { when(workerService.findByProcessId(processId, user, "user_id", "agentTags", "process_id")).thenReturn(workerDto); when(workerService.getLimitTaskNum(workerDto, user)).thenReturn(2); CalculationEngineVo calculationEngineVo = new CalculationEngineVo(); calculationEngineVo.setRunningNum(1); calculationEngineVo.setTaskLimit(2); when(taskService.runningTaskNum(processId, user)).thenReturn(3); when(taskService.subCronOrPlanNum(taskDto,3)).thenReturn(2); when(workerService.scheduleTaskToEngine(taskDto, user, "task", taskDto.getName())).thenReturn(calculationEngineVo); when(taskService.subCronOrPlanNum(taskDto,1)).thenReturn(1); CalculationEngineVo result = taskScheduleService.cloudTaskLimitNum(taskDto, user, false); "<AssertPlaceHolder>"; }
cloudTaskLimitNum(TaskDto taskDto, UserDetail user, boolean limitNum) { TaskDto userId = taskService.findByTaskId(taskDto.getId(), "user_id"); Assert.notNull(userId, "task not found"); user = userService.loadUserById(new ObjectId(userId.getUserId()));  AtomicBoolean needCalculateAgent = new AtomicBoolean(true); String agentId = taskDto.getAgentId(); UserDetail finalUser = user; Optional.ofNullable(agentId).ifPresent(id -> { List<Worker> workerList = workerService.findAvailableAgentByAccessNode(finalUser, Lists.newArrayList(agentId)); if (CollectionUtils.isNotEmpty(workerList)) { Worker workerDto = workerList.get(0);  Object heartTime = settingsService.getValueByCategoryAndKey(CategoryEnum.WORKER, KeyEnum.WORKER_HEART_TIMEOUT); long heartExpire = Objects.nonNull(heartTime) ? (Long.parseLong(heartTime.toString()) + 48) * 1000 : 108000;  if (workerDto.getPingTime() < heartExpire) { needCalculateAgent.set(false); } } }); List<String> accessNodeProcessIdList = agentGroupService.getProcessNodeListWithGroup(taskDto, user); if (needCalculateAgent.get()) { if (AccessNodeTypeEnum.MANUALLY_SPECIFIED_BY_THE_USER.name().equals(taskDto.getAccessNodeType()) && CollectionUtils.isNotEmpty(taskDto.getAccessNodeProcessIdList())) { taskDto.setAgentId(taskDto.getAccessNodeProcessIdList().get(0)); } else if(AccessNodeTypeEnum.isGroupManually(taskDto.getAccessNodeType()) && CollectionUtils.isNotEmpty(accessNodeProcessIdList)){ List<Worker> availableAgent = workerService.findAvailableAgentByAccessNode(user,accessNodeProcessIdList); List<String> processIds = availableAgent.stream().map(Worker::getProcessId).collect(Collectors.toList()); String finalAgentId = null; if(StringUtils.isNotEmpty(taskDto.getPriorityProcessId()) && processIds.contains(taskDto.getPriorityProcessId())){ finalAgentId = taskDto.getPriorityProcessId(); }else{ finalAgentId = processIds.get(0); } taskDto.setAgentId(finalAgentId); } else { taskDto.setAgentId(null); } }  if (AccessNodeTypeEnum.MANUALLY_SPECIFIED_BY_THE_USER.name().equals(taskDto.getAccessNodeType()) && CollectionUtils.isNotEmpty(taskDto.getAccessNodeProcessIdList())) { WorkerDto workerDto = workerService.findByProcessId(taskDto.getAgentId(), user, "user_id", "agentTags", "process_id"); int limitTaskNum = workerService.getLimitTaskNum(workerDto, user); int runningNum = taskService.subCronOrPlanNum(taskDto, taskService.runningTaskNum(taskDto.getAgentId(), user)); if (runningNum > limitTaskNum && !limitNum) { StateMachineResult stateMachineResult = stateMachineService.executeAboutTask(taskDto, DataFlowEvent.SCHEDULE_FAILED, user); if (stateMachineResult.isOk()) { throw new BizException("Task.ScheduleLimit"); }  } }  CalculationEngineVo calculationEngineVo = workerService.scheduleTaskToEngine(taskDto, user, "task", taskDto.getName()); int runningNum = taskService.subCronOrPlanNum(taskDto, calculationEngineVo.getRunningNum()); if (StringUtils.isNotBlank(taskDto.getAgentId()) && runningNum > calculationEngineVo.getTaskLimit() && !limitNum) { StateMachineResult stateMachineResult = stateMachineService.executeAboutTask(taskDto, DataFlowEvent.SCHEDULE_FAILED, user); if (stateMachineResult.isOk()) { throw new BizException("Task.ScheduleLimit"); } } return calculationEngineVo; }
[*] target: assertEquals(calculationEngineVo, result)
[-] pred: org. junit. Assert. assertEquals ( calculationEngineVo, result )
************************************
************************************
[+] input: Exception { FlinkDeployment flinkApp = TestUtils.buildApplicationCluster(); ObjectMeta deployMeta = flinkApp.getMetadata(); FlinkDeploymentStatus status = flinkApp.getStatus(); FlinkDeploymentSpec spec = flinkApp.getSpec(); Configuration deployConfig = configManager.getDeployConfig(deployMeta, spec);  status.getJobStatus().setState(org.apache.flink.api.common.JobStatus.FINISHED.name()); status.setJobManagerDeploymentStatus(JobManagerDeploymentStatus.READY); reconciler .getReconciler() .deploy(getResourceContext(flinkApp), spec, deployConfig, Optional.empty(), false);  final List<Map<String, String>> expectedOwnerReferences = List.of(TestUtils.generateTestOwnerReferenceMap(flinkApp)); List<Map<String, String>> or = deployConfig.get(KubernetesConfigOptions.JOB_MANAGER_OWNER_REFERENCE); Assertions."<AssertPlaceHolder>"; }
deploy( FlinkResourceContext<FlinkDeployment> ctx, FlinkDeploymentSpec spec, Configuration deployConfig, Optional<String> savepoint, boolean requireHaMetadata) throws Exception {  var relatedResource = ctx.getResource(); var status = relatedResource.getStatus(); var flinkService = ctx.getFlinkService();  ClusterHealthEvaluator.removeLastValidClusterHealthInfo( relatedResource.getStatus().getClusterInfo());  if (savepoint.isPresent()) { // Savepoint deployment deployConfig.set(SavepointConfigOptions.SAVEPOINT_PATH, savepoint.get()); } else if (requireHaMetadata && flinkService.atLeastOneCheckpoint(deployConfig)) { // Last state deployment, explicitly set a dummy savepoint path to avoid accidental // incorrect state restore in case the HA metadata is deleted by the user deployConfig.set(SavepointConfigOptions.SAVEPOINT_PATH, LAST_STATE_DUMMY_SP_PATH); status.getJobStatus() .setUpgradeSnapshotReference( FlinkStateSnapshotReference.fromPath(LAST_STATE_DUMMY_SP_PATH)); } else { // Stateless deployment, remove any user configured savepoint path deployConfig.removeConfig(SavepointConfigOptions.SAVEPOINT_PATH); }  setOwnerReference(relatedResource, deployConfig); setRandomJobResultStorePath(deployConfig);  if (status.getJobManagerDeploymentStatus() != JobManagerDeploymentStatus.MISSING) { Preconditions.checkArgument(ReconciliationUtils.isJobInTerminalState(status)); LOG.info("Deleting cluster with terminated application before new deployment"); flinkService.deleteClusterDeployment( relatedResource.getMetadata(), status, deployConfig, !requireHaMetadata); statusRecorder.patchAndCacheStatus(relatedResource, ctx.getKubernetesClient()); }  setJobIdIfNecessary( relatedResource, deployConfig, ctx.getKubernetesClient(), requireHaMetadata);  eventRecorder.triggerEvent( relatedResource, EventRecorder.Type.Normal, EventRecorder.Reason.Submit, EventRecorder.Component.JobManagerDeployment, MSG_SUBMIT, ctx.getKubernetesClient()); flinkService.submitApplicationCluster(spec.getJob(), deployConfig, requireHaMetadata); status.getJobStatus().setState(org.apache.flink.api.common.JobStatus.RECONCILING.name()); status.setJobManagerDeploymentStatus(JobManagerDeploymentStatus.DEPLOYING);  IngressUtils.updateIngressRules( relatedResource.getMetadata(), spec, deployConfig, ctx.getKubernetesClient()); }
[*] target: assertEquals(expectedOwnerReferences, or)
[-] pred: org. junit. Assert. assertEquals ( expectedOwnerReferences, or )
************************************
************************************
[+] input: testTapEvent2MessageNullTapRecordEvent() { MessageEntity actual = hazelcastBaseNode.tapEvent2Message(null); "<AssertPlaceHolder>"; }
tapEvent2Message(TapRecordEvent dataEvent) { if (null == dataEvent) return null; MessageEntity messageEntity = new MessageEntity(); Map<String, Object> before = TapEventUtil.getBefore(dataEvent); messageEntity.setBefore(before); Map<String, Object> after = TapEventUtil.getAfter(dataEvent); messageEntity.setAfter(after); messageEntity.setOp(TapEventUtil.getOp(dataEvent)); messageEntity.setTableName(dataEvent.getTableId()); messageEntity.setTimestamp(dataEvent.getReferenceTime()); messageEntity.setTime(dataEvent.getTime()); messageEntity.setInfo(dataEvent.getInfo()); return messageEntity; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: testReplace() { User user = new User(); user.setId(1L) .setName("张三") .setAge(18) .setCreateTime(LocalDateTime.now()); int replace = commonDao.replace(user); Assertions."<AssertPlaceHolder>"; }
replace(T params);
[*] target: assertEquals(2, replace)
[-] pred: org. junit. Assert. assertEquals ( 2, replace )
************************************
************************************
[+] input: testFormatTimestamp() { String str = DateUtil.formatTimestamp(1685624782010L); Assertions."<AssertPlaceHolder>"; }
formatTimestamp(Long timeMillis) { LocalDateTime localDateTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(timeMillis), ZoneId.systemDefault()); return localDateTime.format(MILL_FORMATTER_PATTERN); }
[*] target: assertNotNull(str)
[-] pred: org. junit. Assert. assertNotNull ( str )
************************************
************************************
[+] input: testStripQuotesAtStartAndEndSingleQuoteEnd() { String input = "/home/user/file.txt""; String expected = input; String result = PathUtil.stripQuotesAtStartAndEnd(input);  "<AssertPlaceHolder>"; }
stripQuotesAtStartAndEnd(String path) { if (path.startsWith(""") && path.endsWith(""")) { return path.substring(1, path.length() - 1); }  return path; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testEraseUnknownSession() { var sessions = new MemorySessions(); sessions.setSessionDuration(1200000);  var auth_id = "unknown"; try { "<AssertPlaceHolder>"; } catch (SessionManagerException e) { fail(ExceptionUtils.getExceptionStackTrace(e)); } }
eraseSession(String authId) throws SessionManagerException { if (null == authId || authId.isEmpty()) { return false; }  return sessions_.remove(authId) != null; }
[*] target: assertFalse(sessions.eraseSession(auth_id))
[-] pred: org. junit. Assert. assertFalse ( sessions. eraseSession ( auth_id ) )
************************************
************************************
[+] input: test12() { QueryOperator queryOperator = new QueryOperator(); queryOperator.setForm(TapTimeForm.CURRENT); List<String> result = TimeTransFormationUtil.calculatedTimeRange(currentDateTime,queryOperator,8L); Assertions."<AssertPlaceHolder>"; }
calculatedTimeRange(LocalDateTime currentDateTime, QueryOperator queryOperator,Long offsetHours){ List<String> result = new ArrayList<>(); if(null == queryOperator.getUnit() || null == queryOperator.getForm())return result; TapTimeForm tapTimeForm = queryOperator.getForm(); Long number = queryOperator.getNumber(); if(  null != offsetHours && offsetHours != 0){ currentDateTime = currentDateTime.plusHours(offsetHours); } switch (queryOperator.getUnit()){ case HOUR: LocalDateTime hourStart; LocalDateTime hourEnd; if(tapTimeForm.equals(TapTimeForm.BEFORE)){ hourStart = currentDateTime.minusHours(number).withMinute(0).withSecond(0); hourEnd = hourStart.plusHours(number-1).withMinute(59).withSecond(59); }else{ hourStart = currentDateTime.withMinute(0).withSecond(0); hourEnd  = currentDateTime; } result.add(formatDateTime(hourStart)); result.add(formatDateTime(hourEnd)); return result; case DAY: LocalDateTime dayStart; LocalDateTime dayEnd; if(tapTimeForm.equals(TapTimeForm.BEFORE)){ dayStart = currentDateTime.minusDays(number).withHour(0).withMinute(0).withSecond(0); dayEnd = dayStart.plusDays(number-1).withHour(23).withMinute(59).withSecond(59); }else{ dayStart = currentDateTime.withHour(0).withMinute(0).withSecond(0); dayEnd  = currentDateTime; } result.add(formatDateTime(dayStart)); result.add(formatDateTime(dayEnd)); return result; case WEEK: LocalDateTime weekStart; LocalDateTime weekEnd; if(tapTimeForm.equals(TapTimeForm.BEFORE)){ weekStart = currentDateTime.minusWeeks(number).with(DayOfWeek.MONDAY).withHour(0).withMinute(0).withSecond(0); weekEnd =  weekStart.plusWeeks(number-1).with(DayOfWeek.SUNDAY).withHour(23).withMinute(59).withSecond(59); }else{ weekStart = currentDateTime.with(DayOfWeek.MONDAY).withHour(0).withMinute(0).withSecond(0); weekEnd =  currentDateTime; } result.add(formatDateTime(weekStart)); result.add(formatDateTime(weekEnd)); return result; case MONTH: LocalDateTime monthStart; LocalDateTime monthEnd; if(tapTimeForm.equals(TapTimeForm.BEFORE)){ monthStart = currentDateTime.minusMonths(number).withDayOfMonth(1).withHour(0).withMinute(0).withSecond(0); monthEnd = currentDateTime.minusMonths(1).withDayOfMonth(currentDateTime.minusMonths(1).toLocalDate().lengthOfMonth()).withHour(23).withMinute(59).withSecond(59); }else{ monthStart = currentDateTime.withDayOfMonth(1).withHour(0).withMinute(0).withSecond(0); monthEnd = currentDateTime; } result.add(formatDateTime(monthStart)); result.add(formatDateTime(monthEnd)); return result; case YEAR: LocalDateTime yearStart; LocalDateTime yearEnd; if(tapTimeForm.equals(TapTimeForm.BEFORE)){ yearStart = currentDateTime.minusYears(number).withDayOfYear(1).withHour(0).withMinute(0).withSecond(0); yearEnd = currentDateTime.minusYears(1).withDayOfYear(currentDateTime.minusYears(1).toLocalDate().lengthOfYear()).withHour(23).withMinute(59).withSecond(59); }else{ yearStart = currentDateTime.withDayOfYear(1).withHour(0).withMinute(0).withSecond(0); yearEnd = currentDateTime; } result.add(formatDateTime(yearStart)); result.add(formatDateTime(yearEnd)); return result; default: return result; } }
[*] target: assertEquals(0,result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: testUpdate() { User user = new User(); user.setName("李四"); user.setAge(17); user.setId(1L); int update = commonDaoWrap.update(user); Assertions."<AssertPlaceHolder>"; }
update(T params) { return dao.update(params); }
[*] target: assertEquals(1, update)
[-] pred: org. junit. Assert. assertEquals ( 1, update )
************************************
************************************
[+] input: testList() { dataSourceRegister.deleteById(1); List<DynamicDataSourceInfo> list = dataSourceRegister.list(); Assertions."<AssertPlaceHolder>"; }
list(){ List<DynamicDataSourceInfo> dynamicDataSourceInfos = dynamicDataSourceDao.list(); dynamicDataSourceInfos.forEach(it -> decryptDataSource(it)); return dynamicDataSourceInfos; }
[*] target: assertEquals(1, list.size())
[-] pred: org. junit. Assert. assertEquals ( 1, list. size ( ) )
************************************
************************************
[+] input: testSubCronOrPlanNum() { taskEntity.setCrontabExpressionFlag(true); try (MockedStatic<DataPermissionHelper> dataPermissionHelperMockedStatic = mockStatic(DataPermissionHelper.class)) { int result = taskService.subCronOrPlanNum(taskDto, 3); "<AssertPlaceHolder>"; } }
subCronOrPlanNum(TaskDto task, int runningNum) { TaskDto taskScheduleFlag = findByTaskId(task.getId(), PLAN_START_DATE_FLAG, CRONTAB_EXPRESSION_FLAG); if (checkIsCronOrPlanTask(taskScheduleFlag) && runningNum > 0) { runningNum -= 1; } return runningNum; }
[*] target: assertEquals(2,result)
[-] pred: org. junit. Assert. assertEquals ( 2, result )
************************************
************************************
[+] input: testDestroy() {  CollectRep.MetricsData metricsData = mock(CollectRep.MetricsData.class); when(metricsData.getId()).thenReturn(1L); when(metricsData.getMetrics()).thenReturn("cpuUsage"); when(metricsData.getCode()).thenReturn(CollectRep.Code.SUCCESS);  memoryDataStorage.saveData(metricsData); memoryDataStorage.destroy();  List<CollectRep.MetricsData> result = memoryDataStorage.getCurrentMetricsData(1L); "<AssertPlaceHolder>"; }
getCurrentMetricsData(@NonNull Long monitorId) { Map<String, CollectRep.MetricsData> metricsDataMap = monitorMetricsDataMap.computeIfAbsent(monitorId, key -> new ConcurrentHashMap<>(METRICS_SIZE)); return new ArrayList<>(metricsDataMap.values()); }
[*] target: assertTrue(result.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( result. isEmpty ( ) )
************************************
************************************
[+] input: testCheckServiceDependency_FrameServiceServiceReturnsNoItems() { // Setup final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  // Configure ClusterServiceInstanceService.listRunningServiceInstance(...). final ClusterServiceInstanceEntity clusterServiceInstanceEntity = new ClusterServiceInstanceEntity(); clusterServiceInstanceEntity.setId(0); clusterServiceInstanceEntity.setClusterId(0); clusterServiceInstanceEntity.setServiceName("serviceName"); clusterServiceInstanceEntity.setLabel("label"); clusterServiceInstanceEntity.setServiceState(ServiceState.WAIT_INSTALL); clusterServiceInstanceEntity.setServiceStateCode(0); clusterServiceInstanceEntity.setUpdateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceInstanceEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceInstanceEntity.setNeedRestart(NeedRestart.NO); clusterServiceInstanceEntity.setFrameServiceId(0); clusterServiceInstanceEntity.setDashboardUrl("dashboardUrl"); clusterServiceInstanceEntity.setAlertNum(0); clusterServiceInstanceEntity.setSortNum(0); final List<ClusterServiceInstanceEntity> serviceInstanceEntityList = Arrays.asList( clusterServiceInstanceEntity); when(mockServiceInstanceService.listRunningServiceInstance(0)).thenReturn(serviceInstanceEntityList);  when(mockFrameService.listServices("serviceIds")).thenReturn(Collections.emptyList());  // Run the test final Result result = serviceInstallServiceImplUnderTest.checkServiceDependency(0, "serviceIds");  // Verify the results "<AssertPlaceHolder>"; }
checkServiceDependency(Integer clusterId, String serviceIds) { // List<ClusterServiceInstanceEntity> serviceInstanceList = serviceInstanceService.listRunningServiceInstance(clusterId); Map<String, ClusterServiceInstanceEntity> instanceMap = serviceInstanceList.stream() .collect( Collectors.toMap( ClusterServiceInstanceEntity::getServiceName, e -> e, (v1, v2) -> v1));  List<FrameServiceEntity> list = frameService.listServices(serviceIds); Map<String, FrameServiceEntity> serviceMap = list.stream() .collect( Collectors.toMap( FrameServiceEntity::getServiceName, e -> e, (v1, v2) -> v1)); if (!instanceMap.containsKey("ALERTMANAGER") && !serviceMap.containsKey("ALERTMANAGER")) { return Result.error( "service install depends on alertmanager ,please make sure you have selected it or that alertmanager is normal and running"); } if (!instanceMap.containsKey("GRAFANA") && !serviceMap.containsKey("GRAFANA")) { return Result.error( "service install depends on grafana ,please make sure you have selected it or that grafana is normal and running"); } if (!instanceMap.containsKey("PROMETHEUS") && !serviceMap.containsKey("PROMETHEUS")) { return Result.error( "service install depends on prometheus ,please make sure you have selected it or that prometheus is normal and running"); }  for (FrameServiceEntity frameServiceEntity : list) { for (String dependService : frameServiceEntity.getDependencies().split(",")) { if (StringUtils.isNotBlank(dependService) && !instanceMap.containsKey(dependService) && !serviceMap.containsKey(dependService)) { return Result.error( "" + frameServiceEntity.getServiceName() + " install depends on " + dependService + ",please make sure that you have selected it or that " + dependService + " is normal and running"); } } } return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: ncmSearchPass() { NCM[] ncmSearch = BrasilAPI.ncmSearch("Animais vivos."); "<AssertPlaceHolder>"; }
ncmSearch(String code) { NCM[] obj = (NCM[]) api(NCM[].class, "ncm/v1?search=", code); return obj != null ? (NCM[]) obj.clone() : null; }
[*] target: assertNotNull(ncmSearch)
[-] pred: org. junit. Assert. assertNotNull ( ncmSearch )
************************************
************************************
[+] input: testReturnSubstringWithCodon2() { String expectedResult = this.expectedCodon2; String actualSubstringResult = returnSubstring(this.testInput, this.testCodon2); "<AssertPlaceHolder>"; }
returnSubstring(String dnaString, int index) { return dnaString.substring(index, index + 3).toUpperCase(); }
[*] target: assertEquals(expectedResult, actualSubstringResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualSubstringResult )
************************************
************************************
[+] input: testDecodeValue() {  CollectRep.MetricsData metricsData = Mockito.mock(CollectRep.MetricsData.class); byte[] bytes = new byte[] {1, 2, 3};  ByteBuffer buffer = ByteBuffer.wrap(bytes);  try { Mockito.mockStatic(CollectRep.MetricsData.class); Mockito.when(CollectRep.MetricsData.parseFrom(buffer)).thenReturn(metricsData);  CollectRep.MetricsData decodedValue = codec.decodeValue(buffer);  "<AssertPlaceHolder>"; } catch (Exception e) { log.error(e.getMessage()); fail("Exception thrown during decodeValue test"); } finally { Mockito.clearAllCaches(); } }
decodeValue(ByteBuffer byteBuffer) { try { return CollectRep.MetricsData.parseFrom(byteBuffer); } catch (Exception e) { log.error(e.getMessage()); return null; } }
[*] target: assertEquals(metricsData, decodedValue)
[-] pred: org. junit. Assert. assertEquals ( metricsData, decodedValue )
************************************
************************************
[+] input: testCheckServiceDependency() { // Setup final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  // Configure ClusterServiceInstanceService.listRunningServiceInstance(...). final ClusterServiceInstanceEntity clusterServiceInstanceEntity = new ClusterServiceInstanceEntity(); clusterServiceInstanceEntity.setId(0); clusterServiceInstanceEntity.setClusterId(0); clusterServiceInstanceEntity.setServiceName("serviceName"); clusterServiceInstanceEntity.setLabel("label"); clusterServiceInstanceEntity.setServiceState(ServiceState.WAIT_INSTALL); clusterServiceInstanceEntity.setServiceStateCode(0); clusterServiceInstanceEntity.setUpdateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceInstanceEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceInstanceEntity.setNeedRestart(NeedRestart.NO); clusterServiceInstanceEntity.setFrameServiceId(0); clusterServiceInstanceEntity.setDashboardUrl("dashboardUrl"); clusterServiceInstanceEntity.setAlertNum(0); clusterServiceInstanceEntity.setSortNum(0); final List<ClusterServiceInstanceEntity> serviceInstanceEntityList = Arrays.asList( clusterServiceInstanceEntity); when(mockServiceInstanceService.listRunningServiceInstance(0)).thenReturn(serviceInstanceEntityList);  // Configure FrameServiceService.listServices(...). final FrameServiceEntity frameServiceEntity = new FrameServiceEntity(); frameServiceEntity.setId(0); frameServiceEntity.setFrameId(0); frameServiceEntity.setServiceName("serviceName"); frameServiceEntity.setLabel("label"); frameServiceEntity.setServiceVersion("serviceVersion"); frameServiceEntity.setServiceDesc("serviceDesc"); frameServiceEntity.setPackageName("packageName"); frameServiceEntity.setDependencies("dependencies"); frameServiceEntity.setServiceJson("serviceJson"); frameServiceEntity.setServiceJsonMd5("serviceJsonMd5"); frameServiceEntity.setServiceConfig("serviceConfig"); frameServiceEntity.setFrameCode("frameCode"); frameServiceEntity.setConfigFileJson("configFileJson"); frameServiceEntity.setConfigFileJsonMd5("configFileJsonMd5"); frameServiceEntity.setSortNum(0); final List<FrameServiceEntity> frameServiceEntities = Arrays.asList(frameServiceEntity); when(mockFrameService.listServices("serviceIds")).thenReturn(frameServiceEntities);  // Run the test final Result result = serviceInstallServiceImplUnderTest.checkServiceDependency(0, "serviceIds");  // Verify the results "<AssertPlaceHolder>"; }
checkServiceDependency(Integer clusterId, String serviceIds) { // List<ClusterServiceInstanceEntity> serviceInstanceList = serviceInstanceService.listRunningServiceInstance(clusterId); Map<String, ClusterServiceInstanceEntity> instanceMap = serviceInstanceList.stream() .collect( Collectors.toMap( ClusterServiceInstanceEntity::getServiceName, e -> e, (v1, v2) -> v1));  List<FrameServiceEntity> list = frameService.listServices(serviceIds); Map<String, FrameServiceEntity> serviceMap = list.stream() .collect( Collectors.toMap( FrameServiceEntity::getServiceName, e -> e, (v1, v2) -> v1)); if (!instanceMap.containsKey("ALERTMANAGER") && !serviceMap.containsKey("ALERTMANAGER")) { return Result.error( "service install depends on alertmanager ,please make sure you have selected it or that alertmanager is normal and running"); } if (!instanceMap.containsKey("GRAFANA") && !serviceMap.containsKey("GRAFANA")) { return Result.error( "service install depends on grafana ,please make sure you have selected it or that grafana is normal and running"); } if (!instanceMap.containsKey("PROMETHEUS") && !serviceMap.containsKey("PROMETHEUS")) { return Result.error( "service install depends on prometheus ,please make sure you have selected it or that prometheus is normal and running"); }  for (FrameServiceEntity frameServiceEntity : list) { for (String dependService : frameServiceEntity.getDependencies().split(",")) { if (StringUtils.isNotBlank(dependService) && !instanceMap.containsKey(dependService) && !serviceMap.containsKey(dependService)) { return Result.error( "" + frameServiceEntity.getServiceName() + " install depends on " + dependService + ",please make sure that you have selected it or that " + dependService + " is normal and running"); } } } return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(String value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } else { BigDecimal decimalValue = new BigDecimal(value); return TypeCodecs.DECIMAL.encode(decimalValue, protocolVersion); } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testInitMonitor() { MonitorManager monitorManager = hazelcastBaseNode.initMonitor(); "<AssertPlaceHolder>"; }
initMonitor() { return MonitorManager.create(); }
[*] target: assertNotNull(monitorManager)
[-] pred: org. junit. Assert. assertNotNull ( monitorManager )
************************************
************************************
[+] input: testShouldPrintGlobalProgressWithUnregisteredRead() { jobCounter = new JobCounter(10, true); // Changed to true to test printPerThread  // Set only WRITE as the registered type jobCounter.setRegisteredTypes(JobCounter.CounterType.WRITE);  // shouldPrintGlobalProgress should return false because READ is not registered "<AssertPlaceHolder>"; }
shouldPrintGlobalProgress() { if (!counterMap.containsKey(CounterType.READ)) { return false; } long globalReads = counterMap.get(CounterType.READ).getGlobalCounter(); long expectedPrintCount = globalReads - globalReads % printStatsAfter; if (expectedPrintCount > printCounter.getGlobalCounter()) { printCounter.setGlobalCounter(expectedPrintCount); return true; } return false; }
[*] target: assertFalse(jobCounter.shouldPrintGlobalProgress())
[-] pred: org. junit. Assert. assertFalse ( jobCounter. shouldPrintGlobalProgress ( ) )
************************************
************************************
[+] input: testGetAlertConverges() {  Page<AlertConverge> page = new PageImpl<>(Collections.emptyList()); when(alertConvergeDao.findAll( any(Specification.class), any(Pageable.class)) ).thenReturn(page);  Page<AlertConverge> result = alertConvergeService.getAlertConverges(null, null, "id", "desc", 1, 10);  verify(alertConvergeDao, times(1)).findAll( any(Specification.class), any(PageRequest.class) ); "<AssertPlaceHolder>"; }
getAlertConverges(List<Long> convergeIds, String search, String sort, String order, int pageIndex, int pageSize);
[*] target: assertEquals(page, result)
[-] pred: org. junit. Assert. assertEquals ( page, result )
************************************
************************************
[+] input: testReturnSubstringWithCodon1() { String expectedResult = this.expectedCodon1; String actualSubstringResult = returnSubstring(this.testInput, this.testCodon1); "<AssertPlaceHolder>"; }
returnSubstring(String dnaString, int index) { return dnaString.substring(index, index + 3).toUpperCase(); }
[*] target: assertEquals(expectedResult, actualSubstringResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualSubstringResult )
************************************
************************************
[+] input: testCascadeSelect() { List<Student> studentTree = studentTreeHelper.toTree(originStudentList); Long targetStudentId = 6L; List<Long> expectedPathIds = Arrays.asList(1L, 3L, 6L); List<Student> selectedPath = studentTreeHelper.cascadeSelect(studentTree, targetStudentId); List<Long> selectedPathIds = selectedPath.stream().map(Student::getId).collect(Collectors.toList()); Assertions."<AssertPlaceHolder>"; }
cascadeSelect(List<T> nodes, R selectedId) { return Steam.of(nodes) .map(rootNode -> findPath(rootNode, selectedId)) .filter(Optional::isPresent) .map(Optional::get) .findFirst() .orElseGet(Collections::emptyList); }
[*] target: assertEquals(expectedPathIds, selectedPathIds)
[-] pred: org. junit. Assert. assertEquals ( expectedPathIds, selectedPathIds )
************************************
************************************
[+] input: parse_ShouldParseStringToValueAndReturnAsString() { String valueAsString = "220412215715"; Instant value = LocalDateTime.parse(valueAsString, formatter).toInstant(zoneOffset); String result = codec.parse(TypeCodecs.TIMESTAMP.format(value)); Assertions."<AssertPlaceHolder>"; }
format(String value) { Instant instantValue = LocalDateTime.parse(value, formatter).toInstant(zoneOffset); return TypeCodecs.TIMESTAMP.format(instantValue); }
[*] target: assertEquals(valueAsString, result)
[-] pred: org. junit. Assert. assertEquals ( valueAsString, result )
************************************
************************************
[+] input: test_isCloudLimit() { ObjectId taskId = MongoUtils.toObjectId("632454d5287a904778c40f8d"); Query query = new Query(Criteria.where("_id").is(taskId)); query.fields().include("id","agentId","agentTags"); TaskEntity mockTask = new TaskEntity(); mockTask.setCrontabExpressionFlag(false); mockTask.setId(MongoUtils.toObjectId("632454d5287a904778c40f8d")); try (MockedStatic<DataPermissionService> serviceMockedStatic = Mockito.mockStatic(DataPermissionService.class)) { serviceMockedStatic.when(DataPermissionService::isCloud).thenReturn(true); when(settingsService.isCloud()).thenReturn(true); when(taskRepository.findOne(query)).thenReturn(Optional.of(mockTask)); TaskDto mockTaskDto = new TaskDto(); BeanUtils.copyProperties(mockTask,mockTaskDto); CalculationEngineVo mockEngineVo = new CalculationEngineVo(); mockEngineVo.setTaskLimit(5); mockEngineVo.setRunningNum(5); when(workerService.calculationEngine(mockTaskDto,user,null)).thenReturn(mockEngineVo); Query mockQuery = new Query(Criteria.where("_id").is(taskId)); mockQuery.fields().include("planStartDateFlag", "crontabExpressionFlag"); when(taskRepository.findOne(mockQuery)).thenReturn(Optional.of(mockTask)); boolean result = taskService.checkCloudTaskLimit(taskId,user,true); "<AssertPlaceHolder>"; } }
checkCloudTaskLimit(ObjectId taskId,UserDetail user,boolean checkCurrentTask){ if (settingsService.isCloud()) { TaskDto task = findByTaskId(taskId,"id",AGENT_ID,"agentTags"); CalculationEngineVo calculationEngineVo = workerService.calculationEngine(task, user, null); int runningNum; if(checkCurrentTask){ runningNum  = subCronOrPlanNum(task, calculationEngineVo.getRunningNum()); }else{ runningNum = calculationEngineVo.getRunningNum(); } if (runningNum >= calculationEngineVo.getTaskLimit()) { return false; } } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: getTopicsPerTeamEnvOverview() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(commonUtilsService.getCurrentUserName()).thenReturn(TestConstants.USERNAME); Mockito.when(commonUtilsService.getTeamId(TestConstants.USERNAME)) .thenReturn(TestConstants.TEAM_ID); Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when( handleDbRequestsJdbc.getAllTopicsForTeamGroupByEnv( TestConstants.TEAM_ID, TestConstants.TENANT_ID)) .thenReturn(TestConstants.TOPICS_COUNT_STRING_BY_ENV_ID_INT); Mockito.when( commonUtilsService.getChartsJsOverview( anyList(), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getTopicsPerTeamEnvOverview(TestConstants.TENANT_ID);  Assertions."<AssertPlaceHolder>"; }
getTopicsPerTeamEnvOverview(int tenantId) { final String currentUserName = getCurrentUserName(); Integer userTeamId = commonUtilsService.getTeamId(currentUserName); List<CommonUtilsService.ChartsOverviewItem<String, Integer>> teamCountList = null; if (currentUserName != null) { teamCountList = manageDatabase.getHandleDbRequests().getAllTopicsForTeamGroupByEnv(userTeamId, tenantId); }  String title = "Topics per cluster (" + manageDatabase.getTeamNameFromTeamId(tenantId, userTeamId) + ")";  return commonUtilsService.getChartsJsOverview( teamCountList, title, MapConstants.CLUSTER_KEY, "Clusters", "Topics", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testForDateTime() { Long expect = 1718953878000L; Object value = new DateTime(expect); Object actual = FieldProcessUtil.handleDateTime(value); "<AssertPlaceHolder>"; }
handleDateTime(Object value) { if (value instanceof DateTime) { value = ((DateTime) value).toEpochMilli(); } return value; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetAllPackageNamesInClassPaths() { Set<String> packageNames = repository.getAllPackageNamesInClassPaths(); "<AssertPlaceHolder>"; info(packageNames); }
getAllPackageNamesInClassPaths() { return packageNameToClassNamesMap.keySet(); }
[*] target: assertNotNull(packageNames)
[-] pred: org. junit. Assert. assertNotNull ( packageNames )
************************************
************************************
[+] input: requiresPreprocessingNotCleartextTest() { final ColumnSchema columnSchema = GeneralTestUtility.sealedColumn("source"); "<AssertPlaceHolder>"; }
requiresPreprocessing() { boolean requiresPreprocessing = pad != null && pad.requiresPreprocessing(); requiresPreprocessing |= type != ColumnType.CLEARTEXT; return requiresPreprocessing; }
[*] target: assertTrue(columnSchema.requiresPreprocessing())
[-] pred: org. junit. Assert. assertTrue ( columnSchema. requiresPreprocessing() )
************************************
************************************
[+] input: concreteGivenFullyQualifiedNameAndTypeArguments() { ConcreteTypeConstructor expected = new ConcreteTypeConstructor(ERUDITE, asList(STRING_TYPE_CONSTRUCTOR.invariant(), TypeConstructor.placeholder().covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant())); ConcreteTypeConstructor toVerify = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.invariant(), TypeConstructor.placeholder().covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant());  "<AssertPlaceHolder>"; }
contravariant() { return TypeConstructorArgument.of(CONTRAVARIANT, this); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: 카트라인_결제금액_있을때_결제필요_여부_조회() { // given Money won2000 = Money.wons(2000L); given(cartOptionAnswer.getAdditionalPrice()).willReturn(won2000); // when Boolean needPaid = hasPriceCartLineItem.isNeedPaid(); // then "<AssertPlaceHolder>"; }
isNeedPaid() { // 0 < totalCartLinePrice return Money.ZERO.isLessThan(getTotalCartLinePrice()); }
[*] target: assertTrue(needPaid)
[-] pred: org. junit. Assert. assertTrue ( needPaid )
************************************
************************************
[+] input: format_ShouldFormatInstantValueAsString() { String valueAsString = "220412215715"; Instant value = LocalDateTime.parse(valueAsString, formatter).toInstant(zoneOffset); String expected = TypeCodecs.TIMESTAMP.format(value);  String result = codec.format(valueAsString); Assertions."<AssertPlaceHolder>"; }
format(String value) { Instant instantValue = LocalDateTime.parse(value, formatter).toInstant(zoneOffset); return TypeCodecs.TIMESTAMP.format(instantValue); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: startAt_가져오기_테스트() { // given LocalDateTime expectedStartAt = startAt; // when when(eventBasic.getStartAt()).thenReturn(expectedStartAt); event.setEventBasic(eventBasic); LocalDateTime actualStartAt = event.getStartAt(); // then "<AssertPlaceHolder>"; }
getStartAt() { if (this.eventBasic == null) return null; return this.getEventBasic().getStartAt(); }
[*] target: assertEquals(expectedStartAt, actualStartAt)
[-] pred: org. junit. Assert. assertEquals ( expectedStartAt, actualStartAt )
************************************
************************************
[+] input: testCheckLicenseEngineLimitWithDaas() { connectorManager = spy(ConnectorManager.class); ClientMongoOperator clientMongoOperator = mock(ClientMongoOperator.class); ReflectionTestUtils.setField(connectorManager,"clientMongoOperator",clientMongoOperator); CheckEngineValidResultDto excepted = mock(CheckEngineValidResultDto.class); when(connectorManager.checkLicenseEngineLimit()).thenReturn(excepted); CheckEngineValidResultDto actual = connectorManager.checkLicenseEngineLimit(); "<AssertPlaceHolder>"; }
checkLicenseEngineLimit() { CheckEngineValidResultDto resultDto = null; if (!AppType.currentType().isCloud()) { try { Map<String, Object> processId = new HashMap<>(); processId.put("processId", instanceNo); resultDto = clientMongoOperator.findOne(processId, ConnectorConstant.LICENSE_COLLECTION + "/checkEngineValid", CheckEngineValidResultDto.class); } catch (Exception e) { Throwable cause = CommonUtils.matchThrowable(e, HttpClientErrorException.class); if (cause instanceof HttpClientErrorException && ((HttpClientErrorException) cause).getRawStatusCode() == 404){ return null; } } } return resultDto; }
[*] target: assertEquals(excepted,actual)
[-] pred: org. junit. Assert. assertEquals ( excepted, actual )
************************************
************************************
[+] input: testOfferWhenTryEmitReturnFalse() { when(mockHazelcastBaseNode.tryEmit(tapdataEvent, 1)).thenReturn(false); boolean actual = mockHazelcastBaseNode.offer(tapdataEvent); "<AssertPlaceHolder>"; }
offer(TapdataEvent dataEvent) { if (dataEvent != null) { if (processorBaseContext.getNode() != null) { dataEvent.addNodeId(processorBaseContext.getNode().getId()); } Outbox outbox = getOutboxAndCheckNullable(); int bucketCount = outbox.bucketCount(); if (!tryEmit(dataEvent, bucketCount)) return false; } bucketIndex = 0; // reset to 0 of return true return true; }
[*] target: assertFalse(actual)
[-] pred: org. junit. Assert. assertFalse ( actual )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismTwoNodeButNotAllNodeAreNull1() { when(nodeList.size()).thenReturn(2); when(nodeList.get(1)).thenReturn(null);  JsProcessorNode node2 = mock(JsProcessorNode.class); when(nodeList.get(0)).thenReturn(node2); boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(1)).get(0); verify(nodeList, times(0)).get(1); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: raw() { String expected = "String"; String toVerify = new ClassName("String").raw();  "<AssertPlaceHolder>"; }
raw() { return className; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testShouldTriggerCronBasedSnapshot_NextValidTimeAfterCurrent() { String cronExpressionString = "0 */10 * * * ?"; // Every 10th minute CronExpression cronExpression = SnapshotUtils.interpretAsCron(cronExpressionString).get();  Calendar calendar = Calendar.getInstance(); calendar.set(2022, Calendar.JUNE, 5, 11, 5);  Instant now = calendar.getTime().toInstant(); // 11:05 Instant lastTrigger = now.minus(Duration.ofMinutes(4)); // 11:01, next trigger at 11:10  boolean result = SnapshotUtils.shouldTriggerCronBasedSnapshot( CHECKPOINT, cronExpression, lastTrigger, now);  "<AssertPlaceHolder>"; }
shouldTriggerCronBasedSnapshot( SnapshotType snapshotType, CronExpression cronExpression, Instant lastTriggerDateInstant, Instant nowInstant) { Date now = Date.from(nowInstant); Date lastTrigger = Date.from(lastTriggerDateInstant);  Date nextValidTimeAfterLastTrigger = cronExpression.getNextValidTimeAfter(lastTrigger);  if (nextValidTimeAfterLastTrigger != null && nextValidTimeAfterLastTrigger.before(now)) { LOG.info( "Triggering new automatic {} based on cron schedule '{}' due at {}", snapshotType.toString().toLowerCase(), cronExpression.toString(), nextValidTimeAfterLastTrigger); return true; } else { return false; } }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: writeStringLatin1() { byte[] bytes = new byte[256]; for (int i = 0; i < bytes.length; i++) { bytes[i] = (byte) i; } JSONWriter jsonWriter = (JSONWriter) new JSONWriterUTF8Vector.Factory().apply(JSONFactory.createWriteContext()); jsonWriter.writeStringLatin1(bytes); String json = jsonWriter.toString(); String str = new String(bytes, 0, bytes.length, StandardCharsets.ISO_8859_1); Object parse = JSON.parse(json); "<AssertPlaceHolder>"; }
writeStringLatin1(byte[] value) { if ((context.features & BrowserSecure.mask) != 0) { writeStringLatin1BrowserSecure(value); return; }  boolean escape = false; int i = 0; // vector optimize 8 final int upperBound = (value.length - i) & ~7; for (; i < upperBound; i += 8) { Vector<Byte> v = ByteVector.SPECIES_64.fromArray(value, i); if (v.eq(V_BYTE_64_DOUBLE_QUOTE) .or(v.eq(V_BYTE_64_SLASH)) .or(v.lt(V_BYTE_64_SPACE)) .anyTrue()) { escape = true; break; } }  if (!escape) { for (; i < value.length; ++i) { byte c = value[i]; if (c == quote || c == '\' || c < ' ') { escape = true; break; } } }  if (!escape) { int off = this.off; int minCapacity = off + value.length + 2; if (minCapacity >= this.bytes.length) { ensureCapacity(minCapacity); }  final byte[] bytes = this.bytes; bytes[off++] = (byte) this.quote; System.arraycopy(value, 0, bytes, off, value.length); off += value.length; bytes[off] = (byte) this.quote; this.off = off + 1; return; } writeStringEscaped(value); }
[*] target: assertEquals(str, parse)
[-] pred: org. junit. Assert. assertEquals ( str, parse )
************************************
************************************
[+] input: corretorasPass() { Corretora[] corretoras = BrasilAPI.corretoras(); "<AssertPlaceHolder>"; }
corretoras() { Corretora[] obj = (Corretora[]) api(Corretora[].class, "cvm/corretoras/v1", ""); return obj != null ? (Corretora[]) obj.clone() : null; }
[*] target: assertNotNull(corretoras)
[-] pred: org. junit. Assert. assertNotNull ( corretoras )
************************************
************************************
[+] input: testUnbindByProcessIdWithId() { String processId = "111"; Query query = Query.query(Criteria.where("process_id").is(processId).and("worker_type").is("connector")); Update update = Update.update("licenseBind", false); UpdateResult result = new UpdateResult() { @Override public boolean wasAcknowledged() { return false; } @Override public long getMatchedCount() { return 1; } @Override public long getModifiedCount() { return 1; } @Override public BsonValue getUpsertedId() { return null; } }; when(workerRepository.update(query,update)).thenReturn(result); boolean actual = workerService.unbindByProcessId(processId); "<AssertPlaceHolder>"; }
unbindByProcessId(String processId);
[*] target: assertEquals(true,actual)
[-] pred: org. junit. Assert. assertEquals ( true, actual )
************************************
************************************
[+] input: givenInstanceMethodAndExplicitTypeArguments() { String toVerify = methodCall() .withObjectPath("objects") .withTypeArguments(CHAR_SEQUENCE) .withMethodName("map") .withArguments("java.lang.Object::toString") .generate();  String expected = "objects.<java.lang.CharSequence>map(java.lang.Object::toString)";  "<AssertPlaceHolder>"; }
generate() { return objectPathOrTypeGenerator.generate() + PERIOD + generateOptionalTypeArguments() + methodName + arguments.stream().collect(joining(SEPARATOR, OPEN_PARENTHESIS, CLOSE_PARENTHESIS)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testDeleteFileOfFile() { //            File file = new File("temp.txt"); //            try { //                if (file.createNewFile() && file.exists()) { //                    utils.deleteFile(file, new TapLog()); //                    Assertions."<AssertPlaceHolder>"; //                } //            } catch (IOException ignore) { } //        }
deleteFile(File file, Log logger) { if (file.exists()) { try { if (file.isDirectory()) { FileUtils.deleteDirectory(file); } else { FileUtils.delete(file); } } catch (Exception e){ logger.info("file not be delete, file: {}, message: {}", file.getAbsolutePath(), e.getMessage()); } } }
[*] target: assertFalse(file.exists())
[-] pred: org. junit. Assert. assertFalse ( file. exists ( ) )
************************************
************************************
[+] input: testSaveDataFailure() {  CollectRep.MetricsData metricsData = mock(CollectRep.MetricsData.class); when(metricsData.getCode()).thenReturn(CollectRep.Code.FAIL);  memoryDataStorage.saveData(metricsData);  List<CollectRep.MetricsData> result = memoryDataStorage.getCurrentMetricsData(metricsData.getId()); "<AssertPlaceHolder>"; }
getCurrentMetricsData(@NonNull Long monitorId) { Map<String, CollectRep.MetricsData> metricsDataMap = monitorMetricsDataMap.computeIfAbsent(monitorId, key -> new ConcurrentHashMap<>(METRICS_SIZE)); return new ArrayList<>(metricsDataMap.values()); }
[*] target: assertTrue(result.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( result. isEmpty ( ) )
************************************
************************************
[+] input: generic() { GenericTypeConstructor expected = new GenericTypeConstructor(T); GenericTypeConstructor toVerify = TypeConstructor.generic(T);  "<AssertPlaceHolder>"; }
generic(TypeParameterName name) { return new GenericTypeConstructor(name); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testReturnSubstringWithCodon4() { String expectedResult = this.expectedCodon4; String actualSubstringResult = returnSubstring(this.testInput, this.testCodon4); "<AssertPlaceHolder>"; }
returnSubstring(String dnaString, int index) { return dnaString.substring(index, index + 3).toUpperCase(); }
[*] target: assertEquals(expectedResult, actualSubstringResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualSubstringResult )
************************************
************************************
[+] input: testInterceptAspectTest() { AspectInterceptResult aspect = observableAspectTask.onInterceptAspect(null); Assertions."<AssertPlaceHolder>"; }
onInterceptAspect(Aspect aspect) { return null; }
[*] target: assertNull(aspect)
[-] pred: org. junit. Assert. assertNull ( aspect )
************************************
************************************
[+] input: marshalNullDataPreserveNullsTrueTest() { fingerprintTransformer = new FingerprintTransformer(secretKey, salt, ClientSettings.lowAssuranceMode(), false); final byte[] hmacText = fingerprintTransformer.marshal(null, context); "<AssertPlaceHolder>"; }
marshal(final byte[] cleartext, final EncryptionContext encryptionContext) { if (encryptionContext == null) { throw new C3rIllegalArgumentException("An EncryptionContext must be provided when marshaling."); } if (encryptionContext.getClientDataType() == null) { throw new C3rIllegalArgumentException("EncryptionContext missing ClientDataType when encrypting data for column `" + encryptionContext.getColumnLabel() + "`."); } if (!encryptionContext.getClientDataType().supportsFingerprintColumns()) { throw new C3rIllegalArgumentException(encryptionContext.getClientDataType() + " is not a type supported by " + "fingerprint columns."); } if (!encryptionContext.getClientDataType().isEquivalenceClassRepresentativeType()) { throw new C3rIllegalArgumentException(encryptionContext.getClientDataType() + " is not the parent type of its equivalence " + "class. Expected parent type is " + encryptionContext.getClientDataType().getRepresentativeType() + "."); }  // Check if a plain null value should be used if (cleartext == null) { if (clientSettings.isPreserveNulls()) { return null; } }  final byte[] key; if (clientSettings.isAllowJoinsOnColumnsWithDifferentNames()) { key = hkdf.deriveKey(HKDF_INFO_BYTES, HMAC_KEY_SIZE); } else { final byte[] hkdfKeyInfo = (KeyUtil.HKDF_COLUMN_BASED_INFO + encryptionContext.getColumnLabel()) .getBytes(StandardCharsets.UTF_8); key = hkdf.deriveKey(hkdfKeyInfo, HMAC_KEY_SIZE); } final SecretKeySpec secretKeySpec = new SecretKeySpec(key, mac.getAlgorithm()); Arrays.fill(key, (byte) 0); // Safe to zero here. SecretKeySpec takes a clone on instantiation. try { mac.init(secretKeySpec); } catch (InvalidKeyException e) { throw new C3rRuntimeException("Initialization of hmac failed for target column `" + encryptionContext.getColumnLabel() + "`.", e); } final byte[] hmacBase64 = Base64.getEncoder().encode(mac.doFinal(cleartext)); final byte[] marshalledBytes = ByteBuffer.allocate(DESCRIPTOR_PREFIX.length + hmacBase64.length) .put(DESCRIPTOR_PREFIX) .put(hmacBase64) .array(); validateMarshalledByteLength(marshalledBytes); return marshalledBytes; }
[*] target: assertNull(hmacText)
[-] pred: org. junit. Assert. assertNull ( hmacText )
************************************
************************************
[+] input: CleanRoomsException { final ClientSettings expectedClientSettings = ClientSettings.builder() .allowCleartext(true) .allowDuplicates(true) .allowJoinsOnColumnsWithDifferentNames(false) .preserveNulls(false) .build(); final DataEncryptionMetadata metadata = DataEncryptionMetadata.builder() .allowCleartext(expectedClientSettings.isAllowCleartext()) .allowDuplicates(expectedClientSettings.isAllowDuplicates()) .allowJoinsOnColumnsWithDifferentNames(expectedClientSettings.isAllowJoinsOnColumnsWithDifferentNames()) .preserveNulls(expectedClientSettings.isPreserveNulls()) .build(); final Collaboration collaboration = Collaboration.builder() .dataEncryptionMetadata(metadata) .build(); final GetCollaborationResponse response = GetCollaborationResponse.builder() .collaboration(collaboration) .build(); final var client = mock(CleanRoomsClient.class); when(client.getCollaboration(any(GetCollaborationRequest.class))).thenReturn(response);  final var dao = spy(CleanRoomsDao.class); when(dao.getClient()).thenReturn(client); final var actualClientSettings = dao.getCollaborationDataEncryptionMetadata(GeneralTestUtility.EXAMPLE_SALT .toString()); "<AssertPlaceHolder>"; }
getCollaborationDataEncryptionMetadata(final String collaborationId) { final AwsRequestOverrideConfiguration overrideConfiguration = AwsRequestOverrideConfiguration.builder() .addApiName(apiName) .build(); final GetCollaborationRequest request = GetCollaborationRequest.builder() .collaborationIdentifier(collaborationId) .overrideConfiguration(overrideConfiguration) .build(); final String baseError = "Unable to retrieve the collaboration configuration for CollaborationID: `" + collaborationId + "`."; final String endError = "Please verify that the CollaborationID is correct and try again."; final GetCollaborationResponse response; try { response = getClient().getCollaboration(request); } catch (ResourceNotFoundException e) { throw new C3rRuntimeException(baseError + " No collaboration found. " + endError, e); } catch (AccessDeniedException e) { throw new C3rRuntimeException(baseError + " Access denied. " + endError, e); } catch (ThrottlingException e) { throw new C3rRuntimeException(baseError + " Throttling. Please wait a moment before trying again.", e); } catch (ValidationException e) { throw new C3rRuntimeException(baseError + " CollaborationID could not be validated. " + endError, e); } catch (SdkException e) { throw new C3rRuntimeException(baseError + " Unknown error: " + e.getMessage(), e); } final DataEncryptionMetadata metadata = response.collaboration().dataEncryptionMetadata(); if (metadata == null) { throw new C3rRuntimeException( "The collaboration with CollaborationID `" + collaborationId + "` was not created for use with " + "C3R! C3R must be enabled on the collaboration when it's created in order to continue."); } final var settings = ClientSettings.builder() .allowJoinsOnColumnsWithDifferentNames(metadata.allowJoinsOnColumnsWithDifferentNames()) .allowCleartext(metadata.allowCleartext()) .allowDuplicates(metadata.allowDuplicates()) .preserveNulls(metadata.preserveNulls()) .build();  final Function<Boolean, String> boolToYesOrNo = (b) -> b ? "yes" : "no";  log.debug("Cryptographic computing parameters found for collaboration {}:", collaborationId); log.debug("  * Allow cleartext columns = {}", boolToYesOrNo.apply(settings.isAllowCleartext())); log.debug("  * Allow duplicates = {}", boolToYesOrNo.apply(settings.isAllowDuplicates())); log.debug("  * Allow JOIN of columns with different names = {}", boolToYesOrNo.apply(settings.isAllowJoinsOnColumnsWithDifferentNames())); log.debug("  * Preserve NULL values = {}", boolToYesOrNo.apply(settings.isPreserveNulls()));  return settings; }
[*] target: assertEquals(expectedClientSettings, actualClientSettings)
[-] pred: org. junit. Assert. assertEquals ( expectedClientSettings, actualClientSettings )
************************************
************************************
[+] input: testGetLevel() { List<Level> levels = new ArrayList<>(); loggingService.getLevels().forEach(levels::add); List<Level> expected = asList(OFF, SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST, ALL); "<AssertPlaceHolder>"; }
getLevels() { return LEVELS; }
[*] target: assertEquals(expected, levels)
[-] pred: org. junit. Assert. assertEquals ( expected, levels )
************************************
************************************
[+] input: decode_ShouldDecodeTextByteBufferAndReturnAsInstant() { String valueAsString = "220412215715"; Instant value = LocalDateTime.parse(valueAsString, formatter).toInstant(zoneOffset); ByteBuffer byteBuffer = TypeCodecs.TEXT.encode(valueAsString, CqlConversion.PROTOCOL_VERSION);  Instant result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { String stringValue = TypeCodecs.TEXT.decode(bytes, protocolVersion); return LocalDateTime.parse(stringValue, formatter).toInstant(zoneOffset); }
[*] target: assertEquals(value, result)
[-] pred: org. junit. Assert. assertEquals ( value, result )
************************************
************************************
[+] input: testCloseOneWebHookByHookId() { WebHookInfoVo vo = new WebHookInfoVo(); when(webHookController.success(vo)).thenReturn(mock(ResponseMessage.class)); List mock = mock(List.class); when(mock.isEmpty()).thenReturn(false); when(mock.get(0)).thenReturn(vo); when(webHookService.close(any(String[].class), any(UserDetail.class))).thenReturn(mock); when(webHookController.closeOneWebHookByHookId("id")).thenCallRealMethod(); ResponseMessage<WebHookInfoVo> hook = webHookController.closeOneWebHookByHookId("id"); Assertions."<AssertPlaceHolder>"; verify(webHookController).success(vo); verify(webHookService).close(any(String[].class), any(UserDetail.class)); }
closeOneWebHookByHookId(@PathVariable(value = "id") String hookId) { List<WebHookInfoVo> closed = webHookService.close(new String[]{hookId}, getLoginUser()); if (closed.isEmpty()) { return success(null); } return success(closed.get(0)); }
[*] target: assertNotNull(hook)
[-] pred: org. junit. Assert. assertNotNull ( hook )
************************************
************************************
[+] input: bottomBit() { final int ret = set.previousClearBit(1);  "<AssertPlaceHolder>"; }
previousClearBit(int fromIndex);  // ------------------------------------------------------------------------ // bulk operations // ------------------------------------------------------------------------  /** * Returns {@code true}
[*] target: assertEquals(1, ret)
[-] pred: org. junit. Assert. assertEquals ( 1, ret )
************************************
************************************
[+] input: testHorizontalLayout() {  UISchemaBuilder builder = new UISchemaBuilder(Layout.HORIZONTAL); builder.addElements(new String[] { "firstName", "lastName", "role" });  String json = builder.build();  "<AssertPlaceHolder>";  logger.info(json);  }
build() {  // close current controllsBuilder.... if (controlsArrayBuilder != null && layoutContext != null) { layoutContext.add("elements", controlsArrayBuilder.build()); }  if (groupArrayBuilder != null) {  // close current layoutContext.... if (layoutsArrayBuilder != null && layoutContext != null) { this.layoutsArrayBuilder.add(layoutContext.build()); }  // close current gourpContext if (groupContext != null) { groupContext.add("elements", layoutsArrayBuilder.build()); groupArrayBuilder.add(groupContext); }  rootLayoutBuilder.add("elements", groupArrayBuilder.build()); }  // write result JsonObject jsonObject = rootLayoutBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: shouldSetAndGetScreenReaderMode() {  options.setScreenReaderMode(true); "<AssertPlaceHolder>"; }
isScreenReaderMode() { return screenReaderMode; }
[*] target: assertTrue(options.isScreenReaderMode())
[-] pred: org. junit. Assert. assertTrue ( options. isScreenReaderMode() )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(Instant value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } else { String stringValue = formatter.format(LocalDateTime.ofInstant(value, zoneOffset)); return TypeCodecs.TEXT.encode(stringValue, protocolVersion); } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testCheckIsCronOrPlanTaskWithFalsePlanTask() { TaskRepository repository = mock(TaskRepository.class); taskService = spy(new TaskServiceImpl(repository)); TaskDto taskDto = new TaskDto(); taskDto.setPlanStartDateFlag(false); boolean result = taskService.checkIsCronOrPlanTask(taskDto); "<AssertPlaceHolder>"; }
checkIsCronOrPlanTask(TaskDto task) { if(null == task) throw new IllegalArgumentException("Task can not be null"); if ((task.getCrontabExpressionFlag() != null && task.getCrontabExpressionFlag()) || task.isPlanStartDateFlag()) { return true; } else { return false; } }
[*] target: assertEquals(false, result)
[-] pred: org. junit. Assert. assertEquals ( false, result )
************************************
************************************
[+] input: format_ShouldFormatNumberValueAsText() { Long value = 9223372036854775807L; String expected = TypeCodecs.BIGINT.format(value); String result = codec.format(value); Assertions."<AssertPlaceHolder>"; }
format(Long value) { return TypeCodecs.BIGINT.format(value); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: calculateCodonStartIndicesUsingDnaSequenceWithLengthTwentyTwoFrame1Test() { int[] expectedResult = {0, 3, 6, 9, 12, 15, 18}; String testSequence = DNA_SEQUENCE_WITH_LENGTH_TWENTY_TWO; CodonFrame temp = new CodonFrame(testSequence, (short) 1, 1, 100); ReadingFrames readingFrameTest = new ReadingFrames(temp); int[] result = readingFrameTest.calculateCodonStartIndices(testSequence); "<AssertPlaceHolder>"; }
calculateCodonStartIndices(final String dna) { int[] codonStartIndices; // calculate max total codons possible final int maxTotalCodons = dna.length() / 3; // reading frame is 1-index based. Calculate offset for 0-index array. final int offset = this.codonFrame.getReadingFrame() - 1; int[] indexArray = IntStream.range(0, maxTotalCodons).map(index -> (index * 3 + offset)).toArray();  // if the last codon index is not 3 positions away from end, remove last index. if (dna.length() - indexArray[indexArray.length - 1] < 3) { codonStartIndices = Arrays.stream(indexArray).limit(indexArray.length - 1).toArray(); } else { codonStartIndices = indexArray; }  return codonStartIndices; }
[*] target: assertArrayEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedResult, result )
************************************
************************************
[+] input: parse_ShouldParseTextAndReturnAsInstant() { String valueAsString = "1681333035000"; Instant value = Instant.ofEpochMilli(Long.parseLong(valueAsString)); Instant result = codec.parse(valueAsString); Assertions."<AssertPlaceHolder>"; }
parse(String value) { return Instant.ofEpochMilli(Long.parseLong(value)); }
[*] target: assertEquals(value, result)
[-] pred: org. junit. Assert. assertEquals ( value, result )
************************************
************************************
[+] input: shouldSetGetOptionIndex() { int index = 1; component.setOptionIndex(index); verify(mockMixin).setOptionIndex(index);  when(mockMixin.getOptionIndex()).thenReturn(index); int result = component.getOptionIndex(); "<AssertPlaceHolder>"; }
getOptionIndex() { return hasOptionsMixin.getOptionIndex(); }
[*] target: assertEquals(index, result)
[-] pred: org. junit. Assert. assertEquals ( index, result )
************************************
************************************
[+] input: validateGivenOuterClassAsContainingClass() { ContainingClass toValidate = PackageName.of("nl.wernerdegroot.applicatives") .asPackage() .containingClass(modifiers(), ClassName.of("Outer"), A, B);  Validated<String, ClassValidator.Result> expected = Validated.valid(ClassValidator.Result.of(asList(A, B))); Validated<String, ClassValidator.Result> toVerify = ClassValidator.validate(toValidate);  "<AssertPlaceHolder>"; }
validate(ContainingClass containingClass) {  // We check whether we're dealing with an outer class or a static inner class. // Why is this required? Consider the following scenario: // //   class Outer<A extends B, B> { //     class Inner<B> { //       ... //     } //   } // // It is impossible to collapse these three type parameters of these two classes into a // single list of type parameters without carefully renaming some of them to avoid shadowing. // Instead of going through all that effort for this extreme edge-case, I'm just going avoid // it completely. If we'd like to be more sophisticated we could try: // //  * To support only a single class with type parameters in the hierarchy //  * Only support multiple classes with type parameters if their names don't conflict //  * Only support conflicts if the type parameter that is shadowed can be removed //    completely (isn't used as upper bound for any of the other type parameters) if (!containingClass.isOuterClass() && !containingClass.isStaticInnerClass()) { return Validated.invalid("Only outer classes and static inner classes are currently supported"); } List<TypeParameter> typeParameters = containingClass.getTypeParameters();  return Validated.valid(Result.of(typeParameters)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testGetCurrentMetricsDataByMetric() {  Long monitorId = 1L; String metric = "cpuUsage"; CollectRep.MetricsData metricsData = mock(CollectRep.MetricsData.class);  memoryDataStorage.saveData(metricsData);  CollectRep.MetricsData result = memoryDataStorage.getCurrentMetricsData(monitorId, metric);  "<AssertPlaceHolder>"; }
getCurrentMetricsData(@NonNull Long monitorId, @NonNull String metric) { Map<String, CollectRep.MetricsData> metricsDataMap = monitorMetricsDataMap.computeIfAbsent(monitorId, key -> new ConcurrentHashMap<>(METRICS_SIZE)); return metricsDataMap.get(metric); }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testInvalid() { Identifier identifier = new ItalianVATCodeIdentifier();  for (String invalid : new String[]{ "0344921012", "0396719092AA", "BRGSFN81P10L682F" }) { "<AssertPlaceHolder>"; } }
isOfThisType(String data) { return identifier.matcher(data).matches(); }
[*] target: assertFalse(identifier.isOfThisType(invalid))
[-] pred: org. junit. Assert. assertFalse ( identifier. isOfThisType ( invalid ) )
************************************
************************************
[+] input: shouldCalculateLoan() {  LoaCalculateLoanResponseDto result = loaLoanService.calculateLoan(24, BigDecimal.valueOf(3000));  "<AssertPlaceHolder>"; }
calculateLoan(Integer installment, BigDecimal principalLoanAmount) {  loaLoanValidationService.controlIsParameterNotNull(installment,principalLoanAmount);  BigDecimal installmentCount = BigDecimal.valueOf(installment);  BigDecimal totalInterestRate = INTEREST_RATE.add(TAX_RATE);  BigDecimal maturity = (installmentCount .multiply(BigDecimal.valueOf(30))).divide(BigDecimal.valueOf(36500),RoundingMode.CEILING);  BigDecimal totalInterest = (principalLoanAmount.multiply(totalInterestRate)).multiply(maturity).multiply(installmentCount); BigDecimal totalPayment = principalLoanAmount.add(totalInterest).add(ALLOCATION_FEE);  BigDecimal monthlyInstallmentAmount = totalPayment.divide(installmentCount,RoundingMode.CEILING);  BigDecimal annualCostRate = totalInterestRate.multiply(BigDecimal.valueOf(12));  loaLoanValidationService.controlIsInterestRateNotNegative(INTEREST_RATE); loaLoanValidationService.controlIsTaxRateNotNegative(TAX_RATE); loaLoanValidationService.controlIsInstallmentAmountPositive(monthlyInstallmentAmount); loaLoanValidationService.controlIsTotalPaymentPositive(totalPayment);  LoaCalculateLoanResponseDto loaCalculateLoanResponseDto = new LoaCalculateLoanResponseDto();  loaCalculateLoanResponseDto.setInterestRate(INTEREST_RATE); loaCalculateLoanResponseDto.setTotalInterest(totalInterest); loaCalculateLoanResponseDto.setMonthlyInstallmentAmount(monthlyInstallmentAmount); loaCalculateLoanResponseDto.setTotalPayment(totalPayment); loaCalculateLoanResponseDto.setAnnualCostRate(annualCostRate); loaCalculateLoanResponseDto.setAllocationFee(ALLOCATION_FEE);  return loaCalculateLoanResponseDto; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testCheckWhenSameDeptId() { SingleDeptDataPermissionChecker checker = new SingleDeptDataPermissionChecker(deptService); when(loginUser.getDeptId()).thenReturn(1L); DataCondition dataCondition = new DataCondition(); dataCondition.setTargetDeptId(1L);  boolean check = checker.check(loginUser, dataCondition);  "<AssertPlaceHolder>"; }
check(SystemLoginUser loginUser, DataCondition condition) { if (condition == null || loginUser == null) { return false; }  if (loginUser.getDeptId() == null || condition.getTargetDeptId() == null) { return false; }  Long currentDeptId = loginUser.getDeptId(); Long targetDeptId = condition.getTargetDeptId();  return Objects.equals(currentDeptId, targetDeptId); }
[*] target: assertTrue(check)
[-] pred: org. junit. Assert. assertTrue ( check )
************************************
************************************
[+] input: bind_withStandardInput() { BoundStatement result = targetUpdateStatement.bind(originRow, targetRow, null,null,null,null); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size())).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { // We reference the originRow and convert it to the target type. // We need the targetRow if (null == originRow) throw new RuntimeException("originRow is null");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue);  BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  Object originValue, targetValue; Object bindValueTarget = null; for (int targetIndex : columnIndexesToBind) { int originIndex = cqlTable.getCorrespondingIndex(targetIndex);  try { if (usingCounter && counterIndexes.contains(targetIndex)) { originValue = cqlTable.getOtherCqlTable().getData(originIndex, originRow); if (null == originValue) { currentBindIndex++; continue; } targetValue = (null == targetRow ? 0L : cqlTable.getData(targetIndex, targetRow)); bindValueTarget = ((Long) originValue - (null == targetValue ? 0L : (Long) targetValue)); } else if (targetIndex== explodeMapKeyIndex) { bindValueTarget = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValueTarget = explodeMapValue; } else { if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValueTarget = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValueTarget, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValueTarget + " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex) + "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex); throw e; } }  PKFactory pkFactory = session.getPKFactory(); EnhancedPK pk = pkFactory.getTargetPK(originRow); boundStatement = pkFactory.bindWhereClause(PKFactory.Side.TARGET, pk, boundStatement, currentBindIndex);  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: test_isCloudLimitScheduling() { ObjectId taskId = MongoUtils.toObjectId("632454d5287a904778c40f8d"); Query query = new Query(Criteria.where("_id").is(taskId)); query.fields().include("id", "agentId", "agentTags"); TaskEntity mockTask = new TaskEntity(); mockTask.setCrontabExpressionFlag(true); mockTask.setId(MongoUtils.toObjectId("632454d5287a904778c40f8d")); try (MockedStatic<DataPermissionService> serviceMockedStatic = Mockito.mockStatic(DataPermissionService.class)) { serviceMockedStatic.when(DataPermissionService::isCloud).thenReturn(true); when(settingsService.isCloud()).thenReturn(true); when(taskRepository.findOne(query)).thenReturn(Optional.of(mockTask)); TaskDto mockTaskDto = new TaskDto(); BeanUtils.copyProperties(mockTask, mockTaskDto); CalculationEngineVo mockEngineVo = new CalculationEngineVo(); mockEngineVo.setTaskLimit(5); mockEngineVo.setRunningNum(5); when(workerService.calculationEngine(mockTaskDto, user, null)).thenReturn(mockEngineVo); Query mockQuery = new Query(Criteria.where("_id").is(taskId)); mockQuery.fields().include("planStartDateFlag", "crontabExpressionFlag"); when(taskRepository.findOne(mockQuery)).thenReturn(Optional.of(mockTask)); boolean result = taskService.checkCloudTaskLimit(taskId, user, true); "<AssertPlaceHolder>"; } }
checkCloudTaskLimit(ObjectId taskId, UserDetail user, boolean checkCurrentTask); public abstract void updateDelayTime(ObjectId taskId, long delayTime); public abstract void refreshSchemas(TaskDto taskDto, String nodeIds, String keys, UserDetail userDetail); public abstract void checkSourceTimeDifference(TaskDto taskDto,UserDetail userDetail);  @Data @AllArgsConstructor @NoArgsConstructor public static class Char1Group { private String _id; private long count; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: calculateCodonStartIndicesUsingDnaSequenceWithLengthTwentyThreeFrame1Test() { int[] expectedResult = {0, 3, 6, 9, 12, 15, 18}; String testSequence = DNA_SEQUENCE_WITH_LENGTH_TWENTY_THREE; CodonFrame temp = new CodonFrame(testSequence, (short) 1, 1, 100); ReadingFrames readingFrameTest = new ReadingFrames(temp); int[] result = readingFrameTest.calculateCodonStartIndices(testSequence); "<AssertPlaceHolder>"; }
calculateCodonStartIndices(final String dna) { int[] codonStartIndices; // calculate max total codons possible final int maxTotalCodons = dna.length() / 3; // reading frame is 1-index based. Calculate offset for 0-index array. final int offset = this.codonFrame.getReadingFrame() - 1; int[] indexArray = IntStream.range(0, maxTotalCodons).map(index -> (index * 3 + offset)).toArray();  // if the last codon index is not 3 positions away from end, remove last index. if (dna.length() - indexArray[indexArray.length - 1] < 3) { codonStartIndices = Arrays.stream(indexArray).limit(indexArray.length - 1).toArray(); } else { codonStartIndices = indexArray; }  return codonStartIndices; }
[*] target: assertArrayEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedResult, result )
************************************
************************************
[+] input: getTopicsTeamsOverview_TeamIdNull() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when(handleDbRequestsJdbc.getTopicsCountByTeams(null, TestConstants.TENANT_ID)) .thenReturn(Collections.emptyList()); Mockito.when( commonUtilsService.getChartsJsOverview( eq(Collections.emptyList()), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getTopicsTeamsOverview(null, TestConstants.TENANT_ID);  Assertions."<AssertPlaceHolder>"; }
getTopicsTeamsOverview(Integer teamId, Integer tenantId) {  List<CommonUtilsService.ChartsOverviewItem<Integer, Integer>> teamCountList = manageDatabase.getHandleDbRequests().getTopicsCountByTeams(teamId, tenantId); String title = ANALYTICS_103; if (teamId != null) { title += " (" + manageDatabase.getTeamNameFromTeamId(tenantId, teamId) + ")"; } else { title += " (all teams)"; }  return commonUtilsService.getChartsJsOverview( teamCountList, title, "teamid", "Teams", "Topics", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldTriggerAutomaticSnapshot_ValidIntervalExpression() { boolean shouldTrigger = shouldTriggerAutomaticSnapshot( CHECKPOINT, "10m", Instant.now().minus(Duration.ofDays(365))); "<AssertPlaceHolder>"; }
shouldTriggerAutomaticSnapshot( SnapshotType snapshotType, String automaticTriggerExpression, Instant lastTrigger) { if (StringUtils.isBlank(automaticTriggerExpression)) { return false; } // automaticTriggerExpression was configured by the user  Optional<Duration> interval = interpretAsInterval(automaticTriggerExpression); Optional<CronExpression> cron = interpretAsCron(automaticTriggerExpression);  // This should never happen. The string cannot be both a valid Duration and a cron // expression at the same time. if (interval.isPresent() && cron.isPresent()) { LOG.error( "Something went wrong with the automatic {} trigger expression {}. This setting cannot be simultaneously a valid Duration and a cron expression.", snapshotType, automaticTriggerExpression); return false; }  if (interval.isPresent()) { return shouldTriggerIntervalBasedSnapshot(snapshotType, interval.get(), lastTrigger); } else if (cron.isPresent()) { return shouldTriggerCronBasedSnapshot( snapshotType, cron.get(), lastTrigger, Instant.now()); } else { LOG.warn( "Automatic {} triggering is configured, but the trigger expression '{}' is neither a valid Duration, nor a cron expression.", snapshotType, automaticTriggerExpression); return false; } }
[*] target: assertTrue(shouldTrigger)
[-] pred: org. junit. Assert. assertTrue ( shouldTrigger )
************************************
************************************
[+] input: BBjException { component.setAllowCustomValue(true); "<AssertPlaceHolder>";  verify(control, times(1)).setProperty("customValue", true); verify(control, times(0)).getProperty("customValue"); }
isAllowCustomValue() { return allowCustomValue; }
[*] target: assertEquals(true, component.isAllowCustomValue())
[-] pred: org. junit. Assert. assertEquals ( true, component. isAllowCustomValue() )
************************************
************************************
[+] input: testCheckIsCronOrPlanTaskWithFalseCronTask() { TaskRepository repository = mock(TaskRepository.class); taskService = spy(new TaskServiceImpl(repository)); TaskDto taskDto = new TaskDto(); taskDto.setCrontabExpressionFlag(false); boolean result = taskService.checkIsCronOrPlanTask(taskDto); "<AssertPlaceHolder>"; }
checkIsCronOrPlanTask(TaskDto task) { if(null == task) throw new IllegalArgumentException("Task can not be null"); if ((task.getCrontabExpressionFlag() != null && task.getCrontabExpressionFlag()) || task.isPlanStartDateFlag()) { return true; } else { return false; } }
[*] target: assertEquals(false, result)
[-] pred: org. junit. Assert. assertEquals ( false, result )
************************************
************************************
[+] input: calculateCodonStartIndicesUsingDnaSequenceWithLengthTwentyThreeFrame2Test() { int[] expectedResult = {1, 4, 7, 10, 13, 16, 19}; String testSequence = DNA_SEQUENCE_WITH_LENGTH_TWENTY_THREE; CodonFrame temp = new CodonFrame(testSequence, (short) 2, 1, 100); ReadingFrames readingFrameTest = new ReadingFrames(temp); int[] result = readingFrameTest.calculateCodonStartIndices(testSequence); "<AssertPlaceHolder>"; }
calculateCodonStartIndices(final String dna) { int[] codonStartIndices; // calculate max total codons possible final int maxTotalCodons = dna.length() / 3; // reading frame is 1-index based. Calculate offset for 0-index array. final int offset = this.codonFrame.getReadingFrame() - 1; int[] indexArray = IntStream.range(0, maxTotalCodons).map(index -> (index * 3 + offset)).toArray();  // if the last codon index is not 3 positions away from end, remove last index. if (dna.length() - indexArray[indexArray.length - 1] < 3) { codonStartIndices = Arrays.stream(indexArray).limit(indexArray.length - 1).toArray(); } else { codonStartIndices = indexArray; }  return codonStartIndices; }
[*] target: assertArrayEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedResult, result )
************************************
************************************
[+] input: testRunningTaskNum() { long except = 5L; when(taskRepository.count(Query.query(Criteria.where("is_deleted").ne(true) .and("syncType").in(TaskDto.SYNC_TYPE_SYNC, TaskDto.SYNC_TYPE_MIGRATE) .and("status").nin(TaskDto.STATUS_DELETE_FAILED,TaskDto.STATUS_DELETING) .orOperator(Criteria.where("status").in(TaskDto.STATUS_RUNNING, TaskDto.STATUS_SCHEDULING, TaskDto.STATUS_WAIT_RUN), Criteria.where("planStartDateFlag").is(true), Criteria.where("crontabExpressionFlag").is(true) )),user)).thenReturn(except); long result = taskService.runningTaskNum(user); "<AssertPlaceHolder>"; }
runningTaskNum(UserDetail userDetail) { long workNum = count(Query.query(Criteria.where(IS_DELETED).ne(true) .and(SYNC_TYPE).in(TaskDto.SYNC_TYPE_SYNC, TaskDto.SYNC_TYPE_MIGRATE) .and(STATUS).nin(TaskDto.STATUS_DELETE_FAILED,TaskDto.STATUS_DELETING) .orOperator(Criteria.where(STATUS).in(TaskDto.STATUS_RUNNING, TaskDto.STATUS_SCHEDULING, TaskDto.STATUS_WAIT_RUN), Criteria.where(PLAN_START_DATE_FLAG).is(true), Criteria.where(CRONTAB_EXPRESSION_FLAG).is(true) )), userDetail); return (int) workNum; }
[*] target: assertEquals(except,result)
[-] pred: org. junit. Assert. assertEquals ( except, result )
************************************
************************************
[+] input: taxasPass() { Taxa[] taxas = BrasilAPI.taxas(); "<AssertPlaceHolder>"; }
taxas() { Taxa[] obj = (Taxa[]) api(Taxa[].class, "taxas/v1", ""); return obj != null ? (Taxa[]) obj.clone() : null; }
[*] target: assertNotNull(taxas)
[-] pred: org. junit. Assert. assertNotNull ( taxas )
************************************
************************************
[+] input: testStartInstallService_ClusterServiceCommandServiceReturnsNoItems() { // Setup final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  when(mockCommandService.listByIds(Arrays.asList("value"))).thenReturn(Collections.emptyList());  // Configure ClusterInfoService.getById(...). final ClusterInfoEntity clusterInfoEntity = new ClusterInfoEntity(); clusterInfoEntity.setId(0); clusterInfoEntity.setCreateBy("createBy"); clusterInfoEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterInfoEntity.setClusterName("clusterName"); clusterInfoEntity.setClusterCode("clusterCode"); clusterInfoEntity.setClusterFrame("clusterFrame"); clusterInfoEntity.setFrameVersion("frameVersion"); clusterInfoEntity.setClusterState(ClusterState.RUNNING); clusterInfoEntity.setFrameId(0); final UserInfoEntity userInfoEntity = new UserInfoEntity(); userInfoEntity.setId(0); userInfoEntity.setUsername("username"); userInfoEntity.setPassword("password"); userInfoEntity.setEmail("email"); userInfoEntity.setPhone("phone"); clusterInfoEntity.setClusterManagerList(Arrays.asList(userInfoEntity)); when(mockClusterInfoService.getById(0)).thenReturn(clusterInfoEntity);  // Configure ClusterServiceCommandHostCommandService.getHostCommandListByCommandId(...). final ClusterServiceCommandHostCommandEntity clusterServiceCommandHostCommandEntity = new ClusterServiceCommandHostCommandEntity(); clusterServiceCommandHostCommandEntity.setHostCommandId("hostCommandId"); clusterServiceCommandHostCommandEntity.setCommandName("commandName"); clusterServiceCommandHostCommandEntity.setCommandState(CommandState.WAIT); clusterServiceCommandHostCommandEntity.setCommandStateCode(0); clusterServiceCommandHostCommandEntity.setCommandProgress(0); clusterServiceCommandHostCommandEntity.setCommandHostId("commandHostId"); clusterServiceCommandHostCommandEntity.setCommandId("commandId"); clusterServiceCommandHostCommandEntity.setHostname("hostname"); clusterServiceCommandHostCommandEntity.setServiceRoleName("serviceRoleName"); clusterServiceCommandHostCommandEntity.setServiceRoleType(RoleType.MASTER); clusterServiceCommandHostCommandEntity.setResultMsg("resultMsg"); clusterServiceCommandHostCommandEntity.setCreateTime( new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceCommandHostCommandEntity.setCommandType(0); final List<ClusterServiceCommandHostCommandEntity> clusterServiceCommandHostCommandEntities = Arrays.asList( clusterServiceCommandHostCommandEntity); when(mockHostCommandService.getHostCommandListByCommandId("commandId")).thenReturn( clusterServiceCommandHostCommandEntities);  // Run the test final Result result = serviceInstallServiceImplUnderTest.startInstallService(0, Arrays.asList("value"));  // Verify the results "<AssertPlaceHolder>"; }
startInstallService(Integer clusterId, List<String> commandIds) { Collection<ClusterServiceCommandEntity> commands = commandService.listByIds(commandIds); ClusterInfoEntity clusterInfo = clusterInfoService.getById(clusterId); DAG<String, ServiceNode, ServiceNodeEdge> dag = new DAG<>(); for (ClusterServiceCommandEntity command : commands) { List<ClusterServiceCommandHostCommandEntity> commandHostList = hostCommandService.getHostCommandListByCommandId(command.getCommandId()); List<ServiceRoleInfo> masterRoles = new ArrayList<>(); List<ServiceRoleInfo> elseRoles = new ArrayList<>(); ServiceNode serviceNode = new ServiceNode(); String serviceKey = clusterInfo.getClusterFrame() + Constants.UNDERLINE + command.getServiceName(); ServiceInfo serviceInfo = ServiceInfoMap.get(serviceKey); for (ClusterServiceCommandHostCommandEntity hostCommand : commandHostList) { String key = clusterInfo.getClusterFrame() + Constants.UNDERLINE + command.getServiceName() + Constants.UNDERLINE + hostCommand.getServiceRoleName(); ServiceRoleInfo serviceRoleInfo = ServiceRoleMap.get(key); serviceRoleInfo.setHostname(hostCommand.getHostname()); serviceRoleInfo.setHostCommandId(hostCommand.getHostCommandId()); serviceRoleInfo.setClusterId(clusterId); serviceRoleInfo.setParentName(command.getServiceName()); if (Constants.MASTER.equals(serviceRoleInfo.getRoleType())) { masterRoles.add(serviceRoleInfo); } else { elseRoles.add(serviceRoleInfo); } } serviceNode.setMasterRoles(masterRoles); serviceNode.setElseRoles(elseRoles); dag.addNode(command.getServiceName(), serviceNode); if (serviceInfo.getDependencies().size() > 0) { for (String dependency : serviceInfo.getDependencies()) { dag.addEdge(dependency, command.getServiceName()); } } } return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: lambdaWithSingleExpressionAsSingleLine() { String toVerify = lambda() .withParameterNames("capacity", "hasPower") .withExpression("new Device(capacity, hasPower)") .generate();  String expected = "(capacity, hasPower) -> new Device(capacity, hasPower)";  "<AssertPlaceHolder>"; }
generate() { return generateParameterList() + SPACE + ARROW + SPACE + expression; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: banksPass() { Bank[] bank = BrasilAPI.banks(); "<AssertPlaceHolder>"; }
banks() { Bank[] obj = (Bank[]) api(Bank[].class, "banks/v1", ""); return obj != null ? (Bank[]) obj.clone() : null; }
[*] target: assertNotNull(bank)
[-] pred: org. junit. Assert. assertNotNull ( bank )
************************************
************************************
[+] input: test2() { UserDetail userDetail = mock(UserDetail.class); Filter filter = new Filter(); filter.setWhere(null); String heartbeatQualifiedNameByNodeId = metadataInstancesService.findHeartbeatQualifiedNameByNodeId(filter, userDetail); "<AssertPlaceHolder>"; }
findHeartbeatQualifiedNameByNodeId(Filter filter, UserDetail user) { Where where = filter.getWhere(); if (where == null) { return null; }  final String nodeId = (String) where.get(NODE_ID); AtomicReference<String> taskId = new AtomicReference<>(); return Optional.ofNullable(nodeId).map(nid -> { // find running task Query query = new Query(Criteria.where(DAG_NODES_ID).is(nid)); query.fields().include("_id"); return taskService.findOne(query, user); }).map(task -> task.getId().toHexString()).map(tid -> { // get heartbeat task dag of the connection node Criteria criteria = Criteria.where(ConnHeartbeatUtils.TASK_RELATION_FIELD).is(tid); criteria.and("status").ne("deleting"); criteria.and(IS_DELETED).ne(true); Query query = new Query(criteria); query.fields().include("_id", "dag"); return taskService.findOne(query, user); }).map(taskDto -> { taskId.set(taskDto.getId().toHexString()); return taskDto.getDag(); }).map(DAG::getTargets).map(targets -> { // if target size is not only one to be fix the logic if (targets.size() == 1) { return targets.get(0); } return null; }).map(node -> { if (node instanceof DataNode) { DataNode dataNode = (DataNode) node; String connectionId = dataNode.getConnectionId(); DataSourceConnectionDto dataSource = dataSourceService.findById(MongoUtils.toObjectId(connectionId)); return MetaDataBuilderUtils.generatePdkQualifiedName(dataNode.getType(), connectionId, ConnHeartbeatUtils.TABLE_NAME, dataSource.getDefinitionPdkId(), dataSource.getDefinitionGroup(), dataSource.getDefinitionVersion(), taskId.get()); } return null; }).orElse(null); }
[*] target: assertEquals(null, heartbeatQualifiedNameByNodeId)
[-] pred: org. junit. Assert. assertEquals ( null, heartbeatQualifiedNameByNodeId )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismTwoNodeButNotAllNodeAreDataParentNode1() { when(nodeList.size()).thenReturn(2); DataParentNode node2 = mock(DataParentNode.class); when(node2.getDatabaseType()).thenReturn("mock-type"); when(nodeList.get(0)).thenReturn(node2);  JsProcessorNode node1 = mock(JsProcessorNode.class); when(nodeList.get(1)).thenReturn(node1); boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(1)).get(0); verify(nodeList, times(1)).get(1); verify(node2, times(0)).getDatabaseType(); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: validateGivenMethodWithNoSharedTypeConstructorBetweenInputParametersAndReturnType() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter()), Optional.of(COMPLETABLE_FUTURE.with(V)), "myFunction", asList( Parameter.of(OPTIONAL.with(T), "left"), Parameter.of(OPTIONAL.with(U), "right"), Parameter.of(BI_FUNCTION.with(T.asType().contravariant(), U.asType().contravariant(), V.asType().covariant()), "compose") ) );  Validated<String, AccumulatorValidator.Result> expected = Validated.invalid("No shared type constructor between parameters (java.util.Optional<T> and java.util.Optional<U>) and result (java.util.concurrent.CompletableFuture<V>)"); Validated<String, AccumulatorValidator.Result> toVerify = AccumulatorValidator.validate(toValidate, new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
validate(Method method, ParametersAndTypeParametersValidator parametersAndTypeParametersValidator) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages); ParametersAndTypeParametersValidator.Result parametersAndTypeParameters = verifyParametersAndTypeParameters(method, parametersAndTypeParametersValidator, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  // Assign a meaningful name to each of the (three) type parameters: TypeParameter leftInputTypeConstructorArgument = parametersAndTypeParameters.getLeftInputTypeConstructorArgument(); TypeParameter rightInputTypeConstructorArgument = parametersAndTypeParameters.getRightInputTypeConstructorArgument(); TypeParameter returnTypeConstructorArgument = parametersAndTypeParameters.getReturnTypeConstructorArgument();  // Assign a meaningful name to the left and right parameters: Type leftParameterType = parametersAndTypeParameters.getLeftParameterType(); Type rightParameterType = parametersAndTypeParameters.getRightParameterType();  String name = method.getName();  TypeConstructor accumulatedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(returnTypeConstructorArgument.getName()); TypeConstructor partiallyAccumulatedTypeConstructor = leftParameterType.asTypeConstructorWithPlaceholderFor(leftInputTypeConstructorArgument.getName()); TypeConstructor inputTypeConstructor = rightParameterType.asTypeConstructorWithPlaceholderFor(rightInputTypeConstructorArgument.getName());  if (!partiallyAccumulatedTypeConstructor.canAccept(accumulatedTypeConstructor)) { // Tweak the error message to not confuse people using the simple case where // parameter types and result type should be identical: if (Objects.equals(partiallyAccumulatedTypeConstructor, inputTypeConstructor)) { return Validated.invalid("No shared type constructor between parameters (" + generateFrom(leftParameterType) + " and " + generateFrom(rightParameterType) + ") and result (" + generateFrom(returnType) + ")"); } else { return Validated.invalid("No shared type constructor between first parameter (" + generateFrom(leftParameterType) + ") and result (" + generateFrom(returnType) + ")"); } }  verifyNoCrossReferences(method.getTypeParameters(), leftParameterType, partiallyAccumulatedTypeConstructor, "type of the first parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), rightParameterType, inputTypeConstructor, "type of the second parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), returnType, accumulatedTypeConstructor, "return type", errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  return Validated.valid( AccumulatorValidator.Result.of( name, inputTypeConstructor, partiallyAccumulatedTypeConstructor, accumulatedTypeConstructor, leftParameterType, rightParameterType, returnType ) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: format_ShouldFormatValueAsString() { String valueAsString = "101"; Integer value = Integer.valueOf(valueAsString); String expected = TypeCodecs.INT.format(value);  String result = codec.format(valueAsString); Assertions."<AssertPlaceHolder>"; }
format(String value) { int intValue = Integer.parseInt(value); return TypeCodecs.INT.format(intValue); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testUpdateTasksException() { // // Setup Test Data and Interactions // RuntimeException testException = new RuntimeException("x-test-exception-x"); Mockito.doThrow(testException) .when(mockTaskSetStorage) .atomicUpdateTaskSetForLocation("x-tenant-id-x", "505050", mockTaskSetGrpcServiceUpdateProcessor);  // // Execute // target.setGrpcIpcServer(mockGrpcIpcServer); target.setTaskSetStorage(mockTaskSetStorage); target.setTaskSetGrpcServiceUpdateProcessorFactory(mockTaskSetGrpcServiceUpdateProcessorFactory);  RuntimeException actualException = null; try { target.updateTasks(testRequest, mockUpdateTasksRepsonseStreamObserver); fail("missing expected exception"); } catch (RuntimeException thrown) { actualException = thrown; }  // // Verify the Results // "<AssertPlaceHolder>"; Mockito.verifyNoInteractions(mockUpdateTasksRepsonseStreamObserver); }
updateTasks(UpdateTasksRequest request, StreamObserver<UpdateTasksResponse> responseObserver) { TaskSetGrpcServiceUpdateProcessor updateProcessor = taskSetGrpcServiceUpdateProcessorFactory.create(request);  try { taskSetStorage.atomicUpdateTaskSetForLocation( request.getTenantId(), request.getLocationId(), updateProcessor); } catch (RuntimeException rtExc) { // Log exceptions here that might otherwise get swallowed LOG.warn("error applying task set updates", rtExc); throw rtExc; }  UpdateTasksResponse response = UpdateTasksResponse.newBuilder() .setNumNew(updateProcessor.getNumNew()) .setNumReplaced(updateProcessor.getNumReplaced()) .setNumRemoved(updateProcessor.getNumRemoved()) .build();  responseObserver.onNext(response); responseObserver.onCompleted(); }
[*] target: assertSame(testException, actualException)
[-] pred: org. junit. Assert. assertSame ( testException, actualException )
************************************
************************************
[+] input: getAclsEnvOverview() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when( handleDbRequestsJdbc.getAclsCountByEnv(TestConstants.TEAM_ID, TestConstants.TENANT_ID)) .thenReturn(TestConstants.ACLS_COUNT_BY_ENV_ID_INTEGERE); Mockito.when( manageDatabase.getTeamNameFromTeamId(TestConstants.TENANT_ID, TestConstants.TEAM_ID)) .thenReturn(TestConstants.TEAM_NAME); Mockito.when(manageDatabase.getEnvsOfTenantsMap()) .thenReturn(Map.of(TestConstants.TENANT_ID, List.of(TestConstants.ENV_ID))); Mockito.when( commonUtilsService.getChartsJsOverview( anyList(), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getAclsEnvOverview( TestConstants.TEAM_ID, TestConstants.TENANT_ID);  Assertions."<AssertPlaceHolder>"; }
getAclsEnvOverview(Integer teamId, Integer tenantId) {  List<CommonUtilsService.ChartsOverviewItem<String, Integer>> aclsPerEnvList = manageDatabase.getHandleDbRequests().getAclsCountByEnv(teamId, tenantId); String title = ANALYTICS_106; if (teamId != null) { title += " (" + manageDatabase.getTeamNameFromTeamId(tenantId, teamId) + ")"; }  // tenant filtering try { List<String> allowedEnvIdList = manageDatabase.getEnvsOfTenantsMap().get(tenantId); if (aclsPerEnvList != null) { aclsPerEnvList = aclsPerEnvList.stream() .filter(mapObj -> allowedEnvIdList.contains(mapObj.getxValue())) .collect(Collectors.toList()); aclsPerEnvList = aclsPerEnvList.stream() .map(item -> item.transformX(x -> getEnvName(item.getxValue()))) .collect(Collectors.toList()); } } catch (Exception e) { log.error("No environments/clusters found.", e); aclsPerEnvList = new ArrayList<>(); }  return commonUtilsService.getChartsJsOverview( aclsPerEnvList, title, MapConstants.CLUSTER_KEY, "Clusters", "Acls", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testTryEmitTwoBucketOneFail() { TapdataEvent spyTapdataEvent = spy(tapdataEvent); when(spyTapdataEvent.clone()).thenReturn(tapdataEvent); when(mockOutBox.offer(0, tapdataEvent)).thenReturn(true); when(mockOutBox.offer(1, tapdataEvent)).thenReturn(false); boolean actual = hazelcastBaseNode.tryEmit(spyTapdataEvent, 2); "<AssertPlaceHolder>"; }
tryEmit(TapdataEvent dataEvent, int bucketCount) { if (null == dataEvent) { return true; } if (bucketCount > 1) { for (bucketIndex = Math.min(bucketIndex, bucketCount); bucketIndex < bucketCount; bucketIndex++) { TapdataEvent cloneEvent = (TapdataEvent) dataEvent.clone(); if (!tryEmit(bucketIndex, cloneEvent)) { return false; } } } else { return tryEmit(dataEvent); } return true; }
[*] target: assertFalse(actual)
[-] pred: org. junit. Assert. assertFalse ( actual )
************************************
************************************
[+] input: format_ShouldFormatValueAsString() { String valueAsString = "9223372036854775807"; Long value = Long.parseLong(valueAsString); String expected = TypeCodecs.BIGINT.format(value);  String result = codec.format(valueAsString); Assertions."<AssertPlaceHolder>"; }
format(String value) { long longValue = Long.parseLong(value); return TypeCodecs.BIGINT.format(longValue); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: isEnabled_initialized_returnsFalse() { testFeature.loadProperties(propertyHelper); "<AssertPlaceHolder>"; }
isEnabled() { if (!isLoaded) throw new RuntimeException("Feature not initialized"); return isEnabled; }
[*] target: assertFalse(testFeature.isEnabled())
[-] pred: org. junit. Assert. assertFalse ( testFeature. isEnabled() )
************************************
************************************
[+] input: shouldFetchProductsUsingPageAttributes() { Page<ProductInfo> page = new PageImpl<>(products); final int pageNumber = 1; final int pageSize = 10; final String sortAttribute = "name"; Sort.Direction sortDirection = Sort.Direction.ASC; Pageable pageable = PageRequest.of(pageNumber, pageSize, sortDirection, sortAttribute);  when(productRepository.findAllProducts( null, null, null, null, null, pageable)).thenReturn(page); when(productInfoConverter.toDto(any(ProductInfo.class))).thenReturn(mock(ProductInfoDto.class)); when(productInfoConverter.toProductPaginationDto(ArgumentMatchers.any())).thenReturn(mock(ProductListWithPaginationInfoDto.class)); when(productUpdater.update(any(ProductInfoDto.class))).thenReturn(mock(ProductInfoDto.class));  ProductListWithPaginationInfoDto productList = productsProvider.getProducts(pageable, null, null, null, null, null);  "<AssertPlaceHolder>";  verify(productRepository, times(1)).findAllProducts( null, null, null, null, null, pageable); verify(productInfoConverter, times(1)).toProductPaginationDto(ArgumentMatchers.any()); }
getProducts(final Pageable pageable, final BigDecimal minPrice, final BigDecimal maxPrice, final Integer minimumAverageRating, final List<String> brandNames, final List<String> sellerNames) { BigDecimal minimumAverageRatingValue = minimumAverageRating == null ? null : BigDecimal.valueOf(minimumAverageRating);  Page<ProductInfoDto> productsWithPageInfo = productInfoRepository .findAllProducts(minPrice, maxPrice, minimumAverageRatingValue, brandNames, sellerNames, pageable) .map(productInfoDtoConverter::toDto) .map(productUpdater::update);  return productInfoDtoConverter.toProductPaginationDto(productsWithPageInfo); }
[*] target: assertNotNull(productList)
[-] pred: org. junit. Assert. assertNotNull ( productList )
************************************
************************************
[+] input: testSkipFileNullVersion() { io.tapdata.utils.AppType appType = io.tapdata.utils.AppType.DFS; ScriptPatchScanner scriptPatchScanner = new ScriptPatchScanner(appType, allVariables);  try (MockedStatic<FileUtil> fileUtilMockedStatic = Mockito.mockStatic(FileUtil.class)) { fileUtilMockedStatic.when(() -> FileUtil.mainName(Mockito.anyString())).thenReturn(null); // set all file name is null List<IPatch> allPatch = spyPatchesRunner.scanPatches(appType, appVersion, softVersion, scriptPatchScanner); Assertions."<AssertPlaceHolder>"; } }
scanPatches(AppType appType, PatchVersion appVersion, PatchVersion softVersion, IPatchScanner... scanners) { List<IPatch> patches = new ArrayList<>();  Predicate<PatchVersion> isVersion = getVersionChecker(appType, softVersion, appVersion);  for (IPatchScanner scanner : scanners) { scanner.scanPatches(patches, isVersion); }  patches.sort(null); return patches; }
[*] target: assertTrue(allPatch.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( allPatch. isEmpty ( ) )
************************************
************************************
[+] input: InterruptedException { // GIVEN var device = new Device(new DeviceId(UUID.randomUUID())); var expectedCustomerId = new CustomerId(UUID.randomUUID()); device.setCustomerId(expectedCustomerId);  when(ctxMock.getDeviceService()).thenReturn(deviceServiceMock); doReturn(device).when(deviceServiceMock).findDeviceById(any(), any()); when(ctxMock.getDbCallbackExecutor()).thenReturn(DB_EXECUTOR);  // WHEN var actualCustomerId = EntitiesCustomerIdAsyncLoader.findEntityIdAsync(ctxMock, device.getId()).get();  // THEN "<AssertPlaceHolder>"; }
findEntityIdAsync(TbContext ctx, EntityId originator) { switch (originator.getEntityType()) { case CUSTOMER: return Futures.immediateFuture((CustomerId) originator); case USER: return toCustomerIdAsync(ctx, ctx.getUserService().findUserByIdAsync(ctx.getTenantId(), (UserId) originator)); case ASSET: return toCustomerIdAsync(ctx, ctx.getAssetService().findAssetByIdAsync(ctx.getTenantId(), (AssetId) originator)); case DEVICE: return toCustomerIdAsync(ctx, Futures.immediateFuture(ctx.getDeviceService().findDeviceById(ctx.getTenantId(), (DeviceId) originator))); default: return Futures.immediateFailedFuture(new TbNodeException("Unexpected originator EntityType: " + originator.getEntityType())); } }
[*] target: assertEquals(expectedCustomerId, actualCustomerId)
[-] pred: org. junit. Assert. assertEquals ( expectedCustomerId, actualCustomerId )
************************************
************************************
[+] input: testTaskDtoIsNull() { when(taskService.findOne(any(Query.class), any(UserDetail.class))).thenReturn(null); List<ErrorEvent> errorEventByTaskId = taskErrorEventService.getErrorEventByTaskId(new ObjectId().toHexString(), user); Assertions."<AssertPlaceHolder>"; }
getErrorEventByTaskId(String taskId, UserDetail user) { TaskDto taskDto = taskService.findOne(Query.query(Criteria.where("_id").is(MongoUtils.toObjectId(taskId))), user); if (null == taskDto) { return Lists.newArrayList(); } return Optional.ofNullable(taskDto.getErrorEvents()).orElse(Lists.newArrayList()); }
[*] target: assertNotNull(errorEventByTaskId)
[-] pred: org. junit. Assert. assertNotNull ( errorEventByTaskId )
************************************
************************************
[+] input: generic() { GenericType expected = new GenericType(T); GenericType toVerify = Type.generic(T);  "<AssertPlaceHolder>"; }
generic(TypeParameterName name) { return GenericType.of(name); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testReplaceBatch() { User user = new User(); user.setId(1L) .setName("张三") .setAge(18) .setCreateTime(LocalDateTime.now()); int replace = commonDao.replaceBatch(Collections.singletonList(user)); Assertions."<AssertPlaceHolder>"; }
replaceBatch(@Param("list") List<E> list);
[*] target: assertEquals(2, replace)
[-] pred: org. junit. Assert. assertEquals ( 2, replace )
************************************
************************************
[+] input: fipeMarcasPass() { FipeMarca[] fipeMarcas = BrasilAPI.fipeMarcas("carros"); "<AssertPlaceHolder>"; }
fipeMarcas(String tipoVeiculo) { FipeMarca[] obj = (FipeMarca[]) api(FipeMarca[].class, "fipe/marcas/v1/", tipoVeiculo); return obj != null ? (FipeMarca[]) obj.clone() : null; }
[*] target: assertNotNull(fipeMarcas)
[-] pred: org. junit. Assert. assertNotNull ( fipeMarcas )
************************************
************************************
[+] input: shouldExtractConfirmAccountLinkWhenHtmlContainsConfirmationLink() { String htmlString = "<html><body><a href='http://localhost/sign-up/verify?token=123'>Confirm Account</a></body></html>"; String expectedLink = "http://localhost/sign-up/verify?token=123"; String actualLink = SignUpUtils.extractConfirmAccountLink(htmlString);  "<AssertPlaceHolder>"; }
extractConfirmAccountLink(String htmlString) { ValidationUtils.validateInputs(htmlString);  // Parse the HTML string using Jsoup Document document = Jsoup.parse(htmlString);  // Select the confirm button link using CSS selector Element confirmButton = document.select("a[href^='http://localhost/sign-up/verify?token=']").first();  if (Objects.nonNull(confirmButton)) { // Retrieve the href attribute from the confirm button link return confirmButton.attr("href"); } else { // Handle the case where the confirm button link is not found return null; } }
[*] target: assertEquals(expectedLink, actualLink)
[-] pred: org. junit. Assert. assertEquals ( expectedLink, actualLink )
************************************
************************************
[+] input: decode_ShouldDecodeTextByteBufferAndReturnAsNumber() { String valueAsString = "9223372036854775807"; Long value = Long.valueOf(valueAsString); ByteBuffer byteBuffer = TypeCodecs.TEXT.encode(valueAsString, CqlConversion.PROTOCOL_VERSION);  Long result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { String stringValue = TypeCodecs.TEXT.decode(bytes, protocolVersion); return Long.parseLong(stringValue); }
[*] target: assertEquals(value, result)
[-] pred: org. junit. Assert. assertEquals ( value, result )
************************************
************************************
[+] input: shouldParseDate() { try (MockedStatic<Environment> mockedEnvironment = mockStatic(Environment.class)) { mockedEnvironment.when(Environment::getCurrent).thenReturn(env); when(env.getWebforjHelper()).thenReturn(bridge);  String input = "12"; String mask = "%Dz-%Mz-%Yz"; Locale locale = Locale.US; LocalDate expected = LocalDate.of(2023, 6, 12); int julian = new JulianLocaleDateTransformer().transformToComponent(expected);  when(bridge.parseDate(input, mask, locale)).thenReturn(julian);  LocalDate result = MaskDecorator.parseDate(input, mask, locale);  "<AssertPlaceHolder>"; } }
parseDate(String input, String mask, Locale locale) { Objects.requireNonNull(input, INPUT_CANNOT_BE_NULL); Objects.requireNonNull(mask, MASK_CANNOT_BE_NULL);  Environment env = Environment.getCurrent(); int julian = env.getWebforjHelper().parseDate(input, mask, locale == null ? App.getLocale() : locale); JulianLocaleDateTransformer transformer = new JulianLocaleDateTransformer();  return transformer.transformToModel(julian); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testDetailBuilder() { //  detail : { //      "type": "HorizontalLayout", //      "elements": [ //          { //              "type": "Control", //              "scope": "#/properties/name" //          }, //          { //              "type": "Control", //              "scope": "#/properties/documentation", //              "label": "Documentation", //              "options": { //                  "multi": true //              } //          } //      ] //    }  JsonObjectBuilder layoutBuilder = Json.createObjectBuilder().add("type", "HorizontalLayout");  JsonArrayBuilder controlsArrayBuilder = Json.createArrayBuilder();  JsonObjectBuilder controlBuilder = Json.createObjectBuilder(). // add("type", "Control"). // add("scope", "#/properties/");  controlsArrayBuilder.add(controlBuilder);  layoutBuilder.add("elements", controlsArrayBuilder);  JsonObjectBuilder detailBuilder = Json.createObjectBuilder(). // add("detail", layoutBuilder.build());  JsonObject jsonObject = detailBuilder.build();  "<AssertPlaceHolder>"; logger.info("" + jsonObject);  }
build() {  // close current controllsBuilder.... if (controlsArrayBuilder != null && layoutContext != null) { layoutContext.add("elements", controlsArrayBuilder.build()); }  if (groupArrayBuilder != null) {  // close current layoutContext.... if (layoutsArrayBuilder != null && layoutContext != null) { this.layoutsArrayBuilder.add(layoutContext.build()); }  // close current gourpContext if (groupContext != null) { groupContext.add("elements", layoutsArrayBuilder.build()); groupArrayBuilder.add(groupContext); }  rootLayoutBuilder.add("elements", groupArrayBuilder.build()); }  // write result JsonObject jsonObject = rootLayoutBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(jsonObject)
[-] pred: org. junit. Assert. assertNotNull ( jsonObject )
************************************
************************************
[+] input: testDeserializeWithBytes() {  CollectRep.MetricsData expectedMetricsData = CollectRep.MetricsData.newBuilder() .setMetrics("someValue") .setApp("linux") .build(); byte[] bytes = expectedMetricsData.toByteArray();  CollectRep.MetricsData actualMetricsData = deserializer.deserialize("", bytes);  "<AssertPlaceHolder>"; }
deserialize(String s, byte[] bytes){ try { return CollectRep.MetricsData.parseFrom(bytes); } catch (InvalidProtocolBufferException e) { throw new RuntimeException(e); } }
[*] target: assertEquals(expectedMetricsData, actualMetricsData)
[-] pred: org. junit. Assert. assertEquals ( expectedMetricsData, actualMetricsData )
************************************
************************************
[+] input: contravariantConcreteTypeConstructorCanAcceptGivenEquivalentInvariantConcreteTypeConstructor() { ConcreteTypeConstructor target = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.contravariant()); ConcreteTypeConstructor source = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.invariant());  "<AssertPlaceHolder>"; }
canAccept(TypeConstructor typeConstructor) { if (typeConstructor instanceof ConcreteTypeConstructor) { ConcreteTypeConstructor that = (ConcreteTypeConstructor) typeConstructor;  return this.fullyQualifiedNameEqualToThatOf(that) && this.typeArgumentsCanAccept(that); } else { return false; } }
[*] target: assertTrue(target.canAccept(source))
[-] pred: org. junit. Assert. assertTrue ( target. canAccept ( source ) )
************************************
************************************
[+] input: bind_withWritetime() { when(writetimeTTLFeature.isEnabled()).thenReturn(true); when(writetimeTTLFeature.hasWritetimeColumns()).thenReturn(true); targetInsertStatement = new TargetInsertStatement(propertyHelper, targetSession);  BoundStatement result = targetInsertStatement.bind(originRow, targetRow, null,10000L,null,null); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size()+1)).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { if (null == originRow) throw new RuntimeException("Origin row is null"); if (usingCounter) throw new RuntimeException("Cannot INSERT onto a counter table, use UPDATE instead");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue); BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; Object bindValue = null;  if (logDebug) logger.debug("bind using conversions: {}",cqlTable.getOtherCqlTable().getConversions()); for (int targetIndex = 0; targetIndex < targetColumnTypes.size(); targetIndex++) { if (!bindColumnIndexes.contains(targetIndex)) { // this happens with constant columns, for example continue; } try { if (targetIndex== explodeMapKeyIndex) { bindValue = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValue = explodeMapValue; } else { int originIndex = cqlTable.getCorrespondingIndex(targetIndex); if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValue = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValue, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValue + " of class:" +(null==bindValue?"unknown":bindValue.getClass().getName())+ " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex)+ "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex + " and bind index: "+ (currentBindIndex-1) + " of statement:" + this.getCQL()); throw e; } }  if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testReturnSubstringWithCodon8() { String expectedResult = this.expectedCodon8; String actualSubstringResult = returnSubstring(this.testInput, this.testCodon8); "<AssertPlaceHolder>"; }
returnSubstring(String dnaString, int index) { return dnaString.substring(index, index + 3).toUpperCase(); }
[*] target: assertEquals(expectedResult, actualSubstringResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualSubstringResult )
************************************
************************************
[+] input: getAll() { final List<Product> products = productService.getAll(); "<AssertPlaceHolder>"; }
getAll() { return productRepository.findAll(); }
[*] target: assertFalse(products.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( products. isEmpty ( ) )
************************************
************************************
[+] input: test_isCloudLimitScheduling() { ObjectId taskId = MongoUtils.toObjectId("632454d5287a904778c40f8d"); Query query = new Query(Criteria.where("_id").is(taskId)); query.fields().include("id","agentId","agentTags"); TaskEntity mockTask = new TaskEntity(); mockTask.setCrontabExpressionFlag(true); mockTask.setId(MongoUtils.toObjectId("632454d5287a904778c40f8d")); try (MockedStatic<DataPermissionService> serviceMockedStatic = Mockito.mockStatic(DataPermissionService.class)) { serviceMockedStatic.when(DataPermissionService::isCloud).thenReturn(true); when(settingsService.isCloud()).thenReturn(true); when(taskRepository.findOne(query)).thenReturn(Optional.of(mockTask)); TaskDto mockTaskDto = new TaskDto(); BeanUtils.copyProperties(mockTask,mockTaskDto); CalculationEngineVo mockEngineVo = new CalculationEngineVo(); mockEngineVo.setTaskLimit(5); mockEngineVo.setRunningNum(5); when(workerService.calculationEngine(mockTaskDto,user,null)).thenReturn(mockEngineVo); Query mockQuery = new Query(Criteria.where("_id").is(taskId)); mockQuery.fields().include("planStartDateFlag", "crontabExpressionFlag"); when(taskRepository.findOne(mockQuery)).thenReturn(Optional.of(mockTask)); boolean result = taskService.checkCloudTaskLimit(taskId,user,true); "<AssertPlaceHolder>"; } }
checkCloudTaskLimit(ObjectId taskId,UserDetail user,boolean checkCurrentTask){ if (settingsService.isCloud()) { TaskDto task = findByTaskId(taskId,"id",AGENT_ID,"agentTags"); CalculationEngineVo calculationEngineVo = workerService.calculationEngine(task, user, null); int runningNum; if(checkCurrentTask){ runningNum  = subCronOrPlanNum(task, calculationEngineVo.getRunningNum()); }else{ runningNum = calculationEngineVo.getRunningNum(); } if (runningNum >= calculationEngineVo.getTaskLimit()) { return false; } } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testDeterminePage01() { DynaValidatorForm validatorForm = new DynaValidatorForm(); ActionMapping mapping = new ActionMapping();  mapping.setAcceptPage(null); validatorForm.setPage(-1); int page = validatorForm.determinePage(mapping, null);  "<AssertPlaceHolder>"; }
determinePage(ActionMapping mapping, HttpServletRequest request) { Integer acceptPage = mapping.getAcceptPage(); return acceptPage != null ? Math.max(acceptPage.intValue(), getPage()) : Integer.MAX_VALUE; }
[*] target: assertEquals(Integer.MAX_VALUE, page)
[-] pred: org. junit. Assert. assertEquals ( Integer. MAX_VALUE, page )
************************************
************************************
[+] input: validateGivenNonStaticInnerClassAsContainingClass() { ContainingClass toValidate = PackageName.of("nl.wernerdegroot.applicatives") .asPackage() .containingClass(modifiers(), ClassName.of("Outer"), A, B) .containingClass(modifiers(), ClassName.of("Inner"), C, D);  Validated<String, ClassValidator.Result> expected = Validated.invalid("Only outer classes and static inner classes are currently supported"); Validated<String, ClassValidator.Result> toVerify = ClassValidator.validate(toValidate);  "<AssertPlaceHolder>"; }
validate(ContainingClass containingClass) {  // We check whether we're dealing with an outer class or a static inner class. // Why is this required? Consider the following scenario: // //   class Outer<A extends B, B> { //     class Inner<B> { //       ... //     } //   } // // It is impossible to collapse these three type parameters of these two classes into a // single list of type parameters without carefully renaming some of them to avoid shadowing. // Instead of going through all that effort for this extreme edge-case, I'm just going avoid // it completely. If we'd like to be more sophisticated we could try: // //  * To support only a single class with type parameters in the hierarchy //  * Only support multiple classes with type parameters if their names don't conflict //  * Only support conflicts if the type parameter that is shadowed can be removed //    completely (isn't used as upper bound for any of the other type parameters) if (!containingClass.isOuterClass() && !containingClass.isStaticInnerClass()) { return Validated.invalid("Only outer classes and static inner classes are currently supported"); } List<TypeParameter> typeParameters = containingClass.getTypeParameters();  return Validated.valid(Result.of(typeParameters)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testAddLoggingHandler() { Logger rootLogger = Logger.getLogger(""); loggingService.addLoggingHandler(); boolean handlerFound = false; for (Handler handler : rootLogger.getHandlers()) { if (handler instanceof HmcStreamHandler) { handlerFound = true; break; } } "<AssertPlaceHolder>"; }
addLoggingHandler() { Logger.getLogger("").addHandler(new HmcStreamHandler(streamFactory.get(), formatterFactory.get())); }
[*] target: assertTrue(handlerFound)
[-] pred: org. junit. Assert. assertTrue ( handlerFound )
************************************
************************************
[+] input: shouldMaskDate() { try (MockedStatic<Environment> mockedEnvironment = mockStatic(Environment.class)) { mockedEnvironment.when(Environment::getCurrent).thenReturn(env); when(env.getWebforjHelper()).thenReturn(bridge);  LocalDate input = LocalDate.now(); String mask = "%Dz-%Mz-%Yl"; String expected = "12-06-2023";  int julian = new JulianLocaleDateTransformer().transformToComponent(input); when(bridge.maskDateTime(julian, null, mask)).thenReturn(expected);  String result = MaskDecorator.forDate(input, mask);  "<AssertPlaceHolder>"; } }
forDate(LocalDate input, String mask) { Objects.requireNonNull(input, INPUT_CANNOT_BE_NULL); Objects.requireNonNull(mask, MASK_CANNOT_BE_NULL);  Environment env = Environment.getCurrent(); JulianLocaleDateTransformer transformer = new JulianLocaleDateTransformer(); int julian = transformer.transformToComponent(input);  return env.getWebforjHelper().maskDateTime(julian, null, mask); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testQueryStatusPageOrg() {  StatusPageOrg expectedOrg = new StatusPageOrg(); when(statusPageOrgDao.findAll()).thenReturn(List.of(expectedOrg));  StatusPageOrg actualOrg = statusPageService.queryStatusPageOrg();  "<AssertPlaceHolder>"; }
queryStatusPageOrg();
[*] target: assertEquals(expectedOrg, actualOrg)
[-] pred: org. junit. Assert. assertEquals ( expectedOrg, actualOrg )
************************************
************************************
[+] input: BBjException { component.setLabelsVisible(true); "<AssertPlaceHolder>";  verify(control).setPaintLabels(true); }
isLabelsVisible() { return labelsVisible; }
[*] target: assertTrue(component.isLabelsVisible())
[-] pred: org. junit. Assert. assertTrue ( component. isLabelsVisible() )
************************************
************************************
[+] input: covariantConcreteTypeConstructorCanAcceptGivenEquivalentInvariantConcreteTypeConstructor() { ConcreteTypeConstructor target = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.covariant()); ConcreteTypeConstructor source = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.invariant());  "<AssertPlaceHolder>"; }
canAccept(TypeConstructor typeConstructor) { if (typeConstructor instanceof ConcreteTypeConstructor) { ConcreteTypeConstructor that = (ConcreteTypeConstructor) typeConstructor;  return this.fullyQualifiedNameEqualToThatOf(that) && this.typeArgumentsCanAccept(that); } else { return false; } }
[*] target: assertTrue(target.canAccept(source))
[-] pred: org. junit. Assert. assertTrue ( target. canAccept ( source ) )
************************************
************************************
[+] input: givenParameters() { String toVerify = toTest() .withParameter(STRING, "s") .withParameters(Parameter.of(BIG_DECIMAL, "bd"), Parameter.of(INTEGER, "i")) .withParameterTypes(OPTIONAL.with(T), OPTIONAL.with(U)) .andParameterNames("t", "u") .getParametersGenerator() .generate();  String expected = "(java.lang.String s, java.math.BigDecimal bd, java.lang.Integer i, java.util.Optional<T> t, java.util.Optional<U> u)";  "<AssertPlaceHolder>"; }
generate() { return parameters .stream() .map(ParameterGenerator::generateFrom) .collect(joining(SEPARATOR, OPEN_PARENTHESIS, CLOSE_PARENTHESIS)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: givenTypeParameter() { String toVerify = toTest() .withType(T.extending(COMPARABLE.with(T))) .getObjectPathOrTypeGenerator() .generate();  String expected = "T";  "<AssertPlaceHolder>"; }
generate() { Optional<String> optionalObjectPathAsString = optionalObjectPathGenerator.map(ObjectPathGenerator::generate); Optional<String> optionalConcreteTypeAsString = optionalConcreteType.map(FullyQualifiedName::raw); Optional<String> optionalGenericTypeAsString = optionalGenericType.map(TypeParameterName::raw); return optionalObjectPathAsString .map(Optional::of).orElse(optionalConcreteTypeAsString) .map(Optional::of).orElse(optionalGenericTypeAsString) .orElseThrow(NullPointerException::new); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testCreateServiceConfig() { // Setup final ServiceConfig expectedResult = new ServiceConfig(); expectedResult.setName("configName"); expectedResult.setValue("configValue"); expectedResult.setLabel("label"); expectedResult.setDescription("description"); expectedResult.setRequired(false); expectedResult.setType("input"); expectedResult.setConfigurableInWizard(false); expectedResult.setDefaultValue("defaultValue"); expectedResult.setMinValue(0); expectedResult.setMaxValue(0); expectedResult.setUnit("unit"); expectedResult.setHidden(false); expectedResult.setSelectValue(Arrays.asList("value")); expectedResult.setConfigType("configType");  // Run the test final ServiceConfig result = ProcessUtils.createServiceConfig("configName", "configValue", "type");  // Verify the results "<AssertPlaceHolder>"; }
createServiceConfig(String configName, Object configValue, String type) { ServiceConfig serviceConfig = new ServiceConfig(); serviceConfig.setName(configName); serviceConfig.setLabel(configName); serviceConfig.setValue(configValue); serviceConfig.setRequired(true); serviceConfig.setHidden(false); serviceConfig.setType(type); return serviceConfig; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: givenObjectPath() { String toVerify = toTest() .withObjectPath("this", "value") .withObjectPath("selection") .withObjectPath("current") .getObjectPathGenerator() .generate();  String expected = "this.value.selection.current";  "<AssertPlaceHolder>"; }
generate() { return String.join(PERIOD, components); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: getMonitorDto() { long id = 1L; Monitor monitor = Monitor.builder().jobId(id).intervals(1).app("app").name("memory").host("host").id(id).build(); when(monitorDao.findById(id)).thenReturn(Optional.of(monitor)); List<Param> params = Collections.singletonList(new Param()); when(paramDao.findParamsByMonitorId(id)).thenReturn(params); Job job = new Job(); job.setMetrics(new ArrayList<>()); when(appService.getAppDefine(monitor.getApp())).thenReturn(job); when(collectorMonitorBindDao.findCollectorMonitorBindByMonitorId(monitor.getId())).thenReturn(Optional.empty()); MonitorDto monitorDto = monitorService.getMonitorDto(id); "<AssertPlaceHolder>"; }
getMonitorDto(long id) throws RuntimeException;
[*] target: assertNotNull(monitorDto)
[-] pred: org. junit. Assert. assertNotNull ( monitorDto )
************************************
************************************
[+] input: concreteGivenFullyQualifiedNameAndListOfTypeArguments() { ConcreteTypeConstructor expected = new ConcreteTypeConstructor(ERUDITE, asList(STRING_TYPE_CONSTRUCTOR.invariant(), TypeConstructor.placeholder().covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant())); ConcreteTypeConstructor toVerify = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.invariant(), TypeConstructor.placeholder().covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant());  "<AssertPlaceHolder>"; }
contravariant() { return TypeConstructorArgument.of(CONTRAVARIANT, this); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testSetRoundRobinHostWeightPairsProperty() { final String expectedPropertyValue = "instance-1:2,instance-2:1,instance-3:0";  final List<HostSpec> hosts = Arrays.asList( new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-1") .weight(2) .build(), new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-2") .weight(1) .build(), new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-3") .weight(0) .build() ); final Properties properties = new Properties(); RoundRobinHostSelector.setRoundRobinHostWeightPairsProperty(properties, hosts);  final String actualPropertyValue = properties.getProperty( RoundRobinHostSelector.ROUND_ROBIN_HOST_WEIGHT_PAIRS.name);  "<AssertPlaceHolder>"; }
setRoundRobinHostWeightPairsProperty(final @NonNull Properties properties, final @NonNull List<HostSpec> hosts) { final StringBuilder builder = new StringBuilder(); for (int i = 0; i < hosts.size(); i++) { builder .append(hosts.get(i).getHost()) .append(":") .append(hosts.get(i).getWeight()); if (i < hosts.size() - 1) { builder.append(","); } } final String roundRobinHostWeightPairsString = builder.toString(); properties.setProperty(ROUND_ROBIN_HOST_WEIGHT_PAIRS.name, roundRobinHostWeightPairsString); }
[*] target: assertEquals(expectedPropertyValue, actualPropertyValue)
[-] pred: org. junit. Assert. assertEquals ( expectedPropertyValue, actualPropertyValue )
************************************
************************************
[+] input: parse_ShouldParseTextAndReturnAsNumber() { String valueAsString = "9223372036854775807"; Long expected = TypeCodecs.BIGINT.parse(valueAsString); Long result = codec.parse(valueAsString); Assertions."<AssertPlaceHolder>"; }
parse(String value) { return value == null ? null : Long.parseLong(value); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: concreteGivenFullyQualifiedName() { ConcreteType expected = new ConcreteType(ERUDITE, emptyList()); ConcreteType toVerify = Type.concrete(ERUDITE);  "<AssertPlaceHolder>"; }
concrete(FullyQualifiedName name) { return ConcreteType.of(name, emptyList()); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: dummyDatasetForDebug() { final IPVDataset dataset = new IPVDataset(Arrays.asList( List.of("A"), List.of("A"), List.of("A"), List.of("B"), List.of("B"), List.of("B") ), null, false);  Double report = new SensitiveSimilarityMeasure().initialize(dataset, null, null, Collections.singletonList(new Partition() { @Override public int size() { return dataset.getNumberOfRows(); }  @Override public double getNormalizedWidth(int qidColumn) { return 0; }  @Override public IPVDataset getMember() { return dataset; }  @Override public boolean isAnonymous() { return false; }  @Override public void setAnonymous(boolean value) {  } }), Collections.singletonList(new SensitiveColumnInformation()), null).report();  "<AssertPlaceHolder>"; System.out.println(report); }
report() { return computeMSE(); }
[*] target: assertNotNull(report)
[-] pred: org. junit. Assert. assertNotNull ( report )
************************************
************************************
[+] input: 카트라인_결제금액_없을때_결제필요_여부_조회() { // given given(cartOptionAnswer.getAdditionalPrice()).willReturn(Money.ZERO); // when Boolean needPaid = freeCartLineItem.isNeedPaid(); // then "<AssertPlaceHolder>"; }
isNeedPaid() { // 0 < totalCartLinePrice return Money.ZERO.isLessThan(getTotalCartLinePrice()); }
[*] target: assertFalse(needPaid)
[-] pred: org. junit. Assert. assertFalse ( needPaid )
************************************
************************************
[+] input: testFindRunningTasksByAgentIdWithId() { TaskRepository repository = mock(TaskRepository.class); taskService = spy(new TaskServiceImpl(repository)); String processId = "111"; Query query = Query.query(Criteria.where("agentId").is(processId).and("status").is("running")); when(taskService.findAll(query)).thenReturn(new ArrayList<>()); int actual = taskService.findRunningTasksByAgentId(processId); "<AssertPlaceHolder>"; }
findRunningTasksByAgentId(String processId){ if (StringUtils.isBlank(processId.trim())) throw new IllegalArgumentException("process id can not be empty"); Query query = Query.query(Criteria.where(AGENT_ID).is(processId).and(STATUS).is("running")); List<TaskDto> runningTasks = findAll(query); return runningTasks.size(); }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: testSaveStatusPageOrg() {  StatusPageOrg inputOrg = new StatusPageOrg(); when(statusPageOrgDao.save(inputOrg)).thenReturn(inputOrg);  StatusPageOrg savedOrg = statusPageService.saveStatusPageOrg(inputOrg);  "<AssertPlaceHolder>"; }
saveStatusPageOrg(StatusPageOrg statusPageOrg);
[*] target: assertEquals(inputOrg, savedOrg)
[-] pred: org. junit. Assert. assertEquals ( inputOrg, savedOrg )
************************************
************************************
[+] input: test_Object_lookup_PageContext_String_String_String3() { pageContext.setAttribute("bean", new MockFormBean());  Object val = null;  try { val = tagutils.lookup(pageContext, "bean", "doesNotExistMethod"); fail("should have thrown exception"); } catch (JspException e) { "<AssertPlaceHolder>"; } }
lookup(PageContext pageContext, String name, String scopeName) throws JspException { if (scopeName == null) { return pageContext.findAttribute(name); }  try { return pageContext.getAttribute(name, instance.getScope(scopeName)); } catch (JspException e) { saveException(pageContext, e); throw e; } }
[*] target: assertNull(val)
[-] pred: org. junit. Assert. assertNull ( val )
************************************
************************************
[+] input: test_getLastCheckAvailableAgentCount() { try(MockedStatic<SettingUtil> mockedStatic = mockStatic(SettingUtil.class)){ mockedStatic.when(()->SettingUtil.getValue(anyString(),anyString())).thenReturn("300"); Long except = 100L; when(workerRepository.count(any(Query.class))).thenReturn(except); Long result = workerService.getLastCheckAvailableAgentCount(); "<AssertPlaceHolder>"; } }
getLastCheckAvailableAgentCount();
[*] target: assertEquals(except,result)
[-] pred: org. junit. Assert. assertEquals ( except, result )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismTwoNodeButAllNodeNotDataParentNode() { when(nodeList.size()).thenReturn(2); JsProcessorNode node1 = mock(JsProcessorNode.class); when(nodeList.get(0)).thenReturn(node1);  JsProcessorNode node2 = mock(JsProcessorNode.class); when(nodeList.get(1)).thenReturn(node2); boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(1)).get(0); verify(nodeList, times(0)).get(1); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: testNullEvent() { List<String> removeFields = TapEventUtil.getRemoveFields(null); "<AssertPlaceHolder>"; }
getRemoveFields(TapEvent tapEvent) { List<String> removeFields=null; if(tapEvent instanceof  TapUpdateRecordEvent){ removeFields=((TapUpdateRecordEvent)tapEvent).getRemovedFields(); return removeFields; } return null; }
[*] target: assertNull(removeFields)
[-] pred: org. junit. Assert. assertNull ( removeFields )
************************************
************************************
[+] input: testFilterConverge_RestoredAlert() {  testAlert.setStatus(CommonConstants.ALERT_STATUS_CODE_RESTORED); boolean result = alarmConvergeReduce.filterConverge(testAlert);  "<AssertPlaceHolder>"; }
filterConverge(Alert currentAlert) { // ignore monitor status auto recover notice if ((currentAlert.getTags() != null && currentAlert.getTags().containsKey(CommonConstants.IGNORE)) || currentAlert.getStatus() == CommonConstants.ALERT_STATUS_CODE_RESTORED) { // restored alert boolean isHasIgnore = false; Map<String, String> tags = currentAlert.getTags(); if (Objects.requireNonNull(tags).containsKey(CommonConstants.IGNORE)) { isHasIgnore = true; tags.remove(CommonConstants.IGNORE); } int alertHash = Objects.hash(CommonConstants.ALERT_PRIORITY_CODE_CRITICAL) + Arrays.hashCode(tags.keySet().toArray(new String[0])) + Arrays.hashCode(tags.values().toArray(new String[0])); converageAlertMap.remove(alertHash); alertHash = Objects.hash(CommonConstants.ALERT_PRIORITY_CODE_EMERGENCY) + Arrays.hashCode(tags.keySet().toArray(new String[0])) + Arrays.hashCode(tags.values().toArray(new String[0])); converageAlertMap.remove(alertHash); alertHash = Objects.hash(CommonConstants.ALERT_PRIORITY_CODE_WARNING) + Arrays.hashCode(tags.keySet().toArray(new String[0])) + Arrays.hashCode(tags.values().toArray(new String[0])); converageAlertMap.remove(alertHash); if (isHasIgnore) { tags.put(CommonConstants.IGNORE, CommonConstants.IGNORE); } return true; }  CommonCacheService<String, Object> convergeCache = CacheFactory.getAlertConvergeCache(); List<AlertConverge> alertConvergeList = (List<AlertConverge>) convergeCache.get(CommonConstants.CACHE_ALERT_CONVERGE); if (alertConvergeList == null) { alertConvergeList = alertConvergeDao.findAll(); // matchAll is in the last alertConvergeList.sort((item1, item2) -> { if (item1.isMatchAll()) { return 1; } else if (item2.isMatchAll()) { return -1; } else { return 0; } }); convergeCache.put(CommonConstants.CACHE_ALERT_CONVERGE, alertConvergeList); } for (AlertConverge alertConverge : alertConvergeList) { if (!alertConverge.isEnable()) { continue; } boolean match = alertConverge.isMatchAll(); if (!match) { List<TagItem> tags = alertConverge.getTags(); if (currentAlert.getTags() != null && !currentAlert.getTags().isEmpty()) { Map<String, String> alertTagMap = currentAlert.getTags(); match = tags.stream().anyMatch(item -> { if (alertTagMap.containsKey(item.getName())) { String tagValue = alertTagMap.get(item.getName()); if (tagValue == null && item.getValue() == null) { return true; } else { return tagValue != null && tagValue.equals(item.getValue()); } } else { return false; } }); } else { match = true; } if (match && alertConverge.getPriorities() != null && !alertConverge.getPriorities().isEmpty()) { match = alertConverge.getPriorities().stream().anyMatch(item -> item != null && item == currentAlert.getPriority()); } } if (match) { long evalInterval = alertConverge.getEvalInterval() * 1000L; long now = System.currentTimeMillis(); if (evalInterval <= 0) { return true; } int alertHash = Objects.hash(currentAlert.getPriority()) + Arrays.hashCode(currentAlert.getTags().keySet().toArray(new String[0])) + Arrays.hashCode(currentAlert.getTags().values().toArray(new String[0])); Alert preAlert = converageAlertMap.get(alertHash); if (preAlert == null) { currentAlert.setTimes(1); currentAlert.setFirstAlarmTime(now); currentAlert.setLastAlarmTime(now); converageAlertMap.put(alertHash, currentAlert.clone()); return true; } else { if (now - preAlert.getFirstAlarmTime() < evalInterval) { preAlert.setTimes(preAlert.getTimes() + 1); preAlert.setLastAlarmTime(now); return false; } else { currentAlert.setTimes(preAlert.getTimes()); if (preAlert.getTimes() == 1) { currentAlert.setFirstAlarmTime(now); } else { currentAlert.setFirstAlarmTime(preAlert.getFirstAlarmTime()); } currentAlert.setLastAlarmTime(now); preAlert.setFirstAlarmTime(now); preAlert.setLastAlarmTime(now); preAlert.setTimes(1); return true; } } } } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: cloneSchemaTest2() { List<Schema> schemaList = migrateProcessorNode.cloneSchema(null); "<AssertPlaceHolder>"; }
cloneSchema(List<Schema> schemas) { if (schemas == null) { return Collections.emptyList(); } return SchemaUtils.cloneSchema(schemas); }
[*] target: assertEquals(0,schemaList.size())
[-] pred: org. junit. Assert. assertEquals ( 0, schemaList. size ( ) )
************************************
************************************
[+] input: testFilterConvergeNoConverge() {  when(convergeCache.get(CommonConstants.CACHE_ALERT_CONVERGE)).thenReturn(null); when(alertConvergeDao.findAll()).thenReturn(Collections.emptyList());  boolean result = alarmConvergeReduce.filterConverge(testAlert);  "<AssertPlaceHolder>"; verify(convergeCache).get(CommonConstants.CACHE_ALERT_CONVERGE); verify(alertConvergeDao).findAll(); verify(convergeCache).put(CommonConstants.CACHE_ALERT_CONVERGE, Collections.emptyList()); }
filterConverge(Alert currentAlert) { // ignore monitor status auto recover notice if ((currentAlert.getTags() != null && currentAlert.getTags().containsKey(CommonConstants.IGNORE)) || currentAlert.getStatus() == CommonConstants.ALERT_STATUS_CODE_RESTORED) { // restored alert boolean isHasIgnore = false; Map<String, String> tags = currentAlert.getTags(); if (Objects.requireNonNull(tags).containsKey(CommonConstants.IGNORE)) { isHasIgnore = true; tags.remove(CommonConstants.IGNORE); } int alertHash = Objects.hash(CommonConstants.ALERT_PRIORITY_CODE_CRITICAL) + Arrays.hashCode(tags.keySet().toArray(new String[0])) + Arrays.hashCode(tags.values().toArray(new String[0])); converageAlertMap.remove(alertHash); alertHash = Objects.hash(CommonConstants.ALERT_PRIORITY_CODE_EMERGENCY) + Arrays.hashCode(tags.keySet().toArray(new String[0])) + Arrays.hashCode(tags.values().toArray(new String[0])); converageAlertMap.remove(alertHash); alertHash = Objects.hash(CommonConstants.ALERT_PRIORITY_CODE_WARNING) + Arrays.hashCode(tags.keySet().toArray(new String[0])) + Arrays.hashCode(tags.values().toArray(new String[0])); converageAlertMap.remove(alertHash); if (isHasIgnore) { tags.put(CommonConstants.IGNORE, CommonConstants.IGNORE); } return true; }  CommonCacheService<String, Object> convergeCache = CacheFactory.getAlertConvergeCache(); List<AlertConverge> alertConvergeList = (List<AlertConverge>) convergeCache.get(CommonConstants.CACHE_ALERT_CONVERGE); if (alertConvergeList == null) { alertConvergeList = alertConvergeDao.findAll(); // matchAll is in the last alertConvergeList.sort((item1, item2) -> { if (item1.isMatchAll()) { return 1; } else if (item2.isMatchAll()) { return -1; } else { return 0; } }); convergeCache.put(CommonConstants.CACHE_ALERT_CONVERGE, alertConvergeList); } for (AlertConverge alertConverge : alertConvergeList) { if (!alertConverge.isEnable()) { continue; } boolean match = alertConverge.isMatchAll(); if (!match) { List<TagItem> tags = alertConverge.getTags(); if (currentAlert.getTags() != null && !currentAlert.getTags().isEmpty()) { Map<String, String> alertTagMap = currentAlert.getTags(); match = tags.stream().anyMatch(item -> { if (alertTagMap.containsKey(item.getName())) { String tagValue = alertTagMap.get(item.getName()); if (tagValue == null && item.getValue() == null) { return true; } else { return tagValue != null && tagValue.equals(item.getValue()); } } else { return false; } }); } else { match = true; } if (match && alertConverge.getPriorities() != null && !alertConverge.getPriorities().isEmpty()) { match = alertConverge.getPriorities().stream().anyMatch(item -> item != null && item == currentAlert.getPriority()); } } if (match) { long evalInterval = alertConverge.getEvalInterval() * 1000L; long now = System.currentTimeMillis(); if (evalInterval <= 0) { return true; } int alertHash = Objects.hash(currentAlert.getPriority()) + Arrays.hashCode(currentAlert.getTags().keySet().toArray(new String[0])) + Arrays.hashCode(currentAlert.getTags().values().toArray(new String[0])); Alert preAlert = converageAlertMap.get(alertHash); if (preAlert == null) { currentAlert.setTimes(1); currentAlert.setFirstAlarmTime(now); currentAlert.setLastAlarmTime(now); converageAlertMap.put(alertHash, currentAlert.clone()); return true; } else { if (now - preAlert.getFirstAlarmTime() < evalInterval) { preAlert.setTimes(preAlert.getTimes() + 1); preAlert.setLastAlarmTime(now); return false; } else { currentAlert.setTimes(preAlert.getTimes()); if (preAlert.getTimes() == 1) { currentAlert.setFirstAlarmTime(now); } else { currentAlert.setFirstAlarmTime(preAlert.getFirstAlarmTime()); } currentAlert.setLastAlarmTime(now); preAlert.setFirstAlarmTime(now); preAlert.setLastAlarmTime(now); preAlert.setTimes(1); return true; } } } } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testSetValue() { ValueHolder valueHolder = new ValueHolder(); String newValue = "new value"; valueHolder.setValue(newValue); // Assert that the value is equal to the new value "<AssertPlaceHolder>"; }
getValue() { return value; }
[*] target: assertEquals(newValue, valueHolder.getValue())
[-] pred: org. junit. Assert. assertEquals ( newValue, valueHolder. getValue() )
************************************
************************************
[+] input: replaceAllTypeParameterNamesGivenMappingThatDoesNotContainElementTypeConstructor() { Map<TypeParameterName, TypeParameterName> mapping = new HashMap<>(); mapping.put(T, A); mapping.put(U, B);  ConcreteTypeConstructor expected = new ConcreteTypeConstructor( ERUDITE, asList( STRING_TYPE_CONSTRUCTOR.invariant(), TypeConstructor.generic(V).covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant() ) );  ConcreteTypeConstructor toVerify = new ConcreteTypeConstructor( ERUDITE, asList( STRING_TYPE_CONSTRUCTOR.invariant(), TypeConstructor.generic(V).covariant(), INTEGER_TYPE_CONSTRUCTOR.contravariant() ) ).replaceTypeParameterNames(mapping);  "<AssertPlaceHolder>"; }
replaceTypeParameterNames(Map<TypeParameterName, TypeParameterName> replacement) { List<TypeConstructorArgument> replacedTypeConstructorArguments = typeConstructorArguments .stream() .map(typeConstructorArgument -> typeConstructorArgument.replaceAllTypeParameterNames(replacement)) .collect(toList());  return TypeConstructor.concrete(fullyQualifiedName, replacedTypeConstructorArguments); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: IOException { BilibiliResponse<FlowItems<DynamicItem>> response = client.dynamicFeedAll("", 1, "video"); Assertions."<AssertPlaceHolder>"; // 需要Cookie }
dynamicFeedAll(String offset, int page, String type) throws IOException { checkBuVid3BuVid4(); String url = ApiUtil.fillUrl(ApiUrlContainer.DYNAMIC_FEED_ALL, offset, page, type); return httpJsonClient.getJson(url, new TypeReference<BilibiliResponse<FlowItems<DynamicItem>>>() { }, requestHeader); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testSaveServiceConfig() { // Setup final ServiceConfig serviceConfig = new ServiceConfig(); serviceConfig.setName("name"); serviceConfig.setValue("value"); serviceConfig.setLabel("label"); serviceConfig.setDescription("description"); serviceConfig.setRequired(false); serviceConfig.setType("type"); serviceConfig.setConfigurableInWizard(false); serviceConfig.setDefaultValue("defaultValue"); serviceConfig.setMinValue(0); serviceConfig.setMaxValue(0); serviceConfig.setUnit("unit"); serviceConfig.setHidden(false); serviceConfig.setSelectValue(Arrays.asList("value")); serviceConfig.setConfigType("configType"); final List<ServiceConfig> list = Arrays.asList(serviceConfig); final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  // Configure ClusterInfoService.getById(...). final ClusterInfoEntity clusterInfoEntity = new ClusterInfoEntity(); clusterInfoEntity.setId(0); clusterInfoEntity.setCreateBy("createBy"); clusterInfoEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterInfoEntity.setClusterName("clusterName"); clusterInfoEntity.setClusterCode("clusterCode"); clusterInfoEntity.setClusterFrame("clusterFrame"); clusterInfoEntity.setFrameVersion("frameVersion"); clusterInfoEntity.setClusterState(ClusterState.RUNNING); clusterInfoEntity.setFrameId(0); final UserInfoEntity userInfoEntity = new UserInfoEntity(); userInfoEntity.setId(0); userInfoEntity.setUsername("username"); userInfoEntity.setPassword("password"); userInfoEntity.setEmail("email"); userInfoEntity.setPhone("phone"); clusterInfoEntity.setClusterManagerList(Arrays.asList(userInfoEntity)); when(mockClusterInfoService.getById(0)).thenReturn(clusterInfoEntity);  // Configure FrameServiceService.getServiceByFrameCodeAndServiceName(...). final FrameServiceEntity frameServiceEntity = new FrameServiceEntity(); frameServiceEntity.setId(0); frameServiceEntity.setFrameId(0); frameServiceEntity.setServiceName("serviceName"); frameServiceEntity.setLabel("label"); frameServiceEntity.setServiceVersion("serviceVersion"); frameServiceEntity.setServiceDesc("serviceDesc"); frameServiceEntity.setPackageName("packageName"); frameServiceEntity.setDependencies("dependencies"); frameServiceEntity.setServiceJson("serviceJson"); frameServiceEntity.setServiceJsonMd5("serviceJsonMd5"); frameServiceEntity.setServiceConfig("serviceConfig"); frameServiceEntity.setFrameCode("frameCode"); frameServiceEntity.setConfigFileJson("configFileJson"); frameServiceEntity.setConfigFileJsonMd5("configFileJsonMd5"); frameServiceEntity.setSortNum(0); when(mockFrameService.getServiceByFrameCodeAndServiceName("clusterFrame", "serviceName")).thenReturn( frameServiceEntity);  // Configure ClusterVariableService.getVariableByVariableName(...). final ClusterVariable clusterVariable = new ClusterVariable(); clusterVariable.setId(0); clusterVariable.setClusterId(0); clusterVariable.setVariableName("variableName"); clusterVariable.setVariableValue("variableValue"); when(mockVariableService.getVariableByVariableName("variableName", 0)).thenReturn(clusterVariable);  when(mockVariableService.updateById(new ClusterVariable())).thenReturn(false); when(mockVariableService.save(new ClusterVariable())).thenReturn(false);  // Configure ClusterHostService.list(...). final ClusterHostEntity clusterHostEntity = new ClusterHostEntity(); clusterHostEntity.setId(0); clusterHostEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterHostEntity.setHostname("hostname"); clusterHostEntity.setIp("ip"); clusterHostEntity.setRack("rack"); clusterHostEntity.setCoreNum(0); clusterHostEntity.setTotalMem(0); clusterHostEntity.setTotalDisk(0); clusterHostEntity.setUsedMem(0); clusterHostEntity.setUsedDisk(0); clusterHostEntity.setAverageLoad("averageLoad"); clusterHostEntity.setCheckTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterHostEntity.setClusterId(0); clusterHostEntity.setHostState(0); clusterHostEntity.setManaged(MANAGED.YES); final List<ClusterHostEntity> clusterHostEntities = Arrays.asList(clusterHostEntity); when(mockHostService.list(any(QueryWrapper.class))).thenReturn(clusterHostEntities);  // Configure ClusterServiceInstanceService.getServiceInstanceByClusterIdAndServiceName(...). final ClusterServiceInstanceEntity clusterServiceInstanceEntity = new ClusterServiceInstanceEntity(); clusterServiceInstanceEntity.setId(0); clusterServiceInstanceEntity.setClusterId(0); clusterServiceInstanceEntity.setServiceName("serviceName"); clusterServiceInstanceEntity.setLabel("label"); clusterServiceInstanceEntity.setServiceState(ServiceState.WAIT_INSTALL); clusterServiceInstanceEntity.setServiceStateCode(0); clusterServiceInstanceEntity.setUpdateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceInstanceEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceInstanceEntity.setNeedRestart(NeedRestart.NO); clusterServiceInstanceEntity.setFrameServiceId(0); clusterServiceInstanceEntity.setDashboardUrl("dashboardUrl"); clusterServiceInstanceEntity.setAlertNum(0); clusterServiceInstanceEntity.setSortNum(0); when(mockServiceInstanceService.getServiceInstanceByClusterIdAndServiceName(0, "serviceName")).thenReturn( clusterServiceInstanceEntity);  when(mockServiceInstanceService.save(new ClusterServiceInstanceEntity())).thenReturn(false); when(mockRoleGroupService.save(new ClusterServiceInstanceRoleGroup())).thenReturn(false); when(mockGroupConfigService.save(new ClusterServiceRoleGroupConfig())).thenReturn(false);  // Configure ClusterServiceInstanceRoleGroupService.getRoleGroupByServiceInstanceId(...). final ClusterServiceInstanceRoleGroup clusterServiceInstanceRoleGroup = new ClusterServiceInstanceRoleGroup(); clusterServiceInstanceRoleGroup.setId(0); clusterServiceInstanceRoleGroup.setRoleGroupName("默认角色组"); clusterServiceInstanceRoleGroup.setServiceInstanceId(0); clusterServiceInstanceRoleGroup.setServiceName("serviceName"); clusterServiceInstanceRoleGroup.setClusterId(0); clusterServiceInstanceRoleGroup.setRoleGroupType("auto"); when(mockRoleGroupService.getRoleGroupByServiceInstanceId(0)).thenReturn(clusterServiceInstanceRoleGroup);  // Configure ClusterServiceRoleGroupConfigService.getConfigByRoleGroupId(...). final ClusterServiceRoleGroupConfig clusterServiceRoleGroupConfig = new ClusterServiceRoleGroupConfig(); clusterServiceRoleGroupConfig.setId(0); clusterServiceRoleGroupConfig.setRoleGroupId(0); clusterServiceRoleGroupConfig.setConfigJson("configJson"); clusterServiceRoleGroupConfig.setConfigJsonMd5("configJsonMd5"); clusterServiceRoleGroupConfig.setConfigVersion(0); clusterServiceRoleGroupConfig.setConfigFileJson("configFileJson"); clusterServiceRoleGroupConfig.setConfigFileJsonMd5("configFileJsonMd5"); clusterServiceRoleGroupConfig.setClusterId(0); clusterServiceRoleGroupConfig.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceRoleGroupConfig.setUpdateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterServiceRoleGroupConfig.setServiceName("serviceName"); when(mockGroupConfigService.getConfigByRoleGroupId(0)).thenReturn(clusterServiceRoleGroupConfig);  when(mockRoleGroupService.count(any(QueryWrapper.class))).thenReturn(0); when(mockServiceInstanceService.updateById(new ClusterServiceInstanceEntity())).thenReturn(false);  // Run the test final Result result = serviceInstallServiceImplUnderTest.saveServiceConfig(0, "serviceName", list, 0);  // Verify the results "<AssertPlaceHolder>"; verify(mockVariableService).updateById(new ClusterVariable()); verify(mockVariableService).save(new ClusterVariable()); verify(mockServiceInstanceService).save(new ClusterServiceInstanceEntity()); verify(mockRoleGroupService).save(new ClusterServiceInstanceRoleGroup()); verify(mockGroupConfigService).save(new ClusterServiceRoleGroupConfig()); verify(mockRoleInstanceService).updateToNeedRestart(0); verify(mockServiceInstanceService).updateById(new ClusterServiceInstanceEntity()); }
saveServiceConfig( Integer clusterId, String serviceName, List<ServiceConfig> list, Integer roleGroupId) { ClusterInfoEntity clusterInfo = clusterInfoService.getById(clusterId); ServiceConfigMap.put( clusterInfo.getClusterCode() + Constants.UNDERLINE + serviceName + Constants.CONFIG, list); HashMap<String, ServiceConfig> map = new HashMap<>(); Map<String, String> globalVariables = GlobalVariables.get(clusterId); // handler config ServiceRoleStrategy serviceRoleHandler = ServiceRoleStrategyContext.getServiceRoleHandler(serviceName); if (Objects.nonNull(serviceRoleHandler)) { serviceRoleHandler.handlerConfig(clusterId, list, ServiceRoleStrategyContext.getServiceName(serviceName)); } // add variable FrameServiceEntity frameServiceEntity = frameService.getServiceByFrameCodeAndServiceName( clusterInfo.getClusterFrame(), serviceName); Boolean configUpdate = false; for (ServiceConfig serviceConfig : list) { String configName = serviceConfig.getName(); String variableName = "${" + configName + "}"; String variableValue = String.valueOf(serviceConfig.getValue()); // add to global variable if (Constants.INPUT.equals(serviceConfig.getType())) { addToGlobalVariable(clusterId, serviceName, variableName, variableValue); } globalVariables.put(variableName, variableValue); map.put(serviceConfig.getName(), serviceConfig); } // update config-file HashMap<Generators, List<ServiceConfig>> configFileMap = new HashMap<>(); buildConfigFileMap(serviceName, clusterInfo, map, configFileMap); if (PROMETHEUS.equals(serviceName.toLowerCase())) { logger.info("add worker and node to prometheus"); // add host node to prometheus addHostNodeToPrometheus(clusterId, configFileMap); } ClusterServiceInstanceEntity serviceInstanceEntity = serviceInstanceService.getServiceInstanceByClusterIdAndServiceName( clusterId, serviceName); if (Objects.isNull(serviceInstanceEntity)) { serviceInstanceEntity = saveServiceInstance(clusterId, serviceName, frameServiceEntity); ClusterServiceInstanceRoleGroup clusterServiceInstanceRoleGroup = saveServiceInstanceRoleGroup(clusterId, serviceName, serviceInstanceEntity); saveServiceRoleGroupConfig( clusterId, serviceName, list, configFileMap, clusterServiceInstanceRoleGroup); CacheUtils.put( "UseRoleGroup_" + serviceInstanceEntity.getId(), clusterServiceInstanceRoleGroup.getId()); } else { configUpdate = isConfigNeedUpdate(serviceInstanceEntity, list); ClusterServiceRoleGroupConfig roleGroupConfig; if (Objects.isNull(roleGroupId)) { ClusterServiceInstanceRoleGroup roleGroup = roleGroupService.getRoleGroupByServiceInstanceId( serviceInstanceEntity.getId()); roleGroupConfig = groupConfigService.getConfigByRoleGroupId(roleGroup.getId()); } else { roleGroupConfig = groupConfigService.getConfigByRoleGroupId(roleGroupId); } CacheUtils.put( "UseRoleGroup_" + serviceInstanceEntity.getId(), roleGroupConfig.getRoleGroupId()); if (configUpdate) { ClusterServiceRoleGroupConfig newRoleGroupConfig = new ClusterServiceRoleGroupConfig(); if (Objects.isNull(roleGroupId)) { ClusterServiceInstanceRoleGroup roleGroup = saveNewRoleGroup(serviceInstanceEntity); newRoleGroupConfig.setConfigVersion(1); newRoleGroupConfig.setRoleGroupId(roleGroup.getId()); CacheUtils.put( "UseRoleGroup_" + serviceInstanceEntity.getId(), roleGroup.getId()); } else { newRoleGroupConfig.setConfigVersion(roleGroupConfig.getConfigVersion() + 1); newRoleGroupConfig.setRoleGroupId(roleGroupConfig.getRoleGroupId()); roleInstanceService.updateToNeedRestart(roleGroupId); roleGroupService.updateToNeedRestart(roleGroupId); serviceInstanceEntity.setNeedRestart(NeedRestart.YES); } newRoleGroupConfig.setClusterId(clusterId); newRoleGroupConfig.setCreateTime(new Date()); newRoleGroupConfig.setUpdateTime(new Date()); newRoleGroupConfig.setServiceName(serviceInstanceEntity.getServiceName()); buildConfig(list, configFileMap, newRoleGroupConfig); groupConfigService.save(newRoleGroupConfig); } // update service instance serviceInstanceEntity.setUpdateTime(new Date()); serviceInstanceEntity.setLabel(frameServiceEntity.getLabel()); serviceInstanceService.updateById(serviceInstanceEntity); } return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testGetIsomorphism() { when(mockHazelcastBaseNode.getIsomorphism()).thenCallRealMethod(); boolean isomorphism = mockHazelcastBaseNode.getIsomorphism(); Assertions."<AssertPlaceHolder>"; }
getIsomorphism() { return Optional.ofNullable(this.processorBaseContext.getTaskDto().getIsomorphism()).orElse(false); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: shouldSetAndGetAltClickMovesCursor() { options.setAltClickMovesCursor(false); "<AssertPlaceHolder>"; }
isAltClickMovesCursor() { return altClickMovesCursor; }
[*] target: assertFalse(options.isAltClickMovesCursor())
[-] pred: org. junit. Assert. assertFalse ( options. isAltClickMovesCursor() )
************************************
************************************
[+] input: should_not_mappe_movie_null() { // when final Movie result = MovieMapper.toDomain(null); // then "<AssertPlaceHolder>"; }
toDomain(final MovieDb movieDb) { if (movieDb == null) { return null; } return Movie.builder() .id(String.valueOf(movieDb.getId())) .title(movieDb.getTitle()) .synopsys(movieDb.getOverview()) .rate(new Rate(movieDb.getPopularity())) .releaseDate(DateTimeUtil.getFromISO(movieDb.getReleaseDate())) .build(); }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: whenObjectIsNull_ThenEqualsReturnsFalse() { UserId id1 = new UserId("bob@example.com");  "<AssertPlaceHolder>"; }
equals(@Nullable Object o) { if (this == o) { return true; }  if (o == null || getClass() != o.getClass()) { return false; }  UserId userId = (UserId) o; return email.equals(userId.email); }
[*] target: assertFalse(id1.equals(null))
[-] pred: org. junit. Assert. assertFalse ( id1. equals ( null ) )
************************************
************************************
[+] input: ingress2RouteTestRegularPathSingleService() { V1Ingress ingress = buildBasicSupportedIngress();  V1ObjectMeta metadata = ingress.getMetadata(); metadata.setName("test"); KubernetesUtil.setAnnotation(metadata, KubernetesConstants.Annotation.DESTINATION_KEY, "hello.default.svc.cluster.local"); KubernetesUtil.setAnnotation(metadata, KubernetesConstants.Annotation.USE_REGEX_KEY, KubernetesConstants.Annotation.TRUE_VALUE);  V1HTTPIngressPath path = ingress.getSpec().getRules().get(0).getHttp().getPaths().get(0); path.setPathType(KubernetesConstants.IngressPathType.PREFIX); path.setPath("/route_\\d+");  Route route = converter.ingress2Route(ingress);  Route expectedRoute = buildBasicRoute(); expectedRoute.setName(metadata.getName()); RoutePredicate pathPredicate = expectedRoute.getPath(); pathPredicate.setMatchType(RoutePredicateTypeEnum.REGULAR.toString()); pathPredicate.setCaseSensitive(null); pathPredicate.setMatchValue(path.getPath()); UpstreamService service = new UpstreamService("hello.default.svc.cluster.local", null, null, 100); expectedRoute.setServices(Collections.singletonList(service)); Assertions."<AssertPlaceHolder>"; }
ingress2Route(V1Ingress ingress) { Route route = new Route(); fillRouteMetadata(route, ingress.getMetadata()); fillRouteInfo(route, ingress.getMetadata(), ingress.getSpec()); fillCustomConfigs(route, ingress.getMetadata()); return route; }
[*] target: assertEquals(expectedRoute, route)
[-] pred: org. junit. Assert. assertEquals ( expectedRoute, route )
************************************
************************************
[+] input: testCreateTaskManagerDeployment() { flinkKubeClient.createTaskManagerDeployment(tmDeployment); final List<Deployment> resultedDeployments = getClient().apps().deployments().inNamespace(TEST_NAMESPACE).list().getItems(); "<AssertPlaceHolder>"; }
createTaskManagerDeployment(Deployment tmDeployment) { this.internalClient.apps().deployments().create(tmDeployment); }
[*] target: assertEquals(1, resultedDeployments.size())
[-] pred: org. junit. Assert. assertEquals ( 1, resultedDeployments. size ( ) )
************************************
************************************
[+] input: shouldSetAndGetSmoothScrollDuration() { options.setSmoothScrollDuration(300); "<AssertPlaceHolder>"; }
getSmoothScrollDuration() { return smoothScrollDuration; }
[*] target: assertEquals(300, options.getSmoothScrollDuration())
[-] pred: org. junit. Assert. assertEquals ( 300, options. getSmoothScrollDuration() )
************************************
************************************
[+] input: getUnknownTypeAsString() { final EditorHelper editorHelper = new EditorHelper();  final String result = editorHelper.getObjectString("unknown-type", true); Assertions."<AssertPlaceHolder>"; }
getObjectString(String type, Object object) { try { final Class<?> klass = parseType(type); return new Gson().toJson(object, klass); } catch (Exception e) { log.warn("Failed to get value: {}, {}", type, object, e); return null; } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: givenConcreteTypeWithoutTypeParameters() { Type type = STRING; String toVerify = type(type).generate(); String expected = "java.lang.String"; "<AssertPlaceHolder>"; }
generate() { return type.match( generic -> generic.getName().raw(),  concrete -> { List<TypeArgument> typeArguments = concrete.getTypeArguments(); if (typeArguments.isEmpty()) { return concrete.getFullyQualifiedName().raw(); } else { return concrete.getFullyQualifiedName().raw() + OPEN_ANGULAR_BRACKET + typeArguments.stream().map(TypeArgumentGenerator::generateFrom).collect(joining(SEPARATOR)) + CLOSE_ANGULAR_BRACKET; } },  array -> type(array.getType()).generate() + OPEN_SQUARE_BRACKET + CLOSE_SQUARE_BRACKET ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(Integer value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } else { String stringValue = value.toString(); return TypeCodecs.TEXT.encode(stringValue, protocolVersion); } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testEmptyTable() { AsciiTable tablePrinter = new AsciiTable(Arrays.asList("TYPE", "NAME", "STATUS", "URL")); String expected = "+------+------+--------+-----+\n" + "| TYPE | NAME | STATUS | URL |\n" + "+------+------+--------+-----+\n" + "+------+------+--------+-----+\n"; "<AssertPlaceHolder>"; }
printTable() { StringBuilder table = new StringBuilder(); int[] columnWidths = new int[headers.size()];  // Calculate the width of each column for (int i = 0; i < headers.size(); i++) { columnWidths[i] = headers.get(i).length(); }  for (List<String> row : rows) { for (int i = 0; i < row.size(); i++) { columnWidths[i] = Math.max(columnWidths[i], row.get(i).length()); } }  // Append the headers table.append(printSeparator(columnWidths)); table.append(printRow(headers, columnWidths)); table.append(printSeparator(columnWidths));  // Append the rows for (List<String> row : rows) { table.append(printRow(row, columnWidths)); } table.append(printSeparator(columnWidths));  return table.toString(); }
[*] target: assertEquals(expected, tablePrinter.printTable())
[-] pred: org. junit. Assert. assertEquals ( expected, tablePrinter. printTable ( ) )
************************************
************************************
[+] input: testGetNullRemoveFields() { TapUpdateRecordEvent tapUpdateRecordEvent = new TapUpdateRecordEvent(); List<String> removeFields = TapEventUtil.getRemoveFields(tapUpdateRecordEvent); "<AssertPlaceHolder>"; }
getRemoveFields(TapEvent tapEvent) { List<String> removeFields=null; if(tapEvent instanceof  TapUpdateRecordEvent){ removeFields=((TapUpdateRecordEvent)tapEvent).getRemovedFields(); return removeFields; } return null; }
[*] target: assertNull(removeFields)
[-] pred: org. junit. Assert. assertNull ( removeFields )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismNullNodeList() { when(nodeList.size()).thenReturn(0); boolean isomorphism = dag.getTaskDtoIsomorphism(null); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(0)).size(); verify(nodeList, times(0)).get(0); verify(nodeList, times(0)).get(1); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: 옵션에_가격이_붙으면_결제가_필요한_오더라인이다() { // given given(orderItem.getPrice()).willReturn(money3000); Money optionAnswerPrice1 = Money.wons(1000L); given(orderOptionAnswer1.getAdditionalPrice()).willReturn(optionAnswerPrice1); Money optionAnswerPrice2 = Money.wons(2000L); given(orderOptionAnswer2.getAdditionalPrice()).willReturn(optionAnswerPrice2); // when Boolean needPayment = orderLineItem.isNeedPaid();  "<AssertPlaceHolder>"; }
isNeedPaid() { Money totalOrderLinePrice = getTotalOrderLinePrice(); // 0 < totalOrderLinePrice return Money.ZERO.isLessThan(totalOrderLinePrice); }
[*] target: assertTrue(needPayment)
[-] pred: org. junit. Assert. assertTrue ( needPayment )
************************************
************************************
[+] input: Exception {  CollectRep.MetricsData metricsData = CollectRep.MetricsData.newBuilder().setMetrics("test metrics").build(); String metricsDataJson = "{"metrics":"test metrics"}";  when(syncCommands.rpop("metricsDataQueueToAlerter")).thenReturn(metricsDataJson);  CollectRep.MetricsData actualMetricsData = redisCommonDataQueue.pollMetricsDataToAlerter(); "<AssertPlaceHolder>"; }
pollMetricsDataToAlerter() {  try { String metricsDataJson = syncCommands.rpop(metricsDataQueueNameToAlerter); if (metricsDataJson != null) { return (CollectRep.MetricsData) ProtoJsonUtil.toProtobuf(metricsDataJson, CollectRep.MetricsData.newBuilder()); } } catch (Exception e) { log.error(e.getMessage()); throw new RuntimeException(e); } return null; }
[*] target: assertEquals(metricsData, actualMetricsData)
[-] pred: org. junit. Assert. assertEquals ( metricsData, actualMetricsData )
************************************
************************************
[+] input: combine() { Map<Integer, String> left = new HashMap<>(); left.put(1, "One"); left.put(2, "Two"); left.put(3, "Three");  Map<Integer, String> right = new HashMap<>(); right.put(2, "Twee"); right.put(3, "Drie"); right.put(4, "Vier");  Map<Integer, String> expected = new HashMap<>(); expected.put(2, "TwoTwee"); expected.put(3, "ThreeDrie"); Map<Integer, String> toVerify = Maps.<Integer>instance().compose(left, right, String::concat);  "<AssertPlaceHolder>"; }
compose(MergeMap<K, ? extends A> left, Map<K, ? extends B> right, BiFunction<? super A, ? super B, ? extends C> fn) { return MergeMap.of(left, right, fn); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testCheckTableExistNormal() { String connectionId = "111"; String tableName = "table"; doReturn(1L).when(metadataInstancesService).count(any(Query.class),any(UserDetail.class)); boolean actual = metadataInstancesService.checkTableExist(connectionId, tableName, userDetail); "<AssertPlaceHolder>"; }
checkTableExist(String connectionId, String tableName, UserDetail user) { Criteria criteria = Criteria.where(ORIGINAL_NAME).is(tableName) .and(IS_DELETED).ne(true) .and("SOURCE_ID").is(connectionId) .and(SOURCE_TYPE).is(SourceTypeEnum.SOURCE.name()) .and(TASK_ID).exists(false); Query query = new Query(criteria); long count = count(query, user); return count > 0; }
[*] target: assertEquals(true,actual)
[-] pred: org. junit. Assert. assertEquals ( true, actual )
************************************
************************************
[+] input: IOException { BilibiliResponse<UserWebListResult> response = client.liveUserWebList(1, 10); Assertions."<AssertPlaceHolder>"; // 需要Cookie }
liveUserWebList(int pageNum, int pageSize) throws IOException { checkBuVid3BuVid4(); String url = ApiUtil.fillUrl(ApiUrlContainer.LIVE_USER_WEB_LIST, pageNum, pageSize, System.currentTimeMillis()); return httpJsonClient.getJson(url, new TypeReference<BilibiliResponse<UserWebListResult>>() { }, requestHeader); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: givenConcreteMethodWithTwoLineBody() { List<String> toVerify = method() .withModifiers(PUBLIC) .withReturnType(STRING) .withName("toString") .withBody("String result = "Helpful description";") .withReturnStatement("result") .lines();  List<String> expected = asList( "public java.lang.String toString() {", "    String result = "Helpful description";", "    return result;", "}" );  "<AssertPlaceHolder>"; }
lines() { List<String> components = new ArrayList<>(); if (!modifiersGenerator.isEmpty()) { components.add(modifiersGenerator.generate()); } if (!typeParametersGenerator.isEmpty()) { components.add(typeParametersGenerator.generate()); } components.add(optionalReturnType.map(TypeGenerator::generateFrom).orElse(VOID)); components.add(name + parametersGenerator.generate()); String methodDeclaration = components.stream().collect(joining(SPACE));  return optionalBodyGenerator .map(bodyGenerator -> { List<String> result = new ArrayList<>(); result.add(methodDeclaration + SPACE + OPEN_BRACE); result.addAll(bodyGenerator.indent().lines()); result.add(CLOSE_BRACE); return result; }) .orElse(asList(methodDeclaration + SEMICOLON)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: applyGivenTypeConstructorWithPlaceholder() { ArrayType expected = new ArrayType(STRING_TYPE); ArrayType toVerify = new ArrayTypeConstructor(new PlaceholderTypeConstructor()).apply(STRING_TYPE);  "<AssertPlaceHolder>"; }
apply(Type toApplyTo) { return Type.array(type.apply(toApplyTo)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: givenColor() { // See https://benjiweber.co.uk/blog/2020/09/19/fun-with-java-records/ Color color = new Color(1, 2, 3); Town expected = new Town(1, 2, 3); Town toVerify = color.decomposeTo(Town::new); "<AssertPlaceHolder>"; }
decomposeTo(Function3<? super First, ? super Second, ? super Third, ? extends T> fn) { var components = this.getClass().getRecordComponents(); try { return fn.apply( (First) components[0].getAccessor().invoke(this), (Second) components[1].getAccessor().invoke(this), (Third) components[2].getAccessor().invoke(this) ); } catch (ReflectiveOperationException e) { throw new RuntimeException(e); } }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testReplay() { Mockito.when(extractor.replay()).thenReturn(MockResult.success("mock")); MockResult result = target.replay(); "<AssertPlaceHolder>"; }
replay() { return extractor.replay(); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: format_ShouldFormatNumberValueAsText() { Integer value = 10; String expected = TypeCodecs.INT.format(value); String result = codec.format(value); Assertions."<AssertPlaceHolder>"; }
format(Integer value) { return TypeCodecs.INT.format(value); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testReduceStock() { long goodsId = 1L; SeckillGoods seckillGoods = new SeckillGoods(); seckillGoods.setStockCount(5);  // 使用 any() 来匹配任何 LambdaQueryWrapper 参数 when(seckillGoodsManager.getOne(any())).thenReturn(seckillGoods);  when(redisService.get(SeckillGoodsKey.seckillCount, String.valueOf(goodsId), Integer.class)) .thenReturn(4); when(seckillGoodsManager.update(eq(seckillGoods), any())).thenReturn(true);  int result = seckillGoodsService.reduceStock(goodsId);  "<AssertPlaceHolder>"; verify(redisService, times(1)).get(SeckillGoodsKey.seckillCount, String.valueOf(goodsId), Integer.class); verify(seckillGoodsManager, times(1)).update(eq(seckillGoods), any()); }
reduceStock(long goodsId) { SeckillGoods seckillGoods = seckillGoodsManager.getOne( Wrappers.<SeckillGoods>lambdaQuery().eq(SeckillGoods::getGoodsId, goodsId) );  // 多线程并发写的时候，有并发问题，这里只读redis的库存，然后写入库中，避免并发问题。 reduceStockCount(goodsId, seckillGoods); boolean flag = seckillGoodsManager.update(seckillGoods, Wrappers.<SeckillGoods>lambdaUpdate().eq(SeckillGoods::getGoodsId, goodsId)); return (flag) ? 1 : 0; }
[*] target: assertEquals(1, result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: shouldSetAndGetMacOptionClickForcesSelection() { options.setMacOptionClickForcesSelection(true); "<AssertPlaceHolder>"; }
isMacOptionClickForcesSelection() { return macOptionClickForcesSelection; }
[*] target: assertTrue(options.isMacOptionClickForcesSelection())
[-] pred: org. junit. Assert. assertTrue ( options. isMacOptionClickForcesSelection() )
************************************
************************************
[+] input: testBuildTaskRetryConfigWithNull() { doCallRealMethod().when(tapTableMap).buildTaskRetryConfig(null); tapTableMap.buildTaskRetryConfig(null); Object actual = ReflectionTestUtils.getField(tapTableMap, "taskConfig"); "<AssertPlaceHolder>"; }
buildTaskRetryConfig(TaskConfig taskConfig){ this.taskConfig = taskConfig; }
[*] target: assertEquals(null,actual)
[-] pred: org. junit. Assert. assertEquals ( null, actual )
************************************
************************************
[+] input: testCheckWhenSameUserId() { OnlySelfDataPermissionChecker checker = new OnlySelfDataPermissionChecker(deptService); SystemLoginUser loginUser = new SystemLoginUser(); loginUser.setUserId(1L); DataCondition dataCondition = new DataCondition(); dataCondition.setTargetUserId(1L);  boolean check = checker.check(loginUser, dataCondition);  "<AssertPlaceHolder>"; }
check(SystemLoginUser loginUser, DataCondition condition) { if (condition == null || loginUser == null) { return false; }  if (loginUser.getUserId() == null || condition.getTargetUserId() == null) { return false; }  Long currentUserId = loginUser.getUserId(); Long targetUserId = condition.getTargetUserId(); return Objects.equals(currentUserId, targetUserId); }
[*] target: assertTrue(check)
[-] pred: org. junit. Assert. assertTrue ( check )
************************************
************************************
[+] input: placeholder() { PlaceholderTypeConstructor expected = new PlaceholderTypeConstructor(); PlaceholderTypeConstructor toVerify = TypeConstructor.placeholder();  "<AssertPlaceHolder>"; }
placeholder() { return new PlaceholderTypeConstructor(); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testGetMessage() { String message = "Another Message"; MessageAction action = new MessageAction(message); String retrievedMessage = action.getMessage();  "<AssertPlaceHolder>"; }
getMessage() { return message; }
[*] target: assertEquals(message, retrievedMessage)
[-] pred: org. junit. Assert. assertEquals ( message, retrievedMessage )
************************************
************************************
[+] input: test_isCloudLimit() { ObjectId taskId = MongoUtils.toObjectId("632454d5287a904778c40f8d"); Query query = new Query(Criteria.where("_id").is(taskId)); query.fields().include("id", "agentId", "agentTags"); TaskEntity mockTask = new TaskEntity(); mockTask.setCrontabExpressionFlag(false); mockTask.setId(MongoUtils.toObjectId("632454d5287a904778c40f8d")); try (MockedStatic<DataPermissionService> serviceMockedStatic = Mockito.mockStatic(DataPermissionService.class)) { serviceMockedStatic.when(DataPermissionService::isCloud).thenReturn(true); when(settingsService.isCloud()).thenReturn(true); when(taskRepository.findOne(query)).thenReturn(Optional.of(mockTask)); TaskDto mockTaskDto = new TaskDto(); BeanUtils.copyProperties(mockTask, mockTaskDto); CalculationEngineVo mockEngineVo = new CalculationEngineVo(); mockEngineVo.setTaskLimit(5); mockEngineVo.setRunningNum(5); when(workerService.calculationEngine(mockTaskDto, user, null)).thenReturn(mockEngineVo); Query mockQuery = new Query(Criteria.where("_id").is(taskId)); mockQuery.fields().include("planStartDateFlag", "crontabExpressionFlag"); when(taskRepository.findOne(mockQuery)).thenReturn(Optional.of(mockTask)); boolean result = taskService.checkCloudTaskLimit(taskId, user, true); "<AssertPlaceHolder>"; } }
checkCloudTaskLimit(ObjectId taskId, UserDetail user, boolean checkCurrentTask); public abstract void updateDelayTime(ObjectId taskId, long delayTime); public abstract void refreshSchemas(TaskDto taskDto, String nodeIds, String keys, UserDetail userDetail); public abstract void checkSourceTimeDifference(TaskDto taskDto,UserDetail userDetail);  @Data @AllArgsConstructor @NoArgsConstructor public static class Char1Group { private String _id; private long count; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: test() { PropertiesToStringConverter converter = PropertiesToStringConverter.INSTANCE; Properties properties = new Properties(); properties.setProperty("A", "1"); String content = converter.convert(properties); "<AssertPlaceHolder>"; }
convert(Properties source) { StringWriter writer = new StringWriter(); try { source.store(writer, "Generated by Microsphere"); } catch (IOException ignored) { } return writer.toString(); }
[*] target: assertNotNull(content)
[-] pred: org. junit. Assert. assertNotNull ( content )
************************************
************************************
[+] input: ncmPass() { NCM[] ncm = BrasilAPI.ncm(); "<AssertPlaceHolder>"; }
ncm() { NCM[] obj = (NCM[]) api(NCM[].class, "ncm/v1", ""); return obj != null ? (NCM[]) obj.clone() : null; }
[*] target: assertNotNull(ncm)
[-] pred: org. junit. Assert. assertNotNull ( ncm )
************************************
************************************
[+] input: testLookup() { MethodHandles.Lookup lookup = lookup(String.class); MethodHandles.Lookup lookup2 = lookup(String.class); "<AssertPlaceHolder>"; }
lookup(Class<?> lookupClass) { return lookup(lookupClass, LookupMode.ALL); }
[*] target: assertSame(lookup, lookup2)
[-] pred: org. junit. Assert. assertSame ( lookup, lookup2 )
************************************
************************************
[+] input: asTypeConstructorWithPlaceHolderForGivenNeedleThatDoesNotMatchElementType() { TypeConstructor expected = new ArrayTypeConstructor(new GenericTypeConstructor(U)); TypeConstructor toVerify = new ArrayType(new GenericType(U)).asTypeConstructorWithPlaceholderFor(T);  "<AssertPlaceHolder>"; }
asTypeConstructorWithPlaceholderFor(TypeParameterName needle) { return TypeConstructor.array(type.asTypeConstructorWithPlaceholderFor(needle)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: decode_ShouldDecodeTextByteBufferAndReturnAsNumber() { String valueAsString = "21474836470.7"; Double value = Double.valueOf(valueAsString); // encoding could be from user input, so may not be in Java Double.toString() format ByteBuffer byteBuffer = TypeCodecs.TEXT.encode(valueAsString, CqlConversion.PROTOCOL_VERSION);  Double result = codec.decode(byteBuffer, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
decode(ByteBuffer bytes, @NotNull ProtocolVersion protocolVersion) { String stringValue = TypeCodecs.TEXT.decode(bytes, protocolVersion); return Double.valueOf(stringValue); }
[*] target: assertEquals(value, result)
[-] pred: org. junit. Assert. assertEquals ( value, result )
************************************
************************************
[+] input: testNormal() { List<WorkerDto> allAgent = agentGroupService.findAllAgent(agentIds, userDetail); Assertions."<AssertPlaceHolder>"; verify(workerServiceImpl, times(1)).findAllDto(any(Query.class), any(UserDetail.class)); }
findAllAgent(Collection<String> agentIds, UserDetail loginUser) { if (CollectionUtils.isEmpty(agentIds)) { return Lists.newArrayList(); } Criteria criteria = Criteria.where(AgentGroupTag.TAG_PROCESS_ID).in(agentIds) .and(AgentGroupTag.TAG_WORKER_TYPE).is(AgentGroupTag.TAG_CONNECTOR); return workerServiceImpl.findAllDto(Query.query(criteria), loginUser); }
[*] target: assertNotNull(allAgent)
[-] pred: org. junit. Assert. assertNotNull ( allAgent )
************************************
************************************
[+] input: givenClassWithModifiersButWithoutTypeParameters() { List<String> toVerify = classOrInterface() .asClass() .withModifiers(PUBLIC, ABSTRACT) .withName("Device") .withBody( "public int capacity = 34;", "public boolean hasPower = true;" ) .lines();  List<String> expected = asList( "public abstract class Device {", "", "    public int capacity = 34;", "    public boolean hasPower = true;", "", "}" );  "<AssertPlaceHolder>"; }
lines() { List<String> result = new ArrayList<>(); result.add( String.join( SPACE, modifiersGenerator.isEmpty() ? type.toString() : modifiersGenerator.generate() + SPACE + type.toString(), name + typeParametersGenerator.generate(), OPEN_BRACE ) ); result.add(EMPTY_LINE); result.addAll(bodyGenerator.indent().lines()); result.add(EMPTY_LINE); result.add(CLOSE_BRACE); return result; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: test_error11() { Exception error = null; try { DefaultJSONParser parser = new DefaultJSONParser("{]"); parser.parse(); } catch (Exception ex) { error = ex; } "<AssertPlaceHolder>"; } }
parse() { return reader.readAny(); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: getConfiguration() { InputStream inputStream = TestFileUtils.getInputStream("statics/import/data-title-style-read.xlsx"); WorkbookParameter workbookParameter = WorkbookParameter.builder() .input(inputStream) .sheetParameter(SheetParameter.builder().sheet(0).titleRowStartIndex(0).headRowStartIndex(1).dataRowStartIndex(3).build()) .build(); Configuration configuration = new Configuration();  DefaultWorkbookContext defaultWorkbookContext = new DefaultWorkbookContext(configuration, workbookParameter);  Assertions."<AssertPlaceHolder>"; }
getConfiguration() { return configuration; }
[*] target: assertEquals(configuration, defaultWorkbookContext.getConfiguration())
[-] pred: org. junit. Assert. assertEquals ( configuration, defaultWorkbookContext. getConfiguration() )
************************************
************************************
[+] input: bind_nonCounter_withStandardInput() { commonSetup(false,false,false); targetUpdateStatement = new TargetUpdateStatement(propertyHelper, targetSession); BoundStatement result = targetUpdateStatement.bind(originRow, targetRow, null,null,null,null); "<AssertPlaceHolder>"; verify(boundStatement, times(targetColumnNames.size())).set(anyInt(), any(), any(Class.class)); }
bind(Row originRow, Row targetRow, Integer ttl, Long writeTime, Object explodeMapKey, Object explodeMapValue) { // We reference the originRow and convert it to the target type. // We need the targetRow if (null == originRow) throw new RuntimeException("originRow is null");  checkBindInputs(ttl, writeTime, explodeMapKey, explodeMapValue);  BoundStatement boundStatement = prepareStatement().bind();  int currentBindIndex = 0; if (usingTTL) { boundStatement = boundStatement.set(currentBindIndex++, ttl, Integer.class); } if (usingWriteTime) { boundStatement = boundStatement.set(currentBindIndex++, writeTime, Long.class); }  Object originValue, targetValue; Object bindValueTarget = null; for (int targetIndex : columnIndexesToBind) { int originIndex = cqlTable.getCorrespondingIndex(targetIndex);  try { if (usingCounter && counterIndexes.contains(targetIndex)) { originValue = cqlTable.getOtherCqlTable().getData(originIndex, originRow); if (null == originValue) { currentBindIndex++; continue; } targetValue = (null == targetRow ? 0L : cqlTable.getData(targetIndex, targetRow)); bindValueTarget = ((Long) originValue - (null == targetValue ? 0L : (Long) targetValue)); } else if (targetIndex== explodeMapKeyIndex) { bindValueTarget = explodeMapKey; } else if (targetIndex== explodeMapValueIndex) { bindValueTarget = explodeMapValue; } else { if (originIndex < 0) // we don't have data to bind for this column; continue to the next targetIndex continue; bindValueTarget = cqlTable.getOtherCqlTable().getAndConvertData(originIndex, originRow); }  boundStatement = boundStatement.set(currentBindIndex++, bindValueTarget, cqlTable.getBindClass(targetIndex)); } catch (Exception e) { logger.error("Error trying to bind value:" + bindValueTarget + " to column:" + targetColumnNames.get(targetIndex) + " of targetDataType:" + targetColumnTypes.get(targetIndex) + "/" + cqlTable.getBindClass(targetIndex).getName() + " at column index:" + targetIndex); throw e; } }  PKFactory pkFactory = session.getPKFactory(); EnhancedPK pk = pkFactory.getTargetPK(originRow); boundStatement = pkFactory.bindWhereClause(PKFactory.Side.TARGET, pk, boundStatement, currentBindIndex);  return boundStatement .setConsistencyLevel(cqlTable.getWriteConsistencyLevel()) .setTimeout(Duration.ofSeconds(10)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: test13() { QueryOperator queryOperator = new QueryOperator(); queryOperator.setUnit(TapTimeUnit.HOUR); List<String> result = TimeTransFormationUtil.calculatedTimeRange(currentDateTime,queryOperator,8L); Assertions."<AssertPlaceHolder>"; }
calculatedTimeRange(LocalDateTime currentDateTime, QueryOperator queryOperator,Long offsetHours){ List<String> result = new ArrayList<>(); if(null == queryOperator.getUnit() || null == queryOperator.getForm())return result; TapTimeForm tapTimeForm = queryOperator.getForm(); Long number = queryOperator.getNumber(); if(  null != offsetHours && offsetHours != 0){ currentDateTime = currentDateTime.plusHours(offsetHours); } switch (queryOperator.getUnit()){ case HOUR: LocalDateTime hourStart; LocalDateTime hourEnd; if(tapTimeForm.equals(TapTimeForm.BEFORE)){ hourStart = currentDateTime.minusHours(number).withMinute(0).withSecond(0); hourEnd = hourStart.plusHours(number-1).withMinute(59).withSecond(59); }else{ hourStart = currentDateTime.withMinute(0).withSecond(0); hourEnd  = currentDateTime; } result.add(formatDateTime(hourStart)); result.add(formatDateTime(hourEnd)); return result; case DAY: LocalDateTime dayStart; LocalDateTime dayEnd; if(tapTimeForm.equals(TapTimeForm.BEFORE)){ dayStart = currentDateTime.minusDays(number).withHour(0).withMinute(0).withSecond(0); dayEnd = dayStart.plusDays(number-1).withHour(23).withMinute(59).withSecond(59); }else{ dayStart = currentDateTime.withHour(0).withMinute(0).withSecond(0); dayEnd  = currentDateTime; } result.add(formatDateTime(dayStart)); result.add(formatDateTime(dayEnd)); return result; case WEEK: LocalDateTime weekStart; LocalDateTime weekEnd; if(tapTimeForm.equals(TapTimeForm.BEFORE)){ weekStart = currentDateTime.minusWeeks(number).with(DayOfWeek.MONDAY).withHour(0).withMinute(0).withSecond(0); weekEnd =  weekStart.plusWeeks(number-1).with(DayOfWeek.SUNDAY).withHour(23).withMinute(59).withSecond(59); }else{ weekStart = currentDateTime.with(DayOfWeek.MONDAY).withHour(0).withMinute(0).withSecond(0); weekEnd =  currentDateTime; } result.add(formatDateTime(weekStart)); result.add(formatDateTime(weekEnd)); return result; case MONTH: LocalDateTime monthStart; LocalDateTime monthEnd; if(tapTimeForm.equals(TapTimeForm.BEFORE)){ monthStart = currentDateTime.minusMonths(number).withDayOfMonth(1).withHour(0).withMinute(0).withSecond(0); monthEnd = currentDateTime.minusMonths(1).withDayOfMonth(currentDateTime.minusMonths(1).toLocalDate().lengthOfMonth()).withHour(23).withMinute(59).withSecond(59); }else{ monthStart = currentDateTime.withDayOfMonth(1).withHour(0).withMinute(0).withSecond(0); monthEnd = currentDateTime; } result.add(formatDateTime(monthStart)); result.add(formatDateTime(monthEnd)); return result; case YEAR: LocalDateTime yearStart; LocalDateTime yearEnd; if(tapTimeForm.equals(TapTimeForm.BEFORE)){ yearStart = currentDateTime.minusYears(number).withDayOfYear(1).withHour(0).withMinute(0).withSecond(0); yearEnd = currentDateTime.minusYears(1).withDayOfYear(currentDateTime.minusYears(1).toLocalDate().lengthOfYear()).withHour(23).withMinute(59).withSecond(59); }else{ yearStart = currentDateTime.withDayOfYear(1).withHour(0).withMinute(0).withSecond(0); yearEnd = currentDateTime; } result.add(formatDateTime(yearStart)); result.add(formatDateTime(yearEnd)); return result; default: return result; } }
[*] target: assertEquals(0,result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: givenGenericType() { Type type = T.asType(); String toVerify = type(type).generate(); String expected = "T"; "<AssertPlaceHolder>"; }
generate() { return type.match( generic -> generic.getName().raw(),  concrete -> { List<TypeArgument> typeArguments = concrete.getTypeArguments(); if (typeArguments.isEmpty()) { return concrete.getFullyQualifiedName().raw(); } else { return concrete.getFullyQualifiedName().raw() + OPEN_ANGULAR_BRACKET + typeArguments.stream().map(TypeArgumentGenerator::generateFrom).collect(joining(SEPARATOR)) + CLOSE_ANGULAR_BRACKET; } },  array -> type(array.getType()).generate() + OPEN_SQUARE_BRACKET + CLOSE_SQUARE_BRACKET ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: returnsNullWhenNodeIdDoesNotExistInDag() { String nodeId = "testNodeId"; DAG dag = mock(DAG.class);  MergeTableNode result = mergeNodeCleaner.getMergeTableNode(dag, nodeId);  "<AssertPlaceHolder>"; }
getMergeTableNode(DAG dag, String nodeId) { Node<?> node = dag.getNode(nodeId); if (node instanceof MergeTableNode) { return (MergeTableNode) node; } return null; }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: shouldTransformToComponentWithValidLocalDate() { LocalDate date = LocalDate.of(2005, 3, 4); int expectedJulianDate = 2453434; int result = transformer.transformToComponent(date); "<AssertPlaceHolder>"; }
transformToComponent(LocalDate modelValue) { try { if (modelValue == null) { return -1; }  int year = modelValue.getYear(); int month = modelValue.getMonthValue(); int day = modelValue.getDayOfMonth();  boolean leap = isLeapYear(year);  int num = year - 1; num = (num * 365) + (num / 4) - (num / 100) + (num / 400);  day += ((3055 * (month + 2)) / 100) - 91; if (month > 2) { if (leap) { day--; } else { day -= 2; } }  return num + day + 1721425; } catch (Exception e) { throw new TransformationException("Error transforming model value to component value"); } }
[*] target: assertEquals(expectedJulianDate, result)
[-] pred: org. junit. Assert. assertEquals ( expectedJulianDate, result )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(String value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } else { int intValue = Integer.parseInt(value); return TypeCodecs.INT.encode(intValue, protocolVersion); } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: numBits_zeroAndPositiveBounds() { SpaceFillingCurve sfc = new TestSpaceFillingCurve(0, 16); "<AssertPlaceHolder>"; }
numBits() { return this.numBits; }
[*] target: assertEquals(5, sfc.numBits())
[-] pred: org. junit. Assert. assertEquals ( 5, sfc. numBits() )
************************************
************************************
[+] input: testNeedSkipNormalNotFile() { File f = mock(File.class); when(f.exists()).thenReturn(true); when(f.isFile()).thenReturn(false); when(f.getName()).thenReturn("setup.py"); boolean needSkip = utils.needSkip(f); Assertions."<AssertPlaceHolder>"; }
needSkip(File f) { if (null == f) return true; if (!f.exists()) return true; if (!f.isFile()) return true; return !f.getName().contains(PACKAGE_COMPILATION_FILE); }
[*] target: assertTrue(needSkip)
[-] pred: org. junit. Assert. assertTrue ( needSkip )
************************************
************************************
[+] input: createShouldCreateLayoutBuilder() { FlexLayoutBuilder builder = FlexLayout.create(); "<AssertPlaceHolder>"; }
create() { return FlexLayout.create(new Component[0]); }
[*] target: assertNotNull(builder)
[-] pred: org. junit. Assert. assertNotNull ( builder )
************************************
************************************
[+] input: Exception { FlinkDeployment flinkApp = TestUtils.buildApplicationCluster(); ObjectMeta deployMeta = flinkApp.getMetadata(); FlinkDeploymentStatus status = flinkApp.getStatus(); FlinkDeploymentSpec spec = flinkApp.getSpec(); Configuration deployConfig = configManager.getDeployConfig(deployMeta, spec);  status.getJobStatus().setState(org.apache.flink.api.common.JobStatus.FINISHED.name()); status.setJobManagerDeploymentStatus(JobManagerDeploymentStatus.READY); reconciler .getReconciler() .deploy(getResourceContext(flinkApp), spec, deployConfig, Optional.empty(), false);  final List<Map<String, String>> expectedOwnerReferences = List.of(TestUtils.generateTestOwnerReferenceMap(flinkApp)); List<Map<String, String>> or = deployConfig.get(KubernetesConfigOptions.JOB_MANAGER_OWNER_REFERENCE); Assertions."<AssertPlaceHolder>"; }
deploy( FlinkResourceContext<FlinkDeployment> ctx, FlinkDeploymentSpec spec, Configuration deployConfig, Optional<String> savepoint, boolean requireHaMetadata) throws Exception { var cr = ctx.getResource(); setOwnerReference(cr, deployConfig); ctx.getFlinkService().submitSessionCluster(deployConfig); cr.getStatus().setJobManagerDeploymentStatus(JobManagerDeploymentStatus.DEPLOYING); IngressUtils.updateIngressRules( cr.getMetadata(), spec, deployConfig, ctx.getKubernetesClient()); }
[*] target: assertEquals(expectedOwnerReferences, or)
[-] pred: org. junit. Assert. assertEquals ( expectedOwnerReferences, or )
************************************
************************************
[+] input: testCheckWhenDifferentUserId() { OnlySelfDataPermissionChecker checker = new OnlySelfDataPermissionChecker(deptService); SystemLoginUser loginUser = new SystemLoginUser(); loginUser.setUserId(1L); DataCondition dataCondition = new DataCondition(); dataCondition.setTargetDeptId(2L);  boolean check = checker.check(loginUser, dataCondition);  "<AssertPlaceHolder>"; }
check(SystemLoginUser loginUser, DataCondition condition) { if (condition == null || loginUser == null) { return false; }  if (loginUser.getUserId() == null || condition.getTargetUserId() == null) { return false; }  Long currentUserId = loginUser.getUserId(); Long targetUserId = condition.getTargetUserId(); return Objects.equals(currentUserId, targetUserId); }
[*] target: assertFalse(check)
[-] pred: org. junit. Assert. assertFalse ( check )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(Long value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } else { String stringValue = Long.toString(value); return TypeCodecs.TEXT.encode(stringValue, protocolVersion); } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testAgentIdsListIsNull() { when(group.getAgentIds()).thenReturn(null); AccessNodeInfo accessNodeInfo = agentGroupUtil.mappingAccessNodeInfo(group, infoMap); Assertions."<AssertPlaceHolder>"; verify(group, times(1)).getAgentIds(); verify(group, times(1)).getGroupId(); verify(group, times(1)).getName(); verify(infoMap, times(0)).get(anyString()); }
mappingAccessNodeInfo(AgentGroupEntity group, Map<String, AccessNodeInfo> infoMap) { List<String> agentIds = group.getAgentIds(); List<AccessNodeInfo> agentInfos = null == agentIds ? new ArrayList<>() : agentIds.stream().map(infoMap::get).filter(Objects::nonNull).collect(Collectors.toList()); AccessNodeInfo item = new AccessNodeInfo(); item.setProcessId(group.getGroupId()); item.setAccessNodeName(group.getName()); item.setAccessNodeType(AccessNodeTypeEnum.MANUALLY_SPECIFIED_BY_THE_USER_AGENT_GROUP.name()); item.setAccessNodes(agentInfos); return item; }
[*] target: assertNotNull(accessNodeInfo)
[-] pred: org. junit. Assert. assertNotNull ( accessNodeInfo )
************************************
************************************
[+] input: testStripQuotesAtStartAndEndSingleQuoteStart() { String input = ""/home/user/file.txt"; String expected = input; String result = PathUtil.stripQuotesAtStartAndEnd(input);  "<AssertPlaceHolder>"; }
stripQuotesAtStartAndEnd(String path) { if (path.startsWith(""") && path.endsWith(""")) { return path.substring(1, path.length() - 1); }  return path; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: of() { ArrayTypeConstructor expected = new ArrayTypeConstructor(new PlaceholderTypeConstructor()); ArrayTypeConstructor toVerify = ArrayTypeConstructor.of(new PlaceholderTypeConstructor());  "<AssertPlaceHolder>"; }
of(TypeConstructor type) { return new ArrayTypeConstructor(type); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testHashCode() { RemoteStorageInfo info = new RemoteStorageInfo(TEST_PATH, confMap); RemoteStorageInfo info1 = new RemoteStorageInfo(TEST_PATH, CONF_STRING); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hashCode(path, confItems); }
[*] target: assertEquals(info.hashCode(), info1.hashCode())
[-] pred: org. junit. Assert. assertEquals ( info. hashCode(), info1. hashCode() )
************************************
************************************
[+] input: MessagingException { doNothing().when(log).error(anyString(), any(Exception.class)); when(mu.connectSMTP(any(Session.class))).thenCallRealMethod(); doCallRealMethod().when(mu).closeTransport(any(Transport.class)); doNothing().when(transport).connect(anyString(), anyInt(), anyString(), anyString()); doNothing().when(mu).initMailConfig(); doNothing().when(transport).close(); Session session = mock(Session.class); InternetAddress[] internetAddressList = new InternetAddress[0]; Address[] addresses = new Address[0];  doAnswer(a -> { throw new IOException(""); }).when(transport).sendMessage(any(MimeMessage.class), any(Address[].class));  doNothing().when(session).setDebug(true); when(session.getTransport("smtp")).thenReturn(transport); try(MockedStatic<Session> s = mockStatic(Session.class); MockedConstruction<InternetAddress> i = mockConstruction(InternetAddress.class, (ic, c) -> {}); MockedConstruction<MimeMessage> m = mockConstruction(MimeMessage.class, (mk,c) -> { doNothing().when(mk).setFrom(any(InternetAddress.class)); doNothing().when(mk).setRecipients(Message.RecipientType.TO, internetAddressList); doNothing().when(mk).setContent(anyString(), anyString()); doNothing().when(mk).setSentDate(any(Date.class)); doNothing().when(mk).saveChanges(); when(mk.getAllRecipients()).thenReturn(addresses); })) { s.when(() -> Session.getDefaultInstance(any(Properties.class))).thenReturn(session); SendStatus sendStatus = mu.sendValidateCodeForResetPWD("", "", ""); Assertions."<AssertPlaceHolder>"; } }
sendValidateCodeForResetPWD(String to, String username, String validateCode) { SendStatus sendStatus = new SendStatus(SEND_STATUS_FALSE, ""); String html = readHtmlToString("resetPasswordTemplate.html"); Document doc = Jsoup.parse(html); doc.getElementById(USER_NAME).html(username); doc.getElementById("code").html(validateCode); doc.getElementById("account").html(to); doc.getElementById("validateTimes").html("5"); sendEmail(doc, sendStatus, Lists.newArrayList(to), "修改密码-验证码", "Send validate code email failed before reset password"); return sendStatus; }
[*] target: assertNotNull(sendStatus)
[-] pred: org. junit. Assert. assertNotNull ( sendStatus )
************************************
************************************
[+] input: testGetClusterInfo() { // Setup final ClusterInfoEntity expectedResult = new ClusterInfoEntity(); expectedResult.setId(0); expectedResult.setCreateBy("createBy"); expectedResult.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); expectedResult.setClusterName("clusterName"); expectedResult.setClusterCode("clusterCode"); expectedResult.setClusterFrame("clusterFrame"); expectedResult.setFrameVersion("frameVersion"); expectedResult.setClusterState(ClusterState.RUNNING); expectedResult.setFrameId(0); final UserInfoEntity userInfoEntity = new UserInfoEntity(); userInfoEntity.setId(0); userInfoEntity.setUsername("username"); userInfoEntity.setPassword("password"); userInfoEntity.setEmail("email"); userInfoEntity.setPhone("phone"); expectedResult.setClusterManagerList(Arrays.asList(userInfoEntity));  // Run the test final ClusterInfoEntity result = ProcessUtils.getClusterInfo(0);  // Verify the results "<AssertPlaceHolder>"; }
getClusterInfo(Integer clusterId) { ClusterInfoService clusterInfoService = SpringTool.getApplicationContext().getBean(ClusterInfoService.class); return clusterInfoService.getById(clusterId); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: shouldParseTime() { try (MockedStatic<Environment> mockedEnvironment = mockStatic(Environment.class)) { mockedEnvironment.when(Environment::getCurrent).thenReturn(env); when(env.getWebforjHelper()).thenReturn(bridge);  String input = "9pm"; String mask = "%Hz:%Mz:%S"; Locale locale = Locale.US; LocalTime expected = LocalTime.of(21, 0, 0); double hms = new HoursLocalTimeTransformer().transformToComponent(expected);  when(bridge.parseTime(input, mask, locale)).thenReturn(hms);  LocalTime result = MaskDecorator.parseTime(input, mask, locale);  "<AssertPlaceHolder>"; } }
parseTime(String input, String mask, Locale locale) { Objects.requireNonNull(input, INPUT_CANNOT_BE_NULL); Objects.requireNonNull(mask, MASK_CANNOT_BE_NULL);  Environment env = Environment.getCurrent(); double hms = env.getWebforjHelper().parseTime(input, mask, locale == null ? App.getLocale() : locale); HoursLocalTimeTransformer transformer = new HoursLocalTimeTransformer();  return transformer.transformToModel(hms); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: of() { ClassName expected = new ClassName("String"); ClassName toVerify = ClassName.of("String");  "<AssertPlaceHolder>"; }
of(String className) { return new ClassName(className); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(String value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } else { long longValue = Long.parseLong(value); return TypeCodecs.BIGINT.encode(longValue, protocolVersion); } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testNullList() { final List<Object> list = new ArrayList<>(); list.add(null); String expectedName = "java.util.ArrayList-"; final String actualName = TypeUtil.getName(list); "<AssertPlaceHolder>"; }
getName(Object result) { if (result == null) { return null; }  if (result instanceof Map) { return mapToString((Map<?, ?>) result); }  // Optional GSON if (result instanceof Optional) { return optionalToString((Optional<?>) result); }  if (result instanceof Collection<?>) { return collectionToString((Collection<?>) result); }  if (result instanceof ParameterizedType) { return parameterizedTypeToString((ParameterizedType) result); }  if (result instanceof Class) { return ((Class<?>) result).getTypeName(); }  if (isGenericType(result)) { return genericTypeToString(result); }  return result.getClass().getName(); }
[*] target: assertEquals(expectedName, actualName)
[-] pred: org. junit. Assert. assertEquals ( expectedName, actualName )
************************************
************************************
[+] input: IOException { OkHttpClient client = createHttpClient(Boolean.TRUE, Boolean.TRUE, Integer.valueOf(5)); "<AssertPlaceHolder>"; }
createHttpClient(Boolean useInternalTestProxy, Boolean ignoreSslErrors, Integer timeout) throws IOException { OkHttpClient client; OkHttpClient.Builder newBuilder = new OkHttpClient.Builder();  if (isTrue(ignoreSslErrors) || isTrue(useInternalTestProxy)) { TrustManager[] trustAllCerts = new TrustManager[]{ new X509TrustManager() { @Override public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) { // we want to ignore the server certificate on purpose, as self-signed certificates are used by some users }  @Override public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) { // we want to ignore the server certificate on purpose, as self-signed certificates are used by some users }   @Override public java.security.cert.X509Certificate[] getAcceptedIssuers() { return new java.security.cert.X509Certificate[]{}; } } }; SSLContext sslContext; try { sslContext = SSLContext.getInstance("TLSv1.2"); sslContext.init(null, trustAllCerts, new java.security.SecureRandom()); newBuilder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustAllCerts[0]); newBuilder.hostnameVerifier((host, session) -> true); } catch (KeyManagementException | NoSuchAlgorithmException e) { throw new IOException("problem setting up SSL http client configuration"); } }  if (isTrue(useInternalTestProxy)) { String hostname = "localhost"/*127.0.0.1*/; int port = 18080; Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(hostname, port)); client = newBuilder .connectTimeout(timeout, TimeUnit.SECONDS) .readTimeout(timeout, TimeUnit.SECONDS) .writeTimeout(timeout, TimeUnit.SECONDS) .callTimeout(timeout, TimeUnit.SECONDS) .proxy(proxy) .build(); } else { client = newBuilder .connectTimeout(timeout, TimeUnit.SECONDS) .readTimeout(timeout, TimeUnit.SECONDS) .writeTimeout(timeout, TimeUnit.SECONDS) .callTimeout(timeout, TimeUnit.SECONDS) .build(); } return client; }
[*] target: assertNotNull(client)
[-] pred: org. junit. Assert. assertNotNull ( client )
************************************
************************************
[+] input: updateUser() { UserAO userAo = new UserAO(); userAo.setUserName("juggle"); userAo.setPassword("juggle"); Mockito.doNothing().when(userRepository).updateUser(userAo); Boolean updateFlag = userService.updateUser(userAo); Assertions."<AssertPlaceHolder>"; }
updateUser(UserAO userAo) { userRepository.updateUser(userAo); return true; }
[*] target: assertEquals(true,updateFlag)
[-] pred: org. junit. Assert. assertEquals ( true, updateFlag )
************************************
************************************
[+] input: testNull() { String result = MessageFormatter.format(null, 1).getMessage(); "<AssertPlaceHolder>"; }
format(String messagePattern, Object arg) { return arrayFormat(messagePattern, new Object[]{arg}); }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: xssf1() { WorkbookParameter workbookParameter = WorkbookParameter.builder().build(); Assertions."<AssertPlaceHolder>"; }
isXssf() { return xssf == null || xssf; }
[*] target: assertTrue(workbookParameter.isXssf())
[-] pred: org. junit. Assert. assertTrue ( workbookParameter. isXssf() )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismTwoNodeAndAllNodeAreDataParentNodeButDataTypeNotEquals() { when(nodeList.size()).thenReturn(2); DataParentNode node1 = mock(DataParentNode.class); when(node1.getDatabaseType()).thenReturn("mock-type-cache"); when(nodeList.get(0)).thenReturn(node1);  DataParentNode node2 = mock(DataParentNode.class); when(node2.getDatabaseType()).thenReturn("mock-type"); when(nodeList.get(1)).thenReturn(node2); boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(1)).get(0); verify(nodeList, times(1)).get(1); verify(node2, times(1)).getDatabaseType(); verify(node2, times(1)).getDatabaseType(); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertFalse(isomorphism)
[-] pred: org. junit. Assert. assertFalse ( isomorphism )
************************************
************************************
[+] input: LocationNotFoundException { // Mock data long id = 1L; MonitoringLocationDTO monitoringLocationDTO = MonitoringLocationDTO.newBuilder() .setId(id) .setTenantId(TENANT_ID) .build(); MonitoringLocation monitoringLocation = new MonitoringLocation(); monitoringLocation.setId(id); monitoringLocation.setTenantId(TENANT_ID); when(mapper.dtoToModel(any(MonitoringLocationDTO.class))).thenReturn(monitoringLocation); when(modelRepo.findByIdAndTenantId(id, TENANT_ID)).thenReturn(Optional.of(monitoringLocation)); when(modelRepo.save(monitoringLocation)).thenReturn(monitoringLocation); when(mapper.modelToDTO(any(MonitoringLocation.class))).thenReturn(monitoringLocationDTO);  // Test MonitoringLocationDTO result = monitoringLocationService.upsert(monitoringLocationDTO);  // Assertions "<AssertPlaceHolder>"; verify(mapper, times(1)).dtoToModel(any(MonitoringLocationDTO.class)); verify(modelRepo, times(1)).save(monitoringLocation); verify(mapper, times(1)).modelToDTO(any(MonitoringLocation.class)); }
upsert(MonitoringLocationDTO dto) throws LocationNotFoundException { if (dto.hasField(MonitoringLocationDTO.getDescriptor().findFieldByNumber(MonitoringLocationDTO.ID_FIELD_NUMBER)) && modelRepo.findByIdAndTenantId(dto.getId(), dto.getTenantId()).isEmpty()) { throw new LocationNotFoundException("Location not found with ID " + dto.getId()); } if (dto.hasField( MonitoringLocationDTO.getDescriptor().findFieldByNumber(MonitoringLocationDTO.LOCATION_FIELD_NUMBER))) { if (StringUtils.isBlank(dto.getLocation())) { throw new InventoryRuntimeException("Location is Blank"); } var location = modelRepo.findByLocationAndTenantId(dto.getLocation().trim(), dto.getTenantId()); if (location.isPresent() && location.get().getId() != dto.getId()) { throw new InventoryRuntimeException("Duplicate Location found with name " + dto.getLocation()); } }  MonitoringLocation model = mapper.dtoToModel(dto); return mapper.modelToDTO(modelRepo.save(model)); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: ParseException { SchedJob job = new SchedJob(); job.setJobId(idGenerator.generateId()); job.setGroup("default"); job.setJobName(RandomStringUtils.randomAlphanumeric(5)); job.setJobExecutor("cn.ponfee.disjob.test.executor.NoopJobExecutor"); job.setJobState(JobState.DISABLED.value());  job.setJobParam(""); job.setJobType(JobType.GENERAL.value());  job.setRetryType(RetryType.NONE.value()); job.setRetryCount(0); job.setRetryInterval(0); job.setStartTime(null); job.setEndTime(null); job.setTriggerType(TriggerType.ONCE.value());  String date = "2022-06-16 11:37:00"; job.setTriggerValue(date); job.setNextTriggerTime(JavaUtilDateFormat.DEFAULT.parse(date).getTime()); job.setExecuteTimeout(3600000); job.setMisfireStrategy(MisfireStrategy.LAST.value()); job.setCollidedStrategy(CollidedStrategy.CONCURRENT.value()); job.setRouteStrategy(RouteStrategy.ROUND_ROBIN.value()); job.setRedeployStrategy(RedeployStrategy.RESUME.value()); job.setRemark("test remark"); job.setLastTriggerTime(null); job.setNextTriggerTime(TriggerTimeUtils.computeNextTriggerTime(job, new Date())); job.setUpdatedBy("0"); job.setCreatedBy("0"); job.setUpdatedAt(new Date()); job.setCreatedAt(new Date());  int insert = bean.insert(job); Assertions."<AssertPlaceHolder>"; }
insert(SchedJob job);
[*] target: assertEquals(1, insert)
[-] pred: org. junit. Assert. assertEquals ( 1, insert )
************************************
************************************
[+] input: testLoadFromBytesErrorNoList() { var loader = new ImageIOLoader();  var image_bytes = new byte[]{2, 9, 7, 12, 45}; // just random values var image = loader.loadFromBytes(image_bytes, null);  "<AssertPlaceHolder>"; }
loadFromBytes(byte[] data, Set<String> errors) throws ContentManagerException { var input = new ByteArrayInputStream(data); Image image; MimeType mime_type = null;  try { var stream = ImageIO.createImageInputStream(input); if (stream == null) { throw new IIOException("Can't create an ImageInputStream"); }  var iter = ImageIO.getImageReaders(stream); if (!iter.hasNext()) { return null; }  var reader = iter.next();  // detect if any of the reader mimetypes corresponds to a CMF supported one var reader_mime_types = reader.getOriginatingProvider().getMIMETypes(); if (reader_mime_types != null) { for (var reader_mime : reader_mime_types) { mime_type = MimeType.getMimeType(reader_mime); if (mime_type != null) { break; } } }  // create an awt image var param = reader.getDefaultReadParam(); reader.setInput(stream, true, true); try { image = reader.read(0, param); } finally { reader.dispose(); stream.close(); }  if (image == null) { stream.close(); }  // wait until the image is fully loaded ImageWaiter.wait(image); } catch (Throwable e) { if (errors != null) { errors.add(ExceptionUtils.getExceptionStackTrace(e)); }  image = null; }  return new LoadedContent<>(mime_type, image); }
[*] target: assertNull(image)
[-] pred: org. junit. Assert. assertNull ( image )
************************************
************************************
[+] input: shouldTurnUpVolume() { //given //when this.tv.turnUpVolume(); this.tv.turnUpVolume(); this.tv.turnUpVolume(); int actual = this.tv.getVolume(); //then int expected = 8; Assertions."<AssertPlaceHolder>"; }
getVolume() { return volume; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldDepositValue() { //given BigDecimal valueToDeposit = BigDecimal.TEN; //when bankAccount.toDeposit(valueToDeposit); BigDecimal actual = bankAccount.getBalance(); //then BigDecimal expected = BigDecimal.TEN; Assertions."<AssertPlaceHolder>"; }
getBalance() { return balance; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testInsert1() { SchedJob job = new SchedJob(); job.setJobId(idGenerator.generateId()); job.setGroup("default"); job.setJobName("test"); job.setJobExecutor("cn.ponfee.disjob.test.executor.NoopJobExecutor"); job.setJobState(JobState.DISABLED.value()); job.setJobType(JobType.GENERAL.value()); job.setJobParam("test param"); job.setRetryType(RetryType.NONE.value()); job.setRetryCount(0); job.setRetryInterval(0); job.setStartTime(null); job.setEndTime(null); job.setTriggerType(TriggerType.CRON.value()); job.setTriggerValue("0/10 * * * * ?"); job.setExecuteTimeout(3600000); job.setCollidedStrategy(CollidedStrategy.CONCURRENT.value()); job.setMisfireStrategy(MisfireStrategy.DISCARD.value()); job.setRouteStrategy(RouteStrategy.ROUND_ROBIN.value()); job.setRedeployStrategy(RedeployStrategy.RESUME.value()); job.setRemark("test remark"); job.setLastTriggerTime(null); job.setNextTriggerTime(TriggerTimeUtils.computeNextTriggerTime(job, new Date())); job.setUpdatedBy("0"); job.setCreatedBy("0"); job.setUpdatedAt(new Date()); job.setCreatedAt(new Date());  int insert = bean.insert(job); Assertions."<AssertPlaceHolder>"; }
insert(SchedJob job);
[*] target: assertEquals(1, insert)
[-] pred: org. junit. Assert. assertEquals ( 1, insert )
************************************
************************************
[+] input: shouldLetterIsCorGReturnTrue() { boolean actual = Properties.letterIsCorG('c'); "<AssertPlaceHolder>"; }
letterIsCorG(char aLetter) { return (aLetter == 'c') || (aLetter == 'g'); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: IOException { OkHttpClient client = createHttpClient(Boolean.FALSE, Boolean.TRUE, Integer.valueOf(5)); "<AssertPlaceHolder>"; }
createHttpClient(Boolean useInternalTestProxy, Boolean ignoreSslErrors, Integer timeout) throws IOException { OkHttpClient client; OkHttpClient.Builder newBuilder = new OkHttpClient.Builder();  if (isTrue(ignoreSslErrors) || isTrue(useInternalTestProxy)) { TrustManager[] trustAllCerts = new TrustManager[]{ new X509TrustManager() { @Override public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) { // we want to ignore the server certificate on purpose, as self-signed certificates are used by some users }  @Override public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) { // we want to ignore the server certificate on purpose, as self-signed certificates are used by some users }   @Override public java.security.cert.X509Certificate[] getAcceptedIssuers() { return new java.security.cert.X509Certificate[]{}; } } }; SSLContext sslContext; try { sslContext = SSLContext.getInstance("TLSv1.2"); sslContext.init(null, trustAllCerts, new java.security.SecureRandom()); newBuilder.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustAllCerts[0]); newBuilder.hostnameVerifier((host, session) -> true); } catch (KeyManagementException | NoSuchAlgorithmException e) { throw new IOException("problem setting up SSL http client configuration"); } }  if (isTrue(useInternalTestProxy)) { String hostname = "localhost"/*127.0.0.1*/; int port = 18080; Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(hostname, port)); client = newBuilder .connectTimeout(timeout, TimeUnit.SECONDS) .readTimeout(timeout, TimeUnit.SECONDS) .writeTimeout(timeout, TimeUnit.SECONDS) .callTimeout(timeout, TimeUnit.SECONDS) .proxy(proxy) .build(); } else { client = newBuilder .connectTimeout(timeout, TimeUnit.SECONDS) .readTimeout(timeout, TimeUnit.SECONDS) .writeTimeout(timeout, TimeUnit.SECONDS) .callTimeout(timeout, TimeUnit.SECONDS) .build(); } return client; }
[*] target: assertNotNull(client)
[-] pred: org. junit. Assert. assertNotNull ( client )
************************************
************************************
[+] input: 좋아요_숫자가_0보다_클때만_감소_기능_동작() { discussion.updateLikeCount(false); int actual = discussion.getLikeCount();  "<AssertPlaceHolder>"; }
updateLikeCount(Boolean flag) { if (flag) { this.likeCount += 1; } else if (likeCount > 0) { this.likeCount -= 1; } }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: whenTaskDtoIsNull() { try (MockedStatic<BeanUtil> beanUtilMockedStatic = mockStatic(BeanUtil.class)) { String taskId = "testTaskId"; String nodeId = "testNodeId"; when(clientMongoOperator.findOne(any(Query.class), anyString(), eq(TaskDto.class))).thenReturn(null); beanUtilMockedStatic.when(() -> BeanUtil.getBean(ClientMongoOperator.class)).thenReturn(clientMongoOperator);  try (MockedStatic<CleanResult> cleanResultMockedStatic = mockStatic(CleanResult.class)) { CleanResult success = CleanResult.success(); cleanResultMockedStatic.when(CleanResult::success).thenReturn(success);  CleanResult result = mergeNodeCleaner.cleanTaskNode(taskId, nodeId); "<AssertPlaceHolder>"; } verify(clientMongoOperator, times(1)).findOne(any(Query.class), anyString(), eq(TaskDto.class)); } }
cleanTaskNode(String taskId, String nodeId) { TaskDto taskDto = findTaskById(taskId); if (null == taskDto) { return CleanResult.success(); } DAG dag = taskDto.getDag(); List<MergeTableNode> mergeTableNodes; if (StringUtils.isBlank(nodeId)) { List<Node> nodes = dag.getNodes(); mergeTableNodes = findNodes(nodes, MergeTableNode.class); } else { MergeTableNode mergeTableNode = getMergeTableNode(dag, nodeId); if (null == mergeTableNode) { return CleanResult.success(); } mergeTableNodes = new LinkedList<>(); mergeTableNodes.add(mergeTableNode); }  cleanTaskNodeByAppType(mergeTableNodes, dag);  return CleanResult.success(); }
[*] target: assertEquals(success, result)
[-] pred: org. junit. Assert. assertEquals ( success, result )
************************************
************************************
[+] input: shouldGetSelectedIndex() { MultipleSelectableComponentMock component = new MultipleSelectableComponentMock(); component.selectIndex(1); Map<String, Object> eventMap = new HashMap<>(); eventMap.put("index", 1); SelectEventMock<MultipleSelectableComponentMock, String> event = new SelectEventMock<>(component, eventMap);  "<AssertPlaceHolder>"; }
getSelectedIndex() { Object selectedIndex = getEventMap().get("index"); if (selectedIndex == null) { return -1; }  return Integer.parseInt(String.valueOf(selectedIndex)); }
[*] target: assertEquals(1, event.getSelectedIndex())
[-] pred: org. junit. Assert. assertEquals ( 1, event. getSelectedIndex() )
************************************
************************************
[+] input: testSkipNotManualCreateSourceInField() { when(field.getCreateSource()).thenReturn(Field.SOURCE_JOB_ANALYZE); boolean skip = skipDetector.skip(field); Assertions."<AssertPlaceHolder>"; verify(field, times(0)).getCreateSource(); }
skip(TapField field) { return false; //是否同构，不是同构就就返回false继续执行codec, 是同构就继续下面的判断 //        if (!isomorphism) return false; //是同构，如果这个字段是手动修改改过表结构的结果就返回false需要走codec, 否则不走codec //        return !(null != field && null != field.getCreateSource() && Field.SOURCE_MANUAL.equalsIgnoreCase(field.getCreateSource())); }
[*] target: assertFalse(skip)
[-] pred: org. junit. Assert. assertFalse ( skip )
************************************
************************************
[+] input: testOfferWhenTryEmitReturnTrue() { when(mockHazelcastBaseNode.tryEmit(tapdataEvent, 1)).thenReturn(true); boolean actual = mockHazelcastBaseNode.offer(tapdataEvent); "<AssertPlaceHolder>"; }
offer(TapdataEvent dataEvent) { if (dataEvent != null) { if (processorBaseContext.getNode() != null) { dataEvent.addNodeId(processorBaseContext.getNode().getId()); } Outbox outbox = getOutboxAndCheckNullable(); int bucketCount = outbox.bucketCount(); if (!tryEmit(dataEvent, bucketCount)) return false; } bucketIndex = 0; // reset to 0 of return true return true; }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: getEnvName_NoEnvNameFound() { Mockito.when(manageDatabase.getKafkaEnvList(anyInt())).thenReturn(List.of()); String actual = analyticsControllerService.getEnvName(TestConstants.ENV_ID);  "<AssertPlaceHolder>"; }
getEnvName(String envId) { Optional<Env> envFound = manageDatabase .getKafkaEnvList(commonUtilsService.getTenantId(getCurrentUserName())) .stream() .filter(env -> Objects.equals(env.getId(), envId)) .findFirst(); return envFound.map(Env::getName).orElse(null); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: testCheckServiceDependency_ClusterServiceInstanceServiceReturnsNoItems() { // Setup final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  when(mockServiceInstanceService.listRunningServiceInstance(0)).thenReturn(Collections.emptyList());  // Configure FrameServiceService.listServices(...). final FrameServiceEntity frameServiceEntity = new FrameServiceEntity(); frameServiceEntity.setId(0); frameServiceEntity.setFrameId(0); frameServiceEntity.setServiceName("serviceName"); frameServiceEntity.setLabel("label"); frameServiceEntity.setServiceVersion("serviceVersion"); frameServiceEntity.setServiceDesc("serviceDesc"); frameServiceEntity.setPackageName("packageName"); frameServiceEntity.setDependencies("dependencies"); frameServiceEntity.setServiceJson("serviceJson"); frameServiceEntity.setServiceJsonMd5("serviceJsonMd5"); frameServiceEntity.setServiceConfig("serviceConfig"); frameServiceEntity.setFrameCode("frameCode"); frameServiceEntity.setConfigFileJson("configFileJson"); frameServiceEntity.setConfigFileJsonMd5("configFileJsonMd5"); frameServiceEntity.setSortNum(0); final List<FrameServiceEntity> frameServiceEntities = Arrays.asList(frameServiceEntity); when(mockFrameService.listServices("serviceIds")).thenReturn(frameServiceEntities);  // Run the test final Result result = serviceInstallServiceImplUnderTest.checkServiceDependency(0, "serviceIds");  // Verify the results "<AssertPlaceHolder>"; }
checkServiceDependency(Integer clusterId, String serviceIds) { // List<ClusterServiceInstanceEntity> serviceInstanceList = serviceInstanceService.listRunningServiceInstance(clusterId); Map<String, ClusterServiceInstanceEntity> instanceMap = serviceInstanceList.stream() .collect( Collectors.toMap( ClusterServiceInstanceEntity::getServiceName, e -> e, (v1, v2) -> v1));  List<FrameServiceEntity> list = frameService.listServices(serviceIds); Map<String, FrameServiceEntity> serviceMap = list.stream() .collect( Collectors.toMap( FrameServiceEntity::getServiceName, e -> e, (v1, v2) -> v1)); if (!instanceMap.containsKey("ALERTMANAGER") && !serviceMap.containsKey("ALERTMANAGER")) { return Result.error( "service install depends on alertmanager ,please make sure you have selected it or that alertmanager is normal and running"); } if (!instanceMap.containsKey("GRAFANA") && !serviceMap.containsKey("GRAFANA")) { return Result.error( "service install depends on grafana ,please make sure you have selected it or that grafana is normal and running"); } if (!instanceMap.containsKey("PROMETHEUS") && !serviceMap.containsKey("PROMETHEUS")) { return Result.error( "service install depends on prometheus ,please make sure you have selected it or that prometheus is normal and running"); }  for (FrameServiceEntity frameServiceEntity : list) { for (String dependService : frameServiceEntity.getDependencies().split(",")) { if (StringUtils.isNotBlank(dependService) && !instanceMap.containsKey(dependService) && !serviceMap.containsKey(dependService)) { return Result.error( "" + frameServiceEntity.getServiceName() + " install depends on " + dependService + ",please make sure that you have selected it or that " + dependService + " is normal and running"); } } } return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: encode_ShouldReturnNull_WhenValueIsNull() { ByteBuffer result = codec.encode(null, CqlConversion.PROTOCOL_VERSION); Assertions."<AssertPlaceHolder>"; }
encode(Instant value, @NotNull ProtocolVersion protocolVersion) { if (value == null) { return null; } else { String stringValue = String.valueOf(value.toEpochMilli()); return TypeCodecs.TEXT.encode(stringValue, protocolVersion); } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testSha1() { Component component = new Component(); String hash = "74f7fcc24e02e61b0eb367e273139b6b24c6587f"; component.setSha1(hash); Assertions."<AssertPlaceHolder>"; }
getSha1() { return sha1; }
[*] target: assertEquals(hash, component.getSha1())
[-] pred: org. junit. Assert. assertEquals ( hash, component. getSha1() )
************************************
************************************
[+] input: givenArrayType() { Type type = OBJECT.array(); String toVerify = type(type).generate(); String expected = "java.lang.Object[]"; "<AssertPlaceHolder>"; }
generate() { return type.match( generic -> generic.getName().raw(),  concrete -> { List<TypeArgument> typeArguments = concrete.getTypeArguments(); if (typeArguments.isEmpty()) { return concrete.getFullyQualifiedName().raw(); } else { return concrete.getFullyQualifiedName().raw() + OPEN_ANGULAR_BRACKET + typeArguments.stream().map(TypeArgumentGenerator::generateFrom).collect(joining(SEPARATOR)) + CLOSE_ANGULAR_BRACKET; } },  array -> type(array.getType()).generate() + OPEN_SQUARE_BRACKET + CLOSE_SQUARE_BRACKET ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testInitLoader() { ExtensionLoader<DemoExtension> extensionLoader = ExtensionLoader.getExtensionLoader(DemoExtension.class); Assertions."<AssertPlaceHolder>"; }
getExtensionLoader(Class<T> type) { if (type == null) { throw new IllegalArgumentException("Extension type == null"); }  if (!type.isInterface()) { throw new IllegalArgumentException("Extension type (" + type + ") is not an interface!"); }  if (!withExtensionAnnotation(type)) { throw new IllegalArgumentException( "Extension type (" + type + ") is not an extension, because it is not annotated with @" + SPI.class.getSimpleName() + "!"); }  ExtensionLoader<T> loader = (ExtensionLoader)EXTENSION_LOADERS.get(type); if (loader == null) { EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader(type)); loader = (ExtensionLoader)EXTENSION_LOADERS.get(type); }  return loader; }
[*] target: assertNotNull(extensionLoader)
[-] pred: org. junit. Assert. assertNotNull ( extensionLoader )
************************************
************************************
[+] input: testOnChannelActive() {  RemotingClient remotingClient = mock(RemotingClient.class); ReflectionTestUtils.setField(collectServer, "remotingClient", remotingClient);  Channel channel = mock(Channel.class); when(collectJobService.getCollectorIdentity()).thenReturn("collector1"); when(collectJobService.getCollectorMode()).thenReturn("mode1"); when(infoProperties.getIp()).thenReturn("127.0.0.1"); when(infoProperties.getVersion()).thenReturn("1.0");  collectNettyEventListener.onChannelActive(channel);  verify(timerDispatch, times(1)).goOnline(); verify(remotingClient, times(1)).sendMsg(any(ClusterMsg.Message.class));  ScheduledExecutorService scheduledExecutor = (ScheduledExecutorService) ReflectionTestUtils.getField(collectServer, "scheduledExecutor"); "<AssertPlaceHolder>"; }
sendMsg(final ClusterMsg.Message message) { this.remotingClient.sendMsg(message); }
[*] target: assertNotNull(scheduledExecutor)
[-] pred: org. junit. Assert. assertNotNull ( scheduledExecutor )
************************************
************************************
[+] input: versionMatch() { ElementMatcher.Junction<ClassLoader> matcher = ModuleVersionMatcher.versionMatch( ModuleDescription.builder().build()); "<AssertPlaceHolder>"; }
versionMatch(ModuleDescription description) { return new IgnoreClassloaderMatcher(new ModuleVersionMatcher(description)); }
[*] target: assertNotNull(matcher)
[-] pred: org. junit. Assert. assertNotNull ( matcher )
************************************
************************************
[+] input: InterruptedException { for (var entityType : SUPPORTED_ENTITY_TYPES) { var entityId = EntityIdFactory.getByTypeAndUuid(entityType, RANDOM_UUID);  initMocks(entityType, false);  when(ctxMock.getTenantId()).thenReturn(TENANT_ID);  var actualEntityFieldsData = EntitiesFieldsAsyncLoader.findAsync(ctxMock, entityId).get(); var expectedEntityFieldsData = new EntityFieldsData(getEntityFromEntityId(entityId));  Assertions."<AssertPlaceHolder>"; } }
findAsync(TbContext ctx, EntityId originatorId) { switch (originatorId.getEntityType()) {  // TODO: use EntityServiceRegistry case TENANT: return toEntityFieldsDataAsync(ctx.getTenantService().findTenantByIdAsync(ctx.getTenantId(), (TenantId) originatorId), EntityFieldsData::new, ctx); case CUSTOMER: return toEntityFieldsDataAsync(ctx.getCustomerService().findCustomerByIdAsync(ctx.getTenantId(), (CustomerId) originatorId), EntityFieldsData::new, ctx); case USER: return toEntityFieldsDataAsync(ctx.getUserService().findUserByIdAsync(ctx.getTenantId(), (UserId) originatorId), EntityFieldsData::new, ctx); case ASSET: return toEntityFieldsDataAsync(ctx.getAssetService().findAssetByIdAsync(ctx.getTenantId(), (AssetId) originatorId), EntityFieldsData::new, ctx); case DEVICE: return toEntityFieldsDataAsync(Futures.immediateFuture(ctx.getDeviceService().findDeviceById(ctx.getTenantId(), (DeviceId) originatorId)), EntityFieldsData::new, ctx); case ALARM: return toEntityFieldsDataAsync(ctx.getAlarmService().findAlarmByIdAsync(ctx.getTenantId(), (AlarmId) originatorId), EntityFieldsData::new, ctx); case RULE_CHAIN: return toEntityFieldsDataAsync(ctx.getRuleChainService().findRuleChainByIdAsync(ctx.getTenantId(), (RuleChainId) originatorId), EntityFieldsData::new, ctx); case ENTITY_VIEW: return toEntityFieldsDataAsync(ctx.getEntityViewService().findEntityViewByIdAsync(ctx.getTenantId(), (EntityViewId) originatorId), EntityFieldsData::new, ctx); case EDGE: return toEntityFieldsDataAsync(ctx.getEdgeService().findEdgeByIdAsync(ctx.getTenantId(), (EdgeId) originatorId), EntityFieldsData::new, ctx); default: return Futures.immediateFailedFuture(new TbNodeException("Unexpected originator EntityType: " + originatorId.getEntityType())); } }
[*] target: assertEquals(expectedEntityFieldsData, actualEntityFieldsData)
[-] pred: org. junit. Assert. assertEquals ( expectedEntityFieldsData, actualEntityFieldsData )
************************************
************************************
[+] input: testConcatToFileEmpty() { File file = utils.concatToFile("mock-path", new String[]{}); Assertions."<AssertPlaceHolder>"; }
concatToFile(String path, String ...paths) { return new File(concat(path, paths)); }
[*] target: assertNotNull(file)
[-] pred: org. junit. Assert. assertNotNull ( file )
************************************
************************************
[+] input: testGetCallerClassLoader() { ClassLoader classLoader = getCallerClassLoader(); "<AssertPlaceHolder>"; }
getCallerClassLoader() { return getCallerClassLoader(4); }
[*] target: assertNotNull(classLoader)
[-] pred: org. junit. Assert. assertNotNull ( classLoader )
************************************
************************************
[+] input: testGetTaskDtoIsomorphismNormal() { DataParentNode node1 = mock(DataParentNode.class); when(node1.getDatabaseType()).thenReturn("mock-type"); when(nodeList.get(0)).thenReturn(node1);  DataParentNode node2 = mock(DataParentNode.class); when(node2.getDatabaseType()).thenReturn("mock-type"); when(nodeList.get(1)).thenReturn(node2);  boolean isomorphism = dag.getTaskDtoIsomorphism(nodeList); Assertions."<AssertPlaceHolder>"; verify(nodeList, times(1)).size(); verify(nodeList, times(1)).get(0); verify(nodeList, times(1)).get(1);  verify(node1, times(1)).getDatabaseType(); verify(node2, times(1)).getDatabaseType(); }
getTaskDtoIsomorphism(List<Node> nodes) { if (null == nodes || nodes.size() != 2) { return false; } Node node1 = nodes.get(0); if (!(node1 instanceof DataParentNode)) return false; Node node2 = nodes.get(1); if (!(node2 instanceof DataParentNode)) return false; DataParentNode dataParentNode1 = (DataParentNode)node1; DataParentNode dataParentNode2 = (DataParentNode)node2; String databaseType = String.valueOf(dataParentNode1.getDatabaseType()); return databaseType.equals(dataParentNode2.getDatabaseType()); }
[*] target: assertTrue(isomorphism)
[-] pred: org. junit. Assert. assertTrue ( isomorphism )
************************************
************************************
[+] input: testEmpty() { when(webHookController.failed("webhook.reOpen.failed")).thenReturn(mock(ResponseMessage.class)); List mock = mock(List.class); when(mock.isEmpty()).thenReturn(true); when(webHookService.reOpen(any(String[].class), any(UserDetail.class))).thenReturn(mock); when(webHookController.reOpenOne("id")).thenCallRealMethod(); ResponseMessage<WebHookInfoVo> hook = webHookController.reOpenOne("id"); Assertions."<AssertPlaceHolder>"; verify(webHookController).failed("webhook.reOpen.failed"); verify(webHookService).reOpen(any(String[].class), any(UserDetail.class)); }
reOpenOne(@PathVariable(value = "id") String hookId) { List<WebHookInfoVo> closed = webHookService.reOpen(new String[]{hookId}, getLoginUser()); if (closed.isEmpty()) { return failed("webhook.reOpen.failed"); } return success(closed.get(0)); }
[*] target: assertNotNull(hook)
[-] pred: org. junit. Assert. assertNotNull ( hook )
************************************
************************************
[+] input: cptecListarLocalidadesPass() { CPTECCidade[] cptecCidade = BrasilAPI.cptecListarLocalidades(); "<AssertPlaceHolder>"; }
cptecListarLocalidades() { CPTEC[] obj = (CPTEC[]) api(CPTEC[].class, "cptec/v1/cidade", ""); return obj != null ? (CPTEC[]) obj.clone() : null; }
[*] target: assertNotNull(cptecCidade)
[-] pred: org. junit. Assert. assertNotNull ( cptecCidade )
************************************
************************************
[+] input: getInstance() { SparkConf sc = new SparkConf(); PropertyHelper helper = PropertyHelper.getInstance(sc); "<AssertPlaceHolder>"; }
getInstance(SparkConf sc) { instance = getInstance(); instance.initializeSparkConf(sc); return instance; }
[*] target: assertNotNull(helper)
[-] pred: org. junit. Assert. assertNotNull ( helper )
************************************
************************************
[+] input: test_nullLimitlessRouterMonitor() { final LimitlessRouterService limitlessRouterService = new LimitlessRouterServiceImpl((a, b, c, d) -> null); final List<HostSpec> actualEndpointHostSpecList = limitlessRouterService.getLimitlessRouters(OTHER_CLUSTER_ID, props); "<AssertPlaceHolder>"; }
getLimitlessRouters(final String clusterId, final Properties props) { final long cacheExpirationNano = TimeUnit.MILLISECONDS.toNanos( MONITOR_DISPOSAL_TIME_MS.getLong(props));  final LimitlessRouterMonitor limitlessRouterMonitor = limitlessRouterMonitors.get(clusterId, cacheExpirationNano); if (limitlessRouterMonitor == null) { return Collections.EMPTY_LIST; } return limitlessRouterMonitor.getLimitlessRouters(); }
[*] target: assertEquals(0, actualEndpointHostSpecList.size())
[-] pred: org. junit. Assert. assertEquals ( 0, actualEndpointHostSpecList. size ( ) )
************************************
************************************
[+] input: testLaneSetLayout() {  UISchemaBuilder builder = new UISchemaBuilder(Layout.CATEGORIZATION);  Map<String, Object> arrayDetailOption = new HashMap<>();  // detail : 'GENERATED' // arrayDetailOption.put("detail", "GENERATED");  //        "type": "HorizontalLayout", //        "elements": [ //            { //                "type": "Control", //                "scope": "#/properties/name" //            }, //            { //                "type": "Control", //                "scope": "#/properties/documentation", //                "label": "Documentation", //                "options": { //                    "multi": true //                } //            } //        ]  JsonObjectBuilder layoutBuilder = Json.createObjectBuilder().add("type", "HorizontalLayout"); JsonArrayBuilder controlsArrayBuilder = Json.createArrayBuilder();  JsonObject multiOptions = Json.createObjectBuilder() // .add("multi", true).build();  controlsArrayBuilder // .add(Json.createObjectBuilder() // .add("type", "Control") // .add("scope", "#/properties/name"))// .add(Json.createObjectBuilder() // .add("type", "Control") // .add("scope", "#/properties/documentation") // .add("label", "Documentation") // .add("options", multiOptions) // ); layoutBuilder.add("elements", controlsArrayBuilder); JsonObjectBuilder detailBuilder = Json.createObjectBuilder(). // add("detail", layoutBuilder.build());  builder.addCategory("Lanes") // .addLayout(Layout.VERTICAL);  builder.addDetailLayout("lanes", "Lanes", detailBuilder.build());  String json = builder.build();  "<AssertPlaceHolder>";  logger.info(json); }
build() {  // close current controllsBuilder.... if (controlsArrayBuilder != null && layoutContext != null) { layoutContext.add("elements", controlsArrayBuilder.build()); }  if (groupArrayBuilder != null) {  // close current layoutContext.... if (layoutsArrayBuilder != null && layoutContext != null) { this.layoutsArrayBuilder.add(layoutContext.build()); }  // close current gourpContext if (groupContext != null) { groupContext.add("elements", layoutsArrayBuilder.build()); groupArrayBuilder.add(groupContext); }  rootLayoutBuilder.add("elements", groupArrayBuilder.build()); }  // write result JsonObject jsonObject = rootLayoutBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: applyGivenTypeConstructorWithoutPlaceholder() { ConcreteType expected = Type.concrete(ERUDITE, STRING_TYPE.invariant(), BOOLEAN_TYPE.contravariant(), INTEGER_TYPE.covariant()); ConcreteType toVerify = TypeConstructor.concrete(ERUDITE, STRING_TYPE_CONSTRUCTOR.invariant(), BOOLEAN_TYPE_CONSTRUCTOR.contravariant(), INTEGER_TYPE_CONSTRUCTOR.covariant()).apply(BOOLEAN_TYPE);  "<AssertPlaceHolder>"; }
apply(Type toApplyTo) { List<TypeArgument> typeArguments = typeConstructorArguments .stream() .map(typeArgument -> typeArgument.apply(toApplyTo)) .collect(toList());  return Type.concrete(fullyQualifiedName, typeArguments); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: 피드백_생성() { FeedbackRequest request = new FeedbackRequest("피드백 본문", 1); Long useerId = 1L;  var expected = Feedback.builder() .content("피드백 본문") .score(Score.ONE_STAR) .userId(1L) .build();  Mockito.when(feedbackRepository.save(any())) .thenReturn(expected);  Feedback actual = feedbackService.create(request, useerId);  "<AssertPlaceHolder>"; }
create(FeedbackRequest request, Long userId) { var feedback = Feedback.builder() .content(request.content()) .score(Score.of(request.score())) .userId(userId) .build();  return feedbackRepository.save(feedback); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: 인물_관계_단일_조회() { // given var expected = Character.builder() .name("디프만 1번 출구") .type(CharacterType.PERSONA) .webtoonId(1L) .build();  Mockito.when(characterRepository.findById(anyLong())) .thenReturn(Optional.of(expected)); // when Character actual = characterService.findById(JOINED_ITEM_ID); // then "<AssertPlaceHolder>"; }
findById(Long characterId) { return characterRepository.findById(characterId) .orElseThrow(NotExistsCharacterException::new); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: withoutAnyTypeParameters() { String toVerify = toTest().getTypeParametersGenerator().generate(); String expected = ""; "<AssertPlaceHolder>"; }
generate() { if (isEmpty()) { return ""; } else { return typeParameters.stream().map(TypeParameterGenerator::typeParameter).map(TypeParameterGenerator::generate).collect(joining(SEPARATOR, OPEN_ANGULAR_BRACKET, CLOSE_ANGULAR_BRACKET)); } }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: validateGivenMethodWithLessThanOneTypeParameters() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(), Optional.of(LIST.with(STRING)), "myFunction", asList(Parameter.of(ARRAY_LIST.with(STRING), "value")) );  Validated<String, InitializerOrFinalizerValidator.Result> expected = Validated.invalid("Method requires exactly 1 type parameters, but found 0"); Validated<String, InitializerOrFinalizerValidator.Result> toVerify = InitializerOrFinalizerValidator.validate(toValidate);  "<AssertPlaceHolder>"; }
validate(Method method) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyParameterCount(method.getParameters(), 1, errorMessages); verifyTypeParameterCount(method.getTypeParameters(), 1, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  TypeParameter typeParameter = method.getTypeParameters().get(0);  String name = method.getName();  Parameter parameter = method.getParameters().get(0);  // Extract the type constructor from the single parameter: TypeConstructor toInitializeOrFinalizeTypeConstructor = parameter.getType().asTypeConstructorWithPlaceholderFor(typeParameter.getName());  // Extract the type constructor from the return type: TypeConstructor initializedOrFinalizedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(typeParameter.getName());  return Validated.valid(Result.of(name, parameter.getType(), toInitializeOrFinalizeTypeConstructor, returnType, initializedOrFinalizedTypeConstructor)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testArray() {  SchemaBuilder builder = new SchemaBuilder(). // addProperty("name", "string", "Please enter your name"). // addProperty("description", "string", null);  builder.addArray("comments");  builder.addProperty("user", "string", "", null); builder.addProperty("date", "string", "", null);  String json = builder.build();  "<AssertPlaceHolder>";  logger.info(json);  }
build() { closeArray();  rootSchemaBuilder.add("type", "object"); rootSchemaBuilder.add("properties", propertiesBuilder);  // write result JsonObject jsonObject = rootSchemaBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: testDeleteOneWebHookByHookId() { when(webHookController.success()).thenReturn(mock(ResponseMessage.class)); doNothing().when(webHookService).delete(any(String[].class), any(UserDetail.class)); when(webHookController.deleteOneWebHookByHookId("id")).thenCallRealMethod(); ResponseMessage<Void> hook = webHookController.deleteOneWebHookByHookId("id"); Assertions."<AssertPlaceHolder>"; verify(webHookController).success(); verify(webHookService).delete(any(String[].class), any(UserDetail.class)); }
deleteOneWebHookByHookId(@PathVariable(value = "id") String hookId) { webHookService.delete(new String[]{hookId}, getLoginUser()); return success(); }
[*] target: assertNotNull(hook)
[-] pred: org. junit. Assert. assertNotNull ( hook )
************************************
************************************
[+] input: setTwoBelow() { set.set(1); final int ret = set.previousSetBit(3);  "<AssertPlaceHolder>"; }
previousSetBit(int fromIndex);  /** * Returns the index of the nearest bit that is set to {@code false}
[*] target: assertEquals(1, ret)
[-] pred: org. junit. Assert. assertEquals ( 1, ret )
************************************
************************************
[+] input: SQLException { rdsHostListProvider = getRdsHostListProvider(mockHostListProviderService, "jdbc:someprotocol://url");  final List<HostSpec> expected = hosts; RdsHostListProvider.topologyCache.put(rdsHostListProvider.clusterId, expected, defaultRefreshRateNano);  final List<HostSpec> result = rdsHostListProvider.getCachedTopology(); "<AssertPlaceHolder>"; }
getCachedTopology() { return topologyCache.get(this.clusterId); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: combineAndLift() { UnaryOperator<Move> transformMove = UnaryOperators.instance().lift(Move::new).apply( cost -> cost.stream().flatMap(energyType -> Stream.of(energyType, energyType)).collect(toList()), name -> name + "!", damage -> damage * 2 );  UnaryOperator<PokemonCard> transformPokemonCard = UnaryOperators.instance().combine( name -> name.toUpperCase(), level -> level + 1, ignored -> COLORLESS, moves -> moves.stream().map(transformMove).collect(toList()), PokemonCard::new );  PokemonCard toTransform = PokemonCard.of( "Bulbasaur", 70, GRASS, asList( Move.of( asList(COLORLESS, GRASS), "Razor Leaf", 30 ) ) );  PokemonCard expected = PokemonCard.of( "BULBASAUR", 71, COLORLESS, asList( Move.of( asList(COLORLESS, COLORLESS, GRASS, GRASS), "Razor Leaf!", 60 ) ) );  PokemonCard toVerify = transformPokemonCard.apply(toTransform);  "<AssertPlaceHolder>"; }
instance() { return INSTANCE; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testIsNotUnwindProcess() { hazelcastTargetPdkBaseNode.unwindProcess = false; TapTable tapTable = mock(TapTable.class); AtomicBoolean atomicBoolean = new AtomicBoolean(false); doCallRealMethod().when(hazelcastTargetPdkBaseNode).createTable(tapTable, atomicBoolean,true); TableNode node = new TableNode(); node.setDisabled(false); when(hazelcastTargetPdkBaseNode.getNode()).thenReturn((Node) node); ConnectorNode connectorNode = mock(ConnectorNode.class); when(hazelcastTargetPdkBaseNode.getConnectorNode()).thenReturn(connectorNode); ConnectorFunctions connectorFunctions = mock(ConnectorFunctions.class); when(connectorNode.getConnectorFunctions()).thenReturn(connectorFunctions); when(connectorFunctions.getCreateTableFunction()).thenReturn(null); when(connectorFunctions.getCreateTableV2Function()).thenReturn(mock(CreateTableV2Function.class)); Connections connections = new Connections(); connections.setId("test"); when(dataProcessorContext.getTargetConn()).thenReturn(connections); boolean result = hazelcastTargetPdkBaseNode.createTable(tapTable, atomicBoolean,true); Assertions."<AssertPlaceHolder>"; }
createTable(TapTable tapTable, AtomicBoolean succeed,boolean init) { if (getNode().disabledNode()) { obsLogger.info("Target node has been disabled, task will skip: create table"); return false; } AtomicReference<TapCreateTableEvent> tapCreateTableEvent = new AtomicReference<>(); boolean createdTable; try { CreateTableFunction createTableFunction = getConnectorNode().getConnectorFunctions().getCreateTableFunction(); CreateTableV2Function createTableV2Function = getConnectorNode().getConnectorFunctions().getCreateTableV2Function(); createdTable = createTableV2Function != null || createTableFunction != null; TapTable finalTapTable = new TapTable(); if (createdTable) { handleTapTablePrimaryKeys(tapTable); BeanUtil.copyProperties(tapTable,finalTapTable); if(unwindProcess){ ignorePksAndIndices(finalTapTable, null); } tapCreateTableEvent.set(createTableEvent(finalTapTable)); executeDataFuncAspect(CreateTableFuncAspect.class, () -> new CreateTableFuncAspect() .createTableEvent(tapCreateTableEvent.get()) .setInit(init) .connectorContext(getConnectorNode().getConnectorContext()) .dataProcessorContext(dataProcessorContext) .start(), (createTableFuncAspect -> PDKInvocationMonitor.invoke(getConnectorNode(), PDKMethod.TARGET_CREATE_TABLE, () -> { if (createTableV2Function != null) { CreateTableOptions createTableOptions = createTableV2Function.createTable(getConnectorNode().getConnectorContext(), tapCreateTableEvent.get()); succeed.set(!createTableOptions.getTableExists()); if (createTableFuncAspect != null) createTableFuncAspect.createTableOptions(createTableOptions); } else { createTableFunction.createTable(getConnectorNode().getConnectorContext(), tapCreateTableEvent.get()); } }, TAG,buildErrorConsumer(tapCreateTableEvent.get().getTableId())))); clientMongoOperator.insertOne(Collections.singletonList(finalTapTable), ConnectorConstant.CONNECTION_COLLECTION + "/load/part/tables/" + dataProcessorContext.getTargetConn().getId()); } else { // only execute start function aspect so that it would be cheated as input AspectUtils.executeAspect(new CreateTableFuncAspect() .createTableEvent(tapCreateTableEvent.get()) .setInit(init) .connectorContext(getConnectorNode().getConnectorContext()) .dataProcessorContext(dataProcessorContext).state(NewFieldFuncAspect.STATE_START)); clientMongoOperator.insertOne(Collections.singletonList(tapTable), ConnectorConstant.CONNECTION_COLLECTION + "/load/part/tables/" + dataProcessorContext.getTargetConn().getId()); }  } catch (Throwable throwable) { Throwable matched = CommonUtils.matchThrowable(throwable, TapCodeException.class); if (null != matched) { throw (TapCodeException) matched; }else { throw new TapEventException(TaskTargetProcessorExCode_15.CREATE_TABLE_FAILED, "Table model: " + tapTable, throwable) .addEvent(tapCreateTableEvent.get()); } } return createdTable; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: addMinutesToCurrentTime_AllGood_FiveMinutesAdded() { try (MockedStatic<Calendar> calendarClassMock = Mockito.mockStatic(Calendar.class)) { when(calendarInstanceMock.getTime()).thenReturn(new Date()); calendarClassMock.when(Calendar::getInstance).thenReturn(calendarInstanceMock);  final var minutes = 5; Date dateAfterAddingFiveMinutesToCurrentTime = DateUtils.addMinutesToCurrentTime(minutes);  verify(calendarInstanceMock).add(Calendar.MINUTE, minutes); "<AssertPlaceHolder>"; } }
addMinutesToCurrentTime(final Integer minutes) { Calendar cal = Calendar.getInstance(); cal.setTime(new Date()); cal.add(Calendar.MINUTE, minutes); return cal.getTime(); }
[*] target: assertNotNull(dateAfterAddingFiveMinutesToCurrentTime)
[-] pred: org. junit. Assert. assertNotNull ( dateAfterAddingFiveMinutesToCurrentTime )
************************************
************************************
[+] input: shouldTurnDownVolume() { //given //when this.tv.turnDownVolume(); this.tv.turnDownVolume(); this.tv.turnDownVolume(); int actual = this.tv.getVolume(); //then int expected = 2; Assertions."<AssertPlaceHolder>"; }
getVolume() { return volume; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: array() { ArrayTypeConstructor expected = new ArrayTypeConstructor(new PlaceholderTypeConstructor()); ArrayTypeConstructor toVerify = new PlaceholderTypeConstructor().array();  "<AssertPlaceHolder>"; }
array() { return array(this); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testDeleteSql() { Map<String, Object> params = new HashMap<>(2); params.put("id", 1); long delete = commonDaoWrap.deleteSql("delete from user where id = #{id}", params); Assertions."<AssertPlaceHolder>"; }
deleteSql(String sql, Map<String, Object> params) { return dao.deleteSql(setSQL(sql, params)); }
[*] target: assertEquals(1, delete)
[-] pred: org. junit. Assert. assertEquals ( 1, delete )
************************************
************************************
[+] input: testInstantiation() { var user = new ContentDataUser<>() { public Object useContentData(Object contentData) throws InnerClassException { return null; } };  "<AssertPlaceHolder>"; }
useContentData(Object contentData) throws InnerClassException;  /** * Calling this method makes it possible to throw a checked exception from * within this class. * <p>To catch it you should surround the using method with a * {@code try-catch}
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: testValid() { Identifier identifier = new ItalianVATCodeIdentifier();  for (String valid : new String[]{ "03449210123", "03967190962" }) { "<AssertPlaceHolder>"; } }
isOfThisType(String data) { return identifier.matcher(data).matches(); }
[*] target: assertTrue(identifier.isOfThisType(valid))
[-] pred: org. junit. Assert. assertTrue ( identifier. isOfThisType ( valid ) )
************************************
************************************
[+] input: returnsMergeTableNodeWhenNodeIsInstanceOfMergeTableNode() { String nodeId = "testNodeId"; MergeTableNode expectedNode = new MergeTableNode();  DAG dag = mock(DAG.class); when(dag.getNode(nodeId)).thenReturn((Node) expectedNode);  MergeTableNode result = mergeNodeCleaner.getMergeTableNode(dag, nodeId);  "<AssertPlaceHolder>"; }
getMergeTableNode(DAG dag, String nodeId) { Node<?> node = dag.getNode(nodeId); if (node instanceof MergeTableNode) { return (MergeTableNode) node; } return null; }
[*] target: assertEquals(expectedNode, result)
[-] pred: org. junit. Assert. assertEquals ( expectedNode, result )
************************************
************************************
[+] input: testGenerateCommandEntity() { // Setup final ClusterServiceCommandEntity expectedResult = new ClusterServiceCommandEntity(); expectedResult.setCommandId("commandId"); expectedResult.setCreateBy("admin"); expectedResult.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); expectedResult.setCommandName("commandName"); expectedResult.setCommandState(CommandState.WAIT); expectedResult.setCommandStateCode(0); expectedResult.setCommandProgress(0); expectedResult.setClusterId(0); expectedResult.setServiceName("serviceName"); expectedResult.setCommandType(0); expectedResult.setDurationTime("durationTime"); expectedResult.setEndTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); expectedResult.setServiceInstanceId(0);  // Run the test final ClusterServiceCommandEntity result = ProcessUtils.generateCommandEntity(0, CommandType.INSTALL_SERVICE, "serviceName");  // Verify the results "<AssertPlaceHolder>"; }
generateCommandEntity(Integer clusterId, CommandType commandType, String serviceName) { ClusterServiceCommandEntity commandEntity = new ClusterServiceCommandEntity(); String commandId = IdUtil.simpleUUID(); commandEntity.setCommandId(commandId); commandEntity.setClusterId(clusterId); commandEntity.setCommandName(commandType.getCommandName(PropertyUtils.getString(Constants.LOCALE_LANGUAGE)) + Constants.SPACE + serviceName); commandEntity.setCommandProgress(0); commandEntity.setCommandState(CommandState.RUNNING); commandEntity.setCommandType(commandType.getValue()); commandEntity.setCreateTime(new Date()); commandEntity.setCreateBy("admin"); commandEntity.setServiceName(serviceName); return commandEntity; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testSkipNotIsomorphism() { skipDetector.setIsomorphism(false); //when(skipDetector.isomorphism).thenReturn(false); when(field.getCreateSource()).thenReturn(Field.SOURCE_JOB_ANALYZE); boolean skip = skipDetector.skip(field); Assertions."<AssertPlaceHolder>"; verify(field, times(0)).getCreateSource(); }
skip(TapField field) { return false; //是否同构，不是同构就就返回false继续执行codec, 是同构就继续下面的判断 //        if (!isomorphism) return false; //是同构，如果这个字段是手动修改改过表结构的结果就返回false需要走codec, 否则不走codec //        return !(null != field && null != field.getCreateSource() && Field.SOURCE_MANUAL.equalsIgnoreCase(field.getCreateSource())); }
[*] target: assertFalse(skip)
[-] pred: org. junit. Assert. assertFalse ( skip )
************************************
************************************
[+] input: testAllListIsNull() { when(a.getAgentIds()).thenReturn(null); when(b.getAgentIds()).thenReturn(null); int count = agentGroupUtil.sortAgentGroup(a, b); Assertions."<AssertPlaceHolder>"; }
sortAgentGroup(AgentGroupEntity a, AgentGroupEntity b) { List<String> agentIdsOfA = a.getAgentIds(); List<String> agentIdsOfB = b.getAgentIds(); if (null == agentIdsOfA && null == agentIdsOfB) { return 0; } if (null == agentIdsOfA) { return 1; } if (null == agentIdsOfB) { return -1; } return agentIdsOfB.size() - agentIdsOfA.size(); }
[*] target: assertEquals(0, count)
[-] pred: org. junit. Assert. assertEquals ( 0, count )
************************************
************************************
[+] input: validateGivenStaticMethod() { Method toValidate = Method.of( emptySet(), modifiers(PUBLIC, STATIC), asList(T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter()), Optional.of(OPTIONAL.with(V)), "myFunction", asList( Parameter.of(OPTIONAL.with(T), "left"), Parameter.of(OPTIONAL.with(U), "right"), Parameter.of(BI_FUNCTION.with(T.asType().contravariant(), U.asType().contravariant(), V.asType().covariant()), "compose") ) );  Validated<String, AccumulatorValidator.Result> expected = Validated.invalid("Method is static and cannot implement an abstract method"); Validated<String, AccumulatorValidator.Result> toVerify = AccumulatorValidator.validate(toValidate, new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
validate(Method method, ParametersAndTypeParametersValidator parametersAndTypeParametersValidator) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages); ParametersAndTypeParametersValidator.Result parametersAndTypeParameters = verifyParametersAndTypeParameters(method, parametersAndTypeParametersValidator, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  // Assign a meaningful name to each of the (three) type parameters: TypeParameter leftInputTypeConstructorArgument = parametersAndTypeParameters.getLeftInputTypeConstructorArgument(); TypeParameter rightInputTypeConstructorArgument = parametersAndTypeParameters.getRightInputTypeConstructorArgument(); TypeParameter returnTypeConstructorArgument = parametersAndTypeParameters.getReturnTypeConstructorArgument();  // Assign a meaningful name to the left and right parameters: Type leftParameterType = parametersAndTypeParameters.getLeftParameterType(); Type rightParameterType = parametersAndTypeParameters.getRightParameterType();  String name = method.getName();  TypeConstructor accumulatedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(returnTypeConstructorArgument.getName()); TypeConstructor partiallyAccumulatedTypeConstructor = leftParameterType.asTypeConstructorWithPlaceholderFor(leftInputTypeConstructorArgument.getName()); TypeConstructor inputTypeConstructor = rightParameterType.asTypeConstructorWithPlaceholderFor(rightInputTypeConstructorArgument.getName());  if (!partiallyAccumulatedTypeConstructor.canAccept(accumulatedTypeConstructor)) { // Tweak the error message to not confuse people using the simple case where // parameter types and result type should be identical: if (Objects.equals(partiallyAccumulatedTypeConstructor, inputTypeConstructor)) { return Validated.invalid("No shared type constructor between parameters (" + generateFrom(leftParameterType) + " and " + generateFrom(rightParameterType) + ") and result (" + generateFrom(returnType) + ")"); } else { return Validated.invalid("No shared type constructor between first parameter (" + generateFrom(leftParameterType) + ") and result (" + generateFrom(returnType) + ")"); } }  verifyNoCrossReferences(method.getTypeParameters(), leftParameterType, partiallyAccumulatedTypeConstructor, "type of the first parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), rightParameterType, inputTypeConstructor, "type of the second parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), returnType, accumulatedTypeConstructor, "return type", errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  return Validated.valid( AccumulatorValidator.Result.of( name, inputTypeConstructor, partiallyAccumulatedTypeConstructor, accumulatedTypeConstructor, leftParameterType, rightParameterType, returnType ) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: test1() { List<Worker> workerList = new ArrayList<>(); Worker worker = new Worker(); workerList.add(worker); doReturn(workerList).when(workerService).findAvailableAgent(any()); String result = workerService.getWorkerCurrentTime(mock(UserDetail.class)); Assertions."<AssertPlaceHolder>"; }
getWorkerCurrentTime(UserDetail userDetail);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: test_getJSONArray2() { JSONObject object = new JSONObject().fluentPut("values", new ArrayList<>()); JSONArray array = object.getJSONArray("values"); "<AssertPlaceHolder>"; }
size() { return map.size(); }
[*] target: assertEquals(0, array.size())
[-] pred: org. junit. Assert. assertEquals ( 0, array. size ( ) )
************************************
************************************
[+] input: canAddKnight() { ChessBoard board = new ChessBoard(); Knight knight = new Knight(BLACK);  board.add(knight, "c1");  Knight foundKnight = (Knight) board.getPieceAtCoords("c1"); "<AssertPlaceHolder>"; }
getPieceAtCoords(String chessCoords) { Coordinates coords = new Coordinates(chessCoords); return internalBoard[coords.getX()][coords.getY()]; }
[*] target: assertEquals(knight, foundKnight)
[-] pred: org. junit. Assert. assertEquals ( knight, foundKnight )
************************************
************************************
[+] input: shouldSetAndGetCursorBlink() { options.setCursorBlink(false); "<AssertPlaceHolder>"; }
isCursorBlink() { return cursorBlink; }
[*] target: assertFalse(options.isCursorBlink())
[-] pred: org. junit. Assert. assertFalse ( options. isCursorBlink() )
************************************
************************************
[+] input: withTypeParameters() { TypeParameterName A = TypeParameterName.of("A"); TypeParameterName B = TypeParameterName.of("B"); TypeParameterName C = TypeParameterName.of("C"); String toVerify = toTest() .withTypeParameters(A.asTypeParameter(), B.extending(COMPARABLE.with(B))) .withTypeParameters(C.asTypeParameter()) .getTypeParametersGenerator() .generate(); String expected = "<A, B extends java.lang.Comparable<B>, C>"; "<AssertPlaceHolder>"; }
generate() { if (isEmpty()) { return ""; } else { return typeParameters.stream().map(TypeParameterGenerator::typeParameter).map(TypeParameterGenerator::generate).collect(joining(SEPARATOR, OPEN_ANGULAR_BRACKET, CLOSE_ANGULAR_BRACKET)); } }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: getActivityLogOverview_TeamIdNotNull() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when( handleDbRequestsJdbc.getActivityLogByTeam( TestConstants.TEAM_ID, NUMBER_OF_DAYS, TestConstants.TENANT_ID)) .thenReturn(TestConstants.ACLS_COUNT_BY_ENV_ID_INTEGERE); Mockito.when( manageDatabase.getTeamNameFromTeamId(TestConstants.TENANT_ID, TestConstants.TEAM_ID)) .thenReturn(TestConstants.TEAM_NAME); Mockito.when( commonUtilsService.getChartsJsOverview( anyList(), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getActivityLogOverview( TestConstants.TEAM_ID, TestConstants.TENANT_ID, NUMBER_OF_DAYS);  Assertions."<AssertPlaceHolder>"; }
getActivityLogOverview( Integer teamId, Integer tenantId, int numberOfDays) {  List<CommonUtilsService.ChartsOverviewItem<String, Integer>> activityCountList; String title = ANALYTICS_107;  if (teamId != null) { activityCountList = manageDatabase.getHandleDbRequests().getActivityLogByTeam(teamId, numberOfDays, tenantId); title = title + " (" + manageDatabase.getTeamNameFromTeamId(tenantId, teamId) + ")"; } else { // tenant filtering List<String> allowedEnvIdList = manageDatabase.getEnvsOfTenantsMap().get(tenantId);  try { activityCountList = manageDatabase .getHandleDbRequests() .getActivityLogForLastDays( numberOfDays, allowedEnvIdList.toArray(new String[0]), tenantId); } catch (Exception e) { log.error("No environments/clusters found.", e); activityCountList = new ArrayList<>(); } }  return commonUtilsService.getChartsJsOverview( activityCountList, title, "dateofactivity", "Days", "Activities", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: valid() { ValidationResult result = ValidationResult.valid();  "<AssertPlaceHolder>"; }
hasErrors() { return !this.errors.isEmpty(); }
[*] target: assertFalse(result.hasErrors())
[-] pred: org. junit. Assert. assertFalse ( result. hasErrors() )
************************************
************************************
[+] input: givenStaticMethodAndNoTypeArguments() { String toVerify = methodCall() .withType(BIG_DECIMAL) .withMethodName("valueOf") .withArguments("10") .generate();  String expected = "java.math.BigDecimal.valueOf(10)";  "<AssertPlaceHolder>"; }
generate() { return objectPathOrTypeGenerator.generate() + PERIOD + generateOptionalTypeArguments() + methodName + arguments.stream().collect(joining(SEPARATOR, OPEN_PARENTHESIS, CLOSE_PARENTHESIS)); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testNewControl() { SortedMap<String, Charset> charsetsSortedMap = Charset.availableCharsets(); for (String encoding : charsetsSortedMap.keySet()) { ResourceBundle.Control control = PropertyResourceBundleControl.newControl(encoding); "<AssertPlaceHolder>"; } }
newControl(final String encoding) throws UnsupportedCharsetException { // check encoding Charset.forName(encoding); final ResourceBundle.Control existedControl = getControl(encoding); ResourceBundle.Control control = existedControl; if (existedControl == null) { control = new PropertyResourceBundleControl(encoding); encodingControlMap.put(encoding, control); } return control; }
[*] target: assertNotNull(control)
[-] pred: org. junit. Assert. assertNotNull ( control )
************************************
************************************
[+] input: endAt_가져오기_테스트() { // given final EventBasic eventBasic = EventBasic.builder().startAt(startAt).runTime(runTime).build(); event.setEventBasic(eventBasic); // when final LocalDateTime expectedEndAt = startAt.plusMinutes(runTime); final LocalDateTime actualEndAt = event.getEndAt(); // then "<AssertPlaceHolder>"; }
getEndAt() { if (this.eventBasic == null) return null; return this.getEventBasic().endAt(); }
[*] target: assertEquals(expectedEndAt, actualEndAt)
[-] pred: org. junit. Assert. assertEquals ( expectedEndAt, actualEndAt )
************************************
************************************
[+] input: testInsert() { User user = new User(); user.setName("张三"); user.setAge(18); user.setCreateTime(LocalDateTime.now().plusYears(-18)); int insert = commonDaoWrap.insert(user); Assertions."<AssertPlaceHolder>"; }
insert(T params) { int insert = dao.insert(params); if(insert > 0){ ReflectionUtils.doWithFields(params.getClass(), field -> { field.setAccessible(true); try { if (field.get(params) == null) { if (field.getType() == Long.class) { field.set(params, selectCountBySQL("select LAST_INSERT_ID()", null)); } if (field.getType() == Integer.class) { field.set(params, (int) selectCountBySQL("select LAST_INSERT_ID()", null)); } } } catch (IllegalAccessException e) { log.error(e.getMessage(), e); } }, field -> field.isAnnotationPresent(TableId.class)); } return insert; }
[*] target: assertEquals(1, insert)
[-] pred: org. junit. Assert. assertEquals ( 1, insert )
************************************
************************************
[+] input: shouldMaskString() { try (MockedStatic<Environment> mockedEnvironment = mockStatic(Environment.class)) { mockedEnvironment.when(Environment::getCurrent).thenReturn(env); when(env.getWebforjHelper()).thenReturn(bridge);  String input = "qw12"; String mask = "AA-00"; String expected = "QW-12";  when(bridge.maskString(input, mask)).thenReturn(expected);  String result = MaskDecorator.forString(input, mask);  "<AssertPlaceHolder>"; } }
forString(String input, String mask) { Objects.requireNonNull(input, INPUT_CANNOT_BE_NULL); Objects.requireNonNull(mask, MASK_CANNOT_BE_NULL);  Environment env = Environment.getCurrent(); return env.getWebforjHelper().maskString(input, mask); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: parse_ShouldParseTextAndReturnAsNumber() { String valueAsString = "21474836470.7"; Double expected = TypeCodecs.DOUBLE.parse(valueAsString); Double result = codec.parse(valueAsString); Assertions."<AssertPlaceHolder>"; }
parse(String value) { return value == null ? null : Double.parseDouble(value); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: isParentOf() { NodeData parent = new NodeData(new File("/test/foobar")); NodeData child = new NodeData(new File("/test/foobar.txt")); Assertions."<AssertPlaceHolder>"; }
isParentOf(NodeData nodeData) { return PathUtils.isParentFolder(this.getFile(), nodeData.getFile()); }
[*] target: assertFalse(parent.isParentOf(child))
[-] pred: org. junit. Assert. assertFalse ( parent. isParentOf ( child ) )
************************************
************************************
[+] input: testUpdateSql() { User user = new User(); user.setName("张三"); user.setId(1L); Map<String, Object> params = BeanUtil.beanToMap(user); long update = commonDaoWrap.updateSql("update user set name = #{name} where id = #{id}", params); Assertions."<AssertPlaceHolder>"; }
updateSql(String sql, Map<String, Object> params) { return dao.updateSql(setSQL(sql, params)); }
[*] target: assertEquals(1, update)
[-] pred: org. junit. Assert. assertEquals ( 1, update )
************************************
************************************
[+] input: testCheckIsCronOrPlanTaskWithNullCronTask() { TaskRepository repository = mock(TaskRepository.class); taskService = spy(new TaskServiceImpl(repository)); TaskDto taskDto = new TaskDto(); boolean result = taskService.checkIsCronOrPlanTask(taskDto); "<AssertPlaceHolder>"; }
checkIsCronOrPlanTask(TaskDto task) { if(null == task) throw new IllegalArgumentException("Task can not be null"); if ((task.getCrontabExpressionFlag() != null && task.getCrontabExpressionFlag()) || task.isPlanStartDateFlag()) { return true; } else { return false; } }
[*] target: assertEquals(false, result)
[-] pred: org. junit. Assert. assertEquals ( false, result )
************************************
************************************
[+] input: deleteEmployee() {  Employee employee = new Employee(); employee.setName("John"); employee.setSalary(20000); Employee savedEmployee = employeeOperationsService.createEmployee(employee);  employeeOperationsService.deleteEmployee(savedEmployee.getEmployeeId());  Employee fetchedEmployee = employeeOperationsService.getEmployee(savedEmployee.getEmployeeId()); "<AssertPlaceHolder>"; }
getEmployee(String employeeId) { return elasticsearchOperations.get(employeeId, Employee.class); }
[*] target: assertNull(fetchedEmployee)
[-] pred: org. junit. Assert. assertNull ( fetchedEmployee )
************************************
************************************
[+] input: getScanMetadataCronSchedule_whenRetrieved_thenReturnsDefaultScheduleAt5MinutesPastHour() { String sensorResultsStoragePath = this.sut.getSynchronizeCronSchedule(); String expected = "5 * * * *"; Assertions."<AssertPlaceHolder>"; }
getSynchronizeCronSchedule() { return synchronizeCronSchedule; }
[*] target: assertEquals(expected, sensorResultsStoragePath)
[-] pred: org. junit. Assert. assertEquals ( expected, sensorResultsStoragePath )
************************************
************************************
[+] input: parseString() { final EditorHelper editorHelper = new EditorHelper(); final String newValue = "test";  final Object result = editorHelper.edit("java.lang.String", newValue); Assertions."<AssertPlaceHolder>"; }
edit(String type, String newValue) { try { final Class<?> klass = parseType(type); return new Gson().fromJson(newValue, klass); } catch (Exception e) { log.warn("Failed to edit value: {}, {}", type, newValue, e); return null; } }
[*] target: assertEquals(newValue, result)
[-] pred: org. junit. Assert. assertEquals ( newValue, result )
************************************
************************************
[+] input: testInsertSql() { User user = new User(); user.setName("张三"); user.setAge(18); user.setCreateTime(LocalDateTime.now().plusYears(-18)); Map<String, Object> params = BeanUtil.beanToMap(user); params.put("selfSQL", "insert into user(name, age, create_time) values(#{name}, #{age}, #{createTime})"); long insert = commonDao.insertSql(params); Assertions."<AssertPlaceHolder>"; }
insertSql(Map<String, Object> params);  /** * update * @param params 参数 * @return result */ @Delete(" ${selfSQL}
[*] target: assertEquals(1, insert)
[-] pred: org. junit. Assert. assertEquals ( 1, insert )
************************************
************************************
[+] input: testFindRunningTasksByAgentIdWithId() { TaskRepository repository = mock(TaskRepository.class); taskService = spy(new TaskServiceImpl(repository)); String processId = "111"; Query query = Query.query(Criteria.where("agentId").is(processId).and("status").is("running")); when(taskService.findAll(query)).thenReturn(new ArrayList<>()); int actual = taskService.findRunningTasksByAgentId(processId); "<AssertPlaceHolder>"; }
findRunningTasksByAgentId(String processId);  public abstract int runningTaskNum(UserDetail userDetail);  public abstract boolean checkCloudTaskLimit(ObjectId taskId, UserDetail user, boolean checkCurrentTask); public abstract void updateDelayTime(ObjectId taskId, long delayTime); public abstract void refreshSchemas(TaskDto taskDto, String nodeIds, String keys, UserDetail userDetail); public abstract void checkSourceTimeDifference(TaskDto taskDto,UserDetail userDetail);  @Data @AllArgsConstructor @NoArgsConstructor public static class Char1Group { private String _id; private long count; }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: addDaysToCurrentTime_AllGood_FiveDaysAdded() { try (MockedStatic<Calendar> calendarClassMock = Mockito.mockStatic(Calendar.class)) { when(calendarInstanceMock.getTime()).thenReturn(new Date()); calendarClassMock.when(Calendar::getInstance).thenReturn(calendarInstanceMock);  final var days = 5; Date dateAfterAddingFiveMinutesToCurrentTime = DateUtils.addDaysToCurrentTime(days);  verify(calendarInstanceMock).add(Calendar.DATE, days); "<AssertPlaceHolder>"; } }
addDaysToCurrentTime(final Integer days) { Calendar cal = Calendar.getInstance(); cal.setTime(new Date()); cal.add(Calendar.DATE, days); return cal.getTime(); }
[*] target: assertNotNull(dateAfterAddingFiveMinutesToCurrentTime)
[-] pred: org. junit. Assert. assertNotNull ( dateAfterAddingFiveMinutesToCurrentTime )
************************************
************************************
[+] input: setProperty_Number() { Integer value = 1234; Integer setValue = (Integer) helper.setProperty(KnownProperties.TEST_NUMBER, value); "<AssertPlaceHolder>"; }
setProperty(String propertyName, Object propertyValue) { if (null == propertyName || null == propertyValue) return null; PropertyType expectedType = getType(propertyName); if (null == expectedType) { return null; }  boolean typesMatch = validateType(expectedType, propertyValue); if (!typesMatch) return null;  synchronized (PropertyHelper.class) { propertyMap.put(propertyName, propertyValue); } return propertyValue; }
[*] target: assertEquals(value, setValue)
[-] pred: org. junit. Assert. assertEquals ( value, setValue )
************************************
************************************
[+] input: testParseWithNull_ReturnNull() { AndroidBatteryInfoResultParser parser = new AndroidBatteryInfoResultParser(); PerformanceTestResult testResult = parser.parse(null, null); Assertions."<AssertPlaceHolder>"; }
parse(PerformanceTestResult performanceTestResult, Logger logger) { if (performanceTestResult == null || performanceTestResult.performanceInspectionResults == null || performanceTestResult.performanceInspectionResults.isEmpty()) { return null; }  List<PerformanceInspectionResult> inspectionResults = performanceTestResult.performanceInspectionResults; for (PerformanceInspectionResult inspectionResult : inspectionResults) { File logFile = inspectionResult.rawResultFile; AndroidBatteryInfo batteryInfo = parseRawResultFile(logFile, inspectionResult.inspection.appId, logger); if (batteryInfo != null) { batteryInfo.setAppPackageName(inspectionResult.inspection.appId); batteryInfo.setDescription(inspectionResult.inspection.description); batteryInfo.setTimeStamp(inspectionResult.timestamp); } inspectionResult.parsedData = batteryInfo; }  // Use the battery usage at the end of the test as a summary performanceTestResult.setResultSummary(getResultSummary(inspectionResults)); return performanceTestResult; }
[*] target: assertNull(testResult)
[-] pred: org. junit. Assert. assertNull ( testResult )
************************************
************************************
[+] input: testGetLoopPackagesFile() { File file = utils.getLoopPackagesFile(); Assertions."<AssertPlaceHolder>"; }
getLoopPackagesFile() { String path = concat(PYTHON_THREAD_PACKAGE_PATH, PYTHON_SITE_PACKAGES_VERSION_CONFIG); return new File(path); }
[*] target: assertNotNull(file)
[-] pred: org. junit. Assert. assertNotNull ( file )
************************************
************************************
[+] input: validateGivenParametersThatReferenceTheWrongTypeParameters() {  // Note: it is currently impossible for the accumulated type constructor and // the partially accumulated type constructor to mention the first or the second // type parameter. If they do, they accumulated type constructor can never // be assigned to the partially accumulated type constructor.  Method toValidate = Method.of( emptySet(), modifiers(PUBLIC), asList(T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter()), Optional.of(FUNCTION.with(U, V)), "myFunction", asList( Parameter.of(FUNCTION.with(U, T), "left"), Parameter.of(FUNCTION.with(U, U), "right"), Parameter.of(BI_FUNCTION.with(T.asType().contravariant(), U.asType().contravariant(), V.asType().covariant()), "compose") ) );  Validated<String, AccumulatorValidator.Result> expected = Validated.invalid( "The type of the first parameter (java.util.function.Function<U, T>) is not allowed to reference type parameter 'U'", "The return type (java.util.function.Function<U, V>) is not allowed to reference type parameter 'U'" ); Validated<String, AccumulatorValidator.Result> toVerify = AccumulatorValidator.validate(toValidate, new CovariantParametersAndTypeParametersValidator());  "<AssertPlaceHolder>"; }
validate(Method method, ParametersAndTypeParametersValidator parametersAndTypeParametersValidator) { List<String> errorMessages = new ArrayList<>();  verifyCanImplementAbstractMethod(method, errorMessages); verifyTypeParametersAreUnbounded(method, errorMessages); Type returnType = verifyHasReturnType(method, errorMessages); ParametersAndTypeParametersValidator.Result parametersAndTypeParameters = verifyParametersAndTypeParameters(method, parametersAndTypeParametersValidator, errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  // Assign a meaningful name to each of the (three) type parameters: TypeParameter leftInputTypeConstructorArgument = parametersAndTypeParameters.getLeftInputTypeConstructorArgument(); TypeParameter rightInputTypeConstructorArgument = parametersAndTypeParameters.getRightInputTypeConstructorArgument(); TypeParameter returnTypeConstructorArgument = parametersAndTypeParameters.getReturnTypeConstructorArgument();  // Assign a meaningful name to the left and right parameters: Type leftParameterType = parametersAndTypeParameters.getLeftParameterType(); Type rightParameterType = parametersAndTypeParameters.getRightParameterType();  String name = method.getName();  TypeConstructor accumulatedTypeConstructor = returnType.asTypeConstructorWithPlaceholderFor(returnTypeConstructorArgument.getName()); TypeConstructor partiallyAccumulatedTypeConstructor = leftParameterType.asTypeConstructorWithPlaceholderFor(leftInputTypeConstructorArgument.getName()); TypeConstructor inputTypeConstructor = rightParameterType.asTypeConstructorWithPlaceholderFor(rightInputTypeConstructorArgument.getName());  if (!partiallyAccumulatedTypeConstructor.canAccept(accumulatedTypeConstructor)) { // Tweak the error message to not confuse people using the simple case where // parameter types and result type should be identical: if (Objects.equals(partiallyAccumulatedTypeConstructor, inputTypeConstructor)) { return Validated.invalid("No shared type constructor between parameters (" + generateFrom(leftParameterType) + " and " + generateFrom(rightParameterType) + ") and result (" + generateFrom(returnType) + ")"); } else { return Validated.invalid("No shared type constructor between first parameter (" + generateFrom(leftParameterType) + ") and result (" + generateFrom(returnType) + ")"); } }  verifyNoCrossReferences(method.getTypeParameters(), leftParameterType, partiallyAccumulatedTypeConstructor, "type of the first parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), rightParameterType, inputTypeConstructor, "type of the second parameter", errorMessages); verifyNoCrossReferences(method.getTypeParameters(), returnType, accumulatedTypeConstructor, "return type", errorMessages);  if (!errorMessages.isEmpty()) { return Validated.invalid(errorMessages); }  return Validated.valid( AccumulatorValidator.Result.of( name, inputTypeConstructor, partiallyAccumulatedTypeConstructor, accumulatedTypeConstructor, leftParameterType, rightParameterType, returnType ) ); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testGetServiceRoleDeployOverview() { // Setup final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  // Configure ClusterInfoService.getById(...). final ClusterInfoEntity clusterInfoEntity = new ClusterInfoEntity(); clusterInfoEntity.setId(0); clusterInfoEntity.setCreateBy("createBy"); clusterInfoEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterInfoEntity.setClusterName("clusterName"); clusterInfoEntity.setClusterCode("clusterCode"); clusterInfoEntity.setClusterFrame("clusterFrame"); clusterInfoEntity.setFrameVersion("frameVersion"); clusterInfoEntity.setClusterState(ClusterState.RUNNING); clusterInfoEntity.setFrameId(0); final UserInfoEntity userInfoEntity = new UserInfoEntity(); userInfoEntity.setId(0); userInfoEntity.setUsername("username"); userInfoEntity.setPassword("password"); userInfoEntity.setEmail("email"); userInfoEntity.setPhone("phone"); clusterInfoEntity.setClusterManagerList(Arrays.asList(userInfoEntity)); when(mockClusterInfoService.getById(0)).thenReturn(clusterInfoEntity);  // Run the test final Result result = serviceInstallServiceImplUnderTest.getServiceRoleDeployOverview(0);  // Verify the results "<AssertPlaceHolder>"; }
getServiceRoleDeployOverview(Integer clusterId) { ClusterInfoEntity clusterInfo = clusterInfoService.getById(clusterId); HashMap<String, List<String>> map = (HashMap<String, List<String>>) CacheUtils.get( clusterInfo.getClusterCode() + Constants.UNDERLINE + Constants.SERVICE_ROLE_HOST_MAPPING); return Result.success(map); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: SQLException { final List<ColumnSchema> columnSchemas = new ArrayList<>(); columnSchemas.add(GeneralTestUtility.sealedColumn("firstname", "firstname", PadType.FIXED, 100)); columnSchemas.add(GeneralTestUtility.fingerprintColumn("lastname", "lastname")); columnSchemas.add(GeneralTestUtility.cleartextColumn("address", "address")); columnSchemas.add(GeneralTestUtility.cleartextColumn("city", "city")); columnSchemas.add(GeneralTestUtility.cleartextColumn("state", "state")); columnSchemas.add(GeneralTestUtility.cleartextColumn("phonenumber", "phonenumber")); columnSchemas.add(GeneralTestUtility.fingerprintColumn("title", "title")); columnSchemas.add(GeneralTestUtility.cleartextColumn("level", "level")); columnSchemas.add(GeneralTestUtility.sealedColumn("notes", "notes", PadType.MAX, 100)); final Statement statement = mock(Statement.class); when(statement.enquoteIdentifier(anyString(), anyBoolean())).thenAnswer((Answer<String>) invocation -> { final Object[] args = invocation.getArguments(); return """ + args[0] + """; // enquote the column names }); final TableSchema tableConfig = new MappedTableSchema(columnSchemas); final String tableSchema = TableGenerator.getTableSchemaFromConfig( statement, tableConfig, new ColumnHeader("nonce")); final StringBuilder expectedSchema = new StringBuilder("CREATE TABLE c3rTmp (\n"nonce" TEXT"); for (ColumnSchema column : columnSchemas) { expectedSchema.append(",\n"").append(column.getInternalHeader()).append("" TEXT"); } expectedSchema.append(")"); "<AssertPlaceHolder>"; }
getTableSchemaFromConfig(final Statement stmt, final TableSchema schema, final ColumnHeader nonceHeader) { try { final StringBuilder sb = new StringBuilder(); // NOTE: we do not declare the nonce column to be a PRIMARY KEY up front to increase performance // for large numbers of inserts, and instead we later make a UNIQUE INDEX on the nonce // _after_ all the data is loaded. (See `getIndexStatement` in this file). sb.append("CREATE TABLE ").append(DEFAULT_TABLE_NAME) .append(" (\n") .append(stmt.enquoteIdentifier(nonceHeader.toString(), false)) .append(" TEXT"); for (ColumnSchema columnSchema : schema.getColumns()) { sb.append(",\n").append(stmt.enquoteIdentifier(columnSchema.getInternalHeader().toString(), true)).append(" TEXT"); } sb.append(")"); return sb.toString(); } catch (SQLException e) { throw new C3rRuntimeException("Invalid SQL identifier encountered.", e); } }
[*] target: assertEquals(expectedSchema.toString(), tableSchema)
[-] pred: org. junit. Assert. assertEquals ( expectedSchema. toString ( ), tableSchema )
************************************
************************************
[+] input: testGenerateCommandHostCommandEntity() { // Setup final ClusterServiceCommandHostEntity commandHost = new ClusterServiceCommandHostEntity(); commandHost.setCommandHostId("commandHostId"); commandHost.setHostname("hostname"); commandHost.setCommandState(CommandState.WAIT); commandHost.setCommandStateCode(0); commandHost.setCommandProgress(0); commandHost.setCommandId("commandId"); commandHost.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime());  final ClusterServiceCommandHostCommandEntity expectedResult = new ClusterServiceCommandHostCommandEntity(); expectedResult.setHostCommandId("hostCommandId"); expectedResult.setCommandName("commandName"); expectedResult.setCommandState(CommandState.WAIT); expectedResult.setCommandStateCode(0); expectedResult.setCommandProgress(0); expectedResult.setCommandHostId("commandHostId"); expectedResult.setCommandId("commandId"); expectedResult.setHostname("hostname"); expectedResult.setServiceRoleName("serviceRoleName"); expectedResult.setServiceRoleType(RoleType.MASTER); expectedResult.setResultMsg("execOut"); expectedResult.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); expectedResult.setCommandType(0);  // Run the test final ClusterServiceCommandHostCommandEntity result = ProcessUtils.generateCommandHostCommandEntity( CommandType.INSTALL_SERVICE, "commandId", "serviceRoleName", RoleType.MASTER, commandHost);  // Verify the results "<AssertPlaceHolder>"; }
generateCommandHostCommandEntity(CommandType commandType, String commandId, String serviceRoleName, RoleType serviceRoleType, ClusterServiceCommandHostEntity commandHost) { ClusterServiceCommandHostCommandEntity hostCommand = new ClusterServiceCommandHostCommandEntity(); String hostCommandId = IdUtil.simpleUUID(); hostCommand.setHostCommandId(hostCommandId); hostCommand.setServiceRoleName(serviceRoleName); hostCommand.setCommandHostId(commandHost.getCommandHostId()); hostCommand.setCommandState(CommandState.RUNNING); hostCommand.setCommandProgress(0); hostCommand.setHostname(commandHost.getHostname()); hostCommand.setCommandName(commandType.getCommandName(PropertyUtils.getString(Constants.LOCALE_LANGUAGE)) + Constants.SPACE + serviceRoleName); hostCommand.setCommandId(commandId); hostCommand.setCommandType(commandType.getValue()); hostCommand.setServiceRoleType(serviceRoleType); hostCommand.setCreateTime(new Date()); return hostCommand; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testSingleRow() { AsciiTable tablePrinter = new AsciiTable(Arrays.asList("TYPE", "NAME", "STATUS", "URL")); tablePrinter.addRow("Type1", "Name1", "Status1", "http://url1.com"); String expected = "+-------+-------+---------+-----------------+\n" + "| TYPE  | NAME  | STATUS  | URL             |\n" + "+-------+-------+---------+-----------------+\n" + "| Type1 | Name1 | Status1 | http://url1.com |\n" + "+-------+-------+---------+-----------------+\n"; "<AssertPlaceHolder>"; }
printTable() { StringBuilder table = new StringBuilder(); int[] columnWidths = new int[headers.size()];  // Calculate the width of each column for (int i = 0; i < headers.size(); i++) { columnWidths[i] = headers.get(i).length(); }  for (List<String> row : rows) { for (int i = 0; i < row.size(); i++) { columnWidths[i] = Math.max(columnWidths[i], row.get(i).length()); } }  // Append the headers table.append(printSeparator(columnWidths)); table.append(printRow(headers, columnWidths)); table.append(printSeparator(columnWidths));  // Append the rows for (List<String> row : rows) { table.append(printRow(row, columnWidths)); } table.append(printSeparator(columnWidths));  return table.toString(); }
[*] target: assertEquals(expected, tablePrinter.printTable())
[-] pred: org. junit. Assert. assertEquals ( expected, tablePrinter. printTable ( ) )
************************************
************************************
[+] input: shouldReturnInvoiceAmount() { //given //when BigDecimal actual = this.invoice.getInvoiceAmount(); //then BigDecimal expected = BigDecimal.valueOf(30); Assertions."<AssertPlaceHolder>"; }
getInvoiceAmount() { return this.getItemPrice().multiply(BigDecimal.valueOf(this.quantityItem)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldConstructWithSrc() { String src = "https://example.com";  Img img = new Img(src); "<AssertPlaceHolder>"; }
getSrc() { return get(srcProp); }
[*] target: assertEquals(src, img.getSrc())
[-] pred: org. junit. Assert. assertEquals ( src, img. getSrc() )
************************************
************************************
[+] input: shouldTransformToModelWithValidJulianDate() { LocalDate expectedDate = LocalDate.of(2005, 3, 4); int julianDate = 2453434; LocalDate result = transformer.transformToModel(julianDate); "<AssertPlaceHolder>"; }
transformToModel(Integer viewValue) { try { if (viewValue < 0) { return null; }  if (viewValue == 0) { return LocalDate.now(); }  int n = viewValue - 1721425; int year = n / 365;  int temp; while ((temp = year * 365 + year / 4 - year / 100 + year / 400) >= n) { --year; }  n -= temp; ++year;  if ((year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0))) { if (n > 60) { ++n; } } else { if (n > 59) { n += 2; } }  n += 91; int month = (n * 100) / 3055; int day = n - (month * 3055) / 100; month -= 2;  return LocalDate.of(year, month, day); } catch (Exception e) { throw new TransformationException("Error transforming component value to model value"); } }
[*] target: assertEquals(expectedDate, result)
[-] pred: org. junit. Assert. assertEquals ( expectedDate, result )
************************************
************************************
[+] input: shouldSetGetOptions() { List<String> options = Arrays.asList("Option1", "Option2", "Option3"); component.setOptions(options); verify(mockMixin).setOptions(options);  when(mockMixin.getOptions()).thenReturn(options); List<String> result = component.getOptions(); "<AssertPlaceHolder>"; }
getOptions() { return hasOptionsMixin.getOptions(); }
[*] target: assertEquals(options, result)
[-] pred: org. junit. Assert. assertEquals ( options, result )
************************************
************************************
[+] input: givenMultipleLinesToIndent() { List<String> toVerify = toTest() .withBody("Line 1", "Line 2") .getBodyGenerator() .indent() .indent() .lines();  List<String> expected = asList( "        Line 1", "        Line 2" );  "<AssertPlaceHolder>"; }
lines() { return lines; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testConvertWhenConversionTypeIsUnsupported() { //        CqlConversion.Type conversionType = CqlConversion.Type.UNSUPPORTED; //        List<CqlConversion.Type> conversionTypeList = Collections.singletonList(conversionType); // //        CqlConversion cqlConversion = spy(new CqlConversion(fromDataType, toDataType, codecRegistry)); //        doReturn(conversionTypeList).when(cqlConversion).getConversionTypeList(); // //        Object inputData = new Object(); //        Object result = cqlConversion.convert(inputData); // //        "<AssertPlaceHolder>"; //    }
convert(Object inputData) { if (null==conversionTypeList || conversionTypeList.isEmpty()) return inputData;  if (logger.isTraceEnabled()) logger.trace("convert() - inputData: {}, converter: {}",inputData,this);  // The first element on the conversionTypeList tells us what conversion the top-level object requires Type conversionType = conversionTypeList.get(0); switch (conversionType) { case NONE: case UNSUPPORTED: return inputData; case CODEC: case UDT: return convert_ONE(conversionType, inputData, fromDataTypeList.get(0), toDataTypeList.get(0), codecRegistry); case LIST: case SET: case MAP: return convert_COLLECTION(conversionType, inputData, conversionTypeList.subList(1,conversionTypeList.size()), fromDataTypeList, toDataTypeList, codecRegistry); } logger.warn("Conversion.convert() - Unknown conversion type: {}", conversionType); return inputData; }
[*] target: assertSame(inputData, result)
[-] pred: org. junit. Assert. assertSame ( inputData, result )
************************************
************************************
[+] input: of() { ContainingPackage expected = new ContainingPackage(packageName); ContainingPackage toVerify = ContainingPackage.of(packageName);  "<AssertPlaceHolder>"; }
of(PackageName packageName) { return new ContainingPackage(packageName); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: shouldReturnCurrentDateForZeroJulianDate() { LocalDate expectedDate = LocalDate.now(); LocalDate result = transformer.transformToModel(0); "<AssertPlaceHolder>"; }
transformToModel(Integer viewValue) { try { if (viewValue < 0) { return null; }  if (viewValue == 0) { return LocalDate.now(); }  int n = viewValue - 1721425; int year = n / 365;  int temp; while ((temp = year * 365 + year / 4 - year / 100 + year / 400) >= n) { --year; }  n -= temp; ++year;  if ((year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0))) { if (n > 60) { ++n; } } else { if (n > 59) { n += 2; } }  n += 91; int month = (n * 100) / 3055; int day = n - (month * 3055) / 100; month -= 2;  return LocalDate.of(year, month, day); } catch (Exception e) { throw new TransformationException("Error transforming component value to model value"); } }
[*] target: assertEquals(expectedDate, result)
[-] pred: org. junit. Assert. assertEquals ( expectedDate, result )
************************************
************************************
[+] input: withMultipleUpperBounds() { TypeParameter typeParameter = T.extending(COMPARABLE.with(T), SERIALIZABLE); String toVerify = generateFrom(typeParameter); String expected = "T extends java.lang.Comparable<T> & java.io.Serializable"; "<AssertPlaceHolder>"; }
generateFrom(TypeParameter typeParameter) { return typeParameter(typeParameter).generate(); }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: requiresPreprocessingWithPaddingTest() { final ColumnSchema columnSchema = GeneralTestUtility.sealedColumn("source", "source", PadType.FIXED, 1); "<AssertPlaceHolder>"; }
requiresPreprocessing() { boolean requiresPreprocessing = pad != null && pad.requiresPreprocessing(); requiresPreprocessing |= type != ColumnType.CLEARTEXT; return requiresPreprocessing; }
[*] target: assertTrue(columnSchema.requiresPreprocessing())
[-] pred: org. junit. Assert. assertTrue ( columnSchema. requiresPreprocessing() )
************************************
************************************
[+] input: getConsumerAclsTeamsOverview_TeamIdNull() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when( handleDbRequestsJdbc.getAclsCountByTeams( AclType.CONSUMER.value, null, TestConstants.TENANT_ID)) .thenReturn(Collections.emptyList()); Mockito.when( commonUtilsService.getChartsJsOverview( eq(Collections.emptyList()), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getConsumerAclsTeamsOverview(null, TestConstants.TENANT_ID);  Assertions."<AssertPlaceHolder>"; }
getConsumerAclsTeamsOverview(Integer teamId, Integer tenantId) { List<CommonUtilsService.ChartsOverviewItem<Integer, Integer>> consumerAclsPerTeamList = manageDatabase .getHandleDbRequests() .getAclsCountByTeams(AclType.CONSUMER.value, teamId, tenantId);  String title = ANALYTICS_102; if (teamId != null) { title += " (" + manageDatabase.getTeamNameFromTeamId(tenantId, teamId) + ")"; } else { title += " (all teams)"; }  return commonUtilsService.getChartsJsOverview( consumerAclsPerTeamList, title, "teamid", "Teams", "Consumer Acls", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testNormal() { when(taskService.findOne(any(Query.class), any(UserDetail.class))).thenReturn(taskDto); List<ErrorEvent> errorEventByTaskId = taskErrorEventService.getErrorEventByTaskId(new ObjectId().toHexString(), user); Assertions."<AssertPlaceHolder>"; }
getErrorEventByTaskId(String taskId, UserDetail user) { TaskDto taskDto = taskService.findOne(Query.query(Criteria.where("_id").is(MongoUtils.toObjectId(taskId))), user); if (null == taskDto) { return Lists.newArrayList(); } return Optional.ofNullable(taskDto.getErrorEvents()).orElse(Lists.newArrayList()); }
[*] target: assertNotNull(errorEventByTaskId)
[-] pred: org. junit. Assert. assertNotNull ( errorEventByTaskId )
************************************
************************************
[+] input: Exception { final RunningJvmLoader runningJvmLoader = new RunningJvmLoader(); try (final TestJvm testJvm = TestJvm.of(SleepForeverProgram.class)) { final RunningJvm runningJvm = TestHelper.waitFor(() -> runningJvmLoader.list() .stream() .filter(r -> r.getId() .equals(String.valueOf( testJvm.getProcess() .pid()))) .findFirst() .orElse(null), 5000); final Properties properties = runningJvm.getSystemProperties(); Assertions."<AssertPlaceHolder>"; } }
getSystemProperties() throws AgentException { try { final VirtualMachine vm = VirtualMachine.attach(id); try { return vm.getSystemProperties(); } finally { vm.detach(); } } catch (AttachNotSupportedException | IOException e) { log.debug("Failed to load system properties", e); throw new AgentException(e.getMessage(), e); } }
[*] target: assertNotNull(properties)
[-] pred: org. junit. Assert. assertNotNull ( properties )
************************************
************************************
[+] input: getPartitionsEnvOverview() { ChartsJsOverview expected = new ChartsJsOverview();  Mockito.when(manageDatabase.getHandleDbRequests()).thenReturn(handleDbRequestsJdbc); Mockito.when( handleDbRequestsJdbc.getPartitionsCountByEnv( TestConstants.TEAM_ID, TestConstants.TENANT_ID)) .thenReturn(TestConstants.TOPICS_COUNT_STRING_BY_ENV_ID_INT); Mockito.when( manageDatabase.getTeamNameFromTeamId(TestConstants.TENANT_ID, TestConstants.TEAM_ID)) .thenReturn(TestConstants.TEAM_NAME); Mockito.when(manageDatabase.getEnvsOfTenantsMap()) .thenReturn(Map.of(TestConstants.TENANT_ID, List.of(TestConstants.ENV_ID))); Mockito.when( commonUtilsService.getChartsJsOverview( anyList(), anyString(), anyString(), anyString(), anyString(), eq(TestConstants.TENANT_ID))) .thenReturn(expected);  ChartsJsOverview actual = analyticsControllerService.getPartitionsEnvOverview( TestConstants.TEAM_ID, TestConstants.TENANT_ID);  Assertions."<AssertPlaceHolder>"; }
getPartitionsEnvOverview(Integer teamId, Integer tenantId) {  List<CommonUtilsService.ChartsOverviewItem<String, Integer>> partitionsCountList = manageDatabase.getHandleDbRequests().getPartitionsCountByEnv(teamId, tenantId); String title = ANALYTICS_105; if (teamId != null) { title += " (" + manageDatabase.getTeamNameFromTeamId(tenantId, teamId) + ")"; }  // tenant filtering try { List<String> allowedEnvIdList = manageDatabase.getEnvsOfTenantsMap().get(tenantId); if (partitionsCountList != null) { partitionsCountList = partitionsCountList.stream() .filter(mapObj -> allowedEnvIdList.contains(mapObj.getxValue())) .collect(Collectors.toList()); partitionsCountList = partitionsCountList.stream() .map(item -> item.transformX(x -> getEnvName(item.getxValue()))) .collect(Collectors.toList()); } } catch (Exception e) { log.error("No environments/clusters found.", e); partitionsCountList = new ArrayList<>(); }  return commonUtilsService.getChartsJsOverview( partitionsCountList, title, MapConstants.CLUSTER_KEY, "Clusters", "Partitions", tenantId); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: cptecBuscarLocalidadesPass() { CPTECCidade[] cptecCidade = BrasilAPI.cptecBuscarLocalidades("São Paulo"); "<AssertPlaceHolder>"; }
cptecBuscarLocalidades(String nomeCidade) { CPTEC[] obj = (CPTEC[]) api(CPTEC[].class, "cptec/v1/cidade/", nomeCidade); return obj != null ? (CPTECCidade[]) obj.clone() : null; }
[*] target: assertNotNull(cptecCidade)
[-] pred: org. junit. Assert. assertNotNull ( cptecCidade )
************************************
************************************
[+] input: givenStaticMethod() { String toVerify = methodReference() .withType(STRING) .withMethodName("toString") .generate();  String expected = "java.lang.String::toString";  "<AssertPlaceHolder>"; }
generate() { return objectPathOrTypeGenerator.generate() + DOUBLE_COLON + methodName; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: testQueryMonitorMetricsDataNotAvailable() {  Long monitorId = 1L;  when(realTimeDataStorage.isServerAvailable()).thenReturn(false);  List<CollectRep.MetricsData> result = warehouseService.queryMonitorMetricsData(monitorId);  "<AssertPlaceHolder>"; verify(realTimeDataStorage, never()).getCurrentMetricsData(anyLong()); }
queryMonitorMetricsData(Long monitorId);
[*] target: assertTrue(result.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( result. isEmpty ( ) )
************************************
************************************
[+] input: InterruptedException { // GIVEN var user = new User(new UserId(UUID.randomUUID())); var expectedCustomerId = new CustomerId(UUID.randomUUID()); user.setCustomerId(expectedCustomerId);  when(ctxMock.getUserService()).thenReturn(userServiceMock); doReturn(Futures.immediateFuture(user)).when(userServiceMock).findUserByIdAsync(any(), any()); when(ctxMock.getDbCallbackExecutor()).thenReturn(DB_EXECUTOR);  // WHEN var actualCustomerId = EntitiesCustomerIdAsyncLoader.findEntityIdAsync(ctxMock, user.getId()).get();  // THEN "<AssertPlaceHolder>"; }
findEntityIdAsync(TbContext ctx, EntityId originator) { switch (originator.getEntityType()) { case CUSTOMER: return Futures.immediateFuture((CustomerId) originator); case USER: return toCustomerIdAsync(ctx, ctx.getUserService().findUserByIdAsync(ctx.getTenantId(), (UserId) originator)); case ASSET: return toCustomerIdAsync(ctx, ctx.getAssetService().findAssetByIdAsync(ctx.getTenantId(), (AssetId) originator)); case DEVICE: return toCustomerIdAsync(ctx, Futures.immediateFuture(ctx.getDeviceService().findDeviceById(ctx.getTenantId(), (DeviceId) originator))); default: return Futures.immediateFailedFuture(new TbNodeException("Unexpected originator EntityType: " + originator.getEntityType())); } }
[*] target: assertEquals(expectedCustomerId, actualCustomerId)
[-] pred: org. junit. Assert. assertEquals ( expectedCustomerId, actualCustomerId )
************************************
************************************
[+] input: test_oldModelLastUpdateIsNull() { try (MockedStatic<MetaDataBuilderUtils> mockedStatic = Mockito.mockStatic(MetaDataBuilderUtils.class)){ mockedStatic.when(()->MetaDataBuilderUtils.generateQualifiedName(any(),any(DataSourceConnectionDto.class),any())).thenReturn("test-qualified"); List<MetadataInstancesDto> input = new ArrayList<>(); MetadataInstancesDto metadataInstancesDto = new MetadataInstancesDto(); metadataInstancesDto.setMetaType("test"); metadataInstancesDto.setOriginalName("test"); metadataInstancesDto.setLastUpdate(0L); input.add(metadataInstancesDto); List<MetadataInstancesDto> oldMetadataInstances = new ArrayList<>(); MetadataInstancesDto old = new MetadataInstancesDto(); old.setQualifiedName("test-qualified"); old.setMetaType("test"); old.setOriginalName("test"); old.setLastUpdate(null); oldMetadataInstances.add(old); when(metadataInstancesService.findAllDto(any(),any())).thenReturn(oldMetadataInstances); List<MetadataInstancesDto> result = metadataUtil.modelNext(input,mock(DataSourceConnectionDto.class),"test",mock(UserDetail.class),false); Assertions."<AssertPlaceHolder>"; } }
modelNext(List<MetadataInstancesDto> newModels, DataSourceConnectionDto connection, String databaseId, UserDetail user,Boolean partLoad) { if (newModels == null || connection == null) { log.info("Finished update new models, newModels = {}, connection = {}", newModels == null ? "" : newModels.size(), connection); return Lists.newArrayList(); }   Map<String, String> newModelMap = newModels.stream().collect(Collectors.toMap(MetadataInstancesDto::getOriginalName , m -> MetaDataBuilderUtils.generateQualifiedName(m.getMetaType(), connection, m.getOriginalName()))); Criteria criteria = Criteria.where("qualified_name").in(newModelMap.values()); List<MetadataInstancesDto> metadataInstancesDtos = metadataInstancesService.findAllDto(new Query(criteria), user);  Map<String, MetadataInstancesDto> oldModeMap = metadataInstancesDtos.stream().collect(Collectors.toMap(MetadataInstancesDto::getQualifiedName, m -> m));   List<MetadataInstancesDto> newModelList = new ArrayList<>(); for (MetadataInstancesDto newModel : newModels) {  MetadataInstancesDto oldModel = oldModeMap.get(newModelMap.get(newModel.getOriginalName()));  if (oldModel != null && CollectionUtils.isNotEmpty(oldModel.getFields()) && CollectionUtils.isNotEmpty(newModel.getFields())) { newModel.setName(StringUtils.isNotBlank(oldModel.getName()) ? oldModel.getName() : ""); //newModel.setComment(StringUtils.isNotBlank(oldModel.getComment()) ? oldModel.getComment() : ""); oldModel.setVersionTime(new Date());  newModel.setHistories(oldModel.getHistories()); addHistory(oldModel.getId(), newModel, oldModel, user, false);  }  if (CollectionUtils.isNotEmpty(newModel.getFields())) { for (Field field : newModel.getFields()) { if (field.getIsAutoAllowed() == null) { field.setIsAutoAllowed(true); } if (field.getSource() == null) { field.setSource("auto"); } } }  if (oldModel != null && CollectionUtils.isNotEmpty(oldModel.getFields())) { for (Field field : oldModel.getFields()) { if (field.getIsAutoAllowed() == null) { field.setIsAutoAllowed(true); } if (field.getSource() == null) { field.setSource("auto"); } } } if(partLoad || null == oldModel || (newModel.getLastUpdate() != null && oldModel.getLastUpdate() != null && newModel.getLastUpdate() >= oldModel.getLastUpdate())){ newModel = MetaDataBuilderUtils.build(newModel.getMetaType(), connection, user.getUserId(), user.getUsername(), newModel.getOriginalName(), newModel, oldModel, databaseId, null, newModelMap); newModelList.add(newModel); } }  return newModelList; }
[*] target: assertEquals(0,result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: combineAndLiftResults() { Function<Random, PokemonCard> randomPokemonCard = Functions.<Random>resultsInstance().lift(PokemonCard::new).apply( oneOf("Bulbasaur", "Charmander", "Squirtle"), oneOf(30, 40, 60), oneOf(EnergyType.values()), listOf( 1, 2, Functions.<Random>resultsInstance().combine( listOf(1, 2, EnergyType.values()), oneOf("Bubble", "Withdraw", "Ember", "Razor Leaf"), oneOf(10, 20, 30), Move::new ) ) ); PokemonCard toVerify = randomPokemonCard.apply(new Random(43)); PokemonCard expected = PokemonCard.of( "Bulbasaur", 60, EnergyType.PSYCHIC, asList( Move.of(asList(EnergyType.LIGHTNING, EnergyType.COLORLESS), "Bubble", 20), Move.of(asList(EnergyType.GRASS), "Withdraw", 30) ) ); "<AssertPlaceHolder>"; }
resultsInstance() { return (Results<P>) RESULT_INSTANCE; }
[*] target: assertEquals(expected, toVerify)
[-] pred: org. junit. Assert. assertEquals ( expected, toVerify )
************************************
************************************
[+] input: test() { //when this.registerPage.insertEmailToRegister();  //then String expected = "camila002@email.com"; String actual = this.registerPage.getEmailNewAccount(); Assertions."<AssertPlaceHolder>"; }
getEmailNewAccount() { super.waitVisibilityOfElementLocated(alertAdditionalInformationLocator); return super.getTextByAttribute(this.emailLocator, "value"); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testCheckWhenDifferentDeptId() { SingleDeptDataPermissionChecker checker = new SingleDeptDataPermissionChecker(deptService); when(loginUser.getDeptId()).thenReturn(1L); DataCondition dataCondition = new DataCondition(); dataCondition.setTargetUserId(2L);  boolean check = checker.check(loginUser, dataCondition);  "<AssertPlaceHolder>"; }
check(SystemLoginUser loginUser, DataCondition condition) { if (condition == null || loginUser == null) { return false; }  if (loginUser.getDeptId() == null || condition.getTargetDeptId() == null) { return false; }  Long currentDeptId = loginUser.getDeptId(); Long targetDeptId = condition.getTargetDeptId();  return Objects.equals(currentDeptId, targetDeptId); }
[*] target: assertFalse(check)
[-] pred: org. junit. Assert. assertFalse ( check )
************************************
************************************
[+] input: done() { ResponseFutureWrapper responseFutureWrapper = new ResponseFutureWrapper("Test"); responseFutureWrapper.done(); "<AssertPlaceHolder>"; }
isDone() { return true; }
[*] target: assertTrue(responseFutureWrapper.isDone())
[-] pred: org. junit. Assert. assertTrue ( responseFutureWrapper. isDone() )
************************************
************************************
[+] input: testSaveClusterGroup() { // Setup final Result expectedResult = new Result(); expectedResult.setCode(0); expectedResult.setMsg("msg"); expectedResult.setData("data");  // Configure ClusterHostService.getHostListByClusterId(...). final ClusterHostEntity clusterHostEntity = new ClusterHostEntity(); clusterHostEntity.setId(0); clusterHostEntity.setCreateTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterHostEntity.setHostname("hostname"); clusterHostEntity.setIp("ip"); clusterHostEntity.setRack("rack"); clusterHostEntity.setCoreNum(0); clusterHostEntity.setTotalMem(0); clusterHostEntity.setTotalDisk(0); clusterHostEntity.setUsedMem(0); clusterHostEntity.setUsedDisk(0); clusterHostEntity.setAverageLoad("averageLoad"); clusterHostEntity.setCheckTime(new GregorianCalendar(2020, Calendar.JANUARY, 1).getTime()); clusterHostEntity.setClusterId(0); clusterHostEntity.setHostState(0); clusterHostEntity.setManaged(MANAGED.YES); final List<ClusterHostEntity> clusterHostEntities = Arrays.asList(clusterHostEntity); when(mockHostService.getHostListByClusterId(0)).thenReturn(clusterHostEntities);  // Run the test final Result result = clusterGroupServiceImplUnderTest.saveClusterGroup(0, "groupName");  // Verify the results "<AssertPlaceHolder>"; }
saveClusterGroup(Integer clusterId, String groupName) { if (hasRepeatGroupName(clusterId, groupName)) { return Result.error(Status.GROUP_NAME_DUPLICATION.getMsg()); } ClusterGroup clusterGroup = new ClusterGroup(); clusterGroup.setClusterId(clusterId); clusterGroup.setGroupName(groupName); this.save(clusterGroup);  List<ClusterHostDO> hostList = hostService.getHostListByClusterId(clusterId); for (ClusterHostDO clusterHost : hostList) { ActorRef unixGroupActor = ActorUtils.getRemoteActor(clusterHost.getHostname(), "unixGroupActor"); CreateUnixGroupCommand createUnixGroupCommand = new CreateUnixGroupCommand(); createUnixGroupCommand.setGroupName(groupName); Timeout timeout = new Timeout(Duration.create(180, TimeUnit.SECONDS)); Future<Object> execFuture = Patterns.ask(unixGroupActor, createUnixGroupCommand, timeout); ExecResult execResult = null; try { execResult = (ExecResult) Await.result(execFuture, timeout.duration()); if (execResult.getExecResult()) { logger.info("create unix group success at {}", clusterHost.getHostname()); } else { logger.info(execResult.getExecOut()); throw new ServiceException(500, "create unix group " + groupName + " failed at " + clusterHost.getHostname()); } } catch (Exception e) { throw new ServiceException(500, "create unix group " + groupName + " failed at " + clusterHost.getHostname()); } }  return Result.success(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testStripQuotesNoQuotes() { String input = "/home/user/file.txt"; Path expected = Paths.get(input); Path result = PathUtil.stripQuotes(input);  "<AssertPlaceHolder>"; }
stripQuotes(String path) { return Paths.get(stripQuotesAtStartAndEnd(path)); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************

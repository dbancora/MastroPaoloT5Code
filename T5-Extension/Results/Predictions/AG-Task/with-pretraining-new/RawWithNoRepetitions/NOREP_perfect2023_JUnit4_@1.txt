[+] input: Exception { q = new FIFORevQueue(AbstractRevQueue.EMPTY_QUEUE); "<AssertPlaceHolder>"; }
[*] target: assertNull(q.next())
[-] pred: org. junit. Assert. assertNull ( q. next() )
************************************
[+] input: test_findByUpdateTimeBefore_return1() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.PRIVATE); repository.save(connection); List<ConnectionEntity> entities = repository.findByUpdateTimeBefore(new Date(new Date().getTime() + 5 * 1000L)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(1, entities.size())
[-] pred: org. junit. Assert. assertEquals ( 1, entities. size ( ) )
************************************
[+] input: Exception { write(new File(db.getWorkTree(), "test.txt"), "0\n1\n2\n3\n4\n5\n6\n7\n8\n9"); try (Git git = new Git(db)) { git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); write(new File(db.getWorkTree(), "test.txt"), "0\n1\n2\n3\n4a\n5\n6\n7\n8\n9");  OutputStream out = new ByteArrayOutputStream(); git.diff().setOutputStream(out).setContextLines(1).call();  String actual = out.toString(); String expected = "diff --git a/test.txt b/test.txt\n" + "index f55b5c9..c5ec8fd 100644\n" + "--- a/test.txt\n" + "+++ b/test.txt\n" + "@@ -4,3 +4,3 @@\n" + " 3\n" + "-4\n" + "+4a\n" + " 5\n"; "<AssertPlaceHolder>"; } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: testGetPushData() { ServiceInfo pushData = serviceStorage.getPushData(SERVICE);  Mockito.verify(switchDomain).getDefaultPushCacheMillis(); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(pushData)
[-] pred: org. junit. Assert. assertNotNull ( pushData )
************************************
[+] input: fromJsonList_json_null_expect_null() { List<A> aList = JsonUtils.fromJsonList(null, A.class);  Assert."<AssertPlaceHolder>"; }
[*] target: assertNull(aList)
[-] pred: org. junit. Assert. assertNull ( aList )
************************************
[+] input: generate_uniqueIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "unique (col asc id 16, col1) using index using btree global with parser 'aaaa'")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); state.setIndexOptions(indexOptions); state.setUsingIndexFlag(true); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_xmlSerializeEncodingVersion1_generateSucceed() { ExprContext context = getExprContext( "xmlSerialize(content 'aaa' as int encoding 'aaa' version 12 indent size=12 hide defaults)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlSerialize", Collections.singletonList(p1)); expect.addOption(new ConstExpression("content")); expect.addOption(new ConstExpression("encoding 'aaa'")); expect.addOption(new ConstExpression("version 12")); expect.addOption( new CompoundExpression(new ConstExpression("indent size"), new ConstExpression("12"), Operator.EQ)); expect.addOption(new ConstExpression("hide defaults")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: copy_noChanges() { final PubcompPacketImpl packet = new PubcompPacketImpl( 1, PubcompReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubcompPacketImpl modifiablePacket = new ModifiablePubcompPacketImpl(packet, configurationService);  final PubcompPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
[+] input: generate_indexPrimaryKeyNoyAlgorithmAndComment_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("primary key (col, col1)")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineConstraint expect = new OutOfLineConstraint(null, Arrays.asList(s1, s2)); expect.setPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: fromJsonList() { String json = "[{"col1":"abc"}]";  List<A> aList = JsonUtils.fromJsonList(json, A.class);  List<A> expected = new ArrayList<>(); expected.add(new A("abc")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, aList)
[-] pred: org. junit. Assert. assertEquals ( expected, aList )
************************************
[+] input: generate_indexPrimaryKey_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("primary key (col, col1) using index using btree comment 'abcd'")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setComment("'abcd'"); state.setIndexOptions(indexOptions); state.setUsingIndexFlag(true); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_columnDefConstraintState_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "tb.col varchar2(64) constraint abcd not null rely using index global storing(a,b) enable novalidate")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); ConstraintState state = new ConstraintState(); state.setRely(true); state.setUsingIndexFlag(true); IndexOptions indexOptions = new IndexOptions(); indexOptions .setStoring(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); indexOptions.setGlobal(true); state.setIndexOptions(indexOptions); state.setEnable(true); state.setValidate(false); InLineConstraint attribute = new InLineConstraint("abcd", state); attribute.setNullable(false); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { File target = dumpSchemaAndDataForLoad(DialectType.OB_ORACLE); assertOracleModeTableNotExists();  UploadFileResult actual = dataTransferService.getMetaInfo(target.getAbsolutePath()); UploadFileResult expect = new UploadFileResult(); expect.setFormat(DataFormat.SQL); expect.setFileType("ZIP"); expect.setFileName(target.getAbsolutePath()); expect.setContainsData(true); expect.setContainsSchema(true); Map<ObjectType, Set<String>> importFileNames = new HashMap<>(); importFileNames.putIfAbsent(ObjectType.TABLE, Collections.singleton(TEST_TABLE_NAME)); expect.setImportObjects(importFileNames);  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_fromSelectStatment_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select abc.* from (select * from tab order by col1 desc) as of snapshot 1 abc"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "abc", "*"); Projection p = new Projection(r, null); SelectBody fromBody = new SelectBody(Collections.singletonList( new Projection()), Collections.singletonList(new NameReference(null, "tab", null))); OrderBy orderBy = new OrderBy(false, Collections.singletonList( new SortKey(new ColumnReference(null, null, "col1"), SortDirection.DESC, null))); fromBody.setOrderBy(orderBy); FlashbackUsage flashbackUsage = new FlashbackUsage(FlashBackType.AS_OF_SNAPSHOT, new ConstExpression("1")); ExpressionReference from = new ExpressionReference(fromBody, "abc"); from.setFlashbackUsage(flashbackUsage); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testStringEmptyAndThenExecuteFail() { String word = ""; final String expect = "call"; String actual = TemplateUtils.stringEmptyAndThenExecute(word, () -> expect); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_modifyPKWithOptions_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify primary key(id) global")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<SortColumn> columns = Collections.singletonList(new SortColumn(new ColumnReference(null, null, "id"))); ConstraintState state = new ConstraintState(); IndexOptions options = new IndexOptions(); options.setGlobal(true); state.setIndexOptions(options); OutOfLineConstraint pk = new OutOfLineConstraint(state, columns); pk.setPrimaryKey(true); expect.setModifyPrimaryKey(pk); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_updateAssignmentUseDefault_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=DEFAULT, col2=1"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), null, true), new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col2")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { //        LogStorageData logStorageData = new LogStorageData(); //        logStorageData.setClusterId(120002L); //        logStorageData.setStoreId(10005L); //        logStorageData.setLogStoreName("测试logStore存储"); //        boolean table = dorisLogStorageService.deleteTable(logStorageData); //        Assert."<AssertPlaceHolder>"; //    }
[*] target: assertTrue(table)
[-] pred: org. junit. Assert. assertTrue ( table )
************************************
[+] input: Exception { final String storeDirectoryPath = stateDirectory.getAbsolutePath() + File.separator + storeName; final File storeDirectory = new File(storeDirectoryPath); //noinspection ResultOfMethodCallIgnored storeDirectory.mkdirs();  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final File oldSegment = new File(storeDirectoryPath + File.separator + storeName + ":" + segmentId * (RETENTION_PERIOD / (NUM_SEGMENTS - 1))); //noinspection ResultOfMethodCallIgnored Files.createFile(oldSegment.toPath()); }  segments.openExisting(context, -1L);  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final File newSegment = new File(storeDirectoryPath + File.separator + storeName + "." + segmentId * (RETENTION_PERIOD / (NUM_SEGMENTS - 1))); "<AssertPlaceHolder>"; } }
[*] target: assertTrue(newSegment.exists())
[-] pred: org. junit. Assert. assertTrue ( newSegment. exists ( ) )
************************************
[+] input: generate_modifyListPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition by list(a,b) (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress," + "partition values ('aaaddd') id 15 tablespace tbs)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setNoCompress(true); options1.setId(14); e2.setPartitionOptions(options1); ListPartitionElement e3 = new ListPartitionElement(null, Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); expect.setModifyPartition(new ListPartition(cols, Arrays.asList(e1, e2, e3), null, null, false)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldDeleteKeyNoPropagateV1() { final MockProcessorContext<String, SubscriptionResponseWrapper<String>> context = new MockProcessorContext<>(); processor.init(context);  final SubscriptionWrapper<String> newValue = new SubscriptionWrapper<>( new long[]{1L}, Instruction.DELETE_KEY_NO_PROPAGATE, "pk1", SubscriptionWrapper.VERSION_1, 12); final Record<CombinedKey<String, String>, Change<ValueAndTimestamp<SubscriptionWrapper<String>>>> record = new Record<>(new CombinedKey<>("fk1", "pk1"), new Change<>(ValueAndTimestamp.make(newValue, 1L), null), 1L ); processor.process(record); final List<CapturedForward<? extends String, ? extends SubscriptionResponseWrapper<String>>> forwarded = context.forwarded(); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(0, forwarded.size())
[-] pred: org. junit. Assert. assertEquals ( 0, forwarded. size ( ) )
************************************
[+] input: isODPSharding_ODP_SHARDING_OB_MYSQL_ReturnTrue() { boolean isODPSharding = ConnectType.ODP_SHARDING_OB_MYSQL.isODPSharding(); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(isODPSharding)
[-] pred: org. junit. Assert. assertTrue ( isODPSharding )
************************************
[+] input: testDefault() { DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) DefaultGrpcClientConfig.newBuilder().build(); assertNull(config.name()); assertEquals(3, config.retryTimes()); assertEquals(3000L, config.timeOutMills()); assertEquals(5000L, config.connectionKeepAlive()); assertEquals(10000L, config.threadPoolKeepAlive()); assertEquals(4, config.threadPoolCoreSize()); assertEquals(16, config.threadPoolMaxSize()); assertEquals(3000L, config.serverCheckTimeOut()); assertEquals(10000, config.threadPoolQueueSize()); assertEquals(10 * 1024 * 1024, config.maxInboundMessageSize()); assertEquals(6 * 60 * 1000, config.channelKeepAlive()); assertEquals(TimeUnit.SECONDS.toMillis(20L), config.channelKeepAliveTimeout()); assertEquals(3, config.healthCheckRetryTimes()); assertEquals(3000L, config.healthCheckTimeOut()); assertEquals(5000L, config.capabilityNegotiationTimeout()); assertEquals(1, config.labels().size()); "<AssertPlaceHolder>"; }
[*] target: assertNotNull(config.tlsConfig())
[-] pred: org. junit. Assert. assertNotNull ( config. tlsConfig() )
************************************
[+] input: generate_modifyPK_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify primary key(id)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<SortColumn> columns = Collections.singletonList(new SortColumn(new ColumnReference(null, null, "id"))); OutOfLineConstraint pk = new OutOfLineConstraint(null, columns); pk.setPrimaryKey(true); expect.setModifyPrimaryKey(pk); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getStatement_createTableOracleMode_getCreateTableStmt() { AbstractSyntaxTreeFactory factory = AbstractSyntaxTreeFactories.getAstFactory(DialectType.OB_MYSQL, 0); AbstractSyntaxTree ast = factory.buildAst("create table abcd (id varchar(64))"); Statement actual = ast.getStatement(); CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: fromJsonMap_json_null_expect_null() { Map<A, A> aMap = JsonUtils.fromJsonMap(null, A.class, A.class);  Assert."<AssertPlaceHolder>"; }
[*] target: assertNull(aMap)
[-] pred: org. junit. Assert. assertNull ( aMap )
************************************
[+] input: generate_timestampLTZWithPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp(2E5) with local time zone")); DataType actual = factory.generate();  DataType expect = new TimestampType(new BigDecimal("2E5"), false, true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { String str = "http://example.com/"; URIish u = new URIish(str); assertEquals("example.com", u.getHost()); assertEquals("/", u.getPath()); assertEquals(str, u.toString());  str = "http://example.com"; u = new URIish(str); assertEquals("example.com", u.getHost()); assertEquals("", u.getPath()); "<AssertPlaceHolder>"; }
[*] target: assertEquals(str, u.toString())
[-] pred: org. junit. Assert. assertEquals ( str, u. toString ( ) )
************************************
[+] input: InterruptedException { when(localPersistence.getSession("client")).thenReturn(new ClientSession(false, 100)); when(subscriptionPersistence.removeAll("client")).thenReturn(Futures.immediateFuture(null)); final Boolean result = clientSessionPersistence.setSessionExpiryInterval("client", 0).get(); "<AssertPlaceHolder>"; verify(subscriptionPersistence).removeAll("client"); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_rollUpGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by ROLLUP(col, col1)"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();  ExpressionParam p1 = new ExpressionParam(new RelationReference("col", null)); ExpressionParam p2 = new ExpressionParam(new RelationReference("col1", null)); FunctionCall fCall = new FunctionCall("ROLLUP", Arrays.asList(p1, p2)); GroupBy expect = new GeneralGroupBy(fCall); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testClear() { final Ref master = newRef("refs/heads/master", ID_ONE); loose = toList(master);  RefMap map = new RefMap("", packed, loose, resolved); assertSame(master, map.get("refs/heads/master"));  map.clear(); assertNull(map.get("refs/heads/master")); assertTrue(map.isEmpty()); "<AssertPlaceHolder>"; }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size() )
************************************
[+] input: testRuleArrayParameter() { Map<String, Object> context = new HashMap<>(); context.put("dateArray", new Date[] {new Date(0), new Date(1000)}); boolean rst = RuleRunner.getInstance() .check( context, Lists.newArrayList( "R1 = "男女" == concat(["男", "女"])", "R2 = "123" == concat([1, 2, 3])", "R3 = "123" == concat([1L, 2L, 3L])", "R4 = "" == concat(dateArray)", "R1 && R2 && R3 && !R4"), ""); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
[+] input: InterruptedException { redisson.getKeys().flushall(); String lockId = "abcd-1234"; boolean isLocked = redisLock.acquireLock(lockId, 1000, 1000, TimeUnit.MILLISECONDS); "<AssertPlaceHolder>";  Thread.sleep(2000);  RLock lock = redisson.getLock(lockId); assertFalse(lock.isLocked()); }
[*] target: assertTrue(isLocked)
[-] pred: org. junit. Assert. assertTrue ( isLocked )
************************************
[+] input: shouldInstantiateAndConfigureDefaultHeaderConverter() { props.remove(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG); createConfig();  // Because it's not explicitly set on the supplied configuration, the logic to use the current classloader for the connector // will exit immediately, and so this method always returns null HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNull(headerConverter); // But we should always find it (or the worker's default) when using the plugins classloader ... headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertInstanceOf(SimpleHeaderConverter.class, headerConverter); }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
[+] input: generate_alterExternalTable1_succeed() { StatementFactory<AlterTable> factory = new MySQLAlterTableFactory( getAlterContext("alter external table a.b refresh")); AlterTable actual = factory.generate();  AlterTableAction a = new AlterTableAction(); a.setRefresh(true); AlterTable expect = new AlterTable("b", Collections.singletonList(a)); expect.setExternal(true); expect.setSchema("a"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getDatabase_Success() { DBDatabase database = accessor.getDatabase(getOracleSchema()); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(database.getId()); Assert.assertNotNull(database.getCharset()); Assert.assertNotNull(database.getCollation()); Assert.assertEquals(getOracleSchema(), database.getName()); }
[*] target: assertNotNull(database)
[-] pred: org. junit. Assert. assertNotNull ( database )
************************************
[+] input: generate_readWrite_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) read write"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setReadWrite(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetRolesByUserName() { Page<RoleInfo> page = embeddedRolePersistService.getRolesByUserNameAndRoleName("userName", "roleName", 1, 10);  Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(page)
[-] pred: org. junit. Assert. assertNotNull ( page )
************************************
[+] input: verifyingTopicCleanupPolicyShouldReturnFalseWhenTopicAuthorizationError() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithTopicAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
[+] input: generate_castAsNumber_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as numeric(3,2))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); NumberType type = new NumberType("numeric", new BigDecimal(3), new BigDecimal(2)); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testEncryptHandler() { Pair<String, String> pair = EncryptionHandler.encryptHandler("test-dataId", "content"); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(pair)
[-] pred: org. junit. Assert. assertNotNull ( pair )
************************************
[+] input: Exception { write(new File(db.getDirectory().getParent(), "test.txt"), "test"); File folder = new File(db.getDirectory().getParent(), "folder"); FileUtils.mkdir(folder); write(new File(folder, "folder.txt"), "folder"); try (Git git = new Git(db); ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(new BufferedOutputStream(os));) { git.add().addFilepattern(".").call(); RevCommit commit = git.commit().setMessage("Initial commit").call(); write(new File(folder, "folder.txt"), "folder change");  dfmt.setRepository(db); dfmt.setPathFilter(PathFilter.create("folder")); dfmt.format(commit.getTree().getId(), null); dfmt.flush();  String actual = os.toString("UTF-8"); String expected = "diff --git a/folder/folder.txt b/folder/folder.txt\n" + "deleted file mode 100644\n" + "index 0119635..0000000\n" + "--- a/folder/folder.txt\n" + "+++ /dev/null\n" + "@@ -1 +0,0 @@\n" + "-folder\n" + "\\ No newline at end of file\n";  "<AssertPlaceHolder>"; } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_hashPartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by hash(a) subpartition by hash(c) subpartitions 165 partitions 12 (" + "partition a.b (" + "subpartition a," + "subpartition b engine=InnoDB)," + "partition d id 14)")); Partition actual = factory.generate();  HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); SubHashPartitionElement se1 = new SubHashPartitionElement("a"); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setEngine("InnoDB"); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "hash"); subPartitionOption.setSubPartitionNum(165); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, 12); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { CreateConnectorRequest requestToWrite = new CreateConnectorRequest( CONNECTOR_NAME, CONNECTOR_CONFIG, CreateConnectorRequest.InitialState.STOPPED );  try (FileWriter writer = new FileWriter(connectorConfigurationFile)) { writer.write(new ObjectMapper().writeValueAsString(requestToWrite)); }  CreateConnectorRequest parsedRequest = connectStandalone.parseConnectorConfigurationFile(connectorConfigurationFile.getAbsolutePath()); "<AssertPlaceHolder>"; }
[*] target: assertEquals(requestToWrite, parsedRequest)
[-] pred: org. junit. Assert. assertEquals ( requestToWrite, parsedRequest )
************************************
[+] input: generate_withNamedWindow_generateSelectSucceed() { Select_stmtContext context = getSelectContext( "select col.* abc from dual window name_w as (name_spec_1 partition by 1,2,3 order by col desc rows interval 1 day FOLLOWING), name_w2 as (range 1 PRECEDING)"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); SelectBody selectBody = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); WindowSpec s1 = new WindowSpec(); s1.setName("name_spec_1"); s1.getPartitionBy().add(new ConstExpression("1")); s1.getPartitionBy().add(new ConstExpression("2")); s1.getPartitionBy().add(new ConstExpression("3")); SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); s1.setOrderBy(new OrderBy(Collections.singletonList(sortKey))); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("1"), "day")); WindowBody windowBody = new WindowBody(WindowType.ROWS, offset); s1.setBody(windowBody); Window w1 = new Window("name_w", s1);  WindowSpec s2 = new WindowSpec(); offset = new WindowOffset(WindowOffsetType.PRECEDING); offset.setInterval(new ConstExpression("1")); windowBody = new WindowBody(WindowType.RANGE, offset); s2.setBody(windowBody); Window w2 = new Window("name_w2", s2); selectBody.getWindows().add(w1); selectBody.getWindows().add(w2); Select expect = new Select(selectBody); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost"); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(ret)
[-] pred: org. junit. Assert. assertTrue ( ret )
************************************
[+] input: Exception { Callable callable = mock(Callable.class); when(callable.call()).thenThrow(new RuntimeException("test")); String actual = TemplateUtils.stringEmptyAndThenExecute(null, callable); "<AssertPlaceHolder>"; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
[+] input: testAddAggrConfigInfoOfAddNewContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and throw EmptyResultDataAccessException. when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenThrow(new EmptyResultDataAccessException(1)); //mock insert success when(jdbcTemplate.update(anyString(), eq(dataId), eq(group), eq(tenant), eq(datumId), eq(appName), eq(content), any(Timestamp.class))).thenReturn(1);  //execute boolean result = externalConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_spatialIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("spatial index using btree (col asc id 16, col1) invisible")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setVisible(false); expect.setIndexOptions(indexOptions); expect.setSpatial(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: deleteByUserId_Exists_ReturnAffectRows() { UserConfigEntity entity = createEntity(); userConfigDAO.batchUpsert(Arrays.asList(entity));  int affectRows = userConfigDAO.deleteByUserId(USER_ID);  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(1, affectRows)
[-] pred: org. junit. Assert. assertEquals ( 1, affectRows )
************************************
[+] input: testJoin() { MapperManager.join(new AbstractMapper() { @Override public String getTableName() { return "test"; }  @Override public String getDataSource() { return DataSourceConstant.MYSQL; } }); MapperManager instance = MapperManager.instance(false); Mapper mapper = instance.findMapper(DataSourceConstant.MYSQL, "test"); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(mapper)
[-] pred: org. junit. Assert. assertNotNull ( mapper )
************************************
[+] input: generate_rangePartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range columns (a,b) partitions 123(" + "partition a.b values less than (-2, maxvalue) engine=InnoDB," + "partition d values less than (func(1,2)) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement("d", Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e3.setPartitionOptions(o1); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartition expect = new RangePartition(cols, Arrays.asList(e1, e3), null, 123, true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: copy_changes() { final ConnectPacketImpl packet = new ConnectPacketImpl( MqttVersion.V_5, "clientId", false, 100, 60, 3, 1000, 10, true, true, null, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiableConnectPacketImpl modifiablePacket = new ModifiableConnectPacketImpl(packet, configurationService);  modifiablePacket.setClientId("modifiedClientId"); modifiablePacket.setCleanStart(true); modifiablePacket.setSessionExpiryInterval(60); modifiablePacket.setKeepAlive(10); modifiablePacket.setReceiveMaximum(2); modifiablePacket.setMaximumPacketSize(100); modifiablePacket.setTopicAliasMaximum(1); modifiablePacket.setRequestProblemInformation(false); modifiablePacket.setRequestResponseInformation(false); modifiablePacket.setUserName("username"); modifiablePacket.setPassword(ByteBuffer.wrap("password".getBytes())); modifiablePacket.setAuthenticationMethod("authMethod"); modifiablePacket.setAuthenticationData(ByteBuffer.wrap("authData".getBytes())); modifiablePacket.setWillPublish(new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, null, false, 10, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L)); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final ConnectPacketImpl copy = modifiablePacket.copy();  final ConnectPacketImpl expectedPacket = new ConnectPacketImpl( MqttVersion.V_5, "modifiedClientId", true, 60, 10, 2, 100, 1, false, false, "username", ByteBuffer.wrap("password".getBytes()), "authMethod", ByteBuffer.wrap("authData".getBytes()), new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, null, false, 10, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue")))); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedPacket, copy)
[-] pred: org. junit. Assert. assertEquals ( expectedPacket, copy )
************************************
[+] input: generate_weightString3Int_generateFunctionCallSucceed() { ExprContext context = getExprContext("WEIGHT_STRING('123', 1,2,3,4)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); params.add(new ExpressionParam(new ConstExpression("3"))); params.add(new ExpressionParam(new ConstExpression("4"))); FunctionCall expect = new FunctionCall("WEIGHT_STRING", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_jsonTable2_generateSucceed() { ExprContext context = getExprContext("json_table('123' format json, 'aaa' " + "error_p on error_p null on empty columns " + ""abcd" FOR ORDINALITY, " + "col1 int truncate exists path 123 asis true on empty, " + "col2 json DISALLOW SCALARS WITH CONDITIONAL ARRAY WRAPPER path col21 asis empty on empty, " + "col3 blob format json truncate allow SCALARS WITH ARRAY WRAPPER path col31 asis empty on empty, " + "col4 nchar(12) truncate path col41[*] asis default -3 on empty, " + "nested path 123 columns(col5))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'123'")); p1.addOption(new ConstExpression("format json")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("json_table", Arrays.asList(p1, p2)); JsonOnOption onOption = new JsonOnOption(); onOption.setOnError(new ConstExpression("error_p")); onOption.setOnEmpty(new NullExpression()); expect.addOption(onOption);  FunctionParam op1 = new ExpressionParam(new ColumnReference(null, null, ""abcd"")); op1.addOption(new ConstExpression("FOR ORDINALITY")); expect.addOption(op1); FunctionParam op2 = new ExpressionParam(new ColumnReference(null, null, "col1")); op2.addOption(new NumberType("int", null, null)); op2.addOption(new ConstExpression("truncate")); op2.addOption(new ConstExpression("exists")); op2.addOption(new ConstExpression("123")); onOption = new JsonOnOption(); onOption.setOnEmpty(new BoolValue(true)); op2.addOption(onOption); expect.addOption(op2); FunctionParam op3 = new ExpressionParam(new ColumnReference(null, null, "col2")); op3.addOption(new GeneralDataType("json", null)); JsonConstraint jc = new JsonConstraint(); jc.setScalarsMode(ScalarsMode.DISALLOW_SCALARS); jc.setWrapperMode(WrapperMode.WITH_CONDITIONAL_ARRAY_WRAPPER); op3.addOption(jc); op3.addOption(new ColumnReference(null, null, "col21")); onOption = new JsonOnOption(); onOption.setOnEmpty(new ConstExpression("empty")); op3.addOption(onOption); expect.addOption(op3);  FunctionParam op4 = new ExpressionParam(new ColumnReference(null, null, "col3")); op4.addOption(new GeneralDataType("blob", null)); op4.addOption(new ConstExpression("format json")); op4.addOption(new ConstExpression("truncate")); jc = new JsonConstraint(); jc.setScalarsMode(ScalarsMode.ALLOW_SCALARS); jc.setWrapperMode(WrapperMode.WITH_ARRAY_WRAPPER); op4.addOption(jc); op4.addOption(new ColumnReference(null, null, "col31")); op4.addOption(onOption); expect.addOption(op4);  FunctionParam op5 = new ExpressionParam(new ColumnReference(null, null, "col4")); op5.addOption(new CharacterType("nchar", new BigDecimal("12"))); op5.addOption(new ConstExpression("truncate")); ColumnReference rc = new ColumnReference(null, null, "col41"); CollectionExpression es = new CollectionExpression(); es.addExpression(new ConstExpression("*")); rc.reference(es, ReferenceOperator.BRACKET); op5.addOption(rc); onOption = new JsonOnOption(); onOption.setOnEmpty(new CompoundExpression(new ConstExpression("3"), null, Operator.SUB)); op5.addOption(onOption); expect.addOption(op5); FunctionParam op6 = new ExpressionParam(new ConstExpression("nested path")); op6.addOption(new ConstExpression("123")); op6.addOption(new ExpressionParam(new ColumnReference(null, null, "col5"))); expect.addOption(op6); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: base64Decode_null() { byte[] bytes = EncodeUtils.base64DecodeFromString(null); Assert."<AssertPlaceHolder>"; }
[*] target: assertNull(bytes)
[-] pred: org. junit. Assert. assertNull ( bytes )
************************************
[+] input: multipleNetaddressStrategyTest() { PlainAccessResource plainAccessResource = new PlainAccessResource(); plainAccessResource.setWhiteRemoteAddress("127.0.0.1,127.0.0.2,127.0.0.3"); RemoteAddressStrategy remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleNetaddressStrategyTest(remoteAddressStrategy);  plainAccessResource.setWhiteRemoteAddress("127.0.0.{1,2,3}"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleNetaddressStrategyTest(remoteAddressStrategy);  plainAccessResource.setWhiteRemoteAddress("192.100-150.*.*"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); plainAccessResource.setWhiteRemoteAddress("192.130.0.2"); boolean match = remoteAddressStrategy.match(plainAccessResource); Assert."<AssertPlaceHolder>";  plainAccessResource = new PlainAccessResource(); plainAccessResource.setWhiteRemoteAddress("1050::0005:0600:300c:1,1050::0005:0600:300c:2,1050::0005:0600:300c:3"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleIPv6NetaddressStrategyTest(remoteAddressStrategy);  plainAccessResource.setWhiteRemoteAddress("1050::0005:0600:300c:{1,2,3}"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleIPv6NetaddressStrategyTest(remoteAddressStrategy);  }
[*] target: assertTrue(match)
[-] pred: org. junit. Assert. assertTrue ( match )
************************************
[+] input: getIssuedAt_getJwtIssueTime_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Date issuedAt = jwtService.getIssuedAt(token); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(issuedAt)
[-] pred: org. junit. Assert. assertNotNull ( issuedAt )
************************************
[+] input: extractResponse_WithNickName_ReturnMatched() { String responseBody = "{"success":true,"errorCode":0,"data":{"username":"user1","nickName":"zhangsan"}}"; when(bastionEncryptionService.decrypt(anyString())).thenReturn(responseBody);  BastionAccount expected = new BastionAccount(); expected.setUsername("user1"); expected.setNickName("zhangsan");  BastionAccount bastionAccount = accountClient.extractResponse(responseBody);  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, bastionAccount)
[-] pred: org. junit. Assert. assertEquals ( expected, bastionAccount )
************************************
[+] input: InterruptedException { FailedLoginAttemptLimiter limiter = new FailedLoginAttemptLimiter(1, 1L);  limiter.attempt(() -> false); TimeUnit.MILLISECONDS.sleep(2L); Boolean result = limiter.attempt(() -> true);  Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: shouldOptimizeActiveTasks() { final Map<Subtopology, Set<TaskId>> tasksForTopicGroup = mkMap( mkEntry(new Subtopology(0, null), mkSet(TASK_0_0, TASK_0_1)), mkEntry(new Subtopology(1, null), mkSet(TASK_1_0, TASK_1_1)) ); final RackAwareTaskAssignor assignor = new RackAwareTaskAssignor( getClusterForAllTopics(), getTaskTopicPartitionMapForAllTasks(), mkMap(), tasksForTopicGroup, getProcessRacksForAllProcess(), mockInternalTopicManager, getRackAwareEnabledConfig(), time );  final ClientState clientState1 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1); final ClientState clientState2 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1); final ClientState clientState3 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1);  clientState1.assignActiveTasks(mkSet(TASK_0_1, TASK_1_1)); clientState2.assignActive(TASK_1_0); clientState3.assignActive(TASK_0_0);  // task_0_0 has same rack as UUID_1 // task_0_1 has same rack as UUID_2 and UUID_3 // task_1_0 has same rack as UUID_1 and UUID_3 // task_1_1 has same rack as UUID_2 // Optimal assignment is UUID_1: {0_0, 1_0}, UUID_2: {1_1}, UUID_3: {0_1} which result in no cross rack traffic final SortedMap<UUID, ClientState> clientStateMap = new TreeMap<>(mkMap( mkEntry(UUID_1, clientState1), mkEntry(UUID_2, clientState2), mkEntry(UUID_3, clientState3) )); final SortedSet<TaskId> taskIds = mkSortedSet(TASK_0_0, TASK_0_1, TASK_1_0, TASK_1_1);  assertTrue(assignor.canEnableRackAwareAssignor()); int expected = stateful ? 40 : 4; final long originalCost = assignor.activeTasksCost(taskIds, clientStateMap, trafficCost, nonOverlapCost); assertEquals(expected, originalCost);  expected = stateful ? 4 : 0; final long cost = assignor.optimizeActiveTasks(taskIds, clientStateMap, trafficCost, nonOverlapCost); "<AssertPlaceHolder>";  assertEquals(mkSet(TASK_0_0, TASK_1_0), clientState1.activeTasks()); assertEquals(mkSet(TASK_1_1), clientState2.activeTasks()); assertEquals(mkSet(TASK_0_1), clientState3.activeTasks()); }
[*] target: assertEquals(expected, cost)
[-] pred: org. junit. Assert. assertEquals ( expected, cost )
************************************
[+] input: copy_noChanges() { final PubrelPacketImpl packet = new PubrelPacketImpl( 1, PubrelReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubrelPacketImpl modifiablePacket = new ModifiablePubrelPacketImpl(packet, configurationService);  final PubrelPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
[+] input: generate_xmlSerializeEncodingVersion3_generateSucceed() { ExprContext context = getExprContext( "xmlSerialize(content 'aaa' as int encoding 'aaa' version 12 indent)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlSerialize", Collections.singletonList(p1)); expect.addOption(new ConstExpression("content")); expect.addOption(new ConstExpression("encoding 'aaa'")); expect.addOption(new ConstExpression("version 12")); expect.addOption(new ConstExpression("indent")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getResource_whenResourcePathIsNull_thenResourceIsNull() { final URL resource = ManifestUtils.getResource(HiveMQEdgeMain.class, null); "<AssertPlaceHolder>"; }
[*] target: assertNull(resource)
[-] pred: org. junit. Assert. assertNull ( resource )
************************************
[+] input: queryByUserId_NotConfigured_Empty() { List<UserConfigEntity> entities = userConfigDAO.queryByUserId(USER_ID); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(0, entities.size())
[-] pred: org. junit. Assert. assertEquals ( 0, entities. size ( ) )
************************************
[+] input: Exception { File directory = createTempDirectory("testInitRepository"); InitCommand command = new InitCommand(); command.setDirectory(directory); command.setInitialBranch("main"); command.setInitialBranch(null); try (Git git = command.call()) { Repository r = git.getRepository(); "<AssertPlaceHolder>"; assertEquals("refs/heads/master", r.getFullBranch()); } }
[*] target: assertNotNull(r)
[-] pred: org. junit. Assert. assertNotNull ( r )
************************************
[+] input: ParseException { String dateStr = "02/21/2007"; Date exp = SystemReader.getInstance().getSimpleDateFormat("MM/dd/yyyy") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
[+] input: testContainsAny() { RuleExprParser ruleExprParser = new RuleExprParser(); Expr e = ruleExprParser.parse( "contains_any(s.entity, ["包膜"]) " + "and contains_any(s.inspection, ["MRI", "CT", "PETCT", "PETMRI"]) " + "and contains_any(s.status, ["完整"]) " + "and " + "not contains_any(s.status, ["无", "不", "未见"])");  Expr2QlexpressTransformer transformer = new Expr2QlexpressTransformer(RuleRunner::convertPropertyName);  List<String> rules = Lists.newArrayList(JavaConversions.asJavaCollection(transformer.transform(e))); Map<String, Object> context = new HashMap<>(); context.put("l", Lists.newArrayList("a", "b", "c")); context.put( "s", new HashMap<String, String>() { { put("entity", "包膜"); put("inspection", "MRI"); put("status", "完整"); } });  boolean rst = RuleRunner.getInstance().check(context, rules, ""); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
[+] input: generate_columnProjectionWithLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col label from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new ColumnReference(null, null, "col"), "label"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testDetailConfigHistory() { long nid = 256789;  //mock query ConfigHistoryInfo mockConfigHistoryInfo = createMockConfigHistoryInfo(0); Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {nid}), eq(HISTORY_DETAIL_ROW_MAPPER))) .thenReturn(mockConfigHistoryInfo); //execute & verify ConfigHistoryInfo historyReturn = embeddedHistoryConfigInfoPersistService.detailConfigHistory(nid); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(mockConfigHistoryInfo, historyReturn)
[-] pred: org. junit. Assert. assertEquals ( mockConfigHistoryInfo, historyReturn )
************************************
[+] input: generate_relationRelationKeyword_generateSucceed() { ExprContext context = getExprContext("chz.tab.BEFORE"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference("chz", "tab", "BEFORE"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: createIfNotExists_NotExists_ReturnNotNull() { Organization created = organizationService.createIfNotExists("123", "name123"); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(created)
[-] pred: org. junit. Assert. assertNotNull ( created )
************************************
[+] input: generate_withColumnGroup_customGroup_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(g1(id))"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); List<String> columnNames = Collections.singletonList("id"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement("g1", columnNames))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testParameter() { ConfigContext context = new ConfigContext(); String key = "key"; String v = "v"; context.setParameter(key, v);  String actual = (String) context.getParameter(key);  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(v, actual)
[-] pred: org. junit. Assert. assertEquals ( v, actual )
************************************
[+] input: listTableIndex_get_all_index_in_schema_Success() { Map<String, List<DBTableIndex>> map = accessor.listTableIndexes(getMySQLDataBaseName()); Assert."<AssertPlaceHolder>"; Assert.assertTrue(map.size() > 0); }
[*] target: assertNotNull(map)
[-] pred: org. junit. Assert. assertNotNull ( map )
************************************
[+] input: generate_valuesStatementOrderByLimit_generateSelectSucceed() { String sql = "values row(1, '2'), row(2, '3') order by 1 desc limit 3"; Select_stmtContext context = getSelectContext(sql); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); values.add(Arrays.asList(new ConstExpression("2"), new ConstExpression("'3'"))); SelectBody body = new SelectBody(values); SortKey s1 = new SortKey(new ConstExpression("1"), SortDirection.DESC, null); OrderBy orderBy = new OrderBy(false, Collections.singletonList(s1)); body.setOrderBy(orderBy); Limit limit = new Limit(new ConstExpression("3")); body.setLimit(limit); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testPollBatch() { try { ClosableBlockingQueue<String> queue = new ClosableBlockingQueue<>();  assertNull(queue.pollBatch());  queue.add("a"); queue.add("b");  assertEquals(asList("a", "b"), queue.pollBatch()); assertNull(queue.pollBatch());  queue.add("c");  assertEquals(singletonList("c"), queue.pollBatch()); "<AssertPlaceHolder>";  assertTrue(queue.close());  try { queue.pollBatch(); fail("should cause an exception"); } catch (IllegalStateException ignored) { // expected } } catch (Exception e) { e.printStackTrace(); fail(e.getMessage()); } }
[*] target: assertNull(queue.pollBatch())
[-] pred: org. junit. Assert. assertNull ( queue. pollBatch ( ) )
************************************
[+] input: testTypeWeightFilterSampleByWeight() { AbstractResult indexResult = new CommonResult(typeIndex, Arrays.asList(0, 2, 4, 5, 6, 9));  String sampleMeta = "topk(by=weight, limit=3, reverse=false, replacement=false)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(0, 2, 4); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_hashPartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) partitions 12 (" + "partition a.b@c (" + "subpartition a.b pctfree=13," + "subpartition b pctused 14)," + "partition d id 14) noCompress")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); PartitionOptions o1 = new PartitionOptions(); o1.setPctFree(13); se1.setPartitionOptions(o1); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setPctUsed(14); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o4 = new PartitionOptions(); o4.setId(14); e2.setPartitionOptions(o4); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2), null, 12); PartitionOptions o3 = new PartitionOptions(); o3.setNoCompress(true); expect.setPartitionOptions(o3); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_fromSelectStatment_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select abc.* from (select * from tab order by col1 desc) as of scn 1 abc"); StatementFactory<Select> factory = new OracleSelectFactory(context); Select actual = factory.generate();  RelationReference r = new RelationReference("abc", new RelationReference("*", null)); Projection p = new Projection(r, null); SelectBody fromBody = new SelectBody(Collections.singletonList( new Projection()), Collections.singletonList(new NameReference(null, "tab", null))); OrderBy orderBy = new OrderBy(false, Collections.singletonList( new SortKey(new RelationReference("col1", null), SortDirection.DESC, null))); fromBody.setOrderBy(orderBy); FlashbackUsage flashbackUsage = new FlashbackUsage(FlashBackType.AS_OF_SCN, new ConstExpression("1")); ExpressionReference from = new ExpressionReference(fromBody, "abc"); from.setFlashbackUsage(flashbackUsage); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetByteN() { byte src = 120; byte dest = 0; for (int i = 0; i < 64; i++) { int a = BytesUtils.getByteN(src, i); dest = BytesUtils.setByteN(dest, i, a); } "<AssertPlaceHolder>"; }
[*] target: assertEquals(src, dest)
[-] pred: org. junit. Assert. assertEquals ( src, dest )
************************************
[+] input: extractResponse_WithoutNickName_ReturnUsernameAsNickName() { BastionAccount expected = new BastionAccount(); expected.setUsername("user1"); expected.setNickName("user1");  String responseBody = "{"success":true,"errorCode":0,"data":{"username":"user1"}}"; BastionAccount bastionAccount = accountClient.extractResponse(responseBody);  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, bastionAccount)
[-] pred: org. junit. Assert. assertEquals ( expected, bastionAccount )
************************************
[+] input: generate_columnDefCheckConstraint_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "tb.col varchar2(64) constraint abcd check(true) rely using index global storing(a,b) enable novalidate")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); ConstraintState state = new ConstraintState(); state.setRely(true); state.setUsingIndexFlag(true); IndexOptions indexOptions = new IndexOptions(); indexOptions .setStoring(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); indexOptions.setGlobal(true); state.setIndexOptions(indexOptions); state.setEnable(true); state.setValidate(false); InLineConstraint attribute = new InLineCheckConstraint("abcd", state, new BoolValue(true)); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetAllWorkflowDefsLatestVersions() { WorkflowDef def = new WorkflowDef(); def.setName("test1"); def.setVersion(1); def.setDescription("description"); def.setCreatedBy("unit_test"); def.setCreateTime(1L); def.setOwnerApp("ownerApp"); def.setUpdatedBy("unit_test2"); def.setUpdateTime(2L); metadataDAO.createWorkflowDef(def);  def.setName("test2"); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def);  def.setName("test3"); def.setVersion(1); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def); def.setVersion(3); metadataDAO.createWorkflowDef(def);  // Placed the values in a map because they might not be stored in order of defName. // To test, needed to confirm that the versions are correct for the definitions. Map<String, WorkflowDef> allMap = metadataDAO.getAllWorkflowDefsLatestVersions().stream() .collect(Collectors.toMap(WorkflowDef::getName, Function.identity()));  "<AssertPlaceHolder>"; assertEquals(4, allMap.size()); assertEquals(1, allMap.get("test1").getVersion()); assertEquals(2, allMap.get("test2").getVersion()); assertEquals(3, allMap.get("test3").getVersion()); }
[*] target: assertNotNull(allMap)
[-] pred: org. junit. Assert. assertNotNull ( allMap )
************************************
[+] input: testEquals() { ServerConfigAbility ability = new ServerConfigAbility(); ability.setSupportRemoteMetrics(true); assertEquals(ability, ability); assertFalse(ability.equals(null)); assertFalse(ability.equals(new ClientConfigAbility())); ServerConfigAbility newOne = new ServerConfigAbility(); assertNotEquals(ability, newOne); newOne.setSupportRemoteMetrics(true); "<AssertPlaceHolder>"; }
[*] target: assertEquals(ability, newOne)
[-] pred: org. junit. Assert. assertEquals ( ability, newOne )
************************************
[+] input: testWeightFilterSampleByTimestamp() { AbstractResult indexResult = new RangeResult(weightIndex, Collections.singletonList(new RangeUnit(1, 8)));  String sampleMeta = "topk(by=time, limit=5, reverse=false, replacement=false)"; TopKSampler<Long> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(8, 7, 6, 5, 4);  "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_duplicateScope_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) duplicate_scope='abcd'"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setDuplicateScope("'abcd'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testSchemaDeserialize() { StandardStructObjectInspector schemaObjectInspector = ObjectInspectorFactory.getStandardStructObjectInspector( Arrays.asList("0:col1", "1:col2"), Arrays.asList( PrimitiveObjectInspectorFactory.writableLongObjectInspector, PrimitiveObjectInspectorFactory.writableStringObjectInspector));  Deserializer deserializer = new Deserializer.Builder() .schema(CUSTOMER_SCHEMA) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(CUSTOMER_SCHEMA)) .sourceInspector(schemaObjectInspector) .build();  Record expected = GenericRecord.create(CUSTOMER_SCHEMA); expected.set(0, 1L); expected.set(1, "Bob");  Record actual = deserializer.deserialize(new Object[] {new LongWritable(1L), new Text("Bob")});  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: getWeekday_Tuesday_2() { // 周二 DateTime233 of = DateTime233.of("2023-01-10 09:00:00", "yyyy-MM-dd HH:mm:ss"); int weekDay = of.getWeekDay(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(2, weekDay)
[-] pred: org. junit. Assert. assertEquals ( 2, weekDay )
************************************
[+] input: testFillTo0() { final IntList i = new IntList(); i.fillTo(0, Integer.MIN_VALUE); "<AssertPlaceHolder>"; }
[*] target: assertEquals(0, i.size())
[-] pred: org. junit. Assert. assertEquals ( 0, i. size() )
************************************
[+] input: generate_modifyPartitionAddRangeSubPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition a.b add " + "subpartition a.b values less than (+3) storage(next 12 initial 15 minextents 16 maxextents 17)," + "subpartition b values less than (maxvalue) tablespace tbs")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setStorage(Arrays.asList("next 12", "initial 15", "minextents 16", "maxextents 17")); se1.setPartitionOptions(sop1); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setTableSpace("tbs"); se2.setPartitionOptions(sop2); RelationFactor factor = new RelationFactor("b"); factor.setSchema("a"); expect.addSubpartitionElements(factor, Arrays.asList(se1, se2)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: convert_jsonToXml() { String json = "{"bookstore":{"book":{"author":"odc","price":99.99,"title":"oceanbase"}}}"; String excepted = "<bookstore><book><author>odc</author><price>99.99</price><title>oceanbase</title></book></bookstore>"; String xml = JsonUtils.jsonToXml(json); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(excepted, xml)
[-] pred: org. junit. Assert. assertEquals ( excepted, xml )
************************************
[+] input: createBuilderWithBardHeader() { Request.Builder builder = BardUtils.createBuilderWithBardHeader(token); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(builder)
[-] pred: org. junit. Assert. assertNotNull ( builder )
************************************
[+] input: generate_columnDefsrId_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col GEOMETRYCOLLECTION srid 12")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new GeneralDataType("GEOMETRYCOLLECTION", null); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); attributes.setSrid(12); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testHandle() { MockedStatic<ConfigCacheService> configCacheServiceMockedStatic = Mockito.mockStatic(ConfigCacheService.class);  String dataId = "dataId"; String group = "group"; String tenant = "tenant"; String groupKey = GroupKey2.getKey(dataId, group, tenant); groupKey = StringPool.get(groupKey);  final String groupKeyCopy = groupKey; configCacheServiceMockedStatic.when( () -> ConfigCacheService.isUptodate(eq(groupKeyCopy), Mockito.any(), Mockito.any(), Mockito.any())) .thenReturn(false); ConfigBatchListenRequest configChangeListenRequest = new ConfigBatchListenRequest(); configChangeListenRequest.addConfigListenContext(group, dataId, tenant, " "); try { ConfigChangeBatchListenResponse configChangeBatchListenResponse = configQueryRequestHandler .handle(configChangeListenRequest, requestMeta); boolean hasChange = false; for (ConfigChangeBatchListenResponse.ConfigContext changedConfig : configChangeBatchListenResponse.getChangedConfigs()) { if (changedConfig.getDataId().equals(dataId)) { hasChange = true; break; } } "<AssertPlaceHolder>"; } catch (NacosException e) { e.printStackTrace(); } finally { configCacheServiceMockedStatic.close(); } }
[*] target: assertTrue(hasChange)
[-] pred: org. junit. Assert. assertTrue ( hasChange )
************************************
[+] input: testFindConfigInfoTags() { String dataId = "dataId1112222"; String group = "group22"; String tenant = "tenant2"; List<String> mockedTags = Arrays.asList("tags1", "tags11", "tags111"); Mockito.when(jdbcTemplate.queryForList(anyString(), eq(new Object[] {dataId, group, tenant}), eq(String.class))) .thenReturn(mockedTags);  List<String> configInfoTags = externalConfigInfoTagPersistService.findConfigInfoTags(dataId, group, tenant); Assert."<AssertPlaceHolder>";  }
[*] target: assertEquals(mockedTags, configInfoTags)
[-] pred: org. junit. Assert. assertEquals ( mockedTags, configInfoTags )
************************************
[+] input: testGetRolesByUserName() { Page<RoleInfo> userName = externalRolePersistService .getRolesByUserNameAndRoleName("userName", "roleName", 1, 10); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(userName)
[-] pred: org. junit. Assert. assertNotNull ( userName )
************************************
[+] input: testAddAggrConfigInfoOfAddNewContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and return null. Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenReturn(null); //mock insert success Mockito.when(databaseOperate.update(any(List.class))).thenReturn(true);  //execute boolean result = embededConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_defaultColumnRef_generateFunctionCallSucceed() { ExprContext context = getExprContext("default(tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("default", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_castAsDatetime_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as datetime(3))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); GeneralDataType type = new GeneralDataType("datetime", Collections.singletonList("3")); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetInstance() { AuthPluginManager instance = AuthPluginManager.getInstance();  Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
[+] input: testPrefixAndBeanNameConnectUseLine() { JoinAliasGenerator generator = new HyphenAliasGenerator(); Map<String, String> table = new HashMap<>(); table.put("users", "users-bean"); table.put("spring.users", "springUsers-bean"); table.put("spring.users.zhangsan", "springUsersZhangsan-bean");  table.forEach((key, value) -> { String alias = generator.generateAlias(key, beanName, clazz); "<AssertPlaceHolder>"; });  }
[*] target: assertEquals(value, alias)
[-] pred: org. junit. Assert. assertEquals ( value, alias )
************************************
[+] input: test_end_batch_compile() { batchCompileId = startBatchCompile(); boolean success = plService.endBatchCompile(batchCompileId); Assert."<AssertPlaceHolder>"; batchCompileId = null; }
[*] target: assertTrue(success)
[-] pred: org. junit. Assert. assertTrue ( success )
************************************
[+] input: NacosException { String dataId = "1"; String group = "2"; String content = "123"; String namespace = ""; String casMd5 = "96147704e3cb8be8597d55d75d244a02"; String type = ConfigType.getDefaultType().getType();  Mockito.when(mockWoker.publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type)) .thenReturn(true);  final boolean b = nacosConfigService.publishConfigCas(dataId, group, content, casMd5); Assert."<AssertPlaceHolder>";  Mockito.verify(mockWoker, Mockito.times(1)) .publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type); }
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
************************************
[+] input: testEncrypt() { String dataId = "cipher-mockAlgo-application"; String content = "content"; String sec = mockEncryptionPluginService.generateSecretKey(); Pair<String, String> pair = EncryptionHandler.encryptHandler(dataId, content); Assert."<AssertPlaceHolder>"; Assert.assertEquals("should return encrypted content.", mockEncryptionPluginService.encrypt(sec, content), pair.getSecond()); Assert.assertEquals("should return encrypted secret key.", mockEncryptionPluginService.encryptSecretKey(sec), pair.getFirst()); }
[*] target: assertNotNull(pair)
[-] pred: org. junit. Assert. assertNotNull ( pair )
************************************
[+] input: generate_alterColumnDropDefault_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter column a.b drop default")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); AlterColumnBehavior behavior = new AlterColumnBehavior(); expect.alterColumnBehavior(new ColumnReference(null, "a", "b"), behavior); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_countAllExprList_generateFunctionCallSucceed() { ExprContext context = getExprContext("count(unique a,b,c)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, null, "a"))); params.add(new ExpressionParam(new ColumnReference(null, null, "b"))); params.add(new ExpressionParam(new ColumnReference(null, null, "c"))); FunctionCall expect = new FunctionCall("count", params); expect.addOption(new ConstExpression("unique")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_existSelect_generateSucceed() { PredicateContext context = getPredicateContext("exists(select 1 from dual)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Projection p = new Projection(new ConstExpression("1"), null); NameReference from = new NameReference(null, "dual", null); FunctionCall expect = new FunctionCall("exists", Collections.singletonList( new ExpressionParam(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_convertAsBinary_generateFunctionCallSucceed() { ExprContext context = getExprContext("convert('abc', binary(12))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); p.addOption(new GeneralDataType("binary", Collections.singletonList("12"))); params.add(p); FunctionCall expect = new FunctionCall("convert", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testUdfQuery() { boolean rst = RuleRunner.getInstance() .check( new HashMap<>(), Lists.newArrayList("'0123456789' == concat(0,1,2,3,4,5,6,7,8,9)"), ""); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
[+] input: generate_uniqueIndexAutoPartition_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext( "unique index idx_name (col asc id 16, col1) partition by range columns(a,b) partition size 'auto' PARTITIONS AUTO")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); RangePartition p = new RangePartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")), null, null, null, true); p.setAuto(true); p.setPartitionSize(new ConstExpression("'auto'")); state.setPartition(p); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_waitDecimal_generateForUpdateSucceed() { For_update_clauseContext context = getForUpdateContext("select 1 from tab for update wait 2E2"); StatementFactory<ForUpdate> factory = new MySQLForUpdateFactory(context); ForUpdate actual = factory.generate();  ForUpdate expect = new ForUpdate(new ArrayList<>(), WaitOption.WAIT, new BigDecimal("2E2")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: copy_changes() { final ImmutableList<MqttUserProperty> list = ImmutableList.of( MqttUserProperty.of("name1", "value1"), MqttUserProperty.of("name2", "value2")); final ModifiableUserPropertiesImpl modifiableUserProperties = new ModifiableUserPropertiesImpl(list, true);  modifiableUserProperties.removeName("name1"); modifiableUserProperties.addUserProperty("name3", "value3"); final UserPropertiesImpl copy = modifiableUserProperties.copy();  final ImmutableList<MqttUserProperty> expectedList = ImmutableList.of( MqttUserProperty.of("name2", "value2"), MqttUserProperty.of("name3", "value3")); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedList, copy.asInternalList())
[-] pred: org. junit. Assert. assertEquals ( expectedList, copy. asInternalList ( ) )
************************************
[+] input: testRegister() { context.setAllowContainerOverriding(true); beanMethodContainerRegistrar.register(service, Service.class);  // mappedMethod Container<?> mappedMethod = context.getContainer("mappedMethod"); Assert."<AssertPlaceHolder>"; Assert.assertEquals("mappedMethod", mappedMethod.getNamespace());  // onoToOneMethod Container<?> onoToOneMethod = context.getContainer("onoToOneMethod"); Assert.assertNotNull(onoToOneMethod); Assert.assertEquals("onoToOneMethod", onoToOneMethod.getNamespace());  // oneToManyMethod Container<?> oneToManyMethod = context.getContainer("oneToManyMethod"); Assert.assertTrue(oneToManyMethod instanceof CacheableContainer); Assert.assertEquals("oneToManyMethod", oneToManyMethod.getNamespace()); }
[*] target: assertNotNull(mappedMethod)
[-] pred: org. junit. Assert. assertNotNull ( mappedMethod )
************************************
[+] input: ClassNotFoundException { JavaSerialization javaSerialization = new JavaSerialization();  // Test object to serialize String testString = "Hello, World!";  // Serialize the object byte[] serializedData = javaSerialization.serialize(testString);  // Deserialize the object String deserializedString = javaSerialization.deserialize(serializedData, String.class);  // Check if the original object and the deserialized object are equal Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(testString, deserializedString)
[-] pred: org. junit. Assert. assertEquals ( testString, deserializedString )
************************************
[+] input: testParseGitFileName_FailFooBar() { final FileHeader fh = data("a/foo b/bar\n-"); assertTrue(fh.parseGitFileName(0, fh.buf.length) > 0); assertNull(fh.getOldPath()); assertNull(fh.getNewPath()); "<AssertPlaceHolder>"; }
[*] target: assertFalse(fh.hasMetaDataChanges())
[-] pred: org. junit. Assert. assertFalse ( fh. hasMetaDataChanges() )
************************************
[+] input: shouldMatchPositionAfterPut() { inMemoryKeyValueStore.init((StateStoreContext) context, inMemoryKeyValueStore);  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); inMemoryKeyValueStore.put(bytesKey("key1"), bytesValue("value1")); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); inMemoryKeyValueStore.put(bytesKey("key2"), bytesValue("value2")); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); inMemoryKeyValueStore.put(bytesKey("key3"), bytesValue("value3"));  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 3L))))); final Position actual = inMemoryKeyValueStore.getPosition(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: test_exists_notExist() { Boolean exist = service.exists("notExists"); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(exist)
[-] pred: org. junit. Assert. assertFalse ( exist )
************************************
[+] input: testToByteArray() { GeometryBuffer buffer = GeometryBufferFactory.create(bufferType, 2); buffer.putByte(0, (byte) 1); buffer.putByte(1, (byte) 2); byte[] bytes = buffer.toByteArray(); "<AssertPlaceHolder>"; assertEquals((byte) 1, bytes[0]); assertEquals((byte) 2, bytes[1]); }
[*] target: assertEquals(2, bytes.length)
[-] pred: org. junit. Assert. assertEquals ( 2, bytes. length )
************************************
[+] input: Exception { ConnectResetRequest request = new ConnectResetRequest(); request.setServerIp("127.0.0.1"); request.setServerPort("8888"); request.setRequestId("1"); request.setConnectionId("11111_127.0.0.1_8888"); String json = mapper.writeValueAsString(request); Assert."<AssertPlaceHolder>"; Assert.assertTrue(json.contains(""serverIp":"127.0.0.1"")); Assert.assertTrue(json.contains(""serverPort":"8888"")); Assert.assertTrue(json.contains(""module":"internal"")); Assert.assertTrue(json.contains(""requestId":"1"")); Assert.assertTrue(json.contains(""connectionId":"11111_127.0.0.1_8888"")); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
[+] input: ParseException { String dateStr = "2007-02-21 15:35:00 +0100"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
[+] input: generate_alterIndexparallel_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter index abc parallel=13")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexParallel("abc", 13); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_exprGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by col"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();  GroupBy expect = new GeneralGroupBy(new RelationReference("col", null)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: existsByNameAndProjectId_checkTemplateExist_succeed() { create(); Boolean result = templateRepository.existsByNameAndProjectId(TEMPLATE_NAME, PROJECT_ID); "<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: shouldInstantiateAndConfigureConnectRestExtension() { props.clear(); props.put(RestServerConfig.REST_EXTENSION_CLASSES_CONFIG, TestConnectRestExtension.class.getName()); config = RestServerConfig.forPublic(null, props);  List<ConnectRestExtension> connectRestExtensions = plugins.newPlugins(config.getList(RestServerConfig.REST_EXTENSION_CLASSES_CONFIG), config, ConnectRestExtension.class); "<AssertPlaceHolder>"; assertEquals("One Rest Extension expected", 1, connectRestExtensions.size()); assertNotNull(connectRestExtensions.get(0)); assertTrue("Should be instance of TestConnectRestExtension", connectRestExtensions.get(0) instanceof TestConnectRestExtension); assertNotNull(((TestConnectRestExtension) connectRestExtensions.get(0)).configs); assertEquals(config.originals(), ((TestConnectRestExtension) connectRestExtensions.get(0)).configs); }
[*] target: assertNotNull(connectRestExtensions)
[-] pred: org. junit. Assert. assertNotNull ( connectRestExtensions )
************************************
[+] input: generate_withAliasList_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext("WITH relation_name (col1, col2) as (select * from dual) select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_existsColumnListWaitIntNum_generateForUpdateSucceed() { For_updateContext context = getForUpdateContext("select 1 from dual for update of tab.col1,tab.col2 wait 12"); StatementFactory<ForUpdate> factory = new OracleForUpdateFactory(context); ForUpdate actual = factory.generate();  ColumnReference c1 = new ColumnReference(null, "tab", "col1"); ColumnReference c2 = new ColumnReference(null, "tab", "col2"); ForUpdate expect = new ForUpdate(Arrays.asList(c1, c2), WaitOption.WAIT, BigDecimal.valueOf(12)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: IOException { File file = ResourceUtils .getResourceAsFile(ResourceUtils.class.getClassLoader(), "resource_utils_test.properties"); "<AssertPlaceHolder>"; }
[*] target: assertNotNull(file)
[-] pred: org. junit. Assert. assertNotNull ( file )
************************************
[+] input: generate_timestampDiff_generateFunctionCallSucceed() { ExprContext context = getExprContext("TIMESTAMPDIFF(DAY, tab,'12')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("DAY"))); params.add(new ExpressionParam(new ColumnReference(null, null, "tab"))); params.add(new ExpressionParam(new ConstExpression("'12'"))); FunctionCall expect = new FunctionCall("TIMESTAMPDIFF", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getConfigMeta_KeyExists_NotNull() { ConfigurationMeta configMeta = userConfigMetaService.getConfigMeta("odc.sqlexecute.default.mysqlAutoCommitMode"); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(configMeta)
[-] pred: org. junit. Assert. assertNotNull ( configMeta )
************************************
[+] input: testInstance() { EncryptionPluginManager instance = EncryptionPluginManager.instance(); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
[+] input: generate_modifyPartitionAddListSubPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition a.b add " + "subpartition a.b values (2) INITRANS 12," + "subpartition b values ('maxvalue') MAXTRANS 13")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setIniTrans(12); se1.setPartitionOptions(sop1);  SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setMaxTrans(13); se2.setPartitionOptions(sop2); RelationFactor factor = new RelationFactor("b"); factor.setSchema("a"); expect.addSubpartitionElements(factor, Arrays.asList(se1, se2)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testEquals_falseWhenCounterDifferent() { DataVersion dataVersion = new DataVersion(); DataVersion other = new DataVersion(); other.setCounter(new AtomicLong(1L)); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(dataVersion.equals(other))
[-] pred: org. junit. Assert. assertFalse ( dataVersion. equals ( other ) )
************************************
[+] input: testRejected() { HealthCheckRequest healthCheckRequest = new HealthCheckRequest(); RequestMeta requestMeta = new RequestMeta(); TpsCheckResponse tpsCheckResponse = new TpsCheckResponse(false, 5031, "rejected"); Mockito.when(tpsControlManager.check(any(TpsCheckRequest.class))).thenReturn(tpsCheckResponse); Response filterResponse = tpsControlRequestFilter.filter(healthCheckRequest, requestMeta, HealthCheckRequestHandler.class); Assert."<AssertPlaceHolder>"; Assert.assertEquals(NacosException.OVER_THRESHOLD, filterResponse.getErrorCode()); Assert.assertEquals("Tps Flow restricted:" + tpsCheckResponse.getMessage(), filterResponse.getMessage()); }
[*] target: assertNotNull(filterResponse)
[-] pred: org. junit. Assert. assertNotNull ( filterResponse )
************************************
[+] input: removeServiceSubscriber() { boolean result = abstractClient.removeServiceSubscriber(service); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_charsetAndCollation_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) default charset=utf8,collate=u8mb4,locality='abcd' force"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setLocality("'abcd' force"); tableOptions.setCharset("utf8"); tableOptions.setCollation("u8mb4"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_dropCheckConstraint_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop check abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropConstraintNames(Collections.singletonList("abcd")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: copy_changes() { final WillPublishPacketImpl packet = new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L); final ModifiableWillPublishImpl modifiablePacket = new ModifiableWillPublishImpl(packet, configurationService);  modifiablePacket.setTopic("modifiedTopic"); modifiablePacket.setQos(Qos.EXACTLY_ONCE); modifiablePacket.setPayload(ByteBuffer.wrap("modifiedPayload".getBytes())); modifiablePacket.setRetain(true); modifiablePacket.setMessageExpiryInterval(30); modifiablePacket.setPayloadFormatIndicator(PayloadFormatIndicator.UNSPECIFIED); modifiablePacket.setContentType("contentType"); modifiablePacket.setResponseTopic("responseTopic"); modifiablePacket.setCorrelationData(ByteBuffer.wrap("correlationData".getBytes())); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); modifiablePacket.setWillDelay(10); final WillPublishPacketImpl copy = modifiablePacket.copy();  final WillPublishPacketImpl expectedPacket = new WillPublishPacketImpl( "modifiedTopic", Qos.AT_LEAST_ONCE, ByteBuffer.wrap("modifiedPayload".getBytes()), true, 30, PayloadFormatIndicator.UNSPECIFIED, "contentType", "responseTopic", ByteBuffer.wrap("correlationData".getBytes()), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue"))), 10, 1234L); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedPacket, copy)
[-] pred: org. junit. Assert. assertEquals ( expectedPacket, copy )
************************************
[+] input: generate_deleteXml_generateSucceed() { Xml_functionContext context = getXmlExprContext("deletexml(1,2,3)"); OracleExpressionFactory factory = new OracleExpressionFactory(); Expression actual = factory.visit(context);  FunctionCall expect = new FunctionCall("deletexml", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")), new ExpressionParam(new ConstExpression("3")))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: parserAnonymousBlock_callProcedureSucceed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_2, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("PROC"); int actual = procedureCall.getCallLine(); int expect = 6; Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: parserAnonymousBlock_callProcedure_4_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_6, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("TEST_CASE_CURSOR"); int actual = procedureCall.getCallLine(); int expect = 5; Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_rangePartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by range(a,b) (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress," + "partition values less than (func(1,2)) id 15 tablespace tbs)")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement(null, Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); RangePartition expect = new RangePartition(cols, Arrays.asList(e1, e2, e3), null, null, false); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { write(new File(db.getDirectory().getParent(), "test.txt"), "test"); File folder = new File(db.getDirectory().getParent(), "folder"); FileUtils.mkdir(folder); write(new File(folder, "folder.txt"), "folder"); try (Git git = new Git(db); ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(new BufferedOutputStream(os))) { git.add().addFilepattern(".").call(); RevCommit commit = git.commit().setMessage("Initial commit").call(); write(new File(folder, "folder.txt"), "folder change");  dfmt.setRepository(db); dfmt.setPathFilter(PathFilter.create("folder")); dfmt.format(null, commit.getTree().getId()); dfmt.flush();  String actual = os.toString("UTF-8"); String expected = "diff --git a/folder/folder.txt b/folder/folder.txt\n" + "new file mode 100644\n" + "index 0000000..0119635\n" + "--- /dev/null\n" + "+++ b/folder/folder.txt\n" + "@@ -0,0 +1 @@\n" + "+folder\n" + "\\ No newline at end of file\n";  "<AssertPlaceHolder>"; } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_columnProjectionWithAsLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col as label from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new RelationReference("col", null), "label"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testEquals_falseWhenCounterDifferent2() { DataVersion dataVersion = new DataVersion(); DataVersion other = new DataVersion(); other.setCounter(null); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(dataVersion.equals(other))
[-] pred: org. junit. Assert. assertFalse ( dataVersion. equals ( other ) )
************************************
[+] input: generate_orderByNullsLast_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select 1 from dual order by col nulls last"); StatementFactory<OrderBy> factory = new OracleOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new RelationReference("col", null), null, SortNullPosition.LAST); OrderBy expect = new OrderBy(false, Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_createIndexWithColumnGroup_allColumns_eachColumn_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns, each column)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_countKeep_generateSucceed() { Bit_exprContext context = getBitExprContext("count(all *) keep (DENSE_RANK first order by col desc) "); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("*"))); FunctionCall expect = new FunctionCall("count", params); SortKey s0 = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.setKeep(new KeepClause("first", new OrderBy(Collections.singletonList(s0)))); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); //when boolean ret = nacosClientAuthService.login(properties); //then Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(ret)
[-] pred: org. junit. Assert. assertTrue ( ret )
************************************
[+] input: listPackages_invalidPackageList() { List<DBPLObjectIdentity> packages = accessor.listPackages(getOracleSchema()); boolean flag = false; for (DBPLObjectIdentity dbPackage : packages) { if (StringUtils.containsIgnoreCase(dbPackage.getErrorMessage(), "ORA")) { flag = true; } } Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
[+] input: generate_deleteWithoutWhereClause_1_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete tab"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: convert_xmlToJson() { String xml = "<bookstore><book><author>odc</author><price>99.99</price><title>oceanbase</title></book></bookstore>"; String excepted = "{"bookstore":{"book":{"author":"odc","price":99.99,"title":"oceanbase"}}}"; String json = JsonUtils.xmlToJson(xml); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(excepted, json)
[-] pred: org. junit. Assert. assertEquals ( excepted, json )
************************************
[+] input: generate_columnDefOrigDefaultExpr_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) orig_default current_timestamp(1)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); FunctionCall expr = new FunctionCall("current_timestamp", Collections.singletonList(new ExpressionParam(new ConstExpression("1")))); attributes.setOrigDefault(expr); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testRelativize_whitespaces() { String base = toOSPathString("/home/eclipse 3.4/runtime New_configuration/project_1"); String other = toOSPathString("/home/eclipse 3.4/runtime New_configuration/project_1/file"); String expected = "file";  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: testReceiveConfigInfoEmpty() { final Deque<Properties> q2 = new ArrayDeque<Properties>(); PropertiesListener a = new PropertiesListener() { @Override public void innerReceive(Properties properties) { q2.offer(properties); } }; a.receiveConfigInfo(""); final Properties actual = q2.poll(); Assert."<AssertPlaceHolder>"; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
[+] input: generate_uniqueIndexHashPartition_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("unique index idx_name (col asc id 16, col1) partition by hash(col)")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); HashPartition p = new HashPartition(Collections.singletonList(new ColumnReference(null, null, "col")), null, null, null); state.setPartition(p); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testInitNamespaceFromAliwareWithCloudParsing() { String expect = "aliware"; System.setProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, "true"); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); properties.setProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE, expect); String actual = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testInitNamespaceFromJvmNamespaceWithoutCloudParsing() { System.setProperty(SystemPropertyKeyConst.ANS_NAMESPACE, "ans"); String expect = "jvm_namespace"; System.setProperty(PropertyKeyConst.NAMESPACE, expect); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); properties.setProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, "false"); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, ns)
[-] pred: org. junit. Assert. assertEquals ( expect, ns )
************************************
[+] input: generate_alterIndex_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter index abc visible")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexVisibility("abc", true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_groupConcat_generateFunctionCallSucceed() { ExprContext context = getExprContext("GROUP_CONCAT(distinct tab.col, col order by col desc SEPARATOR ',')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col")));  FunctionParam p = new ExpressionParam(new ColumnReference(null, null, "col")); params.add(p); GroupConcat expect = new GroupConcat(params); expect.addOption(new ConstExpression("distinct")); SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(sortKey)); expect.addOption(orderBy); expect.addOption(new ConstExpression("SEPARATOR ','")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_columnProjectionWithAsLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select chz.tab.col as label from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new ColumnReference("chz", "tab", "col"), "label"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_createTableAsSelect_generateSucceed() { Create_table_stmtContext context = getCreateTableContext( "create table .abcd as select * from tab order by c desc fetch first 12 rows only"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(new Projection()), Collections.singletonList(from)); Select select = new Select(selectBody); select.setOrderBy(new OrderBy( Collections.singletonList(new SortKey(new RelationReference("c", null), SortDirection.DESC)))); select.setFetch( new Fetch(new ConstExpression("12"), FetchDirection.FIRST, FetchType.COUNT, FetchAddition.ONLY, null)); expect.setAs(select); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetLocalMessage_NullLocale_ReturnTemplate() { String template = "fake template"; String message = MessageTemplateProcessor.getLocalMessage(null, template); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(template, message)
[-] pred: org. junit. Assert. assertEquals ( template, message )
************************************
[+] input: IOException { final Map<TopicPartition, Long> expected = writeCheckpoint();  stateManager.initialize(); final Map<TopicPartition, Long> offsets = stateManager.changelogOffsets(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, offsets)
[-] pred: org. junit. Assert. assertEquals ( expected, offsets )
************************************
[+] input: generate_boolPriAddBoolPri_generateSucceed() { ExprContext context = getExprContext("1>2+3"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ConstExpression("1"); Expression right = new CompoundExpression(new ConstExpression("2"), new ConstExpression("3"), Operator.ADD); Expression expect = new CompoundExpression(left, right, Operator.GT); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_top_k_fre_histWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "TOP_K_FRE_HIST(5,6,7) over (name_ob partition by (1,2) order by col desc RANGE interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); params.add(new ExpressionParam(new ConstExpression("7"))); FunctionCall expect = new FunctionCall("TOP_K_FRE_HIST", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_accessFunctionWithAssign_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(p => (not a <= b) and (c != d))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new CompoundExpression( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.LE), null, Operator.NOT); Expression right = new CompoundExpression(new RelationReference("c", null), new RelationReference("d", null), Operator.NE); ParamWithAssign param1 = new ParamWithAssign("p", new CompoundExpression(left, right, Operator.AND)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testSmallCandidateSize() { AbstractResult indexResult = new RangeResult(typeIndex, Collections.singletonList(new RangeUnit(0, 3)));  String sampleMeta = "topk(by=weight, limit=5, reverse=false, replacement=False)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(0, 3, 5, 8); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: get() { RecyclebinSettings settings = recyclebinSettingsService.get(session); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(settings)
[-] pred: org. junit. Assert. assertNotNull ( settings )
************************************
[+] input: base64Encode_null() { String encoded = EncodeUtils.base64EncodeToString(null); Assert."<AssertPlaceHolder>"; }
[*] target: assertNull(encoded)
[-] pred: org. junit. Assert. assertNull ( encoded )
************************************
[+] input: generate_castAsYear_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as year(3))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam ppp = new ExpressionParam(new ConstExpression("'abc'")); GeneralDataType type = new GeneralDataType("year", Collections.singletonList("3")); ppp.addOption(type); params.add(ppp); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_withColumnGroup_customGroup_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(g1(col), g2(col, col1))")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); List<ColumnGroupElement> columnGroupElements = Arrays.asList( new ColumnGroupElement("g1", Collections.singletonList("col")), new ColumnGroupElement("g2", Arrays.asList("col", "col1"))); expect.setColumnGroupElements(columnGroupElements); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: attempt_MaxTwoSecondTrue_ReturnTrue() { FailedLoginAttemptLimiter limiter = new FailedLoginAttemptLimiter(2, 1000L);  limiter.attempt(() -> false); Boolean result = limiter.attempt(() -> true);  Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_timestampWithPrescision_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("timestamp(12)")); DataType actual = factory.generate();  DataType expect = new TimestampType(new BigDecimal("12"), false, false); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: copy_noChanges() { final WillPublishPacketImpl packet = new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L); final ModifiableWillPublishImpl modifiablePacket = new ModifiableWillPublishImpl(packet, configurationService);  final PublishPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
[+] input: generate_starProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select * from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: findIdsByVisibleScopeAndOrganizationId() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.ORGANIZATION); repository.save(connection);  Set<Long> ids = repository.findIdsByVisibleScopeAndOrganizationId( ConnectionVisibleScope.ORGANIZATION, ORGANIZATION_ID);  HashSet<Long> expected = new HashSet<>(); expected.add(connection.getId()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, ids)
[-] pred: org. junit. Assert. assertEquals ( expected, ids )
************************************
[+] input: encryptAndDecryptOkay() { String originalTxt = "whatever"; String key = "ThisIs128BitKey@"; BlowFishBytesEncryptor blowFishBytesEncryptor = new BlowFishBytesEncryptor(key); byte[] encrypt = blowFishBytesEncryptor.encrypt(originalTxt.getBytes(StandardCharsets.UTF_8)); String decrypted = new String(blowFishBytesEncryptor.decrypt(encrypt), StandardCharsets.UTF_8); "<AssertPlaceHolder>"; }
[*] target: assertEquals(originalTxt, decrypted)
[-] pred: org. junit. Assert. assertEquals ( originalTxt, decrypted )
************************************
[+] input: generate_autoPartition_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getAutoPartitionContext( "partition by range columns(a,b) partition size 'auto' PARTITIONS AUTO")); Partition actual = factory.generate();  RangePartition expect = new RangePartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")), null, null, null, true); expect.setAuto(true); expect.setPartitionSize(new ConstExpression("'auto'")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: insert_insertLabel_insertSucceed() { ConnectionLabel label = TestRandom.nextObject(ConnectionLabel.class); long actual = labelDAO.insert(label); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(1, actual)
[-] pred: org. junit. Assert. assertEquals ( 1, actual )
************************************
[+] input: sign_generateJwtToken_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(token)
[-] pred: org. junit. Assert. assertNotNull ( token )
************************************
[+] input: getIntentValue_getCameraPermissionIndex_returnCameraPermissionMessage() { Intent mockIntent = new Intent(ApplicationProvider.getApplicationContext(), GrantPermissionActivity.class); mockIntent.putExtra("permission", "grantCamera");  GrantPermissionActivity grantPermissionActivityResume = Robolectric.buildActivity(GrantPermissionActivity.class, mockIntent).create().start().resume().get(); String description = grantPermissionActivityResume.getDescriptionTextViewValue(); String actual = "Change permissions in your device’s \napp settings. Give GameFace access to \nCamera.";  "<AssertPlaceHolder>"; }
[*] target: assertEquals(actual, description)
[-] pred: org. junit. Assert. assertEquals ( actual, description )
************************************
[+] input: implies_SameResourceTypeAndId_impliesFalse() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "OWNER"); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(permission.implies(permission1))
[-] pred: org. junit. Assert. assertFalse ( permission. implies( permission1 ) )
************************************
[+] input: generate_dropIndex_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop key abc")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropIndexName("abc"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_columnDefAfter_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) after col")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); expect.setLocation(new Location("after", new ColumnReference(null, null, "col"))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: update_updateLabel_updateSucceed() { ConnectionLabel label = TestRandom.nextObject(ConnectionLabel.class); labelDAO.insert(label); label.setLabelName("new name"); label.setLabelColor("new color"); labelDAO.update(label); ConnectionLabel actual = labelDAO.get(label.getId()); label.setGmtCreated(null); label.setGmtModified(null); actual.setGmtCreated(null); actual.setGmtModified(null); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(label, actual)
[-] pred: org. junit. Assert. assertEquals ( label, actual )
************************************
[+] input: Exception { String[] lines = { "command=fetch\n", "server-option=one\n", "server-option=two\n", PacketLineIn.delimiter(), PacketLineIn.end() };  TestV2Hook testHook = new TestV2Hook(); uploadPackSetup(TransferConfig.ProtocolVersion.V2.version(), (UploadPack up) -> { up.setProtocolV2Hook(testHook); }, lines);  FetchV2Request req = testHook.fetchRequest; "<AssertPlaceHolder>"; assertEquals(2, req.getServerOptions().size()); assertThat(req.getServerOptions(), hasItems("one", "two")); }
[*] target: assertNotNull(req)
[-] pred: org. junit. Assert. assertNotNull ( req )
************************************
[+] input: generate_columnProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new RelationReference("col", null), null); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_indexColumnDescLenId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col(13) desc id 16, col1) comment 'abcd' storing(a,b) noparallel")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.DESC); s1.setLength(13); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setComment("'abcd'"); indexOptions.setNoParallel(true); indexOptions .setStoring(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { SchemaMergeOperator operator = new SchemaMergeOperator(exportOutput, "SYS", DialectType.OB_ORACLE); File dest = new File("datatransfer/temp-export/schema.sql"); operator.mergeSchemaFiles(dest, null);  Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(dest.exists())
[-] pred: org. junit. Assert. assertTrue ( dest. exists ( ) )
************************************
[+] input: test_exists_exist() { MaskingAlgorithm algorithm = createAlgorithm("test_exists", MaskingAlgorithmType.MASK, null); service.create(algorithm); Boolean exist = service.exists(algorithm.getName()); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(exist)
[-] pred: org. junit. Assert. assertTrue ( exist )
************************************
[+] input: generate_hashPartitionWithSubPartitionOptions_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) subpartition by hash(c) subpartition template(" + "subpartition a.b pctfree=13," + "subpartition b pctused 14) partitions 12 (" + "partition a.b@c (" + "subpartition a.b pctfree=13," + "subpartition b pctused 14)," + "partition d id 14) noCompress")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); PartitionOptions o1 = new PartitionOptions(); o1.setPctFree(13); se1.setPartitionOptions(o1); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setPctUsed(14); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o7 = new PartitionOptions(); o7.setId(14); e2.setPartitionOptions(o7); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "hash"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2), subPartitionOption, 12); PartitionOptions o3 = new PartitionOptions(); o3.setNoCompress(true); expect.setPartitionOptions(o3); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testDumpSnapshot() { InputStream inputStream = serviceMetadataSnapshotOperation.dumpSnapshot();  Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(inputStream)
[-] pred: org. junit. Assert. assertNotNull ( inputStream )
************************************
[+] input: generate_dotKeywordKeyword_generateSucceed() { ExprContext context = getExprContext(".BEFORE.BEFORE"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference(null, "BEFORE", "BEFORE"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_generatedColumnDefAsIdentity_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) generated always as identity " + "cycle minvalue -12 increment by 13 maxvalue 15 start with 1 " + "nomaxvalue nominvalue cycle nocycle cache 13 " + "nocache order noorder")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); SequenceOptions options = new SequenceOptions(); options.setCycle(true); options.setMinValue(new BigDecimal("-12")); options.setIncrementBy(new BigDecimal("13")); options.setMaxValue(new BigDecimal("15")); options.setStartWith(new BigDecimal("1")); options.setNoMaxValue(true); options.setNoMinValue(true); options.setCycle(true); options.setNoCycle(true); options.setCache(new BigDecimal("13")); options.setNoCache(true); options.setOrder(true); options.setNoOrder(true); GenerateOption option = new GenerateOption(options); option.setGenerateOption("always"); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: verifyingTopicCleanupPolicyShouldReturnFalseWhenBrokerVersionIsUnsupported() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithUnsupportedVersion(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
[+] input: generate_indexColumnDescNullsLast_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("index (col desc nulls last id 15, col1) pctused 14 tablespace abcd")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); s1.setId(15); s1.setDirection(SortDirection.DESC); s1.setNullPosition(SortNullPosition.LAST); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setPctUsed(14); indexOptions.setTableSpace("abcd"); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { File directory = createTempDirectory("testInitRepository"); InitCommand command = new InitCommand(); command.setDirectory(directory); command.setInitialBranch("main"); command.setInitialBranch(""); try (Git git = command.call()) { Repository r = git.getRepository(); "<AssertPlaceHolder>"; assertEquals("refs/heads/master", r.getFullBranch()); } }
[*] target: assertNotNull(r)
[-] pred: org. junit. Assert. assertNotNull ( r )
************************************
[+] input: generate_withColumnGroup_allColumns_eachColumn_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns, each column)"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_modifyListPartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("partition by list(a) partitions 145 (" + "partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); expect.setModifyPartition(new ListPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 145, false)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_orderSiblingsBy_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select 1 from dual order siblings by col desc"); StatementFactory<OrderBy> factory = new OracleOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new RelationReference("col", null), SortDirection.DESC, null); OrderBy expect = new OrderBy(true, Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_addListPartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("add partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1);  expect.setAddPartitionElements(Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_withColumnGroup_allColumns_eachColumn_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns, each column)"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_relationNameFunctionNameExprAsListNoAlias_generateFunctionCallSucceed() { ExprContext context = getExprContext("relation_name.function_name(tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("relation_name.function_name", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getExpireAt_getJwtExpirationTime_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Date expiresAt = jwtService.getExpiresAt(token); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(expiresAt)
[-] pred: org. junit. Assert. assertNotNull ( expiresAt )
************************************
[+] input: generate_complexStringLiteralExtract_generateSucceed() { ExprContext context = getExprContext("tab.col ->> _UTF8 'str'"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new ConstExpression("_UTF8 'str'"); Expression expect = new CompoundExpression(left, right, Operator.JSON_EXTRACT_UNQUOTED); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_noNameIndex_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("index (col, col1) noparallel pctfree 12")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setNoParallel(true); indexOptions.setPctFree(12); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test() { ConversionService conversionService = DefaultConversionService.getSharedInstance(); SpringConverterManager converterManager = new SpringConverterManager(conversionService); Assert.assertSame(conversionService, converterManager.getConversionService());  BiFunction<String, Integer, Integer> converter = converterManager.getConverter(String.class, Integer.class); Assert."<AssertPlaceHolder>"; Assert.assertEquals((Integer)1, converter.apply("1", 0)); Assert.assertEquals((Integer)0, converter.apply("NaN", 0)); }
[*] target: assertNotNull(converter)
[-] pred: org. junit. Assert. assertNotNull ( converter )
************************************
[+] input: generate_withCycleAliasWithoutAlias_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name as (select * from dual) search breadth first by col2 desc, col3 asc set varname cycle col2,col3 set cyclename to 'abcd' default '1234' select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setSearchMode(SearchMode.BREADTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); expect.setCycleAliasList(Arrays.asList("col2", "col3")); expect.setCycleValueSet(new SetValue("cyclename", "'abcd'", "'1234'")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_alterColumn_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter column a.b set default 12")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); AlterColumnBehavior behavior = new AlterColumnBehavior(); behavior.setDefaultValue(new ConstExpression("12")); expect.alterColumnBehavior(new ColumnReference(null, "a", "b"), behavior); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: SQLException { SingleConnectionDataSource dataSource = getDataSource(DialectType.OB_MYSQL); checkConnection(dataSource);  Connection connection = dataSource.getConnection(getUsername(DialectType.OB_MYSQL), getPassword(DialectType.OB_MYSQL)); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(connection)
[-] pred: org. junit. Assert. assertNotNull ( connection )
************************************
[+] input: generate_createIndexWithColumnGroup_allColumns_eachColumn_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns, each column)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: equalTest() { TimeRange r1 = new TimeRange(5, 8); TimeRange r2 = new TimeRange(5, 8); "<AssertPlaceHolder>"; }
[*] target: assertTrue(r1.equals(r2))
[-] pred: org. junit. Assert. assertTrue ( r1. equals ( r2 ) )
************************************
[+] input: Exception { CancelledTestMonitor m = new CancelledTestMonitor(); try (CancellableDigestOutputStream out = new CancellableDigestOutputStream( m, NullOutputStream.INSTANCE)) { byte[] KB = new byte[1024]; int triggerCancelWriteCnt = BYTES_TO_WRITE_BEFORE_CANCEL_CHECK / KB.length; for (int i = 0; i < triggerCancelWriteCnt + 1; i++) { out.write(KB); } assertTrue(out.length() > BYTES_TO_WRITE_BEFORE_CANCEL_CHECK); m.setCancelled(true);  for (int i = 0; i < triggerCancelWriteCnt - 1; i++) { out.write(KB); }  long lastLength = out.length(); assertThrows(InterruptedIOException.class, () -> { out.write(1); }); assertEquals(lastLength, out.length());  assertThrows(InterruptedIOException.class, () -> { out.write(new byte[1]); }); "<AssertPlaceHolder>"; } }
[*] target: assertEquals(lastLength, out.length())
[-] pred: org. junit. Assert. assertEquals ( lastLength, out. length() )
************************************
[+] input: testRelativize_equalPaths() { String base = toOSPathString("file:/home/eclipse/runtime-New_configuration/project_1"); String other = toOSPathString("file:/home/eclipse/runtime-New_configuration/project_1"); String expected = "";  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: test_findByExpireTimeBefore() { long currentTime = System.currentTimeMillis(); PermissionEntity entity = createPermissionEntity("query", "ODC_DATABASE:1", new Date(currentTime - 90 * 1000L)); createPermissionEntity("change", "ODC_DATABASE:2", new Date(currentTime - 30 * 1000L)); createPermissionEntity("change", "ODC_DATABASE:3", TimeUtils.getMySQLMaxDatetime()); Assert.assertEquals(3, permissionRepository.findAllNoCareExpireTime().size()); List<PermissionEntity> entities = permissionRepository.findByExpireTimeBefore(new Date(currentTime - 60 * 1000L)); Assert."<AssertPlaceHolder>"; Assert.assertEquals(entity.getId(), entities.get(0).getId()); }
[*] target: assertEquals(1, entities.size())
[-] pred: org. junit. Assert. assertEquals ( 1, entities. size ( ) )
************************************
[+] input: testDeserializeEverySupportedType() { Assume.assumeFalse( "No test yet for Hive3 (Date/Timestamp creation)", HiveVersion.min(HiveVersion.HIVE_3));  Deserializer deserializer = new Deserializer.Builder() .schema(HiveIcebergTestUtils.FULL_SCHEMA) .writerInspector( (StructObjectInspector) IcebergObjectInspector.create(HiveIcebergTestUtils.FULL_SCHEMA)) .sourceInspector(HiveIcebergTestUtils.FULL_SCHEMA_OBJECT_INSPECTOR) .build();  Record expected = HiveIcebergTestUtils.getTestRecord(); Record actual = deserializer.deserialize(HiveIcebergTestUtils.valuesForTestRecord(expected));  HiveIcebergTestUtils."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: IOException { String path = "test/payload";  Map<String, Object> payload = new HashMap<>(); payload.put("key1", "value1"); payload.put("key2", 200); byte[] payloadBytes = objectMapper.writeValueAsString(payload).getBytes(); when(externalPayloadStorage.download(path)) .thenReturn(new ByteArrayInputStream(payloadBytes));  Map<String, Object> result = externalPayloadStorageUtils.downloadPayload(path); "<AssertPlaceHolder>"; assertEquals(payload, result); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
[+] input: Exception { ComponentName cn = new ComponentName(getContext(), TEST_ACTIVITY); initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), false  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
[+] input: generate_tableMode_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) table_mode='abcd',parallel 12, noparallel"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); tableOptions.setTableMode("'abcd'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_withColumnGroup_customGroup_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(g1(id))"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); List<String> columnNames = Collections.singletonList("id"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement("g1", columnNames))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getAllPublishedService() { Collection<Service> allPublishedService = abstractClient.getAllPublishedService(); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(allPublishedService)
[-] pred: org. junit. Assert. assertNotNull ( allPublishedService )
************************************
[+] input: copy_noChanges() { final PubackPacketImpl packet = new PubackPacketImpl( 1, AckReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubackPacketImpl modifiablePacket = new ModifiablePubackPacketImpl(packet, configurationService);  final PubackPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
[+] input: testCollidingPrunedAlias() { SortedSet<PluginDesc<Converter>> converters = new TreeSet<>(); converters.add(new PluginDesc<>(CollidingConverter.class, null, PluginType.CONVERTER, CollidingConverter.class.getClassLoader())); SortedSet<PluginDesc<HeaderConverter>> headerConverters = new TreeSet<>(); headerConverters.add(new PluginDesc<>(CollidingHeaderConverter.class, null, PluginType.HEADER_CONVERTER, CollidingHeaderConverter.class.getClassLoader())); PluginScanResult result = new PluginScanResult( Collections.emptySortedSet(), Collections.emptySortedSet(), converters, headerConverters, Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet() ); Map<String, String> actualAliases = PluginUtils.computeAliases(result); Map<String, String> expectedAliases = new HashMap<>(); expectedAliases.put("CollidingConverter", CollidingConverter.class.getName()); expectedAliases.put("CollidingHeaderConverter", CollidingHeaderConverter.class.getName()); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedAliases, actualAliases)
[-] pred: org. junit. Assert. assertEquals ( expectedAliases, actualAliases )
************************************
[+] input: testEquals_falseWhenCounterDifferent3() { DataVersion dataVersion = new DataVersion(); dataVersion.setCounter(null); DataVersion other = new DataVersion(); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(dataVersion.equals(other))
[-] pred: org. junit. Assert. assertFalse ( dataVersion. equals ( other ) )
************************************
[+] input: generate_cur_time_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("CURRENT_TIME(123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("CURRENT_TIME", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: parse2_withClusterWithMultipleWhitespace_expectSuccess() { ConnectionStringParseResult expected = new ConnectionStringParseResult(); expected.setClusterName("C1"); expected.setTenantName("tenant1"); expected.setHost("127.0.0.1"); expected.setPort(2883); expected.setUsername("root"); expected.setDefaultSchema("oceanbase"); expected.setPassword("pwd");  String connStr = "obclient -h127.0.0.1  -P2883   -uroot@tenant1#C1 -Doceanbase -ppwd"; ConnectionStringParseResult result = MySQLClientArgsParser.parse2(connStr);  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
[+] input: testGetUserTenantForAcm() { String expect = "test"; System.setProperty("acm.namespace", expect); String actual = TenantUtil.getUserTenantForAcm(); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_nthValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "NTH_VALUE(5,6) from first respect nulls over (name_ob partition by (1,2) order by col desc RANGE interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); FunctionCall expect = new FunctionCall("NTH_VALUE", params); expect.addOption(new ConstExpression("from first")); expect.addOption(new ConstExpression("respect nulls")); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_updateAssignmentWithSubquery_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE tab1 SET col1 = (SELECT tab2.col1 from tab2 where tab2.col2='abcd');"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab1", null); RelationReference relationReference = new RelationReference("tab2", new RelationReference("col1", null)); Projection p = new Projection(relationReference, null); NameReference from = new NameReference(null, "tab2", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new RelationReference("tab2", new RelationReference("col2", null)); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col1")), body, false))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: implies_DifferentResourceId_impliesFalse() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("2", "ODC_PROJECT"), "DBA"); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(permission.implies(permission1))
[-] pred: org. junit. Assert. assertFalse ( permission. implies( permission1 ) )
************************************
[+] input: generate_splitPartitionList_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b values(a,b)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); actions.setListExprs(Arrays.asList(new RelationReference("a", null), new RelationReference("b", null))); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_convertAsUnsignedInteger_generateFunctionCallSucceed() { ExprContext context = getExprContext("convert('123', unsigned integer)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'123'")); p.addOption(new GeneralDataType("unsigned integer", Collections.emptyList())); params.add(p); FunctionCall expect = new FunctionCall("convert", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_weightStringBinary_generateFunctionCallSucceed() { ExprContext context = getExprContext("WEIGHT_STRING(123 AS Binary (12))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("123")); p.addOption(new GeneralDataType("Binary", Collections.singletonList("12"))); params.add(p); FunctionCall expect = new FunctionCall("WEIGHT_STRING", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldNotCheckpointOffsetsOnCommitIfEosIsEnabled() { task = createStatefulTask(createConfig(StreamsConfig.EXACTLY_ONCE_V2, "100"), true);  task.initializeIfNeeded(); task.completeRestoration(noOpResetter -> { }); task.prepareCommit(); task.postCommit(false); final File checkpointFile = new File( stateDirectory.getOrCreateDirectoryForTask(taskId), StateManagerUtil.CHECKPOINT_FILE_NAME );  "<AssertPlaceHolder>"; }
[*] target: assertFalse(checkpointFile.exists())
[-] pred: org. junit. Assert. assertFalse ( checkpointFile. exists ( ) )
************************************
[+] input: generate_characterUsingUtf8_generateFunctionCallSucceed() { ExprContext context = getExprContext("character('123', 'abc' using utf8)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); params.add(p); FunctionCall expect = new FunctionCall("character", params); expect.addOption(new ConstExpression("using utf8")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testListAllPlugins() { List<PluginInfo> expectedConnectorPlugins = Stream.of( SINK_CONNECTOR_PLUGINS, SOURCE_CONNECTOR_PLUGINS, CONVERTER_PLUGINS, HEADER_CONVERTER_PLUGINS, TRANSFORMATION_PLUGINS, PREDICATE_PLUGINS ).flatMap(Collection::stream) .map(PluginInfo::new) .distinct() .collect(Collectors.toList()); List<PluginInfo> actualConnectorPlugins = new ArrayList<>(connectorPluginsResource.listConnectorPlugins(false)); Comparator<PluginInfo> compare = Comparator.comparing(PluginInfo::className) .thenComparing(PluginInfo::type) .thenComparing(PluginInfo::version); actualConnectorPlugins.sort(compare); expectedConnectorPlugins.sort(compare); "<AssertPlaceHolder>"; verify(herder, atLeastOnce()).plugins(); }
[*] target: assertEquals(expectedConnectorPlugins, actualConnectorPlugins)
[-] pred: org. junit. Assert. assertEquals ( expectedConnectorPlugins, actualConnectorPlugins )
************************************
[+] input: Exception { try (Repository child = cloneRepository(groupADb, true); Repository dest = cloneRepository(db, true)) { StringBuilder xmlContent = new StringBuilder(); xmlContent.append("<?xml version="1.0" encoding="UTF-8"?>\n") .append("<manifest>") .append("<remote name="remote1" fetch=".." />") .append("<default revision="master" remote="remote1" />") .append("<project path="base" name="platform/base" />") .append("</manifest>"); RepoCommand cmd = new RepoCommand(dest);  IndexedRepos repos = new IndexedRepos(); repos.put("platform/base", child);  RevCommit commit = cmd .setInputStream(new ByteArrayInputStream( xmlContent.toString().getBytes(UTF_8))) .setRemoteReader(repos).setURI("platform/") .setTargetURI("platform/superproject") .setRecordRemoteBranch(true).setRecordSubmoduleLabels(true) .call();  String firstIdStr = commit.getId().name() + ":" + ".gitmodules"; commit = new RepoCommand(dest) .setInputStream(new ByteArrayInputStream( xmlContent.toString().getBytes(UTF_8))) .setRemoteReader(repos).setURI("platform/") .setTargetURI("platform/superproject") .setRecordRemoteBranch(true).setRecordSubmoduleLabels(true) .call(); String idStr = commit.getId().name() + ":" + ".gitmodules"; "<AssertPlaceHolder>"; } }
[*] target: assertEquals(firstIdStr, idStr)
[-] pred: org. junit. Assert. assertEquals ( firstIdStr, idStr )
************************************
[+] input: testNonCollidingAliases() { SortedSet<PluginDesc<SinkConnector>> sinkConnectors = new TreeSet<>(); sinkConnectors.add(new PluginDesc<>(MockSinkConnector.class, null, PluginType.SINK, MockSinkConnector.class.getClassLoader())); SortedSet<PluginDesc<SourceConnector>> sourceConnectors = new TreeSet<>(); sourceConnectors.add(new PluginDesc<>(MockSourceConnector.class, null, PluginType.SOURCE, MockSourceConnector.class.getClassLoader())); SortedSet<PluginDesc<Converter>> converters = new TreeSet<>(); converters.add(new PluginDesc<>(CollidingConverter.class, null, PluginType.CONVERTER, CollidingConverter.class.getClassLoader())); PluginScanResult result = new PluginScanResult( sinkConnectors, sourceConnectors, converters, Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet() ); Map<String, String> aliases = PluginUtils.computeAliases(result); Map<String, String> actualAliases = PluginUtils.computeAliases(result); Map<String, String> expectedAliases = new HashMap<>(); expectedAliases.put("MockSinkConnector", MockSinkConnector.class.getName()); expectedAliases.put("MockSink", MockSinkConnector.class.getName()); expectedAliases.put("MockSourceConnector", MockSourceConnector.class.getName()); expectedAliases.put("MockSource", MockSourceConnector.class.getName()); expectedAliases.put("CollidingConverter", CollidingConverter.class.getName()); expectedAliases.put("Colliding", CollidingConverter.class.getName()); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedAliases, actualAliases)
[-] pred: org. junit. Assert. assertEquals ( expectedAliases, actualAliases )
************************************
[+] input: Exception { // Generate a PQ for random 2D vectors var vectors = createRandomVectors(512, 2); var ravv = new ListRandomAccessVectorValues(vectors, 2); var pq = ProductQuantization.compute(ravv, 1, 256, false);  // Compress the vectors var compressed = pq.encodeAll(ravv); var cv = new PQVectors(pq, compressed); assertEquals(2 * Float.BYTES, cv.getOriginalSize()); assertEquals(1, cv.getCompressedSize());  // Write compressed vectors File cvFile = File.createTempFile("pqtest", ".cv"); try (var out = new DataOutputStream(new FileOutputStream(cvFile))) { cv.write(out); } // Read compressed vectors try (var in = new SimpleMappedReader(cvFile.getAbsolutePath())) { var cv2 = PQVectors.load(in, 0); "<AssertPlaceHolder>"; } }
[*] target: assertEquals(cv, cv2)
[-] pred: org. junit. Assert. assertEquals ( cv, cv2 )
************************************
[+] input: generate_addRangePartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext( "add partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1);  expect.setAddPartitionElements(Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_modifyRangePartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition by range(a,b) subpartition by range (c) (" + "partition a.b@c values less than (2, maxvalue) tablespace tbs1 compress for oltp (" + "subpartition a.b values less than (+3) storage(next 12 initial 15 minextents 16 maxextents 17)," + "subpartition b values less than (maxvalue) tablespace tbs)," + "partition d values less than (+3) id 14 nocompress)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList(new ConstExpression("2"), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setStorage(Arrays.asList("next 12", "initial 15", "minextents 16", "maxextents 17")); se1.setPartitionOptions(sop1); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setTableSpace("tbs"); se2.setPartitionOptions(sop2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "range"); expect.setModifyPartition(new RangePartition(cols, Arrays.asList(e1, e2), subPartitionOption, null, false)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_indexHash_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("index idx_name using hash (col, col1) reverse parallel=12")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingHash(true); indexOptions.setParallel(12); indexOptions.setReverse(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getSynonym_testPublicSynonymInfoForOracle() { DBSynonym synonym = accessor.getSynonym(getOracleSchema(), "PUBLIC_SYNONYM_ACCESSOR", DBSynonymType.PUBLIC); Assert."<AssertPlaceHolder>"; Assert.assertEquals(DBSynonymType.PUBLIC, synonym.getSynonymType()); Assert.assertEquals("PUBLIC_SYNONYM_ACCESSOR", synonym.getSynonymName()); }
[*] target: assertNotNull(synonym)
[-] pred: org. junit. Assert. assertNotNull ( synonym )
************************************
[+] input: testGetExpiredMetadataInfos() { Set<ExpiredMetadataInfo> expiredMetadataInfos = namingMetadataManager.getExpiredMetadataInfos();  Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(expiredMetadataInfos)
[-] pred: org. junit. Assert. assertNotNull ( expiredMetadataInfos )
************************************
[+] input: generateSyncData() { ClientSyncData clientSyncData = abstractClient.generateSyncData(); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(clientSyncData)
[-] pred: org. junit. Assert. assertNotNull ( clientSyncData )
************************************
[+] input: generate_fromTableExpr_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from table(generator(1000)) as abcd"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  FunctionCall functionCall = new FunctionCall("generator", Collections.singletonList(new ExpressionParam(new ConstExpression("1000")))); ExpressionReference expect = new ExpressionReference(functionCall, "abcd"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: parserAnonymousBlock_callFunction_2_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_5, 0); Map<String, AnonymousBlockFunctionCall> functionCallMap = result.getFunctionCallMap(); AnonymousBlockFunctionCall functionCall = functionCallMap.get("INOUT_PARAM"); int actual = functionCall.getCallLine(); int expect = 5; Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldMatchPositionAfterPut() { bytesStore.init((StateStoreContext) context, bytesStore);  final String keyA = "a"; final String keyB = "b"; final String keyC = "c";  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyA, windows[0])), serializeValue(10)); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyA, windows[1])), serializeValue(50)); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyB, windows[2])), serializeValue(100)); context.setRecordContext(new ProcessorRecordContext(0, 4, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyC, windows[3])), serializeValue(200));  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 4L))))); final Position actual = bytesStore.getPosition(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: Exception { final long segmentInterval = 60_000L; // the old segment file's naming system maxes out at 1 minute granularity.  segments = new KeyValueSegments(storeName,  METRICS_SCOPE, NUM_SEGMENTS * segmentInterval, segmentInterval);  final String storeDirectoryPath = stateDirectory.getAbsolutePath() + File.separator + storeName; final File storeDirectory = new File(storeDirectoryPath); //noinspection ResultOfMethodCallIgnored storeDirectory.mkdirs();  final SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMddHHmm"); formatter.setTimeZone(new SimpleTimeZone(0, "UTC"));  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final File oldSegment = new File(storeDirectoryPath + File.separator + storeName + "-" + formatter.format(new Date(segmentId * segmentInterval))); //noinspection ResultOfMethodCallIgnored Files.createFile(oldSegment.toPath()); }  segments.openExisting(context, -1L);  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final String segmentName = storeName + "." + (long) segmentId * segmentInterval; final File newSegment = new File(storeDirectoryPath + File.separator + segmentName); "<AssertPlaceHolder>"; } }
[*] target: assertTrue(newSegment.exists())
[-] pred: org. junit. Assert. assertTrue ( newSegment. exists ( ) )
************************************
[+] input: generate_keyPartitionWithSubPartNum_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by key () subpartition by key(c) subpartitions 123")); Partition actual = factory.generate();  SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "key"); subPartitionOption.setSubPartitionNum(123); KeyPartition expect = new KeyPartition(null, null, subPartitionOption, null); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: split_splitBySlashAndContainsMultiComment_splitSucceed() { List<String> sqls = new ArrayList<>(); sqls.add("CREATE\n" + "OR REPLACE PACKAGE BODY BASE_ACCESS_CONTROL_PKG IS\n" + "/* $Header:  BASE_ACCESS_CONTROL_PKG.bdy 3.1.0 2016/10/1 18:48:48 Midea ship $ */\n" + "BEGIN\n" + "    DBMS_OUTPUT.PUT_LINE('a');\n" + "END;\n"); sqls.add("select 1+3 from dual"); SqlCommentProcessor processor = new SqlCommentProcessor(DialectType.OB_ORACLE, true, true); processor.setDelimiter("/"); StringBuffer buffer = new StringBuffer(); List<String> actual = processor.split(buffer, String.join("/", sqls) + "/").stream().map(OffsetString::getStr).collect( Collectors.toList()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(sqls, actual)
[-] pred: org. junit. Assert. assertEquals ( sqls, actual )
************************************
[+] input: isODPSharding_OB_MYSQL_ReturnFalse() { boolean isODPSharding = ConnectType.OB_MYSQL.isODPSharding(); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(isODPSharding)
[-] pred: org. junit. Assert. assertFalse ( isODPSharding )
************************************
[+] input: testSmallCandidateSizeWithoutReplacement() { String sampleMeta = "weighted_sampler(by=weight, limit=5, replacement=false)"; WeightedSampler sampler = new WeightedSampler(new SampleCondition(sampleMeta), neighborDataset); AbstractResult indexResult = new RangeResult(weightIndex, Collections.singletonList(new RangeUnit(0, 2))); List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(0, 1, 2); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: createOKHttpClient() { OkHttpClient okHttpClient = WebUtils.okHttpClientWithTimeout(Duration.ofMinutes(10)); Assert."<AssertPlaceHolder>"; int timeout = okHttpClient.callTimeoutMillis(); Assert.assertEquals(10 * 60 * 1000, timeout); }
[*] target: assertNotNull(okHttpClient)
[-] pred: org. junit. Assert. assertNotNull ( okHttpClient )
************************************
[+] input: testInitNamespaceFromPropNamespaceWithoutCloudParsing() { System.setProperty(SystemPropertyKeyConst.ANS_NAMESPACE, "ans"); System.setProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, "false"); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); String expect = "ns1"; properties.setProperty(PropertyKeyConst.NAMESPACE, expect); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, ns)
[-] pred: org. junit. Assert. assertEquals ( expect, ns )
************************************
[+] input: testGetIntN() { int src = 54243342; int dest = 0; for (int i = 0; i < 32; i++) { int a = BytesUtils.getIntN(src, i); dest = BytesUtils.setIntN(dest, i, a); } "<AssertPlaceHolder>"; }
[*] target: assertEquals(src, dest)
[-] pred: org. junit. Assert. assertEquals ( src, dest )
************************************
[+] input: testGetAllWorkflowDefsLatestVersions() { WorkflowDef def = new WorkflowDef(); def.setName("test1"); def.setVersion(1); def.setDescription("description"); def.setCreatedBy("unit_test"); def.setCreateTime(1L); def.setOwnerApp("ownerApp"); def.setUpdatedBy("unit_test2"); def.setUpdateTime(2L); metadataDAO.createWorkflowDef(def);  def.setName("test2"); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def);  def.setName("test3"); def.setVersion(1); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def); def.setVersion(3); metadataDAO.createWorkflowDef(def);  // Placed the values in a map because they might not be stored in order of defName. // To test, needed to confirm that the versions are correct for the definitions. Map<String, WorkflowDef> allMap = metadataDAO.getAllWorkflowDefsLatestVersions().stream() .collect(Collectors.toMap(WorkflowDef::getName, Function.identity()));  "<AssertPlaceHolder>"; assertEquals(3, allMap.size()); assertEquals(1, allMap.get("test1").getVersion()); assertEquals(2, allMap.get("test2").getVersion()); assertEquals(3, allMap.get("test3").getVersion()); }
[*] target: assertNotNull(allMap)
[-] pred: org. junit. Assert. assertNotNull ( allMap )
************************************
[+] input: generate_skipIndex_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table skip_index_tbl (id varchar(64) SKIP_INDEX(MIN_MAX,SUM))"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("skip_index_tbl"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnAttributes attributes = new ColumnAttributes(); attributes.setSkipIndexTypes(Arrays.asList("MIN_MAX", "SUM")); ColumnDefinition column = new ColumnDefinition(new ColumnReference(null, null, "id"), dataType); column.setColumnAttributes(attributes); expect.setTableElements(Collections.singletonList(column)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: IOException { Map<String, String> configMap = new HashMap<>(baseServerProps());  final String logger = "a.b.c.s.W"; final String loggingLevel = "INFO"; final long lastModified = 789052637671L;  doReturn(KAFKA_CLUSTER_ID).when(herder).kafkaClusterId(); doReturn(plugins).when(herder).plugins(); expectEmptyRestExtensions(); doReturn(Collections.emptyList()).when(herder).setWorkerLoggerLevel(logger, loggingLevel); doReturn(Collections.singletonMap(logger, new LoggerLevel(loggingLevel, lastModified))).when(herder).allLoggerLevels();  server = new ConnectRestServer(null, restClient, configMap); server.initializeServer(); server.initializeResources(herder);  ObjectMapper mapper = new ObjectMapper();  URI serverUrl = server.advertisedUrl();  executePut(serverUrl, "/admin/loggers/" + logger, "{"level": "" + loggingLevel + ""}");  String responseStr = executeGet(serverUrl, "/admin/loggers");  Map<String, Object> expectedLogger = new HashMap<>(); expectedLogger.put("level", loggingLevel); expectedLogger.put("last_modified", lastModified); Map<String, Map<String, Object>> expectedLoggers = Collections.singletonMap(logger, expectedLogger); Map<String, Map<String, Object>> actualLoggers = mapper.readValue(responseStr, new TypeReference<Map<String, Map<String, Object>>>() { }); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedLoggers, actualLoggers)
[-] pred: org. junit. Assert. assertEquals ( expectedLoggers, actualLoggers )
************************************
[+] input: Exception { PowerMockito.whenNew(DefaultConnector.class).withAnyArguments().thenReturn(defaultConnector); Method methodGetObVersion = PowerMockito.method(ObConnectTemplate.class, "getObVersion"); PowerMockito.replace(methodGetObVersion).with((proxy, method, args) -> "2.4.0");  ObOperator operator = ObOperators.newMetaOperator(connectProperties.withCompatibilityMode(CompatibilityMode.MYSQL)); "<AssertPlaceHolder>"; assertNotNull(operator.cluster()); assertNotNull(operator.parameter()); }
[*] target: assertNotNull(operator)
[-] pred: org. junit. Assert. assertNotNull ( operator )
************************************
[+] input: Exception { List<RevCommit> commits = new ArrayList<>(); Git git = Git.wrap(db);  writeTrashFile("Test.txt", "Hello world"); git.add().addFilepattern("Test.txt").call(); commits.add(git.commit().setMessage("initial commit").call());  git.branchCreate().setName("branch1").call(); Ref checkedOut = git.checkout().setName("branch1").call(); assertEquals("refs/heads/branch1", checkedOut.getName()); writeTrashFile("Test1.txt", "Hello world!"); git.add().addFilepattern("Test1.txt").call(); commits.add(git.commit().setMessage("branch1 commit").call());  checkedOut = git.checkout().setName("master").call(); assertEquals("refs/heads/master", checkedOut.getName()); writeTrashFile("Test2.txt", "Hello world!!"); git.add().addFilepattern("Test2.txt").call(); commits.add(git.commit().setMessage("branch1 commit").call());  Iterator<RevCommit> log = git.log().all().call().iterator(); "<AssertPlaceHolder>"; assertTrue(commits.contains(log.next())); assertTrue(log.hasNext()); assertTrue(commits.contains(log.next())); assertTrue(log.hasNext()); assertTrue(commits.contains(log.next())); assertFalse(log.hasNext()); }
[*] target: assertTrue(log.hasNext())
[-] pred: org. junit. Assert. assertTrue ( log. hasNext ( ) )
************************************
[+] input: generate_updateWithPartitionUsage_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE schema.tab PARTITION(p1,p2) SET col=1;"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference("schema", "tab", null); nameReference.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p1", "p2"))); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { Map<String, Object> requestToWrite = new HashMap<>(); requestToWrite.put("name", CONNECTOR_NAME); requestToWrite.put("config", CONNECTOR_CONFIG);  try (FileWriter writer = new FileWriter(connectorConfigurationFile)) { writer.write(new ObjectMapper().writeValueAsString(requestToWrite)); }  CreateConnectorRequest parsedRequest = connectStandalone.parseConnectorConfigurationFile(connectorConfigurationFile.getAbsolutePath()); CreateConnectorRequest expectedRequest = new CreateConnectorRequest(CONNECTOR_NAME, CONNECTOR_CONFIG, null); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedRequest, parsedRequest)
[-] pred: org. junit. Assert. assertEquals ( expectedRequest, parsedRequest )
************************************
[+] input: aes() { String text = "abcdefg"; String key = "test"; String result = Functions.aesDecrypt(key, Functions.aesEncrypt(key, text)); "<AssertPlaceHolder>"; }
[*] target: assertEquals(text, result)
[-] pred: org. junit. Assert. assertEquals ( text, result )
************************************
[+] input: testDetailPreviousConfigHistory() { long nid = 256789; //mock query ConfigHistoryInfo mockConfigHistoryInfo = createMockConfigHistoryInfo(0); Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {nid}), eq(HISTORY_DETAIL_ROW_MAPPER))) .thenReturn(mockConfigHistoryInfo); //execute & verify ConfigHistoryInfo historyReturn = embeddedHistoryConfigInfoPersistService.detailPreviousConfigHistory(nid); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(mockConfigHistoryInfo, historyReturn)
[-] pred: org. junit. Assert. assertEquals ( mockConfigHistoryInfo, historyReturn )
************************************
[+] input: testGetOrCreateLocalFile_Success() { MultipartFile mockFile = new MockMultipartFile("some-file", "some-file", null, new byte[10]); localFileOperator.saveLocalFile(BUCKET, mockFile.getOriginalFilename(), mockFile.getSize(), mockFile.getInputStream()); File file = localFileOperator.getOrCreateLocalFile(BUCKET, "some-file"); "<AssertPlaceHolder>"; assertTrue(file.exists()); }
[*] target: assertNotNull(file)
[-] pred: org. junit. Assert. assertNotNull ( file )
************************************
[+] input: generate_hashPartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by hash(a) partitions 12 (" + "partition a.b (" + "subpartition a.b," + "subpartition b engine=InnoDB)," + "partition d id 14)")); Partition actual = factory.generate();  HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setEngine("InnoDB"); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 12); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testChoose() { Plip p = new Plip(1.2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  //You can create new empties with new Empty(); //Despite what the spec says, you cannot test for Cloruses nearby yet. //Sorry!  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: MalformedURLException { OSS oss = mock(OSSClient.class); Mockito.when(oss.generatePresignedUrl(any())).thenReturn(new URL("http://test.sql")); AlibabaCloudClient alibabaCloudClient = new AlibabaCloudClient(oss, null, "test", "test"); URL url = alibabaCloudClient.generatePresignedUrl("test", "test", new Date()); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
[+] input: generate_hashPartition_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory( getPartitionContext("partition by hash(a)")); Partition actual = factory.generate(); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), null, null, null); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testWebUtil() { SecuritySession session = Mockito.mock(SecuritySession.class); Mockito.when(session.getId()).thenReturn("abcde"); Mockito.when(session.getTimeoutMillis()).thenReturn(100000L); Cookie cookie = WebUtil.generateSecurityCookie(session); Assert."<AssertPlaceHolder>"; Assert.assertEquals(cookie.getValue(), session.getId()); Assert.assertEquals(cookie.getMaxAge(), TimeUnit.SECONDS.convert(session.getTimeoutMillis(), TimeUnit.MILLISECONDS)); Assert.assertTrue(cookie.isHttpOnly()); Assert.assertEquals(cookie.getPath(), "/"); }
[*] target: assertNotNull(cookie)
[-] pred: org. junit. Assert. assertNotNull ( cookie )
************************************
[+] input: loadProperties_WithEncryptedValue() { Map<String, String> load = EncryptableConfigurations.loadProperties(TEST_CONFIG_FILE);  Map<String, String> expected = new HashMap<>(); expected.put("key1", "oceanbase developer center"); expected.put("key2", "build the best database develop platform");  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, load)
[-] pred: org. junit. Assert. assertEquals ( expected, load )
************************************
[+] input: implies_SameResourceTypeAndId_impliesTrue() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "OWNER, DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "OWNER"); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(permission.implies(permission1))
[-] pred: org. junit. Assert. assertTrue ( permission. implies( permission1 ) )
************************************
[+] input: testCopartitioning() { final Random rand = new Random(); @SuppressWarnings("deprecation") final org.apache.kafka.clients.producer.internals.DefaultPartitioner defaultPartitioner = new org.apache.kafka.clients.producer.internals.DefaultPartitioner(); final WindowedSerializer<Integer> timeWindowedSerializer = new TimeWindowedSerializer<>(intSerializer); final WindowedStreamPartitioner<Integer, String> streamPartitioner = new WindowedStreamPartitioner<>(timeWindowedSerializer);  for (int k = 0; k < 10; k++) { final Integer key = rand.nextInt(); final byte[] keyBytes = intSerializer.serialize(topicName, key);  final String value = key.toString(); final byte[] valueBytes = stringSerializer.serialize(topicName, value);  final Integer expected = defaultPartitioner.partition("topic", key, keyBytes, value, valueBytes, cluster);  for (int w = 1; w < 10; w++) { final TimeWindow window = new TimeWindow(10 * w, 20 * w);  final Windowed<Integer> windowedKey = new Windowed<>(key, window); @SuppressWarnings("deprecation") final Integer actual = streamPartitioner.partition(topicName, windowedKey, value, infos.size());  "<AssertPlaceHolder>"; } }  defaultPartitioner.close(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: implies_resourcePermissionWithDiffResourceId1_impliesFalse() { ResourcePermission permission = new ResourcePermission(new DefaultSecurityResource("12", "conn"), ResourcePermission.CREATE | ResourcePermission.DELETE); ResourcePermission permission1 = new ResourcePermission(new DefaultSecurityResource("112", "conn"), ResourcePermission.CREATE); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(permission.implies(permission1))
[-] pred: org. junit. Assert. assertFalse ( permission. implies( permission1 ) )
************************************
[+] input: Exception { QueryServiceResponse res = new QueryServiceResponse(); ServiceInfo info = new ServiceInfo(GROUP_NAME + "@@" + SERVICE_NAME + "@@" + CLUSTERS); res.setServiceInfo(info); when(this.rpcClient.request(any())).thenReturn(res); ServiceInfo actual = client.queryInstancesOfService(SERVICE_NAME, GROUP_NAME, CLUSTERS, false); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(info, actual)
[-] pred: org. junit. Assert. assertEquals ( info, actual )
************************************
[+] input: testCollidingSimpleAlias() { SortedSet<PluginDesc<Converter>> converters = new TreeSet<>(); converters.add(new PluginDesc<>(CollidingConverter.class, null, PluginType.CONVERTER, CollidingConverter.class.getClassLoader())); SortedSet<PluginDesc<Transformation<?>>> transformations = new TreeSet<>(); transformations.add(new PluginDesc<>((Class<? extends Transformation<?>>) (Class<?>) Colliding.class, null, PluginType.TRANSFORMATION, Colliding.class.getClassLoader())); PluginScanResult result = new PluginScanResult( Collections.emptySortedSet(), Collections.emptySortedSet(), converters, Collections.emptySortedSet(), transformations, Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet() ); Map<String, String> actualAliases = PluginUtils.computeAliases(result); Map<String, String> expectedAliases = new HashMap<>(); expectedAliases.put("CollidingConverter", CollidingConverter.class.getName()); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedAliases, actualAliases)
[-] pred: org. junit. Assert. assertEquals ( expectedAliases, actualAliases )
************************************
[+] input: generate_deleteWithWhereClauseCursor_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab where current of tab.col"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); RelationReference left = new RelationReference("tab", new RelationReference("col", null)); expect.setWhere(left); expect.setCursor(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: InterruptedException { final EmbeddedChannel channel = new EmbeddedChannel(); final ClientConnection clientConnection = new ClientConnection(channel, null); clientConnection.setProtocolVersion(ProtocolVersion.MQTTv5); channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).set(clientConnection); when(connectionPersistence.get("client")).thenReturn(clientConnection); when(localPersistence.getSession(eq("client"), anyBoolean(), anyBoolean())).thenReturn(new ClientSession(true, 0)); final ListenableFuture<Boolean> future = clientSessionPersistence.forceDisconnectClient("client", true, ClientSessionPersistenceImpl.DisconnectSource.EXTENSION, Mqtt5DisconnectReasonCode.SESSION_TAKEN_OVER, "reason-string"); channel.disconnect(); final Boolean result = future.get(); "<AssertPlaceHolder>"; verify(pendingWillMessages).cancelWillIfPending("client"); verify(mqttServerDisconnector).disconnect(any(Channel.class), anyString(), anyString(), eq(Mqtt5DisconnectReasonCode.SESSION_TAKEN_OVER), eq("reason-string")); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_topKFreHistBitExpr_generateFunctionCallSucceed() { ExprContext context = getExprContext("TOP_K_FRE_HIST(1, 1+2, tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); Expression left = new ConstExpression("1"); Expression right = new ConstExpression("2"); params.add(new ExpressionParam(new CompoundExpression(left, right, Operator.ADD))); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("TOP_K_FRE_HIST", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_deleteWithoutWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: validNotSqlInjection_NotInjection_ReturnTrue() { boolean isNotInjection = PreConditions.validNotSqlInjection("oms_cluster", "cluster"); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(isNotInjection)
[-] pred: org. junit. Assert. assertTrue ( isNotInjection )
************************************
[+] input: listTypes_Success() { List<DBPLObjectIdentity> types = accessor.listTypes(getOracleSchema()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, types.size()); }
[*] target: assertNotNull(types)
[-] pred: org. junit. Assert. assertNotNull ( types )
************************************
[+] input: generate_readonly_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) read only"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setReadOnly(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_functionNameWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "function_name(5, 1,2) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); FunctionCall expect = new FunctionCall("function_name", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_formatTableOp_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) format=(ENCODING='aaaa',LINE_DELIMITER=123,SKIP_HEADER=12,EMPTY_FIELD_AS_NULL=true,NULL_IF_EXETERNAL=(1,2,3))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); Map<String, Expression> map = new HashMap<>(); map.put("ENCODING", new ConstExpression("'aaaa'")); map.put("EMPTY_FIELD_AS_NULL", new BoolValue(true)); map.put("SKIP_HEADER", new ConstExpression("12")); CollectionExpression es = new CollectionExpression(); es.addExpression(new ConstExpression("1")); es.addExpression(new ConstExpression("2")); es.addExpression(new ConstExpression("3")); map.put("NULL_IF_EXETERNAL", es); map.put("LINE_DELIMITER", new ConstExpression("123")); tableOptions.setFormat(map); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = new ComponentName(mContext.getPackageName(), "placeholder-do"); WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), true  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
[+] input: Exception { write(new File(db.getDirectory().getParent(), "test.txt"), "test"); File folder = new File(db.getDirectory().getParent(), "folder"); FileUtils.mkdir(folder); write(new File(folder, "folder.txt"), "folder"); try (Git git = new Git(db); ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(new BufferedOutputStream(os))) { git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); write(new File(folder, "folder.txt"), "folder change"); dfmt.setRepository(db); dfmt.setPathFilter(PathFilter.create("folder")); DirCacheIterator oldTree = new DirCacheIterator(db.readDirCache()); FileTreeIterator newTree = new FileTreeIterator(db);  dfmt.format(oldTree, newTree); dfmt.flush();  String actual = os.toString("UTF-8"); String expected = "diff --git a/folder/folder.txt b/folder/folder.txt\n" + "index 0119635..95c4c65 100644\n" + "--- a/folder/folder.txt\n" + "+++ b/folder/folder.txt\n" + "@@ -1 +1 @@\n" + "-folder\n" + "\\ No newline at end of file\n" + "+folder change\n" + "\\ No newline at end of file\n";  "<AssertPlaceHolder>"; } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: copy_changes() { final PublishPacketImpl packet = new PublishPacketImpl("topic", Qos.AT_LEAST_ONCE, Qos.AT_LEAST_ONCE, 1, false, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, ImmutableIntArray.of(), UserPropertiesImpl.of(ImmutableList.of()), 1234L); final ModifiablePublishPacketImpl modifiablePacket = new ModifiablePublishPacketImpl(packet, configurationService);  modifiablePacket.setTopic("modifiedTopic"); modifiablePacket.setQos(Qos.EXACTLY_ONCE); modifiablePacket.setPayload(ByteBuffer.wrap("modifiedPayload".getBytes())); modifiablePacket.setRetain(true); modifiablePacket.setMessageExpiryInterval(30); modifiablePacket.setPayloadFormatIndicator(PayloadFormatIndicator.UNSPECIFIED); modifiablePacket.setContentType("contentType"); modifiablePacket.setResponseTopic("responseTopic"); modifiablePacket.setCorrelationData(ByteBuffer.wrap("correlationData".getBytes())); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final PublishPacketImpl copy = modifiablePacket.copy();  final PublishPacketImpl expectedPacket = new PublishPacketImpl("modifiedTopic", Qos.AT_LEAST_ONCE, Qos.EXACTLY_ONCE, 1, false, ByteBuffer.wrap("modifiedPayload".getBytes()), true, 30, PayloadFormatIndicator.UNSPECIFIED, "contentType", "responseTopic", ByteBuffer.wrap("correlationData".getBytes()), ImmutableIntArray.of(), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue"))), 1234L); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedPacket, copy)
[-] pred: org. junit. Assert. assertEquals ( expectedPacket, copy )
************************************
[+] input: generate_functionNameExprAsList_generateFunctionCallSucceed() { ExprContext context = getExprContext("function_name(tab.col as new_label)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); ExpressionParam p = new ExpressionParam(new ColumnReference(null, "tab", "col")); p.addOption(new ConstExpression("new_label")); params.add(p); FunctionCall expect = new FunctionCall("function_name", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_modifyHashPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition by hash(a,b)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); expect.setModifyPartition(new HashPartition(cols, null, null, null)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetRemoteExecutorTimesOfProcessors() { int defaultExpectVal = 1 << 4; int defaultVal = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert.assertEquals(defaultExpectVal, defaultVal);  System.setProperty("remote.executor.times.of.processors", "10"); int val1 = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert.assertEquals(10, val1);  System.setProperty("remote.executor.times.of.processors", "-1"); int val2 = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(defaultExpectVal, val2)
[-] pred: org. junit. Assert. assertEquals ( defaultExpectVal, val2 )
************************************
[+] input: generate_breadthFirstSearch_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name (col1, col2) as (select * from dual) search breadth first by col2 desc, col3 asc set varname select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); expect.setSearchMode(SearchMode.BREADTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testBatchPublishAggrSuccess() {  String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; //mock query datumId and equal with current content param. when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, "d1"}), eq(String.class))).thenReturn("c1"); when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, "d2"}), eq(String.class))).thenReturn("c2"); when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, "d3"}), eq(String.class))).thenReturn("c3"); Map<String, String> datumMap = new HashMap<>(); datumMap.put("d1", "c1"); datumMap.put("d2", "c2"); datumMap.put("d3", "c3"); String appName = "appname1234"; boolean result = externalConfigInfoAggrPersistService.batchPublishAggr(dataId, group, tenant, datumMap, appName); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: testAddAggrConfigInfoOfEqualContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and equal with current content param. String existContent = "content1234"; Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenReturn(existContent); //mock insert success Mockito.when(databaseOperate.update(any(List.class))).thenReturn(true);  boolean result = embededConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_castAsFloat_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as float(2))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); NumberType type = new NumberType("float", new BigDecimal("2"), null); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_dotRelationKeyword_generateSucceed() { ExprContext context = getExprContext(".tab.BEFORE"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference(null, "tab", "BEFORE"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetRemoteExecutorQueueSize() { int defaultExpectVal = 1 << 14; int defaultVal = RemoteUtils.getRemoteExecutorQueueSize(); Assert.assertEquals(defaultExpectVal, defaultVal);  System.setProperty("remote.executor.queue.size", "10"); int val1 = RemoteUtils.getRemoteExecutorQueueSize(); Assert.assertEquals(10, val1);  System.setProperty("remote.executor.queue.size", "-1"); int val2 = RemoteUtils.getRemoteExecutorQueueSize(); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(defaultExpectVal, val2)
[-] pred: org. junit. Assert. assertEquals ( defaultExpectVal, val2 )
************************************
[+] input: NacosException { when(rpcClientConfig.timeOutMills()).thenReturn(5000L); when(rpcClientConfig.retryTimes()).thenReturn(3); rpcClient.rpcClientStatus.set(RpcClientStatus.RUNNING); rpcClient.currentConnection = connection; doThrow(NacosException.class).when(connection).requestFuture(any()); Exception exception = null;  try { rpcClient.requestFuture(null); } catch (NacosException e) { exception = e; }  verify(connection, times(4)).requestFuture(any()); verify(rpcClient).switchServerAsyncOnRequestFail(); Assert."<AssertPlaceHolder>"; assertEquals(RpcClientStatus.UNHEALTHY, rpcClient.rpcClientStatus.get()); }
[*] target: assertNotNull(exception)
[-] pred: org. junit. Assert. assertNotNull ( exception )
************************************
[+] input: test_getInstance_not_present() { clientConnection.setConnectionAttributes(null);  final ConnectionAttributes returnConnectionAttributes = ConnectionAttributes.getInstance(channel);  "<AssertPlaceHolder>"; }
[*] target: assertNotNull(returnConnectionAttributes)
[-] pred: org. junit. Assert. assertNotNull ( returnConnectionAttributes )
************************************
[+] input: generate_skipIndex_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table skip_index_tbl (id varchar(64) SKIP_INDEX(MIN_MAX,SUM))"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("skip_index_tbl"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnAttributes attributes = new ColumnAttributes(); attributes.setSkipIndexTypes(Arrays.asList("MIN_MAX", "SUM")); ColumnDefinition column = new ColumnDefinition(new ColumnReference(null, null, "id"), dataType); column.setColumnAttributes(attributes); expect.setTableElements(Collections.singletonList(column)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_createIndex_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_predicateNotLike_generateSucceed() { ExprContext context = getExprContext("tab.col not like 'abc' 'bcd'"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); CollectionExpression right = new CollectionExpression(); right.addExpression(new ConstExpression("'abc'")); right.addExpression(new ConstExpression("'bcd'")); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testParseEncoding_Accept_Latin_One_AsISO8859_1() { Charset result = RawParseUtils.parseEncoding(Constants .encodeASCII("encoding latin-1\n")); "<AssertPlaceHolder>"; assertEquals("ISO-8859-1", result.name()); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
[+] input: generate_updateWithWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1 where col=100"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); RelationReference left = new RelationReference("col", null); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: bytesToLongOffsetTest1() { long l1 = 1600650710304L; int width1 = 64 - Long.numberOfLeadingZeros(l1); long l2 = -16L; int width2 = 64 - Long.numberOfLeadingZeros(l2); byte[] bs = new byte[1000]; BytesUtils.longToBytes(l1, bs, 0, width1); long res_val1_1 = BytesUtils.bytesToLong(bs, 0, width1); BytesUtils.longToBytes(l2, bs, width1, width2); long res_val1_2 = BytesUtils.bytesToLong(bs, 0, width1); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(res_val1_1, res_val1_2)
[-] pred: org. junit. Assert. assertEquals ( res_val1_1, res_val1_2 )
************************************
[+] input: generate_addColumn_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("add id varchar(64)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); CharacterType type = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition d = new ColumnDefinition(new ColumnReference(null, null, "id"), type); expect.setAddColumns(Collections.singletonList(d)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { // Generate a PQ for random vectors var vectors = createRandomVectors(512, 64); var ravv = new ListRandomAccessVectorValues(vectors, 64); var bq = new BinaryQuantization(ravv.dimension());  // Compress the vectors var compressed = bq.encodeAll(ravv); var cv = new BQVectors(bq, compressed); assertEquals(64 * Float.BYTES, cv.getOriginalSize()); assertEquals(8, cv.getCompressedSize());  // Write compressed vectors File cvFile = File.createTempFile("bqtest", ".cv"); try (var out = new DataOutputStream(new FileOutputStream(cvFile))) { cv.write(out); } // Read compressed vectors try (var in = new SimpleMappedReader(cvFile.getAbsolutePath())) { var cv2 = BQVectors.load(in, 0); "<AssertPlaceHolder>"; } }
[*] target: assertEquals(cv, cv2)
[-] pred: org. junit. Assert. assertEquals ( cv, cv2 )
************************************
[+] input: testGetSubscribedService() { Collection<Service> subscribedService = clientServiceIndexesManager.getSubscribedService();  Assert."<AssertPlaceHolder>"; Assert.assertEquals(subscribedService.size(), 1); }
[*] target: assertNotNull(subscribedService)
[-] pred: org. junit. Assert. assertNotNull ( subscribedService )
************************************
[+] input: generate_parallel_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) parallel 12, noparallel"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testIsDecimalType() { boolean result = ColumnTypeUtil.isDecimalType("decimal"); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_temporaryTable_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create temporary table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setTemporary(true); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testDuplicateInserts() { DependencyFlowNodesDao.instance.getMCollection().drop();  DependencyFlowNodesDao.instance.createIndicesIfAbsent(); Node node = new Node("0", "url", "GET", new HashMap<>()); DependencyFlowNodesDao.instance.insertOne(node);  boolean erroredOut = false; node.getConnections().put("param", new Connection("param", Collections.singletonList(new Edge("0", "url_new", "POST", "param_new", false,20, 0)), false, false)); try { DependencyFlowNodesDao.instance.insertOne(node); } catch (Exception e) { erroredOut = true; }  "<AssertPlaceHolder>"; }
[*] target: assertTrue(erroredOut)
[-] pred: org. junit. Assert. assertTrue ( erroredOut )
************************************
[+] input: testDerbySqlCorrect() { final String testSql = "INSERT INTO `config_info` (`id`, `data_id`, `group_id`, `content`, `md5`, `gmt_create`, `gmt_modified`, `src_user`, `src_ip`, `app_name`, `tenant_id`, `c_desc`, `c_use`, `effect`, `type`, `c_schema`) VALUES (1,'boot-test','ALIBABA','dept:123123123\\ngroup:123123123','2ca50d002a7dabf81497f666a7967e15','2020-04-13 13:44:43','2020-04-30 10:45:21',NULL,'127.0.0.1','','',NULL,NULL,NULL,NULL,NULL);"; final String result = DerbyUtils.insertStatementCorrection(testSql);  final String expect = "INSERT INTO CONFIG_INFO (ID, DATA_ID, GROUP_ID, CONTENT, MD5, GMT_CREATE, GMT_MODIFIED, SRC_USER, SRC_IP, APP_NAME, TENANT_ID, C_DESC, C_USE, EFFECT, TYPE, C_SCHEMA) VALUES (1,'boot-test','ALIBABA','dept:123123123\\ngroup:123123123','2ca50d002a7dabf81497f666a7967e15','2020-04-13 13:44:43','2020-04-30 10:45:21',NULL,'127.0.0.1','','',NULL,NULL,NULL,NULL,NULL)"; Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, result)
[-] pred: org. junit. Assert. assertEquals ( expect, result )
************************************
[+] input: generate_countAllStar_generateFunctionCallSucceed() { ExprContext context = getExprContext("count(all *)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("*"))); FunctionCall expect = new FunctionCall("count", params); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testBuilderHeader() { Header header = NamingHttpUtil.builderHeader(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(header.getValue(HttpHeaderConsts.CLIENT_VERSION_HEADER), VersionUtils.version); Assert.assertEquals(header.getValue(HttpHeaderConsts.USER_AGENT_HEADER), VersionUtils.getFullClientVersion()); Assert.assertEquals(header.getValue(HttpHeaderConsts.ACCEPT_ENCODING), "gzip,deflate,sdch"); Assert.assertEquals(header.getValue(HttpHeaderConsts.CONNECTION), "Keep-Alive"); Assert.assertNotNull(header.getValue(HttpHeaderConsts.REQUEST_ID)); Assert.assertEquals(header.getValue(HttpHeaderConsts.REQUEST_MODULE), "Naming"); }
[*] target: assertNotNull(header)
[-] pred: org. junit. Assert. assertNotNull ( header )
************************************
[+] input: generate_createIndexWithUv_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc@uv1 on tb@uv2 (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor r1 = new RelationFactor("abc"); r1.setUserVariable("@uv1"); RelationFactor r2 = new RelationFactor("tb"); r2.setUserVariable("@uv2"); CreateIndex expect = new CreateIndex(r1, r2, Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetLoggerFallsBackToEffectiveLogLevel() { Logger root = logger("root"); root.setLevel(Level.ERROR);  Hierarchy hierarchy = new Hierarchy(root); Logger a = hierarchy.getLogger("a"); a.setLevel(null); Logger b = hierarchy.getLogger("b"); b.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, a, b);  LoggerLevel expectedLevel = new LoggerLevel(Level.ERROR.toString(), null); LoggerLevel actualLevel = loggers.level("a"); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedLevel, actualLevel)
[-] pred: org. junit. Assert. assertEquals ( expectedLevel, actualLevel )
************************************
[+] input: getIntentValue_getAccessibilityPermissionIndex_returnCameraPermissionMessage() { Intent mockIntent = new Intent(ApplicationProvider.getApplicationContext(), GrantPermissionActivity.class); mockIntent.putExtra("permission", "grantAccessibility");  GrantPermissionActivity grantPermissionActivityResume = Robolectric.buildActivity(GrantPermissionActivity.class, mockIntent).create().start().resume().get(); String description = grantPermissionActivityResume.getDescriptionTextViewValue(); String actual = "Change permissions in your device’s \napp settings. Give GameFace access to \nAccessibility.";  "<AssertPlaceHolder>"; }
[*] target: assertEquals(actual, description)
[-] pred: org. junit. Assert. assertEquals ( actual, description )
************************************
[+] input: nullNetaddressStrategyTest() { boolean isMatch = RemoteAddressStrategyFactory.NULL_NET_ADDRESS_STRATEGY.match(new PlainAccessResource()); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(isMatch)
[-] pred: org. junit. Assert. assertTrue ( isMatch )
************************************
[+] input: testMemberLeave() { Member member = Member.builder().ip("1.1.3.3").port(8848).state(NodeState.DOWN).build(); boolean joinResult = serverMemberManager.memberJoin(Collections.singletonList(member)); assertTrue(joinResult);  List<String> ips = serverMemberManager.getServerListUnhealth(); assertEquals(1, ips.size());  boolean result = serverMemberManager.memberLeave(Collections.singletonList(member)); "<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_indexColumnAscNullsLast_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "index (col asc nulls last id 15, col1) initrans 13 maxtrans 14 storage(next 10 initial 13)")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); s1.setId(15); s1.setDirection(SortDirection.ASC); s1.setNullPosition(SortNullPosition.LAST); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setIniTrans(13); indexOptions.setMaxTrans(14); indexOptions.setStorage(Arrays.asList("next 10", "initial 13")); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getStatement_selectOracleMode_getSelectStmt() { AbstractSyntaxTreeFactory factory = AbstractSyntaxTreeFactories.getAstFactory(DialectType.OB_ORACLE, 0); AbstractSyntaxTree ast = factory.buildAst("select col.* abc from dual"); Statement actual = ast.getStatement(); RelationReference r = new RelationReference("col", new RelationReference("*", null)); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_multiInsert_succeed() { StatementFactory<Insert> factory = new OracleInsertFactory(getInsertContext( "insert all into a partition(p1, p2) " + "into b (c1, c2) " + "into c values (1, default) " + "into d (c3, c4) values(1, 2) " + "select col.* abc from dual order by col desc offset 12 rows fetch first 12 rows only")); Insert actual = factory.generate();  InsertTable t1 = new InsertTable(new RelationFactor("a")); t1.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p1", "p2"))); InsertTable t2 = new InsertTable(new RelationFactor("b")); t2.setColumns(Arrays.asList(new ColumnReference(null, null, "c1"), new ColumnReference(null, null, "c2"))); InsertTable t3 = new InsertTable(new RelationFactor("c")); List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("default"))); t3.setValues(values); InsertTable t4 = new InsertTable(new RelationFactor("d")); values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("2"))); t4.setValues(values); t4.setColumns(Arrays.asList(new ColumnReference(null, null, "c3"), new ColumnReference(null, null, "c4"))); RelationReference r = new RelationReference("col", new RelationReference("*", null)); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); SortKey s1 = new SortKey(new RelationReference("col", null), SortDirection.DESC, null); OrderBy orderBy = new OrderBy(false, Collections.singletonList(s1)); Select select = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); select.setOrderBy(orderBy); select.setFetch(new Fetch(new ConstExpression("12"), FetchDirection.FIRST, FetchType.COUNT, FetchAddition.ONLY, new ConstExpression("12"))); Insert expect = new Insert(Arrays.asList(t1, t2, t3, t4), null); expect.setAll(true); expect.setSelect(select); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testTimeFilterSampleByTimestamp() { AbstractResult indexResult = new RangeResult(timeIndex, Collections.singletonList(new RangeUnit(1, 7)));  String sampleMeta = "topk(by=time, limit=5, reverse=false, replacement=false)"; TopKSampler<Long> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(8, 7, 6, 5, 4);  "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: testTypeTimeFilterSampleByWeight() { AbstractResult indexResult = new CommonResult(typeIndex, Arrays.asList(0, 2, 4, 5, 6, 9));  String sampleMeta = "topk(by=weight, limit=3, reverse=true, replacement=false)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(9, 6, 5); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: testFilter() { Mockito.when(authConfigs.isAuthEnabled()).thenReturn(true);  Request healthCheckRequest = new HealthCheckRequest();  try { Response healthCheckResponse = remoteRequestAuthFilter .filter(healthCheckRequest, new RequestMeta(), MockRequestHandler.class); Assert."<AssertPlaceHolder>"; } catch (NacosException e) { e.printStackTrace(); Assert.fail(e.getMessage()); } }
[*] target: assertNull(healthCheckResponse)
[-] pred: org. junit. Assert. assertNull ( healthCheckResponse )
************************************
[+] input: generate_splitRangePartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress, partition id 12)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); SpecialPartitionElement e3 = new SpecialPartitionElement(null); PartitionOptions o2 = new PartitionOptions(); o2.setId(12); e3.setPartitionOptions(o2); actions.setIntos(Arrays.asList(e1, e2, e3)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testExecutionException() { KafkaProducerManager manager = new KafkaProducerManager( Duration.ofMillis(150), Duration.ofMillis(500), 10, Duration.ofMillis(120000)); KafkaPublishTask.Input input = getInput(); Producer producer = manager.getProducer(input); "<AssertPlaceHolder>"; }
[*] target: assertNotNull(producer)
[-] pred: org. junit. Assert. assertNotNull ( producer )
************************************
[+] input: testListConnectorPlugins() { Set<PluginInfo> expectedConnectorPlugins = Stream.of(SINK_CONNECTOR_PLUGINS, SOURCE_CONNECTOR_PLUGINS) .flatMap(Collection::stream) .map(PluginInfo::new) .collect(Collectors.toSet()); Set<PluginInfo> actualConnectorPlugins = new HashSet<>(connectorPluginsResource.listConnectorPlugins(true)); "<AssertPlaceHolder>"; verify(herder, atLeastOnce()).plugins(); }
[*] target: assertEquals(expectedConnectorPlugins, actualConnectorPlugins)
[-] pred: org. junit. Assert. assertEquals ( expectedConnectorPlugins, actualConnectorPlugins )
************************************
[+] input: Exception { write(new File(db.getWorkTree(), "test.txt"), "test"); try (Git git = new Git(db)) { git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); write(new File(db.getWorkTree(), "test.txt"), "test change");  OutputStream out = new ByteArrayOutputStream(); git.diff().setOutputStream(out).setSourcePrefix("old/") .setDestinationPrefix("new/").call();  String actual = out.toString(); String expected = "diff --git old/test.txt new/test.txt\n" + "index 30d74d2..4dba797 100644\n" + "--- old/test.txt\n" + "+++ new/test.txt\n" + "@@ -1 +1 @@\n" + "-test\n" + "\\ No newline at end of file\n" + "+test change\n" + "\\ No newline at end of file\n"; "<AssertPlaceHolder>"; } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_accessFuncWith_UPDATING_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(UPDATING('regexp_str', 'value', 'value1'))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'regexp_str'")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'value'")); FunctionParam p3 = new ExpressionParam(new ConstExpression("'value1'")); FunctionCall pCall = new FunctionCall("UPDATING", Arrays.asList(p1, p2, p3)); ExpressionParam param1 = new ExpressionParam(pCall); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldNotAbortTxnOnEOSCloseDirtyIfNothingSent() { final AtomicBoolean functionCalled = new AtomicBoolean(false); final RecordCollector collector = new RecordCollectorImpl( logContext, taskId, new StreamsProducer( eosConfig, "-StreamThread-1", new MockClientSupplier() { @Override public Producer<byte[], byte[]> getProducer(final Map<String, Object> config) { return new MockProducer<byte[], byte[]>(cluster, true, byteArraySerializer, byteArraySerializer) { @Override public void abortTransaction() { functionCalled.set(true); } }; } }, taskId, processId, logContext, Time.SYSTEM ), productionExceptionHandler, streamsMetrics, topology );  collector.closeDirty(); "<AssertPlaceHolder>"; }
[*] target: assertFalse(functionCalled.get())
[-] pred: org. junit. Assert. assertFalse ( functionCalled. get ( ) )
************************************
[+] input: testFindMapper() { testJoin(); MapperManager instance = MapperManager.instance(false); Mapper mapper = instance.findMapper(DataSourceConstant.MYSQL, "test"); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(mapper)
[-] pred: org. junit. Assert. assertNotNull ( mapper )
************************************
[+] input: testGetUnknownLogger() { Logger root = logger("root"); root.setLevel(Level.ERROR);  Hierarchy hierarchy = new Hierarchy(root); Logger a = hierarchy.getLogger("a"); a.setLevel(null); Logger b = hierarchy.getLogger("b"); b.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, a, b);  LoggerLevel level = loggers.level("c"); "<AssertPlaceHolder>"; }
[*] target: assertNull(level)
[-] pred: org. junit. Assert. assertNull ( level )
************************************
[+] input: generate_sysdate_generateFunctionCallSucceed() { ExprContext context = getExprContext("sysdate(123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("sysdate", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_xmlSerializeEncodingVersion2_generateSucceed() { ExprContext context = getExprContext( "xmlSerialize(content 'aaa' as int encoding 'aaa' version 12 indent size=-12 hide defaults)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlSerialize", Collections.singletonList(p1)); expect.addOption(new ConstExpression("content")); expect.addOption(new ConstExpression("encoding 'aaa'")); expect.addOption(new ConstExpression("version 12")); expect.addOption(new CompoundExpression(new ConstExpression("indent size"), new CompoundExpression(new ConstExpression("12"), null, Operator.SUB), Operator.EQ)); expect.addOption(new ConstExpression("hide defaults")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: IOException { Map<Integer, String> index2Content = new HashMap<>(); Map<Integer, BinaryContentMetaData> index2MetaData = new HashMap<>();  BinaryDataManager dataManager = getDataManager(); for (int i = 0; i < 3; i++) { String content = getInputContent(); index2Content.putIfAbsent(i, content); index2MetaData.putIfAbsent(i, dataManager.write(getInputContentStream(content))); }  for (int i = 0; i < 3; i++) { BinaryContentMetaData metaData = index2MetaData.get(i); Assert.assertNotNull(metaData); InputStream inputStream = dataManager.read(metaData); String fromFile = String.join("", IOUtils.readLines(inputStream)); String fromMemory = index2Content.get(i); Assert."<AssertPlaceHolder>"; } }
[*] target: assertEquals(fromFile, fromMemory)
[-] pred: org. junit. Assert. assertEquals ( fromFile, fromMemory )
************************************
[+] input: generate_rangePartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than (maxvalue))," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, null, false); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_listPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by list(a,b) (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress," + "partition values ('aaaddd') id 15 tablespace tbs)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); ListPartitionElement e3 = new ListPartitionElement(null, Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2, e3), null, null, false); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_sortKey_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) sortkey (a,b)"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions .setSortKeys(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_updateWithWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1 where col=100"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); ColumnReference left = new ColumnReference(null, null, "col"); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: ParseException { String dateStr = "Wed Feb 21 15:35:00 2007"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("EEE MMM dd HH:mm:ss yyyy").parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
[+] input: NacosException { RpcClient rpcClient = new RpcClient(new RpcClientConfig() { @Override public String name() { return "test-client"; }  @Override public int retryTimes() { return 3; }  @Override public long timeOutMills() { return 3000L; }  @Override public long connectionKeepAlive() { return 5000L; }  @Override public int healthCheckRetryTimes() { return 1; }  @Override public long healthCheckTimeOut() { return 3000L; }  @Override public Map<String, String> labels() { return new HashMap<>(); } }) { @Override public ConnectionType getConnectionType() { return null; }  @Override public int rpcPortOffset() { return 0; }  @Override public Connection connectToServer(ServerInfo serverInfo) { return null; } };  rpcClient.shutdown(); "<AssertPlaceHolder>"; }
[*] target: assertTrue(rpcClient.isShutdown())
[-] pred: org. junit. Assert. assertTrue ( rpcClient. isShutdown() )
************************************
[+] input: generate_uniqueIndexColumnAscIdNoUsingBtree_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("unique index (col asc id 16, col1)")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineConstraint expect = new OutOfLineConstraint(null, Arrays.asList(s1, s2)); expect.setUniqueKey(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_functionNameExprAsListNoAlias_generateFunctionCallSucceed() { ExprContext context = getExprContext("function_name(tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("function_name", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: copy_changes() { final PubrelPacketImpl packet = new PubrelPacketImpl( 1, PubrelReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubrelPacketImpl modifiablePacket = new ModifiablePubrelPacketImpl(packet, configurationService);  modifiablePacket.setReasonString("reason"); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final PubrelPacketImpl copy = modifiablePacket.copy();  final PubrelPacketImpl expectedPacket = new PubrelPacketImpl( 1, PubrelReasonCode.SUCCESS, "reason", UserPropertiesImpl.of(ImmutableList.of(MqttUserProperty.of("testName", "testValue")))); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedPacket, copy)
[-] pred: org. junit. Assert. assertEquals ( expectedPacket, copy )
************************************
[+] input: generate_reorganizePartitionIntoList_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("REORGANIZE partition a,b into (" + "partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); expect.reorganizePartition(Arrays.asList("a", "b"), Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testDeleteQuietly_Exists_ReturnTrue() { MultipartFile mockFile = new MockMultipartFile("some-file", "some-file", null, new byte[10]); localFileOperator.saveLocalFile(BUCKET, mockFile.getOriginalFilename(), mockFile.getSize(), mockFile.getInputStream());  boolean result = localFileOperator.deleteLocalFile(BUCKET, "some-file"); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_createIndexUsingBtree_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create unique index abc using btree on tb (col, col1) using hash")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setUnique(true); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setUsingHash(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldMatchPositionAfterPut() { final MeteredWindowStore<Integer, String> meteredSessionStore = (MeteredWindowStore<Integer, String>) windowStore; final ChangeLoggingWindowBytesStore changeLoggingSessionBytesStore = (ChangeLoggingWindowBytesStore) meteredSessionStore.wrapped(); final WrappedStateStore rocksDBWindowStore = (WrappedStateStore) changeLoggingSessionBytesStore.wrapped();  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); windowStore.put(0, "0", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); windowStore.put(1, "1", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); windowStore.put(2, "2", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 4, 0, "", new RecordHeaders())); windowStore.put(3, "3", SEGMENT_INTERVAL);  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 4L))))); final Position actual = rocksDBWindowStore.getPosition(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: testIsBucketExist_ReturnTrue() { when(bucketRepository.findByName(anyString())).thenReturn(Optional.of(new BucketEntity())); boolean exists = bucketOperation.isBucketExist("whatever"); verify(bucketRepository, times(1)).findByName(anyString()); "<AssertPlaceHolder>"; }
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
[+] input: shouldCountWorkflows() { int counts = 1100; for (int i = 0; i < counts; i++) { WorkflowSummary workflowSummary = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); indexDAO.indexWorkflow(workflowSummary); }  // wait for workflow to be indexed long result = tryGetCount(() -> getWorkflowCount("template_workflow", "RUNNING"), counts); "<AssertPlaceHolder>"; }
[*] target: assertEquals(counts, result)
[-] pred: org. junit. Assert. assertEquals ( counts, result )
************************************
[+] input: generate_xmlagg_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("xmlagg(1 order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("xmlagg", Collections.singletonList( new ExpressionParam(new ConstExpression("1")))); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.addOption(new OrderBy(Collections.singletonList(s))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_indexWithColumnGroup_allColumns_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext( "index idx_name (col) with column group(all columns)"));  OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Collections.singletonList(s1)); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testInitNamespaceFromJvmNamespaceWithCloudParsing() { String expect = "jvm_namespace"; System.setProperty(PropertyKeyConst.NAMESPACE, expect); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, ns)
[-] pred: org. junit. Assert. assertEquals ( expect, ns )
************************************
[+] input: InterruptedException { // make sure the first no delay refresh thread finished. TimeUnit.MILLISECONDS.sleep(500); FailoverSwitch mockFailoverSwitch = new FailoverSwitch(true); when(failoverDataSource.getSwitch()).thenReturn(mockFailoverSwitch); Map<String, FailoverData> map = new HashMap<>(); ServiceInfo serviceInfo = new ServiceInfo("a@@b"); map.put("a@@b", NamingFailoverData.newNamingFailoverData(serviceInfo)); when(failoverDataSource.getFailoverData()).thenReturn(map); when(holder.isChangedServiceInfo(any(), any())).thenReturn(true); // waiting refresh thread work TimeUnit.MILLISECONDS.sleep(5500); ServiceInfo actual = failoverReactor.getService("a@@b"); "<AssertPlaceHolder>"; }
[*] target: assertEquals(serviceInfo, actual)
[-] pred: org. junit. Assert. assertEquals ( serviceInfo, actual )
************************************
[+] input: generate_valuesStatement_generateSelectSucceed() { String sql = "values row(1, '2'), row(2, '3')"; Select_stmtContext context = getSelectContext(sql); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); values.add(Arrays.asList(new ConstExpression("2"), new ConstExpression("'3'"))); SelectBody body = new SelectBody(values); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getResource_whenClazzIsNull_thenResourceIsNull() { final URL resource = ManifestUtils.getResource(null, "path"); "<AssertPlaceHolder>"; }
[*] target: assertNull(resource)
[-] pred: org. junit. Assert. assertNull ( resource )
************************************
[+] input: IOException { ResourceManager manager = getResourceManager(); ResourceSpec defaultEntity = getDefaultResourceEntity(manager);  TableTemplate entity = defaultEntity.getTemplates().get(0); List<DataRecord> permissions = getDataRecords(defaultEntity, manager, entity); Assert.assertEquals(1, permissions.size());  DataRecord permission = permissions.get(0); DataRecordRepository repository = new DataRecordRepository(dataSource); Assert.assertFalse(repository.exists(permission)); repository.save(permission); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(repository.exists(permission))
[-] pred: org. junit. Assert. assertTrue ( repository. exists ( permission ) )
************************************
[+] input: listTriggers_test_invalid_trigger() { List<DBPLObjectIdentity> triggers = accessor.listTriggers(getOracleSchema()); boolean flag = false; for (DBPLObjectIdentity trigger : triggers) { if (StringUtils.containsIgnoreCase(trigger.getErrorMessage(), "ORA")) { flag = true; } } Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
[+] input: generate_generatedColumnDefAsExprConstraint_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "tb.col varchar2(64) generated always as (tb.col+1) virtual constraint abc not null rely")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); RelationReference r1 = new RelationReference("tb", new RelationReference("col", null)); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); ConstraintState state = new ConstraintState(); state.setRely(true); InLineConstraint attribute = new InLineConstraint("abc", state); attribute.setNullable(false); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test_ModelToEntity_Success() { AuditEventMeta model = AuditEventMeta.builder() .action(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION) .type(AuditEventType.PERSONAL_CONFIGURATION) .enabled(true) .inConnection(true) .methodSignature("controller") .sidExtractExpression("test") .build();  AuditEventMetaEntity expected = new AuditEventMetaEntity(); expected.setSidExtractExpression("test"); expected.setMethodSignature("controller"); expected.setEnabled(true); expected.setType(AuditEventType.PERSONAL_CONFIGURATION); expected.setAction(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION); expected.setInConnection(true);  AuditEventMetaEntity actual = mapper.modelToEntity(model); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_modifyHashPartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("partition by hash(a)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setModifyPartition(new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), null, null, null)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testFailWorkflowWithInputPayload() { WorkflowModel workflow = new WorkflowModel(); workflow.setInput(new HashMap<>());  expectedException.expect(TerminateWorkflowException.class); externalPayloadStorageUtils.failWorkflow( workflow, ExternalPayloadStorage.PayloadType.TASK_INPUT, "error"); "<AssertPlaceHolder>"; assertTrue(workflow.getInput().isEmpty()); assertEquals(WorkflowModel.Status.FAILED, workflow.getStatus()); }
[*] target: assertNotNull(workflow)
[-] pred: org. junit. Assert. assertNotNull ( workflow )
************************************
[+] input: test_getInstanceIfPresent_not_present() { clientConnection.setConnectionAttributes(null);  final ConnectionAttributes returnConnectionAttributes = ConnectionAttributes.getInstanceIfPresent(channel);  "<AssertPlaceHolder>"; }
[*] target: assertNull(returnConnectionAttributes)
[-] pred: org. junit. Assert. assertNull ( returnConnectionAttributes )
************************************
[+] input: generate_deleteWithWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab where col=100"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); RelationReference left = new RelationReference("col", null); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: parserAnonymousBlock_callProcedure_2_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_3, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("PL_TEST_2"); int actual = procedureCall.getCallLine(); int expect = 9; Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: ParseException { String dateStr = "21.02.2007"; Date exp = SystemReader.getInstance().getSimpleDateFormat("dd.MM.yyyy") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
[+] input: Exception { Callable callable = mock(Callable.class); when(callable.call()).thenThrow(new RuntimeException("test")); String actual = TemplateUtils.stringBlankAndThenExecute(null, callable); "<AssertPlaceHolder>"; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
[+] input: generate_tableWithPartition_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (" + "id varchar(64))" + "partition by range(id) (partition a values less than (-2))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); RangePartitionElement e1 = new RangePartitionElement("a", Collections.singletonList(new CompoundExpression(new ConstExpression("2"), null, Operator.SUB))); List<Expression> cols = Collections.singletonList(new ColumnReference(null, null, "id")); expect.setPartition(new RangePartition(cols, Collections.singletonList(e1), null, null, false)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldInstantiateAndConfigureExplicitlySetHeaderConverterWithCurrentClassLoader() { assertNotNull(props.get(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG)); HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNotNull(headerConverter); assertInstanceOf(TestHeaderConverter.class, headerConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config"));  headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertInstanceOf(TestHeaderConverter.class, headerConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config")); }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
[+] input: NacosException { String dataId = "1"; String group = "2"; String content = "123"; String namespace = ""; String casMd5 = "96147704e3cb8be8597d55d75d244a02"; String type = ConfigType.PROPERTIES.getType();  Mockito.when(mockWoker.publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type)) .thenReturn(true);  final boolean b = nacosConfigService.publishConfigCas(dataId, group, content, casMd5, type); Assert."<AssertPlaceHolder>";  Mockito.verify(mockWoker, Mockito.times(1)) .publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type); }
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
************************************
[+] input: invokeWithMapContainer() { Method mapContainerMethod = ReflectUtils.getMethod(OperatorInterface.class, "mapContainerMethod", Foo.class, HashMap.class); MethodInvoker invoker = proxyMethodFactory.get(beanOperations, mapContainerMethod, operationExecutor); Assert."<AssertPlaceHolder>"; checkFoo(1, "1", invoker, null);  Map<Integer, Object> map = new HashMap<>(); map.put(2, "name2"); checkFoo(2, "name2", invoker, map); }
[*] target: assertNotNull(invoker)
[-] pred: org. junit. Assert. assertNotNull ( invoker )
************************************
[+] input: generate_dropConstraint_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop constraint abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropConstraintNames(Collections.singletonList("abcd")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_position_generateFunctionCallSucceed() { ExprContext context = getExprContext("position('123' in (1,col.tab))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); Expression left = new ConstExpression("'123'"); CollectionExpression right = new CollectionExpression(); right.addExpression(new ConstExpression("1")); right.addExpression(new ColumnReference(null, "col", "tab")); params.add(new ExpressionParam(new CompoundExpression(left, right, Operator.IN))); FunctionCall expect = new FunctionCall("position", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_addIndex_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("add key abc (a,b)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SortColumn c1 = new SortColumn(new ColumnReference(null, null, "a")); SortColumn c2 = new SortColumn(new ColumnReference(null, null, "b")); expect.setAddIndex(new OutOfLineIndex("abc", Arrays.asList(c1, c2))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_splitRangePartition1_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); actions.setIntos(Arrays.asList(e1, e2)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testStringBlankAndThenExecuteSuccess() { String word = "success"; String actual = TemplateUtils.stringBlankAndThenExecute(word, () -> "call"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(word, actual)
[-] pred: org. junit. Assert. assertEquals ( word, actual )
************************************
[+] input: parserAnonymousBlock_callFunctionSucceed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_1, 0); Map<String, AnonymousBlockFunctionCall> functionCallMap = result.getFunctionCallMap(); AnonymousBlockFunctionCall functionCall = functionCallMap.get("FUN"); int actual = functionCall.getCallLine(); int expect = 7; Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test_get_tls_no_cert() { clientConnection.setAuthCipherSuite("cipher"); clientConnection.setAuthProtocol("TLSv1.2");  final ClientTlsInformation clientTlsInformation = ExtensionInformationUtil.getTlsInformationFromChannel(channel); "<AssertPlaceHolder>"; assertEquals("cipher", clientTlsInformation.getCipherSuite()); assertEquals("TLSv1.2", clientTlsInformation.getProtocol()); assertTrue(clientTlsInformation.getHostname().isEmpty()); assertTrue(clientTlsInformation.getClientCertificate().isEmpty()); }
[*] target: assertNotNull(clientTlsInformation)
[-] pred: org. junit. Assert. assertNotNull ( clientTlsInformation )
************************************
[+] input: generate_tableMode_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) table_mode='abcd',parallel 12, noparallel"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); tableOptions.setTableMode("'abcd'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testCreateOperatorProxy() { Crane4jTemplate.OpsForProxy ops = crane4jTemplate.opsForProxy(); TestOperatorProxy proxy = ops.createOperatorProxy(TestOperatorProxy.class); Assert."<AssertPlaceHolder>"; Foo foo = new Foo("1"); proxy.fill(foo); Assert.assertEquals("name" + foo.getId(), foo.getName()); }
[*] target: assertNotNull(proxy)
[-] pred: org. junit. Assert. assertNotNull ( proxy )
************************************
[+] input: buildDataSource() { DataSource dataSource = SQLUtils.buildDataSource("127.0.0.1:2881", "test", "teat", "test"); "<AssertPlaceHolder>"; }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
[+] input: testDecryptHandler() { Pair<String, String> pair = EncryptionHandler.decryptHandler("test-dataId", "12345678", "content"); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(pair)
[-] pred: org. junit. Assert. assertNotNull ( pair )
************************************
[+] input: shouldReturnTimestampedKeyValueStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlyKeyValueStore<String, ValueAndTimestamp<String>>> stores = provider.stores("ts-kv-store", QueryableStoreTypes.timestampedKeyValueStore()); "<AssertPlaceHolder>"; for (final ReadOnlyKeyValueStore<String, ValueAndTimestamp<String>> store : stores) { assertThat(store, instanceOf(ReadOnlyKeyValueStore.class)); assertThat(store, instanceOf(TimestampedKeyValueStore.class)); } }
[*] target: assertEquals(1, stores.size())
[-] pred: org. junit. Assert. assertEquals ( 1, stores. size ( ) )
************************************
[+] input: testLoadObject() { ConfigMetadata configMetadata = YamlParserUtil.loadObject(CONFIG_METADATA_STRING, ConfigMetadata.class); Assert."<AssertPlaceHolder>";  List<ConfigMetadata.ConfigExportItem> metadataList = configMetadata.getMetadata(); Assert.assertNotNull(metadataList); Assert.assertEquals(metadataList.size(), 2); ConfigMetadata.ConfigExportItem configExportItem1 = metadataList.get(0); ConfigMetadata.ConfigExportItem configExportItem2 = metadataList.get(1); Assert.assertEquals(configExportItem1, item1); Assert.assertEquals(configExportItem2, item2); }
[*] target: assertNotNull(configMetadata)
[-] pred: org. junit. Assert. assertNotNull ( configMetadata )
************************************
[+] input: generate_autoIncrement_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) expire_info=(1) auto_increment=15"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setExpireInfo(new ConstExpression("1")); tableOptions.setAutoIncrement(new BigDecimal("15")); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_depthFirstSearch_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name (col1, col2) as (select * from dual) search depth first by col2 desc, col3 asc set varname select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); expect.setSearchMode(SearchMode.DEPTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testInstance() { MapperManager instance = MapperManager.instance(false); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
[+] input: generate_trim_generateFunctionCallSucceed() { ExprContext context = getExprContext("trim(both '123' from 'abc')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'123'")); p.addOption(new ConstExpression("'abc'")); params.add(p); FunctionCall expect = new FunctionCall("trim", params); expect.addOption(new ConstExpression("both")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_useBloomFilter_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) use_bloom_filter=false"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setUseBloomFilter(false); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetGroupIdList() {  int page = 10; int pageSize = 100; //mock select config state List<String> groupStrings = Arrays.asList("group1", "group2", "group3"); when(jdbcTemplate.queryForList(anyString(), eq(new Object[] {}), eq(String.class))).thenReturn(groupStrings); //execute return mock obj List<String> returnGroups = externalConfigInfoPersistService.getGroupIdList(page, pageSize);  //expect check Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(groupStrings, returnGroups)
[-] pred: org. junit. Assert. assertEquals ( groupStrings, returnGroups )
************************************
[+] input: IOException { PageManager pageManager = getPageManager(5); List<Page> pages = pageManager.create(13); List<Page> readPages = pageManager.get(pages.stream().map(Page::getPhysicalPageId).collect(Collectors.toList())); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(pages.size(), readPages.size())
[-] pred: org. junit. Assert. assertEquals ( pages. size ( ), readPages. size ( ) )
************************************
[+] input: Exception { setTempEnvVars(Map.of("VALUE1", "value$1", "VALUE2", "2", "VALUE3", "value-_/!"\'3!§%&/()=?`*,;.:[]|{}"));  final String testString = "<test1><test2 id="VALUE1"><test3>${ENV:VALUE1}</test3><test4>${ENV:VALUE2}</test4><test5>${ENV:VALUE3}</test5></test2></test1>";  final String result = EnvVarUtil.replaceEnvironmentVariablePlaceholders(testString);  final String expected = "<test1><test2 id="VALUE1"><test3>value$1</test3><test4>2</test4><test5>value-_/!"\'3!§%&/()=?`*,;.:[]|{}</test5></test2></test1>";  "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
[+] input: generate_withColumnGroup_allColumns_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns)"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_castAsJson_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as json)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); p.addOption(new GeneralDataType("json", null)); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldFindTask() { TaskSummary taskSummary = TestUtils.loadTaskSnapshot(objectMapper, "task_summary"); indexDAO.indexTask(taskSummary);  List<TaskSummary> tasks = tryFindResults(() -> searchTaskSummary(taskSummary)); "<AssertPlaceHolder>"; assertEquals(taskSummary, tasks.get(0)); }
[*] target: assertEquals(1, tasks.size())
[-] pred: org. junit. Assert. assertEquals ( 1, tasks. size ( ) )
************************************
[+] input: testAddAggrConfigInfoOfEqualContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and equal with current content param. String existContent = "content1234"; when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenReturn(existContent);  boolean result = externalConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_predicateNotLikeEscapeSimpleExpr_generateSucceed() { ExprContext context = getExprContext("tab.col not like abc escape bcd"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new CompoundExpression(new ColumnReference(null, null, "abc"), new ColumnReference(null, null, "bcd"), Operator.ESCAPE); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test_ModelToEntity_Success() { AuditEvent model = AuditEvent.builder() .connectionName("test") .connectionId(1L) .clientIpAddress("0.0.0.0") .serverIpAddress("0.0.0.0") .organizationId(1L) .taskId("1") .action(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION) .type(AuditEventType.PERSONAL_CONFIGURATION) .userId(1L) .username("account") .result(AuditEventResult.SUCCESS) .detail("{detail:null}") .build();  AuditEventEntity expected = new AuditEventEntity(); expected.setConnectionName("test"); expected.setConnectionId(1L); expected.setTaskId("1"); expected.setResult(AuditEventResult.SUCCESS); expected.setDetail("{detail:null}"); expected.setUserId(1L); expected.setOrganizationId(1L); expected.setServerIpAddress("0.0.0.0"); expected.setClientIpAddress("0.0.0.0"); expected.setAction(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION); expected.setType(AuditEventType.PERSONAL_CONFIGURATION); expected.setUsername("account");  AuditEventEntity actual = mapper.modelToEntity(model); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: testNoFilterSampleByTimestampReverse() { AbstractResult indexResult = new RangeResult(baseIndex, Collections.singletonList(new RangeUnit(0, 9)));  String sampleMeta = "topk(by=weight, limit=5, reverse=true, replacement=false)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(9, 8, 7, 6, 5); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_intervalBitExpr_generateSucceed() { Bit_exprContext context = getBitExprContext("interval 4 day + 1"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression right = new ConstExpression("1"); Expression left = new IntervalExpression(new ConstExpression("4"), "day"); Expression expect = new CompoundExpression(left, right, Operator.ADD); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: ParseException { String dateStr = "Wed, 21 Feb 2007 15:35:00 +0100"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
[+] input: IllegalAccessException { HttpClientFactory factory = new AbstractApacheHttpClientFactory() { @Override protected HttpClientConfig buildHttpClientConfig() { return HttpClientConfig.builder().build(); }  @Override protected Logger assignLogger() { return logger; } }; NacosRestTemplate template = factory.createNacosRestTemplate(); "<AssertPlaceHolder>"; Field field = NacosRestTemplate.class.getDeclaredField("requestClient"); field.setAccessible(true); HttpClientRequest requestClient = (HttpClientRequest) field.get(template); assertTrue(requestClient instanceof DefaultHttpClientRequest); }
[*] target: assertNotNull(template)
[-] pred: org. junit. Assert. assertNotNull ( template )
************************************
[+] input: generate_groupingSetsGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by GROUPING SETS(col, ROLLUP(col), CUBE(col1))"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();   GroupBy g1 = new GeneralGroupBy(new RelationReference("col", null)); ExpressionParam p1 = new ExpressionParam(new RelationReference("col", null)); GroupBy g2 = new GeneralGroupBy(new FunctionCall("ROLLUP", Collections.singletonList(p1))); ExpressionParam p2 = new ExpressionParam(new RelationReference("col1", null)); GroupBy g3 = new GeneralGroupBy(new FunctionCall("CUBE", Collections.singletonList(p2))); GroupBy expect = new GroupingSetsGroupBy(Arrays.asList(g1, g2, g3)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_predicateNotLikeSimpleExpr_generateSucceed() { ExprContext context = getExprContext("tab.col not like abc"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new ColumnReference(null, null, "abc"); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_splitPartitionRange_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b at(1,2) into (partition,partition id 12,partition a.b id 13)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); actions.setRangeExprs(Arrays.asList(new ConstExpression("1"), new ConstExpression("2"))); SpecialPartitionElement e1 = new SpecialPartitionElement(null); SpecialPartitionElement e2 = new SpecialPartitionElement(null); PartitionOptions o1 = new PartitionOptions(); o1.setId(12); e2.setPartitionOptions(o1); SpecialPartitionElement e3 = new SpecialPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setId(13); e3.setPartitionOptions(o2); e3.setSchema("a"); actions.setIntos(Arrays.asList(e1, e2, e3)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testReplaceVariables_Success() { String template = "this is a test template, name=${name}"; Map<String, String> variables = new HashMap<>(); variables.put("name", "fake name");  String expected = "this is a test template, name=fake name"; String actual = MessageTemplateProcessor.replaceVariables(template, Locale.getDefault(), variables);  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: connectorConfig() { final String connName = "sink6"; final Map<String, String> expectedConfig = Collections.singletonMap("key", "value");  @SuppressWarnings("unchecked") ArgumentCaptor<Callback<Map<String, String>>> callback = ArgumentCaptor.forClass(Callback.class); doAnswer(invocation -> { callback.getValue().onCompletion(null, expectedConfig); return null; }).when(herder).connectorConfig(eq(connName), callback.capture());  Map<String, String> actualConfig = connectClusterState.connectorConfig(connName);  "<AssertPlaceHolder>"; assertNotSame( "Config should be copied in order to avoid mutation by REST extensions", expectedConfig, actualConfig ); }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
[+] input: generate_generalOrderByDesc_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select col from tab order by col desc;"); StatementFactory<OrderBy> factory = new MySQLOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy expect = new OrderBy(Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_hashPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) partitions 12 (" + "partition a.b@c," + "partition d id 14," + "partition id 15 tablespace tbs, " + "partition id 16 nocompress," + "partition id 17 tablespace tbs1 compress for oltp)")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); HashPartitionElement e3 = new HashPartitionElement(null); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); HashPartitionElement e4 = new HashPartitionElement(null); PartitionOptions options1 = new PartitionOptions(); options1.setId(16); options1.setNoCompress(true); e4.setPartitionOptions(options1); HashPartitionElement e5 = new HashPartitionElement(null); PartitionOptions options2 = new PartitionOptions(); options2.setId(17); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e5.setPartitionOptions(options2); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2, e3, e4, e5), null, 12); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: detail_detailByEmail_detailSucceed() { UserInfo expect = TestRandom.nextObject(UserInfo.class); userDAO.insert(expect); UserInfo actual = userDAO.detail(expect.getEmail()); expect.setId(actual.getId()); expect.setGmtCreated(null); expect.setGmtModified(null); expect.setEnabled(true); actual.setEnabled(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: validateExists_Exists_ReturnTrue() { boolean ret = PreConditions.validExists(ResourceType.OB_TABLE, "tableName", "t1", () -> true); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(ret)
[-] pred: org. junit. Assert. assertTrue ( ret )
************************************
[+] input: testRelativize_scheme() { String base = toOSPathString("file:/home/eclipse/runtime-New_configuration/project_1/file.java"); String other = toOSPathString("file:/home/eclipse/runtime-New_configuration/project"); // 'file.java' is treated as a folder String expected = toOSPathString("../../project");  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_formatTableOp_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) kv_attributes='12' format=(ENCODING='aaaa',LINE_DELIMITER=123,SKIP_HEADER=12," + "EMPTY_FIELD_AS_NULL=true,NULL_IF_EXETERNAL=(1,2,3))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); Map<String, Expression> map = new HashMap<>(); map.put("ENCODING", new ConstExpression("'aaaa'")); map.put("EMPTY_FIELD_AS_NULL", new BoolValue(true)); map.put("SKIP_HEADER", new ConstExpression("12")); CollectionExpression es = new CollectionExpression(); es.addExpression(new ConstExpression("1")); es.addExpression(new ConstExpression("2")); es.addExpression(new ConstExpression("3")); map.put("NULL_IF_EXETERNAL", es); map.put("LINE_DELIMITER", new ConstExpression("123")); tableOptions.setFormat(map); tableOptions.setKvAttributes("'12'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getConverter() { HutoolConverterManager hutoolConverterManager = new HutoolConverterManager(); // force cast object to collection hutoolConverterManager.getConverter(Object.class, Collection.class); @SuppressWarnings("rawtypes") BiFunction<Object, Collection, Collection> converter = hutoolConverterManager .getConverter(Object.class, Collection.class); Assert."<AssertPlaceHolder>";  Object obj = new Object(); Assert.assertEquals(CollectionUtils.newCollection(ArrayList::new, obj), converter.apply(obj, null)); Assert.assertEquals(converter.apply(Collections.singleton(obj), null), converter.apply(Collections.singleton(obj), null)); }
[*] target: assertNotNull(converter)
[-] pred: org. junit. Assert. assertNotNull ( converter )
************************************
[+] input: Exception { commitGraph = CommitGraphLoader .open(JGitTestUtil.getTestResourceFile("commit-graph.v1")); "<AssertPlaceHolder>"; assertEquals(10, commitGraph.getCommitCnt()); verifyGraphObjectIndex();  assertCommitData("85b0176af27fa1640868f061f224d01e0b295f59", new int[] { 5, 6 }, 1670570408L, 3, 0); assertCommitData("d4f7c00aab3f0160168c9e5991abb6194a4e0d9e", new int[] {}, 1670569901L, 1, 1); assertCommitData("4d03aaf9c20c97d6ccdc05cb7f146b1deb6c01d5", new int[] { 5 }, 1670570119L, 3, 2); assertCommitData("a2f409b753880bf83b18bfb433dd340a6185e8be", new int[] { 7 }, 1670569935L, 3, 3); assertCommitData("431343847343979bbe31127ed905a24fed9a636c", new int[] { 3, 2, 8 }, 1670570644L, 4, 4); assertCommitData("c3f745ad8928ef56b5dbf33740fc8ede6b598290", new int[] { 1 }, 1670570106L, 2, 5); assertCommitData("95b12422c8ea4371e54cd58925eeed9d960ff1f0", new int[] { 1 }, 1670570163L, 2, 6); assertCommitData("de0ea882503cdd9c984c0a43238014569a123cac", new int[] { 1 }, 1670569921L, 2, 7); assertCommitData("102c9d6481559b1a113eb66bf55085903de6fb00", new int[] { 6 }, 1670570616L, 3, 8); assertCommitData("b5de2a84867f8ffc6321649dabf8c0680661ec03", new int[] { 7, 5 }, 1670570364L, 3, 9); }
[*] target: assertNotNull(commitGraph)
[-] pred: org. junit. Assert. assertNotNull ( commitGraph )
************************************
[+] input: generate_regExp_generateSucceed() { PredicateContext context = getPredicateContext("regexp_like(1,2)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("regexp_like", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_predicateNotLikeEscapeMix_generateSucceed() { ExprContext context = getExprContext("tab.col not like 'abc' escape col"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression e1 = new ConstExpression("'abc'"); Expression e2 = new ColumnReference(null, null, "col"); Expression right = new CompoundExpression(e1, e2, Operator.ESCAPE); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_listPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list(a) partitions 145 (" + "partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); ListPartition expect = new ListPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 145, false); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testReduceSmallInput() { final StreamsBuilder builder = new StreamsBuilder(); final String topic = "topic"; final WindowBytesStoreSupplier storeSupplier = setupWindowBytesStoreSupplier(1); final Materialized<String, String, WindowStore<Bytes, byte[]>> materialized = setupMaterialized(emitFinal ? Materialized.as("store-name") : Materialized.as(storeSupplier));  final KTable<Windowed<String>, String> table = builder .stream(topic, Consumed.with(Serdes.String(), Serdes.String())) .groupByKey(Grouped.with(Serdes.String(), Serdes.String())) .windowedBy(SlidingWindows.ofTimeDifferenceAndGrace(ofMillis(10), ofMillis(5))) .emitStrategy(emitStrategy) .reduce( MockReducer.STRING_ADDER, materialized ); final MockApiProcessorSupplier<Windowed<String>, String, Void, Void> supplier = new MockApiProcessorSupplier<>(); table.toStream().process(supplier); try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) { final TestInputTopic<String, String> inputTopic = driver.createInputTopic(topic, new StringSerializer(), new StringSerializer()); inputTopic.pipeInput("A", "1", 10L); inputTopic.pipeInput("A", "2", 14L); inputTopic.pipeInput("A", "3", 15L); inputTopic.pipeInput("A", "4", 22L); inputTopic.pipeInput("A", "5", 26L); inputTopic.pipeInput("A", "6", 30L); }  final Map<Long, Set<ValueAndTimestamp<String>>> actual = gatherOutput(supplier); final Map<Long, Set<ValueAndTimestamp<String>>> expected = new HashMap<>();  if (emitFinal) { expected.put(0L, mkSet(ValueAndTimestamp.make("1", 10L))); expected.put(4L, mkSet(ValueAndTimestamp.make("1+2", 14L))); expected.put(5L, mkSet(ValueAndTimestamp.make("1+2+3", 15L))); expected.put(11L, mkSet(ValueAndTimestamp.make("2+3", 15L))); expected.put(12L, mkSet(ValueAndTimestamp.make("2+3+4", 22L))); } else { expected.put(0L, mkSet(ValueAndTimestamp.make("1", 10L))); expected.put(4L, mkSet(ValueAndTimestamp.make("1+2", 14L))); expected.put(5L, mkSet(ValueAndTimestamp.make("1+2+3", 15L))); expected.put(11L, mkSet( ValueAndTimestamp.make("2", 14L), ValueAndTimestamp.make("2+3", 15L) )); expected.put(12L, mkSet(ValueAndTimestamp.make("2+3+4", 22L))); expected.put(15L, mkSet( ValueAndTimestamp.make("3", 15L), ValueAndTimestamp.make("3+4", 22L) )); expected.put(16L, mkSet( ValueAndTimestamp.make("4", 22L), ValueAndTimestamp.make("4+5", 26L) )); expected.put(20L, mkSet(ValueAndTimestamp.make("4+5+6", 30L))); expected.put(23L, mkSet( ValueAndTimestamp.make("5", 26L), ValueAndTimestamp.make("5+6", 30L) )); expected.put(27L, mkSet(ValueAndTimestamp.make("6", 30L))); } "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_dateAdd_generateFunctionCallSucceed() { ExprContext context = getExprContext("DATE_ADD(tab, INTERVAL '12' DAY_HOUR)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, null, "tab"))); params.add(new ExpressionParam(new IntervalExpression(new ConstExpression("'12'"), "DAY_HOUR"))); FunctionCall expect = new FunctionCall("DATE_ADD", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_autoPartition1_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getAutoPartitionContext( "partition by range(b) partition size 'auto' PARTITIONS AUTO")); Partition actual = factory.generate();  RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "b")), null, null, null, false); expect.setAuto(true); expect.setPartitionSize(new ConstExpression("'auto'")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testSelectInstances() { ServiceInfo serviceInfo = new ServiceInfo(); serviceInfo.setGroupName("groupName"); serviceInfo.setName("serviceName"); serviceInfo.setChecksum("checkSum"); serviceInfo.setAllIPs(false); ServiceInfo cluster = ServiceUtil.selectInstances(serviceInfo, "cluster"); "<AssertPlaceHolder>"; }
[*] target: assertNotNull(cluster)
[-] pred: org. junit. Assert. assertNotNull ( cluster )
************************************
[+] input: testIsBucketExist_ReturnFalse() { boolean exists = bucketOperation.isBucketExist("whatever"); verify(bucketRepository, times(1)).findByName(anyString()); "<AssertPlaceHolder>"; }
[*] target: assertFalse(exists)
[-] pred: org. junit. Assert. assertFalse ( exists )
************************************
[+] input: test_AES256_BASE64() { String raw = RandomStringUtils.random(256); Encryption encryption = createEncryption(EncryptionAlgorithm.AES256_BASE64); String encrypted = EncryptionUtil.encrypt(raw, encryption); Assert.assertNotEquals(raw, encrypted); String decrypted = EncryptionUtil.decrypt(encrypted, encryption); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(raw, decrypted)
[-] pred: org. junit. Assert. assertEquals ( raw, decrypted )
************************************
[+] input: generate_uniqueListaggExprListWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "LISTAGG(unique 5,6 order by col1 asc SEPARATOR 'mmm') over (name_ob partition by (1,2) order by col desc rows between " + "current row and interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); FunctionParam ppp = new ExpressionParam(new ConstExpression("6")); params.add(ppp); FunctionCall expect = new FunctionCall("LISTAGG", params); expect.addOption(new ConstExpression("unique")); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset begin = new WindowOffset(WindowOffsetType.CURRENT_ROW); WindowOffset end = new WindowOffset(WindowOffsetType.FOLLOWING); end.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.ROWS, begin, end); window.setBody(body); expect.setWindow(window); SortKey s0 = new SortKey(new ColumnReference(null, null, "col1"), SortDirection.ASC); expect.addOption(new OrderBy(Collections.singletonList(s0))); expect.addOption(new ConstExpression("SEPARATOR 'mmm'")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_externalCreateTable_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create external table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setExternal(true); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { Map<String, Object> requestToWrite = new HashMap<>(); requestToWrite.put("name", CONNECTOR_NAME); requestToWrite.put("config", CONNECTOR_CONFIG); requestToWrite.put("unknown-field", "random-value");  try (FileWriter writer = new FileWriter(connectorConfigurationFile)) { writer.write(new ObjectMapper().writeValueAsString(requestToWrite)); }  CreateConnectorRequest parsedRequest = connectStandalone.parseConnectorConfigurationFile(connectorConfigurationFile.getAbsolutePath()); CreateConnectorRequest expectedRequest = new CreateConnectorRequest(CONNECTOR_NAME, CONNECTOR_CONFIG, null); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedRequest, parsedRequest)
[-] pred: org. junit. Assert. assertEquals ( expectedRequest, parsedRequest )
************************************
[+] input: generate_convertUsingUtf8_generateFunctionCallSucceed() { ExprContext context = getExprContext("convert('123' using utf8)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'123'")); p.addOption(new ConstExpression("utf8")); params.add(p); FunctionCall expect = new FunctionCall("convert", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test_EntityToModel_Success() { AuditEventMetaEntity entity = new AuditEventMetaEntity(); entity.setSidExtractExpression("test"); entity.setMethodSignature("controller"); entity.setEnabled(true); entity.setType(AuditEventType.PERSONAL_CONFIGURATION); entity.setAction(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION); entity.setInConnection(true);  AuditEventMeta expected = AuditEventMeta.builder() .action(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION) .type(AuditEventType.PERSONAL_CONFIGURATION) .enabled(true) .inConnection(true) .methodSignature("controller") .sidExtractExpression("test") .build();  AuditEventMeta actual = mapper.entityToModel(entity); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: shouldGetAllStreamInstances() { final StreamsMetadata one = new StreamsMetadataImpl(hostOne, mkSet(globalTable, "table-one", "table-two", "merged-table"), mkSet(topic1P0, topic2P1, topic4P0), mkSet("table-one", "table-two", "merged-table"), mkSet(topic2P0, topic1P1)); final StreamsMetadata two = new StreamsMetadataImpl(hostTwo, mkSet(globalTable, "table-two", "table-one", "merged-table"), mkSet(topic2P0, topic1P1), mkSet("table-three"), mkSet(topic3P0)); final StreamsMetadata three = new StreamsMetadataImpl(hostThree, mkSet(globalTable, "table-three"), Collections.singleton(topic3P0), mkSet("table-one", "table-two", "merged-table"), mkSet(topic1P0, topic2P1, topic4P0));  final Collection<StreamsMetadata> actual = metadataState.getAllMetadata(); "<AssertPlaceHolder>"; assertTrue("expected " + actual + " to contain " + one, actual.contains(one)); assertTrue("expected " + actual + " to contain " + two, actual.contains(two)); assertTrue("expected " + actual + " to contain " + three, actual.contains(three)); }
[*] target: assertEquals(3, actual.size())
[-] pred: org. junit. Assert. assertEquals ( 3, actual. size ( ) )
************************************
[+] input: shouldOptimizeEmptyActiveTasks() { final RackAwareTaskAssignor assignor = new RackAwareTaskAssignor( getClusterForAllTopics(), getTaskTopicPartitionMapForAllTasks(), mkMap(), getTopologyGroupTaskMap(), getProcessRacksForAllProcess(), mockInternalTopicManager, getRackAwareEnabledConfig(), time );  final ClientState clientState1 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1);  clientState1.assignActiveTasks(mkSet(TASK_0_1, TASK_1_1));  final SortedMap<UUID, ClientState> clientStateMap = new TreeMap<>(mkMap( mkEntry(UUID_1, clientState1) )); final SortedSet<TaskId> taskIds = mkSortedSet();  assertTrue(assignor.canEnableRackAwareAssignor()); final long originalCost = assignor.activeTasksCost(taskIds, clientStateMap, trafficCost, nonOverlapCost); assertEquals(0, originalCost);  final long cost = assignor.optimizeActiveTasks(taskIds, clientStateMap, trafficCost, nonOverlapCost); "<AssertPlaceHolder>";  assertEquals(mkSet(TASK_0_1, TASK_1_1), clientState1.activeTasks()); }
[*] target: assertEquals(0, cost)
[-] pred: org. junit. Assert. assertEquals ( 0, cost )
************************************
[+] input: testListDeserialize() { Schema schema = new Schema(optional(1, "list_type", Types.ListType.ofOptional(2, Types.LongType.get())));  StructObjectInspector inspector = ObjectInspectorFactory.getStandardStructObjectInspector( Arrays.asList("list_type"), Arrays.asList( ObjectInspectorFactory.getStandardListObjectInspector( PrimitiveObjectInspectorFactory.writableLongObjectInspector)));  Deserializer deserializer = new Deserializer.Builder() .schema(schema) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(schema)) .sourceInspector(inspector) .build();  Record expected = GenericRecord.create(schema); expected.set(0, Collections.singletonList(1L));  Object[] data = new Object[] {new Object[] {new LongWritable(1L)}}; Record actual = deserializer.deserialize(data);  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: test_findByUpdateTimeBeforeAndTemp_return1() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.PRIVATE); connection.setTemp(true); repository.save(connection); List<ConnectionEntity> entities = repository.findByUpdateTimeBeforeAndTemp(new Date(new Date().getTime() + 5 * 1000L), true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(1, entities.size())
[-] pred: org. junit. Assert. assertEquals ( 1, entities. size ( ) )
************************************
[+] input: generate_countStarNameWin_generateSucceed() { Bit_exprContext context = getBitExprContext("count(all *) over name_ob"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("*"))); FunctionCall expect = new FunctionCall("count", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); expect.setWindow(window); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_leadWithWinBody1_generateSucceed() { Bit_exprContext context = getBitExprContext( "LEAD (5,1,2) respect nulls over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); FunctionCall expect = new FunctionCall("LEAD", params); expect.addOption(new ConstExpression("respect nulls")); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_updateWithoutWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getConfigContext() { ConfigResponse configResponse = new ConfigResponse(); IConfigContext configContext = configResponse.getConfigContext(); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(configContext)
[-] pred: org. junit. Assert. assertNotNull ( configContext )
************************************
[+] input: clearInactiveTempConnectionConfigs_Empty_Return0() { int ret = recycleService.clearInactiveTempConnectionConfigs(); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(0, ret)
[-] pred: org. junit. Assert. assertEquals ( 0, ret )
************************************
[+] input: testToObjectId() { MutableLongObjectId m = new MutableLongObjectId(); m.fromRaw(new long[] { 1L, 2L, 3L, 4L }); "<AssertPlaceHolder>"; }
[*] target: assertEquals(m, m.toObjectId())
[-] pred: org. junit. Assert. assertEquals ( m, m. toObjectId() )
************************************
[+] input: generate_createSpatialIndex_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create spatial index if not exists chz.abc on piaoyue.tb (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor relation = new RelationFactor("abc"); relation.setSchema("chz"); RelationFactor on = new RelationFactor("tb"); on.setSchema("piaoyue"); CreateIndex expect = new CreateIndex(relation, on, Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setSpatial(true); expect.setIfNotExists(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testIsOnFalse() { boolean stsOn = StsConfig.getInstance().isStsOn(); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(stsOn)
[-] pred: org. junit. Assert. assertFalse ( stsOn )
************************************
[+] input: testSimplyEnvNameIfOverLimit() { StringBuilder envNameOverLimitBuilder = new StringBuilder("test"); for (int i = 0; i < 50; i++) { envNameOverLimitBuilder.append(i); } String envName = envNameOverLimitBuilder.toString(); String actual = ParamUtil.simplyEnvNameIfOverLimit(envName); String expect = envName.substring(0, 50) + MD5Utils.md5Hex(envName, "UTF-8"); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_cur_date_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("CURRENT_DATE()"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionCall expect = new FunctionCall("CURRENT_DATE", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetConfigContext() { ConfigRequest configRequest = new ConfigRequest(); IConfigContext configContext = configRequest.getConfigContext(); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(configContext)
[-] pred: org. junit. Assert. assertNotNull ( configContext )
************************************
[+] input: IOException { ConnectionSession session = new TestConnectionSession( sessionid, new ByteArrayInputStream("abcd".getBytes())); Mockito.when(sessionService.nullSafeGet(sessionid)).thenReturn(session); CrossLinkedVirtualTable table = new CrossLinkedVirtualTable("tableId"); long rowId = 1; int colId = 1; BinaryContentMetaData metaData = new BinaryContentMetaData("filePath", 0, 0); VirtualElement elt = new CommonVirtualElement("tableId", rowId, colId, "test_type", "test_name", metaData); table.put(elt); ConnectionSessionUtil.setQueryCache(session, table); BinaryContent actual = consoleService.getBinaryContent(sessionid, "tableId", rowId, colId, 2L, 1, ValueEncodeType.TXT); BinaryContent expect = new BinaryContent("c".getBytes(), 4, ValueEncodeType.TXT); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_PERCENTILE_DISC_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("PERCENTILE_DISC(all col) within group(order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("PERCENTILE_DISC", Collections.singletonList(new ExpressionParam(new RelationReference("col", null)))); expect.addOption(new ConstExpression("all")); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.setWithinGroup(new OrderBy(Collections.singletonList(s))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: IOException { File tempFile = File.createTempFile("test", null, new File(".")); tempFile.deleteOnExit();  boolean exists = PreConditions.validExists(tempFile);  Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
[+] input: shouldNotForwardCleanEntryOnEviction() { final ThreadCache cache = new ThreadCache(logContext, 0, new MockStreamsMetrics(new Metrics())); final List<ThreadCache.DirtyEntry> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace, received::addAll); cache.put(namespace, Bytes.wrap(new byte[]{1}), cleanEntry(new byte[]{0})); "<AssertPlaceHolder>"; }
[*] target: assertEquals(0, received.size())
[-] pred: org. junit. Assert. assertEquals ( 0, received. size ( ) )
************************************
[+] input: testStringBlankAndThenExecuteFail() { String word = "   "; final String expect = "call"; String actual = TemplateUtils.stringBlankAndThenExecute(word, () -> expect); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test1() { TestConditionAnnotationParser1 parser = new TestConditionAnnotationParser1(SimpleAnnotationFinder.INSTANCE); Field field1 = AbstractConditionParserTest.class.getDeclaredField("field1"); Assert.assertNotNull(field1); KeyTriggerOperation operation1 = SimpleKeyTriggerOperation.builder() .source(field1).id(field1.getName()).key(field1.getName()) .build(); Condition condition1 = CollectionUtils.getFirstNotNull(parser.parse(field1, operation1)); Assert."<AssertPlaceHolder>"; Assert.assertTrue(condition1.test(null, operation1)); }
[*] target: assertNotNull(condition1)
[-] pred: org. junit. Assert. assertNotNull ( condition1 )
************************************
[+] input: shouldMatchPositionAfterPut() { final MeteredWindowStore<Integer, String> meteredSessionStore = (MeteredWindowStore<Integer, String>) windowStore; final ChangeLoggingWindowBytesStore changeLoggingSessionBytesStore = (ChangeLoggingWindowBytesStore) meteredSessionStore.wrapped(); final InMemoryWindowStore inMemoryWindowStore = (InMemoryWindowStore) changeLoggingSessionBytesStore.wrapped();  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); windowStore.put(0, "0", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); windowStore.put(1, "1", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); windowStore.put(2, "2", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 4, 0, "", new RecordHeaders())); windowStore.put(3, "3", SEGMENT_INTERVAL);  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 4L))))); final Position actual = inMemoryWindowStore.getPosition(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_createIndexWithColumnGroup_allColumns_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: listDatabaseChangingOrderTemplates_useQueryCondition_succeed() { Database database = new Database(); when(databaseService.listDatabasesByIds(any())).thenReturn(Arrays.asList(database)); createDatabaseChangingOrderTemplate_saveEntity_succeed(); Pageable pageable = Pageable.unpaged(); QueryDatabaseChangeChangingOrderParams params = QueryDatabaseChangeChangingOrderParams.builder() .projectId(PROJECT_ID).creatorId(CURRENT_USER_ID).name(TEMPLATE_NAME).build(); Page<DatabaseChangeChangingOrderTemplateResp> result = templateService.listTemplates(pageable, params); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, result.getContent().size()); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
[+] input: NacosException { final String dataId = "1failover"; final String group = "2"; final String tenant = "";  MockedStatic<LocalConfigInfoProcessor> localConfigInfoProcessorMockedStatic = Mockito.mockStatic( LocalConfigInfoProcessor.class); try { String contentFailOver = "failOverContent" + System.currentTimeMillis(); localConfigInfoProcessorMockedStatic.when( () -> LocalConfigInfoProcessor.getFailover(any(), eq(dataId), eq(group), eq(tenant))) .thenReturn(contentFailOver); final int timeout = 3000;  final String config = nacosConfigService.getConfig(dataId, group, timeout); Assert."<AssertPlaceHolder>"; } finally { localConfigInfoProcessorMockedStatic.close(); } }
[*] target: assertEquals(contentFailOver, config)
[-] pred: org. junit. Assert. assertEquals ( contentFailOver, config )
************************************
[+] input: Exception { final File file = testKeyStoreGenerator.generateKeyStore("teststore", "JKS", "passwd1", "passwd2"); final String keystorePath = file.getAbsolutePath();   final Tls tls = new Tls.Builder() .withKeystorePath(keystorePath) .withKeystoreType("JKS") .withKeystorePassword("passwd1") .withPrivateKeyPassword("passwd2") .withProtocols(new ArrayList<>()) .withTruststorePath(keystorePath) .withTruststoreType("JKS") .withTruststorePassword("passwd1") .withClientAuthMode(Tls.ClientAuthMode.OPTIONAL) .withCipherSuites(new ArrayList<>()) .withHandshakeTimeout(10000) .build();   final SslContext sslContext1 = sslFactory.getSslContext(tls); final SslContext sslContext2 = sslFactory.getSslContext(tls);  "<AssertPlaceHolder>"; }
[*] target: assertEquals(sslContext1, sslContext2)
[-] pred: org. junit. Assert. assertEquals ( sslContext1, sslContext2 )
************************************
[+] input: Exception { final ByteBuf byteBuf = Bytes.prefixBytes(new byte[0], Unpooled.buffer()); final int size = byteBuf.readUnsignedShort();  "<AssertPlaceHolder>"; assertEquals(false, byteBuf.isReadable()); }
[*] target: assertEquals(0, size)
[-] pred: org. junit. Assert. assertEquals ( 0, size )
************************************
[+] input: generate_rangePartitionWithSubPartitionOptionsIndividual_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) subpartition by range (c) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue)," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "range"); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testPatchConfig() { HashMap<String, String> config = new HashMap<>(); config.put("unaffected-key", "unaffected-value"); config.put("to-be-changed-key", "to-be-changed-value-old"); config.put("to-be-deleted-key", "to-be-deleted-value");  HashMap<String, String> patch = new HashMap<>(); patch.put("to-be-changed-key", "to-be-changed-value-new"); patch.put("to-be-deleted-key", null); patch.put("to-be-added-key", "to-be-added-value");  HashMap<String, String> expectedResult = new HashMap<>(); expectedResult.put("unaffected-key", "unaffected-value"); expectedResult.put("to-be-changed-key", "to-be-changed-value-new"); expectedResult.put("to-be-added-key", "to-be-added-value");  Map<String, String> result = ConnectUtils.patchConfig(config, patch); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
[+] input: generate_fullTextIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("fulltext index using btree (col asc id 16, col1) invisible")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setVisible(false); expect.setIndexOptions(indexOptions); expect.setFullText(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: convertBinaryToInvisibleStringTest() { Log.i(TAG, "------------ convertBinaryToInvisibleStringTest: ------------"); String binaryMessage = EncodeHelper.convertByteArrayToBinary(loremMessage.getBytes(StandardCharsets.UTF_8)); String invisibleResult = EncodeHelper.convertBinaryToInvisibleString(binaryMessage); "<AssertPlaceHolder>"; }
[*] target: assertNotNull(invisibleResult)
[-] pred: org. junit. Assert. assertNotNull ( invisibleResult )
************************************
[+] input: generate_rangePartitionWithSubPartitionOptions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) subpartition by range (c) subpartition template (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue)(" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue)," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "range"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: verifyingTopicCleanupPolicyShouldReturnFalseWhenClusterAuthorizationError() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithClusterAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
[+] input: attempt_FirstSuccess_ReturnSuccess() { FailedLoginAttemptLimiter limiter = new FailedLoginAttemptLimiter(1, 1000L);  Boolean result = limiter.attempt(() -> true);  Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: addServiceInstance() { boolean result = abstractClient.addServiceInstance(service, instancePublishInfo); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: generate_deleteWithoutWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab"); StatementFactory<Delete> factory = new MySQLDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_comment_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) lob_inrow_threshold=456 comment 'aaaaa'"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setComment("'aaaaa'"); tableOptions.setLobInRowThreshold(456); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_lnnvl_generateSucceed() { PredicateContext context = getPredicateContext("lnnvl(col = '12')"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("lnnvl", Collections.singletonList( new ExpressionParam(new CompoundExpression(new RelationReference("col", null), new ConstExpression("'12'"), Operator.EQ)))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: implies_DifferentResourceType_impliesFalse() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_DATABASE"), "DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "DBA"); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(permission.implies(permission1))
[-] pred: org. junit. Assert. assertFalse ( permission. implies( permission1 ) )
************************************
[+] input: generate_keyPartition_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by key (a,d) subpartition by key(c) subpartition template (" + "subpartition a," + "subpartition b engine=InnoDB) partitions 144 (" + "partition a.b," + "partition d id 14)")); Partition actual = factory.generate();  SubHashPartitionElement se1 = new SubHashPartitionElement("a"); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setEngine("InnoDB"); se2.setPartitionOptions(o2); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "key"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); KeyPartition expect = new KeyPartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "d")), Arrays.asList(e1, e2), subPartitionOption, 144); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetWithPrefixNotFound() { Map<String, String> result = tree.getWithPrefix("cheese"); "<AssertPlaceHolder>"; }
[*] target: assertEquals(0, result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
[+] input: generate_stddevPopExpr_generateFunctionCallSucceed() { ExprContext context = getExprContext("STDDEV_POP(all 1)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); FunctionCall expect = new FunctionCall("STDDEV_POP", params); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test_fail_code_string() { output.authorizerPresent(); output.failAuthorization(AckReasonCode.TOPIC_NAME_INVALID, "test-string"); task.onSuccess(output);  channel.runPendingTasks();  final AuthorizeWillResultEvent resultEvent = eventsCollector.pollEvent(); "<AssertPlaceHolder>"; assertEquals(AckReasonCode.TOPIC_NAME_INVALID, resultEvent.getResult().getAckReasonCode()); assertEquals("test-string", resultEvent.getResult().getReasonString()); }
[*] target: assertNotNull(resultEvent)
[-] pred: org. junit. Assert. assertNotNull ( resultEvent )
************************************
[+] input: testEquals() { DataVersion dataVersion = new DataVersion(); DataVersion other = new DataVersion(); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(dataVersion.equals(other))
[-] pred: org. junit. Assert. assertTrue ( dataVersion. equals ( other ) )
************************************
[+] input: generate_createIndex_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_hashPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by hash(a) partitions 12 (" + "partition a.b," + "partition d id 14)")); Partition actual = factory.generate();  HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 12); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: get() { List<Container<Object>> containers = factory.get(service, annotatedMethod, findAnnotations(annotatedMethod)); Container<Object> container = CollectionUtils.get(containers, 0); Assert.assertTrue(container instanceof CacheableContainer);  Object cachedA = container.get(Collections.singleton("a")).get("a"); Assert.assertNotNull(cachedA); Object a = container.get(Collections.singleton("a")).get("a"); Assert."<AssertPlaceHolder>"; }
[*] target: assertSame(cachedA, a)
[-] pred: org. junit. Assert. assertSame ( cachedA, a )
************************************
[+] input: testRegisterOperatorProxyMethodFactory() { Crane4jTemplate.OpsForProxy ops = crane4jTemplate.opsForProxy(); AtomicBoolean processed = new AtomicBoolean(false); Assert.assertSame( ops, ops.registerOperatorProxyMethodFactory(new OperatorProxyMethodFactory() { @Override public int getSort() { return -1; } @Override public @Nullable MethodInvoker get( BeanOperations beanOperations, Method method, BeanOperationExecutor beanOperationExecutor) { processed.set(true); return null; } }) ); ops.createOperatorProxy(TestOperatorProxy.class); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(processed.get())
[-] pred: org. junit. Assert. assertTrue ( processed. get ( ) )
************************************
[+] input: createMethodInvokerContainerCreator() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); MethodInvokerContainerCreator containerCreator = ConfigurationUtil.createMethodInvokerContainerCreator(configuration); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(containerCreator)
[-] pred: org. junit. Assert. assertNotNull ( containerCreator )
************************************
[+] input: generate_predicateNotBetween_generateSucceed() { ExprContext context = getExprContext("tab.col not between col and col1"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new CompoundExpression(new ColumnReference(null, null, "col"), new ColumnReference(null, null, "col1"), Operator.AND); Expression expect = new CompoundExpression(left, right, Operator.NOT_BETWEEN); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_useBloomFilter_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) use_bloom_filter=false"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setUseBloomFilter(false); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getYamlDataObjectTest() {  Map<String, Object> map = AclUtils.getYamlDataObject("src/test/resources/conf/plain_acl_correct.yml", Map.class); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(map.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( map. isEmpty ( ) )
************************************
[+] input: generate_firstValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "FIRST_VALUE (5 respect nulls) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p1 = new ExpressionParam(new ConstExpression("5")); params.add(p1); FunctionCall expect = new FunctionCall("FIRST_VALUE", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); expect.addOption(new ConstExpression("respect nulls")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: InterruptedException { final EmbeddedChannel channel = new EmbeddedChannel(); final ClientConnection clientConnection = new ClientConnection(channel, null); clientConnection.setProtocolVersion(ProtocolVersion.MQTTv5); channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).set(clientConnection); when(connectionPersistence.get("client")).thenReturn(clientConnection); when(localPersistence.getSession(eq("client"), anyBoolean(), anyBoolean())).thenReturn(new ClientSession(true, 0)); final ListenableFuture<Boolean> future = clientSessionPersistence.forceDisconnectClient("client", true, ClientSessionPersistenceImpl.DisconnectSource.EXTENSION); channel.disconnect(); final Boolean result = future.get(); "<AssertPlaceHolder>"; verify(pendingWillMessages).cancelWillIfPending("client"); verify(mqttServerDisconnector).disconnect(any(Channel.class), anyString(), anyString(), eq(Mqtt5DisconnectReasonCode.ADMINISTRATIVE_ACTION), any()); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: testIsOnTrue() { StsConfig.getInstance().setSecurityCredentials("abc"); boolean stsOn = StsConfig.getInstance().isStsOn(); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(stsOn)
[-] pred: org. junit. Assert. assertTrue ( stsOn )
************************************
[+] input: implies_resourcePermission_impliesTrue() { ResourcePermission permission = new ResourcePermission(new DefaultSecurityResource("*", "*"), "create,write"); ResourcePermission permission1 = new ResourcePermission(new DefaultSecurityResource("12", "conn"), "create"); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(permission.implies(permission1))
[-] pred: org. junit. Assert. assertTrue ( permission. implies( permission1 ) )
************************************
[+] input: generate_listPartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list columns (a,b) (" + "partition a.b values in (default) (" + "subpartition a.b values in (2) Engine=InnoDB," + "subpartition b values in ('maxvalue'))," + "partition d values in (3) id 14)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); se1.setPartitionOptions(o); SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2), null, null, true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldCreateWriteBatches() { final String key = "a"; final Collection<ConsumerRecord<byte[], byte[]>> records = new ArrayList<>(); records.add(new ConsumerRecord<>("", 0, 0L, serializeKey(new Windowed<>(key, windows[0]), true).get(), serializeValue(50L))); records.add(new ConsumerRecord<>("", 0, 0L, serializeKey(new Windowed<>(key, windows[3]), true).get(), serializeValue(100L))); final Map<S, WriteBatch> writeBatchMap = bytesStore.getWriteBatches(records); "<AssertPlaceHolder>";  final int expectedCount = getIndexSchema() == null ? 1 : 2; for (final WriteBatch batch : writeBatchMap.values()) { // 2 includes base and index record assertEquals(expectedCount, batch.count()); } }
[*] target: assertEquals(2, writeBatchMap.size())
[-] pred: org. junit. Assert. assertEquals ( 2, writeBatchMap. size ( ) )
************************************
[+] input: generate_parallel_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) parallel 12, noparallel"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_listaggwithingroup_generateSucceed() { Bit_exprContext context = getBitExprContext( "listagg(1,2,3) within group (order by col desc) over (partition by (1,2) order by col desc rows between current row and 123 PRECEDING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); params.add(new ExpressionParam(new ConstExpression("3"))); FunctionCall expect = new FunctionCall("listagg", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); expect.setWithinGroup(orderBy); WindowOffset begin = new WindowOffset(WindowOffsetType.CURRENT_ROW); WindowOffset end = new WindowOffset(WindowOffsetType.PRECEDING); end.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.ROWS, begin, end); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test_Operate_String() { boolean contains = EventParseUtil.validate("Hello world!", "equals", "Hello world!"); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
[+] input: test_RAW() { String raw = RandomStringUtils.random(256); Encryption encryption = createEncryption(EncryptionAlgorithm.RAW); String encrypted = EncryptionUtil.encrypt(raw, encryption); Assert.assertEquals(raw, encrypted); String decrypted = EncryptionUtil.decrypt(encrypted, encryption); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(raw, decrypted)
[-] pred: org. junit. Assert. assertEquals ( raw, decrypted )
************************************
[+] input: generate_cubeGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by CUBE(col, col1)"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();  ExpressionParam p1 = new ExpressionParam(new RelationReference("col", null)); ExpressionParam p2 = new ExpressionParam(new RelationReference("col1", null)); FunctionCall fCall = new FunctionCall("CUBE", Arrays.asList(p1, p2)); GroupBy expect = new GeneralGroupBy(fCall); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_deleteWithWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab where col=100"); StatementFactory<Delete> factory = new MySQLDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); ColumnReference left = new ColumnReference(null, null, "col"); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: listDBSchemasWithSqlTypes_anonymousBlock_listSucceed() { String pl = "DECLARE\n" + "    i VARCHAR2(300);\n" + "BEGIN\n" + "    select ps_auto_refresh_publish_pkg.getloopup_meaning('YES_NO', 'Y') into i from dual;\n" + "    dbms_output.put_line(i);\n" + "END;"; Map<DBSchemaIdentity, Set<SqlType>> actual = DBSchemaExtractor.listDBSchemasWithSqlTypes( Collections.singletonList(SqlTuple.newTuple(pl)), DialectType.OB_ORACLE, "aps"); Map<DBSchemaIdentity, Set<SqlType>> expect = new HashMap<>(); DBSchemaIdentity dbSchemaIdentity = new DBSchemaIdentity(); dbSchemaIdentity.setSchema("PS_AUTO_REFRESH_PUBLISH_PKG"); expect.put(dbSchemaIdentity, Collections.singleton(SqlType.OTHERS)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getSubscriber() { addServiceSubscriber(); Subscriber subscriber1 = abstractClient.getSubscriber(service); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(subscriber1)
[-] pred: org. junit. Assert. assertNotNull ( subscriber1 )
************************************
[+] input: ParseException { String dateStr = "Wed Feb 21 15:35:00 2007 +0100"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("EEE MMM dd HH:mm:ss yyyy Z") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
[+] input: Exception { when(executionDAO.getWorkflow(any(), anyBoolean())).thenReturn(new WorkflowModel()); Workflow workflow = executionDAOFacade.getWorkflow("workflowId", true); "<AssertPlaceHolder>"; verify(indexDAO, never()).get(any(), any()); }
[*] target: assertNotNull(workflow)
[-] pred: org. junit. Assert. assertNotNull ( workflow )
************************************
[+] input: testTaskOps() { List<TaskModel> tasks = new LinkedList<>(); String workflowId = UUID.randomUUID().toString();  for (int i = 0; i < 3; i++) { TaskModel task = new TaskModel(); task.setScheduledTime(1L); task.setSeq(1); task.setTaskId(workflowId + "_t" + i); task.setReferenceTaskName("testTaskOps" + i); task.setRetryCount(0); task.setWorkflowInstanceId(workflowId); task.setTaskDefName("testTaskOps" + i); task.setStatus(TaskModel.Status.IN_PROGRESS); tasks.add(task); }  for (int i = 0; i < 3; i++) { TaskModel task = new TaskModel(); task.setScheduledTime(1L); task.setSeq(1); task.setTaskId("x" + workflowId + "_t" + i); task.setReferenceTaskName("testTaskOps" + i); task.setRetryCount(0); task.setWorkflowInstanceId("x" + workflowId); task.setTaskDefName("testTaskOps" + i); task.setStatus(TaskModel.Status.IN_PROGRESS); getExecutionDAO().createTasks(Collections.singletonList(task)); }  List<TaskModel> created = getExecutionDAO().createTasks(tasks); assertEquals(tasks.size(), created.size());  List<TaskModel> pending = getExecutionDAO().getPendingTasksForTaskType(tasks.get(0).getTaskDefName()); assertNotNull(pending); assertEquals(2, pending.size()); // Pending list can come in any order.  finding the one we are looking for and then // comparing TaskModel matching = pending.stream() .filter(task -> task.getTaskId().equals(tasks.get(0).getTaskId())) .findAny() .get(); assertTrue(EqualsBuilder.reflectionEquals(matching, tasks.get(0)));  for (int i = 0; i < 3; i++) { TaskModel found = getExecutionDAO().getTask(workflowId + "_t" + i); assertNotNull(found); found.getOutputData().put("updated", true); found.setStatus(TaskModel.Status.COMPLETED); getExecutionDAO().updateTask(found); }  List<String> taskIds = tasks.stream().map(TaskModel::getTaskId).collect(Collectors.toList()); List<TaskModel> found = getExecutionDAO().getTasks(taskIds); assertEquals(taskIds.size(), found.size()); found.forEach( task -> { assertTrue(task.getOutputData().containsKey("updated")); assertEquals(true, task.getOutputData().get("updated")); boolean removed = getExecutionDAO().removeTask(task.getTaskId()); assertTrue(removed); });  found = getExecutionDAO().getTasks(taskIds); "<AssertPlaceHolder>"; }
[*] target: assertTrue(found.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( found. isEmpty ( ) )
************************************
[+] input: testName() { String name = "test"; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setName(name); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(name, config.name())
[-] pred: org. junit. Assert. assertEquals ( name, config. name() )
************************************
[+] input: generate_WMSYS_Dot_WM_CONCATWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "WMSYS.WM_CONCAT(1) keep (DENSE_RANK first order by col asc) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); FunctionCall expect = new FunctionCall("WMSYS.WM_CONCAT", params); SortKey s0 = new SortKey(new RelationReference("col", null), SortDirection.ASC); expect.setKeep(new KeepClause("first", new OrderBy(Collections.singletonList(s0)))); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_onlyColumnDefExists_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test_Operate_Regex() { boolean contains = EventParseUtil.validate("Hello world!", "matches", "Hello.*"); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
[+] input: createShouldReturnFalseWhenSuppliedNullTopicDescription() { Cluster cluster = createCluster(1); try (TopicAdmin admin = new TopicAdmin(new MockAdminClient(cluster.nodes(), cluster.nodeById(0)))) { boolean created = admin.createTopic(null); "<AssertPlaceHolder>"; } }
[*] target: assertFalse(created)
[-] pred: org. junit. Assert. assertFalse ( created )
************************************
[+] input: generate_rowMovement_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) enable row movement, disable row movement enable_extended_rowid=false"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setEnableRowMovement(true); tableOptions.setDisableRowMovement(true); tableOptions.setEnableExtendedRowId(false); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_memberOf_generateSucceed() { ExprContext context = getExprContext("tab.col member of(col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new ColumnReference(null, null, "col"); Expression expect = new CompoundExpression(left, right, Operator.MEMBER_OF); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_updateAssignmentWithColumnList_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE tab1 SET (col1,col2) = (SELECT tab2.col1 from tab2 where tab2.col2='abcd');"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab1", null); RelationReference relationReference = new RelationReference("tab2", new RelationReference("col1", null)); Projection p = new Projection(relationReference, null); NameReference from = new NameReference(null, "tab2", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new RelationReference("tab2", new RelationReference("col2", null)); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col1"), new ColumnReference(null, null, "col2")), body, false))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_decimalWithDecimalPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("dec(2E2)")); DataType actual = factory.generate();  DataType expect = new NumberType("dec", new BigDecimal("2E2"), null); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { final SettableFuture<PublishStatus> future = SettableFuture.create(); final PUBLISH publish = new PUBLISHFactory.Mqtt3Builder() .withHivemqId("hivemqId") .withPayload(new byte[]{0}) .withTopic("topic") .withQoS(QoS.AT_MOST_ONCE) .withOnwardQos(QoS.AT_MOST_ONCE) .withMessageExpiryInterval(MESSAGE_EXPIRY_INTERVAL_NOT_SET) .withPublishId(1L) .withPersistence(publishPayloadPersistence) .build();  final PublishWithFuture publishWithFuture = new PublishWithFuture(publish, future, false, publishPayloadPersistence); final boolean messageDropped = handler.checkChannelNotWritable(ctx, publishWithFuture, promise); "<AssertPlaceHolder>"; assertEquals(PublishStatus.CHANNEL_NOT_WRITABLE, future.get()); verify(promise).setSuccess(); verify(messageDroppedService).notWritable("clientId", "topic", 0); }
[*] target: assertTrue(messageDropped)
[-] pred: org. junit. Assert. assertTrue ( messageDropped )
************************************
[+] input: testDeleteQuietly_NonExists_ReturnFalse() { boolean result = localFileOperator.deleteLocalFile(BUCKET, "any-file-name");  Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
[+] input: test_Operate_Array() { String[] array = new String[] {"DeptA"}; boolean contains = EventParseUtil.validate(array, "contains", "Dept"); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
[+] input: generate_xmlParse_generateSucceed() { ExprContext context = getExprContext("xmlparse(document 'aaa')"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("xmlparse", Collections.singletonList(new ExpressionParam(new ConstExpression("'aaa'")))); expect.addOption(new ConstExpression("document")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: IOException { final String newRef = "refs/heads/abc"; final RefUpdate ru = updateRef(newRef); final SubclassedId newid = new SubclassedId(ru.getNewObjectId()); ru.setNewObjectId(newid); Result update = ru.update(); assertEquals(Result.NEW, update); final Ref r = getRef(db, newRef).get(); "<AssertPlaceHolder>"; assertNotNull(r.getObjectId()); assertNotSame(newid, r.getObjectId()); assertSame(ObjectId.class, r.getObjectId().getClass()); assertEquals(newid, r.getObjectId()); List<ReflogEntry> reverseEntries1 = db .getReflogReader("refs/heads/abc").getReverseEntries(); ReflogEntry entry1 = reverseEntries1.get(0); assertEquals(1, reverseEntries1.size()); assertEquals(ObjectId.zeroId(), entry1.getOldId()); assertEquals(r.getObjectId(), entry1.getNewId()); assertEquals(new PersonIdent(db).toString(),  entry1.getWho().toString()); assertEquals("", entry1.getComment()); List<ReflogEntry> reverseEntries2 = db.getReflogReader("HEAD") .getReverseEntries(); assertEquals(0, reverseEntries2.size()); }
[*] target: assertEquals(newRef, r.getName())
[-] pred: org. junit. Assert. assertEquals ( newRef, r. getName ( ) )
************************************
[+] input: IOException { final boolean[] called = new boolean[1]; os = new TimeoutOutputStream(new OutputStream() { @Override public void write(int b) throws IOException { fail("should not have written"); }  @Override public void flush() throws IOException { called[0] = true; } }, timer); os.setTimeout(timeout); os.flush(); "<AssertPlaceHolder>"; }
[*] target: assertTrue(called[0])
[-] pred: org. junit. Assert. assertTrue ( called[0] )
************************************
[+] input: generate_createIndexUsingBtree_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create unique index abc using btree on tb (col, col1) using hash")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setUnique(true); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setUsingHash(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_WMSYS_Dot_WM_CONCAT_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("wmsys.wm_concat(all col) keep (DENSE_RANK first order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("wmsys.wm_concat", Collections.singletonList(new ExpressionParam(new RelationReference("col", null)))); expect.addOption(new ConstExpression("all")); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.setKeep(new KeepClause("first", new OrderBy(Collections.singletonList(s)))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testContextLoss() { Map<String, Object> context = new HashMap<>(); context.put("A", 1000); boolean rst = RuleRunner.getInstance().check(context, Lists.newArrayList("A > B"), ""); Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(rst)
[-] pred: org. junit. Assert. assertFalse ( rst )
************************************
[+] input: copy_noChanges() { final ConnackPacketImpl packet = new ConnackPacketImpl( ConnackReasonCode.SUCCESS, true, 10, 60, null, null, null, 3, 1000, 10, Qos.AT_LEAST_ONCE, true, true, true, true, null, null, "reason", UserPropertiesImpl.of(ImmutableList.of())); final ModifiableConnackPacketImpl modifiablePacket = new ModifiableConnackPacketImpl(packet, configurationService, true);  final ConnackPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
[+] input: getInstancePublishInfo() { addServiceInstance(); InstancePublishInfo publishInfo = abstractClient.getInstancePublishInfo(service); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(publishInfo)
[-] pred: org. junit. Assert. assertNotNull ( publishInfo )
************************************
[+] input: testParseNamespace() { String expect = "test"; Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.NAMESPACE, expect);  final NacosClientProperties nacosClientProperties = NacosClientProperties.PROTOTYPE.derive(properties); String actual = ParamUtil.parseNamespace(nacosClientProperties); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_withoutAliasList_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name as (select * from dual order by abc desc fetch next 12 rows only) select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  SelectBody selectBody = getDefaultSelect(); SortKey s1 = new SortKey(new RelationReference("abc", null), SortDirection.DESC, null); OrderBy orderBy = new OrderBy(false, Collections.singletonList(s1)); selectBody.setOrderBy(orderBy); Fetch fetch = new Fetch(new ConstExpression("12"), FetchDirection.NEXT, FetchType.COUNT, FetchAddition.ONLY, null); selectBody.setFetch(fetch); WithTable expect = new WithTable("relation_name", selectBody); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_substring_generateFunctionCallSucceed() { ExprContext context = getExprContext("SUBSTRING('123' from 'abc' for 123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); params.add(new ExpressionParam(new ConstExpression("'abc'"))); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("SUBSTRING", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_createTableLike_generateSucceed() { Create_table_like_stmtContext context = getCreateTableLikeContext("create table if not exists abcd like a.b"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setIfNotExists(true); RelationFactor likeTable = new RelationFactor("b"); likeTable.setSchema("a"); expect.setLikeTable(likeTable); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_physicalAttrs_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) pctfree=12,pctused 13,initrans 14, maxtrans 15, storage(next 14 initial 16), tablespace abc"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setPctFree(12); tableOptions.setPctUsed(13); tableOptions.setIniTrans(14); tableOptions.setMaxTrans(15); tableOptions.setStorage(Arrays.asList("next 14", "initial 16")); tableOptions.setTableSpace("abc"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_indexHash_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index idx_name using hash (col, col1) local block_size=30")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingHash(true); indexOptions.setGlobal(false); indexOptions.setBlockSize(30); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: isRedirectUrlValid_HostNotMatch_InValid() { MockHttpServletRequest request = new MockHttpServletRequest("GET", "http://localhost:8989");  boolean redirectUrlValid = WebRequestUtils.isRedirectUrlValid(request, "http://another:8989/hello");  Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(redirectUrlValid)
[-] pred: org. junit. Assert. assertFalse ( redirectUrlValid )
************************************
[+] input: generate_waitIntNum_generateForUpdateSucceed() { For_update_clauseContext context = getForUpdateContext("select 1 from tab for update wait 10"); StatementFactory<ForUpdate> factory = new MySQLForUpdateFactory(context); ForUpdate actual = factory.generate();  ForUpdate expect = new ForUpdate(new ArrayList<>(), WaitOption.WAIT, new BigDecimal("10")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_indexPrimaryKeyWithConstraintName_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("constraint pk_name primary key (col, col1) using index")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); state.setUsingIndexFlag(true); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setConstraintName("pk_name"); expect.setPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testIdentical() { //given String ak = "ak"; String sk = "sk"; String tenantId = "100"; Credentials credentials1 = new Credentials(ak, sk, "101"); Credentials credentials2 = new Credentials(ak, sk, "100"); //then boolean actual = credentials1.identical(credentials2); //then Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
[+] input: generate_dropConstraint_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("drop constraint abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropConstraintNames(Collections.singletonList("abcd")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getByVisibleScopeAndOwnerIdAndName_NotExists_isPresentFalse() { Optional<ConnectionEntity> optionalEntity = repository.findByVisibleScopeAndOwnerIdAndName(ConnectionVisibleScope.PRIVATE, CREATOR_ID, NAME);  Assert."<AssertPlaceHolder>"; }
[*] target: assertFalse(optionalEntity.isPresent())
[-] pred: org. junit. Assert. assertFalse ( optionalEntity. isPresent ( ) )
************************************
[+] input: generate_predicateNotLikeEscapeStringList_generateSucceed() { ExprContext context = getExprContext("tab.col not like 'abc' escape 'bcd' 'abcde'"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression e1 = new ConstExpression("'abc'"); CollectionExpression e2 = new CollectionExpression(); e2.addExpression(new ConstExpression("'bcd'")); e2.addExpression(new ConstExpression("'abcde'")); Expression right = new CompoundExpression(e1, e2, Operator.ESCAPE); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testToTargetState() { assertEquals(TargetState.STARTED, CreateConnectorRequest.InitialState.RUNNING.toTargetState()); assertEquals(TargetState.PAUSED, CreateConnectorRequest.InitialState.PAUSED.toTargetState()); assertEquals(TargetState.STOPPED, CreateConnectorRequest.InitialState.STOPPED.toTargetState());  CreateConnectorRequest createConnectorRequest = new CreateConnectorRequest("test-name", Collections.emptyMap(), null); "<AssertPlaceHolder>"; }
[*] target: assertNull(createConnectorRequest.initialTargetState())
[-] pred: org. junit. Assert. assertNull ( createConnectorRequest. initialTargetState() )
************************************
[+] input: listAll_NoRecord_Empty() { List<SchemaHistory> list = repository.listAll();  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(0, list.size())
[-] pred: org. junit. Assert. assertEquals ( 0, list. size ( ) )
************************************
[+] input: generate_alterIndexNoParallel_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter index abc noParallel")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexNoParallel("abc"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test_fail() { output.authorizerPresent(); output.failAuthorization(); task.onSuccess(output);  channel.runPendingTasks();  final AuthorizeWillResultEvent resultEvent = eventsCollector.pollEvent(); "<AssertPlaceHolder>"; assertEquals(AckReasonCode.NOT_AUTHORIZED, resultEvent.getResult().getAckReasonCode()); assertEquals( "Not allowed to connect with Will Publish for unauthorized topic 'topic' with QoS '2' and retain 'false'", resultEvent.getResult().getReasonString()); }
[*] target: assertNotNull(resultEvent)
[-] pred: org. junit. Assert. assertNotNull ( resultEvent )
************************************
[+] input: generate_forArchiveHighCompress_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) compress    for archive high"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setCompress("for archive high"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: IOException { Properties properties = ResourceUtils.getResourceAsProperties("resource_utils_test.properties"); "<AssertPlaceHolder>"; assertTrue(properties.containsKey("a")); }
[*] target: assertNotNull(properties)
[-] pred: org. junit. Assert. assertNotNull ( properties )
************************************
[+] input: generate_createUniqueIndex_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create unique index chz.abc on piaoyue.tb (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor relation = new RelationFactor("abc"); relation.setSchema("chz"); RelationFactor on = new RelationFactor("tb"); on.setSchema("piaoyue"); CreateIndex expect = new CreateIndex(relation, on, Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setUnique(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_noWait_generateForUpdateSucceed() { For_update_clauseContext context = getForUpdateContext("select 1 from tab for update nowait"); StatementFactory<ForUpdate> factory = new MySQLForUpdateFactory(context); ForUpdate actual = factory.generate();  ForUpdate expect = new ForUpdate(new ArrayList<>(), WaitOption.NOWAIT, null); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetLoggersIgnoresNullLevels() { Logger root = logger("root");  Logger a = logger("a"); a.setLevel(null); Logger b = logger("b"); b.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, a, b);  Map<String, LoggerLevel> expectedLevels = Collections.singletonMap( "b", new LoggerLevel(Level.INFO.toString(), null) ); Map<String, LoggerLevel> actualLevels = loggers.allLevels(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedLevels, actualLevels)
[-] pred: org. junit. Assert. assertEquals ( expectedLevels, actualLevels )
************************************
[+] input: testMapDeserialize() { Schema schema = new Schema( optional( 1, "map_type", Types.MapType.ofOptional(2, 3, Types.LongType.get(), Types.StringType.get())));  StructObjectInspector inspector = ObjectInspectorFactory.getStandardStructObjectInspector( Arrays.asList("map_type"), Arrays.asList( ObjectInspectorFactory.getStandardMapObjectInspector( PrimitiveObjectInspectorFactory.writableLongObjectInspector, PrimitiveObjectInspectorFactory.writableStringObjectInspector)));  Deserializer deserializer = new Deserializer.Builder() .schema(schema) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(schema)) .sourceInspector(inspector) .build();  Record expected = GenericRecord.create(schema); expected.set(0, Collections.singletonMap(1L, "Taylor"));  MapWritable map = new MapWritable(); map.put(new LongWritable(1L), new Text("Taylor")); Object[] data = new Object[] {map}; Record actual = deserializer.deserialize(data);  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_createUniqueIndex_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create unique index chz.abc@oakasda! on piaoyue.tb@uasid! (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor relation = new RelationFactor("abc"); relation.setSchema("chz"); relation.setUserVariable("@oakasda"); relation.setReverseLink(true); RelationFactor on = new RelationFactor("tb"); on.setSchema("piaoyue"); on.setUserVariable("@uasid"); on.setReverseLink(true); CreateIndex expect = new CreateIndex(relation, on, Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setUnique(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_alterConstraintNotEnforced_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter constraint abcd not enforced")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ConstraintState state = new ConstraintState(); state.setEnforced(false); expect.modifyConstraint("abcd", state); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_addRangePartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext( "add partition (partition a.b values less than (-2, maxvalue) engine=InnoDB," + "partition d values less than (func(1,2)) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement("d", Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e3.setPartitionOptions(o1);  expect.setAddPartitionElements(Arrays.asList(e1, e3)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testDuplicateInserts() { DependencyNodeDao.instance.getMCollection().drop(); DependencyNodeDao.instance.createIndicesIfAbsent();  DependencyNode dependencyNode = new DependencyNode( "0", "url1", "GET", "0", "url2", "POST", new ArrayList<>(), 0 ); DependencyNodeDao.instance.insertOne(dependencyNode);  boolean erroredOut = false; try { DependencyNodeDao.instance.insertOne(dependencyNode); } catch (Exception e) { erroredOut = true; }  "<AssertPlaceHolder>"; }
[*] target: assertTrue(erroredOut)
[-] pred: org. junit. Assert. assertTrue ( erroredOut )
************************************
[+] input: get_getById_getSucceed() { UserInfo expect = TestRandom.nextObject(UserInfo.class); userDAO.insert(expect); expect = userDAO.detail(expect.getEmail()); UserInfo actual = userDAO.get(expect.getId()); expect.setGmtCreated(null); expect.setGmtModified(null); expect.setEnabled(true); actual.setEnabled(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { q = new LIFORevQueue(AbstractRevQueue.EMPTY_QUEUE); "<AssertPlaceHolder>"; }
[*] target: assertNull(q.next())
[-] pred: org. junit. Assert. assertNull ( q. next() )
************************************
[+] input: copy_noChanges() { final PublishPacketImpl packet = new PublishPacketImpl("topic", Qos.AT_LEAST_ONCE, Qos.AT_LEAST_ONCE, 1, false, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, ImmutableIntArray.of(), UserPropertiesImpl.of(ImmutableList.of()), System.currentTimeMillis()); final ModifiablePublishPacketImpl modifiablePacket = new ModifiablePublishPacketImpl(packet, configurationService);  final PublishPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
[+] input: generate_indexPrimaryKey_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("primary key `aaaa` using hash (col, col1) comment 'abcd'")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingHash(true); indexOptions.setComment("'abcd'"); state.setIndexOptions(indexOptions); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setPrimaryKey(true); expect.setIndexName("`aaaa`"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: exists_Exists_ReturnTrue() { CreateUserReq req = buildCreateUserReq("detail"); User user = userService.create(req);  boolean exists = userService.exists(user.getOrganizationId(), user.getAccountName());  Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
[+] input: Exception { RevCommit parent; RevCommit head; try (Git git = new Git(db)) { writeTrashFile("foo.txt", "foo\n"); writeTrashFile("src/some.txt", "some\n"); writeTrashFile("src/image.png", "image\n"); writeTrashFile("src/test.pdf", "test\n"); writeTrashFile("src/xyz.txt", "xyz\n"); git.add().addFilepattern(".").call(); parent = git.commit().setMessage("initial").call(); writeTrashFile("foo.txt", "FOO\n"); writeTrashFile("src/some.txt", "SOME\n"); writeTrashFile("src/image.png", "IMAGE\n"); writeTrashFile("src/test.pdf", "TEST\n"); writeTrashFile("src/xyz.txt", "XYZ\n"); git.add().addFilepattern(".").call(); head = git.commit().setMessage("second").call(); } try (ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(os)) { dfmt.setRepository(db); List<TreeFilter> skip = new ArrayList<>(); skip.add(PathSuffixFilter.create(".png")); skip.add(PathSuffixFilter.create(".pdf")); dfmt.setPathFilter(OrTreeFilter.create(skip).negate()); dfmt.format( new CanonicalTreeParser(null, db.newObjectReader(), parent.getTree()), new CanonicalTreeParser(null, db.newObjectReader(), head.getTree())); dfmt.flush();  String actual = os.toString("UTF-8");  String expected = "diff --git a/foo.txt b/foo.txt\n" + "index 257cc56..b7d6715 100644\n" + "--- a/foo.txt\n" + "+++ b/foo.txt\n" + "@@ -1 +1 @@\n" + "-foo\n" + "+FOO\n" + "diff --git a/src/some.txt b/src/some.txt\n" + "index 363ef61..76cea5f 100644\n" + "--- a/src/some.txt\n" + "+++ b/src/some.txt\n" + "@@ -1 +1 @@\n" + "-some\n" + "+SOME\n" + "diff --git a/src/xyz.txt b/src/xyz.txt\n" + "index cd470e6..d4e3ab0 100644\n" + "--- a/src/xyz.txt\n" + "+++ b/src/xyz.txt\n" + "@@ -1 +1 @@\n" + "-xyz\n" + "+XYZ\n";  "<AssertPlaceHolder>"; } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_columnDefBefore_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) before col")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); expect.setLocation(new Location("before", new ColumnReference(null, null, "col"))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_modifyConstraint_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify constraint abc rely enable validate")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ConstraintState constraintState = new ConstraintState(); constraintState.setValidate(true); constraintState.setEnable(true); constraintState.setRely(true); expect.modifyConstraint("abc", constraintState); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_distinctBitExprWithoutWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext("count(distinct 56) over (partition by (1,2) order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("56"))); FunctionCall expect = new FunctionCall("count", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); expect.setWindow(window); expect.addOption(new ConstExpression("distinct")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_accessFuncWith_a_not_like_b_escape_c_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a like b escape c)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CompoundExpression right = new CompoundExpression( new RelationReference("b", null), new RelationReference("c", null), Operator.ESCAPE); ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), right, Operator.LIKE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testSetConnectionKeepAlive() { long connectionKeepAlive = 5000; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setConnectionKeepAlive(connectionKeepAlive); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(connectionKeepAlive, config.connectionKeepAlive())
[-] pred: org. junit. Assert. assertEquals ( connectionKeepAlive, config. connectionKeepAlive() )
************************************
[+] input: testGetData() { ServiceInfo serviceInfo = serviceStorage.getData(SERVICE);  Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(serviceInfo)
[-] pred: org. junit. Assert. assertNotNull ( serviceInfo )
************************************
[+] input: generate_ob40NewTableOptions_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) delay_key_write=12 avg_row_length=13 checksum=15 auto_increment_mode='aaa' " + "enable_extended_rowid=true" + " TTL(col1 + interval 12 year, abcd.col2 + interval 45 day, db1.abcd.col3 + interval 45 day)"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setDelayKeyWrite(12); tableOptions.setAvgRowLength(13); tableOptions.setChecksum(15); tableOptions.setAutoIncrementMode("'aaa'"); tableOptions.setEnableExtendedRowId(true); tableOptions.setTtls(Arrays.asList( new CompoundExpression(new ColumnReference(null, null, "col1"), new IntervalExpression(new ConstExpression("12"), "year"), Operator.ADD), new CompoundExpression(new ColumnReference(null, "abcd", "col2"), new IntervalExpression(new ConstExpression("45"), "day"), Operator.ADD), new CompoundExpression(new ColumnReference("db1", "abcd", "col3"), new IntervalExpression(new ConstExpression("45"), "day"), Operator.ADD))); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); //when nacosClientAuthService.login(properties); //then boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>";  }
[*] target: assertTrue(ret)
[-] pred: org. junit. Assert. assertTrue ( ret )
************************************
[+] input: generate_externalTable_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create external table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setExternal(true); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testPrefixAndBeanNameConnectUseUnderscore() { JoinAliasGenerator generator = new UnderScoreJoinAliasGenerator();  Map<String, String> table = new HashMap<>(); table.put("users", "users_bean"); table.put("spring.users", "springUsers_bean"); table.put("spring.users.zhangsan", "springUsersZhangsan_bean");  table.forEach((key, value) -> { String alias = generator.generateAlias(key, beanName, clazz); "<AssertPlaceHolder>"; });  }
[*] target: assertEquals(value, alias)
[-] pred: org. junit. Assert. assertEquals ( value, alias )
************************************
[+] input: testGetValuesWithPrefixNull() { List<String> result = tree.getValuesWithPrefix(null); "<AssertPlaceHolder>"; }
[*] target: assertEquals(0, result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> a = new HttpRestResult<Object>(); a.setData("{"status":"UP"}"); a.setCode(200); when(nacosRestTemplate.exchangeForm(any(), any(), any(), any(), any(), any())).thenReturn(a);  final Field nacosRestTemplateField = NamingHttpClientProxy.class.getDeclaredField("nacosRestTemplate"); nacosRestTemplateField.setAccessible(true); nacosRestTemplateField.set(clientProxy, nacosRestTemplate);  //when boolean serverHealthy = clientProxy.serverHealthy(); //then verify(nacosRestTemplate, times(1)) .exchangeForm(endsWith("/operator/metrics"), any(), any(), any(), eq(HttpMethod.GET), any()); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(serverHealthy)
[-] pred: org. junit. Assert. assertTrue ( serverHealthy )
************************************
[+] input: generate_splitListPartition1_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress, partition id 12)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setNoCompress(true); options1.setId(14); e2.setPartitionOptions(options1); SpecialPartitionElement e3 = new SpecialPartitionElement(null); PartitionOptions o2 = new PartitionOptions(); o2.setId(12); e3.setPartitionOptions(o2); actions.setIntos(Arrays.asList(e1, e2, e3)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_firstValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "FIRST_VALUE (5 respect nulls) over (name_ob partition by (1,2) order by col desc RANGE interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p1 = new ExpressionParam(new ConstExpression("5")); params.add(p1); FunctionCall expect = new FunctionCall("FIRST_VALUE", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); expect.addOption(new ConstExpression("respect nulls")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test_CreateChannel_withChannelConfig() { Channel saved = notificationService.createChannel(PROJECT_ID, getChannel()); Assert."<AssertPlaceHolder>"; List<ChannelPropertyEntity> properties = channelPropertyRepository.findAllByChannelId(saved.getId()); Assert.assertEquals(2, properties.size()); }
[*] target: assertNotNull(saved)
[-] pred: org. junit. Assert. assertNotNull ( saved )
************************************
[+] input: generate_accessFuncWith_a_between_b_and_c_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a between c and b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CompoundExpression right = new CompoundExpression( new RelationReference("c", null), new RelationReference("b", null), Operator.AND); ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), right, Operator.BETWEEN)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_sortKey_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) sortkey (a,b)"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions .setSortKeys(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testBitmapCounts() { TestPackBitmapIndex index = new TestPackBitmapIndex(bitmaps);  assertEquals(1, index.getBaseBitmapCount()); "<AssertPlaceHolder>"; assertEquals(2, index.getBitmapCount()); }
[*] target: assertEquals(1, index.getXorBitmapCount())
[-] pred: org. junit. Assert. assertEquals ( 1, index. getXorBitmapCount() )
************************************
[+] input: testPeek_NoChannel_MessageThrown() { messageRepository.save(getMessageEntity());  when(channelRepository.findById(anyLong())) .thenReturn(Optional.empty()); List<Message> messages = queue.peek(1, MessageSendingStatus.CREATED);  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(0, messages.size())
[-] pred: org. junit. Assert. assertEquals ( 0, messages. size ( ) )
************************************
[+] input: generate_nthValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "NTH_VALUE(5,6) from first respect nulls over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); FunctionCall expect = new FunctionCall("NTH_VALUE", params); expect.addOption(new ConstExpression("from first")); expect.addOption(new ConstExpression("respect nulls")); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_autoPartition_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getAutoPartitionContext( "partition by range(a,b) partition size 'auto' PARTITIONS AUTO")); Partition actual = factory.generate();  RangePartition expect = new RangePartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")), null, null, null, false); expect.setAuto(true); expect.setPartitionSize(new ConstExpression("'auto'")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: createOperatorProxyFactory() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); OperatorProxyFactory factory = ConfigurationUtil.createOperatorProxyFactory(configuration); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(factory)
[-] pred: org. junit. Assert. assertNotNull ( factory )
************************************
[+] input: Exception { SubscribeServiceResponse res = new SubscribeServiceResponse(); ServiceInfo info = new ServiceInfo(GROUP_NAME + "@@" + SERVICE_NAME + "@@" + CLUSTERS); res.setServiceInfo(info); when(this.rpcClient.request(any())).thenReturn(res); ServiceInfo actual = client.subscribe(SERVICE_NAME, GROUP_NAME, CLUSTERS); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(info, actual)
[-] pred: org. junit. Assert. assertEquals ( info, actual )
************************************
[+] input: shouldFlushDirtyEntriesForNamespace() { final ThreadCache cache = new ThreadCache(logContext, 100000, new MockStreamsMetrics(new Metrics())); final List<byte[]> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace1, dirty -> { for (final ThreadCache.DirtyEntry dirtyEntry : dirty) { received.add(dirtyEntry.key().get()); } }); final List<byte[]> expected = Arrays.asList(new byte[]{0}, new byte[]{1}, new byte[]{2}); for (final byte[] bytes : expected) { cache.put(namespace1, Bytes.wrap(bytes), dirtyEntry(bytes)); } cache.put(namespace2, Bytes.wrap(new byte[]{4}), dirtyEntry(new byte[]{4}));  cache.flush(namespace1); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, received)
[-] pred: org. junit. Assert. assertEquals ( expected, received )
************************************
[+] input: generate_addListPartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("add partition (partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1);  expect.setAddPartitionElements(Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_listPartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list columns (a,b) subpartition by list columns(c,f) (" + "partition a.b values in (default) (" + "subpartition a.b values in (2)," + "subpartition b values in ('maxvalue'))," + "partition d values in (3) id 14," + "partition f values in ('aaaddd') id 15)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); ListPartitionElement e3 = new ListPartitionElement("f", Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions o2 = new PartitionOptions(); o2.setId(15); e3.setPartitionOptions(o2); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); SubPartitionOption subPartitionOption = new SubPartitionOption( Arrays.asList(new ColumnReference(null, null, "c"), new ColumnReference(null, null, "f")), "list columns"); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2, e3), subPartitionOption, null, true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: migrate_labelIdExists_migrateSucceed() { ConnectionEntity connectionEntity = getConnectionEntiy(); connectionEntity.setVisibleScope(ConnectionVisibleScope.PRIVATE); Map<String, String> map = new HashMap<>(); long labelId = 12L; map.put(PropertiesKeys.LABEL_ID, Long.toString(labelId)); connectionEntity.setProperties(map); connectionEntity = repository.save(connectionEntity);  V4103ConnectionLabelMigrate migrate = new V4103ConnectionLabelMigrate(); migrate.migrate(dataSource);  List<ConnectionLabelRelationEntity> actual = labelRelationRepository.findByUserId(connectionEntity.getCreatorId()); actual.forEach(e -> { e.setId(null); e.setCreateTime(null); e.setUpdateTime(null); }); List<ConnectionLabelRelationEntity> expect = new ArrayList<>(); ConnectionLabelRelationEntity entity = new ConnectionLabelRelationEntity(); entity.setUserId(connectionEntity.getCreatorId()); entity.setConnectionId(connectionEntity.getId()); entity.setLabelId(labelId); expect.add(entity); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: bytesToIntOffsetTest1() { int l1 = 123; int width1 = 64 - Integer.numberOfLeadingZeros(l1); int l2 = -124; int width2 = 64 - Integer.numberOfLeadingZeros(l2); byte[] bs = new byte[1000]; BytesUtils.intToBytes(l1, bs, 0, width1); int res_val1_1 = BytesUtils.bytesToInt(bs, 0, width1); BytesUtils.intToBytes(l2, bs, width1, width2); int res_val1_2 = BytesUtils.bytesToInt(bs, 0, width1); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(res_val1_1, res_val1_2)
[-] pred: org. junit. Assert. assertEquals ( res_val1_1, res_val1_2 )
************************************
[+] input: generate_alterCheckEnforced_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter Check abcd enforced")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ConstraintState state = new ConstraintState(); state.setEnforced(true); expect.modifyConstraint("abcd", state); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_cur_timestamp_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("CURRENT_TIMESTAMP(123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("CURRENT_TIMESTAMP", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: list_listLabels_listSucceed() { ConnectionLabel label = TestRandom.nextObject(ConnectionLabel.class); labelDAO.insert(label); List<ConnectionLabel> actual = labelDAO.list(label.getUserId()); List<ConnectionLabel> expect = Collections.singletonList(label); actual.forEach(connectionLabel -> { connectionLabel.setGmtCreated(null); connectionLabel.setGmtModified(null); }); expect.forEach(connectionLabel -> { connectionLabel.setGmtCreated(null); connectionLabel.setGmtModified(null); }); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: ParseException { String dateStr = "2007-02-21"; Date exp = SystemReader.getInstance().getSimpleDateFormat("yyyy-MM-dd") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
[+] input: createOperateTemplate() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); OperateTemplate operateTemplate = ConfigurationUtil.createOperateTemplate(configuration); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(operateTemplate)
[-] pred: org. junit. Assert. assertNotNull ( operateTemplate )
************************************
[+] input: testGetUserTenantForAns() { String expect = "test"; System.setProperty("ans.namespace", expect); String actual = TenantUtil.getUserTenantForAns(); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_locality_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) locality='abcd' force"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setLocality("'abcd' force"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_columnDefOrigDefaultExpr_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) orig_default((current_timestamp(1)))")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); FunctionCall expr = new FunctionCall("current_timestamp", Collections.singletonList(new ExpressionParam(new ConstExpression("1")))); attributes.setOrigDefault(expr); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_timestampLTZWithoutPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp with local time zone")); DataType actual = factory.generate();  DataType expect = new TimestampType(null, false, true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: NacosException { RpcClient rpcClient = buildTestStartClient(serverInfo -> null); rpcClient.shutdown(); rpcClient.start(); "<AssertPlaceHolder>"; }
[*] target: assertTrue(rpcClient.isShutdown())
[-] pred: org. junit. Assert. assertTrue ( rpcClient. isShutdown() )
************************************
[+] input: generate_deleteSingleTableWithPartition_generateSucceed() { Delete_stmtContext context = getDeleteContext("DELETE FROM tab PARTITION(p1) WHERE user = 'test' ORDER BY col LIMIT 100;"); StatementFactory<Delete> factory = new MySQLDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); nameReference.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p1"))); Delete expect = new Delete(context, nameReference); ColumnReference left = new ColumnReference(null, null, "user"); ConstExpression right = new ConstExpression("'test'"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); expect.setLimit(new Limit(new ConstExpression("100"))); SortKey s1 = new SortKey(new ColumnReference(null, null, "col"), null); expect.setOrderBy(new OrderBy(Arrays.asList(s1))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_withColumnGroup_customGroup_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(g1(col), g2(col, col1))")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); List<ColumnGroupElement> columnGroupElements = Arrays.asList( new ColumnGroupElement("g1", Collections.singletonList("col")), new ColumnGroupElement("g2", Arrays.asList("col", "col1"))); expect.setColumnGroupElements(columnGroupElements); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testProject() { boolean rst = RuleRunner.getInstance() .check( new HashMap<>(), Lists.newArrayList("R1 = 1 == 1", "R2 = 10 > 9", "R1 && R2"), ""); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
[+] input: shouldNotReturnWindowStoreAsTimestampedStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlyWindowStore<String, ValueAndTimestamp<String>>> stores = provider.stores("w-store", QueryableStoreTypes.timestampedWindowStore()); "<AssertPlaceHolder>"; }
[*] target: assertEquals(0, stores.size())
[-] pred: org. junit. Assert. assertEquals ( 0, stores. size ( ) )
************************************
[+] input: testRelativize_doc() { // This is the example from the javadoc String base = toOSPathString("c:\\Users\\jdoe\\eclipse\\git\\project"); String other = toOSPathString("c:\\Users\\jdoe\\eclipse\\git\\another_project\\pom.xml"); String expected = toOSPathString("..\\another_project\\pom.xml");  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: JsonProcessingException { String json = "{"supportRemoteConnection":true,"grpcReportEnabled":true}"; ServerRemoteAbility abilities = mapper.readValue(json, ServerRemoteAbility.class); assertTrue(abilities.isSupportRemoteConnection()); "<AssertPlaceHolder>"; }
[*] target: assertTrue(abilities.isGrpcReportEnabled())
[-] pred: org. junit. Assert. assertTrue ( abilities. isGrpcReportEnabled() )
************************************
[+] input: implies_resourcePermissionWithWildChar_impliesTrue() { ResourcePermission permission = new ResourcePermission( new DefaultSecurityResource("12", "conn"), "create,write,update, delete, readwrite,read"); ResourcePermission permission1 = new ResourcePermission(new DefaultSecurityResource("12", "conn"), "*"); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(permission.implies(permission1))
[-] pred: org. junit. Assert. assertTrue ( permission. implies( permission1 ) )
************************************
[+] input: generate_castAsChar_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as character(15) binary)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); CharacterType type = new CharacterType("character", new BigDecimal(15)); type.setBinary(true); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: test_Operate_Number() { boolean contains = EventParseUtil.validate(1234567, "contains", 123); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
[+] input: generate_withCycle_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name (col1, col2) as (select * from dual) search breadth first by col2 desc, col3 asc set varname cycle col2,col3 set cyclename to 'abcd' default '1234' select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); expect.setSearchMode(SearchMode.BREADTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); expect.setCycleAliasList(Arrays.asList("col2", "col3")); expect.setCycleValueSet(new SetValue("cyclename", "'abcd'", "'1234'")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testReplaceVariables_VariableNotExists_ReplaceEmptyString() { String template = "name=${name}, project=${project}";  Map<String, String> variables = new HashMap<>(); variables.put("name", "fake name");  String expected = "name=fake name, project="; String actual = MessageTemplateProcessor.replaceVariables(template, Locale.getDefault(), variables);  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: getClaims_getJwtLoad_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Map<String, Claim> claims = jwtService.getClaims(token); Assert."<AssertPlaceHolder>"; Assert.assertEquals(new Integer(123), claims.get("userId").asInt()); Assert.assertEquals("testUser", claims.get("username").asString()); }
[*] target: assertNotNull(claims)
[-] pred: org. junit. Assert. assertNotNull ( claims )
************************************
[+] input: testQuery() { //        LogQuery logQuery = new LogQuery(); //        logQuery.setStoreId(120042L); //        logQuery.setTailIds(Lists.newArrayList(90028L)); //        logQuery.setTail("hera-app"); //        logQuery.setStartTime(1699427646178L); //        logQuery.setEndTime(1699958631197L); //        logQuery.setPage(1); //        logQuery.setPageSize(100); //        logQuery.setFullTextSearch("level="ERROR""); // //        Result<LogDTO> logDTOResult = esDataService.logQuery(logQuery); //        Assert."<AssertPlaceHolder>"; //    }
[*] target: assertNotNull(logDTOResult)
[-] pred: org. junit. Assert. assertNotNull ( logDTOResult )
************************************
[+] input: testEmpty() { final RawText r = new RawText(new byte[0]); "<AssertPlaceHolder>"; }
[*] target: assertEquals(0, r.size())
[-] pred: org. junit. Assert. assertEquals ( 0, r. size() )
************************************
[+] input: JsonProcessingException { ServerNamingAbility expected = new ServerNamingAbility(); expected.setSupportJraft(true); String serializeJson = jacksonMapper.writeValueAsString(expected); ServerNamingAbility actual = jacksonMapper.readValue(serializeJson, ServerNamingAbility.class); assertEquals(expected, actual); actual = new ServerNamingAbility(); assertNotEquals(expected, actual); actual.setSupportJraft(true); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: queryByNameTest() { String name = "doris"; LogStorageTypeEnum storageTypeEnum = LogStorageTypeEnum.queryByName(name); Assert."<AssertPlaceHolder>"; log.info("result:{}", storageTypeEnum); }
[*] target: assertNotNull(storageTypeEnum)
[-] pred: org. junit. Assert. assertNotNull ( storageTypeEnum )
************************************
[+] input: shouldEnableRackAwareAssignorWithStandbyDescribingTopics() { final MockInternalTopicManager spyTopicManager = spy(mockInternalTopicManager); doReturn( Collections.singletonMap( TP_0_NAME, Collections.singletonList( new TopicPartitionInfo(0, NODE_0, Arrays.asList(REPLICA_1), Collections.emptyList()) ) ) ).when(spyTopicManager).getTopicPartitionInfo(Collections.singleton(TP_0_NAME));  doReturn( Collections.singletonMap( CHANGELOG_TP_0_NAME, Collections.singletonList( new TopicPartitionInfo(0, NODE_0, Arrays.asList(REPLICA_1), Collections.emptyList()) ) ) ).when(spyTopicManager).getTopicPartitionInfo(Collections.singleton(CHANGELOG_TP_0_NAME));  final RackAwareTaskAssignor assignor = spy(new RackAwareTaskAssignor( getClusterWithNoNode(), getTaskTopicPartitionMapForTask0(), getTaskChangeLogTopicPartitionMapForTask0(), getTopologyGroupTaskMap(), getProcessRacksForProcess0(), spyTopicManager, getRackAwareEnabledConfigWithStandby(1), time ));  assertTrue(assignor.canEnableRackAwareAssignor()); verify(assignor, times(1)).populateTopicsToDescribe(anySet(), eq(false)); verify(assignor, times(1)).populateTopicsToDescribe(anySet(), eq(true));  final Map<TopicPartition, Set<String>> racksForPartition = assignor.racksForPartition(); final Map<TopicPartition, Set<String>> expected = mkMap( mkEntry(TP_0_0, mkSet(RACK_1, RACK_2)), mkEntry(CHANGELOG_TP_0_0, mkSet(RACK_1, RACK_2)) ); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, racksForPartition)
[-] pred: org. junit. Assert. assertEquals ( expected, racksForPartition )
************************************
[+] input: testGetBeanOperations() { BeanOperations ops = crane4jTemplate.getBeanOperations(Foo.class); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, ops.getAssembleOperations().size()); Assert.assertTrue(ops.getDisassembleOperations().isEmpty()); }
[*] target: assertNotNull(ops)
[-] pred: org. junit. Assert. assertNotNull ( ops )
************************************
[+] input: generateCreateObjectDDL_sequence_generateSucceed() { DBObjectEditor<DBSequence> editor = new OracleSequenceEditor(); DBSequence sequence = new DBSequence(); sequence.setName("seq_t"); sequence.setMaxValue("1000"); sequence.setStartValue("10"); sequence.setIncreament(2L); sequence.setCached(false); sequence.setOrderd(true); sequence.setCycled(true);  String expect = "CREATE SEQUENCE "seq_t" NOMINVALUE MAXVALUE 1000 START WITH 10 INCREMENT BY 2 NOCACHE ORDER CYCLE;"; Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, editor.generateCreateDefinitionDDL(sequence))
[-] pred: org. junit. Assert. assertEquals ( expect, editor. generateCreateDefinitionDDL ( sequence ) )
************************************
[+] input: generate_sys_interval_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("INTERVAL(12, 13,15)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); params.add(new ExpressionParam(new ConstExpression("13"))); params.add(new ExpressionParam(new ConstExpression("15"))); FunctionCall expect = new FunctionCall("INTERVAL", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: IOException { ZipFileTree zipFileTree = new ZipFileTree(getTestZipFile()); List<ZipElement> elementList = zipFileTree.filter(element -> !element.isDirectory()); List<String> urls = elementList.stream().map(element -> element.getUrl().getPath()).collect(Collectors.toList());  for (String url : urls) { boolean res = url.endsWith("test.zip") || url.endsWith("CHECKPOINT.bin") || url.endsWith("MANIFEST.bin") || url.endsWith("TEST-schema.sql") || url.endsWith("TEST.0.0.sql"); Assert."<AssertPlaceHolder>"; } }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
[+] input: createContainerMethodAnnotationProcessor() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); ContainerMethodAnnotationProcessor processor = ConfigurationUtil.createContainerMethodAnnotationProcessor(configuration); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(processor)
[-] pred: org. junit. Assert. assertNotNull ( processor )
************************************
[+] input: currentSession() { DBSession session = accessor.currentSession(); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(session.getId()); }
[*] target: assertNotNull(session)
[-] pred: org. junit. Assert. assertNotNull ( session )
************************************
[+] input: testToEntity_putDropStatementInComments_success() { String actual = buildResult().toEntity(1L, DialectType.OB_MYSQL).getChangeSqlScript(); String expected = "-- Unsupported operation to drop primary key constraint\n" + "\n" + "/*\n" + "ALTER TABLE `tgtSchema`.`t1` DROP COLUMN `c1`;\n" + "*/\n" + "\n" + "/*\n" + "ALTER TABLE `tgtSchema`.`t1` DROP PARTITION (p1);\n" + "*/\n" + "\n" + "/*\n" + "ALTER TABLE `tgtSchema`.`t1` DROP PARTITION (p2);\n" + "*/\n" + "\n" + "ALTER TABLE `tgtSchema`.`t1` ADD PARTITION (p2);\n" + "\n" + "ALTER TABLE `tgtSchema`.`t1` COMMENT = 'comment1';\n" + "-- Unsupported operation to modify table charset\n"; Assert."<AssertPlaceHolder>";  }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: testEquals_trueWhenCountersBothNull() { DataVersion dataVersion = new DataVersion(); dataVersion.setCounter(null); DataVersion other = new DataVersion(); other.setCounter(null); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(dataVersion.equals(other))
[-] pred: org. junit. Assert. assertTrue ( dataVersion. equals ( other ) )
************************************
[+] input: generate_reorganizePartitionIntoRange_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("REORGANIZE partition a,b into (" + "partition a.b values less than (-2, maxvalue) engine=InnoDB," + "partition d values less than (func(1,2)) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement("d", Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e3.setPartitionOptions(o1); expect.reorganizePartition(Arrays.asList("a", "b"), Arrays.asList(e1, e3)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testParseSquashFixupSequenceCount() { int count = RebaseCommand .parseSquashFixupSequenceCount("# This is a combination of 3 commits.\n# newline"); "<AssertPlaceHolder>"; }
[*] target: assertEquals(3, count)
[-] pred: org. junit. Assert. assertEquals ( 3, count )
************************************
[+] input: generate_indexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col asc id 16, col1) using btree visible")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setVisible(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: copy_noChanges() { final ConnectPacketImpl packet = new ConnectPacketImpl( MqttVersion.V_5, "clientId", false, 100, 60, 3, 1000, 10, true, true, null, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiableConnectPacketImpl modifiablePacket = new ModifiableConnectPacketImpl(packet, configurationService);  final ConnectPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
[+] input: generate_updateWithWhereClauseCursor_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1 where current of tab.col"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); RelationReference left = new RelationReference("tab", new RelationReference("col", null)); expect.setWhere(left); expect.setCursor(true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testInitNamespaceFromAnsWithCloudParsing() { String expect = "ans"; System.setProperty(SystemPropertyKeyConst.ANS_NAMESPACE, expect); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); properties.setProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, "true"); String actual = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldLogAWarningIfCheckpointThrowsAnIOException() { final ProcessorStateManager stateMgr = getStateManager(Task.TaskType.ACTIVE); stateMgr.registerStore(persistentStore, persistentStore.stateRestoreCallback, null); stateDirectory.clean();  try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(ProcessorStateManager.class)) { stateMgr.updateChangelogOffsets(singletonMap(persistentStorePartition, 10L)); stateMgr.checkpoint();  boolean foundExpectedLogMessage = false; for (final LogCaptureAppender.Event event : appender.getEvents()) { if ("WARN".equals(event.getLevel()) && event.getMessage().startsWith("process-state-manager-test Failed to write offset checkpoint file to [") && event.getMessage().endsWith(".checkpoint]." + " This may occur if OS cleaned the state.dir in case when it located in ${java.io.tmpdir} directory." + " This may also occur due to running multiple instances on the same machine using the same state dir." + " Changing the location of state.dir may resolve the problem.") && event.getThrowableInfo().get().startsWith("java.io.FileNotFoundException: ")) {  foundExpectedLogMessage = true; break; } } "<AssertPlaceHolder>"; } }
[*] target: assertTrue(foundExpectedLogMessage)
[-] pred: org. junit. Assert. assertTrue ( foundExpectedLogMessage )
************************************
[+] input: testAggregateSmallInput() { final StreamsBuilder builder = new StreamsBuilder(); final String topic = "topic";  final WindowBytesStoreSupplier storeSupplier = setupWindowBytesStoreSupplier(1); final Materialized<String, String, WindowStore<Bytes, byte[]>> materialized = setupMaterialized(emitFinal ? Materialized.as("store-name") : Materialized.as(storeSupplier));  final KTable<Windowed<String>, String> table = builder .stream(topic, Consumed.with(Serdes.String(), Serdes.String())) .groupByKey(Grouped.with(Serdes.String(), Serdes.String())) .windowedBy(SlidingWindows.ofTimeDifferenceAndGrace(ofMillis(10), ofMillis(5))) .emitStrategy(emitStrategy) .aggregate(MockInitializer.STRING_INIT, MockAggregator.TOSTRING_ADDER, materialized); final MockApiProcessorSupplier<Windowed<String>, String, Void, Void> supplier = new MockApiProcessorSupplier<>(); table.toStream().process(supplier); try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) { final TestInputTopic<String, String> inputTopic = driver.createInputTopic(topic, new StringSerializer(), new StringSerializer()); inputTopic.pipeInput("A", "1", 10L); inputTopic.pipeInput("A", "2", 10L); inputTopic.pipeInput("A", "3", 14L); inputTopic.pipeInput("A", "4", 15L); inputTopic.pipeInput("A", "5", 20L); inputTopic.pipeInput("A", "6", 22L); inputTopic.pipeInput("A", "7", 30L); }  final Map<Long, Set<ValueAndTimestamp<String>>> actual = gatherOutput(supplier); final Map<Long, Set<ValueAndTimestamp<String>>> expected = new HashMap<>();  if (emitFinal) { expected.put(0L, mkSet( ValueAndTimestamp.make("0+1+2", 10L) )); expected.put(4L, mkSet( ValueAndTimestamp.make("0+1+2+3", 14L) )); expected.put(5L, mkSet( ValueAndTimestamp.make("0+1+2+3+4", 15L) )); expected.put(10L, mkSet( ValueAndTimestamp.make("0+1+2+3+4+5", 20L) )); expected.put(11L, mkSet( ValueAndTimestamp.make("0+3+4+5", 20L) )); expected.put(12L, mkSet( ValueAndTimestamp.make("0+3+4+5+6", 22L) )); } else { expected.put(0L, mkSet( ValueAndTimestamp.make("0+1", 10L), ValueAndTimestamp.make("0+1+2", 10L) )); expected.put(4L, mkSet( ValueAndTimestamp.make("0+1+2+3", 14L) )); expected.put(5L, mkSet( ValueAndTimestamp.make("0+1+2+3+4", 15L) )); expected.put(10L, mkSet( ValueAndTimestamp.make("0+1+2+3+4+5", 20L) )); expected.put(11L, mkSet( ValueAndTimestamp.make("0+3", 14L), ValueAndTimestamp.make("0+3+4", 15L), ValueAndTimestamp.make("0+3+4+5", 20L) )); expected.put(12L, mkSet( ValueAndTimestamp.make("0+3+4+5+6", 22L) )); expected.put(15L, mkSet( ValueAndTimestamp.make("0+4", 15L), ValueAndTimestamp.make("0+4+5", 20L), ValueAndTimestamp.make("0+4+5+6", 22L) )); expected.put(16L, mkSet( ValueAndTimestamp.make("0+5", 20L), ValueAndTimestamp.make("0+5+6", 22L) )); expected.put(20L, mkSet( ValueAndTimestamp.make("0+5+6+7", 30L) )); expected.put(21L, mkSet( ValueAndTimestamp.make("0+6", 22L), ValueAndTimestamp.make("0+6+7", 30L) )); expected.put(23L, mkSet( ValueAndTimestamp.make("0+7", 30L) )); }  "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: testReplaceVariables_EmptyVariables_ReturnTemplate() { String template = "fake template"; String actual = MessageTemplateProcessor.replaceVariables(template, Locale.getDefault(), new HashMap<>()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(template, actual)
[-] pred: org. junit. Assert. assertEquals ( template, actual )
************************************
[+] input: testKeywordConvert() { RuleExprParser ruleExprParser = new RuleExprParser(); Expr e = ruleExprParser.parse("A.alias == B.alias && A.when == B.id");  Expr2QlexpressTransformer transformer = new Expr2QlexpressTransformer(RuleRunner::convertPropertyName);  List<String> rules = Lists.newArrayList(JavaConversions.asJavaCollection(transformer.transform(e))); Map<String, Object> context = new HashMap<>(); context.put( "A", new HashMap<String, String>() { { put(RuleRunner.convertPropertyName("alias"), "alias_value"); put(RuleRunner.convertPropertyName("when"), "id_value"); } });  context.put( "B", new HashMap<String, String>() { { put(RuleRunner.convertPropertyName("alias"), "alias_value"); put(RuleRunner.convertPropertyName("id"), "id_value"); } });  boolean rst = RuleRunner.getInstance().check(context, rules, ""); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
[+] input: getAllSubscribeService() { Collection<Service> allSubscribeService = abstractClient.getAllSubscribeService(); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(allSubscribeService)
[-] pred: org. junit. Assert. assertNotNull ( allSubscribeService )
************************************
[+] input: generate_partition_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (" + "id varchar(64)) partition by hash(a) partitions 12 (" + "partition a.b," + "partition d id 14)"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); expect.setPartition(new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 12)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testInstance() { CustomEnvironmentPluginManager instance = CustomEnvironmentPluginManager.getInstance(); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
[+] input: generate_updateWithSelectParens_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE (SELECT * FROM tab) v SET v.col2 = 10 WHERE v.col1 = 1;"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(new Projection()), Collections.singletonList(from)); ExpressionReference updateTable = new ExpressionReference(selectBody, "v"); Update expect = new Update(Arrays.asList(updateTable), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, "v", "col2")), new ConstExpression("10"), false))); RelationReference left = new RelationReference("v", new RelationReference("col1", null)); ConstExpression right = new ConstExpression("1"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: update_updateUser_updateSucceed() { UserInfo expect = TestRandom.nextObject(UserInfo.class); userDAO.insert(expect); expect = userDAO.detail(expect.getEmail()); expect.setName("new name"); expect.setPassword("new password"); expect.setRole("new role"); expect.setStatus(expect.getStatus() + 10); expect.setDesc("new desc"); expect.setCipher(Cipher.BCRYPT); userDAO.update(expect); UserInfo actual = userDAO.get(expect.getId()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldMatchPositionAfterPut() { rocksDBStore.init((StateStoreContext) context, rocksDBStore);  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); rocksDBStore.put(new Bytes(stringSerializer.serialize(null, "one")), stringSerializer.serialize(null, "A")); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); rocksDBStore.put(new Bytes(stringSerializer.serialize(null, "two")), stringSerializer.serialize(null, "B")); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); rocksDBStore.put(new Bytes(stringSerializer.serialize(null, "three")), stringSerializer.serialize(null, "C"));  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 3L))))); final Position actual = rocksDBStore.getPosition(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: ParseException { String dateStr = "2007.02.21"; Date exp = SystemReader.getInstance().getSimpleDateFormat("yyyy.MM.dd") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
[+] input: generate_distinctExprListWithoutWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext("count(distinct 5,6) over (name_ob partition by (1,2) order by col desc)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); FunctionCall expect = new FunctionCall("count", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); expect.setWindow(window); expect.addOption(new ConstExpression("distinct")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_uniqueIndexColumnAscIdNoIndexOps_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("unique index idx_name (col asc id 16, col1) global with parser 'aaaa'")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); state.setIndexOptions(indexOptions); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testInitNamespaceFromPropNamespaceWithCloudParsing() { final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); String expect = "ns1"; properties.setProperty(PropertyKeyConst.NAMESPACE, expect); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, ns)
[-] pred: org. junit. Assert. assertEquals ( expect, ns )
************************************
[+] input: testErrorThroughRpc() { final AtomicReference<Response> reference = new AtomicReference<>();  RpcContext context = new RpcContext() { @Override public void sendResponse(Object responseObj) { reference.set((Response) responseObj); }  @Override public Connection getConnection() { return null; }  @Override public String getRemoteAddress() { return null; } }; AbstractProcessor processor = new NacosWriteRequestProcessor(server, SerializeFactory.getDefault()); processor.execute(server, context, WriteRequest.newBuilder().build(), new JRaftServer.RaftGroupTuple());  Response response = reference.get(); Assert."<AssertPlaceHolder>";  Assert.assertEquals("Error message transmission", response.getErrMsg()); Assert.assertFalse(response.getSuccess()); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
[+] input: generate_noNameIndex_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col, col1) data_table_id=12 virtual_column_id=13 max_used_part_id=14")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setDataTableId(12); indexOptions.setVirtualColumnId(13); indexOptions.setMaxUsedPartId(14); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldReturnSessionStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlySessionStore<String, String>> stores = provider.stores("s-store", QueryableStoreTypes.sessionStore()); "<AssertPlaceHolder>"; for (final ReadOnlySessionStore<String, String> store : stores) { assertThat(store, instanceOf(ReadOnlySessionStore.class)); } }
[*] target: assertEquals(1, stores.size())
[-] pred: org. junit. Assert. assertEquals ( 1, stores. size ( ) )
************************************
[+] input: MalformedURLException { AmazonS3 s3 = mock(AmazonS3Client.class); Mockito.when(s3.generatePresignedUrl(any())).thenReturn(new URL("http://test.sql")); AmazonCloudClient alibabaCloudClient = new AmazonCloudClient(s3, null, "test", "test"); URL url = alibabaCloudClient.generatePresignedUrl("test", "test", new Date()); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
[+] input: generate_updateWithoutWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: validNotSqlInjection_ParamIsNull_ReturnTrue() { boolean isNotInjection = PreConditions.validNotSqlInjection(null, "cluster"); Assert."<AssertPlaceHolder>";  }
[*] target: assertTrue(isNotInjection)
[-] pred: org. junit. Assert. assertTrue ( isNotInjection )
************************************
[+] input: testVersionHintWithBucketNameAsLocation() { Table mockTable = mock(Table.class); when(mockTable.location()).thenReturn("s3://bucket1"); String reportedVersionHintLocation = ReachableFileUtil.versionHintLocation(mockTable); String expectedVersionHintLocation = "s3://bucket1/metadata/" + Util.VERSION_HINT_FILENAME; Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedVersionHintLocation, reportedVersionHintLocation)
[-] pred: org. junit. Assert. assertEquals ( expectedVersionHintLocation, reportedVersionHintLocation )
************************************
[+] input: copy_changes() { final SubscribePacketImpl packet = new SubscribePacketImpl( ImmutableList.of(new SubscriptionImpl("topic", Qos.AT_LEAST_ONCE, RetainHandling.SEND, false, false)), UserPropertiesImpl.of(ImmutableList.of()), 1, 1); final ModifiableSubscribePacketImpl modifiablePacket = new ModifiableSubscribePacketImpl(packet, configurationService);  modifiablePacket.getSubscriptions().get(0).setTopicFilter("test"); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final SubscribePacketImpl copy = modifiablePacket.copy();  final SubscribePacketImpl expectedPacket = new SubscribePacketImpl( ImmutableList.of(new SubscriptionImpl("test", Qos.AT_LEAST_ONCE, RetainHandling.SEND, false, false)), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue"))), 1, 1); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedPacket, copy)
[-] pred: org. junit. Assert. assertEquals ( expectedPacket, copy )
************************************
[+] input: generate_physicalAttrs_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) default_lob_inrow_threshold=123 pctfree=12 tablespace abc"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setPctFree(12); tableOptions.setTableSpace("abc"); tableOptions.setDefaultLobInRowThreshold(123); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_starProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select * from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testRepeatConstraint() { Map<String, Object> context = getRepeatTestContext(); boolean rst = RuleRunner.getInstance() .check( context, Lists.newArrayList( "repeat_constraint(e.nodes, 'pre', 'cur', 'cur.logId == pre.logId && cur.age >= A.age && cur.gender == B.gender', " + "context_capturer(['A.age', 'B.gender'], [A.age, B.gender]))"), ""); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
[+] input: testWebUtilWithIntMaxValue() { SecuritySession session = Mockito.mock(SecuritySession.class); Mockito.when(session.getId()).thenReturn("abcde"); Mockito.when(session.getTimeoutMillis()).thenReturn(Integer.MAX_VALUE * 1000L + 100000); Cookie cookie = WebUtil.generateSecurityCookie(session); Assert."<AssertPlaceHolder>"; Assert.assertEquals(cookie.getValue(), session.getId()); Assert.assertEquals(cookie.getMaxAge(), Integer.MAX_VALUE); Assert.assertTrue(cookie.isHttpOnly()); Assert.assertEquals(cookie.getPath(), "/"); }
[*] target: assertNotNull(cookie)
[-] pred: org. junit. Assert. assertNotNull ( cookie )
************************************
[+] input: parserAnonymousBlock_callProcedure_3_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_4, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("IN_PARAM"); int actual = procedureCall.getCallLine(); int expect = 4; Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldNotReturnKeyValueStoreAsTimestampedStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlyKeyValueStore<String, ValueAndTimestamp<String>>> stores = provider.stores("kv-store", QueryableStoreTypes.timestampedKeyValueStore()); "<AssertPlaceHolder>"; }
[*] target: assertEquals(0, stores.size())
[-] pred: org. junit. Assert. assertEquals ( 0, stores. size ( ) )
************************************
[+] input: generate_expireInfo_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) expire_info=(1)"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setExpireInfo(new ConstExpression("1")); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_orderAndLimitUnion_generateSelectSucceed() { Select_stmtContext context = getSelectContext( "select col.* abc from tab order by col desc limit 3 union distinct select * from dual"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); selectBody.setOrderBy(new OrderBy(Collections.singletonList(s))); selectBody.setLimit(new Limit(new ConstExpression("3"))); selectBody.setRelatedSelect(new RelatedSelectBody(getDefaultSelectSimple(), RelationType.UNION_DISTINCT)); Select expect = new Select(selectBody); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: shouldDeleteKeyNoPropagateV0() { final MockProcessorContext<String, SubscriptionResponseWrapper<String>> context = new MockProcessorContext<>(); processor.init(context);  final SubscriptionWrapper<String> newValue = new SubscriptionWrapper<>( new long[]{1L}, Instruction.DELETE_KEY_NO_PROPAGATE, "pk1", SubscriptionWrapper.VERSION_0, null); final Record<CombinedKey<String, String>, Change<ValueAndTimestamp<SubscriptionWrapper<String>>>> record = new Record<>( new CombinedKey<>("fk1", "pk1"), new Change<>(ValueAndTimestamp.make(newValue, 1L), null), 1L ); processor.process(record); final List<CapturedForward<? extends String, ? extends SubscriptionResponseWrapper<String>>> forwarded = context.forwarded(); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(0, forwarded.size())
[-] pred: org. junit. Assert. assertEquals ( 0, forwarded. size ( ) )
************************************
[+] input: testIsLocalFileAbsent_ReturnTrue() { ObjectMetadata ossMeta = new ObjectMetadata(); ossMeta.setBucketName(BUCKET); ossMeta.setObjectId("some-file"); boolean isLocalAbsent = localFileOperator.isLocalFileAbsent(ossMeta); "<AssertPlaceHolder>"; }
[*] target: assertTrue(isLocalAbsent)
[-] pred: org. junit. Assert. assertTrue ( isLocalAbsent )
************************************
[+] input: test_Operate_BlankValue() { boolean contains = EventParseUtil.validate(Collections.singletonList("Hello World!"), "contains", ""); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
[+] input: testGetSuccessfulSyncCount() { long expected = DistroRecordsHolder.getInstance().getSuccessfulSyncCount() + 1; DistroRecordsHolder.getInstance().getRecord("testGetSuccessfulSyncCount").syncSuccess(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, DistroRecordsHolder.getInstance().getSuccessfulSyncCount())
[-] pred: org. junit. Assert. assertEquals ( expected, DistroRecordsHolder.getInstance ( ). getSuccessfulSyncCount ( ) )
************************************
[+] input: InterruptedException {  when(retainedMessagePersistence.clear()).thenReturn(Futures.immediateFuture(null));  final CompletableFuture<Void> clear = retainedMessageStore.clear();  "<AssertPlaceHolder>"; while (!clear.isDone()) { Thread.sleep(10); } assertTrue(clear.isDone()); assertFalse(clear.isCompletedExceptionally());  }
[*] target: assertNotNull(clear)
[-] pred: org. junit. Assert. assertNotNull ( clear )
************************************
[+] input: generate_columnProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new ColumnReference(null, null, "col"), null); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testSetRootLevel() { Logger root = logger("root"); root.setLevel(Level.ERROR);  Logger p = logger("a.b.c.p"); Logger x = logger("a.b.c.p.X"); Logger y = logger("a.b.c.p.Y"); Logger z = logger("a.b.c.p.Z"); Logger w = logger("a.b.c.s.W"); x.setLevel(Level.INFO); y.setLevel(Level.INFO); z.setLevel(Level.INFO); w.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, x, y, z, w);  List<String> modified = loggers.setLevel("root", Level.DEBUG); assertEquals(Arrays.asList("a.b.c.p.X", "a.b.c.p.Y", "a.b.c.p.Z", "a.b.c.s.W", "root"), modified);  assertNull(p.getLevel());  assertEquals(root.getLevel(), Level.DEBUG);  assertEquals(w.getLevel(), Level.DEBUG); assertEquals(x.getLevel(), Level.DEBUG); assertEquals(y.getLevel(), Level.DEBUG); assertEquals(z.getLevel(), Level.DEBUG);  Map<String, LoggerLevel> expectedLevels = new HashMap<>(); expectedLevels.put("root", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.p.X", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.p.Y", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.p.Z", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.s.W", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME));  Map<String, LoggerLevel> actualLevels = loggers.allLevels(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expectedLevels, actualLevels)
[-] pred: org. junit. Assert. assertEquals ( expectedLevels, actualLevels )
************************************
[+] input: generate_accessFuncWith_a_member_of_b_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a member of b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CompoundExpression expr = new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.MEMBER_OF); ExpressionParam param1 = new ExpressionParam(expr); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { Object expected = new Object(); when(catalogServiceV2.getServiceDetail(Constants.DEFAULT_NAMESPACE_ID, TEST_GROUP_NAME, TEST_SERVICE_NAME)) .thenReturn(expected); Object actual = catalogController.serviceDetail(Constants.DEFAULT_NAMESPACE_ID, TEST_GROUP_NAME + Constants.SERVICE_INFO_SPLITER + TEST_SERVICE_NAME); "<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: shouldCountWorkflows() { int counts = 1100; for (int i = 0; i < counts; i++) { WorkflowSummary workflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); indexDAO.indexWorkflow(workflow); }  // wait for workflow to be indexed long result = tryGetCount(() -> getWorkflowCount("template_workflow", "RUNNING"), counts); "<AssertPlaceHolder>"; }
[*] target: assertEquals(counts, result)
[-] pred: org. junit. Assert. assertEquals ( counts, result )
************************************
[+] input: generate_functionNameExprAsListAsString_generateFunctionCallSucceed() { ExprContext context = getExprContext("function_name(tab.col as 'new_label')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); ExpressionParam p = new ExpressionParam(new ColumnReference(null, "tab", "col")); p.addOption(new ConstExpression("'new_label'")); params.add(p); FunctionCall expect = new FunctionCall("function_name", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_updateWithOrderByAndLimit_generateSucceed() { Update_stmtContext context = getUpdateContext( "update tab set tab.col=1 order by chz.tab.col limit 4"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, "tab", "col")), new ConstExpression("1"), false))); SortKey s1 = new SortKey(new ColumnReference("chz", "tab", "col"), null); expect.setLimit(new Limit(new ConstExpression("4"))); expect.setOrderBy(new OrderBy(Arrays.asList(s1))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testStructDeserialize() { Deserializer deserializer = new Deserializer.Builder() .schema(CUSTOMER_SCHEMA) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(CUSTOMER_SCHEMA)) .sourceInspector(CUSTOMER_OBJECT_INSPECTOR) .build();  Record expected = GenericRecord.create(CUSTOMER_SCHEMA); expected.set(0, 1L); expected.set(1, "Bob");  Record actual = deserializer.deserialize(new Object[] {new LongWritable(1L), new Text("Bob")});  Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
[+] input: generate_modifyRangePartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("partition by range(a) subpartition by range columns (c,b) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue engine=InnoDB)," + "partition d values less than (+3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); se2.setPartitionOptions(o); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Arrays.asList(new ColumnReference(null, null, "c"), new ColumnReference(null, null, "b")), "range columns"); expect.setModifyPartition(new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_updateWithTableReferences_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE chz.t1, chz.t2 PARTITION(p2, p2) SET t1.c2 = 100, t2.c2 = 200"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference1 = new NameReference("chz", "t1", null); NameReference nameReference2 = new NameReference("chz", "t2", null); nameReference2.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p2", "p2"))); Update expect = new Update(Arrays.asList(nameReference1, nameReference2), Arrays.asList( new UpdateAssign( Arrays.asList(new ColumnReference(null, "t1", "c2")), new ConstExpression("100"), false), new UpdateAssign( Arrays.asList(new ColumnReference(null, "t2", "c2")), new ConstExpression("200"), false))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_Compression_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) COMPRESSION 'aaa'"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setCompression("'aaa'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_splitListPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); actions.setIntos(Arrays.asList(e1, e2)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_sys_interval_func_check_generateFunctionCallSucceed() { ExprContext context = getExprContext("CHECK(12)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); FunctionCall expect = new FunctionCall("CHECK", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_rowExprList_generateSucceed() { ExprContext context = getExprContext("row(12,13,14)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); params.add(new ExpressionParam(new ConstExpression("13"))); params.add(new ExpressionParam(new ConstExpression("14"))); FunctionCall expect = new FunctionCall("row", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_rangePartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) subpartition by range columns (c,b) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue engine=InnoDB)," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); se2.setPartitionOptions(o); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Arrays.asList(new ColumnReference(null, null, "c"), new ColumnReference(null, null, "b")), "range columns"); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_indexBtree_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "index idx_name using btree (col, col1) visible data_table_id 14 index_table_id=15 max_used_part_id=16")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setVisible(true); indexOptions.setUsingBtree(true); indexOptions.setDataTableId(14); indexOptions.setIndexTableId(15); indexOptions.setMaxUsedPartId(16); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getTsFilePrefixPathTest() { String tsFilePrefixPath = FilePathUtils.getTsFilePrefixPath(tsFile.getAbsolutePath()); String exceptPrefixPath = storageGroupName + File.separator + dataRegionId + File.separator + partitionId; Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(exceptPrefixPath, tsFilePrefixPath)
[-] pred: org. junit. Assert. assertEquals ( exceptPrefixPath, tsFilePrefixPath )
************************************
[+] input: generate_xmlFunction_generateSucceed() { ExprContext context = getExprContext("xmlcast('aaa' as int)."aaa".count(*)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlcast", Collections.singletonList(p1)); expect.reference(new RelationReference(""aaa"", null), ReferenceOperator.DOT) .reference(new FunctionCall("count", Collections.singletonList( new ExpressionParam(new ConstExpression("*")))), ReferenceOperator.DOT); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: buildRequest_ReturnNotNull() { HttpUriRequest request = accountClient.buildRequest(TOKEN); Assert."<AssertPlaceHolder>"; }
[*] target: assertNotNull(request)
[-] pred: org. junit. Assert. assertNotNull ( request )
************************************
[+] input: testBatchPublishAggrSuccess() {  String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; //mock query datumId and equal with current content param. Mockito.when( databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, "d1"}), eq(String.class))) .thenReturn("c1"); Mockito.when( databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, "d2"}), eq(String.class))) .thenReturn("c2"); Mockito.when( databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, "d3"}), eq(String.class))) .thenReturn("c3"); Mockito.when(databaseOperate.update(any(List.class))).thenReturn(true);  Map<String, String> datumMap = new HashMap<>(); datumMap.put("d1", "c1"); datumMap.put("d2", "c2"); datumMap.put("d3", "c3"); String appName = "appname1234"; boolean result = embededConfigInfoAggrPersistService.batchPublishAggr(dataId, group, tenant, datumMap, appName); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: copy_noChanges() { final SubscribePacketImpl packet = new SubscribePacketImpl( ImmutableList.of(new SubscriptionImpl("topic", Qos.AT_LEAST_ONCE, RetainHandling.SEND, false, false)), UserPropertiesImpl.of(ImmutableList.of()), 1, 1); final ModifiableSubscribePacketImpl modifiablePacket = new ModifiableSubscribePacketImpl(packet, configurationService);  final SubscribePacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
[+] input: generate_trim1_generateFunctionCallSucceed() { ExprContext context = getExprContext("trim(both from 'abc')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); params.add(p); FunctionCall expect = new FunctionCall("trim", params); expect.addOption(new ConstExpression("both")); expect.addOption(new ConstExpression("from")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: IOException { String msg = "test buff to string"; ByteBuffer buff = ByteBuffer.wrap(msg.getBytes(StandardCharsets.UTF_8)); String actual = ConcurrentDiskUtil.byteBufferToString(buff, "UTF-8"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(msg, actual)
[-] pred: org. junit. Assert. assertEquals ( msg, actual )
************************************
[+] input: generate_accessFunctionWithObject_accessFunctionAccess_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(ALL 1).obj_access(2)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall af = new FunctionCall("obj_access", Collections.singletonList(new ExpressionParam(new ConstExpression("2")))); ExpressionParam p = new ExpressionParam(new ConstExpression("1")); FunctionCall expect = new FunctionCall("function", Collections.singletonList(p)); expect.addOption(new ConstExpression("ALL")); expect.reference(af, ReferenceOperator.DOT); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_generalOrderByAsc_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select col from tab order by col asc;"); StatementFactory<OrderBy> factory = new MySQLOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.ASC); OrderBy expect = new OrderBy(Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: equalsTest() { SessionCredentials sessionCredentials=new SessionCredentials("RocketMQ","12345678"); sessionCredentials.setSecurityToken("abcd"); SessionCredentials other=new SessionCredentials("RocketMQ","12345678","abcd"); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(sessionCredentials.equals(other))
[-] pred: org. junit. Assert. assertTrue ( sessionCredentials. equals ( other ) )
************************************
[+] input: generate_generalOrderByMultiSortKeys_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select col from tab order by chz.tab.col,tab3.col1 desc ;"); StatementFactory<OrderBy> factory = new MySQLOrderByFactory(context); OrderBy actual = factory.generate();  SortKey s1 = new SortKey(new ColumnReference("chz", "tab", "col"), null); SortKey s2 = new SortKey(new ColumnReference(null, "tab3", "col1"), SortDirection.DESC); OrderBy expect = new OrderBy(Arrays.asList(s1, s2)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_orderByNullsFirst_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select 1 from dual order by col asc nulls first"); StatementFactory<OrderBy> factory = new OracleOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new RelationReference("col", null), SortDirection.ASC, SortNullPosition.FIRST); OrderBy expect = new OrderBy(false, Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_columnProjectionWithLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col label from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new RelationReference("col", null), "label"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testValid() { //given String ak = "ak"; String sk = "sk"; String tenantId = "100"; Credentials credentials = new Credentials(ak, sk, tenantId); //when boolean actual = credentials.valid(); //then Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
[+] input: testReceiveConfigInfoIsNotProperties() { final Deque<Properties> q2 = new ArrayDeque<Properties>(); PropertiesListener a = new PropertiesListener() { @Override public void innerReceive(Properties properties) { q2.offer(properties); } }; a.receiveConfigInfo(null); final Properties actual = q2.poll(); Assert."<AssertPlaceHolder>"; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
[+] input: queryByUserIdAndName_queryByUserIdAndName_querySucceed() { Snippet snippet = TestRandom.nextObject(Snippet.class); snippetsDAO.insert(snippet); Snippet query = new Snippet(); query.setUserId(snippet.getUserId()); query.setPrefix(snippet.getPrefix()); Snippet actual = snippetsDAO.queryByUserIdAndName(query); snippet.setModifyTime(null); snippet.setCreateTime(null); actual.setModifyTime(null); actual.setCreateTime(null); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(snippet, actual)
[-] pred: org. junit. Assert. assertEquals ( snippet, actual )
************************************
[+] input: isODPSharding_ODP_SHARDING_OB_ORACLE_ReturnTrue() { boolean isODPSharding = ConnectType.ODP_SHARDING_OB_ORACLE.isODPSharding(); Assert."<AssertPlaceHolder>"; }
[*] target: assertTrue(isODPSharding)
[-] pred: org. junit. Assert. assertTrue ( isODPSharding )
************************************
[+] input: verifyingTopicCleanupPolicyShouldReturnTrueWhenTopicHasCorrectPolicy() { String topicName = "myTopic"; Map<String, String> topicConfigs = Collections.singletonMap("cleanup.policy", "compact"); Cluster cluster = createCluster(1); try (MockAdminClient mockAdminClient = new MockAdminClient(cluster.nodes(), cluster.nodeById(0))) { TopicPartitionInfo topicPartitionInfo = new TopicPartitionInfo(0, cluster.nodeById(0), cluster.nodes(), Collections.emptyList()); mockAdminClient.addTopic(false, topicName, Collections.singletonList(topicPartitionInfo), topicConfigs); TopicAdmin admin = new TopicAdmin(mockAdminClient); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
[+] input: testSetMaxInboundMessageSize() { int maxInboundMessageSize = 10485760; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setMaxInboundMessageSize(maxInboundMessageSize); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
[*] target: assertEquals(maxInboundMessageSize, config.maxInboundMessageSize())
[-] pred: org. junit. Assert. assertEquals ( maxInboundMessageSize, config. maxInboundMessageSize ( ) )
************************************
[+] input: copy_noChanges() { final PubrecPacketImpl packet = new PubrecPacketImpl( 1, AckReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubrecPacketImpl modifiablePacket = new ModifiablePubrecPacketImpl(packet, configurationService);  final PubrecPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
[+] input: metaPropertyInitialize() { String[] keys = new String[] { "JDBC_URL", "JDBC_USERNAME", "JDBC_PASSWORD" }; Map<String, String> backup = new HashMap<>(); for (String key : keys) { backup.put(key, System.clearProperty(key)); } try { MetaPropertyInitializer initializer = new MetaPropertyInitializer(); assertFalse(initializer.isPropertyReady()); System.setProperty("JDBC_USERNAME", "test"); assertFalse(initializer.isPropertyReady()); initializer.initialize("127.0.0.1:2881", "test", "user", "pswd"); "<AssertPlaceHolder>"; } finally { for (Entry<String, String> entry : backup.entrySet()) { if (entry.getValue() != null) { System.setProperty(entry.getKey(), entry.getValue()); } } } }
[*] target: assertTrue(initializer.isPropertyReady())
[-] pred: org. junit. Assert. assertTrue ( initializer. isPropertyReady ( ) )
************************************
[+] input: test_get_tls_with_sni() {  clientConnection.setAuthCipherSuite("cipher"); clientConnection.setAuthProtocol("TLSv1.2"); clientConnection.setAuthSniHostname("test.hostname.domain");  final ClientTlsInformation clientTlsInformation = ExtensionInformationUtil.getTlsInformationFromChannel(channel); "<AssertPlaceHolder>"; assertEquals("cipher", clientTlsInformation.getCipherSuite()); assertEquals("TLSv1.2", clientTlsInformation.getProtocol()); assertTrue(clientTlsInformation.getHostname().isPresent()); assertEquals("test.hostname.domain", clientTlsInformation.getHostname().get()); assertEquals("TLSv1.2", clientTlsInformation.getProtocol()); assertTrue(clientTlsInformation.getClientCertificate().isEmpty()); }
[*] target: assertNotNull(clientTlsInformation)
[-] pred: org. junit. Assert. assertNotNull ( clientTlsInformation )
************************************
[+] input: generate_onlyColumnDefExists_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_leadWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "LEAD (5 respect nulls, 1,2) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p1 = new ExpressionParam(new ConstExpression("5")); params.add(p1); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); FunctionCall expect = new FunctionCall("LEAD", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); expect.addOption(new ConstExpression("respect nulls")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_utc_timestamp_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("UTC_TIMESTAMP(12)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); FunctionCall expect = new FunctionCall("UTC_TIMESTAMP", params); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_hashPartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) subpartition by hash(c) subpartitions 165 partitions 12 (" + "partition a.b@c (" + "subpartition a.b pctfree=13," + "subpartition b pctused 14)," + "partition d id 14) noCompress")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); PartitionOptions o1 = new PartitionOptions(); o1.setPctFree(13); se1.setPartitionOptions(o1); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setPctUsed(14); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o7 = new PartitionOptions(); o7.setId(14); e2.setPartitionOptions(o7); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "hash"); subPartitionOption.setSubPartitionNum(165); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2), subPartitionOption, 12); PartitionOptions o3 = new PartitionOptions(); o3.setNoCompress(true); expect.setPartitionOptions(o3); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_indexHashPartitioned_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index idx_name (col, col1) partition by hash(col)")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); HashPartition p = new HashPartition(Collections.singletonList(new ColumnReference(null, null, "col")), null, null, null); expect.setPartition(p); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_withColumnGroup_allColumns_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns)"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_createIndexWithColumnGroup_allColumns_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { PowerMockito.whenNew(DefaultConnector.class).withAnyArguments().thenReturn(defaultConnector); Method methodGetObVersion = PowerMockito.method(ObConnectTemplate.class, "getObVersion"); PowerMockito.replace(methodGetObVersion).with((proxy, method, args) -> "2.4.0");  ObOperator operator = ObOperators.newObOperator(connectProperties.withCompatibilityMode(CompatibilityMode.MYSQL)); "<AssertPlaceHolder>"; assertNotNull(operator.cluster()); assertNotNull(operator.resource()); assertNotNull(operator.session()); assertNotNull(operator.stats()); assertNotNull(operator.tenant()); }
[*] target: assertNotNull(operator)
[-] pred: org. junit. Assert. assertNotNull ( operator )
************************************
[+] input: generate_listPartitionWithSubPartitionOptions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list columns (a,b) subpartition by list(c) subpartition template(" + "subpartition a.b values in (2)," + "subpartition b values in ('maxvalue')) (" + "partition a.b values in (default) (" + "subpartition a.b values in (2)," + "subpartition b values in ('maxvalue'))," + "partition d values in (3) id 14," + "partition f values in ('aaaddd') id 15)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); ListPartitionElement e3 = new ListPartitionElement("f", Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions o2 = new PartitionOptions(); o2.setId(15); e3.setPartitionOptions(o2); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "list"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2, e3), subPartitionOption, null, true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { if (!FS.DETECTED.supportsExecute()) return;  ChangeRecorder recorder = new ChangeRecorder(); ListenerHandle handle = null; try (Git git = new Git(db)) { handle = db.getListenerList() .addWorkingTreeModifiedListener(recorder); // Add non-executable file File file = writeTrashFile("file.txt", "a"); git.add().addFilepattern("file.txt").call(); git.commit().setMessage("commit1").call(); assertFalse(db.getFS().canExecute(file));  // Create branch git.branchCreate().setName("b1").call();  // Make file executable db.getFS().setExecute(file, true); git.add().addFilepattern("file.txt").call(); git.commit().setMessage("commit2").call();  // Verify executable and working directory is clean Status status = git.status().call(); assertTrue(status.getModified().isEmpty()); assertTrue(status.getChanged().isEmpty()); assertTrue(db.getFS().canExecute(file));  writeTrashFile("file.txt", "b");  // Switch branches CheckoutCommand checkout = git.checkout().setName("b1"); try { checkout.call(); fail("Checkout exception not thrown"); } catch (org.eclipse.jgit.api.errors.CheckoutConflictException e) { CheckoutResult result = checkout.getResult(); "<AssertPlaceHolder>"; assertNotNull(result.getConflictList()); assertEquals(1, result.getConflictList().size()); assertTrue(result.getConflictList().contains("file.txt")); } recorder.assertNoEvent(); } finally { if (handle != null) { handle.remove(); } } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
[+] input: Exception { WorkflowSummary oldWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); oldWorkflow.setStatus(WorkflowStatus.RUNNING); oldWorkflow.setUpdateTime(getFormattedTime(new DateTime().minusHours(2).toDate()));  WorkflowSummary recentWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); recentWorkflow.setStatus(WorkflowStatus.RUNNING); recentWorkflow.setUpdateTime(getFormattedTime(new DateTime().minusHours(1).toDate()));  WorkflowSummary tooRecentWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); tooRecentWorkflow.setStatus(WorkflowStatus.RUNNING); tooRecentWorkflow.setUpdateTime(getFormattedTime(new DateTime().toDate()));  indexDAO.indexWorkflow(oldWorkflow); indexDAO.indexWorkflow(recentWorkflow); indexDAO.indexWorkflow(tooRecentWorkflow);  Thread.sleep(1000);  List<String> ids = indexDAO.searchRecentRunningWorkflows(2, 1);  "<AssertPlaceHolder>"; assertEquals(recentWorkflow.getWorkflowId(), ids.get(0)); }
[*] target: assertEquals(1, ids.size())
[-] pred: org. junit. Assert. assertEquals ( 1, ids. size ( ) )
************************************
[+] input: generate_rangePartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by range(a,b) (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp (" + "subpartition a.b values less than (+3) INITRANS 12," + "subpartition b values less than (maxvalue) MAXTRANS 13)," + "partition d values less than (+3) id 14 nocompress)")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setIniTrans(12); se1.setPartitionOptions(sop1); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setMaxTrans(13); se2.setPartitionOptions(sop2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setNoCompress(true); options1.setId(14); e2.setPartitionOptions(options1); RangePartition expect = new RangePartition(cols, Arrays.asList(e1, e2), null, null, false); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: update_updateSnippet_updateSucceed() { Snippet snippet = TestRandom.nextObject(Snippet.class); snippetsDAO.insert(snippet); snippet.setBody("new body"); snippet.setDescription("new desp"); snippet.setPrefix("new prefix"); snippet.setType("new type"); snippetsDAO.update(snippet); Snippet actual = snippetsDAO.get(snippet.getId()); snippet.setModifyTime(null); snippet.setCreateTime(null); actual.setModifyTime(null); actual.setCreateTime(null); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(snippet, actual)
[-] pred: org. junit. Assert. assertEquals ( snippet, actual )
************************************
[+] input: generate_indexBtree_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index idx_name using btree (col, col1) global with parser 'aaaa'")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_indexColumnDescLen_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col(13) desc, col1) with rowid PARALLEL=12")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setDirection(SortDirection.DESC); s1.setLength(13); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setWithRowId(true); indexOptions.setParallel(12); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_uniqueGroupConcatExprListWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "GROUP_CONCAT(unique 5,6 order by col1 asc SEPARATOR 'mmm') over (name_ob partition by (1,2) order by col desc rows between " + "current row and 123 PRECEDING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); FunctionParam pppp = new ExpressionParam(new ConstExpression("6")); params.add(pppp); GroupConcat expect = new GroupConcat(params); expect.addOption(new ConstExpression("unique")); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset begin = new WindowOffset(WindowOffsetType.CURRENT_ROW); WindowOffset end = new WindowOffset(WindowOffsetType.PRECEDING); end.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.ROWS, begin, end); window.setBody(body); expect.setWindow(window); SortKey s0 = new SortKey(new ColumnReference(null, null, "col1"), SortDirection.ASC); expect.addOption(new OrderBy(Collections.singletonList(s0))); expect.addOption(new ConstExpression("SEPARATOR 'mmm'")); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_timestampWithPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp(12)")); DataType actual = factory.generate();  DataType expect = new TimestampType(new BigDecimal("12"), false, false); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: testGetValuesWithPrefixNotFound() { List<String> result = tree.getValuesWithPrefix("cheese"); "<AssertPlaceHolder>"; }
[*] target: assertEquals(0, result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
[+] input: generate_valuesStatementUnion_generateSelectSucceed() { String sql = "values row(1, '2'), row(2, '3') union values row(1, '2')"; Select_stmtContext context = getSelectContext(sql); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); values.add(Arrays.asList(new ConstExpression("2"), new ConstExpression("'3'"))); SelectBody body = new SelectBody(values);  values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); SelectBody second = new SelectBody(values); body.setRelatedSelect(new RelatedSelectBody(second, RelationType.UNION)); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_columnDefOnUpdate_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) on update current_timestamp(1)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); FunctionCall expr = new FunctionCall("current_timestamp", Collections.singletonList(new ExpressionParam(new ConstExpression("1")))); attributes.setOnUpdate(expr); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: getSynonym_testCommonSynonymInfoForOracle() { DBSynonym synonym = accessor.getSynonym(getOracleSchema(), "COMMON_SYNONYM_ACCESSOR", DBSynonymType.COMMON); Assert."<AssertPlaceHolder>"; Assert.assertEquals(DBSynonymType.COMMON, synonym.getSynonymType()); Assert.assertEquals("COMMON_SYNONYM_ACCESSOR", synonym.getSynonymName()); }
[*] target: assertNotNull(synonym)
[-] pred: org. junit. Assert. assertNotNull ( synonym )
************************************
[+] input: generate_commitOption_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) on commit delete rows"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setCommitOption("delete"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_alterIndex_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("alter index abc visible")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexVisibility("abc", true); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { BranchTrackingStatus status = BranchTrackingStatus.of( util.getRepository(), "doesntexist");  "<AssertPlaceHolder>"; }
[*] target: assertNull(status)
[-] pred: org. junit. Assert. assertNull ( status )
************************************
[+] input: testValueOf3() { MediaType mediaType = MediaType.valueOf("application/x-www-form-urlencoded", "ISO-8859-1"); String type = "application/x-www-form-urlencoded"; String charset = "ISO-8859-1"; String excepted = "application/x-www-form-urlencoded;charset=ISO-8859-1"; assertEquals(type, mediaType.getType()); assertEquals(charset, mediaType.getCharset()); "<AssertPlaceHolder>"; }
[*] target: assertEquals(excepted, mediaType.toString())
[-] pred: org. junit. Assert. assertEquals ( excepted, mediaType. toString ( ) )
************************************
[+] input: generate_updateAssignmentUseDefault_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=DEFAULT, col2=1"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), null, true), new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col2")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: Exception { ServerReloadRequest request = new ServerReloadRequest(); request.setReloadCount(10); request.setReloadServer("1.1.1.1"); request.setRequestId("1"); String json = mapper.writeValueAsString(request); System.out.println(json); Assert."<AssertPlaceHolder>"; Assert.assertTrue(json.contains(""reloadCount":10")); Assert.assertTrue(json.contains(""reloadServer":"1.1.1.1"")); Assert.assertTrue(json.contains(""module":"internal"")); Assert.assertTrue(json.contains(""requestId":"1"")); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
[+] input: generate_insertChildXml_generateSucceed() { Xml_functionContext context = getXmlExprContext("insertchildxml(1,2,3,4)"); OracleExpressionFactory factory = new OracleExpressionFactory(); Expression actual = factory.visit(context);  FunctionCall expect = new FunctionCall("insertchildxml", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")), new ExpressionParam(new ConstExpression("3")), new ExpressionParam(new ConstExpression("4")))); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
[+] input: generate_uniqueIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext( "unique index idx_name using btree (col asc id 16, col1) global with parser 'aaaa'")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); state.setIndexOptions(indexOptions); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************

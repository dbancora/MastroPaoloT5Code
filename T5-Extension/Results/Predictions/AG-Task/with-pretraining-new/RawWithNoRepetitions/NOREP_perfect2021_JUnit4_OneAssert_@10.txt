[+] input: toByteArray() { DataItem dataItem = new DataItem(); dataItem.setReturnCode(EReturnCode.from((byte) 0xFF)); dataItem.setVariableType(EDataVariableType.BYTE_WORD_DWORD); dataItem.setCount(1); dataItem.setData(new byte[1]); ReadWriteDatum datum = new ReadWriteDatum(); datum.getReturnItems().add(dataItem); byte[] actual = datum.toByteArray(); byte[] expect = {(byte) 0xFF, (byte) 0x04, (byte) 0x00, (byte) 0x08, (byte) 0x00}; "<AssertPlaceHolder>"; }
toByteArray() { return new byte[0]; }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: testFormatSummary() { repository.addSample(NAME, 100); String summary = repository.formatSummary(); ConsolePrinter.printStandard(summary); String expectedSummary = "CounterRepositoryTest: 100 ms total, 1 inv, 100.0 ms/inv (avg.)" + SystemInfo.LF; "<AssertPlaceHolder>"; }
formatSummary() { DecimalFormat df = new DecimalFormat("0.0", DecimalFormatSymbols.getInstance(Locale.US)); List<String[]> list = new ArrayList<>(counters.size()); List<LatencyCounter> sortedCounters = new ArrayList<>(counters.values()); sortedCounters.sort((c1, c2) -> -Long .compare(c1.totalLatency(), c2.totalLatency())); for (LatencyCounter counter : sortedCounters) { list.add(new String[] { counter.getName() + ":", counter.totalLatency() + " ms total,", counter.sampleCount() + " inv,", df.format(counter.averageLatency()) + " ms/inv (avg.)" }); } return formatSummaryTable(list); }
[*] target: assertEquals(expectedSummary, summary)
[-] pred: org. junit. Assert. assertEquals ( expectedSummary, summary )
************************************
************************************
[+] input: testConstructionNonExisting() {  // Create switch with 1->0, 1->2, and 1->3 device1 = new EcmpSwitch(1, null, 5, new IdentityFlowletIntermediary()); device1.addConnection(topology.getPort(1, 0)); device1.addConnection(topology.getPort(1, 2)); device1.addConnection(topology.getPort(1, 3)); device1.addDestinationToNextSwitch(0, 0);  // ... but deny that you can travel to 2 via a non-existing port boolean thrown = false; try { device1.addDestinationToNextSwitch(2, 4); // there is no port to 4 } catch (IllegalArgumentException e) { thrown = true; } "<AssertPlaceHolder>"; }
addDestinationToNextSwitch(int destinationId, int nextHopId) {  // Check for not possible identifier if (!connectedTo.contains(nextHopId)) { throw new IllegalArgumentException("Cannot add hop to a network device to which it is not connected (" + nextHopId + ")"); }  // Check for duplicate List<Integer> current = this.destinationToNextSwitch.get(destinationId); if (current.contains(nextHopId)) { throw new IllegalArgumentException("Cannot add a duplicate next hop network device identifier (" + nextHopId + ")"); }  // Add to current ones current.add(nextHopId);  }
[*] target: assertTrue(thrown)
[-] pred: org. junit. Assert. assertTrue ( thrown )
************************************
************************************
[+] input: Exception { final DigitalCovidCertificate dgc = (DigitalCovidCertificate) new DigitalCovidCertificate() .withNam(new PersonName().withGn("Martin").withFn("Lindström")) .withDob("1969-11-11") .withV(Arrays.asList(new VaccinationEntry() .withTg("840539006") .withVp("1119349007") .withMp("EU/1/20/1507") .withMa("ORG-100030215") .withDn(Integer.valueOf(1)) .withSd(Integer.valueOf(2)) .withDt(LocalDate.parse("2021-04-17")) .withCo("SE") .withIs("Swedish eHealth Agency") .withCi("01:SE:JKJKHJGHG6768686HGJGH#M")));  byte[] encoding = dgc.encode();  DigitalCovidCertificate dgc2 = DigitalCovidCertificate.decode(encoding);  Assert."<AssertPlaceHolder>"; }
decode(final byte[] cbor) throws DGCSchemaException { try { return cborMapper.readValue(cbor, DigitalCovidCertificate.class); } catch (final IOException e) { throw new DGCSchemaException("Failed to decode DCC from CBOR encoding", e); } }
[*] target: assertEquals(dgc, dgc2)
[-] pred: org. junit. Assert. assertEquals ( dgc, dgc2 )
************************************
************************************
[+] input: testEmpty() { ScriptableExpression expression = new ScriptableExpression(null, null); "<AssertPlaceHolder>"; }
evaluate(Context context) { Object result; if (scriptOrText == null) { result = (defaultValueExpression != null ? defaultValueExpression.evaluate(context) : null); } else if (isScript) { result = ScriptUtil.evaluate(scriptOrText, context); } else { result = scriptOrText; } return result; }
[*] target: assertNull(expression.evaluate(context))
[-] pred: org. junit. Assert. assertNull ( expression. evaluate ( context ) )
************************************
************************************
[+] input: shouldHaveNoError() { LateRecordDropError lateRecordDropError = new LateRecordDropError(initContext); "<AssertPlaceHolder>"; }
hasException() { return false; }
[*] target: assertFalse(lateRecordDropError.hasException())
[-] pred: org. junit. Assert. assertFalse ( lateRecordDropError. hasException() )
************************************
************************************
[+] input: mp4StcoBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x63, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4StcoBox box = new Mp4StcoBox(); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: shouldCheckIfQueryIsInValidInCaseOfSingeEmptyVariableValueForSingleField() { when(sourceConfig.getVariables()).thenReturn("customer_id"); when(sourceConfig.getPattern()).thenReturn(""{\\"key\\": \\"%s\\"}"");  Row row = new Row(2); Row inputData = new Row(2); inputData.setField(1, ""); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{"order_number", "customer_id"}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  boolean queryInvalid = endpointHandler.isQueryInvalid(resultFuture, rowManager, sourceConfig.getVariables(), endpointOrQueryVariablesValues); "<AssertPlaceHolder>"; verify(resultFuture, times(1)).complete(any()); verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.EMPTY_INPUT); }
isQueryInvalid(ResultFuture<Row> resultFuture, RowManager rowManager, String variables, Object[] variablesValue) { if (!StringUtils.isEmpty(variables) && (Arrays.asList(variablesValue).isEmpty() || Arrays.stream(variablesValue).allMatch(""::equals))) { LOGGER.warn("Could not populate any request variable. Skipping external calls"); meterStatsManager.markEvent(ExternalSourceAspects.EMPTY_INPUT); resultFuture.complete(singleton(rowManager.getAll())); return true; } return false; }
[*] target: assertTrue(queryInvalid)
[-] pred: org. junit. Assert. assertTrue ( queryInvalid )
************************************
************************************
[+] input: testCheckAndSet_EnableCaching() { Mockito.when(req.getPathInfo()).thenReturn("/"); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(null); Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(0L);  BinaryResource res = BinaryResources.create() .withFilename("a.html") .withContent("<html></html>".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModified(0L) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey("/"), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert."<AssertPlaceHolder>";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute("jakarta.servlet.forward.path_info"); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, "private, max-age=0, must-revalidate"); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.ETAG, obj.createETag()); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // "private" //   Only browsers may cache this resource. // "max-age" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because "must-revalidate" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, "private, max-age=" + maxAge + ", s-maxage=" + maxAge); } else { // "private" //   Only browsers may cache this resource. // "must-revalidate" //   A cache HAS TO check with the server before using stale resources. // "max-age=0" //   A resource will become stale immediately (after 0 seconds). // Note: "max-age=0, must-revalidate" would be the same as "no-cache" resp.setHeader(CACHE_CONTROL, "private, max-age=0, must-revalidate"); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-None-Match/Etag): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-Modified-Since): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }
[*] target: assertFalse(b)
[-] pred: org. junit. Assert. assertFalse ( b )
************************************
************************************
[+] input: loadInvalidFormatConfigFile() { Enumeration<URL> configFileEnumeration = createConfigFileEnumeration( "invalid_format_yidun_regional_endpoints.json");  Map<String, Map<String, List<String>>> domainMap = EndpointConfigLoader.load(configFileEnumeration);  "<AssertPlaceHolder>"; }
load(Enumeration<URL> configFileUrls) { Map<String, Map<String, List<String>>> domainMap = new HashMap<>();  while (configFileUrls.hasMoreElements()) { List<EndpointConfigEntry> entries = parseConfig(configFileUrls.nextElement()); mergeConfig(domainMap, entries); }  return domainMap; }
[*] target: assertTrue(domainMap.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( domainMap. isEmpty ( ) )
************************************
************************************
[+] input: testSm3() { String str = "a-string-to-hash"; String expectedValue = "10bd18e0e96b6e9d79f8726c04df6c5aecdda4cf3f8e5c227c76eb3d3c850498";  String actualValue = SignatureMethodEnum.SM3.calcSign(str);  "<AssertPlaceHolder>"; }
calcSign(String str) { return signCalculator.calc(str); }
[*] target: assertEquals(expectedValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualValue )
************************************
************************************
[+] input: onCreation_whenGreenplumVersionIsBelowSix_thenExecutionLocationIsNotSet() { withGreenplumVersionLessThan6(() -> { GreenplumFunction function = new GreenplumFunction(mockSchema); Assert."<AssertPlaceHolder>"; }); }
getExecutionLocation() { return executionLocation; }
[*] target: assertNull(function.getExecutionLocation())
[-] pred: org. junit. Assert. assertNull ( function. getExecutionLocation() )
************************************
************************************
[+] input: shouldProcessForParametrizedHeaders() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.MESSAGE); when(httpSinkConfig.getSinkHttpParameterPlacement()).thenReturn(HttpSinkParameterPlacementType.HEADER);  parameterizedHeaderRequest = new ParameterizedHeaderRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedHeaderRequest.canProcess(); "<AssertPlaceHolder>"; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.HEADER; }
[*] target: assertTrue(canProcess)
[-] pred: org. junit. Assert. assertTrue ( canProcess )
************************************
************************************
[+] input: convertMultiPolygon_NoRedundantSpaces_ShouldConvert() { String wkt = "MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)),((15 5, 40 10, 10 20, 5 10, 15 5)))"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"MultiPolygon", "coordinates":" + " [[[[30,20],[45,40],[10,40],[30,20]]],[[[15,5],[40,10],[10,20],[5,10],[15,5]]]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: getVehicleLocationNotFoundWhenVehicleDetailsAreNull() { VehicleDetails vehicleDetails = getDummyVehicleDetails(); Mockito.when(vehicleDetailsRepository.findByUuid(vehicleDetails.getUuid())).thenReturn(null); VehicleLocationResponse vehicleLocationResponse = vehicleService.getVehicleLocation(vehicleDetails.getUuid()); Assertions."<AssertPlaceHolder>"; }
getVehicleLocation(UUID carId) { VehicleDetails vehicleDetails = null; VehicleLocationResponse vehicleLocationForm = null; UserDetails userDetails = null; Random random = new Random(); try { vehicleDetails = vehicleDetailsRepository.findByUuid(carId); if (vehicleDetails != null) { // vehicleDetails = vehicleDetailsRepository.findByVehicleLocation_id(carId); // vehicleDetails.setVehicleLocation(getVehicleLocationList().get(random.nextInt(getVehicleLocationList().size()))); if (vehicleDetails.getOwner() != null) { userDetails = userDetailsRepository.findByUser_id(vehicleDetails.getOwner().getId()); vehicleLocationForm = new VehicleLocationResponse( carId, (userDetails != null ? userDetails.getName() : null), (userDetails != null ? userDetails.getUser().getEmail() : null), vehicleDetails.getVehicleLocation()); return vehicleLocationForm; } } } catch (Exception exception) { log.error("Fail to get vehicle location-> Message: {}", exception); } return null; }
[*] target: assertNull(vehicleLocationResponse)
[-] pred: org. junit. Assert. assertNull ( vehicleLocationResponse )
************************************
************************************
[+] input: testGenerateIssueOrg() { String issueOrg = ChineseIDCardNumberGenerator.generateIssueOrg(); System.err.println(issueOrg); "<AssertPlaceHolder>"; }
generateIssueOrg() { return ChineseAreaList.cityNameList .get(RandomUtils.nextInt(0, ChineseAreaList.cityNameList.size())) + "公安局某某分局"; }
[*] target: assertNotNull(issueOrg)
[-] pred: org. junit. Assert. assertNotNull ( issueOrg )
************************************
************************************
[+] input: shouldFetchParsedValueForFieldForFieldDescriptorOfTypeLong() { long actualValue = 2L;  Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName("s2_id"); LongHandler longHandler = new LongHandler(fieldDescriptor); Object value = longHandler.parseObject(String.valueOf(actualValue));  "<AssertPlaceHolder>"; }
parseObject(Object field) { return Long.parseLong(getValueOrDefault(field, "0")); }
[*] target: assertEquals(actualValue, value)
[-] pred: org. junit. Assert. assertEquals ( actualValue, value )
************************************
************************************
[+] input: shouldReturnStringEnumValueWhenSimpleGroupIsPassed() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("status"); String expectedEnum = fieldDescriptor.getEnumType().getValues().get(1).getName(); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named("status") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add("status", expectedEnum); EnumHandler enumHandler = new EnumHandler(fieldDescriptor);  Object actualEnum = enumHandler.transformFromParquet(simpleGroup);  "<AssertPlaceHolder>"; }
transformFromParquet(SimpleGroup simpleGroup) { String defaultEnumValue = fieldDescriptor.getEnumType().findValueByNumber(0).getName(); String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { String parquetEnumValue = simpleGroup.getString(fieldName, 0); Descriptors.EnumValueDescriptor enumValueDescriptor = fieldDescriptor.getEnumType().findValueByName(parquetEnumValue); return enumValueDescriptor == null ? defaultEnumValue : enumValueDescriptor.getName(); } return defaultEnumValue; }
[*] target: assertEquals(expectedEnum, actualEnum)
[-] pred: org. junit. Assert. assertEquals ( expectedEnum, actualEnum )
************************************
************************************
[+] input: getCacheCodeVerifierNullClientId() { String res = PkceHelper.getCacheCodeVerifier(null); Assert."<AssertPlaceHolder>"; }
getCacheCodeVerifier(String clientId) { return (String) JapAuthentication.getContext().getCache().get(clientId); }
[*] target: assertNull(res)
[-] pred: org. junit. Assert. assertNull ( res )
************************************
************************************
[+] input: Exception { String expected = "0123äöü"; ByteArrayOutputStream out = new ByteArrayOutputStream(); IOUtility.writeString(out, "UTF-8", expected); String actual = new String(out.toByteArray(), "UTF-8"); "<AssertPlaceHolder>"; }
writeString(OutputStream out, String charset, String s) { try (OutputStreamWriter w = new OutputStreamWriter(out, charset)) { w.write(s); w.flush(); } catch (IOException e) { throw new ProcessingException("output: " + out, e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: SQLException { Mockito.when(mockResults.getBoolean("is_temp_table")).thenReturn(true); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert."<AssertPlaceHolder>"; }
isTemporaryTable() { return temporaryTable; }
[*] target: assertTrue(table.isTemporaryTable())
[-] pred: org. junit. Assert. assertTrue ( table. isTemporaryTable() )
************************************
************************************
[+] input: testAsciiConvertionWithSpecialCharInLocalPart() { // Arrange String emailAddress = "sömeöne@example.com";  // Act String convertedAddress = BEANS.get(MailIDNConverter.class).toASCII(emailAddress);  // Assert "<AssertPlaceHolder>"; }
toASCII(String email) { return convertToCharset(email, IDN::toASCII); }
[*] target: assertEquals(emailAddress, convertedAddress)
[-] pred: org. junit. Assert. assertEquals ( emailAddress, convertedAddress )
************************************
************************************
[+] input: testSetOrdered() { EAN8Generator ean8Generator = new EAN8Generator(); ean8Generator.setOrdered(true); "<AssertPlaceHolder>"; }
isOrdered() { return ordered; }
[*] target: assertTrue(ean8Generator.isOrdered())
[-] pred: org. junit. Assert. assertTrue ( ean8Generator. isOrdered() )
************************************
************************************
[+] input: logoutNullStore() { JapUserStore japUserStore = null; JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  boolean result = JapAuthentication.logout(request, response); Assert."<AssertPlaceHolder>"; }
logout(JapHttpRequest request, JapHttpResponse response) { JapUserStore japUserStore = context.getUserStore(); if (null == japUserStore) { return false; } japUserStore.remove(request, response);  // Clear all cookie information Map<String, JapHttpCookie> cookieMap = RequestUtil.getCookieMap(request); if (CollectionUtil.isNotEmpty(cookieMap)) { cookieMap.forEach((key, cookie) -> { cookie.setMaxAge(0); response.addCookie(cookie); }); } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: Exception { when(rccCache.getApiToken(anyString())).thenReturn(null); when(apiTokenService.selectByToken(anyString())).thenReturn(new ApiToken());  ApiToken result = apiTokenCacheServiceImpl.getApiToken("token"); Assert."<AssertPlaceHolder>";   }
getApiToken(String token) { ApiToken apiToken = rccCache.getApiToken(token); if (apiToken == null) { apiToken = apiTokenService.selectByToken(token); if (apiToken != null) { rccCache.loadApiToken(apiToken); } } return apiToken; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: shouldReturnKafkaEnvVarsPositive() { Configuration configuration = new Configuration(); configuration.setString("PATH", "/usr/local/bin"); configuration.setString("SHELL", "/usr/local/bin/zsh"); configuration.setString("source_kafka_config_fetch_min_bytes", "1"); configuration.setString("source_kafka_config_ssl_keystore_location", "/home/user/.ssh/keystore"); configuration.setString("source_kafka_config_enable_auto_commit", "false");  Properties expectedEnvVars = new Properties() {{ put("fetch.min.bytes", "1"); put("ssl.keystore.location", "/home/user/.ssh/keystore"); put("enable.auto.commit", "false"); }};  Properties actualEnvVars = KafkaEnvironmentVariables.parse(configuration);  "<AssertPlaceHolder>"; }
parse(Configuration configuration) { Properties props = new Properties();  if (configuration == null || configuration.keySet().size() == 0) { return props; }  configuration.toMap().entrySet() .stream() .filter(e -> e.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .forEach(e -> props.setProperty(parseVarName(e.getKey()), e.getValue())); return props; }
[*] target: assertEquals(expectedEnvVars, actualEnvVars)
[-] pred: org. junit. Assert. assertEquals ( expectedEnvVars, actualEnvVars )
************************************
************************************
[+] input: Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.exists("key"); Assert."<AssertPlaceHolder>"; }
exists(String key) throws DataAccessException { if (isBlank(key)) { return Boolean.FALSE; } String keyString = keyPrefix.concat(key); return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); return connection.exists(keyb); }); }
[*] target: assertEquals(Boolean.TRUE, result)
[-] pred: org. junit. Assert. assertEquals ( Boolean. TRUE, result )
************************************
************************************
[+] input: shouldNotProvideProtoDeserializerWhenSchemaTypeIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn("JSON");  ProtoDeserializerProvider provider = new ProtoDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator);  "<AssertPlaceHolder>"; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }
[*] target: assertFalse(provider.canProvide())
[-] pred: org. junit. Assert. assertFalse ( provider. canProvide() )
************************************
************************************
[+] input: shouldFetchValueForFieldForFieldDescriptorOfTypeInteger() { int actualValue = 2;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("cancel_reason_id"); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); Object value = integerHandler.parseObject(actualValue);  "<AssertPlaceHolder>"; }
parseObject(Object field) { return Integer.parseInt(getValueOrDefault(field, "0")); }
[*] target: assertEquals(actualValue, value)
[-] pred: org. junit. Assert. assertEquals ( actualValue, value )
************************************
************************************
[+] input: testGenerate() { String generatedName = ChineseNameGenerator.getInstance().generate(); "<AssertPlaceHolder>"; System.err.println(generatedName); }
generate() { //姓名暂时还是两到三字，比较常见些 return genFirstName() + ChineseCharUtils.genRandomLengthChineseChars(1, 2); }
[*] target: assertNotNull(generatedName)
[-] pred: org. junit. Assert. assertNotNull ( generatedName )
************************************
************************************
[+] input: shouldNotBeEmptyWhenEsAndGrpcConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, es, null, grpc);  "<AssertPlaceHolder>"; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }
[*] target: assertFalse(externalSourceConfig.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( externalSourceConfig. isEmpty() )
************************************
************************************
[+] input: toByteArray() { PlcControlParameter parameter = new PlcControlParameter(); parameter.setParameterBlock(new PlcControlStringParamBlock()); parameter.setPiService(PlcControlParameter.P_PROGRAM); byte[] actual = parameter.toByteArray(); byte[] expect = {(byte) 0x28, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xFD, (byte) 0x00, (byte) 0x00, (byte) 0x09, (byte) 0x50, (byte) 0x5f, (byte) 0x50, (byte) 0x52, (byte) 0x4F, (byte) 0x47, (byte) 0x52, (byte) 0x41, (byte) 0x4D}; "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(1 + 7 + 2 + this.parameterBlockLength + 1 + this.lengthPart) .putByte(this.functionCode.getCode()) .putBytes(this.unknownBytes) .putShort(this.parameterBlockLength) .putBytes(this.parameterBlock.toByteArray()) .putByte(this.lengthPart) .putString(this.piService) .getData(); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: testToString() { DefaultClient client = DefaultClient.createDefault(secretId, secretKey);  String expectedStr = "DefaultClient(" + "defaultRegionCode=" + client.defaultRegionCode() + ", defaultProtocol=" + client.defaultProtocol() + ", maxAttemptCount=" + client.maxAttemptCount() + ")";  "<AssertPlaceHolder>"; }
toString() { return "DefaultClient(" + "defaultRegionCode=" + defaultRegionCode + ", defaultProtocol=" + defaultProtocol + ", maxAttemptCount=" + maxAttemptCount + ")"; }
[*] target: assertEquals(expectedStr, client.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedStr, client. toString ( ) )
************************************
************************************
[+] input: InvalidProtocolBufferException { String protoClass = "org.raystack.dagger.consumer.TestComplexMap"; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestComplexMap.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  TestComplexMap complexMapMessage = TestComplexMap.newBuilder() .putComplexMap(1, commonMessage) .build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(complexMapMessage.getDescriptor(), complexMapMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = "{"complex_map":[{"key":1,"value":{"order_number":"order-number-123","order_url":"https://order-url","order_details":"pickup"}}],"int_message":[],"string_message":[]}"; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  "<AssertPlaceHolder>"; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }
[*] target: assertEquals(expectedJsonPayload, actualJsonPayload)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonPayload, actualJsonPayload )
************************************
************************************
[+] input: testErrorDueToNoOtherDBSupportThisQuery() { when(openSearchConnection.select(anyString())) .thenReturn( new DBResult( "OpenSearch", asList(new Type("firstname", "text")), asList(new Row(asList("John"))))); when(otherDbConnection.select(anyString())) .thenThrow(new RuntimeException("Unsupported feature"));  TestReport expected = new TestReport(); expected.addTestCase( new ErrorTestCase( 1, "SELECT * FROM accounts", "No other databases support this query: Unsupported feature;")); TestReport actual = correctnessTest.verify(querySet("SELECT * FROM accounts")); "<AssertPlaceHolder>"; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format("%s: %s", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: gracefulIncompleteParameterPairsParse() { testRequest = new Request.Builder() .url("http://www.amazon.com/request/library?isSigned& =false") .get() .build();  Map<String, List<String>> expected = new HashMap<>(); expected.put("isSigned", Collections.singletonList(null)); expected.put(" ", Collections.singletonList("false"));  underTest = new SignableRequestImpl(testRequest);  "<AssertPlaceHolder>"; }
getParameters() { Map<String, List<String>> parameters = new HashMap<>(); try { List<NameValuePair> nameValuePairs = URLEncodedUtils.parse(originalRequest.url().toURI(), StandardCharsets.UTF_8); nameValuePairs.forEach(nameValuePair -> parameters.put(nameValuePair.getName(), Collections.singletonList(nameValuePair.getValue()))); } catch (URISyntaxException e) { throw new RuntimeException(e); }  return parameters; }
[*] target: assertEquals(expected, underTest.getParameters())
[-] pred: org. junit. Assert. assertEquals ( expected, underTest. getParameters() )
************************************
************************************
[+] input: shouldHaveError() { ValidError validError = new ValidError(); "<AssertPlaceHolder>"; }
hasException() { return true; }
[*] target: assertTrue(validError.hasException())
[-] pred: org. junit. Assert. assertTrue ( validError. hasException() )
************************************
************************************
[+] input: shouldReturnTypeInformation() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName("event_timestamp"); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); TypeInformation actualTypeInformation = timestampHandler.getTypeInformation(); TypeInformation<Row> expectedTypeInformation = Types.ROW_NAMED(new String[]{"seconds", "nanos"}, Types.LONG, Types.INT); "<AssertPlaceHolder>"; }
getTypeInformation() { return TypeInformationFactory.getRowType(fieldDescriptor.getMessageType()); }
[*] target: assertEquals(expectedTypeInformation, actualTypeInformation)
[-] pred: org. junit. Assert. assertEquals ( expectedTypeInformation, actualTypeInformation )
************************************
************************************
[+] input: shouldFetchValueForFieldForFieldDescriptorOfTypeByteString() { ByteString actualValue = ByteString.copyFromUtf8("test");  Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName("log_key"); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor); Object value = byteStringHandler.parseObject(actualValue);  "<AssertPlaceHolder>"; }
parseObject(Object field) { return field; }
[*] target: assertEquals(actualValue, value)
[-] pred: org. junit. Assert. assertEquals ( actualValue, value )
************************************
************************************
[+] input: Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.hdel("key", "field"); Assert."<AssertPlaceHolder>"; }
hdel(String key, String field) throws DataAccessException { if (isBlank(key) || isBlank(field)) { return Boolean.FALSE; } String keyString = keyPrefix.concat(key); return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[] fieldb = field.getBytes(); connection.hDel(keyb, fieldb); return Boolean.TRUE; }); }
[*] target: assertEquals(Boolean.TRUE, result)
[-] pred: org. junit. Assert. assertEquals ( Boolean.TRUE, result )
************************************
************************************
[+] input: testExists404() { Response r = new Response(Collections.emptyMap(), new byte[0], 404); "<AssertPlaceHolder>"; }
exists() { if (statusCode >= 200 && statusCode <= 299) { return true; } else if (statusCode == HttpURLConnection.HTTP_NOT_FOUND) { return false; } else { throw new ServiceException(statusCode, "call failed"); } }
[*] target: assertFalse(r.exists())
[-] pred: org. junit. Assert. assertFalse ( r. exists() )
************************************
************************************
[+] input: createResponse2() { String expect = "Digest username="admin", realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", uri="rtsp://10.3.8.202:554", response="876fcfac745c91bb7dd89faa660891ea""; UsernamePasswordCredential credential = new UsernamePasswordCredential("admin", "12345"); DigestAuthenticator authenticator = new DigestAuthenticator(credential); authenticator.addServerInfo("IP Camera(10789)", "", "6b9a455aec675b8db81a9ceb802e4eb8", false); authenticator.addClientInfo("rtsp://10.3.8.202:554", "DESCRIBE"); String actual = authenticator.createResponse(); "<AssertPlaceHolder>"; }
createResponse() { if (this.realm == null || this.realm.equals("")) { throw new AuthenticationException("realm is empty"); } if (this.nonce == null || this.nonce.equals("")) { throw new AuthenticationException("nonce is empty"); } if (this.uri == null || this.uri.equals("")) { throw new AuthenticationException("uri is empty"); } if (this.method == null || this.method.equals("")) { throw new AuthenticationException("method is empty"); } StringBuilder sb = new StringBuilder(); sb.append(DIGEST_NAME).append(" ") .append("username="").append(this.credential.getUsername()).append("", ") .append("realm="").append(this.realm).append("", ") .append("nonce="").append(this.nonce).append("", ") .append("uri="").append(this.uri).append("", "); if (this.qop == null || this.qop.equals("")) { sb.append("response="").append(this.calculateResponseString()).append("""); } else { sb.append("response="").append(this.calculateResponseString()).append("", ") .append("qop=").append(this.qop).append(", ") .append("nc=").append(String.format("%08X", this.nc)).append(", ") .append("cnonce="").append(this.cnonce).append("""); } return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldNotProvideJsonDeserializerWhenSourceNameIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.BOUNDED)}); when(streamConfig.getDataType()).thenReturn("JSON");  JsonDeserializerProvider provider = new JsonDeserializerProvider(streamConfig);  "<AssertPlaceHolder>"; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }
[*] target: assertFalse(provider.canProvide())
[-] pred: org. junit. Assert. assertFalse ( provider. canProvide() )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeData() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "25"); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: mp4MfhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x10, 0x6D, 0x66, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }; Mp4MfhdBox box = new Mp4MfhdBox(1); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: writeDate() { LocalDate expect = LocalDate.of(2023, 4, 1); s7PLC.writeDate("DB4.296", expect); LocalDate actual = s7PLC.readDate("DB4.296"); "<AssertPlaceHolder>"; }
readDate(String address) { int offset = this.readUInt16(address); return LocalDate.of(1990, 1, 1).plusDays(offset); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testBuildForegroundNotificationWithoutPermission() { permissionManager.setHasPostNotificationsPermission(false); Notification notification = notificationHandler.buildForegroundNotification(); "<AssertPlaceHolder>"; }
buildForegroundNotification() { Log.d(NotificationHandler.class.getName(), "buildForegroundNotification"); if (!permissionManager.hasPostNotificationsPermission(getContext())) { Log.e(NotificationHandler.class.getName(), "Cannot build foreground notification because of missing permission. Returning null."); return null; } String title = getResources().getString(R.string.notification_title); String text = getResources().getString(R.string.notification_foreground_text); foregroundNotificationBuilder = createForegroundNotificationBuilder(); foregroundNotificationBuilder.setSmallIcon(R.drawable.icon_notification_foreground).setContentTitle(title).setContentText(text).setStyle(new NotificationCompat.BigTextStyle().bigText(text)).setPriority(NotificationCompat.PRIORITY_LOW); if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) { foregroundNotificationBuilder.setVibrate(null); foregroundNotificationBuilder.setSound(null); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) { foregroundNotificationBuilder.setForegroundServiceBehavior(Notification.FOREGROUND_SERVICE_IMMEDIATE); } return foregroundNotificationBuilder.build(); }
[*] target: assertNull(notification)
[-] pred: org. junit. Assert. assertNull ( notification )
************************************
************************************
[+] input: selectSingle2() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andIn(MysqlUserEntity::getId, Arrays.asList(1, 1, 1, 1, 1, 1)); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert."<AssertPlaceHolder>"; log.info("mysqlUserEntity : {}", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }
[*] target: assertNotNull(mysqlUserEntity)
[-] pred: org. junit. Assert. assertNotNull ( mysqlUserEntity )
************************************
************************************
[+] input: shouldReturnDefaultTimestampRowDuringTransformIfNullIsPassedToTransformFromParquet() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("event_timestamp"); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor);  Row actualRow = (Row) timestampHandler.transformFromParquet(null);  Row expectedRow = Row.of(0L, 0); "<AssertPlaceHolder>"; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }
[*] target: assertEquals(expectedRow, actualRow)
[-] pred: org. junit. Assert. assertEquals ( expectedRow, actualRow )
************************************
************************************
[+] input: insert() { byte[] expect = {(byte) 0x28, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xFD, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x00, (byte) 0x30, (byte) 0x41, (byte) 0x30, (byte) 0x30, (byte) 0x30, (byte) 0x30, (byte) 0x31, (byte) 0x50, (byte) 0x05, (byte) 0x5F, (byte) 0x49, (byte) 0x4e, (byte) 0x53, (byte) 0x45};  PlcControlParameter insert = PlcControlParameter.insert(EFileBlockType.DB, 1, EDestinationFileSystem.P); "<AssertPlaceHolder>";  }
toByteArray() { return ByteWriteBuff.newInstance(1 + 7 + 2 + this.parameterBlockLength + 1 + this.lengthPart) .putByte(this.functionCode.getCode()) .putBytes(this.unknownBytes) .putShort(this.parameterBlockLength) .putBytes(this.parameterBlock.toByteArray()) .putByte(this.lengthPart) .putString(this.piService) .getData(); }
[*] target: assertArrayEquals(expect, insert.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, insert. toByteArray ( ) )
************************************
************************************
[+] input: shouldNotReturnAnyError() { LateRecordDropError lateRecordDropError = new LateRecordDropError(initContext); "<AssertPlaceHolder>"; }
getCurrentException() { return null; }
[*] target: assertNull(lateRecordDropError.getCurrentException())
[-] pred: org. junit. Assert. assertNull ( lateRecordDropError. getCurrentException() )
************************************
************************************
[+] input: testAppendScan() { LogRecord expected = new MasterLogRecord(1234);  logManager.appendToLog(expected); LogRecord record = logManager.scanFrom(0).next();  "<AssertPlaceHolder>"; }
next() { if (hasNext()) { final BacktrackingIterator<LogRecord> iter = nextIter; BacktrackingIterable<LogRecord> iterable = () -> iter;  nextIter = null; do { ++nextIndex; try { Page page = bufferManager.fetchPage(new DummyLockContext(), nextIndex); nextIter = new LogPageIterator(page, 0); } catch (PageException e) { break; } } while (!nextIter.hasNext());  return iterable; } throw new NoSuchElementException(); }
[*] target: assertEquals(expected, record)
[-] pred: org. junit. Assert. assertEquals ( expected, record )
************************************
************************************
[+] input: hasTypeShouldBeTrueWhenTypeIsPresent() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setType(type) .createEsSourceConfig(); "<AssertPlaceHolder>"; }
hasType() { return StringUtils.isNotEmpty(type); }
[*] target: assertTrue(esSourceConfig.hasType())
[-] pred: org. junit. Assert. assertTrue ( esSourceConfig. hasType() )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x0F, (byte) 0x00, (byte) 0x13, (byte) 0x00, (byte) 0x0A, (byte) 0x02, (byte) 0xCD, (byte) 0x01}; MbWriteMultipleCoilRequest mb = new MbWriteMultipleCoilRequest(); mb.setFunctionCode(EMbFunctionCode.WRITE_MULTIPLE_COIL); mb.setAddress(19); mb.setQuantity(10); mb.setCount(2); mb.setValue(new byte[]{(byte) 0xCD, (byte) 0x01}); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .putByte(this.count) .putBytes(this.value) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: testUpdateActionsFromPaths_invalidChangedPath() { Set<UpdateAction> expectedActions = EnumSet.noneOf(UpdateAction.class); // just a directory is not a valid changedPath: directories don't change, files do. // getUpdateActionsFromPaths should skip invalid changedPaths List<Path> invalidChangedPaths = List.of( Path.of("resources"), Path.of("resources/custom-resources"), Path.of("services")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(invalidChangedPaths); "<AssertPlaceHolder>"; }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: testToString() { SignResult result = new SignResult(SignatureMethodEnum.MD5, "a-secret-id-1", "a-sign-1"); String expectedStr = "SignResult(signMethod=MD5, secretId=a-secret-id-1, signature=a-sign-1)";  String actualStr = result.toString();  "<AssertPlaceHolder>"; }
toString() { return "SignResult(" + "signMethod=" + signMethod + ", secretId=" + secretId + ", signature=" + signature + ")"; }
[*] target: assertEquals(expectedStr, actualStr)
[-] pred: org. junit. Assert. assertEquals ( expectedStr, actualStr )
************************************
************************************
[+] input: filteredListSizeIsCorrect1() { int k = 3; // instantiate random filter with parameter k KLeastExecutedFilter filter = new KLeastExecutedFilter(k); // call filter method to obtain filtered list List<MutationInstance> filteredList = filter.filterMutants(toFilter); // filtered list should be of size k "<AssertPlaceHolder>"; }
filterMutants(List<MutationInstance> toFilter) {  // determine number of mutants to run int n = this.percent ? (guidance.getSeenMutants() * k / 100) : k;  // initialize filtered list to be returned ArrayList<MutationInstance> filteredList = new ArrayList<MutationInstance>(); ArrayList<MutationInstance> executedMutants = new ArrayList<MutationInstance>();  // add (up to n) mutants in toFilter that have not been executed before to filteredList int numMutants = 0; for (MutationInstance mutant : toFilter){ if (numMutants < n && !executionCounts.containsKey(mutant)){ filteredList.add(mutant); numMutants++; } // add all mutants that have already been executed before to a list else if (executionCounts.containsKey(mutant)){ executedMutants.add(mutant); } }  // if numMutants < n mutants have never been executed, add the next (n - numMutants) least executed mutants to filtered list if (numMutants < n){  // sort list of already executed MutationInstances by execution count Collections.sort(executedMutants, (e1, e2) -> executionCounts.get(e1).compareTo(executionCounts.get(e2)));  // add least executed to filteredList until |filteredList| = n int size = executedMutants.size(); for(int i = 0; i < size && numMutants < n; i++){ MutationInstance mutant = executedMutants.get(i); filteredList.add(mutant); numMutants++; } }  // increment execution count for each mutant in filteredList for (MutationInstance mutant: filteredList) { if (!executionCounts.containsKey(mutant)){ executionCounts.put(mutant, 1); } else { executionCounts.put(mutant, executionCounts.get(mutant)+1); } }  return filteredList; }
[*] target: assertEquals(k, filteredList.size())
[-] pred: org. junit. Assert. assertEquals ( k, filteredList. size ( ) )
************************************
************************************
[+] input: toByteArray() { SetupComParameter setupComParameter = new SetupComParameter(); setupComParameter.setFunctionCode(EFunctionCode.READ_VARIABLE); setupComParameter.setReserved((byte) 0x00); setupComParameter.setMaxAmqCaller(0x0001); setupComParameter.setMaxAmqCallee(0x0001); setupComParameter.setPduLength(0x0004); byte[] actual = setupComParameter.toByteArray(); byte[] expect = {(byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x04}; "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.functionCode.getCode()) .putByte(this.reserved) .putShort(this.maxAmqCaller) .putShort(this.maxAmqCallee) .putShort(this.pduLength) .getData(); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: testConstructorTimeAndRandom() {  Random random = new Random();  for (int i = 0; i < DEFAULT_LOOP_MAX; i++) {  // get a random time and a random payload long time = random.nextLong() & 0x00000000ffffffffL; byte[] payload = new byte[Ksuid.PAYLOAD_BYTES]; random.nextBytes(payload);  // build the expected byte array byte[] expectedBytes = new byte[Ksuid.KSUID_BYTES]; ByteBuffer buffer = ByteBuffer.allocate(Ksuid.KSUID_BYTES + 4); buffer.putLong(time - Ksuid.EPOCH_OFFSET); // apply offset buffer.put(payload); System.arraycopy(buffer.array(), 4, expectedBytes, 0, Ksuid.KSUID_BYTES);  // get the actual byte array Ksuid ksuid = new Ksuid(time, payload); byte[] actualBytes = ksuid.toBytes();  // compare the actual byte array to the expected byte array for (int j = 0; j < Ksuid.KSUID_BYTES; j++) { "<AssertPlaceHolder>"; } }  try { long time = 0x0000000000000000L; byte[] payload = null; new Ksuid(time, payload); fail("Should throw an exception"); } catch (IllegalArgumentException e) { // success }  try { long time = 0x0000000000000000L; byte[] payload = new byte[Ksuid.PAYLOAD_BYTES + 1]; new Ksuid(time, payload); fail("Should throw an exception"); } catch (IllegalArgumentException e) { // success } }
toBytes() {  byte[] bytes = new byte[KSUID_BYTES];  // copy the seconds bytes[0] = (byte) ((this.seconds >>> 0x18) & 0xff); bytes[1] = (byte) ((this.seconds >>> 0x10) & 0xff); bytes[2] = (byte) ((this.seconds >>> 0x08) & 0xff); bytes[3] = (byte) ((this.seconds >>> 0x00) & 0xff);  // copy the payload System.arraycopy(this.payload, 0, bytes, TIME_BYTES, PAYLOAD_BYTES);  return bytes; }
[*] target: assertEquals(expectedBytes[j], actualBytes[j])
[-] pred: org. junit. Assert. assertEquals ( expectedBytes [ j ], actualBytes [ j ] )
************************************
************************************
[+] input: testConvertNull() { MiddleMask m = new MiddleMask(3, 2); "<AssertPlaceHolder>"; }
convert(String sourceValue) throws ConversionException { if (sourceValue == null) { return null; } int length = sourceValue.length(); if (length < fromHead) { return sourceValue; } char[] chars = new char[sourceValue.length()]; sourceValue.getChars(0, chars.length, chars, 0); int max = Math.max(length - fromTail, fromHead); Arrays.fill(chars, fromHead, max, mask); return new String(chars); }
[*] target: assertNull(m.convert(null))
[-] pred: org. junit. Assert. assertNull ( m. convert ( null ) )
************************************
************************************
[+] input: testContainsNodeNoNodes() { ITree tree = mock(ITree.class); ITreeNode nodeA = mockNode("a"); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION); "<AssertPlaceHolder>"; }
containsNode(ITreeNode nodeToFind) { if (CollectionUtility.isEmpty(m_nodes)) { return false; } for (ITreeNode node : m_nodes) { if (ObjectUtility.equals(node, nodeToFind)) { return true; } } return false; }
[*] target: assertFalse(event.containsNode(nodeA))
[-] pred: org. junit. Assert. assertFalse ( event. containsNode ( nodeA ) )
************************************
************************************
[+] input: checkTokenNullContext() { Map<String, Object> map = JapAuthentication.checkToken("aaa"); Assert."<AssertPlaceHolder>"; }
checkToken(String token) { if (null == context || ObjectUtil.isEmpty(token)) { return null; } JapCache japCache = context.getCache(); if (null == japCache) { return null; } Map<String, Object> tokenMap = JapTokenHelper.checkToken(token); if (MapUtil.isNotEmpty(tokenMap)) { Kv kv = new Kv(); kv.putAll(tokenMap); // Get the token creation time, multiplied by 1000 is the number of milliseconds long iat = kv.getLong("iat") * 1000; JapConfig japConfig = context.getConfig(); // Get token expiration time long tokenExpireTime = japConfig.getTokenExpireTime(); // The token is available when the token creation time plus the token expiration time is later than the current time, // otherwise the token has expired if (new Date(iat + tokenExpireTime).after(new Date())) { return tokenMap; } } return null; }
[*] target: assertNull(map)
[-] pred: org. junit. Assert. assertNull ( map )
************************************
************************************
[+] input: Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.put("key", "value", Long.valueOf(1)); Assert."<AssertPlaceHolder>"; }
put(String key, Object value, Long customerExpire) throws DataAccessException { if (isBlank(key)) { return Boolean.FALSE; } String keyString = keyPrefix.concat(key); final long liveTime = (customerExpire != null) ? customerExpire : expireTime; return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[] valueb = GsonUtils.toJsonBytes(value); if (liveTime > 0) { connection.setEx(keyb, liveTime, valueb); } else { connection.set(keyb, valueb); } return Boolean.TRUE; }); }
[*] target: assertEquals(Boolean.TRUE, result)
[-] pred: org. junit. Assert. assertEquals ( Boolean.TRUE, result )
************************************
************************************
[+] input: testCleanupWithEmptyList() { List<IMenu> cleanList = MenuUtility.visibleNormalizedMenus(Collections.emptyList()); "<AssertPlaceHolder>"; }
visibleNormalizedMenus(List<IMenu> menus) { return normalizedMenus(menus, createVisibleFilter()); }
[*] target: assertTrue(cleanList.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( cleanList. isEmpty ( ) )
************************************
************************************
[+] input: mp4MvhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x6C, 0x6D, 0x76, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, }; Mp4MvhdBox box = new Mp4MvhdBox(this.trackInfo); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: shouldFetchValueForFieldForFieldDescriptorOfTypeBool() { boolean actualValue = true;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("customer_dynamic_surge_enabled"); BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); Object value = booleanHandler.parseObject(actualValue);  "<AssertPlaceHolder>"; }
parseObject(Object field) { return Boolean.parseBoolean(getValueOrDefault(field, "false")); }
[*] target: assertEquals(actualValue, value)
[-] pred: org. junit. Assert. assertEquals ( actualValue, value )
************************************
************************************
[+] input: fetchKeywordTest1() { String sql = "select * from `busu` where id = '1' and name = 'dingfeng' "; List<String> expectList = Lists .newArrayList("select", "*", "from", "`busu`", "where", "id", "=", "'1'", "and", "name", "=", "'dingfeng'"); List<String> actualList = SqlKeywordMatchUtils.fetchWords(sql); Assert."<AssertPlaceHolder>"; }
fetchWords(String sql) { if (StringUtils.isBlank(sql)) { return Collections.EMPTY_LIST; } List<String> words = Lists.newArrayList(); MyMySqlLexer lexer = new MyMySqlLexer(sql); do { lexer.nextToken(); String word = stringVal(lexer); if (StringUtils.isNotBlank(word)) { words.add(word); } } while (!lexer.isEOF()); return words; }
[*] target: assertEquals(expectList, actualList)
[-] pred: org. junit. Assert. assertEquals ( expectList, actualList )
************************************
************************************
[+] input: Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.put("key", "value"); Assert."<AssertPlaceHolder>"; }
put(String key, Object value) throws DataAccessException { return put(key, value, expireTime + random.nextInt(10)); }
[*] target: assertEquals(Boolean.TRUE, result)
[-] pred: org. junit. Assert. assertEquals ( Boolean.TRUE, result )
************************************
************************************
[+] input: toByteArrayList() { byte[] expect = new byte[]{(byte) 0x81, // 0, 25689 (byte) 0x00, (byte) 0x00, (byte) 0x64, (byte) 0x59, // 523975585 (byte) 0x1F, (byte) 0x3B, (byte) 0x3B, (byte) 0xA1, (byte) 0x1F, (byte) 0x3B, (byte) 0x3B, (byte) 0xA1, // 33.16f, -15.62f (byte) 0x42, (byte) 0x04, (byte) 0xA3, (byte) 0xD7, (byte) 0xC1, (byte) 0x79, (byte) 0xEB, (byte) 0x85, // 156665.35455556 (byte) 0x41, (byte) 0x03, (byte) 0x1F, (byte) 0xCA, (byte) 0xD6, (byte) 0x21, (byte) 0x39, (byte) 0xB7, // -56516.66664 (byte) 0xC0, (byte) 0xEB, (byte) 0x98, (byte) 0x95, (byte) 0x55, (byte) 0x1D, (byte) 0x68, (byte) 0xC7, // 23A (byte) 0x32, (byte) 0x33, (byte) 0x41};  ByteArraySerializer serializer = ByteArraySerializer.newInstance(); ByteArrayListBean listBean = serializer.toObject(ByteArrayListBean.class, expect); byte[] actual = serializer.toByteArray(listBean); "<AssertPlaceHolder>"; }
toByteArray(final T targetBean) { try { // 组装数据，同时计算最大的字节长度 int buffSize = 0; List<ByteArrayParseData> parseDataList = new ArrayList<>(); for (final Field field : targetBean.getClass().getDeclaredFields()) { final ByteArrayVariable variable = field.getAnnotation(ByteArrayVariable.class); if (variable == null) { continue; } ByteArrayParameter parameter = new ByteArrayParameter(variable.byteOffset(), variable.bitOffset(), variable.count(), variable.type(), variable.littleEndian(), variable.format()); this.checkByteArrayVariable(parameter); parseDataList.add(new ByteArrayParseData(variable, field)); int maxPos = variable.byteOffset() + variable.count() * variable.type().getByteLength(); if (maxPos > buffSize) { buffSize = maxPos; } } if (buffSize == 0 || parseDataList.isEmpty()) { return new byte[0]; } // 填充字节数组的内容 ByteWriteBuff buff = ByteWriteBuff.newInstance(buffSize); for (ByteArrayParseData item : parseDataList) { item.getField().setAccessible(true); Object data = item.getField().get(targetBean); if (data == null) { continue; } if (item.getVariable().count() == 1) { this.fillOneData(item.getVariable(), data, buff, 0); } else { this.fillListData(item.getVariable(), data, buff); } } return buff.getData(); } catch (Exception e) { throw new ByteArrayParseException("parsing to object error, cause:" + e.getMessage(), e); } }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: testToAndFromString() { for (int i = 0; i < DEFAULT_LOOP_MAX; i++) { String string = getRandomString(); Ksuid ksuid2 = Ksuid.from(string); "<AssertPlaceHolder>"; } }
toString() { return toBase62(this); }
[*] target: assertEquals(string, ksuid2.toString())
[-] pred: org. junit. Assert. assertEquals ( string, ksuid2. toString() )
************************************
************************************
[+] input: shouldReturnTrueForHasSQLTransformerIfAnyOneTransformConfigContainsSQLTransformer() { String configuration = "{ "external_source": { "es": [ { "host": "localhost:9200", "output_mapping": { "customer_profile": { "path": "$._source" } }, "query_param_pattern": "/customers/customer/%s", "query_param_variables": "customer_id", "retry_timeout": "5000", "socket_timeout": "6000", "stream_timeout": "5000", "type": "TestLogMessage" } ], "http": [ { "body_column_from_sql": "request_body", "connect_timeout": "5000", "endpoint": "http://localhost:8000", "fail_on_errors": "true", "headers": { "content-type": "application/json" }, "output_mapping": { "surge_factor": { "path": "$.data.tensor.values[0]" } }, "stream_timeout": "5000", "verb": "post" } ] }, "internal_source":[ { "output_field": "event_timestamp", "value": "CURRENT_TIMESTAMP", "type": "function" }, { "output_field": "s2_id_level", "value": "7", "type": "constant" } ], "transformers": [ { "transformation_arguments": { "sqlQuery": "SELECT * from data_stream" }, "transformation_class": "SQLTransformer" }, { "transformation_arguments": { "arg1": "test" }, "transformation_class": "org.raystack.dagger.transformer.Test" } ] }"; defaultPostProcessorConfig = PostProcessorConfig.parse(configuration); "<AssertPlaceHolder>"; }
hasSQLTransformer() { return hasTransformConfigs() && transformers .stream() .anyMatch(transformConfig -> transformConfig .getTransformationClass() .equals(Constants.SQL_TRANSFORMER_CLASS)); }
[*] target: assertTrue(defaultPostProcessorConfig.hasSQLTransformer())
[-] pred: org. junit. Assert. assertTrue ( defaultPostProcessorConfig. hasSQLTransformer ( ) )
************************************
************************************
[+] input: shouldReturnCheckPointedPositionWithNoOffsetAndZeroRecordsAfterOffsetWhenReadHasNotBeenCalledYet() { ParquetReader.ParquetReaderProvider provider = new ParquetReader.ParquetReaderProvider(deserializer, statsDReporterSupplierMock); ClassLoader classLoader = getClass().getClassLoader(); ParquetReader reader = provider.getReader(classLoader.getResource("test_file.parquet").getPath());  CheckpointedPosition expectedCheckpointedPosition = new CheckpointedPosition(CheckpointedPosition.NO_OFFSET, 0);  "<AssertPlaceHolder>"; }
getCheckpointedPosition() { return new CheckpointedPosition(CheckpointedPosition.NO_OFFSET, totalEmittedRowCount); }
[*] target: assertEquals(expectedCheckpointedPosition, reader.getCheckpointedPosition())
[-] pred: org. junit. Assert. assertEquals ( expectedCheckpointedPosition, reader. getCheckpointedPosition ( ) )
************************************
************************************
[+] input: InterruptedException { long createdTimestamp = System.currentTimeMillis(); LocalFileMetadata metadata = new LocalFileMetadata("/tmp", "/tmp/a/random-file-name-1", createdTimestamp, 100L, 100L); Thread.sleep(300); boolean shouldRotate = rotatingPolicy.shouldRotate(metadata); Assert."<AssertPlaceHolder>"; }
shouldRotate(LocalFileMetadata metadata) { return System.currentTimeMillis() - metadata.getCreatedTimestampMillis() >= maxRotatingDurationMillis; }
[*] target: assertTrue(shouldRotate)
[-] pred: org. junit. Assert. assertTrue ( shouldRotate )
************************************
************************************
[+] input: shouldDeleteNestedValueAndReturnAsJsonString() { JsonDelete jsonDelete = new JsonDelete(); String jsonEvent = "{"k1":"v1","k2":{"key1":"value1","key2":"value2","key3":"value3"}}"; String expectedJsonEvent = "{"k1":"v1","k2":{"key2":"value2","key3":"value3"}}"; String jPath = "$.k2.key1"; String actual = jsonDelete.eval(jsonEvent, jPath); Assert."<AssertPlaceHolder>"; }
eval(String jsonEvent, String jPath) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).delete(JsonPath.compile(jPath)).jsonString(); }
[*] target: assertEquals(expectedJsonEvent, actual)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonEvent, actual )
************************************
************************************
[+] input: shouldReturnEmptyCollectionOnEmptyEnvVars() { HashMap<String, String> systemEnvs = new HashMap<>(); Map<String, String> expectedEnvVars = new HashMap<>();  Map<String, String> actualEnvVars = KafkaEnvironmentVariables.parse(systemEnvs);  "<AssertPlaceHolder>"; }
parse(Map<String, String> envVars) { if (envVars == null || envVars.isEmpty()) { return Collections.emptyMap(); } Map<String, String> kafkaEnvVars = envVars.entrySet() .stream() .filter(a -> a.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .collect(Collectors.toMap(e -> parseVarName(e.getKey()), e -> e.getValue())); return kafkaEnvVars; }
[*] target: assertEquals(expectedEnvVars, actualEnvVars)
[-] pred: org. junit. Assert. assertEquals ( expectedEnvVars, actualEnvVars )
************************************
************************************
[+] input: shouldReturnKafkaEnvVarsPositive() { HashMap<String, String> systemEnvs = new HashMap<String, String>() {{ put("PATH", "/usr/local/bin"); put("SHELL", "/usr/local/bin/zsh"); put("source_kafka_consumer_config_fetch_min_bytes", "1"); put("source_kafka_consumer_config_ssl_keystore_location", "/home/user/.ssh/keystore"); put("SOURCE_KAFKA_CONSUMER_CONFIG_ENABLE_AUTO_COMMIT", "false");  }};  Map<String, String> expectedEnvVars = new HashMap<String, String>() {{ put("fetch.min.bytes", "1"); put("ssl.keystore.location", "/home/user/.ssh/keystore"); put("enable.auto.commit", "false"); }};  Map<String, String> actualEnvVars = KafkaEnvironmentVariables.parse(systemEnvs);  "<AssertPlaceHolder>"; }
parse(Map<String, String> envVars) { if (envVars == null || envVars.isEmpty()) { return Collections.emptyMap(); } Map<String, String> kafkaEnvVars = envVars.entrySet() .stream() .filter(a -> a.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .collect(Collectors.toMap(e -> parseVarName(e.getKey()), e -> e.getValue())); return kafkaEnvVars; }
[*] target: assertEquals(expectedEnvVars, actualEnvVars)
[-] pred: org. junit. Assert. assertEquals ( expectedEnvVars, actualEnvVars )
************************************
************************************
[+] input: FilterException { TestBookingLogMessage bookingLogMessage = TestBookingLogMessage.newBuilder().setCustomerId("customerId").build(); TestBookingLogKey bookingLogKey = TestBookingLogKey.newBuilder().build(); Message message = new Message(bookingLogKey.toByteArray(), bookingLogMessage.toByteArray(), "topic1", 0, 100); HashMap<String, String> filterConfigs = new HashMap<>(); filterConfigs.put("FILTER_DATA_SOURCE", "message"); filterConfigs.put("FILTER_JSON_SCHEMA", "{"properties":{"customer_dynamic_surge_enabled":{"const":"true"}}}"); filterConfigs.put("FILTER_SCHEMA_PROTO_CLASS", TestBookingLogMessage.class.getName()); filterConfigs.put("FILTER_ESB_MESSAGE_FORMAT", "PROTOBUF"); FilterConfig bookingConsumerConfig = ConfigFactory.create(FilterConfig.class, filterConfigs); JsonFilter bookingFilter = new JsonFilter(stencilClient, bookingConsumerConfig, firehoseInstrumentation); FilteredMessages expectedMessages = new FilteredMessages(); expectedMessages.addToValidMessages(message); FilteredMessages filteredMessages = bookingFilter.filter(Collections.singletonList(message)); "<AssertPlaceHolder>"; }
filter(List<Message> messages) throws FilterException { FilteredMessages filteredMessages = new FilteredMessages(); for (Message message : messages) { byte[] data = (filterConfig.getFilterDataSource().equals(KEY)) ? message.getLogKey() : message.getLogMessage(); String jsonMessage = deserialize(data); if (evaluate(jsonMessage)) { filteredMessages.addToValidMessages(message); } else { filteredMessages.addToInvalidMessages(message); } } return filteredMessages; }
[*] target: assertEquals(expectedMessages, filteredMessages)
[-] pred: org. junit. Assert. assertEquals ( expectedMessages, filteredMessages )
************************************
************************************
[+] input: containsNotEmptyKey() { JapCache japCache = new JapLocalCache(); boolean containsKey = japCache.containsKey("Key"); Assert."<AssertPlaceHolder>"; }
containsKey(String key) { if (StrUtil.isEmpty(key)) { return false; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); return null != cacheObj && !cacheObj.isExpired(); } finally { readLock.unlock(); } }
[*] target: assertFalse(containsKey)
[-] pred: org. junit. Assert. assertFalse ( containsKey )
************************************
************************************
[+] input: testResponseCodeOk() { Response r = new Response(Collections.emptyMap(), new byte[0], 210); "<AssertPlaceHolder>"; }
isOk() { return statusCode >= 200 && statusCode <= 299; }
[*] target: assertTrue(r.isOk())
[-] pred: org. junit. Assert. assertTrue ( r. isOk() )
************************************
************************************
[+] input: testExists299() { Response r = new Response(Collections.emptyMap(), new byte[0], 299); "<AssertPlaceHolder>"; }
exists() { if (statusCode >= 200 && statusCode <= 299) { return true; } else if (statusCode == HttpURLConnection.HTTP_NOT_FOUND) { return false; } else { throw new ServiceException(statusCode, "call failed"); } }
[*] target: assertTrue(r.exists())
[-] pred: org. junit. Assert. assertTrue ( r. exists() )
************************************
************************************
[+] input: testSaveToStringWithIndent() { YamlConfiguration config = getConfig(); config.options().indent(9);  config.set("section.key", 1);  String result = config.saveToString(); String expected = "section:\n         key: 1\n";  "<AssertPlaceHolder>"; }
saveToString() { yamlOptions.setIndent(options().indent()); yamlOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK); yamlOptions.setAllowUnicode(SYSTEM_UTF); yamlRepresenter.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);  String header = buildHeader(); String dump = yaml.dump(getValues(false));  if (dump.equals(BLANK_CONFIG)) { dump = ""; }  return header + dump; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: shouldNotProcessIfParameterIsEnabled() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.MESSAGE);  simpleRequest = new SimpleRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType); boolean canProcess = simpleRequest.canProcess();  "<AssertPlaceHolder>"; }
canProcess() { boolean isDynamicUrl = httpSinkConfig.getSinkHttpServiceUrl().contains(","); return httpSinkConfig.getSinkHttpParameterSource() == HttpSinkParameterSourceType.DISABLED && !isDynamicUrl; }
[*] target: assertFalse(canProcess)
[-] pred: org. junit. Assert. assertFalse ( canProcess )
************************************
************************************
[+] input: getUserNullStore() { JapUserStore japUserStore = null; JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  JapUser japUser = JapAuthentication.getUser(request, response); Assert."<AssertPlaceHolder>"; }
getUser(JapHttpRequest request, JapHttpResponse response) { if (null == context) { return null; } JapUserStore japUserStore = context.getUserStore(); if (null == japUserStore) { return null; } return japUserStore.get(request, response); }
[*] target: assertNull(japUser)
[-] pred: org. junit. Assert. assertNull ( japUser )
************************************
************************************
[+] input: shouldUseDefaultNanosDuringTransformIfSimpleGroupHasGroupTypeTimestampWithNanosNotInitialized() { Instant currentInstant = Instant.now(); long seconds = currentInstant.getEpochSecond(); Row expectedRow = Row.of(seconds, 0);  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("event_timestamp"); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor);  /* adding both nanos and seconds field to the timestamp schema but initializing only for seconds */ GroupType timestampSchema = org.apache.parquet.schema.Types.optionalGroup() .optional(INT64).named("seconds") .optional(INT32).named("nanos") .named("event_timestamp"); SimpleGroup timestampMessage = new SimpleGroup(timestampSchema); timestampMessage.add("seconds", seconds);  MessageType parquetSchema = buildMessage() .addField(timestampSchema) .named("TestBookingLogMessage"); SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add("event_timestamp", timestampMessage);  Row actualRow = (Row) timestampHandler.transformFromParquet(mainMessage);  "<AssertPlaceHolder>"; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }
[*] target: assertEquals(expectedRow, actualRow)
[-] pred: org. junit. Assert. assertEquals ( expectedRow, actualRow )
************************************
************************************
[+] input: testSuccessFinally() { DBConnection anotherDbConnection = mock(DBConnection.class); when(anotherDbConnection.getDatabaseName()).thenReturn("Another"); correctnessTest = new ComparisonTest( openSearchConnection, new DBConnection[] {otherDbConnection, anotherDbConnection});  DBResult openSearchResult = new DBResult( "OpenSearch", asList(new Type("firstname", "text")), asList(new Row(asList("John")))); DBResult otherDbResult = new DBResult( "Other DB", asList(new Type("firstname", "text")), asList(new Row(asList("JOHN")))); DBResult anotherDbResult = new DBResult( "Another DB", asList(new Type("firstname", "text")), asList(new Row(asList("John")))); when(openSearchConnection.select(anyString())).thenReturn(openSearchResult); when(anotherDbConnection.select(anyString())).thenReturn(anotherDbResult);  TestReport expected = new TestReport(); expected.addTestCase(new SuccessTestCase(1, "SELECT * FROM accounts")); TestReport actual = correctnessTest.verify(querySet("SELECT * FROM accounts")); "<AssertPlaceHolder>"; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format("%s: %s", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testSetMobile() { PhoneNumber phoneNumber = new PhoneNumber(); phoneNumber.setMobile(true); "<AssertPlaceHolder>"; }
isMobile() { return mobile; }
[*] target: assertTrue(phoneNumber.isMobile())
[-] pred: org. junit. Assert. assertTrue ( phoneNumber. isMobile() )
************************************
************************************
[+] input: convertMultiPoint_V1_ShouldConvert() { String wkt = "MULTIPOINT (10 40, 40 30, 20 20, 30 10)"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"MultiPoint", "coordinates": [[10,40],[40,30],[20,20],[30,10]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: encodesValueToBase64() { String actual = message.getSerializedMessage();  String expected = "CgMxMjMSA2FiYxoHZGV0YWlscw==";  "<AssertPlaceHolder>"; }
getSerializedMessage() { return encodedSerializedStringFrom(logMessage); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: createReadDeviceBatchMultiBlocksReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x26, 0x00, 0x0C, 0x00, 0x06, 0x04, 0x00, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, (byte) 0xA8, 0x04, 0x00, 0x00, 0x01, 0x00, (byte) 0xB4, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x90, 0x02, 0x00, (byte) 0x80, 0x00, 0x00, (byte) 0x90, 0x02, 0x00, 0x00, 0x01, 0x00, (byte) 0xA0, 0x03, 0x00 }; List<McDeviceAddress> wordAddresses = new ArrayList<>(); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.D, 0, 4)); wordAddresses.add(new McDeviceAddress(EMcDeviceCode.W, 0x100, 8));  List<McDeviceAddress> bitAddresses = new ArrayList<>(); bitAddresses.add(new McDeviceAddress(EMcDeviceCode.M, 0, 2)); bitAddresses.add(new McDeviceAddress(EMcDeviceCode.M, 128, 2)); bitAddresses.add(new McDeviceAddress(EMcDeviceCode.B, 0x100, 3)); McMessageReq req = McReqBuilder.createReadDeviceBatchMultiBlocksReq(wordAddresses, bitAddresses); byte[] actual = req.toByteArray(); "<AssertPlaceHolder>"; }
createReadDeviceBatchMultiBlocksReq(List<McDeviceAddress> wordAddresses, List<McDeviceAddress> bitAddresses) { McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), MONITORING_TIMER_DEFAULT); return createReadDeviceBatchMultiBlocksReq(EMcSeries.QnA, header, wordAddresses, bitAddresses); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: IOException { String fileName = "download-test1.txt"; String expectContent = "hello, world"; String destFile = "download-test1.txt"; manager.delete(fileName); Appender appender = manager.providerAppender(fileName); appender.begin(); appender.append(expectContent.getBytes(), expectContent.getBytes().length); appender.end(); manager.download(fileName, "."); String actualContent = new String(Files.readAllBytes(Paths.get(destFile))); Assert."<AssertPlaceHolder>"; new File(destFile).deleteOnExit(); }
download(String fileName, String localPath) { boolean success = true; do { try (LindormClient client = getLindormClient()) { String lindormFileName = getLindormFileName(fileName); logger.info("begin to download lindorm file: {} to local path: {}", lindormFileName, localPath); S3Object object = client.getObject(getBucket(), lindormFileName); FileOutputStream fos = new FileOutputStream(new File(localPath, fileName)); S3ObjectInputStream input = object.getObjectContent(); IOUtils.copy(input, fos); } catch (Exception e) { success = false; logger.error("download file {} error, will try again!", fileName, e); try { Thread.sleep(1000); } catch (InterruptedException interruptedException) { logger.error("interruption during sleep", interruptedException); break; } } } while (!success); logger.info("success to download file {} to local", fileName); }
[*] target: assertEquals(expectContent, actualContent)
[-] pred: org. junit. Assert. assertEquals ( expectContent, actualContent )
************************************
************************************
[+] input: shouldHandleTimestampMessagesByReturningNullForNonParseableTimeStampsForTransformForPostProcessor() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName("event_timestamp");  TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor);  Object value = typeHandler.transformFromPostProcessor("2");  "<AssertPlaceHolder>"; }
transformFromPostProcessor(Object field) { return isValid(field) ? field.toString() : null; }
[*] target: assertNull(value)
[-] pred: org. junit. Assert. assertNull ( value )
************************************
************************************
[+] input: shouldNotBeEmptyWhenEsConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, es, null, null);  "<AssertPlaceHolder>"; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }
[*] target: assertFalse(externalSourceConfig.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( externalSourceConfig. isEmpty() )
************************************
************************************
[+] input: Exception { Object payload = Payloads.ROME.getPayload().getPayload(new String[]{"ldap://127.0.0.1:43658/Calc"}); Assert."<AssertPlaceHolder>";; }
getPayload(String[] args) { if (this.args != null) args = this.args; try { JdbcRowSetImpl rs = new JdbcRowSetImpl(); rs.setDataSourceName(args[0]); rs.setMatchColumn("foo"); Reflections.getField(javax.sql.rowset.BaseRowSet.class, "listeners").set(rs, null);  ToStringBean item = new ToStringBean(JdbcRowSetImpl.class, rs); EqualsBean root = new EqualsBean(ToStringBean.class, item);  HashMap s = new HashMap<>(); Reflections.setFieldValue(s, "size", 2); Class<?> nodeC; try { nodeC = Class.forName("java.util.HashMap$Node"); } catch (ClassNotFoundException e) { nodeC = Class.forName("java.util.HashMap$Entry"); } Constructor<?> nodeCons = nodeC .getDeclaredConstructor(int.class, Object.class, Object.class, nodeC); nodeCons.setAccessible(true);  Object tbl = Array.newInstance(nodeC, 2); Array.set(tbl, 0, nodeCons.newInstance(0, root, root, null)); Array.set(tbl, 1, nodeCons.newInstance(0, root, root, null)); Reflections.setFieldValue(s, "table", tbl); return s; } catch (Exception e) { e.printStackTrace(); } return null; }
[*] target: assertNotNull(payload)
[-] pred: org. junit. Assert. assertNotNull ( payload )
************************************
************************************
[+] input: getUTCTotalSecond() { LocalDateTime dateTime = LocalDateTime.of(1970, 1, 1, 0, 0, 3); long second = TimesUtil.getUTCTotalSecond(dateTime); "<AssertPlaceHolder>"; }
getUTCTotalSecond(LocalDateTime dateTime) { Duration between = Duration.between(getUTCOriginDateTime(), dateTime); return between.getSeconds(); }
[*] target: assertEquals(3, second)
[-] pred: org. junit. Assert. assertEquals ( 3, second )
************************************
************************************
[+] input: shouldProcessForParametrizedQuery() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.MESSAGE); when(httpSinkConfig.getSinkHttpParameterPlacement()).thenReturn(HttpSinkParameterPlacementType.QUERY);  parameterizedURIRequest = new ParameterizedUriRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedURIRequest.canProcess(); "<AssertPlaceHolder>"; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.QUERY; }
[*] target: assertTrue(canProcess)
[-] pred: org. junit. Assert. assertTrue ( canProcess )
************************************
************************************
[+] input: convertPoint_NoRedundantSpaces_ShouldConvert() { String wkt = "POINT(12.3 13.3)"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"Point", "coordinates": [12.3,13.3]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: Exception { OneHotEncoderModel model = estimator.fit(trainTable); Tuple2<Integer, Integer> expected = new Tuple2<>(0, 2); Tuple2<Integer, Integer> actual = OneHotEncoderModelData.getModelDataStream(model.getModelData()[0]) .executeAndCollect() .next(); "<AssertPlaceHolder>"; }
fit(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); Preconditions.checkArgument(getHandleInvalid().equals(ERROR_INVALID));  final String[] inputCols = getInputCols();  StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); DataStream<Integer[]> localMaxIndices = tEnv.toDataStream(inputs[0]) .transform( "ExtractInputValueAndFindMaxIndexOperator", ObjectArrayTypeInfo.getInfoFor(BasicTypeInfo.INT_TYPE_INFO), new ExtractInputValueAndFindMaxIndexOperator(inputCols));  DataStream<Tuple2<Integer, Integer>> modelData = localMaxIndices .transform( "GenerateModelDataOperator", TupleTypeInfo.getBasicTupleTypeInfo(Integer.class, Integer.class), new GenerateModelDataOperator(inputCols.length)) .setParallelism(1);  OneHotEncoderModel model = new OneHotEncoderModel().setModelData(tEnv.fromDataStream(modelData)); ParamUtils.updateExistingParams(model, paramMap); return model; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testToString() { String expectedStr = "Breaker(status=CLOSED, lastBreakTimeMillis=-1)"; Breaker breaker = new Breaker();  "<AssertPlaceHolder>"; }
toString() { return "Breaker(" + "status=" + status.get() + ", lastBreakTimeMillis=" + lastBreakTimeMillis.get() + ")"; }
[*] target: assertEquals(expectedStr, breaker.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedStr, breaker. toString() )
************************************
************************************
[+] input: mp4MvexBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x28, 0x6D, 0x76, 0x65, 0x78,  0x00, 0x00, 0x00, 0x20, 0x74, 0x72, 0x65, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, }; Mp4MvexBox box = new Mp4MvexBox(Collections.singletonList(this.trackInfo)); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: testGetChildElementsEmptyDocument() { Element root = XmlUtility.getXmlDocument(EMPTY_XML).getDocumentElement(); List<Element> children = XmlUtility.getChildElements(root, "element"); "<AssertPlaceHolder>"; }
getChildElements(Element parent, String tagName) { final NodeList children = parent.getChildNodes(); List<Element> result = new ArrayList<>(children.getLength()); for (int i = 0; i < children.getLength(); i++) { Node n = children.item(i); if (n.getNodeType() == Node.ELEMENT_NODE && (tagName == null || tagName.equals(n.getNodeName()))) { result.add((Element) n); } } return result; }
[*] target: assertEquals(0, children.size())
[-] pred: org. junit. Assert. assertEquals ( 0, children. size ( ) )
************************************
************************************
[+] input: shouldReturnKafkaEnvVarsNegative() { HashMap<String, String> systemEnvs = new HashMap<String, String>() {{ put("PATH", "/usr/local/bin"); put("SHELL", "/usr/local/bin/zsh"); }};  Map<String, String> expectedEnvVars = new HashMap<>();  Map<String, String> actualEnvVars = KafkaEnvironmentVariables.parse(systemEnvs);  "<AssertPlaceHolder>"; }
parse(Map<String, String> envVars) { if (envVars == null || envVars.isEmpty()) { return Collections.emptyMap(); } Map<String, String> kafkaEnvVars = envVars.entrySet() .stream() .filter(a -> a.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .collect(Collectors.toMap(e -> parseVarName(e.getKey()), e -> e.getValue())); return kafkaEnvVars; }
[*] target: assertEquals(expectedEnvVars, actualEnvVars)
[-] pred: org. junit. Assert. assertEquals ( expectedEnvVars, actualEnvVars )
************************************
************************************
[+] input: testMultiplication() { System.out.println("multiplicacion"); double num1 = 12.0; double num2 = 0.0; Calculadora instance = new Calculadora(); double expResult = 0.0; double result = instance.multiplicacion(num1, num2); "<AssertPlaceHolder>"; }
multiplicacion(double num1, double num2) { return num1 * num2; }
[*] target: assertEquals(expResult, result, 0.0)
[-] pred: org. junit. Assert. assertEquals ( expResult, result, 0.0 )
************************************
************************************
[+] input: selectSingle3() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andIn(MysqlUserEntity::getId, Arrays.asList(1, 1, 1, 1, 1, 1)); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert."<AssertPlaceHolder>"; log.info("mysqlUserEntity : {}", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }
[*] target: assertNotNull(mysqlUserEntity)
[-] pred: org. junit. Assert. assertNotNull ( mysqlUserEntity )
************************************
************************************
[+] input: shouldNeedRotateWhenWriterDataSizeGreaterThanEqualToMaxFileSize() { long dataSize = 258L; LocalFileMetadata metadata = new LocalFileMetadata("/tmp", "/tmp/a/random-file-name-1", 1L, 100L, dataSize); boolean shouldRotate = sizeBasedRotatingPolicy.shouldRotate(metadata); Assert."<AssertPlaceHolder>"; }
shouldRotate(LocalFileMetadata metadata) { return metadata.getSize() >= maxSize; }
[*] target: assertTrue(shouldRotate)
[-] pred: org. junit. Assert. assertTrue ( shouldRotate )
************************************
************************************
[+] input: getShardingColumnName3() { String shardingColumnName = SplitTableUtil.getShardingColumnName("commerce2", "table_engine_test"); Assert."<AssertPlaceHolder>"; }
getShardingColumnName(final String keyspace, final String logicTableName) { return getShardingColumnName(Constant.DEFAULT_SPLIT_TABLE_CONFIG_PATH, keyspace, logicTableName); }
[*] target: assertNull(shardingColumnName)
[-] pred: org. junit. Assert. assertNull ( shardingColumnName )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeDataAndRuleRegexMatch2WithSubjectAndResource() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "25"); subject.put("verify_aal", "2."); subject.put("userId", "123457"); subject.put("verify_userId", "12345[6|7]");  Map<String, String> resource = new HashMap<>(); resource.put("aal", "10"); resource.put("verify_aal", ".0"); resource.put("userId", "1111"); resource.put("verify_userId", "1111"); Context context = new Context<>(subject, resource, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: testDatabaseExists() { boolean exists = rocketMQCatalog.databaseExists("default"); "<AssertPlaceHolder>"; }
databaseExists(String databaseName) throws CatalogException { return getDefaultDatabase().equals(databaseName); }
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
************************************
[+] input: shouldReturnFalseIfRepeatedEnumFieldDescriptorIsPassed() { Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName("test_enums"); EnumHandler enumHandler = new EnumHandler(repeatedEnumFieldDescriptor);  "<AssertPlaceHolder>"; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.ENUM && !fieldDescriptor.isRepeated(); }
[*] target: assertFalse(enumHandler.canHandle())
[-] pred: org. junit. Assert. assertFalse ( enumHandler. canHandle() )
************************************
************************************
[+] input: shouldReturnDefaultTimestampRowDuringTransformIfSimpleGroupDoesNotContainValueForInt64TimestampField() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("event_timestamp"); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named("event_timestamp") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row actualRow = (Row) timestampHandler.transformFromParquet(simpleGroup);  Row expectedRow = Row.of(0L, 0); "<AssertPlaceHolder>"; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }
[*] target: assertEquals(expectedRow, actualRow)
[-] pred: org. junit. Assert. assertEquals ( expectedRow, actualRow )
************************************
************************************
[+] input: shouldNotNeedRotateWhenSizeBelowTheLimit() { long dataSize = 100L; LocalFileMetadata metadata = new LocalFileMetadata("/tmp", "/tmp/a/random-file-name-1", 1L, 100L, dataSize); boolean shouldRotate = sizeBasedRotatingPolicy.shouldRotate(metadata); Assert."<AssertPlaceHolder>"; }
shouldRotate(LocalFileMetadata metadata) { return metadata.getSize() >= maxSize; }
[*] target: assertFalse(shouldRotate)
[-] pred: org. junit. Assert. assertFalse ( shouldRotate )
************************************
************************************
[+] input: getByEmptyKey() { JapCache japCache = new JapLocalCache(); String res = (String) japCache.get(""); Assert."<AssertPlaceHolder>"; }
get(String key) { if (StrUtil.isEmpty(key)) { return null; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); if (null == cacheObj || cacheObj.isExpired()) { return null; } return cacheObj.getData(); } finally { readLock.unlock(); } }
[*] target: assertNull(res)
[-] pred: org. junit. Assert. assertNull ( res )
************************************
************************************
[+] input: testGetJobLog() { when(mockEngineService.runScript(any())).thenReturn(getResponseContent(MOCK_JOB_LOG)); JobLog jobLog = mockJobService.getJobLog("admin", mockJobId, -1L); Assert."<AssertPlaceHolder>"; }
getJobLog(String user, String jobId, Long offset) { String groupId = getGroupOrJobId(jobId); String response = null; try { response = engineService.runScript(new EngineService .RunScriptParams() .withOwner(user) .withSql(String.format("load _mlsql_.`log/%d` where filePath="engine_log" as output;", offset)) .withAsync("false") .with("sessionPerRequest", "true") ); } catch (Exception e) { log.error(ExceptionUtils.getRootCause(e)); } if (StringUtils.isEmpty(response) || response.equals("[]")) { return null; }  List<JobLog> resultsMap = JacksonUtils.readJsonArray(response, JobLog.class); JobLog jobLog = Objects.requireNonNull(resultsMap).get(0); if (jobLog.getValue() != null) { jobLog.setValue( jobLog.getValue().stream().filter( s -> s.contains(String.format("[owner] [%s] [groupId]", user)) ).filter(s-> !s.contains("run command as ShowCommand.`jobs/v2")).map(s -> { String[] arr = s.split("__MMMMMM__", 2); if (arr.length == 2) { return arr[1]; } else { return s; } }).collect(Collectors.toList()) ); } else { jobLog.setValue(Lists.newArrayList()); } return jobLog; }
[*] target: assertNotNull(jobLog)
[-] pred: org. junit. Assert. assertNotNull ( jobLog )
************************************
************************************
[+] input: rtspPauseRequestTest() { String expect = "PAUSE rtsp://10.3.8.202:554/ RTSP/1.0\r\n" + "CSeq: 0\r\n" + "Authorization: Digest username="admin", realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", uri="rtsp://10.3.8.202:554", response="56d55b92e8b41aa6cc1a68a5c2e2de15"\r\n" + "User-Agent: IOT-COMMUNICATION\r\n" + "Session: 1273222592\r\n" + "\r\n"; URI uri = URI.create("rtsp://10.3.8.202:554/"); RtspPauseRequest request = new RtspPauseRequest(uri, "1273222592", this.authenticator); request.setCSeq(0); String actual = request.toObjectString(); "<AssertPlaceHolder>"; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testToString() { String expectedStr = "EndpointConfigEntry(" + "productCode=p1" + ", regionCode=r1" + ", domains=[a.b.c, x.y.z]" + ")";  EndpointConfigEntry entry = new EndpointConfigEntry(productCode, regionCode, domains);  "<AssertPlaceHolder>"; }
toString() { return "EndpointConfigEntry(" + "productCode=" + productCode + ", regionCode=" + regionCode + ", domains=" + domains + ")"; }
[*] target: assertEquals(expectedStr, entry.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedStr, entry. toString ( ) )
************************************
************************************
[+] input: mp4TrafBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x6A, 0x74, 0x72, 0x61, 0x66,  0x00, 0x00, 0x00, 0x10, 0x74, 0x66, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,  0x00, 0x00, 0x00, 0x10, 0x74, 0x66, 0x64, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x34, 0x74, 0x72, 0x75, 0x6E, 0x00, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, (byte) 0x8A, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x00, 0x15, 0x57, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x00, 0x13, (byte) 0x86, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x0E, 0x73, 0x64, 0x74, 0x70, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10 }; Mp4TrafBox box = new Mp4TrafBox(0, this.trackInfo); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: shouldNotBeEmptyWhenGrpcAndHttpConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, null, null, grpc);  "<AssertPlaceHolder>"; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }
[*] target: assertFalse(externalSourceConfig.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( externalSourceConfig. isEmpty() )
************************************
************************************
[+] input: shouldReturnFalseIfRepeatedEnumFieldDescriptorIsPassed() { Descriptors.FieldDescriptor repeatedEnumFieldDescriptor = TestRepeatedEnumMessage.getDescriptor().findFieldByName("test_enums"); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedEnumFieldDescriptor);  "<AssertPlaceHolder>"; }
canHandle() { return fieldDescriptor.isRepeated() && fieldDescriptor.getJavaType() != MESSAGE && fieldDescriptor.getJavaType() != ENUM; }
[*] target: assertFalse(repeatedPrimitiveHandler.canHandle())
[-] pred: org. junit. Assert. assertFalse ( repeatedPrimitiveHandler. canHandle() )
************************************
************************************
[+] input: shouldNotFilterUnfinishedFuture() { Future<Long> future = Mockito.mock(Future.class); LocalFileMetadata localFileMetadata = Mockito.mock(LocalFileMetadata.class); FirehoseInstrumentation firehoseInstrumentation = Mockito.mock(FirehoseInstrumentation.class); BlobStorageWriterFutureHandler handler = new BlobStorageWriterFutureHandler(future, localFileMetadata, firehoseInstrumentation); Mockito.when(future.isDone()).thenReturn(false); Assert."<AssertPlaceHolder>"; }
isFinished() { if (!future.isDone()) { return false; } try { long totalTime = future.get(); captureFileUploadSuccessMetric(totalTime); return true; } catch (InterruptedException e) { captureUploadFailedMetric(e); throw new BlobStorageFailedException(e); } catch (ExecutionException e) { captureUploadFailedMetric(e.getCause()); throw new BlobStorageFailedException(e.getCause()); } }
[*] target: assertFalse(handler.isFinished())
[-] pred: org. junit. Assert. assertFalse ( handler. isFinished() )
************************************
************************************
[+] input: shouldNotProcessForDyanamicURL() { when(httpSinkConfig.getSinkHttpServiceUrl()).thenReturn("http://127.0.0.1:1080/api,%s");  simpleRequest = new SimpleRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType); boolean canProcess = simpleRequest.canProcess();  "<AssertPlaceHolder>"; }
canProcess() { boolean isDynamicUrl = httpSinkConfig.getSinkHttpServiceUrl().contains(","); return httpSinkConfig.getSinkHttpParameterSource() == HttpSinkParameterSourceType.DISABLED && !isDynamicUrl; }
[*] target: assertFalse(canProcess)
[-] pred: org. junit. Assert. assertFalse ( canProcess )
************************************
************************************
[+] input: createResponse() { String expect = "Digest username="Mufasa", realm="testrealm@host.com", nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093", uri="/dir/index.html", response="6629fae49393a05397450978507c4ef1", qop=auth, nc=00000001, cnonce="0a4f113b""; UsernamePasswordCredential credential = new UsernamePasswordCredential("Mufasa", "Circle Of Life"); DigestAuthenticator authenticator = new DigestAuthenticator(credential); authenticator.addServerInfoByString("Digest realm="testrealm@host.com", qop="auth", nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093""); authenticator.addClientInfo("/dir/index.html", "GET", "0a4f113b"); String actual = authenticator.createResponse(); "<AssertPlaceHolder>"; }
createResponse() { if (this.realm == null || this.realm.equals("")) { throw new AuthenticationException("realm is empty"); } if (this.nonce == null || this.nonce.equals("")) { throw new AuthenticationException("nonce is empty"); } if (this.uri == null || this.uri.equals("")) { throw new AuthenticationException("uri is empty"); } if (this.method == null || this.method.equals("")) { throw new AuthenticationException("method is empty"); } StringBuilder sb = new StringBuilder(); sb.append(DIGEST_NAME).append(" ") .append("username="").append(this.credential.getUsername()).append("", ") .append("realm="").append(this.realm).append("", ") .append("nonce="").append(this.nonce).append("", ") .append("uri="").append(this.uri).append("", "); if (this.qop == null || this.qop.equals("")) { sb.append("response="").append(this.calculateResponseString()).append("""); } else { sb.append("response="").append(this.calculateResponseString()).append("", ") .append("qop=").append(this.qop).append(", ") .append("nc=").append(String.format("%08X", this.nc)).append(", ") .append("cnonce="").append(this.cnonce).append("""); } return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testRetainWithObjectField() { SearchHit hit = new SearchHit(1); hit.sourceRef(new BytesArray("{"a.id": {"serial": 3}}")); SearchHitRow row = new SearchHitRow(hit, ""); row.retain(ImmutableMap.of("a.id.serial", ""));  SearchHit expected = new SearchHit(1); expected.sourceRef(new BytesArray("{"a.id": {"serial": 3}}")); "<AssertPlaceHolder>"; }
data() { return hit; }
[*] target: assertEquals(expected, row.data())
[-] pred: org. junit. Assert. assertEquals ( expected, row. data() )
************************************
************************************
[+] input: testComment2() { XmlElement x = XmlElement.parse("<a><b>boo</b><!-- hi there --></a>"); "<AssertPlaceHolder>"; }
countChildren() { return children.size(); }
[*] target: assertEquals(1, x.countChildren())
[-] pred: org. junit. Assert. assertEquals ( 1, x. countChildren() )
************************************
************************************
[+] input: IOException { TestingConfig.baseDir = "bin/test"; TestingConfig test = new TestingConfig(); if (test.exists()) test.getFile().delete();  test.writeAll(); "<AssertPlaceHolder>"; }
exists() { if (filename() != null && folder() != null) { return conf.exists(); } else return false; }
[*] target: assertTrue(test.exists())
[-] pred: org. junit. Assert. assertTrue ( test. exists() )
************************************
************************************
[+] input: getByNotEmptyKey() { JapCache japCache = new JapLocalCache(); String res = (String) japCache.get("ke1y"); System.out.println(res); Assert."<AssertPlaceHolder>"; }
get(String key) { if (StrUtil.isEmpty(key)) { return null; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); if (null == cacheObj || cacheObj.isExpired()) { return null; } return cacheObj.getData(); } finally { readLock.unlock(); } }
[*] target: assertNull(res)
[-] pred: org. junit. Assert. assertNull ( res )
************************************
************************************
[+] input: testConsume() { FuzzedDataProvider data = CannedFuzzedDataProvider.create( Arrays.asList( (byte) 1 /* do not return null */, 0 /* first class on the classpath */, (byte) 1 /* do not return null */, 0 /* first constructor */)); ImplementedInterface result = Autofuzz.consume(data, ImplementedInterface.class); "<AssertPlaceHolder>"; }
consume(FuzzedDataProvider data, Class<T> type) { try { return (T) CONSUME.invokeExact(data, type); } catch (AutofuzzConstructionException ignored) { return null; } catch (Throwable t) { rethrowUnchecked(t); // Not reached. return null; } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testRunAnalyze() { String resp = engineService.runAnalyze(new EngineService.RunScriptParams() .withSql("load Everything.`` as Table;").withAsync("false")); Assert."<AssertPlaceHolder>"; }
withAsync(String async) { params.put("async", async); return this; }
[*] target: assertNotNull(resp)
[-] pred: org. junit. Assert. assertNotNull ( resp )
************************************
************************************
[+] input: SQLException { Query.Field[] fields = TestResult.makeTestFields("col|count(*)", "varbinary|decimal"); VtResultSet resultSet = TestResult.makeTestResult(fields, "a|1", "a|1", "b|2", "c|3", "c|4"); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(resultSet));  AbstractAggregateGen4.AggregateParams aggr = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateSum, 1); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(0); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(false, Lists.newArrayList(aggr), false, 0, Lists.newArrayList(groupByParams), null, fp);  VtResultSet result = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList();  VtResultSet wantResult = TestResult.makeTestResult(fields, "a|2", "b|2", "c|7"); Assert."<AssertPlaceHolder>"; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }
[*] target: assertEquals(wantResult, result)
[-] pred: org. junit. Assert. assertEquals ( wantResult, result )
************************************
************************************
[+] input: shouldBeEmptyWhenNoneOfTheConfigsExist() { defaultPostProcessorConfig = new PostProcessorConfig(null, null, null);  "<AssertPlaceHolder>"; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }
[*] target: assertTrue(defaultPostProcessorConfig.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( defaultPostProcessorConfig. isEmpty() )
************************************
************************************
[+] input: getShardingColumnName2() { String shardingColumnName = SplitTableUtil.getShardingColumnName("commerce", "table_engine_test3"); Assert."<AssertPlaceHolder>"; }
getShardingColumnName(final String keyspace, final String logicTableName) { return getShardingColumnName(Constant.DEFAULT_SPLIT_TABLE_CONFIG_PATH, keyspace, logicTableName); }
[*] target: assertNull(shardingColumnName)
[-] pred: org. junit. Assert. assertNull ( shardingColumnName )
************************************
************************************
[+] input: Exception { boolean error = false; try { new ExcludeFilter("*").invoke(null, null); } catch (Exception e) { error = e instanceof UnsupportedOperationException; } Assert."<AssertPlaceHolder>"; }
invoke(FilterInvoker invoker, SofaRequest request) throws SofaRpcException { throw new UnsupportedOperationException(); }
[*] target: assertTrue(error)
[-] pred: org. junit. Assert. assertTrue ( error )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeDataAndRuleRegexMisMatch2WithSubjectAndResourceAndActionAndEnvironment() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "25"); subject.put("verify_aal", "2."); subject.put("userId", "123457"); subject.put("verify_userId", "12345[6|7]");  Map<String, String> resource = new HashMap<>(); resource.put("aal", "10"); resource.put("verify_aal", ".0"); resource.put("userId", "1111"); resource.put("verify_userId", "1111");  Map<String, String> action = new HashMap<>(); resource.put("aal", "abcd"); resource.put("verify_aal", "[a][b][c][d]"); resource.put("userId", "1111"); resource.put("verify_userId", "1111");  Map<String, String> environment = new HashMap<>(); resource.put("aal", "abcd"); resource.put("verify_aal", "[a-z]*"); resource.put("userId", "1111"); resource.put("verify_userId", "111"); Context context = new Context<>(subject, resource, action, environment, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertFalse(flag)
[-] pred: org. junit. Assert. assertFalse ( flag )
************************************
************************************
[+] input: Exception { String xml = "<?xml version="1.0" encoding="UTF-8"?>\n" + "<log>\n" + "    <entry id="1">\n" + "        <message>Application started</message>\n" + "    </entry>\n" + "    <entry id="2">\n" + "        <message>Application ended</message>\n" + "    </entry>\n" + "</log>";  Collection<Integer> ids = parser.getIdsByMessage(xml, "Application stopped");  "<AssertPlaceHolder>"; }
getIdsByMessage(String xmlString, String message) throws Exception { DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); ByteArrayInputStream inputStream = new ByteArrayInputStream(xmlString.getBytes()); Document document = documentBuilder.parse(inputStream);  List<Integer> result = new ArrayList<>(); NodeList elements = document.getElementsByTagName(MESSAGE_TAG); for (int i = 0; i < elements.getLength(); i++) { Node item = elements.item(i); if (message.equals(item.getTextContent())) { NamedNodeMap attributes = item.getParentNode().getAttributes(); result.add(Integer.valueOf(attributes.getNamedItem(ID_ATTRIBUTE).getTextContent())); } } return result; }
[*] target: assertTrue(ids.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( ids. isEmpty ( ) )
************************************
************************************
[+] input: shouldReturnParsedValueForTransformFromParquet() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName("log_key"); String testString = "test-string"; ByteString expectedByteString = ByteString.copyFrom(testString.getBytes()); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named("log_key") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add("log_key", Binary.fromConstantByteArray(expectedByteString.toByteArray())); PrimitiveTypeHandler primitiveTypeHandler = new PrimitiveTypeHandler(fieldDescriptor);  ByteString actualByteString = (ByteString) primitiveTypeHandler.transformFromParquet(simpleGroup);  "<AssertPlaceHolder>"; }
transformFromParquet(SimpleGroup simpleGroup) { PrimitiveHandler primitiveHandler = PrimitiveHandlerFactory.getTypeHandler(fieldDescriptor); return primitiveHandler.parseSimpleGroup(simpleGroup); }
[*] target: assertEquals(expectedByteString, actualByteString)
[-] pred: org. junit. Assert. assertEquals ( expectedByteString, actualByteString )
************************************
************************************
[+] input: testUrlSafeEncryptDecrypt() { char[] password = "insecure".toCharArray(); int keyLength = 128;  Crypter crypter = BEANS.get(Crypter.class).init(password, keyLength); String clearTextData = "lorem ipsum dolor"; String encryptedData = crypter.encryptUrlSafe(clearTextData); String decryptedData = crypter.decryptUrlSafe(encryptedData); "<AssertPlaceHolder>"; }
decryptUrlSafe(String encryptedData) { return decrypt(encryptedData, true); }
[*] target: assertEquals(clearTextData, decryptedData)
[-] pred: org. junit. Assert. assertEquals ( clearTextData, decryptedData )
************************************
************************************
[+] input: isCallbackTokenResponseType() { boolean res = Oauth2Util.isCallback(request, new OAuthConfig() .setResponseType(Oauth2ResponseType.TOKEN)); Assert."<AssertPlaceHolder>"; }
isCallback(JapHttpRequest request, OAuthConfig oAuthConfig) { if (oAuthConfig.getResponseType() == Oauth2ResponseType.CODE) { String code = request.getParameter("code"); return !StrUtil.isEmpty(code); } else if (oAuthConfig.getResponseType() == Oauth2ResponseType.TOKEN) { String accessToken = request.getParameter("access_token"); return !StrUtil.isEmpty(accessToken); } return false; }
[*] target: assertFalse(res)
[-] pred: org. junit. Assert. assertFalse ( res )
************************************
************************************
[+] input: testSchedule() { Mockito.when(nodeClient.threadPool()).thenReturn(threadPool);  Mockito.doAnswer( invocation -> { Runnable task = invocation.getArgument(0); task.run(); return null; }) .when(threadPool) .schedule(ArgumentMatchers.any(), ArgumentMatchers.any(), ArgumentMatchers.any()); AtomicBoolean isRun = new AtomicBoolean(false); Scheduler.schedule(nodeClient, () -> isRun.set(true)); Assert."<AssertPlaceHolder>"; }
schedule(NodeClient client, Runnable task) { ThreadPool threadPool = client.threadPool(); threadPool.schedule(withCurrentContext(task), new TimeValue(0), SQL_WORKER_THREAD_POOL_NAME); }
[*] target: assertTrue(isRun.get())
[-] pred: org. junit. Assert. assertTrue ( isRun. get ( ) )
************************************
************************************
[+] input: testEmptyChild() { final ChildPredicate predicate = ChildPredicate.empty(); final KDLNode node = KDLNode.builder().setIdentifier("node").setChild(KDLDocument.empty()).build();  "<AssertPlaceHolder>"; }
test(KDLNode node) { if (!search.isPresent()) { return !node.getChild().isPresent() || node.getChild().get().getNodes().isEmpty(); }  return node.getChild().map(ch -> search.get().anyMatch(ch)).orElse(false); }
[*] target: assertTrue(predicate.test(node))
[-] pred: org. junit. Assert. assertTrue ( predicate. test ( node ) )
************************************
************************************
[+] input: test_scanParameterizedType_2() { Map<String, Type> m = ReflectUtil.scanParameterizedType(TestSubClass1.class, CommonInterface.class); Assert."<AssertPlaceHolder>"; }
scanParameterizedType(Type from, Class to) { Map<Type, Map<String, Type>> v = visit(from, null); return v.get(to); }
[*] target: assertNull(m)
[-] pred: org. junit. Assert. assertNull ( m )
************************************
************************************
[+] input: convertPoint_RoundNumbers_ShouldConvert() { String wkt = "POINT(12 13)"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"Point", "coordinates": [12,13]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: Exception { RetryActionWithOneParam<String, R> retryActionWithOneParam = new RetryActionWithOneParam<>( "print", 3, "a" ); R result = retryActionWithOneParam.action( a -> { throw new CannotAcquireLockException("throw dae"); } ); Assert."<AssertPlaceHolder>"; }
action(Function<P, R> func) { int times = 0; do { times++; try { return func.apply(param); } catch (DataAccessException ex) { log.warn("{} arg0[{}] in redis happen DataAccessException, times[{}]", actionName, GsonUtils.toJsonString(param), times, ex ); } catch (Exception ex) { log.error("{} arg0[{}] in redis fail.", actionName, GsonUtils.toJsonString(param), ex); break; } } while (times < retryTimes); return null; }
[*] target: assertEquals(null, result)
[-] pred: org. junit. Assert. assertEquals ( null, result )
************************************
************************************
[+] input: mp4HdlrBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x2D, 0x68, 0x64, 0x6C, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x69, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x00, }; Mp4HdlrBox box = new Mp4HdlrBox(this.trackInfo); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: testCheckAndSet_EnableCaching_IfModifiedSince_NotModified() { Mockito.when(req.getPathInfo()).thenReturn("/"); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(null); Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(1000000L);  BinaryResource res = BinaryResources.create() .withFilename("a.html") .withContent("<html></html>".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModified(900000L) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey("/"), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert."<AssertPlaceHolder>";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute("jakarta.servlet.forward.path_info"); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, "private, max-age=0, must-revalidate"); Mockito.verify(resp, ONCE).setStatus(HttpServletResponse.SC_NOT_MODIFIED); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // "private" //   Only browsers may cache this resource. // "max-age" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because "must-revalidate" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, "private, max-age=" + maxAge + ", s-maxage=" + maxAge); } else { // "private" //   Only browsers may cache this resource. // "must-revalidate" //   A cache HAS TO check with the server before using stale resources. // "max-age=0" //   A resource will become stale immediately (after 0 seconds). // Note: "max-age=0, must-revalidate" would be the same as "no-cache" resp.setHeader(CACHE_CONTROL, "private, max-age=0, must-revalidate"); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-None-Match/Etag): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-Modified-Since): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
************************************
************************************
[+] input: testRequestAgain() {  RandomManager manager = new RandomManager(300); manager.getRandom("test"); boolean thrown = false; try { manager.getRandom("test"); } catch (IllegalArgumentException e) { thrown = true; } "<AssertPlaceHolder>";  }
getRandom(String key) {  // Keys are issued typically once if (issuedKeys.contains(key)) { throw new IllegalArgumentException("Unlikely wanted to ask for the same key twice in the same runtime."); } issuedKeys.add(key);  // Generate issued seed long issuedSeed = 997 * universalSeed ^ 991 * key.hashCode();  // Prevent that by chance it is a duplicate (safeguard) if (issuedSeeds.contains(issuedSeed)) { throw new IllegalArgumentException("Likely undesirable: duplicate seed created from two different keys."); } issuedSeeds.add(issuedSeed);  // Create independent random number generator issuedSeeds.add(issuedSeed); return new Random(issuedSeed);  }
[*] target: assertTrue(thrown)
[-] pred: org. junit. Assert. assertTrue ( thrown )
************************************
************************************
[+] input: shouldMakeUpperCaseForKeywords() { //given String expectedString = "SELECT" + lineBreak + "\t*" + lineBreak + "FROM" + lineBreak + "\tmytable;"; String inputString = "select * from mytable;";  //when String formattedString = formatter.format(inputString, configuration);  //then "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, formattedString)
[-] pred: org. junit. Assert. assertEquals ( expectedString, formattedString )
************************************
************************************
[+] input: shouldDoDefaultFormatForCreateStatementWhenIndentSubstatementsInParenthesesOn() { //given String inputString = "CREATE TABLE Persons (PersonID int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255));"; String expectedString = "CREATE TABLE Persons (" + lineBreak + "\tPersonID int," + lineBreak + "\tLastName varchar(255)," + lineBreak + "\tFirstName varchar(255)," + lineBreak + "\tAddress varchar(255)," + lineBreak + "\tCity varchar(255)" + lineBreak + ");";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET))).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, formattedString)
[-] pred: org. junit. Assert. assertEquals ( expectedString, formattedString )
************************************
************************************
[+] input: shouldFetchValueForFieldForFieldDescriptorOfTypeLong() { long actualValue = 2L;  Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName("s2_id"); LongHandler longHandler = new LongHandler(fieldDescriptor); Object value = longHandler.parseObject(actualValue);  "<AssertPlaceHolder>"; }
parseObject(Object field) { return Long.parseLong(getValueOrDefault(field, "0")); }
[*] target: assertEquals(actualValue, value)
[-] pred: org. junit. Assert. assertEquals ( actualValue, value )
************************************
************************************
[+] input: shouldNotProcessIfParameterPlacementDisabled() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.DISABLED);  parameterizedHeaderRequest = new ParameterizedHeaderRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedHeaderRequest.canProcess();  "<AssertPlaceHolder>"; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.HEADER; }
[*] target: assertFalse(canProcess)
[-] pred: org. junit. Assert. assertFalse ( canProcess )
************************************
************************************
[+] input: shouldFetchParsedValueForFieldOfTypeBoolInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("customer_dynamic_surge_enabled"); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BOOLEAN).named("customer_dynamic_surge_enabled") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add("customer_dynamic_surge_enabled", true);  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); Object actualValue = booleanHandler.parseSimpleGroup(simpleGroup);  "<AssertPlaceHolder>"; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getBoolean(fieldName, 0); } else { /* return default value */ return false; } }
[*] target: assertEquals(true, actualValue)
[-] pred: org. junit. Assert. assertEquals ( true, actualValue )
************************************
************************************
[+] input: testNull() { Append a = new Append(); "<AssertPlaceHolder>"; }
convert(Object sourceValue) throws ConversionException { if (sourceValue == null) { return null; } String string = ToStringConverter.convert(sourceValue, null); return string + suffix; }
[*] target: assertNull(a.convert(null))
[-] pred: org. junit. Assert. assertNull ( a. convert ( null ) )
************************************
************************************
[+] input: createWriteDeviceBatchInWordReq() { byte[] expect = new byte[]{ 0x50, 0x00, 0x00, (byte) 0xFF, (byte) 0xFF, 0x03, 0x00, 0x12, 0x00, 0x0C, 0x00, 0x01, 0x14, 0x00, 0x00, 0x58, 0x1B, 0x00, (byte) 0xA8, 0x03, 0x00, (byte) 0x95, 0x19, 0x02, 0x12, 0x30, 0x11 }; byte[] data = new byte[]{(byte) 0x95, 0x19, 0x02, 0x12, 0x30, 0x11}; McDeviceContent deviceAddress = new McDeviceContent(EMcDeviceCode.D, 7000, 3, data); McMessageReq req = McReqBuilder.createWriteDeviceBatchInWordReq(deviceAddress); byte[] actual = req.toByteArray(); "<AssertPlaceHolder>"; }
createWriteDeviceBatchInWordReq(McDeviceContent deviceContent) { McHeaderReq header = McHeaderReq.createByFrameType(EMcFrameType.FRAME_3E, McFrame4E3EAccessRoute.createDefault(), MONITORING_TIMER_DEFAULT); return createWriteDeviceBatchInWordReq(EMcSeries.QnA, header, deviceContent); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: shouldNotBeEmptyWhenHttpConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, null, null, null);  "<AssertPlaceHolder>"; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }
[*] target: assertFalse(externalSourceConfig.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( externalSourceConfig. isEmpty() )
************************************
************************************
[+] input: generateAuthorizationCodeResponseHasCache() { this.initParam(); String code = oauth2Service.createAuthorizationCode(idsRequestParam, new UserInfo(), 100000L); idsRequestParam.setCode(code); IdsResponse<String, Object> response = idsTokenProvider.generateAuthorizationCodeResponse(idsRequestParam, request); System.out.println(response); Assert."<AssertPlaceHolder>"; }
generateAuthorizationCodeResponse(IdsRequestParam param, JapHttpRequest request) { AuthCode codeInfo = oauth2Service.validateAndGetAuthrizationCode(param.getGrantType(), param.getCode());  String scope = codeInfo.getScope(); UserInfo userInfo = codeInfo.getUser(); String nonce = codeInfo.getNonce();  ClientDetail clientDetail = JapIds.getContext().getClientDetailService().getByClientId(param.getClientId());  OauthUtil.validClientDetail(clientDetail); OauthUtil.validateGrantType(param.getGrantType(), clientDetail.getGrantTypes(), GrantType.AUTHORIZATION_CODE); OauthUtil.validateSecret(param, clientDetail, oauth2Service); OauthUtil.validateRedirectUri(param.getRedirectUri(), clientDetail);  oauth2Service.invalidateCode(param.getCode());  long expiresIn = OauthUtil.getAccessTokenExpiresIn(clientDetail.getAccessTokenExpiresIn());  AccessToken accessToken = TokenUtil.createAccessToken(userInfo, clientDetail, param.getGrantType(), scope, nonce, EndpointUtil.getIssuer(request)); IdsResponse<String, Object> response = new IdsResponse<String, Object>() .add(IdsConsts.ACCESS_TOKEN, accessToken.getAccessToken()) .add(IdsConsts.REFRESH_TOKEN, accessToken.getRefreshToken()) .add(IdsConsts.EXPIRES_IN, expiresIn) .add(IdsConsts.TOKEN_TYPE, IdsConsts.TOKEN_TYPE_BEARER) .add(IdsConsts.SCOPE, scope); if (OauthUtil.isOidcProtocol(scope)) { response.add(IdsConsts.ID_TOKEN, TokenUtil.createIdToken(clientDetail, userInfo, nonce, EndpointUtil.getIssuer(request))); } return response; }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: shouldHaveError() { ValidException validException = new ValidException(); "<AssertPlaceHolder>"; }
hasException() { return true; }
[*] target: assertTrue(validException.hasException())
[-] pred: org. junit. Assert. assertTrue ( validException. hasException() )
************************************
************************************
[+] input: toByteArray1() { ByteArraySerializer serializer = ByteArraySerializer.newInstance(); byte[] expect = new byte[]{(byte) 0x01, // 0, 25689 (byte) 0x59, (byte) 0x64, (byte) 0x00, (byte) 0x00, // 523975585 (byte) 0xA1, (byte) 0x3B, (byte) 0x3B, (byte) 0x1F, (byte) 0xA1, (byte) 0x3B, (byte) 0x3B, (byte) 0x1F, // 33.16f, -15.62f (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xD7, (byte) 0xA3, (byte) 0x04, (byte) 0x42, // 156665.35455556 (byte) 0xB7, (byte) 0x39, (byte) 0x21, (byte) 0xD6, (byte) 0xCA, (byte) 0x1F, (byte) 0x03, (byte) 0x41, // -56516.66664 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, // 23A (byte) 0x32, (byte) 0x33, (byte) 0x41};  ByteArrayLittleEndianBean bean = serializer.toObject(ByteArrayLittleEndianBean.class, expect); byte[] actual = serializer.toByteArray(bean); "<AssertPlaceHolder>"; }
toByteArray(final T targetBean) { try { // 组装数据，同时计算最大的字节长度 int buffSize = 0; List<ByteArrayParseData> parseDataList = new ArrayList<>(); for (final Field field : targetBean.getClass().getDeclaredFields()) { final ByteArrayVariable variable = field.getAnnotation(ByteArrayVariable.class); if (variable == null) { continue; } ByteArrayParameter parameter = new ByteArrayParameter(variable.byteOffset(), variable.bitOffset(), variable.count(), variable.type(), variable.littleEndian(), variable.format()); this.checkByteArrayVariable(parameter); parseDataList.add(new ByteArrayParseData(variable, field)); int maxPos = variable.byteOffset() + variable.count() * variable.type().getByteLength(); if (maxPos > buffSize) { buffSize = maxPos; } } if (buffSize == 0 || parseDataList.isEmpty()) { return new byte[0]; } // 填充字节数组的内容 ByteWriteBuff buff = ByteWriteBuff.newInstance(buffSize); for (ByteArrayParseData item : parseDataList) { item.getField().setAccessible(true); Object data = item.getField().get(targetBean); if (data == null) { continue; } if (item.getVariable().count() == 1) { this.fillOneData(item.getVariable(), data, buff, 0); } else { this.fillListData(item.getVariable(), data, buff); } } return buff.getData(); } catch (Exception e) { throw new ByteArrayParseException("parsing to object error, cause:" + e.getMessage(), e); } }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: testSetState() { City city = new City(new State(), "Name", "Addition", new String[] {"foo", "foo", "foo"}, "Area Code"); city.setState(new State()); "<AssertPlaceHolder>"; }
getCountry() { return (state != null ? state.getCountry() : null); }
[*] target: assertNull(city.getCountry())
[-] pred: org. junit. Assert. assertNull ( city. getCountry() )
************************************
************************************
[+] input: testToString() { ResultResponse<String> response = new ResultResponse<>(2, "msg-2", "result-2");  TestResponseForString superResponse = new TestResponseForString(); superResponse.setCode(response.getCode()); superResponse.setMsg(response.getMsg());  String expectedStr = "ResultResponse(" + "super=" + superResponse + ", result=result-2)";  "<AssertPlaceHolder>"; }
toString() { return "ResultResponse(" + "super=" + super.toString() + ", result=" + result + ")"; }
[*] target: assertEquals(expectedStr, response.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedStr, response. toString ( ) )
************************************
************************************
[+] input: convertMultiLineString_NoRedundantSpaces_ShouldConvert() { String wkt = "MULTILINESTRING ((10 10, 20 20, 10 40),(40 40, 30 30, 40 20, 30 10))"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"MultiLineString", "coordinates":" + " [[[10,10],[20,20],[10,40]],[[40,40],[30,30],[40,20],[30,10]]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: testGetLastEntryEmpty() { FileEntrySequence sequence = new FileEntrySequence(entriesFile, entryIndexFile, 1); Assert."<AssertPlaceHolder>"; }
getLastEntry() { if (isEmpty()) { return null; } if (!pendingEntries.isEmpty()) { return pendingEntries.getLast(); } assert !entryIndexFile.isEmpty(); return getEntryInFile(entryIndexFile.getMaxEntryIndex()); }
[*] target: assertNull(sequence.getLastEntry())
[-] pred: org. junit. Assert. assertNull ( sequence. getLastEntry() )
************************************
************************************
[+] input: testReadBytesLengthToBig() { byte[] data = new byte[]{0, 1, 2, 3}; byte[] actual = IOUtility.readBytes(newInputStream(data), 10); "<AssertPlaceHolder>"; }
readBytes(InputStream in, int len) { if (len >= 0) { try { byte[] buf = new byte[len]; int count = 0; while (count < len) { int read = in.read(buf, count, len - count); if (read < 0) { return Arrays.copyOf(buf, count); } count += read; } return buf; } catch (IOException e) { throw new ProcessingException("input: " + in, e); } } else { try (ByteArrayOutputStream buffer = new ByteArrayOutputStream()) { writeFromToStream(buffer, in); return buffer.toByteArray(); } catch (IOException e) { throw new ProcessingException("input: " + in, e); } } }
[*] target: assertArrayEquals(data, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( data, actual )
************************************
************************************
[+] input: testUnSubscribe() { UnSubscribeServiceRequest request = new UnSubscribeServiceRequest(); request.setServiceName("com.alipay.rpc.common.service.facade.pb.SampleServicePb:1.0@DEFAULT"); boolean result = meshApiClient.unSubscribeService(request); Assert."<AssertPlaceHolder>"; }
unSubscribeService(UnSubscribeServiceRequest request) { final String json = JSON.toJSONString(request);  String result = httpPost(MeshEndpoint.UN_SUBCRIBE, json);  if (!StringUtils.equals(result, errorMessage)) { final UnSubscribeServiceResult parse = JSON.parseObject(result, UnSubscribeServiceResult.class); if (parse.isSuccess()) { return true; } return false; } else { return false; } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: SQLException { addUniqueKeys("order_number"); Message message = new Message("key".getBytes(), "msg".getBytes(), "topic1", 0, 100); QueryTemplate queryTemplate = new QueryTemplate(jdbcSinkConfig, protoToFieldMapper); String actualSql = queryTemplate.toQueryString(message);  String expectedSql = "INSERT INTO table ( feedback_rating,event_timestamp,order_number ) values ( '5', 'ts1', 'order_1' ) ON CONFLICT ( order_number ) DO UPDATE SET ( feedback_rating,event_timestamp ) = ('5', 'ts1')";  Assert."<AssertPlaceHolder>"; }
toQueryString(Message message) {  byte[] value;  if ("message".equals(kafkaRecordParserMode)) { value = message.getLogMessage(); } else { value = message.getLogKey(); }  Map<String, Object> columnToValue = protoToFieldMapper.getFields(value);  String insertValues = stringifyColumnValues(columnToValue, insertColumns); String updateValues = stringifyColumnValues(columnToValue, updateColumns);  scopes.put("updateValues", updateValues); scopes.put("insertValues", insertValues);  return template.execute(scopes); }
[*] target: assertEquals(actualSql, expectedSql)
[-] pred: org. junit. Assert. assertEquals ( actualSql, expectedSql )
************************************
************************************
[+] input: Exception { byte[] fullFileContent = createFileContent(3 * 1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 2 * 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  "<AssertPlaceHolder>"; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException("Unexpected EOF encountered"); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }
[*] target: assertArrayEquals(expectedBytes, resultBytes)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedBytes, resultBytes )
************************************
************************************
[+] input: rtspPlayRequestTest() { String expect = "PLAY rtsp://10.3.8.202:554/ RTSP/1.0\r\n" + "CSeq: 0\r\n" + "Authorization: Digest username="admin", realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", uri="rtsp://10.3.8.202:554", response="56d55b92e8b41aa6cc1a68a5c2e2de15"\r\n" + "User-Agent: IOT-COMMUNICATION\r\n" + "Session: 1273222592\r\n" + "Range: npt=0.000-\r\n" + "\r\n"; URI uri = URI.create("rtsp://10.3.8.202:554/"); RtspRange range = new RtspRangeNpt("0.000"); RtspPlayRequest request = new RtspPlayRequest(uri, "1273222592", range, this.authenticator); request.setCSeq(0); String actual = request.toObjectString(); "<AssertPlaceHolder>"; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldReturnAddedJsonStringForNestedJson() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = "{"k1":null,"k2":{"key1":"value1","key2":"value2"}}"; String expectedJsonEvent = "{"k1":null,"k2":{"key1":"value1","key2":"value2","key3":"value3"}}"; String jPath = "$.k2.key3"; String updateValue = "value3"; String actual = jsonUpdate.eval(jsonEvent, jPath, updateValue); Assert."<AssertPlaceHolder>"; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }
[*] target: assertEquals(expectedJsonEvent, actual)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonEvent, actual )
************************************
************************************
[+] input: shouldNotBeEmptyWhenGrpcConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, null, null, grpc);  "<AssertPlaceHolder>"; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }
[*] target: assertFalse(externalSourceConfig.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( externalSourceConfig. isEmpty() )
************************************
************************************
[+] input: shouldDoDefaultFormatForSubSelectAndForValuesNestedInTheFunctionAndDoNotMakeALineBreakAfterTheCommaForThem() { //given String inputString = "CREATE VIEW bi_gaz_check_curve AS (SELECT cal.date, pay.check_id, COALESCE(pay.base_amount, pay.amount) amount_ars, pay.future_pay_due_date due_date, pay.cleared_date, pay.check_date issued_date FROM (SELECT generate_series('2010-01-01'::date, '2050-12-31'::date, INTERVAL '1 day') date, 1 payment_id) cal LEFT JOIN oracle.ap_checks_all pay ON cal.date >= pay.check_date AND cal.date <= (pay.future_pay_due_date::date + 30));"; //#9365 String expectedString = "CREATE VIEW bi_gaz_check_curve AS (" + lineBreak + "SELECT" + lineBreak + "\tcal.date," + lineBreak + "\tpay.check_id," + lineBreak + "\tCOALESCE(pay.base_amount, pay.amount) amount_ars," + lineBreak + "\tpay.future_pay_due_date due_date," + lineBreak + "\tpay.cleared_date," + lineBreak + "\tpay.check_date issued_date" + lineBreak + "FROM" + lineBreak + "\t(" + lineBreak + "\tSELECT" + lineBreak + "\t\tgenerate_series('2010-01-01'::date, '2050-12-31'::date, INTERVAL '1 day') date," + lineBreak + "\t\t1 payment_id) cal" + lineBreak + "LEFT JOIN oracle.ap_checks_all pay ON" + lineBreak + "\tcal.date >= pay.check_date" + lineBreak + "\tAND cal.date <= (pay.future_pay_due_date::date + 30));";  Mockito.when(configuration.isFunction("COALESCE")).thenReturn(true); Mockito.when(configuration.isFunction("generate_series")).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, formattedString)
[-] pred: org. junit. Assert. assertEquals ( expectedString, formattedString )
************************************
************************************
[+] input: pesquisarCliente() { Cliente clienteConsultado = clienteDao.consultar(cliente.getCpf()); Assert."<AssertPlaceHolder>"; }
consultar(String codigo) throws Exception { Connection connection = null; PreparedStatement stm = null; ResultSet rs = null; Cliente cliente = null; try { connection = ConnectionFactory.getConnection(); String sql = "select * from tb_cliente_2 where codigo = ?"; stm = connection.prepareStatement(sql); stm.setString(1, codigo); rs = stm.executeQuery(); if (rs.next()) { cliente = new Cliente(); cliente.setId(rs.getLong("id")); cliente.setCodigo(rs.getString("codigo")); cliente.setNome(rs.getString("nome")); } return cliente; } catch(Exception e) { throw e; } finally { if (stm != null && !stm.isClosed()) { stm.close(); } if (connection != null && !connection.isClosed()) { connection.close(); } } }
[*] target: assertNotNull(clienteConsultado)
[-] pred: org. junit. Assert. assertNotNull ( clienteConsultado )
************************************
************************************
[+] input: moveKingInChaos21() { Board board = Board.getBoard("r2k3r/PpPp1ppp/5nbN/nP6/BB2P3/q4N2/Pp1P2PP/R2Q1RK1 b - -"); board.inCheck = true; System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 1); System.out.println("NUMBER OF POSITIONS: " + positions); Assert."<AssertPlaceHolder>"; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }
[*] target: assertEquals(3, positions)
[-] pred: org. junit. Assert. assertEquals ( 3, positions )
************************************
************************************
[+] input: Exception { String name = "test_force"; MPFastKV kv1 = new MPFastKV.Builder(TestHelper.MP_DIR, name).disableWatchFileChange().build(); long newTime = System.currentTimeMillis() ^ System.nanoTime();  kv1.putLong("time", newTime); kv1.commit(); kv1.force();  File aFile = new File(TestHelper.MP_DIR, name + ".kva"); RandomAccessFile accessFile = new RandomAccessFile(aFile, "r"); ByteBuffer buffer = ByteBuffer.allocate(26); buffer.order(ByteOrder.LITTLE_ENDIAN); accessFile.read(buffer.array(), 0, 26); long t = buffer.getLong(18); Assert."<AssertPlaceHolder>"; }
force() { try { if (aBuffer != null) { aBuffer.force(); } if (bChannel != null) { bChannel.force(true); } } catch (Exception e) { error(e); } }
[*] target: assertEquals(newTime, t)
[-] pred: org. junit. Assert. assertEquals ( newTime, t )
************************************
************************************
[+] input: shouldProcessBaseCase() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.DISABLED);  simpleRequest = new SimpleRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType); boolean canProcess = simpleRequest.canProcess(); "<AssertPlaceHolder>"; }
canProcess() { boolean isDynamicUrl = httpSinkConfig.getSinkHttpServiceUrl().contains(","); return httpSinkConfig.getSinkHttpParameterSource() == HttpSinkParameterSourceType.DISABLED && !isDynamicUrl; }
[*] target: assertTrue(canProcess)
[-] pred: org. junit. Assert. assertTrue ( canProcess )
************************************
************************************
[+] input: logout() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  boolean result = JapAuthentication.logout(request, response); Assert."<AssertPlaceHolder>"; }
logout(JapHttpRequest request, JapHttpResponse response) { JapUserStore japUserStore = context.getUserStore(); if (null == japUserStore) { return false; } japUserStore.remove(request, response);  // Clear all cookie information Map<String, JapHttpCookie> cookieMap = RequestUtil.getCookieMap(request); if (CollectionUtil.isNotEmpty(cookieMap)) { cookieMap.forEach((key, cookie) -> { cookie.setMaxAge(0); response.addCookie(cookie); }); } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testAppendFetch() { LogRecord expected = new MasterLogRecord(1234);  logManager.appendToLog(expected); LogRecord record = logManager.fetchLogRecord(0);  "<AssertPlaceHolder>"; }
fetchLogRecord(long LSN) { try { Page logPage = bufferManager.fetchPage(new DummyLockContext("_dummyLogPageRecord"), getLSNPage(LSN)); try { Buffer buf = logPage.getBuffer(); buf.position(getLSNIndex(LSN)); Optional<LogRecord> record = LogRecord.fromBytes(buf); record.ifPresent((LogRecord e) -> e.setLSN(LSN)); return record.orElse(null); } finally { logPage.unpin(); } } catch (PageException e) { return null; } }
[*] target: assertEquals(expected, record)
[-] pred: org. junit. Assert. assertEquals ( expected, record )
************************************
************************************
[+] input: Exception { XADataSource dataSource = dataSourceFactory.createXADataSource(null); Assert."<AssertPlaceHolder>"; }
createXADataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); PGXADataSource dataSource = new PGXADataSource(); configureBaseDataSource(dataSource, props); return dataSource; }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: filteredListSizeIsCorrect2() { int k = 5; // instantiate random filter with parameter k KLeastExecutedFilter filter = new KLeastExecutedFilter(k); // call filter method to obtain filtered list List<MutationInstance> filteredList = filter.filterMutants(toFilter); // filtered list should be of size k "<AssertPlaceHolder>"; }
filterMutants(List<MutationInstance> toFilter) {  // determine number of mutants to run int n = this.percent ? (guidance.getSeenMutants() * k / 100) : k;  // initialize filtered list to be returned ArrayList<MutationInstance> filteredList = new ArrayList<MutationInstance>(); ArrayList<MutationInstance> executedMutants = new ArrayList<MutationInstance>();  // add (up to n) mutants in toFilter that have not been executed before to filteredList int numMutants = 0; for (MutationInstance mutant : toFilter){ if (numMutants < n && !executionCounts.containsKey(mutant)){ filteredList.add(mutant); numMutants++; } // add all mutants that have already been executed before to a list else if (executionCounts.containsKey(mutant)){ executedMutants.add(mutant); } }  // if numMutants < n mutants have never been executed, add the next (n - numMutants) least executed mutants to filtered list if (numMutants < n){  // sort list of already executed MutationInstances by execution count Collections.sort(executedMutants, (e1, e2) -> executionCounts.get(e1).compareTo(executionCounts.get(e2)));  // add least executed to filteredList until |filteredList| = n int size = executedMutants.size(); for(int i = 0; i < size && numMutants < n; i++){ MutationInstance mutant = executedMutants.get(i); filteredList.add(mutant); numMutants++; } }  // increment execution count for each mutant in filteredList for (MutationInstance mutant: filteredList) { if (!executionCounts.containsKey(mutant)){ executionCounts.put(mutant, 1); } else { executionCounts.put(mutant, executionCounts.get(mutant)+1); } }  return filteredList; }
[*] target: assertEquals(k, filteredList.size())
[-] pred: org. junit. Assert. assertEquals ( k, filteredList. size ( ) )
************************************
************************************
[+] input: IOException { ApkModule apkModule = getApkModule(); Assert."<AssertPlaceHolder>"; File dir = TestUtils.getTempDir(); dir = new File(dir, "decode_xml"); ApkModuleXmlDecoder decoder = new ApkModuleXmlDecoder(apkModule); decoder.decode(dir); mDir_xml = dir; }
getApkModule(); public void setApkLogger(APKLogger apkLogger) { this.apkLogger = apkLogger; }
[*] target: assertNotNull(apkModule)
[-] pred: org. junit. Assert. assertNotNull ( apkModule )
************************************
************************************
[+] input: shouldUseDefaultNanosDuringTransformIfSimpleGroupDoesNotContainNanosInGroupTypeTimestamp() { Instant currentInstant = Instant.now(); long seconds = currentInstant.getEpochSecond(); Row expectedRow = Row.of(seconds, 0);  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("event_timestamp"); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor);  /* only adding seconds field to the timestamp schema and initializing it */ GroupType timestampSchema = org.apache.parquet.schema.Types.optionalGroup() .optional(INT64).named("seconds") .named("event_timestamp"); SimpleGroup timestampMessage = new SimpleGroup(timestampSchema); timestampMessage.add("seconds", seconds);  MessageType parquetSchema = buildMessage() .addField(timestampSchema) .named("TestBookingLogMessage"); SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add("event_timestamp", timestampMessage);  Row actualRow = (Row) timestampHandler.transformFromParquet(mainMessage);  "<AssertPlaceHolder>"; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }
[*] target: assertEquals(expectedRow, actualRow)
[-] pred: org. junit. Assert. assertEquals ( expectedRow, actualRow )
************************************
************************************
[+] input: shouldReturnTypeInformation() { Descriptors.FieldDescriptor repeatedFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("meta_array"); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedFieldDescriptor); TypeInformation actualTypeInformation = repeatedPrimitiveHandler.getTypeInformation(); TypeInformation<String[]> expectedTypeInformation = ObjectArrayTypeInfo.getInfoFor(Types.STRING); "<AssertPlaceHolder>"; }
getTypeInformation() { return PrimitiveHandlerFactory.getTypeHandler(fieldDescriptor).getArrayType(); }
[*] target: assertEquals(expectedTypeInformation, actualTypeInformation)
[-] pred: org. junit. Assert. assertEquals ( expectedTypeInformation, actualTypeInformation )
************************************
************************************
[+] input: toByteArray1() { byte[] actual = IntegerUtil.toByteArray(2111286, true); byte[] expect = new byte[]{(byte) 0x36, (byte) 0x37, (byte) 0x20, (byte) 0x00}; "<AssertPlaceHolder>"; }
toByteArray(int data, boolean littleEndian) { byte[] bytes = new byte[4];  if (littleEndian) { bytes[0] = (byte) ((data) & 0xFF); bytes[1] = (byte) ((data >> 8) & 0xFF); bytes[2] = (byte) ((data >> 16) & 0xFF); bytes[3] = (byte) ((data >> 24) & 0xFF); } else { bytes[0] = (byte) ((data >> 24) & 0xFF); bytes[1] = (byte) ((data >> 16) & 0xFF); bytes[2] = (byte) ((data >> 8) & 0xFF); bytes[3] = (byte) ((data) & 0xFF); } return bytes; }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: IOException { ClassLoader classLoader = getClass().getClassLoader(); String pythonFile = classLoader.getResource("python_udf.zip").getFile(); byte[] expectedObject = Files.readAllBytes(Paths.get(pythonFile));  when(gcsClient.getFile(pythonFile)).thenReturn(expectedObject); GcsFileSource gcsFileSource = new GcsFileSource(pythonFile, gcsClient);  byte[] actualObject = gcsFileSource.getObjectFile();  Assert."<AssertPlaceHolder>"; }
getObjectFile() { return getGcsClient().getFile(pythonFile); }
[*] target: assertEquals(expectedObject, actualObject)
[-] pred: org. junit. Assert. assertEquals ( expectedObject, actualObject )
************************************
************************************
[+] input: testVerifyRequestEmptyRequest() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: shouldNotBeEmptyWhenTransformConfigsExist() { transformConfigs.add(new TransformConfig("testClass", new HashMap<>())); defaultPostProcessorConfig = new PostProcessorConfig(null, transformConfigs, null);  "<AssertPlaceHolder>"; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }
[*] target: assertFalse(defaultPostProcessorConfig.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( defaultPostProcessorConfig. isEmpty() )
************************************
************************************
[+] input: testGetMonotonicKsuidAfterLeapSecond() {  long second = Instant.parse("2021-12-31T23:59:59.000Z").getEpochSecond(); long leapSecond = second - 1; // simulate a leap second long times[] = { second, leapSecond };  AtomicInteger i = new AtomicInteger(); Supplier<Instant> instantFunction = () -> Instant.ofEpochSecond(times[i.getAndIncrement() % times.length]);  KsuidFactory factory = KsuidFactory.newMonotonicInstance(() -> new Random().nextLong(), instantFunction);  long ms1 = factory.create().getTime(); // second long ms2 = factory.create().getTime(); // leap second  "<AssertPlaceHolder>"; // LEAP SECOND! DON'T MOVE BACKWARDS! }
create() { return create(instantFunction.get()); }
[*] target: assertEquals(ms1, ms2)
[-] pred: org. junit. Assert. assertEquals ( ms1, ms2 )
************************************
************************************
[+] input: Exception { FilterRegistrationBean result = webMvcConfig.uriCostFilterRegistration(); Assert."<AssertPlaceHolder>"; }
uriCostFilterRegistration() { FilterRegistrationBean uriCostFilterBean = new FilterRegistrationBean(); uriCostFilterBean.setFilter(new UriCostFilter(brccInstanceService, projectService, productService)); uriCostFilterBean.setOrder(99); uriCostFilterBean.addUrlPatterns("/*"); return uriCostFilterBean; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testEnsureTypeWithItself() { final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT); RexBuilder builder = new RexBuilder(typeFactory);  RexNode node =  new RexLiteral( Boolean.TRUE, typeFactory.createSqlType(SqlTypeName.BOOLEAN), SqlTypeName.BOOLEAN); RexNode ensuredNode = builder.ensureType( typeFactory.createSqlType(SqlTypeName.BOOLEAN), node, true);  "<AssertPlaceHolder>"; }
ensureType( RelDataType type, RexNode node, boolean matchNullability) { RelDataType targetType = type; if (matchNullability) { targetType = matchNullability(type, node); }  if (targetType.getSqlTypeName() == SqlTypeName.ANY && (!matchNullability || targetType.isNullable() == node.getType().isNullable())) { return node; }  if (!node.getType().equals(targetType)) { return makeCast(targetType, node); } return node; }
[*] target: assertEquals(node, ensuredNode)
[-] pred: org. junit. Assert. assertEquals ( node, ensuredNode )
************************************
************************************
[+] input: testSaveToStringWithHeader() { FileConfiguration config = getConfig(); config.options().header(getTestHeaderInput());  for (Map.Entry<String, Object> entry : getTestValues().entrySet()) { config.set(entry.getKey(), entry.getValue()); }  String result = config.saveToString(); String expected = getTestHeaderResult() + "\n" + getTestValuesString();  "<AssertPlaceHolder>"; }
saveToString();  /** * Loads this {@link FileConfiguration}
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testFilterClassIgnoringInjectFieldAnnotationExpectingNullValue() { Class<Replacement> filteredValue = ConfigurationUtility.filterClassIgnoringInjectFieldAnnotation(new Class[]{Replacement.class}, Replacement.class); "<AssertPlaceHolder>"; }
filterClassIgnoringInjectFieldAnnotation(Class[] classes, Class<T> filter) { for (Class c : classes) { if (filter.isAssignableFrom(c) && !Modifier.isAbstract(c.getModifiers()) && !isInjectFieldAnnotationPresent(c)) { return c; } } return null; }
[*] target: assertNull(filteredValue)
[-] pred: org. junit. Assert. assertNull ( filteredValue )
************************************
************************************
[+] input: shouldReturnTypeInformation() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("profile_data"); StructMessageHandler structMessageHandler = new StructMessageHandler(fieldDescriptor); TypeInformation actualTypeInformation = structMessageHandler.getTypeInformation(); TypeInformation<Row> expectedTypeInformation = Types.ROW_NAMED(new String[]{}); "<AssertPlaceHolder>"; }
getTypeInformation() { return Types.ROW_NAMED(new String[]{}); }
[*] target: assertEquals(expectedTypeInformation, actualTypeInformation)
[-] pred: org. junit. Assert. assertEquals ( expectedTypeInformation, actualTypeInformation )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x10, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x02}; MbWriteMultipleRegisterResponse mb = new MbWriteMultipleRegisterResponse(); mb.setFunctionCode(EMbFunctionCode.WRITE_MULTIPLE_REGISTER); mb.setAddress(1); mb.setQuantity(2); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: mp4StszBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x14, 0x73, 0x74, 0x73, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4StszBox box = new Mp4StszBox(); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: readIntTest() { ByteBuf byteBuf = Unpooled.buffer(); for (int value = Integer.MIN_VALUE; value < Integer.MAX_VALUE; value++) { byteBuf.clear(); ByteBufUtils.writeInt(byteBuf, value); int result = ByteBufUtils.readInt(byteBuf); Assert."<AssertPlaceHolder>"; } }
readInt(ByteBuf byteBuf) { int readIndex = byteBuf.readerIndex(); int b = byteBuf.getByte(readIndex++); int value = b; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x0000007F | b << 7; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x00003FFF | b << 14; if (b < 0) { b = byteBuf.getByte(readIndex++); value = value & 0x001FFFFF | b << 21; if (b < 0) { value = value & 0x0FFFFFFF | byteBuf.getByte(readIndex++) << 28; } } } } byteBuf.readerIndex(readIndex); return ((value >>> 1) ^ -(value & 1)); }
[*] target: assertEquals(result, value)
[-] pred: org. junit. Assert. assertEquals ( result, value )
************************************
************************************
[+] input: testToString() { String expectedStr = "MetricsData(successCount=1, failCount=2)"; MetricsData data = new MetricsData(1, 2); "<AssertPlaceHolder>"; }
toString() { return "MetricsData(" + "successCount=" + successCount + ", failCount=" + failCount + ")"; }
[*] target: assertEquals(expectedStr, data.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedStr, data. toString() )
************************************
************************************
[+] input: shouldDoDefaultFormatForValuesNestedInTheFunctionAndDoNotMakeALineBreakAfterTheCommaForThem() { //given String inputString = "SELECT to_date(CONCAT(YEAR('2019-12-31'),'-',lpad(CEIL(MONTH('2019-12-31')/3)*3-2, 2, 0),'-01')) AS season_first_day"; //#7509 String expectedString = "SELECT" + lineBreak + "\tto_date(CONCAT(YEAR('2019-12-31'), '-', lpad(CEIL(MONTH('2019-12-31')/ 3)* 3-2, 2, 0), '-01')) AS season_first_day";  Mockito.when(configuration.isFunction("to_date")).thenReturn(true); Mockito.when(configuration.isFunction("lpad")).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, formattedString)
[-] pred: org. junit. Assert. assertEquals ( expectedString, formattedString )
************************************
************************************
[+] input: testSubstitute_nullSql() { PreparedStatementRequest psr = new PreparedStatementRequest(null, new JSONObject(), null);  Assert."<AssertPlaceHolder>"; }
getSql() { return this.sql; }
[*] target: assertNull(psr.getSql())
[-] pred: org. junit. Assert. assertNull ( psr. getSql() )
************************************
************************************
[+] input: IOException { ApkModule apkModule = getApkModule(); Assert."<AssertPlaceHolder>"; File dir = TestUtils.getTempDir(); dir = new File(dir, "decode_json"); ApkModuleJsonDecoder decoder = new ApkModuleJsonDecoder(apkModule); decoder.decode(dir); mDir_json = dir; }
getApkModule(); public void setApkLogger(APKLogger apkLogger) { this.apkLogger = apkLogger; }
[*] target: assertNotNull(apkModule)
[-] pred: org. junit. Assert. assertNotNull ( apkModule )
************************************
************************************
[+] input: selectByPrimaryKey() { final MysqlUserEntity mysqlUserEntity = BraveSql.build(MysqlUserEntity.class).selectByPrimaryKey(1); Assert."<AssertPlaceHolder>"; log.info("mysqlUserEntity : {}", mysqlUserEntity); }
selectByPrimaryKey(Object primaryKeyValue) throws SQLException, InstantiationException, IllegalAccessException;  T selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }
[*] target: assertNotNull(mysqlUserEntity)
[-] pred: org. junit. Assert. assertNotNull ( mysqlUserEntity )
************************************
************************************
[+] input: mp4VmhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x14, 0x76, 0x6D, 0x68, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4VmhdBox box = new Mp4VmhdBox(); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: shouldReturnFalseIfRepeatedMessageFieldDescriptorIsPassed() { Descriptors.FieldDescriptor repeatedMessageFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("routes"); RepeatedPrimitiveHandler repeatedPrimitiveHandler = new RepeatedPrimitiveHandler(repeatedMessageFieldDescriptor);  "<AssertPlaceHolder>"; }
canHandle() { return fieldDescriptor.isRepeated() && fieldDescriptor.getJavaType() != MESSAGE && fieldDescriptor.getJavaType() != ENUM; }
[*] target: assertFalse(repeatedPrimitiveHandler.canHandle())
[-] pred: org. junit. Assert. assertFalse ( repeatedPrimitiveHandler. canHandle() )
************************************
************************************
[+] input: testSQLInterceptor2() { //        InterceptorHelper.initSQLInterceptor(new FalseSQLInterceptor()); final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); //设置一个类型不匹配的错误 dynamicSql.andGreaterThanOrEqualTo(MysqlUserEntity::getId, null); final List<MysqlUserEntity> select = BraveSql.build(dynamicSql, MysqlUserEntity.class).select(); log.info("select.size() :{}", select.size()); Assert."<AssertPlaceHolder>"; }
select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }
[*] target: assertEquals(0, select.size())
[-] pred: org. junit. Assert. assertEquals ( 0, select. size ( ) )
************************************
************************************
[+] input: shouldFetchTimeStampAsStringFromFieldForFieldDescriptorOfTypeTimeStampForTransformForPostProcessor() { String strValue = "2018-08-30T02:21:39.975107Z";  Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName("booking_creation_time");  TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor);  Object value = typeHandler.transformFromPostProcessor(strValue); "<AssertPlaceHolder>"; }
transformFromPostProcessor(Object field) { return isValid(field) ? field.toString() : null; }
[*] target: assertEquals(strValue, value)
[-] pred: org. junit. Assert. assertEquals ( strValue, value )
************************************
************************************
[+] input: testUtf8SubjectEncoded() { String s = null; try { s = MimeUtility.decodeText(ENV_UTF8_ENCODED_SUBJECT); } catch (UnsupportedEncodingException ex) { } final String subject = s;  testWithHandler( new IMAPTest() { @Override public void test(Folder folder, IMAPHandlerMessage handler) throws MessagingException { Message m = folder.getMessage(1); "<AssertPlaceHolder>"; } }, new IMAPHandlerMessage() { { { envelope = "(" + ENV_DATE + " "" + ENV_UTF8_ENCODED_SUBJECT + "" " + ENV_ADDRS + ")"; } } }); }
getSubject() throws MessagingException { checkExpunged(); if (bodyLoaded) return super.getSubject();  if (subject != null) // already cached ? return subject;  loadEnvelope(); if (envelope.subject == null) // no subject return null;  // Cache and return the decoded value. try { // The server *should* unfold the value, but just in case it // doesn't we unfold it here. subject = MimeUtility.decodeText(MimeUtility.unfold(envelope.subject)); } catch (UnsupportedEncodingException ex) { subject = envelope.subject; }  return subject; }
[*] target: assertEquals(subject, m.getSubject())
[-] pred: org. junit. Assert. assertEquals ( subject, m. getSubject ( ) )
************************************
************************************
[+] input: testFormatSequence() { CompactFormatter cf = new CompactFormatter("%9$d"); LogRecord record = new LogRecord(Level.SEVERE, ""); String output = cf.format(record); String expect = Long.toString(record.getSequenceNumber()); "<AssertPlaceHolder>"; }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }
[*] target: assertEquals(expect, output)
[-] pred: org. junit. Assert. assertEquals ( expect, output )
************************************
************************************
[+] input: interpolationMiddle() { createCueFile("'a\\(123)b'"); var literal = findTypedElement(CueStringLiteral.class); var ranges = CueMultiHostInjector.findInjectionRanges(literal);  var expected = Arrays.asList( new InjectionData(TextRange.create(1, 2), null, null), new InjectionData(TextRange.create(8, 9), "\\(123)", null)); "<AssertPlaceHolder>"; }
findInjectionRanges(CueStringLiteral context) { var totalRange = context.getLiteralContentRange(); var interpolations = context.getInterpolationList() .stream() .map(PsiElement::getTextRangeInParent) .sorted(Comparator.comparingInt(TextRange::getStartOffset)) .collect(Collectors.toList());  if (interpolations.isEmpty()) { return Collections.singletonList(new InjectionData(totalRange, null, null)); }  var hostText = context.getText(); var result = new LinkedList<InjectionData>(); var lastStart = totalRange.getStartOffset(); var lastEnd = totalRange.getStartOffset(); for (TextRange range : interpolations) { var start = range.getStartOffset(); var end = range.getEndOffset(); if (start == totalRange.getStartOffset()) { // interpolation at start, insert empty range before to allow editing result.add(new InjectionData(TextRange.create(start, start), null, null)); } else if (start > lastEnd) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, start), prefix, null)); } lastStart = start; lastEnd = end; } if (lastEnd < totalRange.getEndOffset()) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } else if (lastEnd == totalRange.getEndOffset() && lastEnd > lastStart) { var prefix = hostText.substring(lastStart, lastEnd); result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } return result; }
[*] target: assertEquals(expected, ranges)
[-] pred: org. junit. Assert. assertEquals ( expected, ranges )
************************************
************************************
[+] input: Exception { TestAbstractDAGVisitor visitor = new TestAbstractDAGVisitor(); visitor.putEdge(new TestAbstractDAGNode("1", "1"), new TestAbstractDAGNode("2", "2")); visitor.putEdge(new TestAbstractDAGNode("2", "2"), new TestAbstractDAGNode("3", "3")); visitor.putEdge(new TestAbstractDAGNode("4", "4"), new TestAbstractDAGNode("5", "5")); visitor.putEdge(new TestAbstractDAGNode("5", "5"), new TestAbstractDAGNode("4", "4")); Assert."<AssertPlaceHolder>"; }
hasCircle() { Set<String> allMarked = new HashSet<>(); Set<String> stackMarked = new HashSet<>(); try { for (Map.Entry<String, N> node : nodes.entrySet()) { if (allMarked.contains(node.getKey())) { continue; } markNode(allMarked, stackMarked, node.getKey()); } return false; } catch (Exception ex) { return true; } }
[*] target: assertTrue(visitor.hasCircle())
[-] pred: org. junit. Assert. assertTrue ( visitor. hasCircle ( ) )
************************************
************************************
[+] input: testUpdateActionsFromPaths_shortPaths() { Set<UpdateAction> expectedActions = EnumSet.noneOf(UpdateAction.class); List<Path> changedPaths = List.of(Path.of("pom.xml")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(changedPaths); "<AssertPlaceHolder>"; }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: toByteArray1() { AckHeader header = new AckHeader(); header.setProtocolId((byte) 0x32); header.setMessageType(EMessageType.JOB); header.setReserved(0x0000); header.setPduReference(0x0000); header.setParameterLength(0x0000); header.setDataLength(0x0002); header.setErrorClass(EErrorClass.NO_ERROR); header.setErrorCode((byte) 0x00); byte[] actual = header.toByteArray(); byte[] expect = new byte[]{(byte) 0x32, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00}; "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.protocolId) .putByte(this.messageType.getCode()) .putShort(this.reserved) .putShort(this.pduReference) .putShort(this.parameterLength) .putShort(this.dataLength) .getData(); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: testCustomEChartsSerializer() { EChartsSerializer serializer = new EChartsSerializer(new CustomObjectAdapter()); Object object = new CustomObject("name"); JsonElement actual = serializer.toJsonTree(object); JsonElement expected = JsonParser.parseString("'name'"); "<AssertPlaceHolder>"; }
toJsonTree(Object src) { return gson.toJsonTree(src); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testHasNodesNoNodes() { ITree tree = mock(ITree.class); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION); "<AssertPlaceHolder>"; }
hasNodes() { return m_nodes == null ? false : !m_nodes.isEmpty(); }
[*] target: assertFalse(event.hasNodes())
[-] pred: org. junit. Assert. assertFalse ( event. hasNodes() )
************************************
************************************
[+] input: shouldReturnEmptyStringWhenThereIsOnlyOneSpace() { //given String expectedString = ""; String inputString = " ";  //when String format = formatter.format(inputString, configuration);  //then "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, format)
[-] pred: org. junit. Assert. assertEquals ( expectedString, format )
************************************
************************************
[+] input: shouldNotBeAbleToBuildSourceIfSourceNameIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.UNBOUNDED)}); FlinkKafkaConsumerDaggerSource daggerSource = new FlinkKafkaConsumerDaggerSource(streamConfig, configuration, daggerDeserializer);  "<AssertPlaceHolder>"; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }
[*] target: assertFalse(daggerSource.canBuild())
[-] pred: org. junit. Assert. assertFalse ( daggerSource. canBuild ( ) )
************************************
************************************
[+] input: miss_DoTable_Miss_IgnoreTable_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb("full_src_1, rpl"); replicaMeta.setIgnoreDb("full_src_1, rpl"); replicaMeta.setDoTable("full_src_1.t1, full_src_1.t2"); replicaMeta.setIgnoreTable("full_src_1.t1, full_src_1.t2"); replicaMeta.setWildDoTable("d%.tb\\_charset%, d%.col\\_charset%"); replicaMeta.setWildIgnoreTable("d%.tb\\_charset%, d%.col\\_charset%"); replicaMeta.setRewriteDb(""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  // Hit Replicate_Do_Table rowChange.setSchema("full_src_1"); rowChange.setTable("t3"); Assert."<AssertPlaceHolder>"; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }
[*] target: assertTrue(filter.ignoreEvent(rowChange))
[-] pred: org. junit. Assert. assertTrue ( filter. ignoreEvent ( rowChange ) )
************************************
************************************
[+] input: IOException { EntryIndexFile file = new EntryIndexFile(new ByteArraySeekableFile()); Iterator<EntryIndexItem> iterator = file.iterator(); Assert."<AssertPlaceHolder>"; }
hasNext() { checkModification(); return currentEntryIndex <= maxEntryIndex; }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext ( ) )
************************************
************************************
[+] input: convertPoint_SecondIsRoundNumber_ShouldConvert() { String wkt = "POINT(12.2 13)"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"Point", "coordinates": [12.2,13]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: testExists200() { Response r = new Response(Collections.emptyMap(), new byte[0], 200); "<AssertPlaceHolder>"; }
exists() { if (statusCode >= 200 && statusCode <= 299) { return true; } else if (statusCode == HttpURLConnection.HTTP_NOT_FOUND) { return false; } else { throw new ServiceException(statusCode, "call failed"); } }
[*] target: assertTrue(r.exists())
[-] pred: org. junit. Assert. assertTrue ( r. exists() )
************************************
************************************
[+] input: hasTypeShouldBeFalseWhenTypeIsEmpty() { pgSourceConfig = getPgSourceConfigBuilder() .setType("") .createPgSourceConfig(); "<AssertPlaceHolder>"; }
hasType() { return StringUtils.isNotEmpty(type); }
[*] target: assertFalse(pgSourceConfig.hasType())
[-] pred: org. junit. Assert. assertFalse ( pgSourceConfig. hasType() )
************************************
************************************
[+] input: SQLException { Query.Field[] fields = TestResult.makeTestFields("c1|c2|c3", "varbinary|decimal|int64"); VtResultSet resultSet = TestResult.makeTestResult(fields, "a|1|1", "g|2|1", "a|1|1", "c|4|1", "c|3|1"); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(resultSet));  OrderByParamsGen4 orderByParamsGen4 = new OrderByParamsGen4(1, false, -1, null); MemorySortGen4Engine ms = new MemorySortGen4Engine(Lists.newArrayList(orderByParamsGen4), fp); ms.setTruncateColumnCount(2);  VtResultSet result = (VtResultSet) ms.execute(VtContext.background(), new NoopVCursor(), null, false).getVtRowList(); VtResultSet wantResult = TestResult.makeTestResult(new Query.Field[] {fields[0], fields[1]}, "a|1", "a|1", "g|2", "c|3", "c|4"); Assert."<AssertPlaceHolder>"; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { int count = this.fetchCount(bindVariableMap);  IExecute.ExecuteMultiShardResponse response = this.input.execute(ctx, vcursor, bindVariableMap, wantFields);  VtResultSet resultSet = (VtResultSet) response.getVtRowList(); return getExecuteMultiShardResponse(count, resultSet); }
[*] target: assertEquals(wantResult, result)
[-] pred: org. junit. Assert. assertEquals ( wantResult, result )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeDataAndRuleRegexMatch2WithSubjectAndResourceAndActionAndEnvironment() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "25"); subject.put("verify_aal", "2."); subject.put("userId", "123457"); subject.put("verify_userId", "12345[6|7]");  Map<String, String> resource = new HashMap<>(); resource.put("aal", "10"); resource.put("verify_aal", ".0"); resource.put("userId", "1111"); resource.put("verify_userId", "1111");  Map<String, String> action = new HashMap<>(); resource.put("aal", "abcd"); resource.put("verify_aal", "[a][b][c][d]"); resource.put("userId", "1111"); resource.put("verify_userId", "1111");  Map<String, String> environment = new HashMap<>(); resource.put("aal", "abcd"); resource.put("verify_aal", "[a-z]*"); resource.put("userId", "1111"); resource.put("verify_userId", "1111"); Context context = new Context<>(subject, resource, action, environment, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: InvalidProtocolBufferException { String protoClass = "org.raystack.dagger.consumer.TestNestedMessage"; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestNestedMessage.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  TestNestedMessage nestedMessage = TestNestedMessage.newBuilder() .setNestedId("id-123") .setSingleMessage(commonMessage) .build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(nestedMessage.getDescriptor(), nestedMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = "{"nested_id":"id-123","single_message":{"order_number":"order-number-123","order_url":"https://order-url","order_details":"pickup"}}"; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  "<AssertPlaceHolder>"; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }
[*] target: assertEquals(expectedJsonPayload, actualJsonPayload)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonPayload, actualJsonPayload )
************************************
************************************
[+] input: selectByCategoryType() { ProductCategory productCategory = mapper.selectByCategoryType(7); Assert."<AssertPlaceHolder>"; }
selectByCategoryType(Integer categoryType);
[*] target: assertNotNull(productCategory)
[-] pred: org. junit. Assert. assertNotNull ( productCategory )
************************************
************************************
[+] input: AccountTransactionException { // fill code  // when boolean isDeposited = dao.deposit("ISBN0000", 4000.0); // Method call // then verify(ds, times(1)).getConnection(); verify(con, times(1)).prepareStatement(anyString()); verify(ps, times(1)).executeUpdate(); "<AssertPlaceHolder>"; }
deposit(String accNo, double amount) throws AccountTransactionException { try { if (accNo == null || accNo.isEmpty()) { throw new AccountTransactionException("Invalid account number"); }  if (amount <= 0) { throw new AccountTransactionException("Invalid amount"); }  Connection con = ds.getConnection(); PreparedStatement ps = con.prepareStatement("UPDATE ACCOUNT SET balance = balance + ? WHERE accNo = ?"); ps.setDouble(1, amount); ps.setString(2, accNo); int result = ps.executeUpdate(); return result > 0; } catch (SQLException ex) { throw new AccountTransactionException(ex.getMessage()); } }
[*] target: assertTrue(isDeposited)
[-] pred: org. junit. Assert. assertTrue ( isDeposited )
************************************
************************************
[+] input: FilterException { TestBookingLogMessage bookingLogMessage = TestBookingLogMessage.newBuilder().setCustomerId("customerId").build(); TestBookingLogKey bookingLogKey = TestBookingLogKey.newBuilder().build(); Message message = new Message(bookingLogKey.toByteArray(), bookingLogMessage.toByteArray(), "topic1", 0, 100); HashMap<String, String> bookingFilterConfigs = new HashMap<>(); bookingFilterConfigs.put("FILTER_DATA_SOURCE", "message"); bookingFilterConfigs.put("FILTER_JEXL_EXPRESSION", "testBookingLogMessage.getCustomerDynamicSurgeEnabled() == false"); bookingFilterConfigs.put("FILTER_SCHEMA_PROTO_CLASS", TestBookingLogMessage.class.getName()); FilterConfig bookingConsumerConfig = ConfigFactory.create(FilterConfig.class, bookingFilterConfigs); JexlFilter bookingFilter = new JexlFilter(bookingConsumerConfig, firehoseInstrumentation); FilteredMessages expectedMessages = new FilteredMessages(); expectedMessages.addToValidMessages(message); FilteredMessages filteredMessages = bookingFilter.filter(Arrays.asList(message)); "<AssertPlaceHolder>"; }
filter(List<Message> messages) throws FilterException { FilteredMessages filteredMessages = new FilteredMessages(); for (Message message : messages) { try { Object data = (filterDataSourceType.equals(FilterDataSourceType.KEY)) ? message.getLogKey() : message.getLogMessage(); Object obj = MethodUtils.invokeStaticMethod(Class.forName(protoSchema), "parseFrom", data); if (evaluate(obj)) { filteredMessages.addToValidMessages(message); } else { filteredMessages.addToInvalidMessages(message); } } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { throw new FilterException("Failed while filtering EsbMessages", e); } } return filteredMessages;  }
[*] target: assertEquals(expectedMessages, filteredMessages)
[-] pred: org. junit. Assert. assertEquals ( expectedMessages, filteredMessages )
************************************
************************************
[+] input: convertPolygon_NoRedundantSpaces_ShouldConvert() { String wkt = "POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"Polygon", "coordinates": [[[30,10],[40,40],[20,40],[10,20],[30,10]]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: shouldAddLineBreakBeforeBraceBySpecialSetting() { //given String expectedString = getExpectedStringWithLineBreakBeforeBraces(); String inputString = "SELECT (SELECT thecol FROM thetable) FROM dual";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA))).thenReturn(false); Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET))).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, formattedString)
[-] pred: org. junit. Assert. assertEquals ( expectedString, formattedString )
************************************
************************************
[+] input: IOException { String storeFileType = "JKS"; when(jsonReader.nextString()).thenReturn(storeFileType); DaggerSSLTrustStoreFileTypeAdaptor daggerSSLTrustStoreFileTypeAdaptor = new DaggerSSLTrustStoreFileTypeAdaptor(); String truststoreFileType = daggerSSLTrustStoreFileTypeAdaptor.read(jsonReader); "<AssertPlaceHolder>"; }
read(JsonReader jsonReader) throws IOException { String trustStoreFileType = jsonReader.nextString(); if (Arrays.stream(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SSL_STORE_FILE_TYPE).anyMatch(trustStoreFileType::equals)) { return trustStoreFileType; } else { throw new InvalidConfigurationException(String.format("Configured wrong SOURCE_KAFKA_CONSUMER_CONFIG_SSL_TRUSTSTORE_TYPE_KEY supported values are %s", Arrays.toString(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SSL_STORE_FILE_TYPE))); } }
[*] target: assertEquals(storeFileType, truststoreFileType)
[-] pred: org. junit. Assert. assertEquals ( storeFileType, truststoreFileType )
************************************
************************************
[+] input: shouldBuildBigQuerySink() { StencilClientOrchestrator stencilClientOrchestrator = Mockito.mock(StencilClientOrchestrator.class); BigQuerySinkBuilder builder = BigQuerySinkBuilder.create(); builder.setColumnNames(new String[]{"test", "some_column"}); builder.setConfiguration(new Configuration(ParameterTool.fromMap(new HashMap<String, String>() {{ put("SINK_CONNECTOR_SCHEMA_PROTO_MESSAGE_CLASS", "test"); }}))); builder.setStencilClientOrchestrator(stencilClientOrchestrator); Assert."<AssertPlaceHolder>"; }
build() { ProtoSerializer protoSerializer = new ProtoSerializer( configuration.getString("SINK_CONNECTOR_SCHEMA_PROTO_KEY_CLASS", ""), configuration.getString("SINK_CONNECTOR_SCHEMA_PROTO_MESSAGE_CLASS", ""), columnNames, stencilClientOrchestrator); Configuration conf = setDefaultValues(configuration); return new BigQuerySink(conf, protoSerializer, daggerStatsDReporter); }
[*] target: assertNotNull(builder.build())
[-] pred: org. junit. Assert. assertNotNull ( builder. build() )
************************************
************************************
[+] input: Exception { Class<?>[] targets = { MockObject1.class, MockObject2.class, }; Class<?>[] params = {MockObject1.class};  for (Class<?> targetClass : targets) { Constructor<?> c = ClassUtil.getConstructor(targetClass, params); "<AssertPlaceHolder>"; } // FOR }
getConstructor(Class<T> target_class, Class<?>... params) { NoSuchMethodException error = null; try { return (target_class.getConstructor(params)); } catch (NoSuchMethodException ex) { // The first time we get this it can be ignored // We'll try to be nice and find a match for them error = ex; }  if (LOG.isDebugEnabled()) { LOG.debug("TARGET CLASS:  {}", target_class); LOG.debug("TARGET PARAMS: {}", Arrays.toString(params)); }  @SuppressWarnings("rawtypes") List<Class<?>>[] paramSuper = (List<Class<?>>[]) new List[params.length]; for (int i = 0; i < params.length; i++) { paramSuper[i] = ClassUtil.getSuperClasses(params[i]); if (LOG.isDebugEnabled()) { LOG.debug("  SUPER[{}] => {}", params[i].getSimpleName(), paramSuper[i]); } }  for (Constructor<?> c : target_class.getConstructors()) { Class<?>[] cTypes = c.getParameterTypes(); if (LOG.isDebugEnabled()) { LOG.debug("CANDIDATE: {}", c); LOG.debug("CANDIDATE PARAMS: {}", Arrays.toString(cTypes)); } if (params.length != cTypes.length) { continue; }  for (int i = 0; i < params.length; i++) { List<Class<?>> cSuper = ClassUtil.getSuperClasses(cTypes[i]); if (LOG.isDebugEnabled()) { LOG.debug("  SUPER[{}] => {}", cTypes[i].getSimpleName(), cSuper); } if (!CollectionUtils.intersection(paramSuper[i], cSuper).isEmpty()) { return ((Constructor<T>) c); } } } throw new RuntimeException( "Failed to retrieve constructor for " + target_class.getSimpleName(), error); }
[*] target: assertNotNull(c)
[-] pred: org. junit. Assert. assertNotNull ( c )
************************************
************************************
[+] input: testEnsureTypeWithAny() { final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT); RexBuilder builder = new RexBuilder(typeFactory);  RexNode node =  new RexLiteral( Boolean.TRUE, typeFactory.createSqlType(SqlTypeName.BOOLEAN), SqlTypeName.BOOLEAN); RexNode ensuredNode = builder.ensureType( typeFactory.createSqlType(SqlTypeName.ANY), node, true);  "<AssertPlaceHolder>"; }
ensureType( RelDataType type, RexNode node, boolean matchNullability) { RelDataType targetType = type; if (matchNullability) { targetType = matchNullability(type, node); }  if (targetType.getSqlTypeName() == SqlTypeName.ANY && (!matchNullability || targetType.isNullable() == node.getType().isNullable())) { return node; }  if (!node.getType().equals(targetType)) { return makeCast(targetType, node); } return node; }
[*] target: assertEquals(node, ensuredNode)
[-] pred: org. junit. Assert. assertEquals ( node, ensuredNode )
************************************
************************************
[+] input: shouldFetchDefaultValueIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("customer_dynamic_surge_enabled"); /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BOOLEAN).named("customer_dynamic_surge_enabled") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor);  Object actualValue = booleanHandler.parseSimpleGroup(simpleGroup);  "<AssertPlaceHolder>"; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getBoolean(fieldName, 0); } else { /* return default value */ return false; } }
[*] target: assertEquals(false, actualValue)
[-] pred: org. junit. Assert. assertEquals ( false, actualValue )
************************************
************************************
[+] input: createResponse4() { String expect = "Digest username="admin", realm="IP Camera(G5366)", nonce="00ea0e5bc0d4bee565d77d40502f9229"," + " uri="rtsp://192.168.3.142:554/h264/ch1/main/av_stream", response="f5592b62173d44ecc24738e0b0ed8dfd""; UsernamePasswordCredential credential = new UsernamePasswordCredential("admin", "kilox1234"); DigestAuthenticator authenticator = new DigestAuthenticator(credential); authenticator.addServerInfoByString("Digest realm="IP Camera(G5366)", nonce="00ea0e5bc0d4bee565d77d40502f9229", stale="FALSE""); authenticator.addClientInfo("rtsp://192.168.3.142:554/h264/ch1/main/av_stream", "DESCRIBE"); String actual = authenticator.createResponse(); "<AssertPlaceHolder>"; }
createResponse() { if (this.realm == null || this.realm.equals("")) { throw new AuthenticationException("realm is empty"); } if (this.nonce == null || this.nonce.equals("")) { throw new AuthenticationException("nonce is empty"); } if (this.uri == null || this.uri.equals("")) { throw new AuthenticationException("uri is empty"); } if (this.method == null || this.method.equals("")) { throw new AuthenticationException("method is empty"); } StringBuilder sb = new StringBuilder(); sb.append(DIGEST_NAME).append(" ") .append("username="").append(this.credential.getUsername()).append("", ") .append("realm="").append(this.realm).append("", ") .append("nonce="").append(this.nonce).append("", ") .append("uri="").append(this.uri).append("", "); if (this.qop == null || this.qop.equals("")) { sb.append("response="").append(this.calculateResponseString()).append("""); } else { sb.append("response="").append(this.calculateResponseString()).append("", ") .append("qop=").append(this.qop).append(", ") .append("nc=").append(String.format("%08X", this.nc)).append(", ") .append("cnonce="").append(this.cnonce).append("""); } return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: getCartShouldReturnCart() { Cart cart = shoppingCart.getCart();  "<AssertPlaceHolder>"; }
getCart() { Cart cart = new Cart(); cart.id = 1; for(Map.Entry<Product, Integer> entry : contents.entrySet()) { Product product = entry.getKey(); int quantity = entry.getValue(); CartItem cartItem = new CartItem(); cartItem.productId = product.id; cartItem.quantity = quantity; cart.subTotal += product.price * quantity; cart.basket.add(cartItem); } return cart; }
[*] target: assertNotNull(cart)
[-] pred: org. junit. Assert. assertNotNull ( cart )
************************************
************************************
[+] input: Exception { ProductCategory productCategory = new ProductCategory("男生专享", 2); ProductCategory result = categoryService.save(productCategory); Assert."<AssertPlaceHolder>"; }
save(ProductCategory productCategory) { return repository.save(productCategory); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testNotNull_Negative() { Assertions."<AssertPlaceHolder>"; }
assertNotNull(final T value) { return assertNotNull(value, "expected 'non-null' object but was 'null'"); }
[*] target: assertNotNull(null)
[-] pred: org. junit. Assert. assertNotNull ( null )
************************************
************************************
[+] input: testRunAutoSuggest() { String resp = engineService.runAutoSuggest(new EngineService.RunScriptParams().withSql("s").withAsync("false")); Assert."<AssertPlaceHolder>"; }
withAsync(String async) { params.put("async", async); return this; }
[*] target: assertNotNull(resp)
[-] pred: org. junit. Assert. assertNotNull ( resp )
************************************
************************************
[+] input: canDecorateShouldBeFalse() { InitializationDecorator initializationDecorator = new InitializationDecorator(new ColumnNameManager(new String[0], new ArrayList<>())); "<AssertPlaceHolder>"; }
canDecorate() { return false; }
[*] target: assertFalse(initializationDecorator.canDecorate())
[-] pred: org. junit. Assert. assertFalse ( initializationDecorator. canDecorate() )
************************************
************************************
[+] input: getInstance() { IastClassDiagram instance = IastClassDiagram.getInstance(); Assert."<AssertPlaceHolder>"; }
getInstance() { // DCL if (instance == null) { synchronized (IastClassDiagram.class) { if (instance == null) { instance = new IastClassDiagram(); } } } return instance; }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
************************************
[+] input: shouldFetchDefaultValueIfFieldNotPresentInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("cash_amount");  GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(DOUBLE).named("some-other-field") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor);  Object actualValue = doubleHandler.parseSimpleGroup(simpleGroup);  "<AssertPlaceHolder>"; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getDouble(fieldName, 0); } else { /* return default value */ return 0.0D; } }
[*] target: assertEquals(0.0D, actualValue)
[-] pred: org. junit. Assert. assertEquals ( 0.0D, actualValue )
************************************
************************************
[+] input: IOException { ParquetReader.ParquetReaderProvider provider = new ParquetReader.ParquetReaderProvider(deserializer, statsDReporterSupplierMock); ClassLoader classLoader = getClass().getClassLoader(); ParquetReader reader = provider.getReader(classLoader.getResource("test_file.parquet").getPath());  reader.read(); reader.read(); reader.read(); /* This 4th call to read will return null as there are only 3 rows in test_file.parquet */ reader.read();  CheckpointedPosition expectedCheckpointedPosition = new CheckpointedPosition(CheckpointedPosition.NO_OFFSET, 3);  "<AssertPlaceHolder>"; }
getCheckpointedPosition() { return new CheckpointedPosition(CheckpointedPosition.NO_OFFSET, totalEmittedRowCount); }
[*] target: assertEquals(expectedCheckpointedPosition, reader.getCheckpointedPosition())
[-] pred: org. junit. Assert. assertEquals ( expectedCheckpointedPosition, reader. getCheckpointedPosition ( ) )
************************************
************************************
[+] input: shouldAddIndentForName() { //given String expectedString = "SELECT"+lineBreak + "\tmy_field" + lineBreak + "FROM" + lineBreak + "\tmy_table"; String inputString = "SELECT my_field FROM my_table";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA))).thenReturn(false); Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET))).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, formattedString)
[-] pred: org. junit. Assert. assertEquals ( expectedString, formattedString )
************************************
************************************
[+] input: test04ctById() {  Parent p = new Parent(); p.setAge(18); p.setName("person"); p.setId("10");  mars.insert(p); Criteria id = Criteria.where("_id").is("10");  long l = mars.count(new Query(id), Parent.class);  Assert."<AssertPlaceHolder>"; }
setId( String id ) { this.id = id; }
[*] target: assertEquals(1, l)
[-] pred: org. junit. Assert. assertEquals ( 1, l )
************************************
************************************
[+] input: InvalidProtocolBufferException { String protoClass = "org.raystack.dagger.consumer.TestMapMessage"; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestMapMessage.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  TestMapMessage mapMessage = TestMapMessage.newBuilder() .putCurrentState("foo", "bar") .build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(mapMessage.getDescriptor(), mapMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = "{"order_number":"","current_state":[{"key":"foo","value":"bar"}]}"; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  "<AssertPlaceHolder>"; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }
[*] target: assertEquals(expectedJsonPayload, actualJsonPayload)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonPayload, actualJsonPayload )
************************************
************************************
[+] input: testHostSafeCheck2() { boolean exception = false; try { CommonUtil.hostSafeCheck("acbdabdasdhkj.com=="); } catch (Exception e) { exception = true; } "<AssertPlaceHolder>"; }
hostSafeCheck(String host) { String regex = "^[a-zA-Z0-9_\\-.:\\[\\]]+$";  Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(host);  if (!matcher.matches()) { throw new PolardbxException(String.format("invalid host name : %s", host)); } }
[*] target: assertTrue(exception)
[-] pred: org. junit. Assert. assertTrue ( exception )
************************************
************************************
[+] input: checkTokenNullToken() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = new JapLocalCache(); JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  Map<String, Object> map = JapAuthentication.checkToken(null); Assert."<AssertPlaceHolder>"; }
checkToken(String token) { if (null == context || ObjectUtil.isEmpty(token)) { return null; } JapCache japCache = context.getCache(); if (null == japCache) { return null; } Map<String, Object> tokenMap = JapTokenHelper.checkToken(token); if (MapUtil.isNotEmpty(tokenMap)) { Kv kv = new Kv(); kv.putAll(tokenMap); // Get the token creation time, multiplied by 1000 is the number of milliseconds long iat = kv.getLong("iat") * 1000; JapConfig japConfig = context.getConfig(); // Get token expiration time long tokenExpireTime = japConfig.getTokenExpireTime(); // The token is available when the token creation time plus the token expiration time is later than the current time, // otherwise the token has expired if (new Date(iat + tokenExpireTime).after(new Date())) { return tokenMap; } } return null; }
[*] target: assertNull(map)
[-] pred: org. junit. Assert. assertNull ( map )
************************************
************************************
[+] input: InvalidProtocolBufferException { String protoClass = "org.raystack.dagger.consumer.TestNestedRepeatedMessage"; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestNestedRepeatedMessage.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  TestNestedRepeatedMessage nestedRepeatedMessage = TestNestedRepeatedMessage.newBuilder() .addRepeatedMessage(commonMessage) .addRepeatedMessage(commonMessage) .addRepeatedNumberField(1) .addRepeatedNumberField(2) .setNumberField(10) .build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(nestedRepeatedMessage.getDescriptor(), nestedRepeatedMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = "{"single_message":{"order_number":"","order_url":"","order_details":""},"repeated_message":[{"order_number":"order-number-123","order_url":"https://order-url","order_details":"pickup"},{"order_number":"order-number-123","order_url":"https://order-url","order_details":"pickup"}],"number_field":10,"repeated_number_field":[1,2],"metadata":null,"event_timestamp":{"seconds":0,"nanos":0},"repeated_long_field":[]}"; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  "<AssertPlaceHolder>"; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }
[*] target: assertEquals(expectedJsonPayload, actualJsonPayload)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonPayload, actualJsonPayload )
************************************
************************************
[+] input: shouldNotProvideSimpleGroupDeserializerWhenSchemaTypeIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.BOUNDED)}); when(streamConfig.getDataType()).thenReturn("JSON");  SimpleGroupDeserializerProvider provider = new SimpleGroupDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator);  "<AssertPlaceHolder>"; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!sourceName.equals(COMPATIBLE_SOURCE) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }
[*] target: assertFalse(provider.canProvide())
[-] pred: org. junit. Assert. assertFalse ( provider. canProvide() )
************************************
************************************
[+] input: testFailureDueToEventualInconsistency() { DBConnection anotherDbConnection = mock(DBConnection.class); when(anotherDbConnection.getDatabaseName()) .thenReturn("ZZZ DB"); // Make sure this will be called after Other DB correctnessTest = new ComparisonTest( openSearchConnection, new DBConnection[] {otherDbConnection, anotherDbConnection});  DBResult openSearchResult = new DBResult( "OpenSearch", asList(new Type("firstname", "text")), asList(new Row(asList("John")))); DBResult otherDbResult = new DBResult( "Other DB", asList(new Type("firstname", "text")), asList(new Row(asList("JOHN")))); DBResult anotherDbResult = new DBResult( "ZZZ DB", asList(new Type("firstname", "text")), asList(new Row(asList("Hank")))); when(openSearchConnection.select(anyString())).thenReturn(openSearchResult); when(otherDbConnection.select(anyString())).thenReturn(otherDbResult); when(anotherDbConnection.select(anyString())).thenReturn(anotherDbResult);  TestReport expected = new TestReport(); expected.addTestCase( new FailedTestCase( 1, "SELECT * FROM accounts", asList(openSearchResult, otherDbResult, anotherDbResult), "")); TestReport actual = correctnessTest.verify(querySet("SELECT * FROM accounts")); "<AssertPlaceHolder>"; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format("%s: %s", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testEncodeDecode() { UUID uuid = UUID.randomUUID(); String encoded = s_helper.encodeUrlSafe(uuid); UUID decoded = s_helper.decodeUrlSafe(encoded); "<AssertPlaceHolder>"; }
decodeUrlSafe(String string) { byte[] bytes = Base64Utility.decodeUrlSafe(string); return fromByteArray(bytes); }
[*] target: assertEquals(uuid, decoded)
[-] pred: org. junit. Assert. assertEquals ( uuid, decoded )
************************************
************************************
[+] input: insertByMap() { Map<String,Object> category = new HashMap<>(); category.put("categoryName","饮料"); category.put("category_type",new Integer(7)); int result = mapper.insertByMap(category); Assert."<AssertPlaceHolder>"; }
insertByMap(Map<String, Object> map);  /** * 新增 * 通过对象注入 * @param productCategory * @return */ @Insert("insert into product_category(category_name, category_type) values (#{categoryName, jdbcType=VARCHAR}
[*] target: assertEquals(1,result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> a ); String result = redisCache.get("key", String.class); Assert."<AssertPlaceHolder>"; }
get(String key, Class<T> type) throws DataAccessException { if (isBlank(key)) { return null; } String keyString = keyPrefix.concat(key); return redisTemplate.execute((RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[] value = connection.get(keyb); if (value == null) { return null; } return GsonUtils.toObject(value, type); }); }
[*] target: assertEquals(a, result)
[-] pred: org. junit. Assert. assertEquals ( a, result )
************************************
************************************
[+] input: shouldReturnUpdatedJsonStringForNewNestedKeyValueInNestedPath() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = "{"k1":null,"k2":"v2","k3":{"nk1":"nv1","nk2":"nv2"}}"; String expectedJsonEvent = "{"k1":null,"k2":"v2","k3":{"nk1":{"key1":"value1","key2":"value2"},"nk2":"nv2"}}"; String jPath = "$.k3.nk1"; Map<String, String> updateValue = new HashMap<String, String>() {{ put("key1", "value1"); put("key2", "value2"); }}; String actual = jsonUpdate.eval(jsonEvent, jPath, updateValue); Assert."<AssertPlaceHolder>"; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }
[*] target: assertEquals(expectedJsonEvent, actual)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonEvent, actual )
************************************
************************************
[+] input: shouldProperlySerializeMessageToTemplateWithSingleUnknownField() { String template = "{"test":"$.vehicle_type"}"; StencilClient stencilClient = StencilClientFactory.getClient(); protoParser = stencilClient.getParser(TestAggregatedSupplyMessage.class.getName()); MessageToTemplatizedJson messageToTemplatizedJson = MessageToTemplatizedJson .create(firehoseInstrumentation, template, protoParser); Message message = new Message(Base64.getDecoder().decode(logKey.getBytes()), Base64.getDecoder().decode(logMessage.getBytes()), "sample-topic", 0, 100);  String serializedMessage = messageToTemplatizedJson.serialize(message); String expectedMessage = "{"test":"BIKE"}"; Assert."<AssertPlaceHolder>"; }
serialize(Message message) throws DeserializerException { try { String jsonMessage; String jsonString; // only supports messages not keys DynamicMessage msg = protoParser.parse(message.getLogMessage()); jsonMessage = JsonFormat.printer().includingDefaultValueFields().preservingProtoFieldNames().print(msg); String finalMessage = httpSinkJsonBodyTemplate; for (String path : pathsToReplace) { if (path.equals(ALL_FIELDS_FROM_TEMPLATE)) { jsonString = jsonMessage; } else { Object element = JsonPath.read(jsonMessage, path.replaceAll(""", "")); jsonString = gson.toJson(element); } finalMessage = finalMessage.replace(path, jsonString); } return finalMessage; } catch (InvalidProtocolBufferException | PathNotFoundException e) { throw new DeserializerException(e.getMessage()); } }
[*] target: assertEquals(expectedMessage, serializedMessage)
[-] pred: org. junit. Assert. assertEquals ( expectedMessage, serializedMessage )
************************************
************************************
[+] input: Exception { String data = "0123äöü"; String expected = data.substring(0, 6); String actual = IOUtility.readString(newInputStream(data.getBytes("UTF-8")), "UTF-8", 6); "<AssertPlaceHolder>"; }
readString(InputStream in, String charset, int len) { if (StringUtility.hasText(charset)) { try { return readString(new InputStreamReader(in, charset), len); } catch (UnsupportedEncodingException e) { throw new PlatformException("charset {}", charset, e); } } else { return readString(new InputStreamReader(in), len); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testCheckAndSet_EnableCaching_IfNoneMatch_true() { Mockito.when(req.getPathInfo()).thenReturn("/"); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn("W/"FooBar", W/"13-535168142"");//matching E-Tag Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(0L);  BinaryResource res = BinaryResources.create() .withFilename("a.html") .withContent("<html></html>".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModifiedNow() .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey("/"), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert."<AssertPlaceHolder>";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute("jakarta.servlet.forward.path_info"); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, "private, max-age=0, must-revalidate"); Mockito.verify(resp, ONCE).setStatus(HttpServletResponse.SC_NOT_MODIFIED); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // "private" //   Only browsers may cache this resource. // "max-age" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because "must-revalidate" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, "private, max-age=" + maxAge + ", s-maxage=" + maxAge); } else { // "private" //   Only browsers may cache this resource. // "must-revalidate" //   A cache HAS TO check with the server before using stale resources. // "max-age=0" //   A resource will become stale immediately (after 0 seconds). // Note: "max-age=0, must-revalidate" would be the same as "no-cache" resp.setHeader(CACHE_CONTROL, "private, max-age=0, must-revalidate"); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-None-Match/Etag): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-Modified-Since): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
************************************
************************************
[+] input: writeDTL() { LocalDateTime expect = LocalDateTime.of(2023, 5, 27, 12, 11, 22, 333225555); s7PLC.writeDTL("DB1.0", expect);  LocalDateTime actual = s7PLC.readDTL("DB1.0"); "<AssertPlaceHolder>"; }
readDTL(String address) { byte[] bytes = this.readByte(address, 12); ByteReadBuff buff = ByteReadBuff.newInstance(bytes); int year = buff.getUInt16(); int month = buff.getByteToInt(); int dayOfMonth = buff.getByteToInt(); int week = buff.getByteToInt(); int hour = buff.getByteToInt(); int minute = buff.getByteToInt(); int second = buff.getByteToInt(); long nanoOfSecond = buff.getUInt32(); return LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, (int) nanoOfSecond); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: hasTypeShouldBeFalseWhenTypeIsEmpty() { HttpSourceConfig httpSourceConfig = new HttpSourceConfig("", "", "", "", "", "", "", "", "", false, "", "", new HashMap<>(), new HashMap<>(), metricId, false); "<AssertPlaceHolder>"; }
hasType() { return StringUtils.isNotEmpty(type); }
[*] target: assertFalse(httpSourceConfig.hasType())
[-] pred: org. junit. Assert. assertFalse ( httpSourceConfig. hasType() )
************************************
************************************
[+] input: shouldReturnFalseForUpdateOnlyMode() { MongoUpsertRequestHandler mongoUpsertRequestHandler = new MongoUpsertRequestHandler(MongoSinkMessageType.PROTOBUF, jsonSerializer, MongoSinkRequestType.UPDATE_ONLY, "customer_id", "message");  "<AssertPlaceHolder>"; }
canCreate() { return mongoSinkRequestType == MongoSinkRequestType.UPSERT; }
[*] target: assertFalse(mongoUpsertRequestHandler.canCreate())
[-] pred: org. junit. Assert. assertFalse ( mongoUpsertRequestHandler. canCreate() )
************************************
************************************
[+] input: Exception { TestAbstractDAGVisitor visitor = new TestAbstractDAGVisitor(); visitor.putEdge(new TestAbstractDAGNode("1", "1"), new TestAbstractDAGNode("2", "2")); visitor.putEdge(new TestAbstractDAGNode("2", "2"), new TestAbstractDAGNode("3", "3")); visitor.putEdge(new TestAbstractDAGNode("1", "1"), new TestAbstractDAGNode("4", "4")); visitor.putEdge(new TestAbstractDAGNode("4", "4"), new TestAbstractDAGNode("3", "3")); Assert."<AssertPlaceHolder>"; }
hasCircle() { Set<String> allMarked = new HashSet<>(); Set<String> stackMarked = new HashSet<>(); try { for (Map.Entry<String, N> node : nodes.entrySet()) { if (allMarked.contains(node.getKey())) { continue; } markNode(allMarked, stackMarked, node.getKey()); } return false; } catch (Exception ex) { return true; } }
[*] target: assertFalse(visitor.hasCircle())
[-] pred: org. junit. Assert. assertFalse ( visitor. hasCircle ( ) )
************************************
************************************
[+] input: no_DoTable_Miss_DoDb_Hit_WildDoTable_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb("full_src_1, rpl"); replicaMeta.setIgnoreDb("full_src_1, rpl"); replicaMeta.setDoTable(""); replicaMeta.setIgnoreTable("full_src_1.t1, full_src_1.t2"); replicaMeta.setWildDoTable("d%.tb\\_charset%, d%.col\\_charset%"); replicaMeta.setWildIgnoreTable("d%.tb\\_charset%, d%.col\\_charset%"); replicaMeta.setRewriteDb(""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema("dutf8"); rowChange.setTable("tb_charset_gbk"); Assert."<AssertPlaceHolder>"; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }
[*] target: assertTrue(filter.ignoreEvent(rowChange))
[-] pred: org. junit. Assert. assertTrue ( filter. ignoreEvent ( rowChange ) )
************************************
************************************
[+] input: testAssembleUrl() { String expectedUrl = "https://test.org/api/v1/res/id-1/%E8%8E%B7%E5%8F%96%E5%90%8D%E7%A7%B0" + "?nothing&from=from-there&to=%E8%BF%99%E9%87%8C"; HttpRequest request = createRequestWithFluentApi();  String actualUrl = request.assembleUrl();  "<AssertPlaceHolder>"; }
assembleUrl() { Map<String, String> mapQueries = ObjectUtils.defaultIfNull(queryParameters, Collections.emptyMap()); StringBuilder urlBuilder = new StringBuilder(); urlBuilder.append(protocol.toString()); urlBuilder.append("://").append(domain); if (null != this.uriPattern) { urlBuilder.append(populatePathParams(uriPattern, pathParameters)); } if (-1 == urlBuilder.indexOf("?")) { urlBuilder.append("?"); } else if (!urlBuilder.toString().endsWith("?")) { urlBuilder.append("&"); }  if (!mapQueries.isEmpty()) { urlBuilder.append(UrlUtils.encode(mapQueries)); }  String url = urlBuilder.toString();  if (url.endsWith("?") || url.endsWith("&")) { url = url.substring(0, url.length() - 1); } return url; }
[*] target: assertEquals(expectedUrl, actualUrl)
[-] pred: org. junit. Assert. assertEquals ( expectedUrl, actualUrl )
************************************
************************************
[+] input: testDivisionByNaN() { System.out.println("division por NaN"); double num1 = 0.0; double num2 = Double.NaN; Calculadora instance = new Calculadora(); double expResult = Double.NaN; double result = instance.division(num1, num2); "<AssertPlaceHolder>"; }
division(double num1, double num2) { if (num2 != 0) { return num1 / num2; } else { return Double.NaN; } }
[*] target: assertEquals(expResult, result, 0.0)
[-] pred: org. junit. Assert. assertEquals ( expResult, result, 0.0 )
************************************
************************************
[+] input: interpolationEnd() { createCueFile("'a\\(123)'"); var literal = findTypedElement(CueStringLiteral.class); var ranges = CueMultiHostInjector.findInjectionRanges(literal);  var expected = Arrays.asList( new InjectionData(TextRange.create(1, 2), null, null), new InjectionData(TextRange.create(8, 8), "\\(123)", null)); "<AssertPlaceHolder>"; }
findInjectionRanges(CueStringLiteral context) { var totalRange = context.getLiteralContentRange(); var interpolations = context.getInterpolationList() .stream() .map(PsiElement::getTextRangeInParent) .sorted(Comparator.comparingInt(TextRange::getStartOffset)) .collect(Collectors.toList());  if (interpolations.isEmpty()) { return Collections.singletonList(new InjectionData(totalRange, null, null)); }  var hostText = context.getText(); var result = new LinkedList<InjectionData>(); var lastStart = totalRange.getStartOffset(); var lastEnd = totalRange.getStartOffset(); for (TextRange range : interpolations) { var start = range.getStartOffset(); var end = range.getEndOffset(); if (start == totalRange.getStartOffset()) { // interpolation at start, insert empty range before to allow editing result.add(new InjectionData(TextRange.create(start, start), null, null)); } else if (start > lastEnd) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, start), prefix, null)); } lastStart = start; lastEnd = end; } if (lastEnd < totalRange.getEndOffset()) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } else if (lastEnd == totalRange.getEndOffset() && lastEnd > lastStart) { var prefix = hostText.substring(lastStart, lastEnd); result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } return result; }
[*] target: assertEquals(expected, ranges)
[-] pred: org. junit. Assert. assertEquals ( expected, ranges )
************************************
************************************
[+] input: toByteArray1() { byte[] actual = ShortUtil.toByteArray(24565, true); byte[] expect = new byte[]{(byte) 0xF5, (byte) 0x5F}; "<AssertPlaceHolder>"; }
toByteArray(int data, boolean littleEndian) { byte[] bytes = new byte[2];  if (littleEndian) { bytes[0] = (byte) (data & 0xFF); bytes[1] = (byte) (data >> 8 & 0xFF); } else { bytes[0] = (byte) (data >> 8 & 0xFF); bytes[1] = (byte) (data & 0xFF); } return bytes; }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: testNullBitName() { byte holder = 0; NamedBitMaskHelper bitMask = new NamedBitMaskHelper(); try { holder = bitMask.setBit(null, holder); Assert.fail("null bitname is not allowed"); } catch (AssertionException e) { // ok } Assert."<AssertPlaceHolder>"; // ensure unchanged }
setBit(String bitName, byte holder) { return changeBit(bitName, true, holder); }
[*] target: assertEquals(0, holder)
[-] pred: org. junit. Assert. assertEquals ( 0, holder )
************************************
************************************
[+] input: mp4TkhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x5C, 0x74, 0x6B, 0x68, 0x64, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x07, (byte) 0x80, 0x00, 0x00, 0x04, 0x38, 0x00, 0x00, }; Mp4TkhdBox box = new Mp4TkhdBox(this.trackInfo); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: createRsaJsonWebKeySetJson() { String jwkJson = JwkUtil.createRsaJsonWebKeySetJson("jap-jwks-keyid", TokenSigningAlg.RS256); Assert."<AssertPlaceHolder>"; }
createRsaJsonWebKeySetJson(String keyId, TokenSigningAlg signingAlg) { RsaJsonWebKey jwk = createRsaJsonWebKey(keyId, signingAlg); return new JsonWebKeySet(jwk).toJson(JsonWebKey.OutputControlLevel.INCLUDE_PRIVATE); }
[*] target: assertNotNull(jwkJson)
[-] pred: org. junit. Assert. assertNotNull ( jwkJson )
************************************
************************************
[+] input: testUpdateActionsFromPaths_unrecognizedPath() { Set<UpdateAction> expectedActions = EnumSet.noneOf(UpdateAction.class); List<Path> unrecognizedPaths = List.of(Path.of("abc/unrecognized/path.java")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(unrecognizedPaths); "<AssertPlaceHolder>"; }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: mp4BtrtBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x14, 0x62, 0x74, 0x72, 0x74, 0x00, 0x1C, (byte) 0x9C, (byte) 0x80, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, 0x00, 0x2D, (byte) 0xC6, (byte) 0xC0, }; Mp4BtrtBox box = new Mp4BtrtBox(); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: InterruptedException { MDC.put(MDC_KEY, "value should not be pushed to child thread");  final AtomicReference<String> childThreadMdcValue = new AtomicReference<>(); final CountDownLatch latch = new CountDownLatch(1); new NamedThreadFactory("mdc-test-thread").newThread(() -> { childThreadMdcValue.set(MDC.get(MDC_KEY)); latch.countDown(); }).start();  latch.await(1, TimeUnit.SECONDS); "<AssertPlaceHolder>"; }
newThread(final Runnable runnable) { final AtomicReference<ThreadInfo> threadInfoRef = new AtomicReference<>(); final Thread thread = new Thread(m_group, runnable, m_threadName, 0) {  @Override public void run() { /* * Workaround to clear inherited Mapped Diagnostic Context (MDC) which would otherwise preserve * and log MDC entries which were valid when the new worker thread was created. * Logback < 1.1.5 is affected (see https://jira.qos.ch/browse/LOGBACK-422) */ MDC.clear();  ThreadInfo.CURRENT.set(threadInfoRef.get()); try { super.run(); } finally { ThreadInfo.CURRENT.remove(); } } }; threadInfoRef.set(new ThreadInfo(thread, m_threadName, m_sequence.incrementAndGet()));  thread.setDaemon(false); thread.setPriority(Thread.NORM_PRIORITY); thread.setUncaughtExceptionHandler(this);  return thread; }
[*] target: assertNull(childThreadMdcValue.get())
[-] pred: org. junit. Assert. assertNull ( childThreadMdcValue. get ( ) )
************************************
************************************
[+] input: shouldDeleteArrayValueAndReturnAsJsonString() { JsonDelete jsonDelete = new JsonDelete(); String jsonEvent = "{"k1":"v1","k2":["value1","value2","value3"]}"; String expectedJsonEvent = "{"k1":"v1","k2":["value1","value3"]}"; String jPath = "$.k2[1]"; String actual = jsonDelete.eval(jsonEvent, jPath); Assert."<AssertPlaceHolder>"; }
eval(String jsonEvent, String jPath) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).delete(JsonPath.compile(jPath)).jsonString(); }
[*] target: assertEquals(expectedJsonEvent, actual)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonEvent, actual )
************************************
************************************
[+] input: shouldNotHaveInternalSourceWhenInternalSourceIsEmpty() { defaultPostProcessorConfig = new PostProcessorConfig(defaultExternalSourceConfig, null, defaultInternalSource); "<AssertPlaceHolder>"; }
hasInternalSource() { return internalSource != null && !internalSource.isEmpty(); }
[*] target: assertFalse(defaultPostProcessorConfig.hasInternalSource())
[-] pred: org. junit. Assert. assertFalse ( defaultPostProcessorConfig. hasInternalSource() )
************************************
************************************
[+] input: Exception { TestAbstractDAGVisitor visitor = new TestAbstractDAGVisitor(); visitor.putEdge(new TestAbstractDAGNode("1", "1"), new TestAbstractDAGNode("2", "2")); visitor.putEdge(new TestAbstractDAGNode("2", "2"), new TestAbstractDAGNode("3", "3")); visitor.putEdge(new TestAbstractDAGNode("3", "3"), new TestAbstractDAGNode("1", "1")); Assert."<AssertPlaceHolder>"; }
hasCircle() { Set<String> allMarked = new HashSet<>(); Set<String> stackMarked = new HashSet<>(); try { for (Map.Entry<String, N> node : nodes.entrySet()) { if (allMarked.contains(node.getKey())) { continue; } markNode(allMarked, stackMarked, node.getKey()); } return false; } catch (Exception ex) { return true; } }
[*] target: assertTrue(visitor.hasCircle())
[-] pred: org. junit. Assert. assertTrue ( visitor. hasCircle ( ) )
************************************
************************************
[+] input: testEnsureTypeWithAny() { final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT); RexBuilder builder = new RexBuilder(typeFactory);  RexNode node =  new RexLiteral( Boolean.TRUE, typeFactory.createSqlType(SqlTypeName.BOOLEAN), SqlTypeName.BOOLEAN); RexNode ensuredNode = builder.ensureType( typeFactory.createSqlType(SqlTypeName.ANY), node, true);  "<AssertPlaceHolder>"; }
ensureType( RelDataType type, RexNode node, boolean matchNullability) { RelDataType targetType = type; if (matchNullability) { targetType = matchNullability(type, node); }  if (targetType.getSqlTypeName() == SqlTypeName.ANY && (!matchNullability || targetType.isNullable() == node.getType().isNullable())) { return node; }  //    if (!node.getType().equals(targetType)) { //      if (node instanceof RexInputRef) { //        RexInputRef ref = (RexInputRef) node; //        return new RexInputRef(ref.getIndex(), targetType); //      } else { //        return makeCast(targetType, node); //      } //    } return node; }
[*] target: assertEquals(node, ensuredNode)
[-] pred: org. junit. Assert. assertEquals ( node, ensuredNode )
************************************
************************************
[+] input: convertPolygon_NegativeCoordinates_ShouldConvert() { String wkt = "POLYGON ((-30 10, 40 40, 20 40, 10 20, -30 10))"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"Polygon", "coordinates": [[[-30,10],[40,40],[20,40],[10,20],[-30,10]]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: shouldReturnFalseIfEnumFieldDescriptorIsPassed() { Descriptors.FieldDescriptor enumFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("service_type"); RepeatedEnumHandler repeatedEnumHandler = new RepeatedEnumHandler(enumFieldDescriptor);  "<AssertPlaceHolder>"; }
canHandle() { return fieldDescriptor.getJavaType() == ENUM && fieldDescriptor.isRepeated(); }
[*] target: assertFalse(repeatedEnumHandler.canHandle())
[-] pred: org. junit. Assert. assertFalse ( repeatedEnumHandler. canHandle() )
************************************
************************************
[+] input: mp4FtypBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70, 0x69, 0x73, 0x6F, 0x6D, 0x00, 0x00, 0x00, 0x01, 0x69, 0x73, 0x6F, 0x6D, 0x61, 0x76, 0x63, 0x31 }; Mp4FtypBox box = new Mp4FtypBox(); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putString(this.majorBrand) .putInteger(this.minorVersion) .putString(this.compatibleBrands) .getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: shouldFetchUTF8EncodedByteStringForFieldOfTypeBinaryInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName("log_key"); String testString = "test-string"; ByteString expectedByteString = ByteString.copyFrom(testString.getBytes()); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named("log_key") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add("log_key", Binary.fromConstantByteArray(expectedByteString.toByteArray())); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor);  Object actualValue = byteStringHandler.parseSimpleGroup(simpleGroup);  "<AssertPlaceHolder>"; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { byte[] byteArray = simpleGroup.getBinary(fieldName, 0).getBytes(); return ByteString.copyFrom(byteArray); } else { return null; } }
[*] target: assertEquals(expectedByteString, actualValue)
[-] pred: org. junit. Assert. assertEquals ( expectedByteString, actualValue )
************************************
************************************
[+] input: interpolationFirst() { createCueFile("'\\(123)b'"); var literal = findTypedElement(CueStringLiteral.class); var ranges = CueMultiHostInjector.findInjectionRanges(literal);  var expected = Arrays.asList( new InjectionData(TextRange.create(1, 1), null, null), new InjectionData(TextRange.create(7, 8), "\\(123)", null)); "<AssertPlaceHolder>"; }
findInjectionRanges(CueStringLiteral context) { var totalRange = context.getLiteralContentRange(); var interpolations = context.getInterpolationList() .stream() .map(PsiElement::getTextRangeInParent) .sorted(Comparator.comparingInt(TextRange::getStartOffset)) .collect(Collectors.toList());  if (interpolations.isEmpty()) { return Collections.singletonList(new InjectionData(totalRange, null, null)); }  var hostText = context.getText(); var result = new LinkedList<InjectionData>(); var lastStart = totalRange.getStartOffset(); var lastEnd = totalRange.getStartOffset(); for (TextRange range : interpolations) { var start = range.getStartOffset(); var end = range.getEndOffset(); if (start == totalRange.getStartOffset()) { // interpolation at start, insert empty range before to allow editing result.add(new InjectionData(TextRange.create(start, start), null, null)); } else if (start > lastEnd) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, start), prefix, null)); } lastStart = start; lastEnd = end; } if (lastEnd < totalRange.getEndOffset()) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } else if (lastEnd == totalRange.getEndOffset() && lastEnd > lastStart) { var prefix = hostText.substring(lastStart, lastEnd); result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } return result; }
[*] target: assertEquals(expected, ranges)
[-] pred: org. junit. Assert. assertEquals ( expected, ranges )
************************************
************************************
[+] input: convertLineString_NoRedundantSpaces_ShouldConvert() { String wkt = "LINESTRING (30 10, 10 30, 40 40)"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"LineString", "coordinates": [[30,10],[10,30],[40,40]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: should_notEnableCsrf_When_CreatingCsrfCheckerAndXsrfProtectionDisabled() { Mockito.when(appConfig.isXsrfProtectionEnabled()).thenReturn(false); csrfChecker = Mockito.spy(new CsrfChecker(servletContext));  Assert."<AssertPlaceHolder>"; }
isCsrfProtectionEnabled() { return csrfProtectionEnabled; }
[*] target: assertFalse(csrfChecker.isCsrfProtectionEnabled())
[-] pred: org. junit. Assert. assertFalse ( csrfChecker. isCsrfProtectionEnabled() )
************************************
************************************
[+] input: clearEmptyPaths_EmptyMap_ShouldReturnTrue() { Map<String, Object> map = new HashMap<>(); boolean result = Util.clearEmptyPaths(map); // Assert."<AssertPlaceHolder>"; }
clearEmptyPaths(Map<String, Object> map) { if (map.size() == 0) { return true; } Set<String> keysToDelete = new HashSet<>(); for (Map.Entry<String, Object> entry : map.entrySet()) { Object value = entry.getValue(); if (Map.class.isAssignableFrom(value.getClass())) { if (clearEmptyPaths((Map<String, Object>) value)) { keysToDelete.add(entry.getKey()); } } } if (keysToDelete.size() != 0) { if (map.size() == keysToDelete.size()) { map.clear(); return true; } for (String key : keysToDelete) { // TODO: seems like a bug, either fix, or just get rid of for loop and remove the first key map.remove(key); return false; } } return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: createSsoToken() { when(httpServletRequestMock.getHeader("x-forwarded-for")).thenReturn("127.0.0.1"); when(httpServletRequestMock.getHeader("user-agent")).thenReturn("ua"); SSOToken ssoToken = JapSsoUtil.createSsoToken("userId", "userName", request); System.out.println(ssoToken); Assert."<AssertPlaceHolder>"; }
createSsoToken(Object userId, String username, JapHttpRequest request) { return new SSOToken() .setId(userId) .setIssuer(username) .setIp(getIp(request)) .setUserAgent(RequestUtil.getUa(request)) .setTime(System.currentTimeMillis()); }
[*] target: assertNotNull(ssoToken)
[-] pred: org. junit. Assert. assertNotNull ( ssoToken )
************************************
************************************
[+] input: getShardingColumnName4() { String shardingColumnName = SplitTableUtil.getShardingColumnName("commerce3", "table_engine_test3"); Assert."<AssertPlaceHolder>"; }
getShardingColumnName(final String keyspace, final String logicTableName) { return getShardingColumnName(Constant.DEFAULT_SPLIT_TABLE_CONFIG_PATH, keyspace, logicTableName); }
[*] target: assertNull(shardingColumnName)
[-] pred: org. junit. Assert. assertNull ( shardingColumnName )
************************************
************************************
[+] input: hasTypeShouldBeFalseWhenTypeIsEmpty() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setType("") .createEsSourceConfig(); "<AssertPlaceHolder>"; }
hasType() { return StringUtils.isNotEmpty(type); }
[*] target: assertFalse(esSourceConfig.hasType())
[-] pred: org. junit. Assert. assertFalse ( esSourceConfig. hasType() )
************************************
************************************
[+] input: testWithLocalDate() { LocalDate startDate = LocalDate.of(2020, 3, 11); LocalDate endDate = LocalDate.of(2020, 3, 13); final String uid = "5edf8af0-5347-4331-ae0f-3b4980180b37"; ICalVCardHelper helper = BEANS.get(ICalVCardHelper.class); ICalBean cal = BEANS.get(ICalBuilder.class) .withProductIdentifier("IDENTIFIER") .withComponent(BEANS.get(ICalVEventBuilder.class) .withDescription("description") .withLocation("location") .withSummary("summary") .withScheduling(startDate, endDate) .withUid(uid)) .build(); String expectedContent = "BEGIN:VCALENDAR\r\n" + "VERSION:2.0\r\n" + "PRODID;CHARSET=utf-8:IDENTIFIER\r\n" + "BEGIN:VEVENT\r\n" + "DTSTAMP;CHARSET=utf-8:" + helper.createDateTime(s_mockDate) + "\r\n" + "DESCRIPTION;CHARSET=utf-8:description\r\n" + "LOCATION;CHARSET=utf-8:location\r\n" + "SUMMARY;CHARSET=utf-8:summary\r\n" + "DTSTART;CHARSET=utf-8:20200311\r\n" + "DTEND;CHARSET=utf-8:20200314\r\n" + "UID;CHARSET=utf-8:5edf8af0-5347-4331-ae0f-3b4980180b37\r\n" + "END:VEVENT\r\n" + "END:VCALENDAR\r\n"; String createdContent = new String(cal.toBytes(StandardCharsets.UTF_8.name()), StandardCharsets.UTF_8); "<AssertPlaceHolder>"; }
build() { buildComponents(); end(); return m_ical; }
[*] target: assertEquals(expectedContent, createdContent)
[-] pred: org. junit. Assert. assertEquals ( expectedContent, createdContent )
************************************
************************************
[+] input: testLargeTablesConstituents() { final int GapSize = 32;  TableSet ts = new TableSet(); List<TableSet> expected = new ArrayList<>(); int table = 0;  for (int t = 0; t < 256; t++) { table += new Random().nextInt(GapSize) + 1; expected.add(singleTableSet(table)); ts.addTable(table); } Assert."<AssertPlaceHolder>"; }
constituents() { List<TableSet> result = new ArrayList<>(); forEachTable(t -> result.add(TableSet.singleTableSet((Integer) t))); return result; }
[*] target: assertEquals(expected, ts.constituents())
[-] pred: org. junit. Assert. assertEquals ( expected, ts. constituents() )
************************************
************************************
[+] input: canNotProcessWhenTypeIsNull() { InvalidInternalConfigProcessor invalidInternalConfigProcessor = new InvalidInternalConfigProcessor(null);  "<AssertPlaceHolder>"; }
canProcess(String type) { return false; }
[*] target: assertFalse(invalidInternalConfigProcessor.canProcess(null))
[-] pred: org. junit. Assert. assertFalse ( invalidInternalConfigProcessor. canProcess ( null ) )
************************************
************************************
[+] input: testRetainWithUnexpandedObjectField() { SearchHit hit = new SearchHit(1); hit.sourceRef(new BytesArray("{"a.attributes.hardware.correlate_id": 10}")); SearchHitRow row = new SearchHitRow(hit, ""); row.retain(ImmutableMap.of("a.attributes.hardware.correlate_id", ""));  SearchHit expected = new SearchHit(1); expected.sourceRef(new BytesArray("{"a.attributes.hardware.correlate_id": 10}")); "<AssertPlaceHolder>"; }
data() { return hit; }
[*] target: assertEquals(expected, row.data())
[-] pred: org. junit. Assert. assertEquals ( expected, row. data() )
************************************
************************************
[+] input: shouldReturnAddedJsonStringForEmptyJsonWithNewKeyValue() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = "{}"; String expectedJsonEvent = "{"k1":"v1"}"; String jPath = "$.k1"; String updateValue = "v1"; String actual = jsonUpdate.eval(jsonEvent, jPath, updateValue); Assert."<AssertPlaceHolder>"; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }
[*] target: assertEquals(expectedJsonEvent, actual)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonEvent, actual )
************************************
************************************
[+] input: shouldNotBeAbleToBuildSourceIfSourceTypeIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.BOUNDED)}); FlinkKafkaConsumerDaggerSource daggerSource = new FlinkKafkaConsumerDaggerSource(streamConfig, configuration, daggerDeserializer);  "<AssertPlaceHolder>"; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }
[*] target: assertFalse(daggerSource.canBuild())
[-] pred: org. junit. Assert. assertFalse ( daggerSource. canBuild ( ) )
************************************
************************************
[+] input: mp4StscBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4StscBox box = new Mp4StscBox(); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: prueba1() { System.out.println("PRUEBA 1 - The test case is a prototype."); double a = 4.5566; double b = 2.3; double result = calculadora1.getSuma(a, b); double expected = 6.8566; "<AssertPlaceHolder>"; }
getSuma(double a, double b) { return a + b; }
[*] target: assertEquals(expected, result, 0)
[-] pred: org. junit. Assert. assertEquals ( expected, result, 0 )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeDataAndRuleRegexMatch2() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "25"); subject.put("verify_aal", "2."); subject.put("userId", "123456"); subject.put("verify_userId", "12345[6|7]"); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: getPrintStackTraceString() { Exception e = new Exception(); String printStackTraceString = ExceptionUtil.getPrintStackTraceString(e); Assert."<AssertPlaceHolder>"; }
getPrintStackTraceString(Throwable e) { StringWriter stringWriter = new StringWriter(); PrintWriter printWriter = new PrintWriter(stringWriter); e.printStackTrace(printWriter); return stringWriter.toString(); }
[*] target: assertNotNull(printStackTraceString)
[-] pred: org. junit. Assert. assertNotNull ( printStackTraceString )
************************************
************************************
[+] input: testFailureDueToInconsistencyAndExceptionMixed() { DBConnection otherDBConnection2 = mock(DBConnection.class); when(otherDBConnection2.getDatabaseName()).thenReturn("ZZZ DB"); correctnessTest = new ComparisonTest( openSearchConnection, new DBConnection[] {otherDbConnection, otherDBConnection2});  DBResult openSearchResult = new DBResult( "OpenSearch", asList(new Type("firstname", "text")), asList(new Row(asList("John")))); DBResult otherResult = new DBResult("Other", asList(new Type("firstname", "text")), Collections.emptyList());  when(openSearchConnection.select(anyString())).thenReturn(openSearchResult); when(otherDbConnection.select(anyString())).thenReturn(otherResult); when(otherDBConnection2.select(anyString())) .thenThrow(new RuntimeException("Unsupported feature"));  TestReport expected = new TestReport(); expected.addTestCase( new FailedTestCase( 1, "SELECT * FROM accounts", asList(openSearchResult, otherResult), "Unsupported feature;")); TestReport actual = correctnessTest.verify(querySet("SELECT * FROM accounts")); "<AssertPlaceHolder>"; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format("%s: %s", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { User result = userServiceImpl.selectUserByToken("token"); Assert."<AssertPlaceHolder>"; }
selectUserByToken(String token) { User user = selectOneByExample(UserExample.newBuilder() .build() .createCriteria() .andTokenEqualTo(token) .toExample() ); return user; }
[*] target: assertEquals(null, result)
[-] pred: org. junit. Assert. assertEquals ( null, result )
************************************
************************************
[+] input: multiplyByTwo2() { Class2 class2Mock = Mockito.mock(Class2.class); Mockito.when(class2Mock.getValue()).thenReturn(5);  Class1 class1 = new Class1(); int result = class1.multiplyByTwo2(class2Mock); Assert."<AssertPlaceHolder>"; }
multiplyByTwo2(Class2 class2){ if(class2 == null){ logger.error("The parameter should not be null"); System.exit(1); } return class2.getValue() * 2; }
[*] target: assertEquals(10, result)
[-] pred: org. junit. Assert. assertEquals ( 10, result )
************************************
************************************
[+] input: shouldFetchParsedValueForFieldForFieldDescriptorOfTypeDouble() { double actualValue = 2.0D;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("cash_amount"); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor); Object value = doubleHandler.parseObject(String.valueOf(actualValue));  "<AssertPlaceHolder>"; }
parseObject(Object field) { return Double.parseDouble(getValueOrDefault(field, "0")); }
[*] target: assertEquals(actualValue, value)
[-] pred: org. junit. Assert. assertEquals ( actualValue, value )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeDataAndNullRule() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "25"); subject.put("verify_aal", null); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: translate() { String input = TestUtils.resourceToString("pluscal/translate/test.tla"); String expected = TestUtils.resourceToString("pluscal/translate/test_expected.tla"); String actual = PlusCalTranslator.translate(input).getTranslated(); "<AssertPlaceHolder>"; }
translate(@NotNull String text) { List<String> lines = text.lines().collect(Collectors.toList());  ToolIO.reset(); ToolIO.setMode(ToolIO.TOOL); PcalParams.resetParams();  List<String> translated = trans.performTranslation(lines); if (translated != null) { return new Result(true, Arrays.asList(ToolIO.getAllMessages()), StringUtil.joinLines(translated)); }  return new Result(false, Arrays.asList(ToolIO.getAllMessages()), null); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldNotBeEmptyWhenInternalSourceExist() { ArrayList<InternalSourceConfig> internalSourceConfigs = new ArrayList<>(); internalSourceConfigs.add(new InternalSourceConfig("outputField", "value", "type", null)); defaultPostProcessorConfig = new PostProcessorConfig(null, null, internalSourceConfigs);  "<AssertPlaceHolder>"; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }
[*] target: assertFalse(defaultPostProcessorConfig.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( defaultPostProcessorConfig. isEmpty() )
************************************
************************************
[+] input: testEncodeAsBytes() { AbstractEntityEncoder e = createEntityEncoder(); byte[] actualBytes = e.encodeEntityAsBytes(createEntity()); byte[] expectedBytes = new byte[] { 112, 101, 114, 115, 111, 110, 91, 110, 97, 109, 101, 61, 79, 116, 116, 111, 93 }; "<AssertPlaceHolder>"; }
encodeEntityAsBytes(Entity entity) { return StringUtil.toBytes(encodeEntityAsString(entity), encoding); }
[*] target: assertArrayEquals(expectedBytes, actualBytes)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedBytes, actualBytes )
************************************
************************************
[+] input: testMd5() { String str = "a-string-to-hash"; String expectedValue = "c6b763343cfeada6a408772701329d30";  String actualValue = SignatureMethodEnum.MD5.calcSign(str);  "<AssertPlaceHolder>"; }
calcSign(String str) { return signCalculator.calc(str); }
[*] target: assertEquals(expectedValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualValue )
************************************
************************************
[+] input: shouldCheckIfQueryIsInvalidInCaseOfAllVariableValues() { when(sourceConfig.getVariables()).thenReturn("order_number,customer_id"); when(sourceConfig.getPattern()).thenReturn(""{\\"key\\": \\"%s\\", \\"other_key\\": \\"%s\\"}"");  Row row = new Row(2); Row inputData = new Row(2); inputData.setField(1, ""); inputData.setField(0, ""); row.setField(0, inputData); row.setField(1, new Row(1)); RowManager rowManager = new RowManager(row);  endpointHandler = new EndpointHandler(meterStatsManager, errorReporter, inputProtoClasses, getColumnNameManager(new String[]{"order_number", "customer_id"}), descriptorManager); Object[] endpointOrQueryVariablesValues = endpointHandler .getVariablesValue(rowManager, Constants.ExternalPostProcessorVariableType.REQUEST_VARIABLES, sourceConfig.getVariables(), resultFuture);  boolean queryInvalid = endpointHandler.isQueryInvalid(resultFuture, rowManager, sourceConfig.getVariables(), endpointOrQueryVariablesValues); "<AssertPlaceHolder>"; verify(meterStatsManager, times(1)).markEvent(ExternalSourceAspects.EMPTY_INPUT); }
isQueryInvalid(ResultFuture<Row> resultFuture, RowManager rowManager, String variables, Object[] variablesValue) { if (!StringUtils.isEmpty(variables) && (Arrays.asList(variablesValue).isEmpty() || Arrays.stream(variablesValue).allMatch(""::equals))) { LOGGER.warn("Could not populate any request variable. Skipping external calls"); meterStatsManager.markEvent(ExternalSourceAspects.EMPTY_INPUT); resultFuture.complete(singleton(rowManager.getAll())); return true; } return false; }
[*] target: assertTrue(queryInvalid)
[-] pred: org. junit. Assert. assertTrue ( queryInvalid )
************************************
************************************
[+] input: ParseException { final JSONObject expected = new JSONObject(ImmutableMap.of("commands", new JSONArray()));  final JSONObject actual = parser.emptyCommands();  "<AssertPlaceHolder>"; }
emptyCommands() throws IOException, ParseException { return parse(this.getClass().getClassLoader().getResourceAsStream(EMPTY_FILE)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testClearErrorStatus() { Cell c = new Cell(); c.addErrorStatus(new Status("error", IStatus.ERROR)); c.clearErrorStatus(); "<AssertPlaceHolder>"; }
getErrorStatus() { return m_errorStatus; }
[*] target: assertNull(c.getErrorStatus())
[-] pred: org. junit. Assert. assertNull ( c. getErrorStatus() )
************************************
************************************
[+] input: testRestartConnectionWithSsl_CreatesSslSocket() { ProxyServer server = mock(ProxyServer.class); Socket socket = mock(Socket.class); when(socket.getInetAddress()).thenReturn(InetAddress.getLoopbackAddress()); AtomicBoolean calledCreateSSLSocket = new AtomicBoolean(); ConnectionHandler connection = new ConnectionHandler(server, socket) { @Override void createSSLSocket() { calledCreateSSLSocket.set(true); } }; connection.setThread(mock(Thread.class)); connection.restartConnectionWithSsl();  "<AssertPlaceHolder>"; }
restartConnectionWithSsl() { try { createSSLSocket(); runConnection(true); } catch (IOException ioException) { PGException pgException = PGException.newBuilder( "Failed to create SSL socket: " + (ioException.getMessage() == null ? ioException.getClass().getName() : ioException.getMessage())) .setSeverity(Severity.FATAL) .setSQLState(SQLState.InternalError) .build(); try { handleError(pgException); } catch (Exception ignore) { } throw pgException; } }
[*] target: assertTrue(calledCreateSSLSocket.get())
[-] pred: org. junit. Assert. assertTrue ( calledCreateSSLSocket. get ( ) )
************************************
************************************
[+] input: InvalidProtocolBufferException { String protoClass = "org.raystack.dagger.consumer.TestRepeatedEnumMessage"; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestRepeatedEnumMessage.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  TestRepeatedEnumMessage repeatedEnumMessage = TestRepeatedEnumMessage.newBuilder() .addTestEnumsValue(0) .addTestEnumsValue(0) .build();  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(repeatedEnumMessage.getDescriptor(), repeatedEnumMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = "{"test_enums":["UNKNOWN","UNKNOWN"]}"; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  "<AssertPlaceHolder>"; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }
[*] target: assertEquals(expectedJsonPayload, actualJsonPayload)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonPayload, actualJsonPayload )
************************************
************************************
[+] input: getByNullKey() { JapCache japCache = new JapLocalCache(); String res = (String) japCache.get(null); Assert."<AssertPlaceHolder>"; }
get(String key) { if (StrUtil.isEmpty(key)) { return null; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); if (null == cacheObj || cacheObj.isExpired()) { return null; } return cacheObj.getData(); } finally { readLock.unlock(); } }
[*] target: assertNull(res)
[-] pred: org. junit. Assert. assertNull ( res )
************************************
************************************
[+] input: shouldNotProcessIfParameterPlacedInHeader() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.MESSAGE); when(httpSinkConfig.getSinkHttpParameterPlacement()).thenReturn(HttpSinkParameterPlacementType.HEADER);  parameterizedURIRequest = new ParameterizedUriRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedURIRequest.canProcess();  "<AssertPlaceHolder>"; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.QUERY; }
[*] target: assertFalse(canProcess)
[-] pred: org. junit. Assert. assertFalse ( canProcess )
************************************
************************************
[+] input: rtspInterleavedTransportToString() { String expect = "RTP/AVP/TCP;unicast;interleaved=0-1"; RtspInterleavedTransport transport = new RtspInterleavedTransport(); transport.setProtocol("RTP/AVP/TCP"); transport.setCastMode("unicast"); transport.setInterleaved1(0); transport.setInterleaved2(1); "<AssertPlaceHolder>"; }
toString() { if (this.protocol == null || this.protocol.equals("")) { throw new RtspCommException("protocol of RtspTransport is null or empty"); } if (this.castMode == null || this.castMode.equals("")) { throw new RtspCommException("castMode of RtspTransport is null or empty"); } List<String> res = new ArrayList<>(); res.add(this.protocol); res.add(this.castMode);  if (this.ssrc != null && !this.ssrc.equals("")) { res.add(String.format("ssrc=%s", this.ssrc)); } if (this.mode != null && !this.mode.equals("")) { res.add(String.format("mode="%s"", this.mode)); } return String.join(";", res); }
[*] target: assertEquals(expect, transport.toString())
[-] pred: org. junit. Assert. assertEquals ( expect, transport. toString ( ) )
************************************
************************************
[+] input: testEnsureTypeWithItself() { final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT); RexBuilder builder = new RexBuilder(typeFactory);  RexNode node =  new RexLiteral( Boolean.TRUE, typeFactory.createSqlType(SqlTypeName.BOOLEAN), SqlTypeName.BOOLEAN); RexNode ensuredNode = builder.ensureType( typeFactory.createSqlType(SqlTypeName.BOOLEAN), node, true);  "<AssertPlaceHolder>"; }
ensureType( RelDataType type, RexNode node, boolean matchNullability) { RelDataType targetType = type; if (matchNullability) { targetType = matchNullability(type, node); }  if (targetType.getSqlTypeName() == SqlTypeName.ANY && (!matchNullability || targetType.isNullable() == node.getType().isNullable())) { return node; }  //    if (!node.getType().equals(targetType)) { //      if (node instanceof RexInputRef) { //        RexInputRef ref = (RexInputRef) node; //        return new RexInputRef(ref.getIndex(), targetType); //      } else { //        return makeCast(targetType, node); //      } //    } return node; }
[*] target: assertEquals(node, ensuredNode)
[-] pred: org. junit. Assert. assertEquals ( node, ensuredNode )
************************************
************************************
[+] input: Exception { TestAbstractDAGVisitor visitor = new TestAbstractDAGVisitor(); visitor.putEdge(new TestAbstractDAGNode("1", "1"), new TestAbstractDAGNode("2", "2")); visitor.putEdge(new TestAbstractDAGNode("1", "1"), new TestAbstractDAGNode("3", "3")); visitor.putEdge(new TestAbstractDAGNode("1", "1"), new TestAbstractDAGNode("4", "4")); visitor.putEdge(new TestAbstractDAGNode("2", "2"), new TestAbstractDAGNode("5", "5")); visitor.putEdge(new TestAbstractDAGNode("3", "3"), new TestAbstractDAGNode("6", "6")); visitor.putEdge(new TestAbstractDAGNode("4", "4"), new TestAbstractDAGNode("7", "7")); visitor.putEdge(new TestAbstractDAGNode("5", "5"), new TestAbstractDAGNode("8", "8")); visitor.putEdge(new TestAbstractDAGNode("5", "5"), new TestAbstractDAGNode("9", "9")); visitor.putEdge(new TestAbstractDAGNode("8", "8"), new TestAbstractDAGNode("10", "10")); visitor.putEdge(new TestAbstractDAGNode("9", "9"), new TestAbstractDAGNode("10", "10")); visitor.putEdge(new TestAbstractDAGNode("7", "7"), new TestAbstractDAGNode("10", "10")); visitor.putEdge(new TestAbstractDAGNode("10", "10"), new TestAbstractDAGNode("2", "2")); Assert."<AssertPlaceHolder>"; }
hasCircle() { Set<String> allMarked = new HashSet<>(); Set<String> stackMarked = new HashSet<>(); try { for (Map.Entry<String, N> node : nodes.entrySet()) { if (allMarked.contains(node.getKey())) { continue; } markNode(allMarked, stackMarked, node.getKey()); } return false; } catch (Exception ex) { return true; } }
[*] target: assertTrue(visitor.hasCircle())
[-] pred: org. junit. Assert. assertTrue ( visitor. hasCircle ( ) )
************************************
************************************
[+] input: testAsciiConvertionWithoutSpecialChar() { // Arrange String emailAddress = "someone@example.com";  // Act String convertedAddress = BEANS.get(MailIDNConverter.class).toASCII(emailAddress);  // Assert "<AssertPlaceHolder>"; }
toASCII(String email) { return convertToCharset(email, IDN::toASCII); }
[*] target: assertEquals(emailAddress, convertedAddress)
[-] pred: org. junit. Assert. assertEquals ( emailAddress, convertedAddress )
************************************
************************************
[+] input: selectSingle() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert."<AssertPlaceHolder>"; log.info("mysqlUserEntity : {}", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }
[*] target: assertNotNull(mysqlUserEntity)
[-] pred: org. junit. Assert. assertNotNull ( mysqlUserEntity )
************************************
************************************
[+] input: moveKingInChaos4() { Board board = Board.getBoard("r6r/Pp1pkppp/1PP2nbN/n7/BB2P3/q4N2/Pp1P2PP/R2Q1RK1 b - -"); board.inCheck = true; System.out.println(board); Engine engine = new Engine(); final int positions = engine.countAllMoves(board, 1); System.out.println("NUMBER OF POSITIONS: " + positions); Assert."<AssertPlaceHolder>"; }
countAllMoves(final Board board, final int depth) { return countAllMoves(board, depth, 1000); }
[*] target: assertEquals(5, positions)
[-] pred: org. junit. Assert. assertEquals ( 5, positions )
************************************
************************************
[+] input: shouldHaveNoError() { NoError noError = new NoError(); "<AssertPlaceHolder>"; }
hasException() { return false; }
[*] target: assertFalse(noError.hasException())
[-] pred: org. junit. Assert. assertFalse ( noError. hasException() )
************************************
************************************
[+] input: readSE() { byte[] data = new byte[]{0x0F, 0x00}; ExpGolomb expGolomb = new ExpGolomb(data); int actual = expGolomb.readSE(); "<AssertPlaceHolder>"; }
readSE() { int value = this.readUE(); int sign = ((value & 0x01) << 1) - 1; return ((value >> 1) + (value & 0x01)) * sign; }
[*] target: assertEquals(15, actual)
[-] pred: org. junit. Assert. assertEquals ( 15, actual )
************************************
************************************
[+] input: toByteArray() { RequestItem requestItem = new RequestItem(); requestItem.setSpecificationType((byte) 0x12); requestItem.setLengthOfFollowing((byte) 0x10); requestItem.setSyntaxId(ESyntaxID.S7ANY); requestItem.setVariableType(EParamVariableType.BYTE); requestItem.setCount(7); requestItem.setDbNumber(7); requestItem.setArea(EArea.DATA_BLOCKS); requestItem.setByteAddress(3); requestItem.setBitAddress(1); ReadWriteParameter readWriteParameter = new ReadWriteParameter(); readWriteParameter.setFunctionCode(EFunctionCode.READ_VARIABLE); readWriteParameter.setItemCount((byte) 0x01); readWriteParameter.getRequestItems().add(requestItem); byte[] actual = readWriteParameter.toByteArray(); byte[] expect = new byte[]{(byte) 0x04, (byte) 0x01, (byte) 0x12, (byte) 0x10, (byte) 0x10, (byte) 0x02, (byte) 0x00, (byte) 0x07, (byte) 0x00, (byte) 0x07, (byte) 0x84, (byte) 0x00, (byte) 0x00, (byte) 0x19}; "<AssertPlaceHolder>"; }
toByteArray() { int length = 2 + this.requestItems.stream().mapToInt(RequestBaseItem::byteArrayLength).sum(); ByteWriteBuff buff = ByteWriteBuff.newInstance(length) .putByte(this.functionCode.getCode()) .putByte(this.itemCount); for (RequestBaseItem requestItem : this.requestItems) { buff.putBytes(requestItem.toByteArray()); } return buff.getData(); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: testDefaultEChartsSerializer() { EChartsSerializer serializer = new EChartsSerializer(); Object object = new MarkArea2DDataItem() .setStartPoint(new MarkArea2DDataItemDim().setName("start")) .setEndPoint(new MarkArea2DDataItemDim().setName("end")); JsonElement actual = serializer.toJsonTree(object); JsonElement expected = JsonParser.parseString("[{'name': 'start'}, {'name': 'end'}]"); "<AssertPlaceHolder>"; }
toJsonTree(Object src) { return gson.toJsonTree(src); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: SQLException { Mockito.when(mockResults.getBoolean("writable")).thenReturn(true); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert."<AssertPlaceHolder>"; }
isWritable() { return writable; }
[*] target: assertTrue(table.isWritable())
[-] pred: org. junit. Assert. assertTrue ( table. isWritable() )
************************************
************************************
[+] input: testTimestamp() {  final TimestampType dataType = new TimestampType(TEST_SCALE); TimestampBlockBuilder timestampBlockBuilder = new TimestampBlockBuilder(TEST_SIZE, dataType, new ExecutionContext());  // write List<String> values = IntStream.range(0, TEST_SIZE) .mapToObj( i -> RandomTimeGenerator.generateDatetimeString(1) ) .map( l -> R.nextInt() % 4 == 0 ? null : (String) l.get(0) ) .map(String.class::cast) .collect(Collectors.toList());  values.forEach(timestampBlockBuilder::writeString); Block block = timestampBlockBuilder.build();  // serialization & deserialization TimestampBlockEncoding encoding = new TimestampBlockEncoding(); SliceOutput sliceOutput = new DynamicSliceOutput(1 << 10); encoding.writeBlock(sliceOutput, block);  Slice slice = sliceOutput.slice(); Block block1 = encoding.readBlock(slice.getInput());  IntStream.range(0, TEST_SIZE) .forEach( i -> { boolean isEqual = block.equals(i, block1, i); Assert."<AssertPlaceHolder>"; } ); }
equals(int position, Block other, int otherPosition) { position = realPositionOf(position); if (other instanceof TimestampBlock) { return equalsInner(position, other.cast(TimestampBlock.class), otherPosition); } else if (other instanceof TimestampBlockBuilder) { return equalsInner(position, (TimestampBlockBuilder) other, otherPosition); } else { throw new AssertionError(); } }
[*] target: assertTrue(isEqual)
[-] pred: org. junit. Assert. assertTrue ( isEqual )
************************************
************************************
[+] input: convertMultiLineString_WithRedundantSpaces_ShouldConvert() { String wkt = "MULTILINESTRING ( (10 10, 20 20, 10   40 ) , (40 40, 30 30, 40 20, 30 10))"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"MultiLineString", "coordinates":" + " [[[10,10],[20,20],[10,40]],[[40,40],[30,30],[40,20],[30,10]]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: convertMultiPolygon_WithRedundantSpaces_ShouldConvert() { String wkt = "MULTIPOLYGON ( ((30 20, 45 40, 10 40, 30 20) ) , ((15 5, 40 10, 10 20, 5 10, 15 5)))"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"MultiPolygon", "coordinates":" + " [[[[30,20],[45,40],[10,40],[30,20]]],[[[15,5],[40,10],[10,20],[5,10],[15,5]]]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: readRecombination1() { int[] data = new int[]{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; int[] expect = new int[]{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; List<Integer> src = Arrays.stream(data).boxed().collect(Collectors.toList()); List<S7ComGroup> recombination = S7SequentialGroupAlg.readRecombination(src, 240 - 14, 5, 12); int[] actual = recombination.stream().flatMap(x -> x.getItems().stream()) .mapToInt(S7ComItem::getRipeSize).toArray(); "<AssertPlaceHolder>"; }
readRecombination(List<Integer> src, int targetSize, int extraSize, int threshold) { List<S7ComGroup> groupList = new LinkedList<>(); S7ComGroup group = new S7ComGroup(); groupList.add(group); int sum = 0; for (int i = 0; i < src.size(); i++) { int number = src.get(i); int offset = 0; while (number > 0) { S7ComItem item = new S7ComItem(i, src.get(i), offset, 0, extraSize, threshold); if (sum + number + item.getExtraSize() > targetSize) { item.setRipeSize(targetSize - sum - item.getExtraSize()); } else { item.setRipeSize(number); } sum += item.getTotalLength(); number -= item.getRipeSize(); offset += item.getRipeSize(); group.add(item); if (sum + threshold >= targetSize) { group = new S7ComGroup(); groupList.add(group); sum = 0; } } } return groupList.stream().filter(x -> !x.getItems().isEmpty()).collect(Collectors.toList()); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: convertLineString_NegativeCoordinates_ShouldConvert() { String wkt = "LINESTRING (-30 10, 10 30, 40 40)"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"LineString", "coordinates": [[-30,10],[10,30],[40,40]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: ketoneTest() { ContextRx contextRx = new ContextRx(JoH.hexStringToByteArray("02040006")); "<AssertPlaceHolder>"; }
ketone() { return mealType == 0x06; }
[*] target: assertTrue(contextRx.ketone())
[-] pred: org. junit. Assert. assertTrue ( contextRx. ketone() )
************************************
************************************
[+] input: testApplyFindsRootCause() { /** * Lots of frameworks wrap exceptions with runtime exceptions. The root * cause is always more important. */ SeverityComparator a = new SeverityComparator(); final Throwable root = new Exception(); Throwable next = root; for (int i = 0; i < 7; i++) { next = new RuntimeException(next); } Throwable reduced = a.apply(next); "<AssertPlaceHolder>"; }
apply(final Throwable chain) { //Matches the j.u.f.UnaryOperator<Throwable> interface. int limit = 0; Throwable root = chain; Throwable high = null; Throwable normal = null; for (Throwable cause = chain; cause != null; cause = cause.getCause()) { root = cause;  //Find the deepest cause.  //Find the deepest normal occurrance. if (isNormal(cause)) { normal = cause; }  //Find the deepest error that happened before a normal occurrance. if (normal == null && cause instanceof Error) { high = cause; }  //Deal with excessive cause chains and cyclic throwables. if (++limit == (1 << 16)) { break; //Give up. } } return high != null ? high : normal != null ? normal : root; }
[*] target: assertEquals(root, reduced)
[-] pred: org. junit. Assert. assertEquals ( root, reduced )
************************************
************************************
[+] input: SQLException { Mockito.when(mockResults.getBoolean("is_logging_errors")).thenReturn(true); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert."<AssertPlaceHolder>"; }
isLoggingErrors() { return loggingErrors; }
[*] target: assertTrue(table.isLoggingErrors())
[-] pred: org. junit. Assert. assertTrue ( table. isLoggingErrors() )
************************************
************************************
[+] input: test_serialized_deserialize_focus_test_config() { GinkgoRunConfigurationOptions configOptions = new GinkgoRunConfigurationOptions(); configOptions.setGinkgoExecutable("ginkgo"); configOptions.setWorkingDir("/workspace"); configOptions.setEnvData(EnvironmentVariablesData.DEFAULT); configOptions.setGinkgoAdditionalOptions("-race"); configOptions.setGinkgoScope(GinkgoScope.FOCUS); configOptions.setFocusTestExpression("books"); configOptions.setTestNames(Arrays.asList("books")); configOptions.setGoToolOptions("build tool options"); Element element = new Element("ginkgo_config");  GinkgoSerializationUtil.writeXml(element, configOptions); GinkgoRunConfigurationOptions result = GinkgoSerializationUtil.readXml(element);  "<AssertPlaceHolder>"; }
readXml(@NotNull Element element) { GinkgoRunConfigurationOptions ginkgoRunConfigurationOptions = new GinkgoRunConfigurationOptions(); ginkgoRunConfigurationOptions.setGinkgoExecutable(read(element, GINKGO_EXECUTABLE)); ginkgoRunConfigurationOptions.setWorkingDir(read(element, WORKING_DIR)); ginkgoRunConfigurationOptions.setEnvData(EnvironmentVariablesData.readExternal(element)); ginkgoRunConfigurationOptions.setGinkgoAdditionalOptions(read(element, GINKGO_ADDITIONAL_OPTIONS)); ginkgoRunConfigurationOptions.setGoToolOptions(read(element, GO_TOOL_OPTIONS)); ginkgoRunConfigurationOptions.setGinkgoScope(readScope(element)); ginkgoRunConfigurationOptions.setFocusTestExpression(read(element, FOCUS_EXPRESSION)); ginkgoRunConfigurationOptions.setPackageName(read(element, PACKAGE_NAME)); ginkgoRunConfigurationOptions.setTestNames(readTestNames(element));  return ginkgoRunConfigurationOptions; }
[*] target: assertEquals(configOptions, result)
[-] pred: org. junit. Assert. assertEquals ( configOptions, result )
************************************
************************************
[+] input: containsNullKey() { JapCache japCache = new JapLocalCache(); boolean containsKey = japCache.containsKey(null); Assert."<AssertPlaceHolder>"; }
containsKey(String key) { if (StrUtil.isEmpty(key)) { return false; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); return null != cacheObj && !cacheObj.isExpired(); } finally { readLock.unlock(); } }
[*] target: assertFalse(containsKey)
[-] pred: org. junit. Assert. assertFalse ( containsKey )
************************************
************************************
[+] input: createEsJsonWebKeyJson() { String jwkJson = JwkUtil.createEsJsonWebKeyJson("jap-jwks-keyid", TokenSigningAlg.ES256); Assert."<AssertPlaceHolder>"; }
createEsJsonWebKeyJson(String keyId, TokenSigningAlg signingAlg) { EllipticCurveJsonWebKey jwk = createEsJsonWebKey(keyId, signingAlg); return jwk.toJson(RsaJsonWebKey.OutputControlLevel.INCLUDE_PRIVATE); }
[*] target: assertNotNull(jwkJson)
[-] pred: org. junit. Assert. assertNotNull ( jwkJson )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeDataAndRuleMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "25"); subject.put("verify_aal", "25"); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: listLocalFilesTest() { List<CdcFile> localFiles = fileSystem.listLocalFiles(); List<String> actualFileList = new ArrayList<>(); for (CdcFile file : localFiles) { actualFileList.add(file.getName()); } List<String> expectFileList = new ArrayList<>(); int n = 15; for (int i = 1; i < n; i++) { expectFileList.add(binlogFilePrefix + String.format("%06d", i)); } boolean expectTrue = ListUtils.isEqualList(expectFileList, actualFileList); Assert."<AssertPlaceHolder>"; }
listLocalFiles() { return localFileSystem.listFiles(); }
[*] target: assertTrue(expectTrue)
[-] pred: org. junit. Assert. assertTrue ( expectTrue )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeDataAndEmptyRule() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "25"); subject.put("verify_aal", ""); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: testVetoExceptionHtmlMessage() { TestFormWithMandatoryField form = new TestFormWithMandatoryField(); String htmlErrorMessage = "";  String expectedErrorMessage = HTML.fragment( HTML.div(TEXTS.get("FormEmptyMandatoryFieldsMessage")), HTML.ul(HTML.li(form.getStringField().getFullyQualifiedLabel(IValidateContentDescriptor.LABEL_SEPARATOR)))) .toHtml();  try { form.validateForm(); } catch (VetoException ve) { htmlErrorMessage = ve.getHtmlMessage().toHtml(); }  "<AssertPlaceHolder>"; }
validateForm() { if (!interceptCheckFields()) { VetoException veto = new VetoException("Validate " + getClass().getSimpleName()); veto.consume(); throw veto; } if (!getHandler().onCheckFields()) { VetoException veto = new VetoException("Validate " + getClass().getSimpleName()); veto.consume(); throw veto; }  // check all fields that might be invalid FormFieldErrorCollector collector = createFormFieldErrorCollector(); visit(collector, IFormField.class); collector.firstProblem() .ifPresent(firstProblem -> handleFormErrors(firstProblem, collector.messagesOfInvalidFields(), collector.messagesOfMandatoryFields()));  if (!interceptValidate()) { VetoException veto = new VetoException("Validate " + getClass().getSimpleName()); veto.consume(); throw veto; } if (!getHandler().onValidate()) { VetoException veto = new VetoException("Validate " + getClass().getSimpleName()); veto.consume(); throw veto; } }
[*] target: assertEquals(expectedErrorMessage, htmlErrorMessage)
[-] pred: org. junit. Assert. assertEquals ( expectedErrorMessage, htmlErrorMessage )
************************************
************************************
[+] input: SQLException { VtResultSet input = TestResult.makeTestResult(TestResult.makeTestFields("col|count(*)", "varbinary|decimal"), "a|1", "a|0"); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(input));  AbstractAggregateGen4.AggregateParams aggr1 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateSum, 1); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(0); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(false, Lists.newArrayList(aggr1), false, 0, Lists.newArrayList(groupByParams), null, fp);  Query.Field field1 = Query.Field.newBuilder().setName("col").setType(Query.Type.VARBINARY).build(); Query.Field field2 = Query.Field.newBuilder().setName("count(*)").setType(Query.Type.DECIMAL).build();  VtResultValue value1 = new VtResultValue("a", Query.Type.VARBINARY); VtResultValue value2 = new VtResultValue(BigDecimal.valueOf(1), Query.Type.DECIMAL); List<VtResultValue> vtResultValues = Lists.newArrayList(value1, value2); List<List<VtResultValue>> rows = new ArrayList<>(); rows.add(vtResultValues); VtResultSet result = new VtResultSet(new Query.Field[] {field1, field2}, rows);  VtResultSet res = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList();  Assert."<AssertPlaceHolder>";  fp.rewind(); }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }
[*] target: assertEquals(result, res)
[-] pred: org. junit. Assert. assertEquals ( result, res )
************************************
************************************
[+] input: startingBoard() { Board board = Board.getStartBoard(); final List<Move> legalMoves = board.getLegalMoves(); Assert."<AssertPlaceHolder>"; }
getLegalMoves() { final Piece king = getKing(playerToMove); //better to check for pin from king than discoveries if (inCheck) { final Set<Piece> attackers = attackingKing(king); final List<Move> legalMoves = new ArrayList<>(getMoveList(king)); if (attackers.size() < 2) { final Set<Piece> pinnedToKing = pinnedToKing(king).keySet(); final List<Piece> movableExceptKing = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.contains(piece)) .filter(piece -> !(piece.sameType(PieceType.KING))) .collect(Collectors.toList()); final Piece attacker = new ArrayList<>(attackers).get(0); final Set<Cell> cellsWithCheck = rayOfCheck(king, attacker); if (attacker.sameType(PieceType.PAWN)) { //enPassant can capture a checking pawn movableExceptKing.stream() .filter(piece -> piece.sameType(PieceType.PAWN)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> move.captureMove) .filter(move -> move.captureCell.equals(attacker.position)) .filter(move -> !move.captureCell.equals(move.target)) .forEach(legalMoves::add); } legalMoves.addAll(movableExceptKing.stream() .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> cellsWithCheck.contains(move.target)) .collect(Collectors.toList())); } return legalMoves; } else { final Map<Piece, Piece> pinnedToKing = pinnedToKing(king); final List<Move> normalMoves = playerPieces.get(playerToMove).stream() .filter(piece -> !pinnedToKing.containsKey(piece)) .map(this::getMoveList) .flatMap(Collection::stream) .filter(move -> !illegalEnPassant(move, king)) .collect(Collectors.toList()); final List<Move> pinnedPieceMoves = pinnedToKing.entrySet() .stream() .filter(entry -> !entry.getKey().sameType(PieceType.KNIGHT)) .map(this::getMovesWithinPin) .flatMap(Collection::stream) .collect(Collectors.toList()); normalMoves.addAll(pinnedPieceMoves); return normalMoves; } }
[*] target: assertEquals(20, legalMoves.size())
[-] pred: org. junit. Assert. assertEquals ( 20, legalMoves. size ( ) )
************************************
************************************
[+] input: testSuccess() { when(openSearchConnection.select(anyString())) .thenReturn( new DBResult( "OpenSearch", asList(new Type("firstname", "text")), asList(new Row(asList("John"))))); when(otherDbConnection.select(anyString())) .thenReturn( new DBResult( "Other DB", asList(new Type("firstname", "text")), asList(new Row(asList("John")))));  TestReport expected = new TestReport(); expected.addTestCase(new SuccessTestCase(1, "SELECT * FROM accounts")); TestReport actual = correctnessTest.verify(querySet("SELECT * FROM accounts")); "<AssertPlaceHolder>"; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format("%s: %s", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: hasTypeShouldBeFalseWhenTypeIsEmpty() { HttpSourceConfig httpSourceConfig = new HttpSourceConfig("", "",  "", "", "", "", "", "", "", false, "", "", new HashMap<>(), new HashMap<>(), metricId, false); "<AssertPlaceHolder>"; }
hasType() { return StringUtils.isNotEmpty(type); }
[*] target: assertFalse(httpSourceConfig.hasType())
[-] pred: org. junit. Assert. assertFalse ( httpSourceConfig. hasType() )
************************************
************************************
[+] input: shouldDeleteValueAndReturnAsJsonString() { JsonDelete jsonDelete = new JsonDelete(); String jsonEvent = "{"k1":"v1","k2":"v2"}"; String expectedJsonEvent = "{"k1":"v1"}"; String jPath = "$.k2"; String actual = jsonDelete.eval(jsonEvent, jPath); Assert."<AssertPlaceHolder>"; }
eval(String jsonEvent, String jPath) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).delete(JsonPath.compile(jPath)).jsonString(); }
[*] target: assertEquals(expectedJsonEvent, actual)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonEvent, actual )
************************************
************************************
[+] input: test_DE() { StreetNameGenerator generator = new StreetNameGenerator("DE"); generator.init(context); for (int i = 0; i < 10; i++) { String product = generator.generate(); "<AssertPlaceHolder>"; } generator.close(); }
generate() { return GeneratorUtil.generateNonNull(this); }
[*] target: assertNotNull(product)
[-] pred: org. junit. Assert. assertNotNull ( product )
************************************
************************************
[+] input: testGenerate() { String idCard = ChineseIDCardNumberGenerator.getInstance().generate(); System.err.println(idCard); System.out.println("Verify id result: " + ChineseIDCardUtil.isIDCard(idCard)); "<AssertPlaceHolder>"; if (idCard.charAt(idCard.length()-2)%2 == 0){ System.err.println("女"); } else { System.err.println("男"); } }
generate() { Map<String, String> code = getAreaCode(); String areaCode = code.keySet().toArray(new String[0])[RandomUtils .nextInt(0, code.size())] + StringUtils.leftPad((RandomUtils.nextInt(0, 9998) + 1) + "", 4, "0");  String birthday = new SimpleDateFormat("yyyyMMdd").format(randomDate()); String randomCode = String.valueOf(1000 + RandomUtils.nextInt(0, 999)) .substring(1); String pre = areaCode + birthday + randomCode; String verifyCode = getVerifyCode(pre); String result = pre + verifyCode;  return result; }
[*] target: assertNotNull(idCard)
[-] pred: org. junit. Assert. assertNotNull ( idCard )
************************************
************************************
[+] input: FilterException { Message message = new Message(key.toByteArray(), this.testMessage.toByteArray(), "topic1", 0, 100); filter = new JexlFilter(kafkaConsumerConfig, firehoseInstrumentation); FilteredMessages filteredMessages = filter.filter(Arrays.asList(message)); FilteredMessages expectedMessages = new FilteredMessages(); expectedMessages.addToValidMessages(message); "<AssertPlaceHolder>"; }
filter(List<Message> messages) throws FilterException { FilteredMessages filteredMessages = new FilteredMessages(); for (Message message : messages) { try { Object data = (filterDataSourceType.equals(FilterDataSourceType.KEY)) ? message.getLogKey() : message.getLogMessage(); Object obj = MethodUtils.invokeStaticMethod(Class.forName(protoSchema), "parseFrom", data); if (evaluate(obj)) { filteredMessages.addToValidMessages(message); } else { filteredMessages.addToInvalidMessages(message); } } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { throw new FilterException("Failed while filtering EsbMessages", e); } } return filteredMessages;  }
[*] target: assertEquals(expectedMessages, filteredMessages)
[-] pred: org. junit. Assert. assertEquals ( expectedMessages, filteredMessages )
************************************
************************************
[+] input: createToken() { when(httpServletRequestMock.getHeader("x-forwarded-for")).thenReturn("127.0.0.1"); when(httpServletRequestMock.getHeader("user-agent")).thenReturn("ua"); String token = JapSsoUtil.createToken("userId", "userName", request); System.out.println(token); Assert."<AssertPlaceHolder>"; }
createToken(Object userId, String username, JapHttpRequest request) { return createSsoToken(userId, username, request).getToken(); }
[*] target: assertNotNull(token)
[-] pred: org. junit. Assert. assertNotNull ( token )
************************************
************************************
[+] input: shouldNotProcessIfParameterPlacementDisabled() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.DISABLED);  parameterizedURIRequest = new ParameterizedUriRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedURIRequest.canProcess();  "<AssertPlaceHolder>"; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.QUERY; }
[*] target: assertFalse(canProcess)
[-] pred: org. junit. Assert. assertFalse ( canProcess )
************************************
************************************
[+] input: TestPlugin() { Conversable conversable = new FakeConversable(); ConversationContext context = new ConversationContext(null, conversable, new HashMap<Object, Object>()); "<AssertPlaceHolder>"; }
getPlugin() { return plugin; }
[*] target: assertEquals(null, context.getPlugin())
[-] pred: org. junit. Assert. assertEquals ( null, context. getPlugin() )
************************************
************************************
[+] input: IOException { RocketMQPartitionSplitSerializer serializer = new RocketMQPartitionSplitSerializer(); RocketMQSourceSplit expected = new RocketMQSourceSplit("test-split-serialization", "taobaodaily", 256, 100, 300); RocketMQSourceSplit actual = serializer.deserialize(serializer.getVersion(), serializer.serialize(expected)); "<AssertPlaceHolder>"; }
serialize(RocketMQSourceSplit split) throws IOException { try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); DataOutputStream out = new DataOutputStream(byteArrayOutputStream)) { out.writeUTF(split.getTopic()); out.writeUTF(split.getBrokerName()); out.writeInt(split.getQueueId()); out.writeLong(split.getStartingOffset()); out.writeLong(split.getStoppingOffset()); out.flush(); return byteArrayOutputStream.toByteArray(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldNotProvideJsonDeserializerWhenSchemaTypeIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn("PROTO");  JsonDeserializerProvider provider = new JsonDeserializerProvider(streamConfig);  "<AssertPlaceHolder>"; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }
[*] target: assertFalse(provider.canProvide())
[-] pred: org. junit. Assert. assertFalse ( provider. canProvide() )
************************************
************************************
[+] input: shouldFetchDefaultValueIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("cash_amount");  /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(DOUBLE).named("cash_amount") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); DoubleHandler doubleHandler = new DoubleHandler(fieldDescriptor);  Object actualValue = doubleHandler.parseSimpleGroup(simpleGroup);  "<AssertPlaceHolder>"; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getDouble(fieldName, 0); } else { /* return default value */ return 0.0D; } }
[*] target: assertEquals(0.0D, actualValue)
[-] pred: org. junit. Assert. assertEquals ( 0.0D, actualValue )
************************************
************************************
[+] input: shouldNotBeAbleToBuildSourceIfSourceTypeIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.BOUNDED)}); KafkaDaggerSource daggerSource = new KafkaDaggerSource(streamConfig, configuration, daggerDeserializer);  "<AssertPlaceHolder>"; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }
[*] target: assertFalse(daggerSource.canBuild())
[-] pred: org. junit. Assert. assertFalse ( daggerSource. canBuild ( ) )
************************************
************************************
[+] input: findByCategoryType() { ProductCategory result = mapper.findByCategoryType(new Integer(7)); Assert."<AssertPlaceHolder>"; }
findByCategoryType(Integer categoryType);  /** * 查询，并指定要查询的字段 * @param categoryName * @return */ @Select("select * from product_category where category_name = #{categoryName}
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: shouldFetchParsedValueForFieldForFieldDescriptorOfTypeInteger() { int actualValue = 2;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("cancel_reason_id"); IntegerHandler integerHandler = new IntegerHandler(fieldDescriptor); Object value = integerHandler.parseObject(String.valueOf(actualValue));  "<AssertPlaceHolder>"; }
parseObject(Object field) { return Integer.parseInt(getValueOrDefault(field, "0")); }
[*] target: assertEquals(actualValue, value)
[-] pred: org. junit. Assert. assertEquals ( actualValue, value )
************************************
************************************
[+] input: shouldReturnFalseIfFieldDescriptorOtherThanEnumTypeIsPassed() { Descriptors.FieldDescriptor otherFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("order_number"); EnumHandler enumHandler = new EnumHandler(otherFieldDescriptor);  "<AssertPlaceHolder>"; }
canHandle() { return fieldDescriptor.getJavaType() == Descriptors.FieldDescriptor.JavaType.ENUM && !fieldDescriptor.isRepeated(); }
[*] target: assertFalse(enumHandler.canHandle())
[-] pred: org. junit. Assert. assertFalse ( enumHandler. canHandle() )
************************************
************************************
[+] input: testDogs() { List<String> input = Arrays.asList( "The dogs bark", "The dog barks", "The dog sleeps");  List<String> expectedResult = Arrays.asList( "The dog barks", "The dog sleeps", "The dogs bark");  List<String> actualResult = new ArrayList<>(input); Collections.sort(actualResult, m_collatorProvider.getInstance(new Locale("en")));  "<AssertPlaceHolder>"; }
getInstance(Locale locale) { // always return a cloned instance return (Collator) THREAD_LOCAL.get() .computeIfAbsent(locale, this::create) .clone(); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: shouldBeEmptyWhenExternalSourceHasEmptyConfig() { ArrayList<HttpSourceConfig> http = new ArrayList<>(); ArrayList<EsSourceConfig> es = new ArrayList<>(); ArrayList<PgSourceConfig> pg = new ArrayList<>(); ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, new ArrayList<>()); defaultPostProcessorConfig = new PostProcessorConfig(externalSourceConfig, null, null);  "<AssertPlaceHolder>"; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }
[*] target: assertTrue(defaultPostProcessorConfig.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( defaultPostProcessorConfig. isEmpty() )
************************************
************************************
[+] input: testGenerateOdd() { String generatedName = ChineseNameGenerator.getInstance().generateOdd(); "<AssertPlaceHolder>"; System.err.println(generatedName); }
generateOdd() { return genFirstName() + ChineseCharUtils.getOneOddChar(); }
[*] target: assertNotNull(generatedName)
[-] pred: org. junit. Assert. assertNotNull ( generatedName )
************************************
************************************
[+] input: convertMultiPolygon_OnePolygonHaveHoles_ShouldConvert() { String wkt = "MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20),(20 30, 35 35, 30 20, 20 30)),((15 5, 40 10," + " 10 20, 5 10, 15 5)))"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"MultiPolygon", "coordinates":" + " [[[[30,20],[45,40],[10,40],[30,20]],[[20,30],[35,35],[30,20],[20,30]]],[[[15,5],[40,10],[10,20],[5,10],[15,5]]]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: SQLException { VtResultSet input = TestResult.makeTestResult(TestResult.makeTestFields("col1|col2", "varbinary|varbinary"), "a|aaa", "a|0", "a|1"); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(input));  AbstractAggregateGen4.AggregateParams aggr1 = new AbstractAggregateGen4.AggregateParams(Engine.AggregateOpcodeG4.AggregateSumDistinct, 1, "sum(distinct col2)"); GroupByParams groupByParams = new GroupByParams(); groupByParams.setKeyCol(0); OrderedAggregateGen4Engine oa = new OrderedAggregateGen4Engine(true, Lists.newArrayList(aggr1), false, 0, Lists.newArrayList(groupByParams), null, fp); VtResultSet result = (VtResultSet) oa.execute(VtContext.background(), null, null, false).getVtRowList();  VtResultSet wantResult = TestResult.makeTestResult(TestResult.makeTestFields("col1|sum(distinct col2)", "varbinary|decimal"), "a|1"); Assert."<AssertPlaceHolder>"; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { IExecute.ExecuteMultiShardResponse resultResponse = this.input.execute(ctx, vcursor, bindVariableMap, wantFields); VtResultSet result = (VtResultSet) resultResponse.getVtRowList();  VtResultSet out = new VtResultSet(convertFields(result.getFields(), super.preProcess, super.aggregates, super.aggrOnEngine), new ArrayList<>());  // This code is similar to the one in StreamExecute. List<VtResultValue> current = null; List<VtResultValue> curDistincts = null; for (List<VtResultValue> row : result.getRows()) { if (current == null) { Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } boolean equal = this.keysEqual(current, row); if (equal) { Pair<List<VtResultValue>, List<VtResultValue>> pair = merge(result.getFields(), current, row, curDistincts, super.collations, super.aggregates); current = pair.getLeft(); curDistincts = pair.getRight(); continue; } out.getRows().add(current); Pair<List<VtResultValue>, List<VtResultValue>> pair = convertRow(row, super.preProcess, super.aggregates, super.aggrOnEngine); current = pair.getLeft(); curDistincts = pair.getRight(); } if (current != null) { List<VtResultValue> finalValues = convertFinal(current, super.aggregates); out.getRows().add(finalValues); } return new IExecute.ExecuteMultiShardResponse(out.truncate(super.truncateColumnCount)); }
[*] target: assertEquals(wantResult, result)
[-] pred: org. junit. Assert. assertEquals ( wantResult, result )
************************************
************************************
[+] input: shouldReturnEmptyJsonAsJsonString() { JsonDelete jsonDelete = new JsonDelete(); String jsonEvent = "{"k1":"v1","k2":["value1","value2","value3"]}"; String expectedJsonEvent = "{}"; String jPath = "$..*"; String actual = jsonDelete.eval(jsonEvent, jPath); Assert."<AssertPlaceHolder>"; }
eval(String jsonEvent, String jPath) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).delete(JsonPath.compile(jPath)).jsonString(); }
[*] target: assertEquals(expectedJsonEvent, actual)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonEvent, actual )
************************************
************************************
[+] input: InterruptedException { long createdTimestamp = System.currentTimeMillis(); LocalFileMetadata metadata = new LocalFileMetadata("/tmp", "/tmp/a/random-file-name-1", createdTimestamp, 100L, 100L); Thread.sleep(100); boolean shouldRotate = rotatingPolicy.shouldRotate(metadata); Assert."<AssertPlaceHolder>"; }
shouldRotate(LocalFileMetadata metadata) { return System.currentTimeMillis() - metadata.getCreatedTimestampMillis() >= maxRotatingDurationMillis; }
[*] target: assertFalse(shouldRotate)
[-] pred: org. junit. Assert. assertFalse ( shouldRotate )
************************************
************************************
[+] input: shouldReturnFalseIfFieldDescriptorOtherThanMapTypeIsPassed() { Descriptors.FieldDescriptor otherFieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("order_number"); MapHandler mapHandler = new MapHandler(otherFieldDescriptor);  "<AssertPlaceHolder>"; }
canHandle() { return fieldDescriptor.isMapField(); }
[*] target: assertFalse(mapHandler.canHandle())
[-] pred: org. junit. Assert. assertFalse ( mapHandler. canHandle() )
************************************
************************************
[+] input: toHexArray_Multi() { byte[] actual = HexUtil.toHexArray("1a6BdE8c"); byte[] expected = new byte[]{(byte) 0x1A, (byte) 0x6B, (byte) 0xDE, (byte) 0x8C}; "<AssertPlaceHolder>"; }
toHexArray(String src) { if (src == null || src.length() == 0) { // 字符串不能为null或长度不能为0 throw new HexParseException("The string cannot be null or the length cannot be 0"); } if ((src.length() & -src.length()) == 1) { // 输入的字符串个数必须为偶数 throw new HexParseException("The number of strings entered must be an even number"); } if (!src.matches(REGEX)) { // 字符串内容必须是[0-9|a-f|A-F] throw new HexParseException("The string content must be [0-9|a-f|A-F]."); }  char[] chars = src.toCharArray(); final byte[] out = new byte[chars.length >> 1]; for (int i = 0; i < chars.length; i = i + 2) { int high = Character.digit(chars[i], 16) << 4; int low = Character.digit(chars[i + 1], 16); out[i / 2] = (byte) ((high | low) & 0xFF); } return out; }
[*] target: assertArrayEquals(expected, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expected, actual )
************************************
************************************
[+] input: testNumericParsingNaN() { String value = "NaN"; byte[] byteResult = new byte[8]; ByteConverter.int2(byteResult, 4, (short) 0xC000);  byte[] stringResult = {'N', 'a', 'N'};  NumericParser parser = new NumericParser(value);  validate(parser, byteResult, stringResult, stringResult); "<AssertPlaceHolder>"; validateCreateText(stringResult, Oid.NUMERIC, value); }
getItem() { return this.item; }
[*] target: assertEquals(value, parser.getItem())
[-] pred: org. junit. Assert. assertEquals ( value, parser. getItem() )
************************************
************************************
[+] input: Exception { LocalMapPartitionFileMeta fileMeta = StorageTestUtils.createLocalMapPartitionFileMeta();  File tmpFile = temporaryFolder.newFile(); try (DataOutputStream output = new DataOutputStream(new FileOutputStream(tmpFile))) { fileMeta.writeTo(output); }  LocalMapPartitionFileMeta recovered; try (DataInputStream input = new DataInputStream(new FileInputStream(tmpFile))) { recovered = LocalMapPartitionFileMeta.readFrom(input); }  "<AssertPlaceHolder>"; }
readFrom(DataInput dataInput) throws IOException { int storageVersion = dataInput.readInt(); return readFrom(dataInput, storageVersion); }
[*] target: assertEquals(fileMeta, recovered)
[-] pred: org. junit. Assert. assertEquals ( fileMeta, recovered )
************************************
************************************
[+] input: SQLException { SystemRef system = createDbTestSystem(); Connection connection = EnvironmentUtil.connectDb(system); try { connection = EnvironmentUtil.connectDb(system); "<AssertPlaceHolder>"; } finally { connection.close(); HSQLUtil.shutdown(system.getProperty("url"), HSQLUtil.DEFAULT_USER, HSQLUtil.DEFAULT_PASSWORD); } }
connectDb(SystemRef system) throws ConnectFailedException { if (!system.isDb()) { throw ExceptionFactory.getInstance().configurationError("Not a database: " + system.getName() + " in environment " + system.getEnvironment().getName()); } Map<String, String> pp = system.getProperties(); String readOnlySpec = pp.get("readOnly"); boolean readOnly = (!StringUtil.isEmpty(readOnlySpec) && Boolean.parseBoolean(readOnlySpec)); return DBUtil.connect(pp.get("url"), pp.get("driver"), pp.get("user"), pp.get("password"), readOnly); }
[*] target: assertNotNull(connection)
[-] pred: org. junit. Assert. assertNotNull ( connection )
************************************
************************************
[+] input: testParsingCustomAgent() { UserAgent testUserAgent = UserAgents .create() .withUiLayer(UiLayer.HTML) .withUiDeviceType(UiDeviceType.MOBILE) .withUiEngineType(UiEngineType.ANDROID) .withUiSystem(UiSystem.ANDROID) .withDeviceId("Mozilla/5.0 (Linux; U; Android 4.0.3; ko-kr; LG-L160L Build/IML74K) AppleWebkit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30") .build(); DefaultUserAgentParser parser = new DefaultUserAgentParser(); String id = testUserAgent.createIdentifier(parser);  UserAgent parsedAgent = UserAgents.createByIdentifier(parser, id); "<AssertPlaceHolder>"; }
createIdentifier(UserAgent userAgent) { String uiDeviceId = userAgent.getUiDeviceId(); if (uiDeviceId.contains(DELIMITER)) { uiDeviceId = uiDeviceId.replaceAll("\" + DELIMITER, "_"); LOG.warn("Character which is used as delimiter has been found in uiDeviceId. Replaced with '_'. Old uiDeviceId: {}. New uiDeviceId: {}", userAgent.getUiDeviceId(), uiDeviceId); } return StringUtility.concatenateTokens( userAgent.getUiLayer().getIdentifier(), DELIMITER, userAgent.getUiDeviceType().getIdentifier(), DELIMITER, userAgent.getUiEngineType().getIdentifier(), DELIMITER, userAgent.getUiSystem().getIdentifier(), DELIMITER, uiDeviceId); }
[*] target: assertEquals(testUserAgent, parsedAgent)
[-] pred: org. junit. Assert. assertEquals ( testUserAgent, parsedAgent )
************************************
************************************
[+] input: shouldGetParentRow() { Row parentRow = Row.of(new Row(3), new Row(4)); RowManager rowManager = new RowManager(parentRow);  Row expected = Row.of(new Row(3), new Row(4)); "<AssertPlaceHolder>"; }
getAll() { return parentRow; }
[*] target: assertEquals(expected, rowManager.getAll())
[-] pred: org. junit. Assert. assertEquals ( expected, rowManager. getAll() )
************************************
************************************
[+] input: shouldReturnMandatoryFields() { HashMap<String, Object> expectedMandatoryFields = new HashMap<>(); expectedMandatoryFields.put("host", host); expectedMandatoryFields.put("port", port); expectedMandatoryFields.put("endpoint_pattern", endpointPattern); expectedMandatoryFields.put("capacity", capacity); expectedMandatoryFields.put("connect_timeout", connectTimeout); expectedMandatoryFields.put("retry_timeout", retryTimeout); expectedMandatoryFields.put("socket_timeout", socketTimeout); expectedMandatoryFields.put("stream_timeout", streamTimeout); expectedMandatoryFields.put("fail_on_errors", failOnErrors); expectedMandatoryFields.put("outputMapping", outputMappingHashMap); EsSourceConfig esSourceConfig = getValidEsSourceConfigBuilder().createEsSourceConfig(); HashMap<String, Object> actualMandatoryFields = esSourceConfig.getMandatoryFields(); "<AssertPlaceHolder>"; }
getMandatoryFields() { HashMap<String, Object> mandatoryFields = new HashMap<>(); mandatoryFields.put("host", host); mandatoryFields.put("port", port); mandatoryFields.put("endpoint_pattern", endpointPattern); mandatoryFields.put("capacity", capacity); mandatoryFields.put("connect_timeout", connectTimeout); mandatoryFields.put("retry_timeout", retryTimeout); mandatoryFields.put("socket_timeout", socketTimeout); mandatoryFields.put("stream_timeout", streamTimeout); mandatoryFields.put("fail_on_errors", failOnErrors); mandatoryFields.put("outputMapping", outputMapping);  return mandatoryFields; }
[*] target: assertEquals(expectedMandatoryFields, actualMandatoryFields)
[-] pred: org. junit. Assert. assertEquals ( expectedMandatoryFields, actualMandatoryFields )
************************************
************************************
[+] input: generateRandomDate() { Date randomDate = ChineseIDCardNumberGenerator.randomDate(); System.err.println(randomDate); "<AssertPlaceHolder>"; }
randomDate() { Calendar calendar = Calendar.getInstance(); calendar.set(1970, 1, 1); long earlierDate = calendar.getTime().getTime(); calendar.set(2000, 1, 1); long laterDate = calendar.getTime().getTime();  long chosenDate = RandomUtils.nextLong(earlierDate, laterDate);  return new Date(chosenDate); }
[*] target: assertNotNull(randomDate)
[-] pred: org. junit. Assert. assertNotNull ( randomDate )
************************************
************************************
[+] input: encodesKeyToBase64() { String actual = message.getSerializedKey();  String expected = "CgMxMjMSA2FiYw==";  "<AssertPlaceHolder>"; }
getSerializedKey() { return encodedSerializedStringFrom(logKey); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: no_DoTable_Hit_DoDb_Hit_WildDoTable_Keep() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb("full_src_1, rpl, dutf8"); replicaMeta.setIgnoreDb("full_src_1, rpl, dutf8"); replicaMeta.setDoTable(""); replicaMeta.setIgnoreTable("full_src_1.t1, full_src_1.t2"); replicaMeta.setWildDoTable("d%.tb\\_charset%, d%.col\\_charset%"); replicaMeta.setWildIgnoreTable("d%.tb\\_charset%, d%.col\\_charset%"); replicaMeta.setRewriteDb(""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema("dutf8"); rowChange.setTable("tb_charset_gbk"); Assert."<AssertPlaceHolder>"; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }
[*] target: assertFalse(filter.ignoreEvent(rowChange))
[-] pred: org. junit. Assert. assertFalse ( filter. ignoreEvent ( rowChange ) )
************************************
************************************
[+] input: shouldReturnFalseForInsertOrUpdateMode() { MongoUpdateRequestHandler mongoUpdateRequestHandler = new MongoUpdateRequestHandler(MongoSinkMessageType.PROTOBUF, jsonSerializer, MongoSinkRequestType.UPSERT, "customer_id", "message");  "<AssertPlaceHolder>"; }
canCreate() { return mongoSinkRequestType == MongoSinkRequestType.UPDATE_ONLY; }
[*] target: assertFalse(mongoUpdateRequestHandler.canCreate())
[-] pred: org. junit. Assert. assertFalse ( mongoUpdateRequestHandler. canCreate() )
************************************
************************************
[+] input: test_generate() {  // 1. Arrange String hllCode = Objects.requireNonNull(FileReaderUtil.getResourceFileAsString("lexer/code.ck")); List<Token> tokens = Lexer.tokenize(hllCode); AstNode oldAst = new Parser(tokens).parse(); SvgAstNode newAst = new Transformer().transform(oldAst);  // 2. Act String result = new CodeGenerator().generate(newAst);  // 3. Assert "<AssertPlaceHolder>";  // 4. Log System.out.println(result); saveToFile(result, "src/test/resources/output/code.svg"); }
generate(SvgAstNode node) { return printAst(node); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: FilterException { Message message1 = new Message(testKeyProto1.toByteArray(), testMessageProto1.toByteArray(), "topic1", 0, 100); Message message2 = new Message(testKeyProto2.toByteArray(), testMessageProto2.toByteArray(), "topic1", 0, 101); Map<String, String> filterConfigs = new HashMap<>(); filterConfigs.put("FILTER_DATA_SOURCE", "message"); filterConfigs.put("FILTER_ESB_MESSAGE_FORMAT", "PROTOBUF"); filterConfigs.put("FILTER_JSON_SCHEMA", ""); filterConfigs.put("FILTER_SCHEMA_PROTO_CLASS", TestMessage.class.getName()); filterConfig = ConfigFactory.create(FilterConfig.class, filterConfigs); jsonFilter = new JsonFilter(stencilClient, filterConfig, firehoseInstrumentation); FilteredMessages expectedMessages = new FilteredMessages(); expectedMessages.addToValidMessages(message1); expectedMessages.addToValidMessages(message2); List<Message> inputMessages = Arrays.asList(message1, message2); FilteredMessages filteredMessages = jsonFilter.filter(inputMessages); "<AssertPlaceHolder>"; }
filter(List<Message> messages) throws FilterException { FilteredMessages filteredMessages = new FilteredMessages(); for (Message message : messages) { byte[] data = (filterConfig.getFilterDataSource().equals(KEY)) ? message.getLogKey() : message.getLogMessage(); String jsonMessage = deserialize(data); if (evaluate(jsonMessage)) { filteredMessages.addToValidMessages(message); } else { filteredMessages.addToInvalidMessages(message); } } return filteredMessages; }
[*] target: assertEquals(expectedMessages, filteredMessages)
[-] pred: org. junit. Assert. assertEquals ( expectedMessages, filteredMessages )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeDataAndRuleRegexMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "25"); subject.put("verify_aal", "2."); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: testIsParallelizable_unique() { RegexStringGenerator regexStringGenerator = new RegexStringGenerator(); regexStringGenerator.setUnique(true); "<AssertPlaceHolder>"; }
isParallelizable() { return !isUnique(); }
[*] target: assertFalse(regexStringGenerator.isParallelizable())
[-] pred: org. junit. Assert. assertFalse ( regexStringGenerator. isParallelizable() )
************************************
************************************
[+] input: save() { ProductInfo productInfo = new ProductInfo(); productInfo.setProductId("123457"); productInfo.setProductName("肉包子"); productInfo.setProductPrice(new BigDecimal(3.0)); productInfo.setProductStock(100); productInfo.setProductDescription("刚蒸的包子"); productInfo.setProductIcon("http://xxxx.jpg"); productInfo.setProductStatus(ProductStatusEnum.UP.getCode()); productInfo.setCategoryType(2);  ProductInfo result = productService.save(productInfo); Assert."<AssertPlaceHolder>"; }
save(ProductInfo productInfo) { return repository.save(productInfo); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: hasTypeShouldBeFalseWhenTypeIsNull() { pgSourceConfig = getPgSourceConfigBuilder() .setType(null) .createPgSourceConfig(); "<AssertPlaceHolder>"; }
hasType() { return StringUtils.isNotEmpty(type); }
[*] target: assertFalse(pgSourceConfig.hasType())
[-] pred: org. junit. Assert. assertFalse ( pgSourceConfig. hasType() )
************************************
************************************
[+] input: rangeQueryPointTest() { TreeIndex<Point> treeIndex = new STRTreeIndex<>(); treeIndex.insert(points);  List<Point> result = treeIndex.query(new Envelope(110, 120, 30, 40)); "<AssertPlaceHolder>"; }
size() { return rTree.size(); }
[*] target: assertEquals(2, result.size())
[-] pred: org. junit. Assert. assertEquals ( 2, result. size ( ) )
************************************
************************************
[+] input: IOException { List<String> expect = new ArrayList<>(); List<String> actual = new ArrayList<>(); int n = 11; for (int i = 1; i < n; i++) { String fileName = BinlogFileUtil.getBinlogFilePrefix(group, stream) + String.format(".%06d", i); expect.add(fileName); File f = fileSystem.newFile(fileName); f.createNewFile(); }  // 测试后缀不匹配场景 String fileName = String.format("%06d", 10) + ".tmp"; File f = fileSystem.newFile(fileName); f.createNewFile(); fileName = String.format("%05d", 10); f = fileSystem.newFile(fileName); f.createNewFile(); // 测试前缀不匹配场景 fileName = "random" + String.format("%06d", 10); f = fileSystem.newFile(fileName); f.createNewFile();  List<CdcFile> fileList = fileSystem.listFiles(); for (CdcFile cdcFile : fileList) { actual.add(cdcFile.getName()); } boolean res = ListUtils.isEqualList(expect, actual); Assert."<AssertPlaceHolder>"; }
listFiles() { List<CdcFile> res = new ArrayList<>();  List<File> fileList = BinlogFileUtil.listLocalBinlogFiles(fullPath, group, stream); for (File f : fileList) { CdcFile cdcFile = new CdcFile(f.getName(), this); cdcFile.setLocation("LOCAL"); res.add(cdcFile); }  res.sort(CdcFile::compareTo); return res; }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: test() { // extract(year from col_date)  final int positionCount = context.getExecutorChunkLimit(); final int nullCount = 20; final int lowerBound = 0; // 1970-01-01 final int upperBound = 365 * 50; // days final SqlOperator operator = TddlOperatorTable.EXTRACT;  List<DataType<?>> inputTypes = ImmutableList.of(DataTypes.DateType);  RexNode root = REX_BUILDER.makeCall( TYPE_FACTORY.createSqlType(SqlTypeName.BIGINT), operator, ImmutableList.of( REX_BUILDER.makeLiteral("YEAR"), REX_BUILDER.makeInputRef(TYPE_FACTORY.createSqlType(SqlTypeName.DATE), 0) ));  InputRefTypeChecker inputRefTypeChecker = new InputRefTypeChecker(inputTypes); root = root.accept(inputRefTypeChecker);  Rex2VectorizedExpressionVisitor converter = new Rex2VectorizedExpressionVisitor(context, inputTypes.size());  VectorizedExpression expression = root.accept(converter);  MutableChunk preAllocatedChunk = MutableChunk.newBuilder(positionCount) .addEmptySlots(inputTypes) .addEmptySlots(converter.getOutputDataTypes()) .build();  // build input decimal block DateBlock inputBlock = generateDateBlock(positionCount, nullCount, lowerBound, upperBound); Chunk inputChunk = new Chunk(positionCount, inputBlock);  LongBlock outputBlock = (LongBlock) BlockUtils.createBlock(DataTypes.LongType, inputChunk.getPositionCount());  preAllocatedChunk.setSelection(null); preAllocatedChunk.setSelectionInUse(false); preAllocatedChunk.setSlotAt(inputBlock, 0); preAllocatedChunk.setSlotAt(outputBlock, expression.getOutputIndex()); preAllocatedChunk.setBatchSize(positionCount);  EvaluationContext evaluationContext = new EvaluationContext(preAllocatedChunk, context); expression.eval(evaluationContext);  for (int i = 0; i < inputChunk.getPositionCount(); i++) { Object actual = outputBlock.getObject(i); Object expected = inputBlock.isNull(i) ? null : ((OriginalDate) inputBlock.getDate(i)).getMysqlDateTime().getYear();  Assert."<AssertPlaceHolder>"; } }
eval(EvaluationContext ctx) { evalChildren(ctx); MutableChunk chunk = ctx.getPreAllocatedChunk(); int batchSize = chunk.batchSize(); boolean isSelectionInUse = chunk.isSelectionInUse(); int[] sel = chunk.selection();  // output block RandomAccessBlock outputVectorSlot = chunk.slotIn(outputIndex, outputDataType); long[] output = (outputVectorSlot.cast(LongBlock.class)).longArray();  // date block RandomAccessBlock inputVectorSlot = chunk.slotIn(children[1].getOutputIndex(), children[1].getOutputDataType());  // when the interval unit is null boolean[] outputNulls = outputVectorSlot.nulls(); if (isConstOperandNull) { outputVectorSlot.setHasNull(true); for (int i = 0; i < batchSize; i++) { outputNulls[i] = true; } return; }  // handle nulls VectorizedExpressionUtils.mergeNulls(chunk, outputIndex, children[1].getOutputIndex());  if (inputVectorSlot instanceof DateBlock) { long[] packedLongs = inputVectorSlot.cast(DateBlock.class).getPacked();  switch (intervalType) { case INTERVAL_YEAR: { // for year if (isSelectionInUse) { for (int i = 0; i < batchSize; i++) { int j = sel[i]; long l = packedLongs[j]; output[j] = (l >> 46) / 13; } } else { for (int i = 0; i < batchSize; i++) { long l = packedLongs[i]; output[i] = (l >> 46) / 13; } } } break; case INTERVAL_MONTH: { // for month if (isSelectionInUse) { for (int i = 0; i < batchSize; i++) { int j = sel[i]; long l = packedLongs[j]; output[j] = (l >> 46) % 13; } } else { for (int i = 0; i < batchSize; i++) { long l = packedLongs[i]; output[i] = (l >> 46) % 13; } } } break; case INTERVAL_DAY: { // for day final long modulo = 1L << 5; if (isSelectionInUse) { for (int i = 0; i < batchSize; i++) { int j = sel[i]; long l = packedLongs[j]; output[j] = (l >> 41) % modulo; } } else { for (int i = 0; i < batchSize; i++) { long l = packedLongs[i]; output[i] = (l >> 41) % modulo; } } } break; default: // for other interval type, use non-vectorized method. boolean isDate = MySQLIntervalType.isDate(intervalType);  // normal processing for datetime value. MysqlDateTime scratchValue = new MysqlDateTime(); for (int i = 0; i < batchSize; i++) { int j = isSelectionInUse ? sel[i] : i;  // parse date value long packedLong = packedLongs[j]; TimeStorage.readDate(packedLong, scratchValue);  // parse interval by sign and mysql datetime value. int sign = isDate ? 1 : (scratchValue.isNeg() ? -1 : 1); long result = doParseInterval(scratchValue, sign); output[j] = result; } } } else if (inputVectorSlot instanceof ReferenceBlock) { // for other interval type, use non-vectorized method. boolean isDate = MySQLIntervalType.isDate(intervalType);  // normal processing for datetime value. for (int i = 0; i < batchSize; i++) { int j = isSelectionInUse ? sel[i] : i;  // parse date value Object timeObj = inputVectorSlot.elementAt(j); MysqlDateTime t; int sign; if (isDate) { t = DataTypeUtil.toMySQLDatetimeByFlags(timeObj, Types.TIMESTAMP, TimeParserFlags.FLAG_TIME_FUZZY_DATE); if (t == null) { outputNulls[j] = true; continue; } sign = 1; } else { t = DataTypeUtil.toMySQLDatetime(timeObj, Types.TIME); if (t == null) { outputNulls[j] = true; continue; } sign = t.isNeg() ? -1 : 1; }  // parse interval by sign and mysql datetime value. long result = doParseInterval(t, sign); output[j] = result; } }  }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testLazyBoolean() { boolean value = false; subject = makeSimpleCallable(value);  "<AssertPlaceHolder>"; }
value() { eval(); Object value = internalValue.get(); if (value == ACTUALLY_NULL) { return null; } return value; }
[*] target: assertEquals(value, subject.value())
[-] pred: org. junit. Assert. assertEquals ( value, subject. value() )
************************************
************************************
[+] input: shouldGetIntValueForValueForGivenKeyInGivenMap() { ArrayList<Row> rows = new ArrayList<>(); Row row1 = new Row(2); int expectedValue = 4; row1.setField(0, "payment_switch"); row1.setField(1, "PB-123456"); Row row2 = new Row(2); row2.setField(0, "weighted_abuse_probability"); row2.setField(1, expectedValue); String givenKey = "weighted_abuse_probability";  rows.add(row1); rows.add(row2);   MapGet mapGet = new MapGet(); Object actualValue = mapGet.eval(rows.toArray(new Row[0]), givenKey);  "<AssertPlaceHolder>"; }
eval(Row[] inputMap, Object key) { List<Row> rows = Arrays.asList(inputMap); Optional<Row> requiredRow = rows.stream().filter(row -> row.getField(0).equals(key)).findFirst(); return requiredRow.map(row -> row.getField(1)).orElse(null); }
[*] target: assertEquals(expectedValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualValue )
************************************
************************************
[+] input: SQLException { Mockito.when(mockResults.getInt("rejectlimit")).thenReturn(50_000); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); int expectedUriLocation = 50_000; Assert."<AssertPlaceHolder>"; }
getRejectLimit() { return rejectLimit; }
[*] target: assertEquals(expectedUriLocation, table.getRejectLimit())
[-] pred: org. junit. Assert. assertEquals ( expectedUriLocation, table. getRejectLimit ( ) )
************************************
************************************
[+] input: testElasticLogsBackendWithoutJenkinsVisualization() { ElasticBackend elasticBackend = new ElasticBackend(); elasticBackend.setElasticLogsBackend(new ElasticLogsBackendWithoutJenkinsVisualization()); Map<String, String> actual = elasticBackend.getOtelConfigurationProperties(); Map<String, String> expected = Collections.singletonMap("otel.logs.exporter", "otlp"); Assert."<AssertPlaceHolder>"; }
getOtelConfigurationProperties() { // FIXME related to https://github.com/jenkinsci/opentelemetry-plugin/issues/683 if (elasticLogsBackend == null) { return Collections.emptyMap(); } else { return elasticLogsBackend.getOtelConfigurationProperties(); } }
[*] target: assertEquals(actual, expected)
[-] pred: org. junit. Assert. assertEquals ( actual, expected )
************************************
************************************
[+] input: createResponse3() { String expect = "Digest username="admin", realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", uri="rtsp://10.3.8.202:554", response="876fcfac745c91bb7dd89faa660891ea""; UsernamePasswordCredential credential = new UsernamePasswordCredential("admin", "12345"); DigestAuthenticator authenticator = new DigestAuthenticator(credential); authenticator.addServerInfoByString("Digest realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", stale="FALSE""); authenticator.addClientInfo("rtsp://10.3.8.202:554", "DESCRIBE"); String actual = authenticator.createResponse(); "<AssertPlaceHolder>"; }
createResponse() { if (this.realm == null || this.realm.equals("")) { throw new AuthenticationException("realm is empty"); } if (this.nonce == null || this.nonce.equals("")) { throw new AuthenticationException("nonce is empty"); } if (this.uri == null || this.uri.equals("")) { throw new AuthenticationException("uri is empty"); } if (this.method == null || this.method.equals("")) { throw new AuthenticationException("method is empty"); } StringBuilder sb = new StringBuilder(); sb.append(DIGEST_NAME).append(" ") .append("username="").append(this.credential.getUsername()).append("", ") .append("realm="").append(this.realm).append("", ") .append("nonce="").append(this.nonce).append("", ") .append("uri="").append(this.uri).append("", "); if (this.qop == null || this.qop.equals("")) { sb.append("response="").append(this.calculateResponseString()).append("""); } else { sb.append("response="").append(this.calculateResponseString()).append("", ") .append("qop=").append(this.qop).append(", ") .append("nc=").append(String.format("%08X", this.nc)).append(", ") .append("cnonce="").append(this.cnonce).append("""); } return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testVerifyRequestRequestWithEmptyDataAndRuleMisMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", ""); subject.put("verify_aal", "25"); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertFalse(flag)
[-] pred: org. junit. Assert. assertFalse ( flag )
************************************
************************************
[+] input: Exception { final DigitalCovidCertificate dgc = (DigitalCovidCertificate) new DigitalCovidCertificate() .withNam(new PersonName().withGn("Martin").withFn("Lindström")) .withDob("1969-11-11") .withV(Arrays.asList(new VaccinationEntry() .withTg("840539006") .withVp("1119349007") .withMp("EU/1/20/1507") .withMa("ORG-100030215") .withDn(Integer.valueOf(1)) .withSd(Integer.valueOf(2)) .withDt(LocalDate.parse("2021-04-17")) .withCo("SE") .withIs("Swedish eHealth Agency") .withCi("01:SE:JKJKHJGHG6768686HGJGH#M")));  String json = dgc.toJSONString();  DigitalCovidCertificate dgc2 = DigitalCovidCertificate.fromJsonString(json);  Assert."<AssertPlaceHolder>"; }
fromJsonString(final String json) throws DGCSchemaException { try { return jsonMapper.readValue(json, DigitalCovidCertificate.class); } catch (final IOException e) { throw new DGCSchemaException("Failed to decode DCC from JSON", e); } }
[*] target: assertEquals(dgc, dgc2)
[-] pred: org. junit. Assert. assertEquals ( dgc, dgc2 )
************************************
************************************
[+] input: testDate() {  final DateType dataType = new DateType(TEST_SCALE); DateBlockBuilder dateBlockBuilder = new DateBlockBuilder(TEST_SIZE, dataType, new ExecutionContext());  // write List<String> values = IntStream.range(0, TEST_SIZE) .mapToObj( i -> RandomTimeGenerator.generateDatetimeString(1) ) .map( l -> R.nextInt() % 4 == 0 ? null : (String) l.get(0) ) .map(String.class::cast) .collect(Collectors.toList());  values.forEach(dateBlockBuilder::writeString); Block block = dateBlockBuilder.build();  // serialization & deserialization DateBlockEncoding encoding = new DateBlockEncoding(); SliceOutput sliceOutput = new DynamicSliceOutput(1 << 10); encoding.writeBlock(sliceOutput, block);  Slice slice = sliceOutput.slice(); Block block1 = encoding.readBlock(slice.getInput());  IntStream.range(0, TEST_SIZE) .forEach( i -> { boolean isEqual = block.equals(i, block1, i); "<AssertPlaceHolder>"; } ); }
equals(int position, Block other, int otherPosition) { position = realPositionOf(position); if (other instanceof DateBlock) { return equalsInner(position, other.cast(DateBlock.class), otherPosition); } else if (other instanceof DateBlockBuilder) { return equalsInner(position, (DateBlockBuilder) other, otherPosition); } else { throw new AssertionError(); } }
[*] target: assertTrue(isEqual)
[-] pred: org. junit. Assert. assertTrue ( isEqual )
************************************
************************************
[+] input: shouldBeEmptyWhenAllConfigsAreEmpty() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(null, null, null, null);  "<AssertPlaceHolder>"; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }
[*] target: assertTrue(externalSourceConfig.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( externalSourceConfig. isEmpty() )
************************************
************************************
[+] input: testVerifyRequestRequestWithNoDataAndRuleMisMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("verify_aal", "25"); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertFalse(flag)
[-] pred: org. junit. Assert. assertFalse ( flag )
************************************
************************************
[+] input: testSuccessWhenOneDBSupportThisQuery() { DBConnection anotherDbConnection = mock(DBConnection.class); when(anotherDbConnection.getDatabaseName()).thenReturn("Another"); correctnessTest = new ComparisonTest( openSearchConnection, new DBConnection[] {otherDbConnection, anotherDbConnection});  when(openSearchConnection.select(anyString())) .thenReturn( new DBResult( "OpenSearch", asList(new Type("firstname", "text")), asList(new Row(asList("John"))))); when(anotherDbConnection.select(anyString())) .thenReturn( new DBResult( "Another DB", asList(new Type("firstname", "text")), asList(new Row(asList("John")))));  TestReport expected = new TestReport(); expected.addTestCase(new SuccessTestCase(1, "SELECT * FROM accounts")); TestReport actual = correctnessTest.verify(querySet("SELECT * FROM accounts")); "<AssertPlaceHolder>"; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format("%s: %s", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: JsonProcessingException { JsonQuery jsonQuery = new JsonQuery(); String jsonEvent = "{"k1":null,"k2":"v2"}"; String jPath = "$.k1"; String result = jsonQuery.eval(jsonEvent, jPath); Assert."<AssertPlaceHolder>"; }
eval(@DataTypeHint("STRING") String jsonEvent, @DataTypeHint("STRING") String jPath) throws JsonProcessingException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); Object jChildObject = JsonPath.using(configuration).parse(jsonEvent).read(JsonPath.compile(jPath)); ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.USE_DEFAULTS); return Objects.isNull(jChildObject) ? null : mapper.writeValueAsString(jChildObject); }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testCreateStringId_NullValue() { String str = null; FixtureStringId id = BEANS.get(IdFactory.class).createInternal(FixtureStringId.class, str); "<AssertPlaceHolder>"; }
createInternal(Class<ID> idClass, Object... values) { try { Method createMethod = lookupCreateMethod(idClass); return idClass.cast(createMethod.invoke(null, values)); } catch (Exception e) { throw BEANS.get(PlatformExceptionTranslator.class).translate(e) .withContextInfo("idClass", idClass.getName()) .withContextInfo("values", Arrays.toString(values)); } }
[*] target: assertNull(id)
[-] pred: org. junit. Assert. assertNull ( id )
************************************
************************************
[+] input: shouldMapEmptyDataWhenFieldIsInvalidInTheQuery() { String[] columnNames = {"invalid"}; String outputProtoKey = "org.raystack.dagger.consumer.TestBookingLogKey"; String outputProtoMessage = "org.raystack.dagger.consumer.TestBookingLogMessage"; ProtoSerializer serializer = new ProtoSerializer(outputProtoKey, outputProtoMessage, columnNames, stencilClientOrchestrator); Row element = new Row(1); element.setField(0, "order_number");  byte[] valueBytes = serializer.serializeValue(element);  "<AssertPlaceHolder>"; }
serializeValue(Row row) { return parse(row, getDescriptor(messageProtoClassName)).toByteArray(); }
[*] target: assertEquals(0, valueBytes.length)
[-] pred: org. junit. Assert. assertEquals ( 0, valueBytes. length )
************************************
************************************
[+] input: testCustomMaxBacklog() { OptionsMetadata options = new OptionsMetadata( new String[] {"-p", "p", "-i", "i", "-max_backlog", "100", "-c", "credentials.json"}); "<AssertPlaceHolder>"; }
getMaxBacklog() { return this.maxBacklog; }
[*] target: assertEquals(100, options.getMaxBacklog())
[-] pred: org. junit. Assert. assertEquals ( 100, options. getMaxBacklog() )
************************************
************************************
[+] input: shouldNotBeAbleToBuildSourceIfSourceNameIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.UNBOUNDED)}); KafkaDaggerSource daggerSource = new KafkaDaggerSource(streamConfig, configuration, daggerDeserializer);  "<AssertPlaceHolder>"; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }
[*] target: assertFalse(daggerSource.canBuild())
[-] pred: org. junit. Assert. assertFalse ( daggerSource. canBuild ( ) )
************************************
************************************
[+] input: testInvalidSelectionViaButton() { m_group.selectButton(new AbstractRadioButton<Long>() { }); "<AssertPlaceHolder>"; }
getSelectedButton() { return getButtonFor(getSelectedKey()); }
[*] target: assertNull(m_group.getSelectedButton())
[-] pred: org. junit. Assert. assertNull ( m_group. getSelectedButton() )
************************************
************************************
[+] input: shouldFetchValueForFieldForFieldDescriptorOfTypeFloat() { float actualValue = 5.1f;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("amount_paid_by_cash"); FloatHandler floatHandler = new FloatHandler(fieldDescriptor); Object value = floatHandler.parseObject(actualValue);  "<AssertPlaceHolder>"; }
parseObject(Object field) { return Float.parseFloat(getValueOrDefault(field, "0")); }
[*] target: assertEquals(actualValue, value)
[-] pred: org. junit. Assert. assertEquals ( actualValue, value )
************************************
************************************
[+] input: isCallbackNoneResponseType() { boolean res = Oauth2Util.isCallback(request, new OAuthConfig() .setResponseType(Oauth2ResponseType.NONE)); Assert."<AssertPlaceHolder>"; }
isCallback(JapHttpRequest request, OAuthConfig oAuthConfig) { if (oAuthConfig.getResponseType() == Oauth2ResponseType.CODE) { String code = request.getParameter("code"); return !StrUtil.isEmpty(code); } else if (oAuthConfig.getResponseType() == Oauth2ResponseType.TOKEN) { String accessToken = request.getParameter("access_token"); return !StrUtil.isEmpty(accessToken); } return false; }
[*] target: assertFalse(res)
[-] pred: org. junit. Assert. assertFalse ( res )
************************************
************************************
[+] input: shouldReturnMultipleEmptyBlackListStatusCodesAsEmptyList() { String inputRetryStatusCodeBlacklist = ",,,,,"; List<Integer> statusCodesAsList = MongoSinkClientUtil.getStatusCodesAsList(inputRetryStatusCodeBlacklist); "<AssertPlaceHolder>"; }
getStatusCodesAsList(String mongoRetryStatusCodeBlacklist) { try { return Arrays .stream(mongoRetryStatusCodeBlacklist.split(",")) .map(String::trim) .filter(s -> (!s.isEmpty())) .map(Integer::parseInt) .collect(Collectors.toList()); } catch (NumberFormatException e) { throw new IllegalArgumentException("Status code must be an integer"); } }
[*] target: assertEquals(0, statusCodesAsList.size())
[-] pred: org. junit. Assert. assertEquals ( 0, statusCodesAsList. size ( ) )
************************************
************************************
[+] input: testElasticLogsBackendWithJenkinsVisualization() { ElasticBackend elasticBackend = new ElasticBackend(); elasticBackend.setElasticLogsBackend(new ElasticLogsBackendWithJenkinsVisualization()); Map<String, String> actual = elasticBackend.getOtelConfigurationProperties(); Map<String, String> expected = Collections.singletonMap("otel.logs.exporter", "otlp"); Assert."<AssertPlaceHolder>"; }
getOtelConfigurationProperties() { // FIXME related to https://github.com/jenkinsci/opentelemetry-plugin/issues/683 if (elasticLogsBackend == null) { return Collections.emptyMap(); } else { return elasticLogsBackend.getOtelConfigurationProperties(); } }
[*] target: assertEquals(actual, expected)
[-] pred: org. junit. Assert. assertEquals ( actual, expected )
************************************
************************************
[+] input: testTerribleHashing() {  // Packet destined for node 3 when(packet.getSourceId()).thenReturn(4); when(packet.getDestinationId()).thenReturn(3); when(packet.getHash(eq(4), anyInt())).thenReturn(3);  boolean thrown = false; try { device4identity.receiveFromIntermediary(packet); } catch (RuntimeException e) { thrown = true; } "<AssertPlaceHolder>";  }
receiveFromIntermediary(Packet genericPacket) { TcpPacket packet = (TcpPacket) genericPacket; assert(this.identifier == packet.getSourceId());  // Determine source and destination ToR int sourceToR; int destinationToR; if (isWithinExtendedTopology) { sourceToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getSourceId()); destinationToR = Simulator.getConfiguration().getGraphDetails().getTorIdOfServer(packet.getDestinationId()); } else { sourceToR =  packet.getSourceId(); destinationToR = packet.getDestinationId(); }  // Choose a valiant node (tries again if it finds one that is not allowed) int chosen; int i = 0; do { chosen = lowBoundValiantRangeIncl + packet.getHash(this.identifier, i) % valiantRangeSize;  i++; if (i > 10000) { throw new RuntimeException( "Chose a wrong random number more than a 10000 times. This is extremely unlikely to happen; " + "presumably there is an extremely poor hashing function at work." ); } } while (chosen == sourceToR || chosen == destinationToR);  // Log for statistic of valiant balancing if (!flowSeen.contains(packet.getFlowId())) { SimulationLogger.increaseStatisticCounter("VAL_NODE_" + chosen); flowSeen.add(packet.getFlowId()); }  // Create encapsulation ValiantEncapsulation encapsulation = new ValiantEncapsulation( packet, chosen );  // If it is a data acknowledgment, we always go shortest path // This excludes the third part of the three-way handshake, which is supposed to precede the initial data window if (packet.isSYN() || (packet.isACK() && packet.getAcknowledgementNumber() != 1)) { encapsulation.markPassedValiant(); }  // Propagate through the network receiveEncapsulationPassOn(encapsulation);  }
[*] target: assertTrue(thrown)
[-] pred: org. junit. Assert. assertTrue ( thrown )
************************************
************************************
[+] input: shouldFetchDefaultValueIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName("s2_id");  /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named("s2_id") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); LongHandler longHandler = new LongHandler(fieldDescriptor);  Object actualValue = longHandler.parseSimpleGroup(simpleGroup);  "<AssertPlaceHolder>"; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getLong(fieldName, 0); } else { /* return default value */ return 0L; } }
[*] target: assertEquals(0L, actualValue)
[-] pred: org. junit. Assert. assertEquals ( 0L, actualValue )
************************************
************************************
[+] input: InvalidProtocolBufferException { String protoClass = "org.raystack.dagger.consumer.TestMessage"; InternalSourceConfig internalSourceConfig = getInternalSourceConfigForProtoClass(protoClass); SchemaConfig schemaConfig = getSchemaConfigForProtoAndDescriptor(protoClass, TestMessage.getDescriptor());  JsonPayloadFunction jsonPayloadFunction = new JsonPayloadFunction(internalSourceConfig, schemaConfig);  DynamicMessage dynamicMessage = DynamicMessage.parseFrom(commonMessage.getDescriptor(), commonMessage.toByteArray()); RowManager rowManager = getRowManagerForMessage(dynamicMessage);  String expectedJsonPayload = "{"order_number":"order-number-123","order_url":"https://order-url","order_details":"pickup"}"; String actualJsonPayload = (String) jsonPayloadFunction.getResult(rowManager);  "<AssertPlaceHolder>"; }
getResult(RowManager rowManager) { if (jsonRowSerializationSchema == null) { jsonRowSerializationSchema = createJsonRowSerializationSchema(); } return new String(jsonRowSerializationSchema.serialize(rowManager.getInputData())); }
[*] target: assertEquals(expectedJsonPayload, actualJsonPayload)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonPayload, actualJsonPayload )
************************************
************************************
[+] input: IOException { String storeFileType = "JKS"; when(jsonReader.nextString()).thenReturn(storeFileType); DaggerSSLKeyStoreFileTypeAdaptor daggerSSLKeyStoreFileTypeAdaptor = new DaggerSSLKeyStoreFileTypeAdaptor(); String keystoreFileType = daggerSSLKeyStoreFileTypeAdaptor.read(jsonReader); "<AssertPlaceHolder>"; }
read(JsonReader jsonReader) throws IOException { String keyStoreFileType = jsonReader.nextString(); if (Arrays.stream(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SSL_STORE_FILE_TYPE).anyMatch(keyStoreFileType::equals)) { return keyStoreFileType; } else { throw new InvalidConfigurationException(String.format("Configured wrong SOURCE_KAFKA_CONSUMER_CONFIG_SSL_KEYSTORE_TYPE_KEY supported values are %s", Arrays.toString(Constants.SUPPORTED_SOURCE_KAFKA_CONSUMER_CONFIG_SSL_STORE_FILE_TYPE))); } }
[*] target: assertEquals(storeFileType, keystoreFileType)
[-] pred: org. junit. Assert. assertEquals ( storeFileType, keystoreFileType )
************************************
************************************
[+] input: testInvalidateDoesNothing() { Object o = new Object(); subject = new FixedMetadataValue(plugin, o); subject.invalidate(); "<AssertPlaceHolder>"; }
value() { return internalValue; }
[*] target: assertSame(o, subject.value())
[-] pred: org. junit. Assert. assertSame ( o, subject. value() )
************************************
************************************
[+] input: shouldNotBeEmptyWhenAllConfigsArePresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, grpc);  "<AssertPlaceHolder>"; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }
[*] target: assertFalse(externalSourceConfig.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( externalSourceConfig. isEmpty() )
************************************
************************************
[+] input: shouldProperlySerializeMessageToTemplateWithAsItIs() { String template = ""$._all_""; StencilClient stencilClient = StencilClientFactory.getClient(); protoParser = stencilClient.getParser(TestAggregatedSupplyMessage.class.getName()); MessageToTemplatizedJson messageToTemplatizedJson = MessageToTemplatizedJson .create(firehoseInstrumentation, template, protoParser); Message message = new Message(Base64.getDecoder().decode(logKey.getBytes()), Base64.getDecoder().decode(logMessage.getBytes()), "sample-topic", 0, 100);  String serializedMessage = messageToTemplatizedJson.serialize(message); String expectedMessage = "{\n" + "  "window_start_time": "2017-03-20T10:54:00Z",\n" + "  "window_end_time": "2017-03-20T10:55:00Z",\n" + "  "s2_id_level": 13,\n" + "  "s2_id": "3344472187078705152",\n" + "  "vehicle_type": "BIKE",\n" + "  "unique_drivers": "3"\n" + "}"; Assert."<AssertPlaceHolder>"; }
serialize(Message message) throws DeserializerException { try { String jsonMessage; String jsonString; // only supports messages not keys DynamicMessage msg = protoParser.parse(message.getLogMessage()); jsonMessage = JsonFormat.printer().includingDefaultValueFields().preservingProtoFieldNames().print(msg); String finalMessage = httpSinkJsonBodyTemplate; for (String path : pathsToReplace) { if (path.equals(ALL_FIELDS_FROM_TEMPLATE)) { jsonString = jsonMessage; } else { Object element = JsonPath.read(jsonMessage, path.replaceAll(""", "")); jsonString = gson.toJson(element); } finalMessage = finalMessage.replace(path, jsonString); } return finalMessage; } catch (InvalidProtocolBufferException | PathNotFoundException e) { throw new DeserializerException(e.getMessage()); } }
[*] target: assertEquals(expectedMessage, serializedMessage)
[-] pred: org. junit. Assert. assertEquals ( expectedMessage, serializedMessage )
************************************
************************************
[+] input: shouldFetchParsedValueForFieldForFieldDescriptorOfTypeFloat() { float actualValue = 5.1f;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("amount_paid_by_cash"); FloatHandler floatHandler = new FloatHandler(fieldDescriptor); Object value = floatHandler.parseObject(String.valueOf(actualValue));  "<AssertPlaceHolder>"; }
parseObject(Object field) { return Float.parseFloat(getValueOrDefault(field, "0")); }
[*] target: assertEquals(actualValue, value)
[-] pred: org. junit. Assert. assertEquals ( actualValue, value )
************************************
************************************
[+] input: test03Countt() { Parent p = new Parent(); p.setAge(18); p.setName("person"); p.setId("10");  mars.insert(p); long count = mars.estimatedCount(Parent.class); Assert."<AssertPlaceHolder>";  }
setId( String id ) { this.id = id; }
[*] target: assertEquals(1, count)
[-] pred: org. junit. Assert. assertEquals ( 1, count )
************************************
************************************
[+] input: shouldFetchDefaultValueIfFieldNotPresentInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestAggregatedSupplyMessage.getDescriptor().findFieldByName("s2_id");  GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named("some-other-field") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); LongHandler longHandler = new LongHandler(fieldDescriptor);  Object actualValue = longHandler.parseSimpleGroup(simpleGroup);  "<AssertPlaceHolder>"; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getLong(fieldName, 0); } else { /* return default value */ return 0L; } }
[*] target: assertEquals(0L, actualValue)
[-] pred: org. junit. Assert. assertEquals ( 0L, actualValue )
************************************
************************************
[+] input: Exception { SeedSentenceGenerator generator = new SeedSentenceGenerator("license.txt"); generator.init(context); for (int i = 0; i < 10; i++) { String sentence = generator.generate(); "<AssertPlaceHolder>"; } }
generate() { return toString(generateFromNotNullSource()); }
[*] target: assertNotNull(sentence)
[-] pred: org. junit. Assert. assertNotNull ( sentence )
************************************
************************************
[+] input: testGenerate() { String generatedAddress = ChineseAddressGenerator.getInstance() .generate(); System.err.println(generatedAddress); "<AssertPlaceHolder>"; }
generate() { StringBuilder result = new StringBuilder(genProvinceAndCity()); result.append(ChineseCharUtils.genRandomLengthChineseChars(2, 3) + "路"); result.append(RandomUtils.nextInt(1, 8000) + "号"); result .append(ChineseCharUtils.genRandomLengthChineseChars(2, 3) + "小区"); result.append(RandomUtils.nextInt(1, 20) + "单元"); result.append(RandomUtils.nextInt(101, 2500) + "室"); return result.toString(); }
[*] target: assertNotNull(generatedAddress)
[-] pred: org. junit. Assert. assertNotNull ( generatedAddress )
************************************
************************************
[+] input: testPropSerialization() { Prop prop = new Prop(); List<Element> any = prop.getAny(); Element element1 = SardineUtil.createElement(SardineUtil.createQNameWithCustomNamespace("hello")); element1.setTextContent("bla"); any.add(element1);  Element element2 = SardineUtil.createElement(SardineUtil.createQNameWithDefaultNamespace("hello")); element2.setTextContent("bla"); any.add(element2);  prop.setDisplayname("bli");  String xml = SardineUtil.toXml(prop); String expectedXML = "<?xml version="1.0" encoding="utf-8"?>\n" + "<D:prop xmlns:D="DAV:">\n" + "   <s:hello xmlns:s="SAR:">bla</s:hello>\n" + "   <D:hello>bla</D:hello>\n" + "   <D:displayname>bli</D:displayname>\n" + "</D:prop>";  "<AssertPlaceHolder>"; }
toXml(Object jaxbElement) { StringWriter writer = new StringWriter(); try { getSerializer().write(jaxbElement, writer); } catch (Exception e) { throw new RuntimeException(e.getMessage(), e); } return writer.toString(); }
[*] target: assertEquals(expectedXML, xml)
[-] pred: org. junit. Assert. assertEquals ( expectedXML, xml )
************************************
************************************
[+] input: mp4SdtpBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x0E, 0x73, 0x64, 0x74, 0x70, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10 }; Mp4SdtpBox box = new Mp4SdtpBox(this.samples); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: testJoinQueryParametersWithLocaleIT() {  Locale.setDefault(new Locale("it", "IT"));  String joinedQuery = String.format("key1=%s&key2=%s", extensiveDecimalsDouble, highDouble); String buildQuery = UrlBuilder.joinQueryParameters(mockDoubleParameters); "<AssertPlaceHolder>"; }
joinQueryParameters(Map<String, Object> params) { return joinQueryParameters(new StringBuilder(), params).toString(); }
[*] target: assertEquals(joinedQuery, buildQuery)
[-] pred: org. junit. Assert. assertEquals ( joinedQuery, buildQuery )
************************************
************************************
[+] input: shouldUseDefaultSecondsDuringTransformIfSimpleGroupHasGroupTypeTimestampWithSecondsNotInitialized() { Instant currentInstant = Instant.now(); int nanos = currentInstant.getNano(); Row expectedRow = Row.of(0L, nanos);  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("event_timestamp"); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor);  /* adding both nanos and seconds field to the timestamp schema but initializing only for nanos */ GroupType timestampSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named("seconds") .required(INT32).named("nanos") .named("event_timestamp"); SimpleGroup timestampMessage = new SimpleGroup(timestampSchema); timestampMessage.add("nanos", nanos);  MessageType parquetSchema = buildMessage() .addField(timestampSchema) .named("TestBookingLogMessage"); SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add("event_timestamp", timestampMessage);  Row actualRow = (Row) timestampHandler.transformFromParquet(mainMessage);  "<AssertPlaceHolder>"; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }
[*] target: assertEquals(expectedRow, actualRow)
[-] pred: org. junit. Assert. assertEquals ( expectedRow, actualRow )
************************************
************************************
[+] input: testSpacesAndHyphens() { List<String> input = Arrays.asList( "abc_PT", "abc-mno1", "ABC MNO2", "abC NOP", "ABCOP", "abcopp", "ABC PQR", "abc PT", "ABC-PT");  List<String> expectedResult = Arrays.asList( "abc-mno1", "ABC MNO2", "abC NOP", "ABC PQR", "abc PT", "ABC-PT", "abc_PT", "ABCOP", "abcopp");  List<String> actualResult = new ArrayList<>(input); Collections.sort(actualResult, m_collatorProvider.getInstance(new Locale("en")));  "<AssertPlaceHolder>"; }
getInstance(Locale locale) { // always return a cloned instance return (Collator) THREAD_LOCAL.get() .computeIfAbsent(locale, this::create) .clone(); }
[*] target: assertEquals(expectedResult, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: mp4DinfBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x24, 0x64, 0x69, 0x6E, 0x66,  0x00, 0x00, 0x00, 0x1C, 0x64, 0x72, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x75, 0x72, 0x6C, 0x20, 0x00, 0x00, 0x00, 0x01, }; Mp4DinfBox box = new Mp4DinfBox(); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: shouldReturnNullIfValueIsNotPresentInGivenMap() { ArrayList<Row> rows = new ArrayList<>(); Row row1 = new Row(2); int expectedValue = 4; row1.setField(0, "payment_switch"); row1.setField(1, "PB-123456"); Row row2 = new Row(2); row2.setField(0, "weighted_abuse_probability"); row2.setField(1, expectedValue); String givenKey = "abuse_probability";  rows.add(row1); rows.add(row2);  MapGet valueForKeyInMap = new MapGet(); Object actualValue = valueForKeyInMap.eval(rows.toArray(new Row[0]), givenKey);  "<AssertPlaceHolder>"; }
eval(Row[] inputMap, Object key) { List<Row> rows = Arrays.asList(inputMap); Optional<Row> requiredRow = rows.stream().filter(row -> row.getField(0).equals(key)).findFirst(); return requiredRow.map(row -> row.getField(1)).orElse(null); }
[*] target: assertNull(actualValue)
[-] pred: org. junit. Assert. assertNull ( actualValue )
************************************
************************************
[+] input: IOException { ClassLoader classLoader = this.getClass().getClassLoader(); URL resource = classLoader.getResource("test.json"); File f = new File(resource.getPath()); String s = readString(f); StructuredDataEncoder structuredData = new StructuredDataEncoder(s); byte[] msgHash = structuredData.hashStructuredData(); String ownerAddress = "0xE10AA6471B33845FaE88DD7bBeB63c250DA3a639"; String sig = "4f4e0dec5f1d6f99460fea04bc374d96a495d96c0c455d4731902cdbf95525fc77c66ee08346466fe188f521c196f0f06bebb8d1a8df44cb68792514ca24808e2a"; byte[] signatureBytes = Hex.decode(sig); byte v = signatureBytes[64]; Sign.SignatureData sd = new Sign.SignatureData( v, Arrays.copyOfRange(signatureBytes, 0, 32), Arrays.copyOfRange(signatureBytes, 32, 64));  boolean verified = false; for (int i = 0; i < 4; i++) { BigInteger publicKey = Sign.recoverFromSignature( (byte) i, new ECDSASignature( new BigInteger(1, sd.getR()), new BigInteger(1, sd.getS())), msgHash);  if (publicKey != null) { String addressRecovered = Keys.toChecksumAddress(Keys.getAddress(publicKey)); if (addressRecovered.equals(ownerAddress)) { verified = true; break; } } } "<AssertPlaceHolder>"; }
getAddress(byte[] publicKey) { byte[] hash = new Keccak.Digest256().digest(publicKey); return Arrays.copyOfRange(hash, hash.length - 20, hash.length);  // right most 160 bits }
[*] target: assertTrue(verified)
[-] pred: org. junit. Assert. assertTrue ( verified )
************************************
************************************
[+] input: byteArrayLength() { PlcStopParameter parameter = new PlcStopParameter(); "<AssertPlaceHolder>"; }
byteArrayLength() { return 7 + this.lengthPart; }
[*] target: assertEquals(7, parameter.byteArrayLength())
[-] pred: org. junit. Assert. assertEquals ( 7, parameter. byteArrayLength() )
************************************
************************************
[+] input: shouldNotProcessIfParameterPlacedInQuery() { when(httpSinkConfig.getSinkHttpParameterSource()).thenReturn(HttpSinkParameterSourceType.MESSAGE); when(httpSinkConfig.getSinkHttpParameterPlacement()).thenReturn(HttpSinkParameterPlacementType.QUERY);  parameterizedHeaderRequest = new ParameterizedHeaderRequest(statsDReporter, httpSinkConfig, jsonBody, httpSinkRequestMethodType, protoToFieldMapper); boolean canProcess = parameterizedHeaderRequest.canProcess();  "<AssertPlaceHolder>"; }
canProcess() { return httpSinkConfig.getSinkHttpParameterSource() != HttpSinkParameterSourceType.DISABLED && httpSinkConfig.getSinkHttpParameterPlacement() == HttpSinkParameterPlacementType.HEADER; }
[*] target: assertFalse(canProcess)
[-] pred: org. junit. Assert. assertFalse ( canProcess )
************************************
************************************
[+] input: testExecutionSkippedNetworkTaskDoesNotExist() { NetworkTask task = getNetworkTask(); Intent intent = new Intent(); intent.putExtras(task.toBundle()); broadcastReceiver.onReceive(TestRegistry.getContext(), intent); List<LogEntry> entries = logDAO.readAllLogsForNetworkTask(task.getId()); "<AssertPlaceHolder>"; }
onReceive(Context context, Intent intent) { NetworkTask task = new NetworkTask(Objects.requireNonNull(intent.getExtras())); Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Received request for " + task); boolean synchronous = context.getResources().getBoolean(R.bool.worker_synchronous_execution); boolean addToPool = context.getResources().getBoolean(R.bool.worker_add_to_pool); int wakeLockTimeout = context.getResources().getInteger(R.integer.worker_execution_wakelock_timeout) * 1000; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Synchronous execution is " + synchronous); PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wakeLock = null; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Creating ExecutorService"); ExecutorService executorService = Executors.newSingleThreadExecutor(); try { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Acquiring partial wake lock with a timeout of " + wakeLockTimeout + " msec"); wakeLock = Objects.requireNonNull(powerManager).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "KeepItUp:NetworkTaskProcessBroadcastReceiver"); wakeLock.acquire(wakeLockTimeout); TimeBasedSuspensionScheduler timeBasedScheduler = createTimeBasedSuspensionScheduler(context); synchronized (TimeBasedSuspensionScheduler.LOCK) { if (timeBasedScheduler.isRunning()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is running."); if (!timeBasedScheduler.isSuspended()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not suspended."); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is suspended. Skipping execution and rescheduling."); } } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not running."); if (!timeBasedScheduler.isSuspensionActiveAndEnabled()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not active."); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not running but is active. Restarting..."); timeBasedScheduler.start(task); } } } } catch (Exception exc) { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), "Error executing worker", exc); } finally { if (wakeLock != null && synchronous && wakeLock.isHeld()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Releasing partial wake lock"); wakeLock.release(); } Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Shutting down ExecutorService"); executorService.shutdown(); } }
[*] target: assertEquals(0, entries.size())
[-] pred: org. junit. Assert. assertEquals ( 0, entries. size ( ) )
************************************
************************************
[+] input: shouldNotBeEmptyWhenHttpAndEsConfigIsPresent() { ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, null, null);  "<AssertPlaceHolder>"; }
isEmpty() { return (http == null || http.isEmpty()) && (es == null || es.isEmpty()) && (pg == null || pg.isEmpty()) && (grpc == null || grpc.isEmpty()); }
[*] target: assertFalse(externalSourceConfig.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( externalSourceConfig. isEmpty() )
************************************
************************************
[+] input: convertPolygonWithHole_NoRedundantSpaces_ShouldConvert() { String wkt = "POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10),(20 30, 35 35, 30 20, 20 30))"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"Polygon", "coordinates":" + " [[[35,10],[45,45],[15,40],[10,20],[35,10]],[[20,30],[35,35],[30,20],[20,30]]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: shouldFetchDefaultValueIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("amount_paid_by_cash");  /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = requiredGroup() .required(FLOAT).named("amount_paid_by_cash") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); FloatHandler floatHandler = new FloatHandler(fieldDescriptor);  Object actualValue = floatHandler.parseSimpleGroup(simpleGroup);  "<AssertPlaceHolder>"; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getFloat(fieldName, 0); } else { /* return default value */ return 0.0F; } }
[*] target: assertEquals(0.0F, actualValue)
[-] pred: org. junit. Assert. assertEquals ( 0.0F, actualValue )
************************************
************************************
[+] input: shouldGetCurrentTimestampAsResult() { long currentTimestampMs = System.currentTimeMillis(); Clock clock = mock(Clock.class); when(clock.millis()).thenReturn(currentTimestampMs);  CurrentTimestampFunction currentTimestampFunction = new CurrentTimestampFunction(clock);  Timestamp expectedCurrentTimestamp = new Timestamp(currentTimestampMs); Timestamp actualCurrentTimestamp = (Timestamp) currentTimestampFunction.getResult(null);  "<AssertPlaceHolder>"; }
getResult(RowManager rowManager) { return new Timestamp(clock.millis()); }
[*] target: assertEquals(expectedCurrentTimestamp, actualCurrentTimestamp)
[-] pred: org. junit. Assert. assertEquals ( expectedCurrentTimestamp, actualCurrentTimestamp )
************************************
************************************
[+] input: Exception { Assume.assumeTrue(whole.markSupported()); whole.mark(1024); int read = whole.read(); whole.reset(); int reread = whole.read(); "<AssertPlaceHolder>"; }
read() { return (pos < count) ? (data.bytes[pos++] & 0xff) : -1; }
[*] target: assertEquals(read, reread)
[-] pred: org. junit. Assert. assertEquals ( read, reread )
************************************
************************************
[+] input: TableNotExistException { ObjectPath objectPath = new ObjectPath("default", "test"); CatalogBaseTable catalogBaseTable = rocketMQCatalog.getTable(objectPath); "<AssertPlaceHolder>"; }
getTable(ObjectPath tablePath) throws TableNotExistException, CatalogException { if (!tableExists(tablePath)) { throw new TableNotExistException(getName(), tablePath); } String subject = tablePath.getObjectName(); try { GetSchemaResponse getSchemaResponse = schemaRegistryClient.getSchemaBySubject(subject); if (getSchemaResponse.getType() != SchemaType.AVRO) { throw new CatalogException("Only support avro schema."); } return getCatalogTableForSchema(subject, getSchemaResponse); } catch (Exception e) { throw new CatalogException( String.format( "Failed to get schema of table %s from schema registry client.", tablePath.getFullName()), e); } }
[*] target: assertNotNull(catalogBaseTable)
[-] pred: org. junit. Assert. assertNotNull ( catalogBaseTable )
************************************
************************************
[+] input: testCheckAndSet_DisableCaching() { Mockito.when(req.getPathInfo()).thenReturn("/");  BinaryResource res = BinaryResources.create() .withFilename("a.html") .withContent("<html></html>".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(false) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey("/"), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert."<AssertPlaceHolder>";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute("jakarta.servlet.forward.path_info"); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, "private, no-store, no-cache, max-age=0"); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // "private" //   Only browsers may cache this resource. // "max-age" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because "must-revalidate" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, "private, max-age=" + maxAge + ", s-maxage=" + maxAge); } else { // "private" //   Only browsers may cache this resource. // "must-revalidate" //   A cache HAS TO check with the server before using stale resources. // "max-age=0" //   A resource will become stale immediately (after 0 seconds). // Note: "max-age=0, must-revalidate" would be the same as "no-cache" resp.setHeader(CACHE_CONTROL, "private, max-age=0, must-revalidate"); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-None-Match/Etag): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-Modified-Since): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }
[*] target: assertFalse(b)
[-] pred: org. junit. Assert. assertFalse ( b )
************************************
************************************
[+] input: Exception { boolean error = false; try { new ExcludeRouter("*").route(null, null); } catch (Exception e) { error = e instanceof UnsupportedOperationException; } Assert."<AssertPlaceHolder>"; }
route(SofaRequest request, List<ProviderInfo> providerInfos) { throw new UnsupportedOperationException(); }
[*] target: assertTrue(error)
[-] pred: org. junit. Assert. assertTrue ( error )
************************************
************************************
[+] input: hasTypeShouldBeFalseWhenTypeIsNull() { HttpSourceConfig httpSourceConfig = new HttpSourceConfig("", "", "", "", "", "", "", null, "", false, null, "", new HashMap<>(), new HashMap<>(), metricId, false); "<AssertPlaceHolder>"; }
hasType() { return StringUtils.isNotEmpty(type); }
[*] target: assertFalse(httpSourceConfig.hasType())
[-] pred: org. junit. Assert. assertFalse ( httpSourceConfig. hasType() )
************************************
************************************
[+] input: mp4AvcCBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x28, 0x61, 0x76, 0x63, 0x43, 0x01, 0x64, 0x00, 0x2A, (byte) 0xFF, (byte) 0xE1, 0x00, 0x11, 0x67, 0x64, 0x00, 0x2A, (byte) 0xAC, 0x2B, 0x50, 0x3C, 0x01, 0x13, (byte) 0xF2, (byte) 0xCD, (byte) 0xC0, 0x40, 0x40, 0x40, (byte) 0x80, 0x01, 0x00, 0x04, 0x68, (byte) 0xEE, 0x3C, (byte) 0xB0, }; Mp4AvcCBox box = new Mp4AvcCBox(this.trackInfo); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: testLocales() { Runnable runner = () -> { logger.debug("Checking Locale " + Locale.getDefault()); DepartmentNameGenerator generator = new DepartmentNameGenerator(); generator.init(context); for (int i = 0; i < 100; i++) { String product = generator.generate(); logger.debug(product); "<AssertPlaceHolder>"; } }; LocaleUtil.runInLocale(Locale.US, runner); LocaleUtil.runInLocale(Locale.GERMAN, runner); LocaleUtil.runInLocale(new Locale("XX"), runner); }
generate() { return GeneratorUtil.generateNonNull(this); }
[*] target: assertNotNull(product)
[-] pred: org. junit. Assert. assertNotNull ( product )
************************************
************************************
[+] input: convertMultiPoint_V2_ShouldConvert() { String wkt = "MULTIPOINT ((10 40), (40 30), (20 20), (30 10))"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"MultiPoint", "coordinates": [[10,40],[40,30],[20,20],[30,10]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: createResponse1() { String expect = "Digest username="q", realm="test", nonce="N6yEOiDGTvOx9hwloHW7AQ==", uri="/portal/applications", response="bc3662d7309bdf68b5f6684647bd17e2", qop=auth, nc=00000001, cnonce="04fefcb40dae7db4""; UsernamePasswordCredential credential = new UsernamePasswordCredential("q", "q"); DigestAuthenticator authenticator = new DigestAuthenticator(credential); authenticator.addServerInfo("test", "auth", "N6yEOiDGTvOx9hwloHW7AQ==", false); authenticator.addClientInfo("/portal/applications", "GET", "04fefcb40dae7db4"); String actual = authenticator.createResponse(); "<AssertPlaceHolder>";  }
createResponse() { if (this.realm == null || this.realm.equals("")) { throw new AuthenticationException("realm is empty"); } if (this.nonce == null || this.nonce.equals("")) { throw new AuthenticationException("nonce is empty"); } if (this.uri == null || this.uri.equals("")) { throw new AuthenticationException("uri is empty"); } if (this.method == null || this.method.equals("")) { throw new AuthenticationException("method is empty"); } StringBuilder sb = new StringBuilder(); sb.append(DIGEST_NAME).append(" ") .append("username="").append(this.credential.getUsername()).append("", ") .append("realm="").append(this.realm).append("", ") .append("nonce="").append(this.nonce).append("", ") .append("uri="").append(this.uri).append("", "); if (this.qop == null || this.qop.equals("")) { sb.append("response="").append(this.calculateResponseString()).append("""); } else { sb.append("response="").append(this.calculateResponseString()).append("", ") .append("qop=").append(this.qop).append(", ") .append("nc=").append(String.format("%08X", this.nc)).append(", ") .append("cnonce="").append(this.cnonce).append("""); } return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: toByteArray() { RequestItem requestItem = new RequestItem(); requestItem.setSpecificationType((byte)0x12); requestItem.setLengthOfFollowing((byte)0x10); requestItem.setSyntaxId(ESyntaxID.S7ANY); requestItem.setVariableType(EParamVariableType.BYTE); requestItem.setCount(7); requestItem.setDbNumber(7); requestItem.setArea(EArea.DATA_BLOCKS); requestItem.setByteAddress(3); requestItem.setBitAddress(1); byte[] actual = requestItem.toByteArray(); byte[] expect = new byte[]{(byte) 0x12, (byte) 0x10, (byte) 0x10, (byte) 0x02, (byte) 0x00, (byte) 0x07, (byte) 0x00, (byte) 0x07, (byte) 0x84, (byte) 0x00, (byte) 0x00, (byte) 0x19}; "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.specificationType) .putByte(this.lengthOfFollowing) .putByte(this.syntaxId.getCode()) .putByte(this.variableType.getCode()) .putShort(this.count) .putShort(this.dbNumber) .putByte(this.area.getCode()) // 只有3个字节，因此只取后面的3字节，第一个字节舍弃 .putBytes(IntegerUtil.toByteArray((this.byteAddress << 3) + this.bitAddress), 1) .getData(); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: shouldNotReturnAnyError() { NoError noError = new NoError(); "<AssertPlaceHolder>"; }
getCurrentException() { return null; }
[*] target: assertNull(noError.getCurrentException())
[-] pred: org. junit. Assert. assertNull ( noError. getCurrentException() )
************************************
************************************
[+] input: shouldAddLineBreakIfScriptStartsWithComment() { //given String expectedString = lineBreak + "-- SELECT * FROM mytable;"; String inputString = "-- SELECT * FROM mytable;";  //when String formattedString = formatter.format(inputString, configuration);  //then "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, formattedString)
[-] pred: org. junit. Assert. assertEquals ( expectedString, formattedString )
************************************
************************************
[+] input: testGenerateValidPeriod() { String result = ChineseIDCardNumberGenerator.generateValidPeriod(); System.err.println(result); "<AssertPlaceHolder>"; }
generateValidPeriod() { DateTime beginDate = new DateTime(randomDate()); String formater = "yyyyMMdd"; DateTime endDate = beginDate.withYear(beginDate.getYear() + 20); return beginDate.toString(formater) + "-" + endDate.toString(formater); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testCleanupWithEmptyList() { //noinspection deprecation List<IMenu> cleanList = ActionUtility.visibleNormalizedActions(Collections.emptyList()); "<AssertPlaceHolder>"; }
visibleNormalizedActions(List<T> actionNodes) { return normalizedActions(actionNodes, createVisibleFilter()); }
[*] target: assertTrue(cleanList.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( cleanList. isEmpty ( ) )
************************************
************************************
[+] input: getVehicleLocationNotFoundWhenVehicleDetailsOwnerIsNull() { VehicleDetails vehicleDetails = getDummyVehicleDetails(); vehicleDetails.setOwner(null); Mockito.when(vehicleDetailsRepository.findByUuid(vehicleDetails.getUuid())) .thenReturn(vehicleDetails); VehicleLocationResponse vehicleLocationResponse = vehicleService.getVehicleLocation(vehicleDetails.getUuid()); Assertions."<AssertPlaceHolder>"; }
getVehicleLocation(UUID carId) { VehicleDetails vehicleDetails = null; VehicleLocationResponse vehicleLocationForm = null; UserDetails userDetails = null; Random random = new Random(); try { vehicleDetails = vehicleDetailsRepository.findByUuid(carId); if (vehicleDetails != null) { // vehicleDetails = vehicleDetailsRepository.findByVehicleLocation_id(carId); // vehicleDetails.setVehicleLocation(getVehicleLocationList().get(random.nextInt(getVehicleLocationList().size()))); if (vehicleDetails.getOwner() != null) { userDetails = userDetailsRepository.findByUser_id(vehicleDetails.getOwner().getId()); vehicleLocationForm = new VehicleLocationResponse( carId, (userDetails != null ? userDetails.getName() : null), (userDetails != null ? userDetails.getUser().getEmail() : null), vehicleDetails.getVehicleLocation()); return vehicleLocationForm; } } } catch (Exception exception) { log.error("Fail to get vehicle location-> Message: {}", exception); } return null; }
[*] target: assertNull(vehicleLocationResponse)
[-] pred: org. junit. Assert. assertNull ( vehicleLocationResponse )
************************************
************************************
[+] input: testActive() { ILookupRow<String> row = new LookupRow<>("key", "text"); row.withActive(true); row.withActive(false); row.withActive(true); "<AssertPlaceHolder>"; }
isActive() { return getOrElse(ACTIVE_BIT, Boolean.TRUE); }
[*] target: assertTrue(row.isActive())
[-] pred: org. junit. Assert. assertTrue ( row. isActive() )
************************************
************************************
[+] input: filteredListSizeIsCorrect2() { int k = 5; // instantiate random filter with parameter k KRandomFilter filter = new KRandomFilter(k); // call filter method to obtain filtered list List<MutationInstance> filteredList = filter.filterMutants(toFilter); // filtered list should be of size k "<AssertPlaceHolder>"; }
filterMutants(List<MutationInstance> toFilter) {  // determine number of mutants to run int n = this.percent ? (guidance.getSeenMutants() * k / 100) : k;  // shuffle list of mutants to randomize first n elements Collections.shuffle(toFilter);  // add first k mutants in list to filtered list List<MutationInstance> filtered = new ArrayList<>(); for(int i = 0; i < n && i < toFilter.size(); i++){ filtered.add(toFilter.get(i)); }  return filtered; }
[*] target: assertEquals(k, filteredList.size())
[-] pred: org. junit. Assert. assertEquals ( k, filteredList. size ( ) )
************************************
************************************
[+] input: testTabletSetLargeMerge() { final int SetRange = 256; final int Blocks = 64;  TableSet[] tablesets = new TableSet[64];  for (int i = 0; i < tablesets.length; i++) { TableSet ts = new TableSet(); int setrng = i * SetRange;  for (int tid = 0; tid < SetRange; tid++) { ts.addTable(setrng + tid); }  tablesets[i] = ts; }  TableSet result = new TableSet(); for (TableSet ts : tablesets) { result = result.merge(ts); }  List<TableSet> expected = new ArrayList<>(); for (int tid = 0; tid < SetRange * Blocks; tid++) { expected.add(singleTableSet(tid)); } Assert."<AssertPlaceHolder>"; }
constituents() { List<TableSet> result = new ArrayList<>(); forEachTable(t -> result.add(TableSet.singleTableSet((Integer) t))); return result; }
[*] target: assertEquals(expected, result.constituents())
[-] pred: org. junit. Assert. assertEquals ( expected, result. constituents ( ) )
************************************
************************************
[+] input: canDecorateGrpcAsync() { GrpcStreamDecorator grpcStreamDecorator = new GrpcStreamDecorator(grpcSourceConfig, externalMetricConfig, schemaConfig); "<AssertPlaceHolder>"; }
canDecorate() { return grpcSourceConfig != null; }
[*] target: assertTrue(grpcStreamDecorator.canDecorate())
[-] pred: org. junit. Assert. assertTrue ( grpcStreamDecorator. canDecorate() )
************************************
************************************
[+] input: shouldFetchDefaultValueIfFieldNotPresentInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("amount_paid_by_cash"); GroupType parquetSchema = requiredGroup() .required(FLOAT).named("some-other-field") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); FloatHandler floatHandler = new FloatHandler(fieldDescriptor);  Object actualValue = floatHandler.parseSimpleGroup(simpleGroup);  "<AssertPlaceHolder>"; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getFloat(fieldName, 0); } else { /* return default value */ return 0.0F; } }
[*] target: assertEquals(0.0F, actualValue)
[-] pred: org. junit. Assert. assertEquals ( 0.0F, actualValue )
************************************
************************************
[+] input: testReadString() { String expected = "0123"; String actual = IOUtility.readString(newReader(expected)); "<AssertPlaceHolder>"; }
readString(Reader in) { return readString(in, -1); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: listBucketTest() { List<String> buckets = manager.listBuckets(); boolean expectTrue = buckets.contains(manager.getBucket()); Assert."<AssertPlaceHolder>"; }
getBucket() { return lindormConfig.getBucket(); }
[*] target: assertTrue(expectTrue)
[-] pred: org. junit. Assert. assertTrue ( expectTrue )
************************************
************************************
[+] input: selectSingle4() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andIn(MysqlUserEntity::getId, Arrays.asList(1, 1, 1, 1, 1, 1)); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); dynamicSql.andEqualTo(MysqlUserEntity::getGender, "未知"); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert."<AssertPlaceHolder>"; log.info("mysqlUserEntity : {}", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }
[*] target: assertNotNull(mysqlUserEntity)
[-] pred: org. junit. Assert. assertNotNull ( mysqlUserEntity )
************************************
************************************
[+] input: shouldNotBeAbleToBuildSourceIfSourceDetailsContainsMultipleBackToBackSources() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED), new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); FlinkKafkaConsumerDaggerSource daggerSource = new FlinkKafkaConsumerDaggerSource(streamConfig, configuration, daggerDeserializer);  "<AssertPlaceHolder>"; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }
[*] target: assertFalse(daggerSource.canBuild())
[-] pred: org. junit. Assert. assertFalse ( daggerSource. canBuild ( ) )
************************************
************************************
[+] input: shouldNotReturnAnyPostProcessor() { when(configuration.getString(Constants.FLINK_SQL_QUERY_KEY, Constants.FLINK_SQL_QUERY_DEFAULT)).thenReturn("test-sql"); when(configuration.getBoolean(Constants.PROCESSOR_POSTPROCESSOR_ENABLE_KEY, Constants.PROCESSOR_POSTPROCESSOR_ENABLE_DEFAULT)).thenReturn(false); List<PostProcessor> postProcessors = PostProcessorFactory.getPostProcessors(daggerContext, stencilClientOrchestrator, columnNames, metricsTelemetryExporter);  "<AssertPlaceHolder>"; }
getPostProcessors(DaggerContext daggerContext, StencilClientOrchestrator stencilClientOrchestrator, String[] columnNames, MetricsTelemetryExporter metricsTelemetryExporter) { List<PostProcessor> postProcessors = new ArrayList<>();  if (Arrays.stream(columnNames).anyMatch(s -> Pattern.compile(".*\\blongbow.*key\\b.*").matcher(s).find())) { postProcessors.add(getLongBowProcessor(columnNames, daggerContext.getConfiguration(), metricsTelemetryExporter, stencilClientOrchestrator)); } if (daggerContext.getConfiguration().getBoolean(Constants.PROCESSOR_POSTPROCESSOR_ENABLE_KEY, Constants.PROCESSOR_POSTPROCESSOR_ENABLE_DEFAULT)) { postProcessors.add(new ParentPostProcessor(daggerContext, stencilClientOrchestrator, metricsTelemetryExporter)); } if (daggerContext.getConfiguration().getBoolean(Constants.METRIC_TELEMETRY_ENABLE_KEY, Constants.METRIC_TELEMETRY_ENABLE_VALUE_DEFAULT)) { postProcessors.add(new TelemetryProcessor(metricsTelemetryExporter)); } return postProcessors; }
[*] target: assertEquals(0, postProcessors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, postProcessors. size ( ) )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeDataAndRuleRegexMisMatch2() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "25"); subject.put("verify_aal", "2."); subject.put("userId", "123458"); subject.put("verify_userId", "12345[6|7]"); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertFalse(flag)
[-] pred: org. junit. Assert. assertFalse ( flag )
************************************
************************************
[+] input: testExecutionSkippedMarkedAsNotRunning() { NetworkTask task = getNetworkTask(); task = networkTaskDAO.insertNetworkTask(task); networkTaskDAO.updateNetworkTaskRunning(task.getId(), false); Intent intent = new Intent(); intent.putExtras(task.toBundle()); broadcastReceiver.onReceive(TestRegistry.getContext(), intent); List<LogEntry> entries = logDAO.readAllLogsForNetworkTask(task.getId()); "<AssertPlaceHolder>"; }
onReceive(Context context, Intent intent) { NetworkTask task = new NetworkTask(Objects.requireNonNull(intent.getExtras())); Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Received request for " + task); boolean synchronous = context.getResources().getBoolean(R.bool.worker_synchronous_execution); boolean addToPool = context.getResources().getBoolean(R.bool.worker_add_to_pool); int wakeLockTimeout = context.getResources().getInteger(R.integer.worker_execution_wakelock_timeout) * 1000; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Synchronous execution is " + synchronous); PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wakeLock = null; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Creating ExecutorService"); ExecutorService executorService = Executors.newSingleThreadExecutor(); try { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Acquiring partial wake lock with a timeout of " + wakeLockTimeout + " msec"); wakeLock = Objects.requireNonNull(powerManager).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "KeepItUp:NetworkTaskProcessBroadcastReceiver"); wakeLock.acquire(wakeLockTimeout); TimeBasedSuspensionScheduler timeBasedScheduler = createTimeBasedSuspensionScheduler(context); synchronized (TimeBasedSuspensionScheduler.LOCK) { if (timeBasedScheduler.isRunning()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is running."); if (!timeBasedScheduler.isSuspended()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not suspended."); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is suspended. Skipping execution and rescheduling."); } } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not running."); if (!timeBasedScheduler.isSuspensionActiveAndEnabled()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not active."); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not running but is active. Restarting..."); timeBasedScheduler.start(task); } } } } catch (Exception exc) { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), "Error executing worker", exc); } finally { if (wakeLock != null && synchronous && wakeLock.isHeld()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Releasing partial wake lock"); wakeLock.release(); } Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Shutting down ExecutorService"); executorService.shutdown(); } }
[*] target: assertEquals(0, entries.size())
[-] pred: org. junit. Assert. assertEquals ( 0, entries. size ( ) )
************************************
************************************
[+] input: testReWriteWrongSql() { String ddl = "alter table `payment_voucher` drop key `out_voucher_id`,drop key pay_no\n" + "add index key `uid_pay_no`(`user_id`,`pay_no`) using btree\n" + "add unique key `uid_voucherid_source`(`user_id`,`out_voucher_id`,`source`) using btree";  String expect = "alter table `payment_voucher` drop key `out_voucher_id`,drop key pay_no \n" + "add index `uid_pay_no`(`user_id`,`pay_no`) using btree \n" + "add unique key `uid_voucherid_source`(`user_id`,`out_voucher_id`,`source`) using btree"; String newDdl = SQLUtils.reWriteWrongDdl(ddl); Assert."<AssertPlaceHolder>"; }
reWriteWrongDdl(String sql) { Scanner scanner = new Scanner(sql); StringBuilder sb = new StringBuilder(); int keyCount = 0; boolean reWrite = false; while (scanner.hasNext()) { String line = scanner.nextLine(); Scanner lineScanner = new Scanner(line); while (lineScanner.hasNext()) { String key = lineScanner.next(); String lowerKey = key.toLowerCase(); if (StringUtils.equalsAny(lowerKey, "key", "index")) { keyCount++; if (keyCount > 1) { reWrite = true; continue; } } else { keyCount = 0; } sb.append(key).append(" "); } sb.append("\n"); } if (reWrite) { return sb.toString().trim(); } return null; }
[*] target: assertEquals(expect, newDdl)
[-] pred: org. junit. Assert. assertEquals ( expect, newDdl )
************************************
************************************
[+] input: rtspOptionRequestTest() { String expect = "OPTIONS rtsp://10.3.8.202:554 RTSP/1.0\r\n" + "CSeq: 0\r\n" + "User-Agent: IOT-COMMUNICATION\r\n" + "\r\n"; URI uri = URI.create("rtsp://10.3.8.202:554"); RtspOptionRequest request = new RtspOptionRequest(uri); request.setCSeq(0); String actual = request.toObjectString(); "<AssertPlaceHolder>"; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: convertPoint_WithRedundantSpaces_ShouldConvert() { String wkt = " POINT ( 12.3 13.3 )   "; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"Point", "coordinates": [12.3,13.3]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: testContainsNodeSingleNode() { ITree tree = mock(ITree.class); ITreeNode nodeA = mockNode("a"); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION, nodeA); "<AssertPlaceHolder>"; }
containsNode(ITreeNode nodeToFind) { if (CollectionUtility.isEmpty(m_nodes)) { return false; } for (ITreeNode node : m_nodes) { if (ObjectUtility.equals(node, nodeToFind)) { return true; } } return false; }
[*] target: assertTrue(event.containsNode(nodeA))
[-] pred: org. junit. Assert. assertTrue ( event. containsNode ( nodeA ) )
************************************
************************************
[+] input: createResponse() { String expect = "Basic YWRtaW46MTIzNDU2"; UsernamePasswordCredential credential = new UsernamePasswordCredential("admin", "123456"); BasicAuthenticator authenticator = new BasicAuthenticator(credential); String actual = authenticator.createResponse(); "<AssertPlaceHolder>"; }
createResponse() { String src = String.format("%s:%s", this.credential.getUsername(), this.credential.getPassword()); return this.name + " " + this.encoder.encodeToString(src.getBytes(StandardCharsets.UTF_8)); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: checkTokenNullCache() { JapUserStore japUserStore = new JapUserStoreTest(); JapCache japCache = null; JapConfig japConfig = new JapConfig(); JapContext japContext = new JapContext(japUserStore, japCache, japConfig); JapAuthentication.setContext(japContext);  Map<String, Object> map = JapAuthentication.checkToken("aaa"); Assert."<AssertPlaceHolder>"; }
checkToken(String token) { if (null == context || ObjectUtil.isEmpty(token)) { return null; } JapCache japCache = context.getCache(); if (null == japCache) { return null; } Map<String, Object> tokenMap = JapTokenHelper.checkToken(token); if (MapUtil.isNotEmpty(tokenMap)) { Kv kv = new Kv(); kv.putAll(tokenMap); // Get the token creation time, multiplied by 1000 is the number of milliseconds long iat = kv.getLong("iat") * 1000; JapConfig japConfig = context.getConfig(); // Get token expiration time long tokenExpireTime = japConfig.getTokenExpireTime(); // The token is available when the token creation time plus the token expiration time is later than the current time, // otherwise the token has expired if (new Date(iat + tokenExpireTime).after(new Date())) { return tokenMap; } } return null; }
[*] target: assertNull(map)
[-] pred: org. junit. Assert. assertNull ( map )
************************************
************************************
[+] input: test_serialized_deserialize_all_test_config() { GinkgoRunConfigurationOptions configOptions = new GinkgoRunConfigurationOptions(); configOptions.setGinkgoExecutable("ginkgo"); configOptions.setWorkingDir("/workspace"); configOptions.setEnvData(EnvironmentVariablesData.DEFAULT); configOptions.setGinkgoAdditionalOptions("-race"); configOptions.setGinkgoScope(GinkgoScope.ALL); configOptions.setFocusTestExpression(""); configOptions.setTestNames(Arrays.asList("ginkgo all")); configOptions.setGoToolOptions("build tool options"); Element element = new Element("ginkgo_config");  GinkgoSerializationUtil.writeXml(element, configOptions); GinkgoRunConfigurationOptions result = GinkgoSerializationUtil.readXml(element);  "<AssertPlaceHolder>"; }
readXml(@NotNull Element element) { GinkgoRunConfigurationOptions ginkgoRunConfigurationOptions = new GinkgoRunConfigurationOptions(); ginkgoRunConfigurationOptions.setGinkgoExecutable(read(element, GINKGO_EXECUTABLE)); ginkgoRunConfigurationOptions.setWorkingDir(read(element, WORKING_DIR)); ginkgoRunConfigurationOptions.setEnvData(EnvironmentVariablesData.readExternal(element)); ginkgoRunConfigurationOptions.setGinkgoAdditionalOptions(read(element, GINKGO_ADDITIONAL_OPTIONS)); ginkgoRunConfigurationOptions.setGoToolOptions(read(element, GO_TOOL_OPTIONS)); ginkgoRunConfigurationOptions.setGinkgoScope(readScope(element)); ginkgoRunConfigurationOptions.setFocusTestExpression(read(element, FOCUS_EXPRESSION)); ginkgoRunConfigurationOptions.setPackageName(read(element, PACKAGE_NAME)); ginkgoRunConfigurationOptions.setTestNames(readTestNames(element));  return ginkgoRunConfigurationOptions; }
[*] target: assertEquals(configOptions, result)
[-] pred: org. junit. Assert. assertEquals ( configOptions, result )
************************************
************************************
[+] input: shouldReturnMultipleListOfStringWhenLongbowDataMoreThanOne() { List<Result> scanResult = new ArrayList<>(); scanResult.add(result1); scanResult.add(result2); String[] columnNames = {"longbow_key", "longbow_data1", "rowtime", "longbow_duration", "longbow_data2"};  LongbowSchema longbowSchema = new LongbowSchema(columnNames); LongbowTableData longbowTableData = new LongbowTableData(longbowSchema); Map<String, List<String>> actualData = longbowTableData.parse(scanResult); Map<String, List<String>> expectedMap = new HashMap<String, List<String>>() {{ put("longbow_data1", Arrays.asList("RB-234", "RB-224")); put("longbow_data2", Arrays.asList("RB-235", "RB-225")); }}; "<AssertPlaceHolder>"; }
parse(List<Result> scanResult) { Map<String, List<String>> longbowData = new HashMap<>(); List<String> longbowDataColumnNames = longbowSchema.getColumnNames(c -> c.getKey().contains(Constants.LONGBOW_DATA_KEY)); if (scanResult.isEmpty()) { longbowDataColumnNames.forEach(name -> longbowData.put(name, new ArrayList<>())); } else { longbowDataColumnNames.forEach(name -> longbowData.put(name, getData(scanResult, name))); } return longbowData; }
[*] target: assertEquals(expectedMap, actualData)
[-] pred: org. junit. Assert. assertEquals ( expectedMap, actualData )
************************************
************************************
[+] input: testSubstitute() { String sqlTemplate = "select * from table_name where number_param > ? and string_param = 'Amazon.com' and" + " test_str = '''test escape? \'' and state in (?,?) and null_param = ? and" + " double_param = ? and question_mark = '?'"; List<PreparedStatementRequest.PreparedStatementParameter> params = new ArrayList<>(); params.add(new PreparedStatementRequest.PreparedStatementParameter<Integer>(10)); params.add(new PreparedStatementRequest.StringParameter("WA")); params.add(new PreparedStatementRequest.StringParameter("")); params.add(new PreparedStatementRequest.NullParameter()); params.add(new PreparedStatementRequest.PreparedStatementParameter<Double>(2.0)); PreparedStatementRequest psr = new PreparedStatementRequest(sqlTemplate, new JSONObject(), params); String generatedSql = psr.getSql();  String expectedSql = "select * from table_name where number_param > 10 and string_param = 'Amazon.com' " + "and test_str = '''test escape? \'' and state in ('WA','') and null_param = null " + "and double_param = 2.0 and question_mark = '?'"; Assert."<AssertPlaceHolder>"; }
getSql() { return this.sql; }
[*] target: assertEquals(expectedSql, generatedSql)
[-] pred: org. junit. Assert. assertEquals ( expectedSql, generatedSql )
************************************
************************************
[+] input: Exception { final SubscriptionConfig config = new SubscriptionConfig(subNodeName, home, subHostPortPair, feederHostPortPair, groupName, groupUUID, NodeType.EXTERNAL);  for (EntryRequestType type : EntryRequestType.values()) { config.setStreamMode(type); "<AssertPlaceHolder>"; } }
getStreamMode() { return streamMode; }
[*] target: assertEquals(type, config.getStreamMode())
[-] pred: org. junit. Assert. assertEquals ( type, config. getStreamMode() )
************************************
************************************
[+] input: mp4TrexBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x20, 0x74, 0x72, 0x65, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, }; Mp4TrexBox box = new Mp4TrexBox(1); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: testCheckAndSet_EnableCaching_LastModified() { Mockito.when(req.getPathInfo()).thenReturn("/"); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(null); Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(0L);  BinaryResource res = BinaryResources.create() .withFilename("a.html") .withContent("<html></html>".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModifiedNow() .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey("/"), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert."<AssertPlaceHolder>";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute("jakarta.servlet.forward.path_info"); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, "private, max-age=0, must-revalidate"); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.ETAG, obj.createETag()); Mockito.verify(resp, ONCE).setDateHeader(HttpCacheControl.LAST_MODIFIED, obj.getResource().getLastModified()); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // "private" //   Only browsers may cache this resource. // "max-age" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because "must-revalidate" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, "private, max-age=" + maxAge + ", s-maxage=" + maxAge); } else { // "private" //   Only browsers may cache this resource. // "must-revalidate" //   A cache HAS TO check with the server before using stale resources. // "max-age=0" //   A resource will become stale immediately (after 0 seconds). // Note: "max-age=0, must-revalidate" would be the same as "no-cache" resp.setHeader(CACHE_CONTROL, "private, max-age=0, must-revalidate"); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-None-Match/Etag): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-Modified-Since): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }
[*] target: assertFalse(b)
[-] pred: org. junit. Assert. assertFalse ( b )
************************************
************************************
[+] input: testExplainRequest() { PPLQueryRequest request = new PPLQueryRequest("source=t a=1", null, "/_plugins/_ppl/_explain"); "<AssertPlaceHolder>"; }
isExplainRequest() { return path.endsWith("/_explain"); }
[*] target: assertTrue(request.isExplainRequest())
[-] pred: org. junit. Assert. assertTrue ( request. isExplainRequest ( ) )
************************************
************************************
[+] input: testUpdateActionsFromPaths_resourcesCheckstyle() { Set<UpdateAction> expectedActions = EnumSet.noneOf(UpdateAction.class); // this is not a valid update target List<Path> changedPaths = List.of(Path.of("resources/checkstyle/checkstyle.xml")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(changedPaths); "<AssertPlaceHolder>"; }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: testVerifyRequestRequestWithNullDataAndRuleMisMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", null); subject.put("verify_aal", "25"); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertFalse(flag)
[-] pred: org. junit. Assert. assertFalse ( flag )
************************************
************************************
[+] input: readAndWriteLock() { final SingleGroupAddressHolder addressHolder = new SingleGroupAddressHolder(null); final Random random = new Random(); final AtomicBoolean run = new AtomicBoolean(true); final AtomicBoolean error = new AtomicBoolean(false); // 有没有发生异常，例如死锁等 final CountDownLatch latch = new CountDownLatch(1); // 出现异常 跳出等待 Thread readThread = new Thread(new Runnable() { @Override public void run() { while (run.get()) { try { // 不停的读取 addressHolder.getProviderGroups(); } catch (Exception e) { error.set(true); latch.countDown(); } } } }, "readThread"); Thread writeThread = new Thread(new Runnable() { @Override public void run() { while (run.get()) { try { // 不停的变更 addressHolder.updateAllProviders(Arrays.asList( new ProviderGroup("xxx", Arrays.asList(ProviderHelper.toProviderInfo("127.0.0.1:" + random.nextInt(65535)))), new ProviderGroup(ADDRESS_DIRECT_GROUP, Arrays.asList(ProviderHelper.toProviderInfo("127.0.0.1:" + random.nextInt(65535)))))); } catch (Exception e) { error.set(true); latch.countDown(); } } } }, "writeThread"); readThread.start(); writeThread.start();  // 正常跑3秒 或者出异常 try { latch.await(3000, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { e.printStackTrace(); } finally { run.set(false); } Assert."<AssertPlaceHolder>"; }
getProviderGroups() { rLock.lock(); try { List<ProviderGroup> list = new ArrayList<ProviderGroup>(); list.add(registryGroup); list.add(directUrlGroup); return list; } finally { rLock.unlock(); } }
[*] target: assertFalse(error.get())
[-] pred: org. junit. Assert. assertFalse ( error. get ( ) )
************************************
************************************
[+] input: shouldDoDefaultFormatForAlterStatementWhenIndentSubstatementsInParenthesesOn() { //given String inputString = "ALTER TABLE `users` ADD COLUMN (count_copy smallint(6) NOT NULL, status int(10) unsigned NOT NULL) AFTER `lastname`;"; String expectedString = "ALTER TABLE `users` ADD COLUMN (" + lineBreak + "\tcount_copy SMALLINT(6) NOT NULL," + lineBreak + "\tstatus int(10) unsigned NOT NULL" + lineBreak + ") AFTER `lastname`;";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET))).thenReturn(true);  //when String formattedString = formatter.format(inputString, configuration);  //then "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, formattedString)
[-] pred: org. junit. Assert. assertEquals ( expectedString, formattedString )
************************************
************************************
[+] input: IOException { long actual = binlogFileReadChannel.size(); long expect = localChannel.size(); Assert."<AssertPlaceHolder>"; }
size() throws IOException { try { return parse(size.invoke(channel)); } catch (Exception e) { log.error("invoke size method error", e); throw new IOException("Get size of file channel error!"); } }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: dbResultWithSameRowsInDifferentOrderShouldEqual() { DBResult result1 = DBResult.result("DB 1"); result1.addColumn("name", "VARCHAR"); result1.addRow(new Row(ImmutableList.of("test-1"))); result1.addRow(new Row(ImmutableList.of("test-2")));  DBResult result2 = DBResult.result("DB 2"); result2.addColumn("name", "VARCHAR"); result2.addRow(new Row(ImmutableList.of("test-2"))); result2.addRow(new Row(ImmutableList.of("test-1")));  "<AssertPlaceHolder>"; }
addRow(Row row) { dataRows.add(row); }
[*] target: assertEquals(result1, result2)
[-] pred: org. junit. Assert. assertEquals ( result1, result2 )
************************************
************************************
[+] input: shouldDistinguishLongbowPlus() { String[] columnNames = {"longbow_key"};  longBowSchema = new LongbowSchema(columnNames); "<AssertPlaceHolder>"; }
isLongbowPlus() { return getType() != LongbowType.LongbowProcess; }
[*] target: assertFalse(longBowSchema.isLongbowPlus())
[-] pred: org. junit. Assert. assertFalse ( longBowSchema. isLongbowPlus() )
************************************
************************************
[+] input: testSaveToString() { FileConfiguration config = getConfig();  for (Map.Entry<String, Object> entry : getTestValues().entrySet()) { config.set(entry.getKey(), entry.getValue()); }  String result = config.saveToString(); String expected = getTestValuesString();  "<AssertPlaceHolder>"; }
saveToString();  /** * Loads this {@link FileConfiguration}
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: FilterException { Message message1 = new Message(testKeyJson1.getBytes(), testMessageJson1.getBytes(), "topic1", 0, 100); Message message2 = new Message(testKeyJson2.getBytes(), testMessageJson2.getBytes(), "topic1", 0, 101); Map<String, String> filterConfigs = new HashMap<>(); filterConfigs.put("FILTER_ESB_MESSAGE_FORMAT", "JSON"); filterConfigs.put("FILTER_DATA_SOURCE", "message"); filterConfigs.put("FILTER_JSON_SCHEMA", ""); filterConfig = ConfigFactory.create(FilterConfig.class, filterConfigs); jsonFilter = new JsonFilter(stencilClient, filterConfig, firehoseInstrumentation); FilteredMessages expectedMessages = new FilteredMessages(); expectedMessages.addToValidMessages(message1); expectedMessages.addToValidMessages(message2); List<Message> inputMessages = Arrays.asList(message1, message2); FilteredMessages filteredMessages = jsonFilter.filter(inputMessages); "<AssertPlaceHolder>"; }
filter(List<Message> messages) throws FilterException { FilteredMessages filteredMessages = new FilteredMessages(); for (Message message : messages) { byte[] data = (filterConfig.getFilterDataSource().equals(KEY)) ? message.getLogKey() : message.getLogMessage(); String jsonMessage = deserialize(data); if (evaluate(jsonMessage)) { filteredMessages.addToValidMessages(message); } else { filteredMessages.addToInvalidMessages(message); } } return filteredMessages; }
[*] target: assertEquals(expectedMessages, filteredMessages)
[-] pred: org. junit. Assert. assertEquals ( expectedMessages, filteredMessages )
************************************
************************************
[+] input: testSuma() { System.out.println("suma"); double num1 = 5.0; double num2 = 7.0; Calculadora instance = new Calculadora(); double expResult = 12.0; double result = instance.suma(num1, num2); "<AssertPlaceHolder>"; }
suma(double num1, double num2) { return num1 + num2; }
[*] target: assertEquals(expResult, result, 0.0)
[-] pred: org. junit. Assert. assertEquals ( expResult, result, 0.0 )
************************************
************************************
[+] input: convertPolygon_WithRedundantSpaces_ShouldConvert() { String wkt = " POLYGON  ( (30  10, 40    40 , 20 40, 10  20, 30 10 ) ) "; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"Polygon", "coordinates": [[[30,10],[40,40],[20,40],[10,20],[30,10]]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: test() { FilterBlacklistTableFilter filter = new FilterBlacklistTableFilter("cdc_blacklist_db.*\\.cdc_black_table.*"); boolean flag = filter.doFilter1("cdc_blacklist_db", "cdc_black_table"); Assert."<AssertPlaceHolder>"; }
doFilter1(String dbName, String tableName) { String key = dbName + "." + tableName; boolean ignore = pattern.matcher(key).matches(); if (ignore) { log.warn("detected event : " + key + " match black table, will ignore it"); } return ignore; }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: shouldDoDefaultFormat() { //given String expectedString = getExpectedString(); String inputString = "SELECT * FROM TABLE1 t WHERE a > 100 AND b BETWEEN 12 AND 45;  SELECT t.*, j1.x, j2.y FROM TABLE1 t JOIN JT1 j1 ON j1.a = t.a LEFT OUTER JOIN JT2 j2 ON j2.a = t.a AND j2.b = j1.b WHERE t.xxx NOT NULL;  DELETE FROM TABLE1 WHERE a = 1;  UPDATE TABLE1 SET a = 2 WHERE a = 1;  SELECT table1.id, table2.number, SUM(table1.amount) FROM table1 INNER JOIN table2 ON table.id = table2.table1_id WHERE table1.id IN ( SELECT table1_id FROM table3 WHERE table3.name = 'Foo Bar' AND table3.type = 'unknown_type') GROUP BY table1.id, table2.number ORDER BY table1.id;\n";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_LF_BEFORE_COMMA))).thenReturn(false);  //when String formattedString = formatter.format(inputString, configuration);  //then  "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, formattedString)
[-] pred: org. junit. Assert. assertEquals ( expectedString, formattedString )
************************************
************************************
[+] input: no_DoTable_No_DoDb_Hit_IgnoreDb_Hit_WildDoTable_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""); replicaMeta.setIgnoreDb("full_src_1, dutf8"); replicaMeta.setDoTable(""); replicaMeta.setIgnoreTable("full_src_1.t1, full_src_1.t2"); replicaMeta.setWildDoTable("d%.tb\\_charset%, d%.col\\_charset%"); replicaMeta.setWildIgnoreTable("d%.tb\\_charset%, d%.col\\_charset%"); replicaMeta.setRewriteDb(""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  // Hit Replicate_Do_Table rowChange.setSchema("dutf8"); rowChange.setTable("tb_charset_gbk"); Assert."<AssertPlaceHolder>"; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }
[*] target: assertTrue(filter.ignoreEvent(rowChange))
[-] pred: org. junit. Assert. assertTrue ( filter. ignoreEvent ( rowChange ) )
************************************
************************************
[+] input: shouldUseDefaultSecondsDuringTransformIfSimpleGroupDoesNotContainSecondsInGroupTypeTimestamp() { Instant currentInstant = Instant.now(); int nanos = currentInstant.getNano(); Row expectedRow = Row.of(0L, nanos);  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("event_timestamp"); TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor);  /* only adding nanos field to the timestamp schema and initializing it */ GroupType timestampSchema = org.apache.parquet.schema.Types.optionalGroup() .optional(INT32).named("nanos") .named("event_timestamp"); SimpleGroup timestampMessage = new SimpleGroup(timestampSchema); timestampMessage.add("nanos", nanos);  MessageType parquetSchema = buildMessage() .addField(timestampSchema) .named("TestBookingLogMessage"); SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add("event_timestamp", timestampMessage);  Row actualRow = (Row) timestampHandler.transformFromParquet(mainMessage);  "<AssertPlaceHolder>"; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }
[*] target: assertEquals(expectedRow, actualRow)
[-] pred: org. junit. Assert. assertEquals ( expectedRow, actualRow )
************************************
************************************
[+] input: createRsaJsonWebKey() { RsaJsonWebKey rsaJsonWebKey = JwkUtil.createRsaJsonWebKey("jap-jwks-keyid", TokenSigningAlg.RS256); Assert."<AssertPlaceHolder>"; }
createRsaJsonWebKey(String keyId, TokenSigningAlg signingAlg) { if (!Arrays.asList(TokenSigningAlg.RS256, TokenSigningAlg.RS384, TokenSigningAlg.RS512).contains(signingAlg)) { throw new InvalidJwksException("Unable to create RSA Json Web Key. Unsupported jwk algorithm, only supports RS256, RS384, RS512"); } RsaJsonWebKey jwk = null; try { jwk = RsaJwkGenerator.generateJwk(2048); jwk.setUse(Use.SIGNATURE); jwk.setKeyId(keyId); jwk.setAlgorithm(signingAlg.getAlg()); } catch (JoseException e) { e.printStackTrace(); throw new InvalidJwksException("Unable to create RSA Json Web Key."); } return jwk; }
[*] target: assertNotNull(rsaJsonWebKey)
[-] pred: org. junit. Assert. assertNotNull ( rsaJsonWebKey )
************************************
************************************
[+] input: testToString() { String expectedStr = "BaseRequest(" + "regionCode=" + regionCode + ", protocol=" + protocol + ", domain=" + domain + ", productCode=" + productCode + ", uriPattern=" + uriPattern + ", method=" + method + ", fallbackHttp=null" + ")"; BaseRequest<?> request = createRequestWithFluentApi();  "<AssertPlaceHolder>"; }
toString() { return "BaseRequest(" + "regionCode=" + regionCode + ", protocol=" + protocol + ", domain=" + domain + ", productCode=" + productCode + ", uriPattern=" + uriPattern + ", method=" + method + ", fallbackHttp=" + fallbackHttp + ")"; }
[*] target: assertEquals(expectedStr, request.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedStr, request. toString ( ) )
************************************
************************************
[+] input: Exception { ConnectionPoolDataSource dataSource = dataSourceFactory.createConnectionPoolDataSource(null); Assert."<AssertPlaceHolder>"; }
createConnectionPoolDataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); ConnectionPool dataSource = new ConnectionPool(); configureBaseDataSource(dataSource, props); return dataSource; }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: testEnvironmentAndSystemSubstitution() { final Properties defaults = new Properties(); defaults.put("a", "1"); defaults.put("b", "2"); defaults.put("c", "3");  final Properties systems = new Properties(); systems.put("a", "4"); systems.put("b", "5"); systems.put("c", "6");  final Map<String, String> environments = new HashMap<>(); environments.put("a", "7"); environments.put("b", "8"); environments.put("c", "9");  final StringSubstitution substitution = new StringSubstitution(defaults, systems, environments); final Map<String, String> mapping = new LinkedHashMap<>();  mapping.put("${a} ${sys:a} ${env:a}", "1 4 7"); mapping.put("${missing:-${b}} ${missing:-${sys:b}} ${missing:-${env:b}}", "2 5 8"); mapping.put("${sys:missing:-${b}} ${sys:missing:-${sys:b}} ${sys:missing:-${env:b}}", "2 5 8"); mapping.put("${env:missing:-${b}} ${env:missing:-${sys:b}} ${env:missing:-${env:b}}", "2 5 8");  for (final Map.Entry<String, String> entry : mapping.entrySet()) { final String text = entry.getKey(); final String expected = entry.getValue(); final String actual = substitution.substitute(text);  Assert."<AssertPlaceHolder>"; } }
substitute(final String text) { final StringBuilder builder = new StringBuilder();  for (int index = 0; index < text.length(); ) { final int position = text.indexOf("${", index);  if (position < 0) { builder.append(text, index, text.length()); break; }  builder.append(text, index, position); index = substitute(text, position, builder); }  return builder.toString(); }  private int substitute(final String source, int index, final StringBuilder target) { final int end = source.length(); final int start = index;  index += 2;  while (index < end) { char c = source.charAt(index);  if (c == '}') { final String key = source.substring(start + 2, index); final String value = lookup(key);  if (value == null) { target.append("${").append(key).append(":#UNRESOLVED#").append("}"); } else { target.append(value); }  return index + 1; }  if (c == ':' && index + 1 < end && source.charAt(index + 1) == '-') { final String key = source.substring(start + 2, index); final String value = lookup(key);  final int length = target.length(); final int mid = index + 2;  index = mid;  while (index < end) { c = source.charAt(index);  if (c == '}') { if (value != null) { target.setLength(length); target.append(value); }  return index + 1; }  if (c == '$' && index + 1 < end && source.charAt(index + 1) == '{') { index = substitute(source, index, target); continue; }  target.append(c); index++; }  target.insert(length, source, start, mid); return end; }  index++; }  target.append(source, start, end); return index; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: filteredListSizeIsCorrect1() { int k = 3; // instantiate random filter with parameter k KRandomFilter filter = new KRandomFilter(k); // call filter method to obtain filtered list List<MutationInstance> filteredList = filter.filterMutants(toFilter); // filtered list should be of size k "<AssertPlaceHolder>"; }
filterMutants(List<MutationInstance> toFilter) {  // determine number of mutants to run int n = this.percent ? (guidance.getSeenMutants() * k / 100) : k;  // shuffle list of mutants to randomize first n elements Collections.shuffle(toFilter);  // add first k mutants in list to filtered list List<MutationInstance> filtered = new ArrayList<>(); for(int i = 0; i < n && i < toFilter.size(); i++){ filtered.add(toFilter.get(i)); }  return filtered; }
[*] target: assertEquals(k, filteredList.size())
[-] pred: org. junit. Assert. assertEquals ( k, filteredList. size ( ) )
************************************
************************************
[+] input: writeRecombination1() { int[] data = new int[]{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; int[] expect = new int[]{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; List<Integer> src = Arrays.stream(data).boxed().collect(Collectors.toList()); List<S7ComGroup> recombination = S7SequentialGroupAlg.writeRecombination(src, 228, 17); int[] actual = recombination.stream().flatMap(x -> x.getItems().stream()) .mapToInt(S7ComItem::getRipeSize).toArray(); "<AssertPlaceHolder>"; }
writeRecombination(List<Integer> src, int targetSize, int extraSize) { List<S7ComGroup> groupList = new LinkedList<>(); S7ComGroup group = new S7ComGroup(); groupList.add(group); int sum = 0; for (int i = 0; i < src.size(); i++) { int number = src.get(i); int offset = 0; while (number > 0) { S7ComItem item = new S7ComItem(i, src.get(i), offset, 0, extraSize, 0); if (sum + number + item.getExtraSize() > targetSize) { item.setRipeSize(targetSize - sum - item.getExtraSize()); } else { item.setRipeSize(number); } number -= item.getRipeSize(); offset += item.getRipeSize(); sum += item.getTotalLength(); group.add(item); if (sum + extraSize >= targetSize) { group = new S7ComGroup(); groupList.add(group); sum = 0; } } } return groupList.stream().filter(x -> !x.getItems().isEmpty()).collect(Collectors.toList()); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: shouldDeleteNodeValueAndReturnAsJsonString() { JsonDelete jsonDelete = new JsonDelete(); String jsonEvent = "{"k1":"v1","k2":{"key1":"value1","key2":"value2","key3":"value3"}}"; String expectedJsonEvent = "{"k1":"v1"}"; String jPath = "$.k2"; String actual = jsonDelete.eval(jsonEvent, jPath); Assert."<AssertPlaceHolder>"; }
eval(String jsonEvent, String jPath) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).delete(JsonPath.compile(jPath)).jsonString(); }
[*] target: assertEquals(expectedJsonEvent, actual)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonEvent, actual )
************************************
************************************
[+] input: shouldNotProcessNullStringAsProperties() { Properties actualProperties = new ProtoIndexToFieldMapConverter().convert(null, null);  "<AssertPlaceHolder>"; }
convert(Method method, String input) { if (Strings.isNullOrEmpty(input)) { return null; } Type type = new TypeToken<Map<String, Object>>() { }.getType(); Map<String, Object> m = new Gson().fromJson(input, type); Properties properties = getProperties(m); validate(properties); return properties; }
[*] target: assertNull(actualProperties)
[-] pred: org. junit. Assert. assertNull ( actualProperties )
************************************
************************************
[+] input: testDivisionByZero() { System.out.println("division por cero"); double num1 = 0.0; double num2 = 0.0; Calculadora instance = new Calculadora(); double expResult = Double.NaN; double result = instance.division(num1, num2); "<AssertPlaceHolder>"; }
division(double num1, double num2) { if (num2 != 0) { return num1 / num2; } else { return Double.NaN; } }
[*] target: assertEquals(expResult, result, 0.0)
[-] pred: org. junit. Assert. assertEquals ( expResult, result, 0.0 )
************************************
************************************
[+] input: testVetoExceptionHtmlMessageWithHtmlLabel() { TestFormWithMandatoryField form = new TestFormWithMandatoryField(); form.getStringField().setLabelHtmlEnabled(true); form.getStringField().setLabel(HTML.italic("String") + " " + HTML.bold("Field")); String htmlErrorMessage = "";  String expectedErrorMessage = HTML.fragment( HTML.div(TEXTS.get("FormEmptyMandatoryFieldsMessage")), HTML.ul(HTML.li(form.getMainBox().getFullyQualifiedLabel(IValidateContentDescriptor.LABEL_SEPARATOR) + IValidateContentDescriptor.LABEL_SEPARATOR + "String Field"))) .toHtml();  try { form.validateForm(); } catch (VetoException ve) { htmlErrorMessage = ve.getHtmlMessage().toHtml(); }  "<AssertPlaceHolder>"; }
validateForm() { if (!interceptCheckFields()) { VetoException veto = new VetoException("Validate " + getClass().getSimpleName()); veto.consume(); throw veto; } if (!getHandler().onCheckFields()) { VetoException veto = new VetoException("Validate " + getClass().getSimpleName()); veto.consume(); throw veto; }  // check all fields that might be invalid FormFieldErrorCollector collector = createFormFieldErrorCollector(); visit(collector, IFormField.class); collector.firstProblem() .ifPresent(firstProblem -> handleFormErrors(firstProblem, collector.messagesOfInvalidFields(), collector.messagesOfMandatoryFields()));  if (!interceptValidate()) { VetoException veto = new VetoException("Validate " + getClass().getSimpleName()); veto.consume(); throw veto; } if (!getHandler().onValidate()) { VetoException veto = new VetoException("Validate " + getClass().getSimpleName()); veto.consume(); throw veto; } }
[*] target: assertEquals(expectedErrorMessage, htmlErrorMessage)
[-] pred: org. junit. Assert. assertEquals ( expectedErrorMessage, htmlErrorMessage )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeDataAndRuleRegexMisMatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "35"); subject.put("verify_aal", "2?"); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertFalse(flag)
[-] pred: org. junit. Assert. assertFalse ( flag )
************************************
************************************
[+] input: getAuthorizeUrlTest() { try { String url = webPageAuthorizationManager.getAuthorizeUrl("http://www.jlxxw.net", AuthScope.BASE, null); Assert."<AssertPlaceHolder>"; } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }
getAuthorizeUrl(@NotBlank(message = "重定向地址不能为空") @Pattern(regexp = "^([hH][tT]{2}
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
************************************
[+] input: toByteArray2() { ByteArraySerializer serializer = ByteArraySerializer.newInstance(); byte[] expect = new byte[]{(byte) 0x01, // 0, 25689 (byte) 0x00, (byte) 0x00, (byte) 0x64, (byte) 0x59, // 523975585 (byte) 0x3B, (byte) 0xA1, (byte) 0x1F, (byte) 0x3B, (byte) 0x3B, (byte) 0xA1, (byte) 0x1F, (byte) 0x3B, // 33.16f, -15.62f (byte) 0xA3, (byte) 0xD7, (byte) 0x42, (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, // 156665.35455556 (byte) 0xD6, (byte) 0x21, (byte) 0x39, (byte) 0xB7, (byte) 0x41, (byte) 0x03, (byte) 0x1F, (byte) 0xCA, // -56516.66664 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, // 23A (byte) 0x32, (byte) 0x33, (byte) 0x41};  ByteFormatBean bean = serializer.toObject(ByteFormatBean.class, expect); byte[] actual = serializer.toByteArray(bean); "<AssertPlaceHolder>"; bean.getInt32Data().byteValue(); }
toByteArray(final T targetBean) { try { // 组装数据，同时计算最大的字节长度 int buffSize = 0; List<ByteArrayParseData> parseDataList = new ArrayList<>(); for (final Field field : targetBean.getClass().getDeclaredFields()) { final ByteArrayVariable variable = field.getAnnotation(ByteArrayVariable.class); if (variable == null) { continue; } ByteArrayParameter parameter = new ByteArrayParameter(variable.byteOffset(), variable.bitOffset(), variable.count(), variable.type(), variable.littleEndian(), variable.format()); this.checkByteArrayVariable(parameter); parseDataList.add(new ByteArrayParseData(variable, field)); int maxPos = variable.byteOffset() + variable.count() * variable.type().getByteLength(); if (maxPos > buffSize) { buffSize = maxPos; } } if (buffSize == 0 || parseDataList.isEmpty()) { return new byte[0]; } // 填充字节数组的内容 ByteWriteBuff buff = ByteWriteBuff.newInstance(buffSize); for (ByteArrayParseData item : parseDataList) { item.getField().setAccessible(true); Object data = item.getField().get(targetBean); if (data == null) { continue; } if (item.getVariable().count() == 1) { this.fillOneData(item.getVariable(), data, buff, 0); } else { this.fillListData(item.getVariable(), data, buff); } } return buff.getData(); } catch (Exception e) { throw new ByteArrayParseException("parsing to object error, cause:" + e.getMessage(), e); } }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: updateByCategoryType() { int result = mapper.updateByCategoryType("清蒸", 7); Assert."<AssertPlaceHolder>"; }
updateByCategoryType(@Param("categoryName") String categoryName, @Param("categoryType") Integer categoryType);  /** * 通过对象更新 * @param productCategory * @return */ @Update("update product_category set category_name = #{categoryName}
[*] target: assertEquals(1,result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: shouldReturnOutputColumnIndex() { HashMap<String, Object> stringObjectHashMap = new HashMap<>(); stringObjectHashMap.put("outputColumnName", "features"); HashMap<String, String> data = new HashMap<>(); data.put("keyColumnName", "customer_id"); data.put("valueColumnName", "order_number"); data.put("type", "StingType"); List<HashMap<String, String>> hashMaps = Collections.singletonList(data); stringObjectHashMap.put("data", hashMaps);  String[] inputColumnNames = {"customer_id", "order_number", "features"}; FeatureWithTypeHandler featureWithTypeHandler = new FeatureWithTypeHandler(stringObjectHashMap, inputColumnNames); int outputColumnIndex = featureWithTypeHandler.getOutputColumnIndex();  Assert."<AssertPlaceHolder>"; }
getOutputColumnIndex() { int outputColumnIndex = Arrays.asList(inputColumns).indexOf(outputColumnName); if (outputColumnIndex == -1) { throw new IllegalArgumentException("OutputColumnName is not given or not exist"); } return outputColumnIndex; }
[*] target: assertEquals(2, outputColumnIndex)
[-] pred: org. junit. Assert. assertEquals ( 2, outputColumnIndex )
************************************
************************************
[+] input: shouldBeAbleToBuildSourceIfSourceDetailsIsUnboundedKafkaConsumerAndDaggerDeserializerIsKafkaDeserializationSchema() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); FlinkKafkaConsumerDaggerSource daggerSource = new FlinkKafkaConsumerDaggerSource(streamConfig, configuration, daggerDeserializer);  "<AssertPlaceHolder>"; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }
[*] target: assertTrue(daggerSource.canBuild())
[-] pred: org. junit. Assert. assertTrue ( daggerSource. canBuild ( ) )
************************************
************************************
[+] input: shouldNotBeAbleToBuildSourceIfSourceDetailsContainsMultipleBackToBackSources() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED), new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); KafkaDaggerSource daggerSource = new KafkaDaggerSource(streamConfig, configuration, daggerDeserializer);  "<AssertPlaceHolder>"; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }
[*] target: assertFalse(daggerSource.canBuild())
[-] pred: org. junit. Assert. assertFalse ( daggerSource. canBuild ( ) )
************************************
************************************
[+] input: miss_DoTable_Miss_IgnoreTable_Hit_DoWildTable_Hit_IgnoreDb_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb(""); replicaMeta.setIgnoreDb("full_src_1, dutf8"); replicaMeta.setDoTable(""); replicaMeta.setIgnoreTable(""); replicaMeta.setWildDoTable("d%.tb\\_charset%, d%.col\\_charset%"); replicaMeta.setWildIgnoreTable(""); replicaMeta.setRewriteDb(""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema("dutf8"); rowChange.setTable("tb_charset_gbk"); Assert."<AssertPlaceHolder>"; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }
[*] target: assertTrue(filter.ignoreEvent(rowChange))
[-] pred: org. junit. Assert. assertTrue ( filter. ignoreEvent ( rowChange ) )
************************************
************************************
[+] input: testGenerate() { String generatedMobileNum = ChineseMobileNumberGenerator.getInstance() .generate(); "<AssertPlaceHolder>"; System.err.println(generatedMobileNum); }
generate() { return genMobilePre() + StringUtils .leftPad("" + RandomUtils.nextInt(0, 99999999 + 1), 8, "0"); }
[*] target: assertNotNull(generatedMobileNum)
[-] pred: org. junit. Assert. assertNotNull ( generatedMobileNum )
************************************
************************************
[+] input: testFillTabWithSpace() { String sql = "   select sum(rate)      from                                                                          feed_receive_0117                                                            t             where       RATED_UID=?     and RATER_UID=?     and suspended=0 and validscore=1      and rater_type=?     and trade_closingdate>=?     and trade_closingdate<?     and id<>?        and (IFNULL(IMPORT_FROM, 0)&8) = 0        #@#mysql_feel_01#@#EXECUTE_A_SQL_TIMEOUT#@#1#@#484#@#484#@#484"; String assertSql = "select sum(rate) from feed_receive_0117 t where RATED_UID=? and RATER_UID=? and suspended=0 and validscore=1 and rater_type=? and trade_closingdate>=? and trade_closingdate<? and id<>? and (IFNULL(IMPORT_FROM, 0)&8) = 0 #@#mysql_feel_01#@#EXECUTE_A_SQL_TIMEOUT#@#1#@#484#@#484#@#484"; String acutulSql = null; acutulSql = TStringUtil.fillTabWithSpace(sql); Assert."<AssertPlaceHolder>"; }
fillTabWithSpace(String str) { if (str == null) { return null; }  str = str.trim(); int sz = str.length(); StringBuilder buffer = new StringBuilder(sz);  int index = 0, index0 = -1, index1 = -1; for (int i = 0; i < sz; i++) { char c = str.charAt(i); if (!Character.isWhitespace(c)) { if (index0 != -1) {  if (index0 != index1 || str.charAt(i - 1) != ' ') { buffer.append(str.substring(index, index0)).append(" "); index = index1 + 1; } } index0 = index1 = -1; } else { if (index0 == -1) { index0 = index1 = i; } else { index1 = i; } } }  buffer.append(str.substring(index)); return buffer.toString(); }
[*] target: assertEquals(assertSql, acutulSql)
[-] pred: org. junit. Assert. assertEquals ( assertSql, acutulSql )
************************************
************************************
[+] input: testCheckAndSet_EnableCaching_IfNoneMatch_false() { Mockito.when(req.getPathInfo()).thenReturn("/"); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn("W/"FooBar"");//non-matching E-Tag Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(0L);  BinaryResource res = BinaryResources.create() .withFilename("a.html") .withContent("<html></html>".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModifiedNow() .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey("/"), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert."<AssertPlaceHolder>";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute("jakarta.servlet.forward.path_info"); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, "private, max-age=0, must-revalidate"); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.ETAG, obj.createETag()); Mockito.verify(resp, ONCE).setDateHeader(HttpCacheControl.LAST_MODIFIED, obj.getResource().getLastModified()); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // "private" //   Only browsers may cache this resource. // "max-age" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because "must-revalidate" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, "private, max-age=" + maxAge + ", s-maxage=" + maxAge); } else { // "private" //   Only browsers may cache this resource. // "must-revalidate" //   A cache HAS TO check with the server before using stale resources. // "max-age=0" //   A resource will become stale immediately (after 0 seconds). // Note: "max-age=0, must-revalidate" would be the same as "no-cache" resp.setHeader(CACHE_CONTROL, "private, max-age=0, must-revalidate"); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-None-Match/Etag): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-Modified-Since): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }
[*] target: assertFalse(b)
[-] pred: org. junit. Assert. assertFalse ( b )
************************************
************************************
[+] input: shouldReturnEmptyCollectionOnNullEnvVars() { HashMap<String, String> systemEnvs = null; Map<String, String> expectedEnvVars = new HashMap<>();  Map<String, String> actualEnvVars = KafkaEnvironmentVariables.parse(systemEnvs);  "<AssertPlaceHolder>"; }
parse(Map<String, String> envVars) { if (envVars == null || envVars.isEmpty()) { return Collections.emptyMap(); } Map<String, String> kafkaEnvVars = envVars.entrySet() .stream() .filter(a -> a.getKey().toLowerCase().startsWith(KAFKA_PREFIX)) .collect(Collectors.toMap(e -> parseVarName(e.getKey()), e -> e.getValue())); return kafkaEnvVars; }
[*] target: assertEquals(expectedEnvVars, actualEnvVars)
[-] pred: org. junit. Assert. assertEquals ( expectedEnvVars, actualEnvVars )
************************************
************************************
[+] input: getExtensionLoaderTest() { ExtensionLoader<?> extensionLoader = ExtensionLoader.getLoader(Extension.class); Assert."<AssertPlaceHolder>"; }
getLoader(Class<S> type) { // 扩展类型必须是接口 if (!type.isInterface()) { throw new IllegalStateException(type.getName() + " is not interface"); } SPI annotation = type.getAnnotation(SPI.class); if (annotation == null) { throw new IllegalStateException(type.getName() + " has not @SPI annotation."); } ExtensionLoader<?> extensionLoader = extensionLoaderCache.get(type); if (extensionLoader != null) { //noinspection unchecked return (ExtensionLoader<S>) extensionLoader; } extensionLoader = new ExtensionLoader<>(type); extensionLoaderCache.putIfAbsent(type, extensionLoader); //noinspection unchecked return (ExtensionLoader<S>) extensionLoader; }
[*] target: assertNotNull(extensionLoader)
[-] pred: org. junit. Assert. assertNotNull ( extensionLoader )
************************************
************************************
[+] input: convertLineString_WithRedundantSpaces_ShouldConvert() { String wkt = "LINESTRING (     30  10, 10 30 , 40 40    )"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"LineString", "coordinates": [[30,10],[10,30],[40,40]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: testSha256() { String str = "a-string-to-hash"; String expectedValue = "47bd5d1c4ab68a55391f0b5304481eb11cb6a7a33066bb8d69c114a69254fdb2";  String actualValue = SignatureMethodEnum.SHA256.calcSign(str);  "<AssertPlaceHolder>"; }
calcSign(String str) { return signCalculator.calc(str); }
[*] target: assertEquals(expectedValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualValue )
************************************
************************************
[+] input: testFindByLastNameIgnoreCase() { List<Student> expectedList = entities() .map(repository::save) .filter(student -> student.getLastName().equalsIgnoreCase("Stark")) .collect(Collectors.toList());  List<Student> actualList = repository.findByLastNameIgnoreCase("Stark"); Assert."<AssertPlaceHolder>"; }
findByLastNameIgnoreCase(@Param("lName") String lastName);
[*] target: assertEquals(expectedList, actualList)
[-] pred: org. junit. Assert. assertEquals ( expectedList, actualList )
************************************
************************************
[+] input: channelShouldBeAddedForAHostAndPort() {  grpcSourceConfig = mock(GrpcSourceConfig.class);  GrpcClient grpcClient = new GrpcClient(grpcSourceConfig);  when(grpcSourceConfig.getEndpoint()).thenReturn("localhost"); when(grpcSourceConfig.getServicePort()).thenReturn(8080);  grpcClient.addChannel();  Channel decoratedChannel = grpcClient.getDecoratedChannel(); "<AssertPlaceHolder>";  }
getDecoratedChannel() { return decoratedChannel; }
[*] target: assertNotNull(decoratedChannel)
[-] pred: org. junit. Assert. assertNotNull ( decoratedChannel )
************************************
************************************
[+] input: testAppendIterator() { LogRecord expected = new MasterLogRecord(1234);  logManager.appendToLog(expected); LogRecord record = logManager.iterator().next();  "<AssertPlaceHolder>"; }
next() { if (hasNext()) { final BacktrackingIterator<LogRecord> iter = nextIter; BacktrackingIterable<LogRecord> iterable = () -> iter;  nextIter = null; do { ++nextIndex; try { Page page = bufferManager.fetchPage(new DummyLockContext(), nextIndex); nextIter = new LogPageIterator(page, 0); } catch (PageException e) { break; } } while (!nextIter.hasNext());  return iterable; } throw new NoSuchElementException(); }
[*] target: assertEquals(expected, record)
[-] pred: org. junit. Assert. assertEquals ( expected, record )
************************************
************************************
[+] input: testErrorDueToESException() { when(openSearchConnection.select(anyString())) .thenThrow(new RuntimeException("All shards failure"));  TestReport expected = new TestReport(); expected.addTestCase( new ErrorTestCase(1, "SELECT * FROM accounts", "RuntimeException: All shards failure")); TestReport actual = correctnessTest.verify(querySet("SELECT * FROM accounts")); "<AssertPlaceHolder>"; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format("%s: %s", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testPrintEnvironments() { BeneratorUtil.printEnvironments(); "<AssertPlaceHolder>"; }
printEnvironments() { ConsolePrinter.printStandard(formatEnvironmentList()); }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: testUtf8Subject() { String s = null; try { s = MimeUtility.decodeText(ENV_UTF8_ENCODED_SUBJECT); } catch (UnsupportedEncodingException ex) { } final String subject = s;  testWithHandler( new IMAPTest() { @Override public void test(Folder folder, IMAPHandlerMessage handler) throws MessagingException { Message m = folder.getMessage(1); "<AssertPlaceHolder>"; } }, new IMAPHandlerMessage() { { { envelope = "(" + ENV_DATE + " "" + subject + "" " + ENV_ADDRS + ")"; capabilities += " ENABLE UTF8=ACCEPT"; } }  @Override public void enable(String line) throws IOException { ok(); } }); }
getSubject() throws MessagingException { checkExpunged(); if (bodyLoaded) return super.getSubject();  if (subject != null) // already cached ? return subject;  loadEnvelope(); if (envelope.subject == null) // no subject return null;  // Cache and return the decoded value. try { // The server *should* unfold the value, but just in case it // doesn't we unfold it here. subject = MimeUtility.decodeText(MimeUtility.unfold(envelope.subject)); } catch (UnsupportedEncodingException ex) { subject = envelope.subject; }  return subject; }
[*] target: assertEquals(subject, m.getSubject())
[-] pred: org. junit. Assert. assertEquals ( subject, m. getSubject ( ) )
************************************
************************************
[+] input: toByteArray() { PlcStopParameter parameter = new PlcStopParameter(); parameter.setPiService("P_PROGRAM"); byte[] actual = parameter.toByteArray(); byte[] expect = {(byte) 0x29, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x09, (byte) 0x50, (byte) 0x5f, (byte) 0x50, (byte) 0x52, (byte) 0x4F, (byte) 0x47, (byte) 0x52, (byte) 0x41, (byte) 0x4D}; "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(7 + this.lengthPart) .putByte(this.functionCode.getCode()) .putBytes(this.unknownBytes) .putByte(this.lengthPart) .putString(this.piService) .getData(); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: testCreateCatalog() { RocketMQCatalogFactory factory = new RocketMQCatalogFactory(); FactoryUtil.DefaultCatalogContext context = new FactoryUtil.DefaultCatalogContext( "rocketmq-catalog", new HashMap<>(), null, this.getClass().getClassLoader()); Catalog catalog = factory.createCatalog(context); "<AssertPlaceHolder>"; }
createCatalog(Context context) { final FactoryUtil.CatalogFactoryHelper helper = FactoryUtil.createCatalogFactoryHelper(this, context); helper.validate(); return new RocketMQCatalog( context.getName(), helper.getOptions().get(DEFAULT_DATABASE), helper.getOptions().get(NAME_SERVER_ADDR), helper.getOptions().get(SCHEMA_REGISTRY_BASE_URL)); }
[*] target: assertNotNull(catalog)
[-] pred: org. junit. Assert. assertNotNull ( catalog )
************************************
************************************
[+] input: testInstNonExistingPort() { boolean thrown = false; try { ForwarderSwitch device = new ForwarderSwitch(0, null, 5, new IdentityFlowletIntermediary()); device.addConnection(topology.getPort(0, 1)); device.setDestinationToNextSwitch(1, 2); } catch (IllegalArgumentException e) { thrown = true; } "<AssertPlaceHolder>"; }
setDestinationToNextSwitch(int destinationId, int nextHopId) { if (!connectedTo.contains(nextHopId)) { throw new IllegalArgumentException("Cannot add hop to a network device to which it is not connected (" + nextHopId + ")"); } this.destinationToNextSwitch[destinationId] = nextHopId; }
[*] target: assertTrue(thrown)
[-] pred: org. junit. Assert. assertTrue ( thrown )
************************************
************************************
[+] input: shouldGetValueForValueForGivenKeyInGivenMap() { ArrayList<Row> rows = new ArrayList<>(); Row row1 = new Row(2); String expectedValue = "0.4"; row1.setField(0, "payment_switch"); row1.setField(1, "PB-123456"); Row row2 = new Row(2); row2.setField(0, "weighted_abuse_probability"); row2.setField(1, expectedValue); String givenKey = "weighted_abuse_probability";  rows.add(row1); rows.add(row2);   MapGet mapGet = new MapGet(); Object actualValue = mapGet.eval(rows.toArray(new Row[0]), givenKey);  "<AssertPlaceHolder>"; }
eval(Row[] inputMap, Object key) { List<Row> rows = Arrays.asList(inputMap); Optional<Row> requiredRow = rows.stream().filter(row -> row.getField(0).equals(key)).findFirst(); return requiredRow.map(row -> row.getField(1)).orElse(null); }
[*] target: assertEquals(expectedValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualValue )
************************************
************************************
[+] input: testCoalesceEmptySet() { InvalidateCacheNotificationCoalescer coalescer = new InvalidateCacheNotificationCoalescer(); List<InvalidateCacheNotification> res = coalescer.coalesce(new ArrayList<>()); "<AssertPlaceHolder>"; }
coalesce(List<InvalidateCacheNotification> notifications) { List<InvalidateCacheNotification> result = new ArrayList<>(); if (notifications.isEmpty()) { return result; } Map<String, List<ICacheEntryFilter<?, ?>>> filterMap = new HashMap<>(); for (InvalidateCacheNotification notification : notifications) { List<ICacheEntryFilter<?, ?>> list = filterMap.get(notification.getCacheId()); if (list == null) { list = new ArrayList<>(); list.add(notification.getFilter()); } else { coalesceFilters(list, notification.getFilter()); } filterMap.put(notification.getCacheId(), list); }  for (Entry<String, List<ICacheEntryFilter<?, ?>>> entry : filterMap.entrySet()) { for (ICacheEntryFilter<?, ?> filter : entry.getValue()) { result.add(new InvalidateCacheNotification(entry.getKey(), filter)); } } return result; }
[*] target: assertTrue(res.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( res. isEmpty ( ) )
************************************
************************************
[+] input: testFilterColumns() { String sqlInput = "CREATE TABLE `omc_index_col_unique_test_gsi1` \n" + "( `a` int(11) NOT NULL,\n" + " `B` bigint(20) DEFAULT NULL, \n" + " `c` bigint(20) DEFAULT NULL, \n" + " PRIMARY KEY (`a`), \n" + " UNIQUE KEY `b` (`b`), \n" + " UNIQUE KEY `c` USING BTREE (`c`), \n" + " INDEX `idx_i` using btree(`B`)," + " UNIQUE KEY `b_zplr` \n" + " USING BTREE (`c`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4"; String sqlOutput = "CREATE TABLE `omc_index_col_unique_test_gsi1` (\n" + "\t`a` int(11) NOT NULL,\n" + "\t`c` bigint(20) DEFAULT NULL,\n" + "\tPRIMARY KEY (`a`),\n" + "\tUNIQUE KEY `c` USING BTREE (`c`),\n" + "\tUNIQUE KEY `b_zplr` USING BTREE (`c`)\n" + ") ENGINE = InnoDB DEFAULT CHARSET = utf8mb4";  List<SQLStatement> statementList = SQLParserUtils.createSQLStatementParser(sqlInput, DbType.mysql, SQL_PARSE_FEATURES).parseStatementList(); MySqlCreateTableStatement createStmt = (MySqlCreateTableStatement) statementList.get(0); filterColumns(createStmt, Lists.newArrayList("b")); String result = createStmt.toString(); Assert."<AssertPlaceHolder>"; }
filterColumns(MySqlCreateTableStatement stmt, List<String> toRemoveColumns) { if (!toRemoveColumns.isEmpty()) { Iterator<SQLTableElement> iterator = stmt.getTableElementList().iterator(); while (iterator.hasNext()) { SQLTableElement element = iterator.next(); if (element instanceof SQLColumnDefinition) { SQLColumnDefinition definition = (SQLColumnDefinition) element; String c1 = normalize(definition.getColumnName()); if (toRemoveColumns.contains(c1.toLowerCase())) { iterator.remove(); } } else if (element instanceof MySqlPrimaryKey) { MySqlPrimaryKey column = (MySqlPrimaryKey) element; List<SQLSelectOrderByItem> pks = column.getColumns(); for (SQLSelectOrderByItem pk : pks) { String name = getSqlName(pk.getExpr()); if (toRemoveColumns.contains(name.toLowerCase())) { iterator.remove(); break; } } } else if (element instanceof MySqlUnique) { MySqlUnique column = (MySqlUnique) element; List<SQLSelectOrderByItem> uks = column.getColumns(); for (SQLSelectOrderByItem uk : uks) { String name = getSqlName(uk.getExpr()); if (toRemoveColumns.contains(name.toLowerCase())) { iterator.remove(); break; } } } else if (element instanceof MySqlTableIndex) { MySqlTableIndex column = (MySqlTableIndex) element; List<SQLSelectOrderByItem> indexes = column.getColumns(); for (SQLSelectOrderByItem idx : indexes) { String name = getSqlName(idx.getExpr()); if (toRemoveColumns.contains(name.toLowerCase())) { iterator.remove(); break; } } } } } }
[*] target: assertEquals(sqlOutput, result)
[-] pred: org. junit. Assert. assertEquals ( sqlOutput, result )
************************************
************************************
[+] input: testFindByLastName() { List<Student> expectedList = entities() .map(repository::save) .filter(student -> student.getLastName().equals("Stark")) .collect(Collectors.toList());  List<Student> actualList = repository.findByLastName("Stark");  Assert."<AssertPlaceHolder>"; }
findByLastName(@Param("lName") String lastName);
[*] target: assertEquals(expectedList, actualList)
[-] pred: org. junit. Assert. assertEquals ( expectedList, actualList )
************************************
************************************
[+] input: loadBlankConfigFile() { Enumeration<URL> configFileEnumeration = createConfigFileEnumeration("blank_yidun_regional_endpoints.json");  Map<String, Map<String, List<String>>> domainMap = EndpointConfigLoader.load(configFileEnumeration);  "<AssertPlaceHolder>"; }
load(Enumeration<URL> configFileUrls) { Map<String, Map<String, List<String>>> domainMap = new HashMap<>();  while (configFileUrls.hasMoreElements()) { List<EndpointConfigEntry> entries = parseConfig(configFileUrls.nextElement()); mergeConfig(domainMap, entries); }  return domainMap; }
[*] target: assertTrue(domainMap.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( domainMap. isEmpty ( ) )
************************************
************************************
[+] input: shouldReturnNullWhenTimeStampNotAvailableAndFieldDescriptorOfTypeTimeStampForTransformForPostProcessor() { Descriptors.Descriptor descriptor = TestBookingLogMessage.getDescriptor(); Descriptors.FieldDescriptor fieldDescriptor = descriptor.findFieldByName("booking_creation_time");  TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(fieldDescriptor);  Object value = typeHandler.transformFromPostProcessor(null); "<AssertPlaceHolder>"; }
transformFromPostProcessor(Object field) { return isValid(field) ? field.toString() : null; }
[*] target: assertNull(value)
[-] pred: org. junit. Assert. assertNull ( value )
************************************
************************************
[+] input: includeListTest() {  ProviderConfig providerConfig = new ProviderConfig(); DefaultProviderBootstrap defaultProviderBootstra = new DefaultProviderBootstrap(providerConfig); boolean result = defaultProviderBootstra.inList("hello1", "hello2", "hello1"); Assert."<AssertPlaceHolder>"; }
inList(String includeMethods, String excludeMethods, String methodName) { //判断是否在白名单中 if (!StringUtils.ALL.equals(includeMethods)) { if (!inMethodConfigs(includeMethods, methodName)) { return false; } } //判断是否在黑白单中 if (inMethodConfigs(excludeMethods, methodName)) { return false; } //默认还是要发布 return true;  }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: hasTypeShouldBeFalseWhenTypeIsNull() { EsSourceConfig esSourceConfig = new EsSourceConfigBuilder() .setType(null) .createEsSourceConfig(); "<AssertPlaceHolder>"; }
hasType() { return StringUtils.isNotEmpty(type); }
[*] target: assertFalse(esSourceConfig.hasType())
[-] pred: org. junit. Assert. assertFalse ( esSourceConfig. hasType() )
************************************
************************************
[+] input: byteArrayLength() { COTPData cotpData = new COTPData(); "<AssertPlaceHolder>"; }
byteArrayLength() { return BYTE_LENGTH; }
[*] target: assertEquals(3, cotpData.byteArrayLength())
[-] pred: org. junit. Assert. assertEquals ( 3, cotpData. byteArrayLength() )
************************************
************************************
[+] input: mp4DrefBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x1C, 0x64, 0x72, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x75, 0x72, 0x6C, 0x20, 0x00, 0x00, 0x00, 0x01, }; Mp4DrefBox box = new Mp4DrefBox(); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: shouldNotProvideSimpleGroupDeserializerWhenSourceNameIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); when(streamConfig.getDataType()).thenReturn("PROTO");  SimpleGroupDeserializerProvider provider = new SimpleGroupDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator);  "<AssertPlaceHolder>"; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!sourceName.equals(COMPATIBLE_SOURCE) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }
[*] target: assertFalse(provider.canProvide())
[-] pred: org. junit. Assert. assertFalse ( provider. canProvide() )
************************************
************************************
[+] input: testIterableEnumeration() { final int size = 10; Enumeration<Integer> e = new Enumeration<Integer>() { int ctr = 0;  @Override public Integer nextElement() { return (ctr++); }  @Override public boolean hasMoreElements() { return (ctr < size); } };  List<Integer> found = new ArrayList<Integer>(); for (Integer i : CollectionUtil.iterable(e.asIterator())) found.add(i); "<AssertPlaceHolder>"; }
iterable(final Iterator<T> it) { return (new Iterable<T>() { @Override public Iterator<T> iterator() { return (it); } }); }
[*] target: assertEquals(size, found.size())
[-] pred: org. junit. Assert. assertEquals ( size, found. size ( ) )
************************************
************************************
[+] input: testGenerate() { String generatedName = EnglishNameGenerator.getInstance().generate(); "<AssertPlaceHolder>"; System.err.println(generatedName); }
generate() { //英文名 return genFirstName(); }
[*] target: assertNotNull(generatedName)
[-] pred: org. junit. Assert. assertNotNull ( generatedName )
************************************
************************************
[+] input: Exception { String name = "test_force"; FastKV kv1 = new FastKV.Builder(TestHelper.DIR, name).build(); long newTime = System.currentTimeMillis() ^ System.nanoTime();  kv1.putLong("time", newTime); kv1.force();  File aFile = new File(TestHelper.DIR, name + ".kva"); RandomAccessFile accessFile = new RandomAccessFile(aFile, "r"); ByteBuffer buffer = ByteBuffer.allocate(26); buffer.order(ByteOrder.LITTLE_ENDIAN); accessFile.read(buffer.array(), 0, 26); long t = buffer.getLong(18); Assert."<AssertPlaceHolder>"; }
force() { if (closed) return; if (writingMode == NON_BLOCKING) { aBuffer.force(); bBuffer.force(); } }
[*] target: assertEquals(newTime, t)
[-] pred: org. junit. Assert. assertEquals ( newTime, t )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x0F, (byte) 0x00, (byte) 0x13, (byte) 0x00, (byte) 0x0A}; MbWriteMultipleCoilResponse mb = new MbWriteMultipleCoilResponse(); mb.setFunctionCode(EMbFunctionCode.WRITE_MULTIPLE_COIL); mb.setAddress(19); mb.setQuantity(10); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: testApplicationInfo() { ApplicationInfoRequest request = new ApplicationInfoRequest(); request.setAppName("test"); boolean result = meshApiClient.registeApplication(request); Assert."<AssertPlaceHolder>"; }
registeApplication(ApplicationInfoRequest applicationInfoRequest) {  final String json = applicationInfoRequest.toJson(); String result = httpPost(MeshEndpoint.CONFIGS, json);  if (!StringUtils.equals(result, errorMessage)) { final ApplicationInfoResult parse = JSON.parseObject(result, ApplicationInfoResult.class); if (parse.isSuccess()) { return true; } return false; } else { return false; }  }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testGgenerateFake() { String generatedMobileNum = ChineseMobileNumberGenerator.getInstance() .generateFake(); "<AssertPlaceHolder>"; System.err.println(generatedMobileNum); }
generateFake() { return "19" + StringUtils .leftPad("" + RandomUtils.nextInt(0, 999999999 + 1), 9, "0"); }
[*] target: assertNotNull(generatedMobileNum)
[-] pred: org. junit. Assert. assertNotNull ( generatedMobileNum )
************************************
************************************
[+] input: convertPolygonWithHole_WithRedundantSpaces_ShouldConvert() { String wkt = "POLYGON ( (35 10, 45 45, 15 40, 10 20, 35 10 ), (20 30 , 35 35, 30 20,   20 30 ) ) "; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"Polygon", "coordinates":" + " [[[35,10],[45,45],[15,40],[10,20],[35,10]],[[20,30],[35,35],[30,20],[20,30]]]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: createRsaJsonWebKeyJson() { String jwkJson = JwkUtil.createRsaJsonWebKeyJson("jap-jwks-keyid", TokenSigningAlg.RS256); Assert."<AssertPlaceHolder>"; }
createRsaJsonWebKeyJson(String keyId, TokenSigningAlg signingAlg) { RsaJsonWebKey jwk = createRsaJsonWebKey(keyId, signingAlg); return jwk.toJson(RsaJsonWebKey.OutputControlLevel.INCLUDE_PRIVATE); }
[*] target: assertNotNull(jwkJson)
[-] pred: org. junit. Assert. assertNotNull ( jwkJson )
************************************
************************************
[+] input: convertPoint_FirstIsRoundNumber_ShouldConvert() { String wkt = "POINT(12 13.3)"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"Point", "coordinates": [12,13.3]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: testSetOrdered() { EAN13Generator ean13Generator = new EAN13Generator(); ean13Generator.setOrdered(true); "<AssertPlaceHolder>"; }
isOrdered() { return ordered; }
[*] target: assertTrue(ean13Generator.isOrdered())
[-] pred: org. junit. Assert. assertTrue ( ean13Generator. isOrdered() )
************************************
************************************
[+] input: JSONException { ITree tree = createTreeWithOneNode(); JsonTree<ITree> jsonTree = m_uiSession.createJsonAdapter(tree, new JsonAdapterMock()); Assert."<AssertPlaceHolder>"; }
getOrCreateNodeId(ITreeNode node) { if (node == null) { return null; } if (isInvisibleRootNode(node)) { return null; } String id = m_treeNodeIds.get(node); if (id != null) { return id; } id = getUiSession().createUniqueId(); m_treeNodes.put(id, node); m_treeNodeIds.put(node, id); return id; }
[*] target: assertNull(jsonTree.getOrCreateNodeId(null))
[-] pred: org. junit. Assert. assertNull ( jsonTree. getOrCreateNodeId ( null ) )
************************************
************************************
[+] input: should_ReturnNoErrors_When_ValidEndpointNameGiven() { String validationResult = checker.check("ordinaryName");  "<AssertPlaceHolder>"; }
check(String endpointName) { if (endpointName == null || endpointName.isEmpty()) { return "Endpoint name cannot be blank"; } if (ECMA_SCRIPT_RESERVED_WORDS.contains(endpointName)) { return "Endpoint name cannot be equal to JavaScript reserved words"; } if (WHITESPACE_PATTERN.matcher(endpointName).find()) { return "Endpoint name cannot contain any whitespaces"; } return null; }
[*] target: assertNull(validationResult)
[-] pred: org. junit. Assert. assertNull ( validationResult )
************************************
************************************
[+] input: testReadBytes() { byte[] expected = new byte[]{0, 1, 2, 3}; byte[] actual = IOUtility.readBytes(newInputStream(expected)); "<AssertPlaceHolder>"; }
readBytes(InputStream in) { return readBytes(in, -1); }
[*] target: assertArrayEquals(expected, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expected, actual )
************************************
************************************
[+] input: testIsReplacePgCatalogTables_defaultTrue() { OptionsMetadata optionsMetadata = mock(OptionsMetadata.class); when(optionsMetadata.replacePgCatalogTables()).thenReturn(true); SessionState state = new SessionState( ImmutableMap.of( "spanner.replace_pg_catalog_tables", new PGSetting("spanner", "replace_pg_catalog_tables")), optionsMetadata); "<AssertPlaceHolder>"; }
isReplacePgCatalogTables() { PGSetting setting = internalGet(toKey("spanner", "replace_pg_catalog_tables"), false); if (setting == null) { return true; } return tryGetFirstNonNull( true, () -> BooleanParser.toBoolean(setting.getSetting()), () -> BooleanParser.toBoolean(setting.getResetVal()), () -> BooleanParser.toBoolean(setting.getBootVal())); }
[*] target: assertTrue(state.isReplacePgCatalogTables())
[-] pred: org. junit. Assert. assertTrue ( state. isReplacePgCatalogTables ( ) )
************************************
************************************
[+] input: testVarchar() { setConfig(ConfigKeys.TASK_EXTRACT_REBUILD_DATA_LOG, "true"); String str = "abcdefgh"; Field field = MakeFieldFactory.makeField("varchar(5)", str, "utf8", false, false); RowDataRebuildLogger logger = new RowDataRebuildLogger(); Serializable s = logger.doDecode(field.getMysqlType().getType(), field.doGetTableMeta(), field.encode(), "utf8", false); Assert."<AssertPlaceHolder>"; }
doDecode(int type, byte[] meta, byte[] data, String charset, boolean isUnsigned) { int m = decodeMeta(type, meta); String javaCharset = CharsetConversion.getJavaCharset(charset); return logBuffer .fetchValue(type, m, false, new LogBuffer(data, 0, data.length), javaCharset, isUnsigned); }
[*] target: assertEquals(str, s)
[-] pred: org. junit. Assert. assertEquals ( str, s )
************************************
************************************
[+] input: testUnPublish() { UnPublishServiceRequest request = new UnPublishServiceRequest(); request.setServiceName("aa"); int result = meshApiClient.unPublishService(request); Assert."<AssertPlaceHolder>"; }
unPublishService(UnPublishServiceRequest request) {  final String json = JSON.toJSONString(request); String result = httpPost(MeshEndpoint.UN_PUBLISH, json);  if (!StringUtils.equals(result, errorMessage)) { final UnPublishServiceResult parse = JSON.parseObject(result, UnPublishServiceResult.class); if (parse.isSuccess()) { return 1; } return 0; } else { return 0; }  }
[*] target: assertEquals(1, result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: testWriteString() { String expected = "0123"; StringWriter out = new StringWriter(); IOUtility.writeString(out, expected); String actual = out.toString(); "<AssertPlaceHolder>"; }
writeString(Writer out, String s) { try { out.write(s); } catch (IOException e) { throw new ProcessingException("output: " + out, e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldParseProtoByteDataFromBigTable() { ArrayList<Result> results = new ArrayList<>(); results.add(scanResult); byte[] mockResult = Bytes.toBytes("test"); when(scanResult.getValue(COLUMN_FAMILY_NAME, Bytes.toBytes(Constants.LONGBOW_QUALIFIER_DEFAULT))).thenReturn(mockResult); LongbowProtoData longbowProtoData = new LongbowProtoData(); Map<String, List<byte[]>> actualMap = longbowProtoData.parse(results); Map<String, List<byte[]>> expectedMap = new HashMap<String, List<byte[]>>() {{ put("proto_data", Arrays.asList(mockResult)); }}; "<AssertPlaceHolder>"; }
parse(List<Result> scanResult) { ArrayList<byte[]> data = new ArrayList<>();  for (int i = 0; i < scanResult.size(); i++) { data.add(i, scanResult.get(i).getValue(COLUMN_FAMILY_NAME, Bytes.toBytes(Constants.LONGBOW_QUALIFIER_DEFAULT))); }  HashMap<String, List<byte[]>> longbowData = new HashMap<>(); longbowData.put(Constants.LONGBOW_PROTO_DATA_KEY, data); return longbowData; }
[*] target: assertEquals(expectedMap, actualMap)
[-] pred: org. junit. Assert. assertEquals ( expectedMap, actualMap )
************************************
************************************
[+] input: shouldFetchValueForFieldForFieldDescriptorOfTypeString() { String actualValue = "test";  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("order_number"); StringHandler stringHandler = new StringHandler(fieldDescriptor); Object value = stringHandler.parseObject(actualValue);  "<AssertPlaceHolder>"; }
parseObject(Object field) { return getValueOrDefault(field, ""); }
[*] target: assertEquals(actualValue, value)
[-] pred: org. junit. Assert. assertEquals ( actualValue, value )
************************************
************************************
[+] input: InterruptedException { TopoServer topoServer = MemoryTopoFactory.newServerAndFactory("cell1", "cell2").getTopoServer(); startWatchTopo("k", topoServer, "cell1", "cell2"); topoServer.addKeyspace("k"); topoServer.startTickerReloadCell(globalContext);  printComment("10. HealthCheck Test Primary in other cell"); printComment("a. Get Health"); HealthCheck hc = getHealthCheck();  printComment("b. Add a no-serving primary Tablet in different cell"); MockTablet mockTablet = MockTablet.buildMockTablet(grpcCleanup, "cell2", 0, "a", "k", "s", portMap, Topodata.TabletType.MASTER); hc.addTablet(mockTablet.getTablet()); sleepMillisSeconds(200);  printComment("c. Modify the status of Tablet to serving"); sendOnNextMessage(mockTablet, Topodata.TabletType.MASTER, true, 0, 0.5, 0); sleepMillisSeconds(200);  printComment("d.// check that PRIMARY tablet from other cell IS in healthy tablet list"); List<TabletHealthCheck> hcList = hc.getHealthyTabletStats(Query.Target.newBuilder().setKeyspace("k").setShard("s").setTabletType(Topodata.TabletType.MASTER).build()); Assert."<AssertPlaceHolder>";  MockTablet.closeQueryService(mockTablet); TopologyWatcherManager.INSTANCE.close(); topoServer.close();  printOk(); }
getHealthyTabletStats(Query.Target target) { this.lock.lock(); try { List<TabletHealthCheck> list = this.healthy.get(keyFromTarget(target)); if (null == list || list.isEmpty()) { return null; } if (target.getTabletType() == Topodata.TabletType.MASTER) { return list; }  List<TabletHealthCheck> servlist = new ArrayList<>(list.size()); list.forEach(entry -> { if (entry.getServing().get()) { servlist.add(entry); } }); return servlist; } finally { this.lock.unlock(); } }
[*] target: assertEquals(1, hcList.size())
[-] pred: org. junit. Assert. assertEquals ( 1, hcList. size ( ) )
************************************
************************************
[+] input: shouldFetchDefaultValueIfFieldNotPresentInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("customer_dynamic_surge_enabled"); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BOOLEAN).named("some-other-field") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor);  Object actualValue = booleanHandler.parseSimpleGroup(simpleGroup);  "<AssertPlaceHolder>"; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { return simpleGroup.getBoolean(fieldName, 0); } else { /* return default value */ return false; } }
[*] target: assertEquals(false, actualValue)
[-] pred: org. junit. Assert. assertEquals ( false, actualValue )
************************************
************************************
[+] input: testToString() { ForwarderSwitch device = new ForwarderSwitch(3, null, 5, new IdentityFlowletIntermediary()); device.addConnection(topology.getPort(3, 1)); device.addConnection(topology.getPort(3, 4)); device.setDestinationToNextSwitch(0, 1); device.setDestinationToNextSwitch(1, 1); device.setDestinationToNextSwitch(2, 4); device.setDestinationToNextSwitch(4, 4); "<AssertPlaceHolder>"; }
toString() { StringBuilder builder = new StringBuilder(); builder.append("ForwarderSwitch<id="); builder.append(getIdentifier()); builder.append(", connected="); builder.append(connectedTo); builder.append(", routing: "); for (int i = 0; i < destinationToNextSwitch.length; i++) { if (i != 0) { builder.append(", "); } builder.append(i); builder.append("->"); builder.append(destinationToNextSwitch[i]); } builder.append(">"); return builder.toString(); }
[*] target: assertNotNull(device.toString())
[-] pred: org. junit. Assert. assertNotNull ( device. toString ( ) )
************************************
************************************
[+] input: InterruptedException {  Field registedAppField = null; try { registedAppField = MeshRegistry.class.getDeclaredField("registedApp"); registedAppField.setAccessible(true); } catch (NoSuchFieldException e) { e.printStackTrace(); }  Boolean registedAppValue = null; // in case of effected by other case. try { registedAppValue = (Boolean) registedAppField.get(registry); registedAppField.set(registry, false); } catch (IllegalAccessException e) { e.printStackTrace(); }  ServerConfig serverConfig = new ServerConfig() .setProtocol("bolt") .setHost("0.0.0.0") .setPort(12200); ProviderConfig<?> provider = new ProviderConfig(); provider.setInterfaceId("com.alipay.xxx.TestService") .setUniqueId("unique123Id") .setApplication(new ApplicationConfig().setAppName("test-server")) .setProxy("javassist") .setRegister(true) .setRegistry(registryConfig) .setSerialization("hessian2") .setServer(serverConfig) .setWeight(222) .setTimeout(3000);  registry.register(provider); Thread.sleep(3000);  try { registedAppValue = (Boolean) registedAppField.get(registry); } catch (IllegalAccessException e) { e.printStackTrace(); }  LOGGER.info("final registedAppValue is " + registedAppValue);  Assert."<AssertPlaceHolder>"; }
register(ProviderConfig config) { String appName = config.getAppName(); if (!registryConfig.isRegister()) { if (LOGGER.isInfoEnabled(appName)) { LOGGER.infoWithApp(appName, LogCodes.getLog(LogCodes.INFO_REGISTRY_IGNORE)); } return; } if (!config.isRegister()) { // 注册中心不注册或者服务不注册 return; } List<ServerConfig> serverConfigs = config.getServer(); if (CommonUtils.isNotEmpty(serverConfigs)) { for (ServerConfig server : serverConfigs) { String serviceName = MeshRegistryHelper.buildMeshKey(config, server.getProtocol()); ProviderInfo providerInfo = MeshRegistryHelper.convertProviderToProviderInfo(config, server); if (LOGGER.isInfoEnabled(appName)) { LOGGER.infoWithApp(appName, LogCodes.getLog(LogCodes.INFO_ROUTE_REGISTRY_PUB_START, serviceName)); } doRegister(appName, serviceName, providerInfo, server.getProtocol());  if (LOGGER.isInfoEnabled(appName)) { LOGGER.infoWithApp(appName, LogCodes.getLog(LogCodes.INFO_ROUTE_REGISTRY_PUB_OVER, serviceName)); } } if (EventBus.isEnable(ProviderPubEvent.class)) { ProviderPubEvent event = new ProviderPubEvent(config); EventBus.post(event); }  } }
[*] target: assertTrue(registedAppValue)
[-] pred: org. junit. Assert. assertTrue ( registedAppValue )
************************************
************************************
[+] input: miss_DoTable_Miss_IgnoreTable_Hit_DoWildTable_Miss_DoDb_Ignore() { ReplicaMeta replicaMeta = new ReplicaMeta(); replicaMeta.setDoDb("full_src_1, full_src_2"); replicaMeta.setIgnoreDb(""); replicaMeta.setDoTable(""); replicaMeta.setIgnoreTable(""); replicaMeta.setWildDoTable("d%.tb\\_charset%, d%.col\\_charset%"); replicaMeta.setWildIgnoreTable(""); replicaMeta.setRewriteDb(""); printChangeFilterSql(replicaMeta);  // init ReplicaFilter filter = new ReplicaFilter(replicaMeta); filter.init();  DefaultRowChange rowChange = new DefaultRowChange(); rowChange.setAction(DBMSAction.INSERT);  rowChange.setSchema("dutf8"); rowChange.setTable("tb_charset_gbk"); Assert."<AssertPlaceHolder>"; }
ignoreEvent(DefaultRowChange rowChange) { return ignoreEvent(getRewriteDb(rowChange.getSchema(), DBMSAction.INSERT), rowChange.getTable(), rowChange.getAction(), Integer.MIN_VALUE); }
[*] target: assertTrue(filter.ignoreEvent(rowChange))
[-] pred: org. junit. Assert. assertTrue ( filter. ignoreEvent ( rowChange ) )
************************************
************************************
[+] input: SQLException { Mockito.when(mockResults.getString("urilocation")).thenReturn(""); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); Assert."<AssertPlaceHolder>"; }
getUriLocations() { return this.uriLocationsHandler.getCommaSeparatedList(); }
[*] target: assertTrue(table.getUriLocations().isEmpty())
[-] pred: org. junit. Assert. assertTrue ( table. getUriLocations ( ). isEmpty ( ) )
************************************
************************************
[+] input: toByteArray() { TPKT tpkt = new TPKT(); tpkt.setLength(100); byte[] actual = tpkt.toByteArray(); byte[] expect = {(byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x64}; "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.version) .putByte(this.reserved) .putShort(this.length) .getData(); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: Exception { BinaryResource res = BinaryResources.create() .withFilename("a.html") .withContent("<html></html>".getBytes("UTF-8")) .withCachingAllowed(true) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey("/"), res); boolean b = rc.put(obj); Assert."<AssertPlaceHolder>"; }
put(HttpCacheObject obj) { if (!obj.isCachingAllowed()) { return false; } m_cache.put(obj.getCacheKey(), obj); LOG.debug("Stored object in cache: {}", obj.getCacheKey()); return true; }
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
************************************
************************************
[+] input: testGetNonExistent() { LRUCache<CacheValue> cache = new LRUCache<>(100); CacheValue nobody = cache.get("nobody");  Assert."<AssertPlaceHolder>"; }
get(String key) { lock.lock(); try { if (!cacheMap.containsKey(key)) { return null; } Node<T> node = this.cacheMap.get(key);  updateCacheNodeLocked(node); return node.value; } finally { lock.unlock(); } }
[*] target: assertNull(nobody)
[-] pred: org. junit. Assert. assertNull ( nobody )
************************************
************************************
[+] input: mp4TfhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x10, 0x74, 0x66, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }; Mp4TfhdBox box = new Mp4TfhdBox(1); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); return ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mfhdBox.toByteArray()) .putBytes(this.trafBox.toByteArray()) .getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: Exception { User u = mock(User.class); UserThreadLocal.setUser(u); Object result = loginUserHandlerMethodArgumentResolver.resolveArgument(null, null, null, null); Assert."<AssertPlaceHolder>"; }
resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception { return UserThreadLocal.currentUser(); }
[*] target: assertEquals(u, result)
[-] pred: org. junit. Assert. assertEquals ( u, result )
************************************
************************************
[+] input: testDecompress_umlauts() { String original = CHARACTERS.repeat(100000); String decompressed = StringUtility.decompress(StringUtility.compress(original));  "<AssertPlaceHolder>"; }
compress(String s) { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION); DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(buffer, deflater); // writes the compressed data into the stream buffer StringReader in = null; try { in = new StringReader(s);  char[] c = new char[102400]; int len; while ((len = in.read(c)) > 0) { String str = new String(c, 0, len); byte[] b = str.getBytes(StandardCharsets.UTF_8); deflaterOutputStream.write(b, 0, b.length); } } catch (IOException e) { // NOOP } finally { try { deflaterOutputStream.flush(); } catch (IOException e) { } try { buffer.flush(); } catch (IOException e) { } deflater.finish(); try { deflaterOutputStream.finish(); } catch (IOException e) { } deflater.end(); try { deflaterOutputStream.close(); } catch (IOException e) { } try { buffer.close(); } catch (IOException e) { } if (in != null) { in.close(); } }  return buffer.toByteArray(); }
[*] target: assertEquals(original, decompressed)
[-] pred: org. junit. Assert. assertEquals ( original, decompressed )
************************************
************************************
[+] input: testFor() { pipeline.sample(3);  Object users = mars.aggregate(pipeline, "users").tryNext(); Assert."<AssertPlaceHolder>";    }
sample(long size) { return new Sample(size); }
[*] target: assertNotNull(users)
[-] pred: org. junit. Assert. assertNotNull ( users )
************************************
************************************
[+] input: testUnicodeConvertionWithSpecialChar() { // Arrange String punycodeAddress = "sömeöne@xn--exmple-cua.com"; String emailAddress = "sömeöne@exämple.com";  // Act String convertedAddress = BEANS.get(MailIDNConverter.class).toUnicode(punycodeAddress);  // Assert "<AssertPlaceHolder>"; }
toUnicode(String email) { return convertToCharset(email, IDN::toUnicode); }
[*] target: assertEquals(emailAddress, convertedAddress)
[-] pred: org. junit. Assert. assertEquals ( emailAddress, convertedAddress )
************************************
************************************
[+] input: add() { cal.add(2,2); "<AssertPlaceHolder>"; }
getResult() { return this.result; }
[*] target: assertEquals(4,cal.getResult())
[-] pred: org. junit. Assert. assertEquals ( 4, cal. getResult() )
************************************
************************************
[+] input: getContent() { String expectedContent = "{"foo":"bar"}"; StringBuilder actualContent = new StringBuilder();  underTest = new SignableRequestImpl(new Request.Builder() .url("https://www.amazon.com") .post(RequestBody.create(MediaType.parse("application/json; charset=utf-8"), expectedContent)) .build());  try(Scanner scanner = new Scanner(underTest.getContent())){ while(scanner.hasNext()) { actualContent.append(scanner.next()); } }  "<AssertPlaceHolder>"; }
getContent() { ByteArrayInputStream inputStream = null;  if (originalRequest.body() != null) { try { Buffer buffer = new Buffer(); originalRequest.body().writeTo(buffer); inputStream = new ByteArrayInputStream(buffer.readByteArray()); } catch (IOException e) { throw new RuntimeException("Unable to buffer request body", e); } }  return inputStream; }
[*] target: assertEquals(expectedContent, actualContent.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedContent, actualContent. toString ( ) )
************************************
************************************
[+] input: shouldNotProvideProtoDeserializerWhenSourceNameIsUnsupported() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.PARQUET_SOURCE, SourceType.BOUNDED)}); when(streamConfig.getDataType()).thenReturn("PROTO");  ProtoDeserializerProvider provider = new ProtoDeserializerProvider(streamConfig, configuration, stencilClientOrchestrator);  "<AssertPlaceHolder>"; }
canProvide() { SourceDetails[] sourceDetailsList = streamConfig.getSourceDetails(); for (SourceDetails sourceDetails : sourceDetailsList) { SourceName sourceName = sourceDetails.getSourceName(); DataTypes inputSchemaType = DataTypes.valueOf(streamConfig.getDataType()); if (!COMPATIBLE_SOURCES.contains(sourceName) || !inputSchemaType.equals(COMPATIBLE_INPUT_SCHEMA_TYPE)) { return false; } } return true; }
[*] target: assertFalse(provider.canProvide())
[-] pred: org. junit. Assert. assertFalse ( provider. canProvide() )
************************************
************************************
[+] input: shouldDoDefaultFormatForCreateStatementWhenIndentSubstatementsInParenthesesOff() { //given String inputString = "CREATE TABLE Persons (PersonID int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255));"; String expectedString = "CREATE TABLE Persons (PersonID int," + lineBreak + "LastName varchar(255)," + lineBreak + "FirstName varchar(255)," + lineBreak + "Address varchar(255)," + lineBreak + "City varchar(255));";  Mockito.when(preferenceStore.getBoolean(Mockito.eq(ModelPreferences.SQL_FORMAT_BREAK_BEFORE_CLOSE_BRACKET))).thenReturn(false);  //when String formattedString = formatter.format(inputString, configuration);  //then "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, formattedString)
[-] pred: org. junit. Assert. assertEquals ( expectedString, formattedString )
************************************
************************************
[+] input: Exception { List<Long> result = userServiceImpl.getProjectIdsByUserId(Long.valueOf(1)); Assert."<AssertPlaceHolder>"; }
getProjectIdsByUserId(Long userId) { List<Long> resIdList = new ArrayList<>(); // 获取projectUser表中的数据 List<Long> projectIdList = projectUserService.selectByExample( ProjectUserExample.newBuilder() .distinct(true) .build() .createCriteria() .andUserIdEqualTo(userId) .toExample(), ProjectUser :: getProjectId, MetaProjectUser.COLUMN_NAME_PROJECTID );  if (!CollectionUtils.isEmpty(projectIdList) && projectIdList.size() > Constants.MAX_PROJECT_NUM_PER_USER) { resIdList = projectIdList.subList(0, Constants.MAX_PROJECT_NUM_PER_USER - 1); } else { resIdList = projectIdList; }  return resIdList; }
[*] target: assertEquals(0, result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: testSubstraction() { System.out.println("resta"); double num1 = -2.0; double num2 = -7.0; Calculadora instance = new Calculadora(); double expResult = 5.0; double result = instance.resta(num1, num2); "<AssertPlaceHolder>"; }
resta(double num1, double num2) { return num1 - num2; }
[*] target: assertEquals(expResult, result, 0.0)
[-] pred: org. junit. Assert. assertEquals ( expResult, result, 0.0 )
************************************
************************************
[+] input: testAsciiConvertionWithSpecialChar() { // Arrange String emailAddress = "sömeone@exämple.com"; String punycodeAddress = "sömeone@xn--exmple-cua.com";  // Act String convertedAddress = BEANS.get(MailIDNConverter.class).toASCII(emailAddress);  // Assert "<AssertPlaceHolder>"; }
toASCII(String email) { return convertToCharset(email, IDN::toASCII); }
[*] target: assertEquals(punycodeAddress, convertedAddress)
[-] pred: org. junit. Assert. assertEquals ( punycodeAddress, convertedAddress )
************************************
************************************
[+] input: testPublish() { PublishServiceRequest request = new PublishServiceRequest(); request.setServiceName("aa"); ProviderMetaInfo providerMetaInfo = new ProviderMetaInfo(); providerMetaInfo.setAppName("testApp"); providerMetaInfo.setProtocol("bolt"); providerMetaInfo.setSerializeType("hessian2"); providerMetaInfo.setVersion("4.0"); request.setProviderMetaInfo(providerMetaInfo); boolean result = meshApiClient.publishService(request); Assert."<AssertPlaceHolder>"; }
publishService(PublishServiceRequest publishServiceRequest) {  final String json = JSON.toJSONString(publishServiceRequest); String result = httpPost(MeshEndpoint.PUBLISH, json); if (!StringUtils.equals(result, errorMessage)) { final PublishServiceResult parse = JSON.parseObject(result, PublishServiceResult.class); if (parse.isSuccess()) { return true; } return false; } else { return false; } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: shouldNotBeAbleToBuildSourceIfDeserializerTypeIsUnsupported() { DaggerDeserializer<Row> unsupportedDeserializer = Mockito.mock(SimpleGroupDeserializer.class); when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); KafkaDaggerSource daggerSource = new KafkaDaggerSource(streamConfig, configuration, unsupportedDeserializer);  "<AssertPlaceHolder>"; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }
[*] target: assertFalse(daggerSource.canBuild())
[-] pred: org. junit. Assert. assertFalse ( daggerSource. canBuild ( ) )
************************************
************************************
[+] input: toByteArray() { DataItem dataItem = new DataItem(); dataItem.setReturnCode(EReturnCode.from((byte) 0xFF)); dataItem.setVariableType(EDataVariableType.BYTE_WORD_DWORD); dataItem.setCount(1); dataItem.setData(new byte[1]); byte[] actual = dataItem.toByteArray(); byte[] expect = {(byte) 0xFF, (byte) 0x04, (byte) 0x00, (byte) 0x08, (byte) 0x00}; "<AssertPlaceHolder>"; }
toByteArray() { int length = 4 + this.data.length; ByteWriteBuff buff = ByteWriteBuff.newInstance(length) .putByte(this.returnCode.getCode()) .putByte(this.variableType.getCode()); // 如果数据类型是位，不需要 * 8，如果是其他类型，需要 * 8 switch (this.variableType) { case NULL: case BYTE_WORD_DWORD: case INTEGER: buff.putShort(this.count * 8); break; case BIT: case DINTEGER: case REAL: case OCTET_STRING: buff.putShort(this.count); break; default: throw new S7CommException("Data type not recognized"); } buff.putBytes(this.data); return buff.getData(); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: interpolationMultiple() { createCueFile("'a\\(1)b\\(2)b\\(3)'"); var literal = findTypedElement(CueStringLiteral.class); var ranges = CueMultiHostInjector.findInjectionRanges(literal);  var expected = Arrays.asList( new InjectionData(TextRange.create(1, 2), null, null), new InjectionData(TextRange.create(6, 7), "\\(1)", null), new InjectionData(TextRange.create(11, 12), "\\(2)", null), new InjectionData(TextRange.create(16, 16), "\\(3)", null)); "<AssertPlaceHolder>"; }
findInjectionRanges(CueStringLiteral context) { var totalRange = context.getLiteralContentRange(); var interpolations = context.getInterpolationList() .stream() .map(PsiElement::getTextRangeInParent) .sorted(Comparator.comparingInt(TextRange::getStartOffset)) .collect(Collectors.toList());  if (interpolations.isEmpty()) { return Collections.singletonList(new InjectionData(totalRange, null, null)); }  var hostText = context.getText(); var result = new LinkedList<InjectionData>(); var lastStart = totalRange.getStartOffset(); var lastEnd = totalRange.getStartOffset(); for (TextRange range : interpolations) { var start = range.getStartOffset(); var end = range.getEndOffset(); if (start == totalRange.getStartOffset()) { // interpolation at start, insert empty range before to allow editing result.add(new InjectionData(TextRange.create(start, start), null, null)); } else if (start > lastEnd) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, start), prefix, null)); } lastStart = start; lastEnd = end; } if (lastEnd < totalRange.getEndOffset()) { var prefix = lastEnd > lastStart ? hostText.substring(lastStart, lastEnd) : null; result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } else if (lastEnd == totalRange.getEndOffset() && lastEnd > lastStart) { var prefix = hostText.substring(lastStart, lastEnd); result.add(new InjectionData(TextRange.create(lastEnd, totalRange.getEndOffset()), prefix, null)); } return result; }
[*] target: assertEquals(expected, ranges)
[-] pred: org. junit. Assert. assertEquals ( expected, ranges )
************************************
************************************
[+] input: testSearchReturnsSomething() { final ChildPredicate predicate = new ChildPredicate(Optional.of(search)); final KDLDocument child = KDLDocument.builder() .addNode(KDLNode.builder().setIdentifier("identifier").build()) .build(); final KDLNode node = KDLNode.builder().setIdentifier("node") .setChild(child) .build();  when(search.anyMatch(any())).thenReturn(true);  "<AssertPlaceHolder>"; verify(search, times(1)).anyMatch(eq(child)); verifyNoMoreInteractions(search); }
test(KDLNode node) { if (!search.isPresent()) { return !node.getChild().isPresent() || node.getChild().get().getNodes().isEmpty(); }  return node.getChild().map(ch -> search.get().anyMatch(ch)).orElse(false); }
[*] target: assertTrue(predicate.test(node))
[-] pred: org. junit. Assert. assertTrue ( predicate. test ( node ) )
************************************
************************************
[+] input: testGetNodeCountNoNodes() { ITree tree = mock(ITree.class); TreeEvent event = new TreeEvent(tree, TreeEvent.TYPE_NODE_ACTION); "<AssertPlaceHolder>"; }
getNodeCount() { return m_nodes == null ? 0 : m_nodes.size(); }
[*] target: assertEquals(0, event.getNodeCount())
[-] pred: org. junit. Assert. assertEquals ( 0, event. getNodeCount() )
************************************
************************************
[+] input: createEsJsonWebKey() { EllipticCurveJsonWebKey ellipticCurveJsonWebKey = JwkUtil.createEsJsonWebKey("jap-jwks-keyid", TokenSigningAlg.ES256); Assert."<AssertPlaceHolder>"; }
createEsJsonWebKey(String keyId, TokenSigningAlg signingAlg) { if (!Arrays.asList(TokenSigningAlg.ES256, TokenSigningAlg.ES384, TokenSigningAlg.ES512).contains(signingAlg)) { throw new InvalidJwksException("Unable to create ES Json Web Key. Unsupported jwk algorithm, only supports ES256, ES384, ES512"); } EllipticCurveJsonWebKey jwk = null;  ECParameterSpec spec = null; if (signingAlg == TokenSigningAlg.ES256) { spec = EllipticCurves.P256; } else if (signingAlg == TokenSigningAlg.ES384) { spec = EllipticCurves.P384; } else { spec = EllipticCurves.P521; }  try { jwk = EcJwkGenerator.generateJwk(spec); jwk.setUse(Use.SIGNATURE); jwk.setKeyId(keyId); jwk.setAlgorithm(signingAlg.getAlg()); } catch (JoseException e) { e.printStackTrace(); throw new InvalidJwksException("Unable to create ES Json Web Key."); } return jwk; }
[*] target: assertNotNull(ellipticCurveJsonWebKey)
[-] pred: org. junit. Assert. assertNotNull ( ellipticCurveJsonWebKey )
************************************
************************************
[+] input: testVerifyRequestRequestWithSomeDataAndRuleMismatch() { Response response = new Response(); Map<String, String> subject = new HashMap<>(); subject.put("aal", "25"); subject.put("verify_aal", "26"); Context context = new Context<>(subject, null, null, null, null, response, null, null);  boolean flag = context.verifyRequest();  Assert."<AssertPlaceHolder>"; }
verifyRequest(){ return verifyRequest(subject) && verifyRequest(resource) && verifyRequest(action) && verifyRequest(environment); }
[*] target: assertFalse(flag)
[-] pred: org. junit. Assert. assertFalse ( flag )
************************************
************************************
[+] input: shouldBeTrueWhenTransformerSourceExists() { Map<String, Object> transformationArguments = new HashMap<>(); transformationArguments.put("keyValue", "key"); transformConfigs.add(new TransformConfig("test.postprocessor.XTransformer", transformationArguments)); defaultPostProcessorConfig = new PostProcessorConfig(null, transformConfigs, defaultInternalSource); "<AssertPlaceHolder>"; }
hasTransformConfigs() { return transformers != null && !transformers.isEmpty(); }
[*] target: assertTrue(defaultPostProcessorConfig.hasTransformConfigs())
[-] pred: org. junit. Assert. assertTrue ( defaultPostProcessorConfig. hasTransformConfigs ( ) )
************************************
************************************
[+] input: convertPoint_NegativeCoordinates_ShouldConvert() { String wkt = "POINT(-12.2 13)"; String geoJson = WktToGeoJsonConverter.toGeoJson(wkt); String expectedGeoJson = "{"type":"Point", "coordinates": [-12.2,13]}"; Assert."<AssertPlaceHolder>"; }
toGeoJson(String wkt) { wkt = wkt.toLowerCase(); int startOfCoordinates = wkt.indexOf("("); if (startOfCoordinates == -1) { throw new IllegalArgumentException( StringUtils.format("Failed to convert well-known-text [%s] to geometry type", wkt)); }  String wktType = wkt.substring(0, startOfCoordinates).trim(); wkt = wkt.substring(startOfCoordinates);  String type = ""; String coordinates = ""; switch (wktType) { case ("point"): type = "Point"; coordinates = pointCoordinatesFromWkt(wkt); break; case ("polygon"): type = "Polygon"; coordinates = polygonCoordinatesFromWkt(wkt); break; case ("linestring"): type = "LineString"; coordinates = lineStringCoordinatesFromWkt(wkt); break; case ("multipolygon"): type = "MultiPolygon"; coordinates = multiPolygonCoordinatesFromWkt(wkt); break; case ("multipoint"): type = "MultiPoint"; coordinates = multiPointCoordinatesFromWkt(wkt); break; case ("multilinestring"): type = "MultiLineString"; coordinates = multiLineStringCoordinatesFromWkt(wkt); break; default: throw new IllegalArgumentException("Unsupported well-known-text type: " + wktType); }  return buildGeoJson(type, coordinates); }
[*] target: assertEquals(expectedGeoJson, geoJson)
[-] pred: org. junit. Assert. assertEquals ( expectedGeoJson, geoJson )
************************************
************************************
[+] input: IOException { PipedOutputStream pipedOutputStream = new PipedOutputStream(); BinaryCopyParser parser = new BinaryCopyParser(new PipedInputStream(pipedOutputStream, 256));  DataOutputStream data = new DataOutputStream(pipedOutputStream); data.write(COPY_BINARY_HEADER); data.writeInt(0); data.writeInt(0);  // Write trailer. data.writeShort(-1);  Iterator<CopyRecord> iterator = parser.iterator(); "<AssertPlaceHolder>"; }
hasNext() { try { // The hasNext status is UNKNOWN if a call to next() has been executed since the last time // hasNext() was called, or if this is the first time hasNext() is called. if (hasNext == HasNext.UNKNOWN) { // The first value in a row is the number of fields in that row. The value will be -1 for // the last tuple (this is the file trailer). The value should be the same for all other // rows. short fieldCount = dataInputStream.readShort(); if (fieldCount == -1) { logger.log(Level.FINE, "End of copy file: -1"); hasNext = HasNext.NO; } else if (fieldCount > -1) { if (firstRowFieldCount == -1) { firstRowFieldCount = fieldCount; currentRow = new BinaryField[fieldCount]; } else if (firstRowFieldCount != fieldCount) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, String.format( "Invalid field count encountered: %d, expected %d", fieldCount, firstRowFieldCount)); } hasNext = HasNext.YES; } else { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, String.format("Invalid field count encountered: %d", fieldCount)); } } return hasNext == HasNext.YES; } catch (EOFException eofException) { // The protocol specifies that the stream should contain a -1 as the trailer in the file, // but it seems that some clients do not include this. logger.log(Level.FINE, "EOF in BinaryCopyParser"); hasNext = HasNext.NO; return false; } catch (IOException ioException) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.INTERNAL, ioException.getMessage(), ioException); } }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext() )
************************************
************************************
[+] input: tryLockUnlock_conditionNotMet() { final AttributeValue onboardingId = AttributeValue.builder().s(ONBOARDING_ID).build(); doReturn(ScanResponse.builder().items(List.of(Map.of("id", onboardingId))).build()) .when(mockDdb).scan(any(ScanRequest.class));  doThrow(ConditionalCheckFailedException.builder().build()).when(mockDdb).updateItem(any(UpdateItemRequest.class));  boolean success = testLock.tryLockUnlock(TEST_CONTEXT, true); "<AssertPlaceHolder>"; }
tryLockUnlock(RequestContext requestContext, boolean tryLock) { try { UpdateItemRequest updateItemRequest = UpdateItemRequest.builder() .tableName(requestContext.onboardingDdbTable) .key(Map.of("id", currentOnboardingId(requestContext))) .conditionExpression("ecs_cluster_locked = :lock_expected") .updateExpression("SET ecs_cluster_locked = :new_lock") .expressionAttributeValues(Map.of( ":lock_expected", AttributeValue.builder().bool(!tryLock).build(), ":new_lock", AttributeValue.builder().bool(tryLock).build())) .build(); LOGGER.debug("trying to {} with updateItemRequest {}", tryLock ? "lock" : "unlock", updateItemRequest); ddb.updateItem(UpdateItemRequest.builder() .tableName(requestContext.onboardingDdbTable) .key(Map.of("id", currentOnboardingId(requestContext))) .conditionExpression("ecs_cluster_locked = :lock_expected") .updateExpression("SET ecs_cluster_locked = :new_lock") .expressionAttributeValues(Map.of( ":lock_expected", AttributeValue.builder().bool(!tryLock).build(), ":new_lock", AttributeValue.builder().bool(tryLock).build())) .build()); } catch (ConditionalCheckFailedException ccfe) { LOGGER.error("Could not {} ecs_cluster_locked, conditional check failed: {}", tryLock ? "lock" : "unlock", ccfe.getMessage()); return false; } catch (DynamoDbException ddbe) { LOGGER.error("Error trying to update lock for current onboarding id: {}", ddbe.getMessage()); LOGGER.error(Utils.getFullStackTrace(ddbe)); throw new RuntimeException(ddbe); } return true; }
[*] target: assertFalse(success)
[-] pred: org. junit. Assert. assertFalse ( success )
************************************
************************************
[+] input: testExecutionSkippedNotValid() { NetworkTask task = getNetworkTask(); task = networkTaskDAO.insertNetworkTask(task); networkTaskDAO.updateNetworkTaskRunning(task.getId(), true); task.setSchedulerId(task.getSchedulerId() + 1); Intent intent = new Intent(); intent.putExtras(task.toBundle()); broadcastReceiver.onReceive(TestRegistry.getContext(), intent); List<LogEntry> entries = logDAO.readAllLogsForNetworkTask(task.getId()); "<AssertPlaceHolder>"; }
onReceive(Context context, Intent intent) { NetworkTask task = new NetworkTask(Objects.requireNonNull(intent.getExtras())); Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Received request for " + task); boolean synchronous = context.getResources().getBoolean(R.bool.worker_synchronous_execution); boolean addToPool = context.getResources().getBoolean(R.bool.worker_add_to_pool); int wakeLockTimeout = context.getResources().getInteger(R.integer.worker_execution_wakelock_timeout) * 1000; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Synchronous execution is " + synchronous); PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wakeLock = null; Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Creating ExecutorService"); ExecutorService executorService = Executors.newSingleThreadExecutor(); try { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Acquiring partial wake lock with a timeout of " + wakeLockTimeout + " msec"); wakeLock = Objects.requireNonNull(powerManager).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "KeepItUp:NetworkTaskProcessBroadcastReceiver"); wakeLock.acquire(wakeLockTimeout); TimeBasedSuspensionScheduler timeBasedScheduler = createTimeBasedSuspensionScheduler(context); synchronized (TimeBasedSuspensionScheduler.LOCK) { if (timeBasedScheduler.isRunning()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is running."); if (!timeBasedScheduler.isSuspended()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not suspended."); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is suspended. Skipping execution and rescheduling."); } } else { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not running."); if (!timeBasedScheduler.isSuspensionActiveAndEnabled()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not active."); executeAndReschedule(context, task, wakeLock, synchronous, addToPool, executorService); } else { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), "Time based scheduler is not running but is active. Restarting..."); timeBasedScheduler.start(task); } } } } catch (Exception exc) { Log.e(NetworkTaskProcessBroadcastReceiver.class.getName(), "Error executing worker", exc); } finally { if (wakeLock != null && synchronous && wakeLock.isHeld()) { Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Releasing partial wake lock"); wakeLock.release(); } Log.d(NetworkTaskProcessBroadcastReceiver.class.getName(), "Shutting down ExecutorService"); executorService.shutdown(); } }
[*] target: assertEquals(0, entries.size())
[-] pred: org. junit. Assert. assertEquals ( 0, entries. size ( ) )
************************************
************************************
[+] input: shouldFetchParsedValueForFieldForFieldDescriptorOfTypeBool() { boolean actualValue = true;  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("customer_dynamic_surge_enabled");  BooleanHandler booleanHandler = new BooleanHandler(fieldDescriptor); Object value = booleanHandler.parseObject(String.valueOf(actualValue));  "<AssertPlaceHolder>"; }
parseObject(Object field) { return Boolean.parseBoolean(getValueOrDefault(field, "false")); }
[*] target: assertEquals(actualValue, value)
[-] pred: org. junit. Assert. assertEquals ( actualValue, value )
************************************
************************************
[+] input: shouldNotBeAbleToBuildSourceIfDeserializerTypeIsUnsupported() { DaggerDeserializer<Row> unsupportedDeserializer = Mockito.mock(SimpleGroupDeserializer.class); when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_CONSUMER, SourceType.UNBOUNDED)}); FlinkKafkaConsumerDaggerSource daggerSource = new FlinkKafkaConsumerDaggerSource(streamConfig, configuration, unsupportedDeserializer);  "<AssertPlaceHolder>"; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }
[*] target: assertFalse(daggerSource.canBuild())
[-] pred: org. junit. Assert. assertFalse ( daggerSource. canBuild ( ) )
************************************
************************************
[+] input: Exception { FilterRegistrationBean result = webMvcConfig.crossDomainFilter(); Assert."<AssertPlaceHolder>"; }
crossDomainFilter() { FilterRegistrationBean cross = new FilterRegistrationBean(); cross.setFilter(new CrossDomainFilter()); cross.setOrder(98); cross.addUrlPatterns("/*"); return cross; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: SQLException { Mockito.when(mockResults.getString("execlocation")).thenReturn("ALL_SEGMENTS"); GreenplumExternalTable table = new GreenplumExternalTable(mockSchema, mockResults); String expectedUriLocation = "ALL_SEGMENTS"; Assert."<AssertPlaceHolder>"; }
getExecLocation() { return execLocation; }
[*] target: assertEquals(expectedUriLocation, table.getExecLocation())
[-] pred: org. junit. Assert. assertEquals ( expectedUriLocation, table. getExecLocation ( ) )
************************************
************************************
[+] input: Exception { byte[] fullFileContent = createFileContent(1024 * 1024 + 987654); RandomAccessFile raf = createRaf(fullFileContent); DataSource rafDataSource = new FileChannelDataSource(raf.getChannel());  ByteArrayDataSink dataSink = new ByteArrayDataSink();  int offset = 23456; int bytesToFeed = 1024 * 1024 + 12345; rafDataSource.feed(offset, bytesToFeed, dataSink);  byte[] expectedBytes = Arrays.copyOfRange(fullFileContent, offset, offset + bytesToFeed);  byte[] resultBytes = getDataSinkBytes(dataSink);  "<AssertPlaceHolder>"; }
feed(long offset, long size, DataSink sink) throws IOException { long sourceSize = size(); checkChunkValid(offset, size, sourceSize); if (size == 0) { return; }  long chunkOffsetInFile = mOffset + offset; long remaining = size; ByteBuffer buf = ByteBuffer.allocateDirect((int) Math.min(remaining, MAX_READ_CHUNK_SIZE));  while (remaining > 0) { int chunkSize = (int) Math.min(remaining, buf.capacity()); int chunkRemaining = chunkSize; buf.limit(chunkSize); synchronized (mChannel) { mChannel.position(chunkOffsetInFile); while (chunkRemaining > 0) { int read = mChannel.read(buf); if (read < 0) { throw new IOException("Unexpected EOF encountered"); } chunkRemaining -= read; } } buf.flip(); sink.consume(buf); buf.clear(); chunkOffsetInFile += chunkSize; remaining -= chunkSize; } }
[*] target: assertArrayEquals(expectedBytes, resultBytes)
[-] pred: org. junit. Assert. assertArrayEquals ( expectedBytes, resultBytes )
************************************
************************************
[+] input: shouldReturnDefaultTimestampRowDuringTransformIfSimpleGroupDoesNotContainField() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("event_timestamp"); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named("some-other-field") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema);  TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row actualRow = (Row) timestampHandler.transformFromParquet(simpleGroup);  Row expectedRow = Row.of(0L, 0); "<AssertPlaceHolder>"; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }
[*] target: assertEquals(expectedRow, actualRow)
[-] pred: org. junit. Assert. assertEquals ( expectedRow, actualRow )
************************************
************************************
[+] input: test_AU() { DatasetUtil.runInRegion(Country.AUSTRALIA.getIsoCode(), () -> { StreetNameGenerator generator = new StreetNameGenerator(); generator.init(context); for (int i = 0; i < 10; i++) { String product = generator.generate(); "<AssertPlaceHolder>"; } generator.close(); }); }
generate() { return GeneratorUtil.generateNonNull(this); }
[*] target: assertNotNull(product)
[-] pred: org. junit. Assert. assertNotNull ( product )
************************************
************************************
[+] input: testIndexResponse() {  String expectedStringValue = "{"_id":"id","_index":"index","_primary_term":1,"result":"created","_seq_no":2,"_shards":{"failed":1.0,"successful":1.0,"total":3.0,"failures":[{"index":"index","node":"node","reason":{"reason":"Failed to create query.","type":"query_shard_exception"},"shard":1,"status":"Failed"}],"skipped":1.0},"_version":3}"; IndexResponse indexResponse = IndexResponse.of( response -> response.result(Result.Created) .index("index") .id("id") .primaryTerm(1) .seqNo(2) .version(3) .shards( shardStats -> shardStats.total(3) .successful(1) .skipped(1) .failed(1) .failures( shardFailure -> shardFailure.index("index") .node("node") .shard(1) .status("Failed") .reason(cause -> cause.type("query_shard_exception").reason("Failed to create query.")) ) ) );  String indexResponseString = indexResponse.toJsonString(); "<AssertPlaceHolder>"; }
toJsonString() { try (StringWriter writer = new StringWriter()) { try (JsonGenerator generator = JsonpUtils.DEFAULT_PROVIDER.createGenerator(writer)) { serialize(generator, JsonpUtils.DEFAULT_JSONP_MAPPER); } return writer.toString(); } catch (IOException ex) { throw new UncheckedIOException(ex); } }
[*] target: assertEquals(expectedStringValue, indexResponseString)
[-] pred: org. junit. Assert. assertEquals ( expectedStringValue, indexResponseString )
************************************
************************************
[+] input: Exception { RetryActionWithOneParam<String, R> retryActionWithOneParam = new RetryActionWithOneParam<>( "print", 3, "a" ); R result = retryActionWithOneParam.action( a -> { throw new RuntimeException("run time exception test"); } ); Assert."<AssertPlaceHolder>"; }
action(Function<P, R> func) { int times = 0; do { times++; try { return func.apply(param); } catch (DataAccessException ex) { log.warn("{} arg0[{}] in redis happen DataAccessException, times[{}]", actionName, GsonUtils.toJsonString(param), times, ex ); } catch (Exception ex) { log.error("{} arg0[{}] in redis fail.", actionName, GsonUtils.toJsonString(param), ex); break; } } while (times < retryTimes); return null; }
[*] target: assertEquals(null, result)
[-] pred: org. junit. Assert. assertEquals ( null, result )
************************************
************************************
[+] input: testEncryptDecrypt() { char[] password = "insecure".toCharArray(); int keyLength = 128;  Crypter crypter = BEANS.get(Crypter.class).init(password, keyLength); String clearTextData = "lorem ipsum dolor"; String encryptedData = crypter.encrypt(clearTextData); String decryptedData = crypter.decrypt(encryptedData); "<AssertPlaceHolder>"; }
decrypt(String encryptedData) { return decrypt(encryptedData, false); }
[*] target: assertEquals(clearTextData, decryptedData)
[-] pred: org. junit. Assert. assertEquals ( clearTextData, decryptedData )
************************************
************************************
[+] input: rtspSetupRequestTest() {  String expect = "SETUP rtsp://10.3.8.202:554/trackID=1 RTSP/1.0\r\n" + "CSeq: 0\r\n" + "Authorization: Digest username="admin", realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", uri="rtsp://10.3.8.202:554", response="56d55b92e8b41aa6cc1a68a5c2e2de15"\r\n" + "User-Agent: IOT-COMMUNICATION\r\n" + "Transport: RTP/AVP;unicast;client_port=57844-57845\r\n" + "\r\n";  URI uri = URI.create("rtsp://10.3.8.202:554/trackID=1"); RtspTransport transport = RtspTransport.fromString("RTP/AVP;unicast;client_port=57844-57845"); RtspSetupRequest request = new RtspSetupRequest(uri, transport, this.authenticator); request.setCSeq(0); String actual = request.toObjectString(); "<AssertPlaceHolder>"; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testConstructionDuplicate() {  // Create an ECMP switch with port 0 to 1... device0 = new EcmpSwitch(0, null, 5, new IdentityFlowletIntermediary()); device0.addConnection(topology.getPort(0, 1)); device0.addDestinationToNextSwitch(1, 1);  // ... and try to add the same destination to switch again boolean thrown = false; try { device0.addDestinationToNextSwitch(1, 1); } catch (IllegalArgumentException e) { thrown = true; } "<AssertPlaceHolder>";  }
addDestinationToNextSwitch(int destinationId, int nextHopId) {  // Check for not possible identifier if (!connectedTo.contains(nextHopId)) { throw new IllegalArgumentException("Cannot add hop to a network device to which it is not connected (" + nextHopId + ")"); }  // Check for duplicate List<Integer> current = this.destinationToNextSwitch.get(destinationId); if (current.contains(nextHopId)) { throw new IllegalArgumentException("Cannot add a duplicate next hop network device identifier (" + nextHopId + ")"); }  // Add to current ones current.add(nextHopId);  }
[*] target: assertTrue(thrown)
[-] pred: org. junit. Assert. assertTrue ( thrown )
************************************
************************************
[+] input: lrcTest1() { byte[] src = new byte[]{0x01, 0x03, 0x00, 0x00, 0x00, 0x14}; boolean actual = LRCUtil.lrc(src, (byte) 0xE8); "<AssertPlaceHolder>"; }
lrc(byte[] src, byte target) { byte des = lrc(src); return des == target; }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: containsEmptyKey() { JapCache japCache = new JapLocalCache(); boolean containsKey = japCache.containsKey(""); Assert."<AssertPlaceHolder>"; }
containsKey(String key) { if (StrUtil.isEmpty(key)) { return false; } readLock.lock(); try { CacheObj cacheObj = LOCAL_CACHE.get(key); return null != cacheObj && !cacheObj.isExpired(); } finally { readLock.unlock(); } }
[*] target: assertFalse(containsKey)
[-] pred: org. junit. Assert. assertFalse ( containsKey )
************************************
************************************
[+] input: testRunScript_error_warn() { TextFileLocation location = new TextFileLocation("file.js", 5, 7, 6, 8); Object result = EvaluateStatement.runScript("Hello ${name}", "ftl", "warn", context, location); "<AssertPlaceHolder>"; }
runScript( String text, String type, String onError, Context context, TextFileLocation location) { ErrorHandler errorHandler = new ErrorHandler(EvaluateStatement.class.getName(), Level.valueOf(onError)); boolean evaluating = false; try { Script script = ScriptUtil.parseScriptText(text, type); evaluating = true; return script.evaluate(context); } catch (Exception e) { RuntimeException e2; if (evaluating) { e2 = BeneratorExceptionFactory.getInstance().scriptEvaluationFailed( "Error evaluating script", e, text, location); } else { e2 = BeneratorExceptionFactory.getInstance().syntaxErrorForText( "Error parsing script", e, BeneratorErrorIds.SYN_EVALUATE_TEXT, location); } errorHandler.handleError(e2.getMessage(), e2); return null; } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: Exception { String entityContent = "{\n" + "    "TxnId": 22736752,\n" + "    "Label": "119d4ca5-a920-4dbb-84ad-64e062a449c5",\n" + "    "Status": "Success",\n" + "    "Message": "OK",\n" + "    "NumberTotalRows": 93,\n" + "    "NumberLoadedRows": 93,\n" + "    "NumberFilteredRows": 0,\n" + "    "NumberUnselectedRows": 0,\n" + "    "LoadBytes": 17227,\n" + "    "LoadTimeMs": 17575,\n" + "    "BeginTxnTimeMs": 0,\n" + "    "StreamLoadPlanTimeMs": 1,\n" + "    "ReadDataTimeMs": 0,\n" + "    "WriteDataTimeMs": 17487,\n" + "    "CommitAndPublishTimeMs": 86\n" + "}";  ObjectMapper objectMapper = new ObjectMapper(); // StreamLoadResponseBody does not contain all fields returned by StarRocks objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // filed names in StreamLoadResponseBody are case-insensitive objectMapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true); StreamLoadResponse.StreamLoadResponseBody responseBody = objectMapper.readValue(entityContent, StreamLoadResponse.StreamLoadResponseBody.class);  Assert."<AssertPlaceHolder>"; }
getStreamLoadPlanTimeMs() { return streamLoadPlanTimeMs; }
[*] target: assertNotNull(responseBody.getStreamLoadPlanTimeMs())
[-] pred: org. junit. Assert. assertNotNull ( responseBody. getStreamLoadPlanTimeMs() )
************************************
************************************
[+] input: Exception { JobID jobId = randomJobId(); RegistrationID worker1 = new RegistrationID();  AssignmentTracker assignmentTracker = createAssignmentTracker( jobId, worker1, new InstanceID("worker1"), new EmptyShuffleWorkerGateway());  DataSetID dataSetId = randomDataSetId(); MapPartitionID dataPartitionId = randomMapPartitionId(); ShuffleResource shuffleResource1 = assignmentTracker.requestShuffleResource( jobId, dataSetId, dataPartitionId, 2, partitionFactory, null);  // reallocation the same data partition on the same worker should remain unchanged ShuffleResource shuffleResource2 = assignmentTracker.requestShuffleResource( jobId, dataSetId, dataPartitionId, 2, partitionFactory, null); "<AssertPlaceHolder>"; }
requestShuffleResource( JobID jobID, DataSetID dataSetID, MapPartitionID mapPartitionID, int numberOfConsumers, String dataPartitionFactoryName, String taskLocation) throws ShuffleResourceAllocationException;
[*] target: assertEquals(shuffleResource1, shuffleResource2)
[-] pred: org. junit. Assert. assertEquals ( shuffleResource1, shuffleResource2 )
************************************
************************************
[+] input: IOException { String pemPathString = "src/test/java/unit/signature/Ed25519PrivateKeyExample.pem";  String payload = "timeInForce=GTC&quantity=0.2&price=30000&symbol=BTCUSDT&side=SELL&type=LIMIT&timestamp=1683189275000"; String expectedSignature = "kJs8urXFQ/GkR/hQ+ukZMFwH9H8oe7Ec/sap6pFIB/7HHHoh5mKVQT1zLVaRl7QdJLjNB2QB4PGZPflubUCHBA==";  Ed25519SignatureGenerator ed25519SignatureGenerator = new Ed25519SignatureGenerator(pemPathString); String actualSignature = ed25519SignatureGenerator.getSignature(payload); "<AssertPlaceHolder>"; }
getSignature(String data) {  byte[] dataBytes = data.getBytes(StandardCharsets.UTF_8);  Ed25519Signer signer = new Ed25519Signer(); signer.init(true, this.privateKey); signer.update(dataBytes, offset, dataBytes.length); byte[] signatureBytes = signer.generateSignature(); return Base64.getEncoder().encodeToString(signatureBytes);  }
[*] target: assertEquals(expectedSignature, actualSignature)
[-] pred: org. junit. Assert. assertEquals ( expectedSignature, actualSignature )
************************************
************************************
[+] input: testCheckAndSet_EnableCaching_IfModifiedSince_NotModifiedAtFidelity() { Mockito.when(req.getPathInfo()).thenReturn("/"); Mockito.when(req.getHeader(HttpCacheControl.ETAG)).thenReturn(null); Mockito.when(req.getHeader(HttpCacheControl.IF_NONE_MATCH)).thenReturn(null); Mockito.when(req.getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE)).thenReturn(1000000L);  BinaryResource res = BinaryResources.create() .withFilename("a.html") .withContent("<html></html>".getBytes(StandardCharsets.UTF_8)) .withCachingAllowed(true) .withLastModified(1000000L + HttpCacheControl.IF_MODIFIED_SINCE_FIDELITY) .build(); HttpCacheObject obj = new HttpCacheObject(new HttpCacheKey("/"), res); boolean b = cc.checkAndSetCacheHeaders(req, resp, obj); Assert."<AssertPlaceHolder>";  Mockito.verify(req, ANY_TIMES).getPathInfo(); Mockito.verify(req, ANY_TIMES).getAttribute("jakarta.servlet.forward.path_info"); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.ETAG); Mockito.verify(req, ANY_TIMES).getHeader(HttpCacheControl.IF_NONE_MATCH); Mockito.verify(req, ANY_TIMES).getDateHeader(HttpCacheControl.IF_MODIFIED_SINCE); Mockito.verify(resp, ONCE).setHeader(HttpCacheControl.CACHE_CONTROL, "private, max-age=0, must-revalidate"); Mockito.verify(resp, ONCE).setStatus(HttpServletResponse.SC_NOT_MODIFIED); }
checkAndSetCacheHeaders(HttpServletRequest req, HttpServletResponse resp, HttpCacheObject obj) { if (!UrlHints.isCacheHint(req)) { disableCaching(req, resp); return false; }  if (obj == null || !obj.isCachingAllowed()) { disableCaching(req, resp); return false; }  int maxAge = obj.getCacheMaxAge(); if (maxAge > 0) { // "private" //   Only browsers may cache this resource. // "max-age" //   A cache may use this resource for X seconds without checking with the server. s-maxage //   is basically the same, but for proxies (s = shared). This overrides any default value //   the proxy may use internally. // Note: Because "must-revalidate" is not present, a cache MAY use a stale resource longer than max-age. resp.setHeader(CACHE_CONTROL, "private, max-age=" + maxAge + ", s-maxage=" + maxAge); } else { // "private" //   Only browsers may cache this resource. // "must-revalidate" //   A cache HAS TO check with the server before using stale resources. // "max-age=0" //   A resource will become stale immediately (after 0 seconds). // Note: "max-age=0, must-revalidate" would be the same as "no-cache" resp.setHeader(CACHE_CONTROL, "private, max-age=0, must-revalidate"); }  String etag = obj.createETag(); String ifNoneMatch = req.getHeader(IF_NONE_MATCH); boolean clientSentEtag = (ifNoneMatch != null);  // Check If-None-Match (Etag) if (clientSentEtag) { if (notModified(ifNoneMatch, etag)) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-None-Match/Etag): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } // When the Etag comparison fails (i.e. file was modified), we must _not_ check for If-Modified-Since! } // Check If-Modified-Since else { long ifModifiedSince = req.getDateHeader(IF_MODIFIED_SINCE); if (notModifiedSince(ifModifiedSince, obj.getResource().getLastModified())) { if (LOG.isDebugEnabled()) { LOG.debug("Use http cached object (If-Modified-Since): {}", req.getPathInfo()); } resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); return true; } }  if (obj.getResource().getLastModified() > 0) { resp.setDateHeader(LAST_MODIFIED, obj.getResource().getLastModified()); } if (etag != null) { resp.setHeader(ETAG, etag); }  return false; }
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
************************************
************************************
[+] input: testSerialize() { List<TableMeta.FieldMeta> fieldMetas = Lists.newArrayList( new TableMeta.FieldMeta("c1", "char", true, true, "xxx", false, "xxx"), new TableMeta.FieldMeta("c2", "char", true, true, "xxx", false, "xxx"), new TableMeta.FieldMeta("c3", "char", true, true, "xxx", false, "xxx") );  Map<String, TableMeta.IndexMeta> indexMetaMap = Maps.newHashMap(); indexMetaMap.put("idx1", new TableMeta.IndexMeta("idx1", "INDEX", false)); indexMetaMap.put("idx2", new TableMeta.IndexMeta("idx2", "INDEX", false)); indexMetaMap.put("idx3", new TableMeta.IndexMeta("idx3", "INDEX", false));  TableMeta tableMeta = new TableMeta(); tableMeta.setTable("t1"); tableMeta.setDdl("create table t1(id bigint)"); tableMeta.setCharset("utf8"); tableMeta.setSchema("d1"); tableMeta.setUseImplicitPk(true); tableMeta.setFields(fieldMetas); tableMeta.setIndexes(indexMetaMap);  DefaultQueryLog defaultQueryLog = new DefaultQueryLog( "d1", "create table t1", new Timestamp(System.currentTimeMillis()), 10000000, 1, DBMSAction.CREATE, System.currentTimeMillis()); defaultQueryLog.setFirstDdl(new AtomicBoolean(true)); defaultQueryLog.setParallelSeq(23); defaultQueryLog.setOptionValue("opt1", 200); defaultQueryLog.setTableMeta(tableMeta);  byte[] data = SerializationUtils.serialize(defaultQueryLog); DefaultQueryLog defaultQueryLog1 = SerializationUtils.deserialize(data); Assert."<AssertPlaceHolder>"; }
setTableMeta(TableMeta tableMeta) { this.tableMeta = tableMeta; }
[*] target: assertEquals(defaultQueryLog, defaultQueryLog1)
[-] pred: org. junit. Assert. assertEquals ( defaultQueryLog, defaultQueryLog1 )
************************************
************************************
[+] input: testToString() { String expectedStr = "HttpClientConfig(" + "protocol=https" + ", socketTimeoutMillis=5000" + ", maxIdleTimeMillis=43000" + ", connectionRequestTimeoutMillis=1000" + ", connectionKeepAliveMillis=43000" + ", connectionTimeoutMillis=15000" + ", responseTimeoutMillis=20000" + ", maxConnectionCount=200" + ", maxConnectionCountPerRoute=20" + ", maxNoResponseRetryCount=1" + ", proxyScheme=null" + ", proxyHost=null" + ", proxyPort=-1)";  HttpClientConfig config = HttpClientConfig.defaultConfig();  "<AssertPlaceHolder>"; }
toString() { return "HttpClientConfig(" + "protocol=" + protocol + ", socketTimeoutMillis=" + socketTimeoutMillis + ", maxIdleTimeMillis=" + maxIdleTimeMillis + ", connectionRequestTimeoutMillis=" + connectionRequestTimeoutMillis + ", connectionKeepAliveMillis=" + connectionKeepAliveMillis + ", connectionTimeoutMillis=" + connectionTimeoutMillis + ", responseTimeoutMillis=" + responseTimeoutMillis + ", maxConnectionCount=" + maxConnectionCount + ", maxConnectionCountPerRoute=" + maxConnectionCountPerRoute + ", maxNoResponseRetryCount=" + maxNoResponseRetryCount + ", proxyScheme=" + proxyScheme + ", proxyHost=" + proxyHost + ", proxyPort=" + proxyPort + ")"; }
[*] target: assertEquals(expectedStr, config.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedStr, config. toString ( ) )
************************************
************************************
[+] input: DeserializerException { when(testGrpcService.bindService()).thenCallRealMethod();  Server server = ServerBuilder .forPort(5000) .addService(testGrpcService.bindService()) .build() .start();  Map<String, String> config = new HashMap<>(); config.put("SINK_GRPC_METHOD_URL", "org.raystack.firehose.consumer.TestServer/TestRpcMethod"); config.put("SINK_GRPC_SERVICE_HOST", "localhost"); config.put("SINK_GRPC_SERVICE_PORT", "5000");   Sink sink = GrpcSinkFactory.create(config, statsDReporter, stencilClient);  Assert."<AssertPlaceHolder>"; server.shutdownNow(); }
create(Map<String, String> configuration, StatsDReporter statsDReporter, StencilClient stencilClient) { GrpcSinkConfig grpcConfig = ConfigFactory.create(GrpcSinkConfig.class, configuration); FirehoseInstrumentation firehoseInstrumentation = new FirehoseInstrumentation(statsDReporter, GrpcSinkFactory.class); String grpcSinkConfig = String.format("\n\tService host: %s\n\tService port: %s\n\tMethod url: %s\n\tResponse proto schema: %s", grpcConfig.getSinkGrpcServiceHost(), grpcConfig.getSinkGrpcServicePort(), grpcConfig.getSinkGrpcMethodUrl(), grpcConfig.getSinkGrpcResponseSchemaProtoClass()); firehoseInstrumentation.logDebug(grpcSinkConfig);  ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(grpcConfig.getSinkGrpcServiceHost(), grpcConfig.getSinkGrpcServicePort()).usePlaintext().build();  GrpcClient grpcClient = new GrpcClient(new FirehoseInstrumentation(statsDReporter, GrpcClient.class), grpcConfig, managedChannel, stencilClient); firehoseInstrumentation.logInfo("GRPC connection established");  return new GrpcSink(new FirehoseInstrumentation(statsDReporter, GrpcSink.class), grpcClient, stencilClient); }
[*] target: assertNotNull(sink)
[-] pred: org. junit. Assert. assertNotNull ( sink )
************************************
************************************
[+] input: Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> a ); String result = redisCache.hget("key", "field", String.class); Assert."<AssertPlaceHolder>"; }
hget(String key, String field, Class<T> type) throws DataAccessException { if (isBlank(key) || isBlank(field)) { return null; } String keyString = keyPrefix.concat(key); return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[] fieldb = field.getBytes(); byte[] valueb = connection.hGet(keyb, fieldb); return GsonUtils.toObject(valueb, type); }); }
[*] target: assertEquals(a, result)
[-] pred: org. junit. Assert. assertEquals ( a, result )
************************************
************************************
[+] input: writeTimeOfDay() { LocalTime expect = LocalTime.of(20, 15, 11); s7PLC.writeTimeOfDay("DB4.298", expect); LocalTime actual = s7PLC.readTimeOfDay("DB4.298"); "<AssertPlaceHolder>"; }
readTimeOfDay(String address) { long value = this.readUInt32(address); return LocalTime.ofSecondOfDay(value / 1000); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testSearchResponse() {  String expectedStringValue = "{"aggregations":{},"query":{"match":{"name":{"query":"OpenSearch"}}},"terminate_after":5}"; SearchRequest searchRequest = SearchRequest.of( request -> request.index("index1", "index2") .aggregations(Collections.emptyMap()) .terminateAfter(5L) .query(q -> q.match(t -> t.field("name").query(FieldValue.of("OpenSearch")))) ); String searchRequestString = searchRequest.toJsonString(); "<AssertPlaceHolder>";  }
toJsonString() { try (StringWriter writer = new StringWriter()) { try (JsonGenerator generator = JsonpUtils.DEFAULT_PROVIDER.createGenerator(writer)) { serialize(generator, JsonpUtils.DEFAULT_JSONP_MAPPER); } return writer.toString(); } catch (IOException ex) { throw new UncheckedIOException(ex); } }
[*] target: assertEquals(expectedStringValue, searchRequestString)
[-] pred: org. junit. Assert. assertEquals ( expectedStringValue, searchRequestString )
************************************
************************************
[+] input: toByteArray() { Header header = new Header(); header.setProtocolId((byte) 0x32); header.setMessageType(EMessageType.JOB); header.setReserved(0x0000); header.setPduReference(0x0000); header.setParameterLength(0x0000); header.setDataLength(0x0002); //        header.setErrorClass(EErrorClass.NO_ERROR); //        header.setErrorCode((byte) 0x00); byte[] actual = header.toByteArray(); //        byte[] expect = new byte[]{(byte) 0x32, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00}; byte[] expect = new byte[]{(byte) 0x32, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02}; "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.protocolId) .putByte(this.messageType.getCode()) .putShort(this.reserved) .putShort(this.pduReference) .putShort(this.parameterLength) .putShort(this.dataLength) .getData(); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: toByteArray() { COTPData cotpData = new COTPData(); cotpData.setLength((byte) 0x11); cotpData.setPduType(EPduType.CONNECT_REQUEST); cotpData.setTpduNumber((byte) 0x01); cotpData.setLastDataUnit(true); byte[] actual = cotpData.toByteArray(); byte[] expect = {(byte) 0x11, (byte)0xE0, (byte)0x81}; "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.length) .putByte(this.pduType.getCode()) // TPDU编号和是否最后一个数据单元组合成一个字节，最高位表示是否最后一个 .putByte((byte) (BooleanUtil.setBit((byte) 0x00, 7, this.lastDataUnit) | (this.tpduNumber & 0xFF))) .getData(); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: toByteArray() { COTPConnection connection = COTPConnection.crConnectRequest(0x0100,0x0100); byte[] actual = connection.toByteArray(); byte[] expect = {(byte) 0x11, (byte) 0xE0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0xC0, (byte) 0x01, (byte) 0x0A, (byte) 0xC1, (byte) 0x02, (byte) 0x01, (byte) 0x00, (byte) 0xC2, (byte) 0x02, (byte) 0x01, (byte) 0x00};  "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(BYTE_LENGTH) .putByte(this.length) .putByte(this.pduType.getCode()) .putShort(this.destinationReference) .putShort(this.sourceReference) .putByte(this.flags) .putByte(this.parameterCodeTpduSize) .putByte(this.parameterLength1) .putByte(this.tpduSize) .putByte(this.parameterCodeSrcTsap) .putByte(this.parameterLength2) .putShort(this.sourceTsap) .putByte(this.parameterCodeDstTsap) .putByte(this.parameterLength3) .putShort(this.destinationTsap) .getData(); }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: shouldNotBeEmptyWhenExternalSourceHasHttpConfigExist() { ArrayList<HttpSourceConfig> http = new ArrayList<>(); http.add(new HttpSourceConfig("", "", "", "", "", "", "", "", "", false, "", "", new HashMap<>(), new HashMap<>(), "metricId_01", false)); ArrayList<EsSourceConfig> es = new ArrayList<>(); ArrayList<PgSourceConfig> pg = new ArrayList<>(); ExternalSourceConfig externalSourceConfig = new ExternalSourceConfig(http, es, pg, new ArrayList<>()); defaultPostProcessorConfig = new PostProcessorConfig(externalSourceConfig, null, null);  "<AssertPlaceHolder>"; }
isEmpty() { return !hasTransformConfigs() && !hasExternalSource() && !hasInternalSource(); }
[*] target: assertFalse(defaultPostProcessorConfig.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( defaultPostProcessorConfig. isEmpty() )
************************************
************************************
[+] input: testCreateHttpClientInfo() { Map<String, HttpClientInfo> testMap = initTestMap(); for (String userAgent : testMap.keySet()) { HttpClientInfo createdHttpClientInfo = newHttpClientInfo(userAgent); HttpClientInfo expectedHttpClientInfo = testMap.get(userAgent);  //Ignore versions if not explicitly set if (expectedHttpClientInfo.getEngineVersion() == null) { createdHttpClientInfo.setEngineVersion(null); } if (expectedHttpClientInfo.getSystemVersion() == null) { createdHttpClientInfo.setSystemVersion(null); }  "<AssertPlaceHolder>"; } }
setSystemVersion(Version systemVersion) { m_systemVersion = systemVersion; }
[*] target: assertEquals(expectedHttpClientInfo, createdHttpClientInfo)
[-] pred: org. junit. Assert. assertEquals ( expectedHttpClientInfo, createdHttpClientInfo )
************************************
************************************
[+] input: Exception { String expected = StringUtility.trim(readFile("json/DefaultValuesFilterServiceTest_defaults_override_expected.json")); String actual = BEANS.get(DefaultValuesFilterService.class).getCombinedDefaultValuesConfiguration(); "<AssertPlaceHolder>"; }
getCombinedDefaultValuesConfiguration() { ensureLoaded(); return m_combinedDefaultValuesConfiguration; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { this.rpcSofaTracer.startRpc(sofaRequest);  SofaTraceContext sofaTraceContext = SofaTraceContextHolder.getSofaTraceContext(); SofaTracerSpan sofaTracerSpan = sofaTraceContext.pop(); "<AssertPlaceHolder>"; System.err.println("\n" + sofaTracerSpan); }
startRpc(SofaRequest request) { //客户端的启动 SofaTraceContext sofaTraceContext = SofaTraceContextHolder.getSofaTraceContext(); SofaTracerSpan serverSpan = sofaTraceContext.pop();  SofaTracerSpan clientSpan = (SofaTracerSpan) this.sofaTracer.buildSpan(request.getInterfaceName()) .asChildOf(serverSpan) .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT) .start();  if (RpcInternalContext.isAttachmentEnable()) { RpcInternalContext context = RpcInternalContext.getContext(); clientSpan .setTag(RpcSpanTags.LOCAL_APP, (String) context.getAttachment(RpcConstants.INTERNAL_KEY_APP_NAME)); clientSpan.setTag(RpcSpanTags.PROTOCOL, (String) context.getAttachment(RpcConstants.INTERNAL_KEY_PROTOCOL_NAME)); SofaTracerSpanContext spanContext = clientSpan.getSofaTracerSpanContext(); if (spanContext != null) { context.setAttachment(RpcConstants.INTERNAL_KEY_TRACE_ID, spanContext.getTraceId()); context.setAttachment(RpcConstants.INTERNAL_KEY_SPAN_ID, spanContext.getSpanId()); } }  clientSpan.setTag(RpcSpanTags.SERVICE, request.getTargetServiceUniqueName()); clientSpan.setTag(RpcSpanTags.METHOD, request.getMethodName()); clientSpan.setTag(RpcSpanTags.CURRENT_THREAD_NAME, Thread.currentThread().getName());  //需要主动缓存自己的 serverSpan,原因是:asChildOf 关注的是 spanContext clientSpan.setParentSofaTracerSpan(serverSpan); //push sofaTraceContext.push(clientSpan); }
[*] target: assertNotNull(sofaTracerSpan)
[-] pred: org. junit. Assert. assertNotNull ( sofaTracerSpan )
************************************
************************************
[+] input: MalformedURLException { URL jarUrl = getClass().getResource("test repository/test.jar_"); URL scoutXml = new URL("jar:" + jarUrl.toExternalForm() + "!/" + JandexInventoryBuilder.SCOUT_XML_PATH); JandexInventoryBuilder builder = new JandexInventoryBuilder(RebuildStrategy.ALWAYS); Index index = builder.scanModule(builder.findIndexUri(scoutXml)); "<AssertPlaceHolder>"; }
findIndexUri(URL scoutXmlUrl) { String s = scoutXmlUrl.toExternalForm(); try { return new URI(s.substring(0, s.length() - SCOUT_XML_PATH.length()) + JANDEX_INDEX_PATH); } catch (URISyntaxException ex) { throw new PlatformException("Cannot find index URI from '{}'", s, ex); } }
[*] target: assertNotNull(index)
[-] pred: org. junit. Assert. assertNotNull ( index )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x10, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x02, (byte) 0x04, (byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x02}; MbWriteMultipleRegisterRequest mb = new MbWriteMultipleRegisterRequest(); mb.setFunctionCode(EMbFunctionCode.WRITE_MULTIPLE_REGISTER); mb.setAddress(1); mb.setQuantity(2); mb.setCount(4); mb.setValue(new byte[]{(byte) 0x00, (byte) 0x0A, (byte) 0x01, (byte) 0x02}); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .putByte(this.count) .putBytes(this.value) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: testTableExists() { ObjectPath objectPath = new ObjectPath("default", "test"); boolean exists = rocketMQCatalog.tableExists(objectPath); "<AssertPlaceHolder>"; }
tableExists(ObjectPath tablePath) throws CatalogException { if (!getDefaultDatabase().equals(tablePath.getDatabaseName())) { throw new CatalogException("Database name is not default."); } if (StringUtils.isEmpty(tablePath.getObjectName())) { return false; } String subject = tablePath.getObjectName(); try { GetSchemaResponse getSchemaResponse = schemaRegistryClient.getSchemaBySubject(subject); if (Objects.nonNull(getSchemaResponse)) { return true; } } catch (Exception e) { throw new CatalogException( String.format( "Failed to get schema of table %s from schema registry client.", tablePath.getFullName()), e); } return false; }
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
************************************
[+] input: testNull() { Mask m = new Mask(); "<AssertPlaceHolder>"; }
convert(Object sourceValue) throws ConversionException { if (sourceValue == null) { return null; } String string = ToStringConverter.convert(sourceValue, null); int length = string.length(); char[] chars = new char[string.length()]; Arrays.fill(chars, 0, length, maskChar); return new String(chars); }
[*] target: assertNull(m.convert(null))
[-] pred: org. junit. Assert. assertNull ( m. convert ( null ) )
************************************
************************************
[+] input: testFor() { AggregationPipeline<Document> pipeline = AggregationPipeline.create();  pipeline.project(Projection.project() .include("date", DateExpressions.dateToParts(field("date"))) .include("date_iso",DateExpressions.dateToParts(field("date")).iso8601(true).timezone(value("Asia/Shanghai"))));  Document document = mars.aggregate(pipeline, "sales").tryNext(); Assert."<AssertPlaceHolder>";  }
timezone(Expression timezone) { this.timeZone = timezone; return this; }
[*] target: assertNotNull(document)
[-] pred: org. junit. Assert. assertNotNull ( document )
************************************
************************************
[+] input: shouldBeAbleToBuildSourceIfSourceDetailsIsUnboundedKafkaAndDaggerDeserializerIsKafkaDeserializationSchema() { when(streamConfig.getSourceDetails()).thenReturn(new SourceDetails[]{new SourceDetails(SourceName.KAFKA_SOURCE, SourceType.UNBOUNDED)}); KafkaDaggerSource daggerSource = new KafkaDaggerSource(streamConfig, configuration, daggerDeserializer);  "<AssertPlaceHolder>"; }
canBuild() { SourceDetails[] sourceDetailsArray = streamConfig.getSourceDetails(); if (sourceDetailsArray.length != 1) { return false; } else { SourceName sourceName = sourceDetailsArray[0].getSourceName(); SourceType sourceType = sourceDetailsArray[0].getSourceType(); return sourceName.equals(SUPPORTED_SOURCE_NAME) && sourceType.equals(SUPPORTED_SOURCE_TYPE) && deserializer instanceof KafkaDeserializationSchema; } }
[*] target: assertTrue(daggerSource.canBuild())
[-] pred: org. junit. Assert. assertTrue ( daggerSource. canBuild ( ) )
************************************
************************************
[+] input: selectSingle5() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andIn(MysqlUserEntity::getId, Arrays.asList(1, 1, 1, 1, 1, 1)); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); dynamicSql.andEqualTo(MysqlUserEntity::getGender, GenderEnum.未知); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert."<AssertPlaceHolder>"; log.info("mysqlUserEntity : {}", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }
[*] target: assertNotNull(mysqlUserEntity)
[-] pred: org. junit. Assert. assertNotNull ( mysqlUserEntity )
************************************
************************************
[+] input: createEsJsonWebKeySetJson() { String jwkJson = JwkUtil.createEsJsonWebKeySetJson("jap-jwks-keyid", TokenSigningAlg.ES256); Assert."<AssertPlaceHolder>"; }
createEsJsonWebKeySetJson(String keyId, TokenSigningAlg signingAlg) { EllipticCurveJsonWebKey jwk = createEsJsonWebKey(keyId, signingAlg); return new JsonWebKeySet(jwk).toJson(JsonWebKey.OutputControlLevel.INCLUDE_PRIVATE); }
[*] target: assertNotNull(jwkJson)
[-] pred: org. junit. Assert. assertNotNull ( jwkJson )
************************************
************************************
[+] input: shouldTransformEpochInMillisFromSimpleGroup() { long sampleTimeInMillis = Instant.now().toEpochMilli(); Instant instant = Instant.ofEpochMilli(sampleTimeInMillis); Row expectedRow = Row.of(instant.getEpochSecond(), instant.getNano());  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("event_timestamp"); GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named("event_timestamp") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); simpleGroup.add("event_timestamp", sampleTimeInMillis);  TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row actualRow = (Row) timestampHandler.transformFromParquet(simpleGroup);  "<AssertPlaceHolder>"; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }
[*] target: assertEquals(expectedRow, actualRow)
[-] pred: org. junit. Assert. assertEquals ( expectedRow, actualRow )
************************************
************************************
[+] input: mp4SttsBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; Mp4SttsBox box = new Mp4SttsBox(); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: rtspClientPortTransportToString1() { String expect = "RTP/AVP;unicast;client_port=60802-60803"; RtspClientPortTransport transport = new RtspClientPortTransport(); transport.setProtocol("RTP/AVP"); transport.setCastMode("unicast"); transport.setRtpClientPort(60802); transport.setRtcpClientPort(60803); "<AssertPlaceHolder>"; }
toString() { if (this.protocol == null || this.protocol.equals("")) { throw new RtspCommException("protocol of RtspTransport is null or empty"); } if (this.castMode == null || this.castMode.equals("")) { throw new RtspCommException("castMode of RtspTransport is null or empty"); } List<String> res = new ArrayList<>(); res.add(this.protocol); res.add(this.castMode);  if (this.ssrc != null && !this.ssrc.equals("")) { res.add(String.format("ssrc=%s", this.ssrc)); } if (this.mode != null && !this.mode.equals("")) { res.add(String.format("mode="%s"", this.mode)); } return String.join(";", res); }
[*] target: assertEquals(expect, transport.toString())
[-] pred: org. junit. Assert. assertEquals ( expect, transport. toString ( ) )
************************************
************************************
[+] input: shouldUpdateCountAndReturnTheCorrectCountValue() { Counter simpleCounter = new SimpleCounter(); when(metricGroup.addGroup("counterTest")).thenReturn(metricGroup); when(metricGroup.counter("test_aspect3")).thenReturn(simpleCounter); counterStatsManager.registerAspects(TestAspects.values(), "counterTest"); counterStatsManager.inc(TestAspects.TEST_ASPECT_THREE); counterStatsManager.inc(TestAspects.TEST_ASPECT_THREE); long count = counterStatsManager.getCount(TestAspects.TEST_ASPECT_THREE); "<AssertPlaceHolder>"; }
getCount(Aspects aspect) { return counters.get(aspect).getCount(); }
[*] target: assertEquals(2, count)
[-] pred: org. junit. Assert. assertEquals ( 2, count )
************************************
************************************
[+] input: testToString() { String expectedStr = "CommonResponse(code=2, msg=msg-2)";  CommonResponse response = new TestResponse(2, "msg-2");  "<AssertPlaceHolder>"; }
toString() { return "CommonResponse(" + "code=" + code + ", msg=" + msg + ")"; }
[*] target: assertEquals(expectedStr, response.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedStr, response. toString ( ) )
************************************
************************************
[+] input: Exception { BinaryResource res = BinaryResources.create() .withFilename("a.html") .withContent("<html></html>".getBytes("UTF-8")) .build(); HttpCacheKey key = new HttpCacheKey("/"); HttpCacheObject obj = new HttpCacheObject(key, res); boolean b = rc.put(obj); Assert."<AssertPlaceHolder>"; }
put(HttpCacheObject obj) { if (!obj.isCachingAllowed()) { return false; } m_cache.put(obj.getCacheKey(), obj); LOG.debug("Stored object in cache: {}", obj.getCacheKey()); return true; }
[*] target: assertFalse(b)
[-] pred: org. junit. Assert. assertFalse ( b )
************************************
************************************
[+] input: shouldTransformGroupTypeTimestampFromSimpleGroup() { Instant currentInstant = Instant.now(); long seconds = currentInstant.getEpochSecond(); int nanos = currentInstant.getNano(); Row expectedRow = Row.of(seconds, nanos);  Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("event_timestamp"); GroupType timestampSchema = org.apache.parquet.schema.Types.requiredGroup() .required(INT64).named("seconds") .required(INT32).named("nanos") .named("event_timestamp"); SimpleGroup timestampMessage = new SimpleGroup(timestampSchema); timestampMessage.add("seconds", seconds); timestampMessage.add("nanos", nanos);  MessageType parquetSchema = buildMessage() .addField(timestampSchema) .named("TestBookingLogMessage"); SimpleGroup mainMessage = new SimpleGroup(parquetSchema); mainMessage.add("event_timestamp", timestampMessage);  TimestampHandler timestampHandler = new TimestampHandler(fieldDescriptor); Row actualRow = (Row) timestampHandler.transformFromParquet(mainMessage);  "<AssertPlaceHolder>"; }
transformFromParquet(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName(); if (simpleGroup != null && SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { Type timestampType = simpleGroup.getType().getType(fieldName); if (timestampType instanceof PrimitiveType) { return parseInt64TimestampFromSimpleGroup(simpleGroup, fieldName); } else if (timestampType instanceof GroupType) { return parseGroupTypeTimestampFromSimpleGroup(simpleGroup, fieldName); } } return Row.of(DEFAULT_SECONDS_VALUE, DEFAULT_NANOS_VALUE); }
[*] target: assertEquals(expectedRow, actualRow)
[-] pred: org. junit. Assert. assertEquals ( expectedRow, actualRow )
************************************
************************************
[+] input: selectSingle6() { final DynamicSql<MysqlUserEntity> dynamicSql = DynamicSql.createDynamicSql(); dynamicSql.andIn(MysqlUserEntity::getId, Arrays.asList(1, 1, 1, 1, 1, 1)); dynamicSql.andEqualTo(MysqlUserEntity::getId, 1); dynamicSql.andIn(MysqlUserEntity::getGender, Arrays.asList(GenderEnum.未知, GenderEnum.未知, GenderEnum.未知)); final MysqlUserEntity mysqlUserEntity = BraveSql.build(dynamicSql, MysqlUserEntity.class).selectSingle(); Assert."<AssertPlaceHolder>"; log.info("mysqlUserEntity : {}", mysqlUserEntity); }
selectSingle() throws SQLException, InstantiationException, IllegalAccessException;  List<T> select() throws SQLException, InstantiationException, IllegalAccessException;  /** * 执行聚合函数，已验证5个，分别是 * sum(), avg(), min(), max(),  count() * * @param property     实体类字段名 * @param functionEnum 函数类型 * @param returnType   期待返回的类型 * @return 期待执行的结果 */ <R> R selectAggregateFunction(String property, FunctionEnum functionEnum, Class<R> returnType) throws SQLException;  <K, R> Map<K, R> selectAggregateFunction(String valueProperty, FunctionEnum functionEnum, Class<K> keyClass, Class<R> valueClass, String keyProperty) throws SQLException;  List<T> selectAll() throws SQLException, InstantiationException, IllegalAccessException;  PageInfo<T> selectPageInfo() throws SQLException, InstantiationException, IllegalAccessException;  Integer batchInsert() throws SQLException;  Integer insertActive() throws SQLException;  Integer insertOrUpdate() throws SQLException;  Integer insertOrUpdateActive() throws SQLException;  Integer update() throws SQLException;  Integer updateActive() throws SQLException;  //    Integer updateBatch();  Integer updateByPrimaryKey() throws SQLException;  Integer updateActiveByPrimaryKey() throws SQLException;  Integer delete() throws SQLException;  Integer deleteByPrimaryKey(Object primaryKeyValue) throws SQLException;  default void printSql(String sql) { if (log.isDebugEnabled()) { log.debug(sql); } }
[*] target: assertNotNull(mysqlUserEntity)
[-] pred: org. junit. Assert. assertNotNull ( mysqlUserEntity )
************************************
************************************
[+] input: shouldReturnUpdatedJsonStringForNewNestedKeyValue() { JsonUpdate jsonUpdate = new JsonUpdate(); String jsonEvent = "{"k1":null,"k2":"v2"}"; String expectedJsonEvent = "{"k1":null,"k2":"v2","k3":{"key1":"value1","key2":"value2"}}"; String jPath = "$.k3"; Map<String, String> updateValue = new HashMap<String, String>() {{ put("key1", "value1"); put("key2", "value2"); }}; String actual = jsonUpdate.eval(jsonEvent, jPath, updateValue); Assert."<AssertPlaceHolder>"; }
eval(String jsonEvent, String jPath, @DataTypeHint(inputGroup = InputGroup.ANY) Object newValue) throws PathNotFoundException { Configuration configuration = Configuration.defaultConfiguration().setOptions(Option.DEFAULT_PATH_LEAF_TO_NULL); return JsonPath.using(configuration).parse(jsonEvent).set(JsonPath.compile(jPath), newValue).jsonString(); }
[*] target: assertEquals(expectedJsonEvent, actual)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonEvent, actual )
************************************
************************************
[+] input: shouldReturnNullIfFieldNotInitializedWithAValueInSimpleGroup() { Descriptors.FieldDescriptor fieldDescriptor = TestMessageEnvelope.getDescriptor().findFieldByName("log_key"); /* The field is added to the schema but not assigned a value */ GroupType parquetSchema = org.apache.parquet.schema.Types.requiredGroup() .required(BINARY).named("log_key") .named("TestGroupType"); SimpleGroup simpleGroup = new SimpleGroup(parquetSchema); ByteStringHandler byteStringHandler = new ByteStringHandler(fieldDescriptor);  Object actualValue = byteStringHandler.parseSimpleGroup(simpleGroup);  "<AssertPlaceHolder>"; }
parseSimpleGroup(SimpleGroup simpleGroup) { String fieldName = fieldDescriptor.getName();  /* this if branch checks that the field name exists in the simple group schema and is initialized */ if (SimpleGroupValidation.checkFieldExistsAndIsInitialized(simpleGroup, fieldName)) { byte[] byteArray = simpleGroup.getBinary(fieldName, 0).getBytes(); return ByteString.copyFrom(byteArray); } else { return null; } }
[*] target: assertNull(actualValue)
[-] pred: org. junit. Assert. assertNull ( actualValue )
************************************
************************************
[+] input: shouldReturnEmptyBlackListRetryStatusCodesAsEmptyList() { String inputRetryStatusCodeBlacklist = ""; List<Integer> statusCodesAsList = MongoSinkClientUtil.getStatusCodesAsList(inputRetryStatusCodeBlacklist); "<AssertPlaceHolder>"; }
getStatusCodesAsList(String mongoRetryStatusCodeBlacklist) { try { return Arrays .stream(mongoRetryStatusCodeBlacklist.split(",")) .map(String::trim) .filter(s -> (!s.isEmpty())) .map(Integer::parseInt) .collect(Collectors.toList()); } catch (NumberFormatException e) { throw new IllegalArgumentException("Status code must be an integer"); } }
[*] target: assertEquals(0, statusCodesAsList.size())
[-] pred: org. junit. Assert. assertEquals ( 0, statusCodesAsList. size ( ) )
************************************
************************************
[+] input: testFailureDueToInconsistency() { DBResult openSearchResult = new DBResult( "OpenSearch", asList(new Type("firstname", "text")), asList(new Row(asList("John")))); DBResult otherDbResult = new DBResult( "Other DB", asList(new Type("firstname", "text")), asList(new Row(asList("JOHN")))); when(openSearchConnection.select(anyString())).thenReturn(openSearchResult); when(otherDbConnection.select(anyString())).thenReturn(otherDbResult);  TestReport expected = new TestReport(); expected.addTestCase( new FailedTestCase( 1, "SELECT * FROM accounts", asList(openSearchResult, otherDbResult), "")); TestReport actual = correctnessTest.verify(querySet("SELECT * FROM accounts")); "<AssertPlaceHolder>"; }
verify(TestQuerySet querySet) { TestReport report = new TestReport(); for (String sql : querySet) { try { DBResult openSearchResult = thisConnection.select(sql); report.addTestCase(compareWithOtherDb(sql, openSearchResult)); } catch (Exception e) { report.addTestCase( new ErrorTestCase( nextId(), sql, StringUtils.format("%s: %s", e.getClass().getSimpleName(), extractRootCause(e)))); } } return report; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testAddInvalidNegativeWeight() { RandomCollection<Integer> rc = new RandomCollection<>(random);  boolean thrown = false; try { rc.add(-0.0001, 894); } catch (IllegalArgumentException e) { thrown = true; } "<AssertPlaceHolder>";  }
add(double weight, E result) { if (weight <= 0) { throw new IllegalArgumentException("Cannot add negative weight (" + weight + ") to random collection."); } total += weight; map.put(total, result); }
[*] target: assertTrue(thrown)
[-] pred: org. junit. Assert. assertTrue ( thrown )
************************************
************************************
[+] input: Exception { Future<Long> future = Mockito.mock(Future.class); LocalFileMetadata localFileMetadata = Mockito.mock(LocalFileMetadata.class); FirehoseInstrumentation firehoseInstrumentation = Mockito.mock(FirehoseInstrumentation.class); BlobStorageWriterFutureHandler handler = new BlobStorageWriterFutureHandler(future, localFileMetadata, firehoseInstrumentation); Mockito.when(future.isDone()).thenReturn(true); Mockito.when(future.get()).thenReturn(1000L); Mockito.when(localFileMetadata.getFullPath()).thenReturn("/tmp/test"); Mockito.when(localFileMetadata.getSize()).thenReturn(1024L); Assert."<AssertPlaceHolder>"; Mockito.verify(firehoseInstrumentation, Mockito.times(1)).logInfo("Flushed to blob storage {}", "/tmp/test"); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).incrementCounter(BlobStorageMetrics.FILE_UPLOAD_TOTAL, Metrics.SUCCESS_TAG); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureCount(BlobStorageMetrics.FILE_UPLOAD_BYTES, 1024L); Mockito.verify(firehoseInstrumentation, Mockito.times(1)).captureDuration(BlobStorageMetrics.FILE_UPLOAD_TIME_MILLISECONDS, 1000L); }
isFinished() { if (!future.isDone()) { return false; } try { long totalTime = future.get(); captureFileUploadSuccessMetric(totalTime); return true; } catch (InterruptedException e) { captureUploadFailedMetric(e); throw new BlobStorageFailedException(e); } catch (ExecutionException e) { captureUploadFailedMetric(e.getCause()); throw new BlobStorageFailedException(e.getCause()); } }
[*] target: assertTrue(handler.isFinished())
[-] pred: org. junit. Assert. assertTrue ( handler. isFinished() )
************************************
************************************
[+] input: testLazyString() { String value = "TEN"; subject = makeSimpleCallable(value);  "<AssertPlaceHolder>"; }
value() { eval(); Object value = internalValue.get(); if (value == ACTUALLY_NULL) { return null; } return value; }
[*] target: assertEquals(value, subject.value())
[-] pred: org. junit. Assert. assertEquals ( value, subject. value() )
************************************
************************************
[+] input: rtspTeardownRequestTest() { String expect = "TEARDOWN rtsp://10.3.8.202:554/ RTSP/1.0\r\n" + "CSeq: 0\r\n" + "Authorization: Digest username="admin", realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", uri="rtsp://10.3.8.202:554", response="56d55b92e8b41aa6cc1a68a5c2e2de15"\r\n" + "User-Agent: IOT-COMMUNICATION\r\n" + "Session: 1273222592\r\n" + "\r\n"; URI uri = URI.create("rtsp://10.3.8.202:554/"); RtspTeardownRequest request = new RtspTeardownRequest(uri, "1273222592", this.authenticator); request.setCSeq(0); String actual = request.toObjectString(); "<AssertPlaceHolder>"; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { when(redisTemplate.execute(any(RedisCallback.class))).thenAnswer( invocation -> Boolean.TRUE ); Boolean result = redisCache.hmdel("key", Arrays.asList("String")); Assert."<AssertPlaceHolder>"; }
hmdel(String key, List<String> fields) throws DataAccessException { if (isBlank(key) || CollectionUtils.isEmpty(fields)) { return Boolean.FALSE; } String keyString = keyPrefix.concat(key); return redisTemplate.execute( (RedisConnection connection) -> { byte[] keyb = keyString.getBytes(); byte[][] fieldsb = new byte[fields.size()][]; int i = 0; for (String f : fields) { fieldsb[i++] = f.getBytes(); } connection.hDel(keyb, fieldsb); return Boolean.TRUE; }); }
[*] target: assertEquals(Boolean.TRUE, result)
[-] pred: org. junit. Assert. assertEquals ( Boolean. TRUE, result )
************************************
************************************
[+] input: testGet() { try { String result = PoolHttpClient.get("https://www.baidu.com/"); Assert."<AssertPlaceHolder>"; } catch (Exception e) { fail("Unexpect an exception: " + e.getMessage()); } }
get(String url) throws IOException { try { return get(url, null); } catch (Exception e) { throw new IOException(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { DataSource dataSource = dataSourceFactory.createDataSource(null); Assert."<AssertPlaceHolder>"; }
createDataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); if (props.containsKey(JDBC_INITIAL_POOL_SIZE) || props.containsKey(JDBC_MIN_POOL_SIZE) || props.containsKey(JDBC_MAX_POOL_SIZE) || props.containsKey(JDBC_MAX_IDLE_TIME) || props.containsKey(JDBC_MAX_STATEMENTS)) { return createPoolingDataSource(props); } else { return createSimpleDataSource(props); } }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: testNoElasticLogsBackend() { ElasticBackend elasticBackend = new ElasticBackend(); elasticBackend.setElasticLogsBackend(new NoElasticLogsBackend()); Map<String, String> actual = elasticBackend.getOtelConfigurationProperties(); Map<String, String> expected = Collections.emptyMap(); Assert."<AssertPlaceHolder>"; }
getOtelConfigurationProperties() { // FIXME related to https://github.com/jenkinsci/opentelemetry-plugin/issues/683 if (elasticLogsBackend == null) { return Collections.emptyMap(); } else { return elasticLogsBackend.getOtelConfigurationProperties(); } }
[*] target: assertEquals(actual, expected)
[-] pred: org. junit. Assert. assertEquals ( actual, expected )
************************************
************************************
[+] input: shouldReturnEmptyArrayListWhenBulkResponseExecutedSuccessfully() { MongoSinkClient mongoSinkClient = new MongoSinkClient(mongoCollection, firehoseInstrumentation, mongoRetryStatusCodeBlacklist, mongoClient, mongoSinkConfig); when(mongoCollection.bulkWrite(request)).thenReturn(new BulkWriteResultMock(true, 1, 1, 0)); List<BulkWriteError> nonBlacklistedErrors = mongoSinkClient.processRequest(request); Assert."<AssertPlaceHolder>"; }
processRequest(List<WriteModel<Document>> request) {  try { logResults(mongoCollection.bulkWrite(request), request.size()); return Collections.emptyList(); } catch (MongoBulkWriteException writeException) { firehoseInstrumentation.logWarn("Bulk request failed"); List<BulkWriteError> writeErrors = writeException.getWriteErrors();  logErrors(writeErrors); return writeErrors.stream() .filter(writeError -> !mongoRetryStatusCodeBlacklist.contains(writeError.getCode())) .collect(Collectors.toList()); } }
[*] target: assertEquals(0, nonBlacklistedErrors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, nonBlacklistedErrors. size ( ) )
************************************
************************************
[+] input: mp4MdhdBox() { byte[] expect = new byte[]{ 0x00, 0x00, 0x00, 0x20, 0x6D, 0x64, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x5F, (byte) 0x90, 0x00, 0x01, 0x5F, (byte) 0x90, 0x55, (byte) 0xC4, 0x00, 0x00, }; Mp4MdhdBox box = new Mp4MdhdBox(this.trackInfo); "<AssertPlaceHolder>"; }
toByteArray() { int size = this.byteArrayLength(); ByteWriteBuff buff = ByteWriteBuff.newInstance(size) .putInteger(size) .putBytes(this.mp4Type.getByteArray()) .putBytes(this.mvhdBox.toByteArray()); this.trakBoxes.forEach(x -> buff.putBytes(x.toByteArray())); buff.putBytes(this.mvexBox.toByteArray()); return buff.getData(); }
[*] target: assertArrayEquals(expect, box.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( expect, box. toByteArray ( ) )
************************************
************************************
[+] input: Exception { List<Long> tablets1 = new ArrayList<>(); tablets1.add(1L); tablets1.add(2L); List<Long> tablets2 = new ArrayList<>(); tablets2.add(3L); tablets2.add(4L); Map<String, List<Long>> beToTablets = new HashMap<>(); beToTablets.put("be1", tablets1); beToTablets.put("be2", tablets2);  Settings settings = new PropertiesSettings(); String opaquedQueryPlan = "query_plan"; String cluster = "c"; String database = "d"; String table = "t";  Set<Long> be1Tablet = new HashSet<>(); be1Tablet.add(1L); be1Tablet.add(2L); PartitionDefinition pd1 = new PartitionDefinition( database, table, settings, "be1", be1Tablet, opaquedQueryPlan);  Set<Long> be2Tablet = new HashSet<>(); be2Tablet.add(3L); be2Tablet.add(4L); PartitionDefinition pd2 = new PartitionDefinition( database, table, settings, "be2", be2Tablet, opaquedQueryPlan);  List<PartitionDefinition> expected = new ArrayList<>(); expected.add(pd1); expected.add(pd2); Collections.sort(expected);  List<PartitionDefinition> actual = RestService.tabletsMapToPartition( settings, beToTablets, opaquedQueryPlan, database, table, logger); Collections.sort(actual);  Assert."<AssertPlaceHolder>"; }
tabletsMapToPartition(Settings cfg, Map<String, List<Long>> be2Tablets, String opaquedQueryPlan, String database, String table, Logger logger) throws IllegalArgumentException { int tabletsSize = tabletCountLimitForOnePartition(cfg, logger); List<PartitionDefinition> partitions = new ArrayList<>(); for (Map.Entry<String, List<Long>> beInfo : be2Tablets.entrySet()) { logger.debug("Generate partition with beInfo: '{}'.", beInfo); HashSet<Long> tabletSet = new HashSet<>(beInfo.getValue()); beInfo.getValue().clear(); beInfo.getValue().addAll(tabletSet); int first = 0; while (first < beInfo.getValue().size()) { Set<Long> partitionTablets = new HashSet<>(beInfo.getValue().subList( first, Math.min(beInfo.getValue().size(), first + tabletsSize))); first = first + tabletsSize; PartitionDefinition partitionDefinition = new PartitionDefinition(database, table, cfg, beInfo.getKey(), partitionTablets, opaquedQueryPlan); logger.debug("Generate one PartitionDefinition '{}'.", partitionDefinition); partitions.add(partitionDefinition); } } return partitions; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldRemoveSpacesBeforeCommentSymbol() { //given String expectedString = "SELECT" + lineBreak + "\t*" + lineBreak + "FROM" + lineBreak + "\ttable1;" + lineBreak + "-- SELECT * FROM mytable;"; String inputString = "SELECT" + lineBreak + "\t*" + lineBreak + "FROM" + lineBreak + "\ttable1;" + lineBreak +" -- SELECT * FROM mytable;";  //when String formattedString = formatter.format(inputString, configuration);  //then "<AssertPlaceHolder>"; }
format(final String argSql, SQLFormatterConfiguration configuration) { formatterCfg = configuration;  for (String delim : formatterCfg.getSyntaxManager().getStatementDelimiters()) { statementDelimiters.add(delim.toUpperCase(Locale.ENGLISH)); }  SQLTokensParser fParser = new SQLTokensParser(formatterCfg);  boolean isSqlEndsWithNewLine = false; if (argSql.endsWith("\n")) { //$NON-NLS-1$ isSqlEndsWithNewLine = true; }  List<FormatterToken> list = fParser.parse(argSql); list = format(list);  StringBuilder after = new StringBuilder(argSql.length() + 20); for (FormatterToken token : list) { after.append(token.getString()); }  if (isSqlEndsWithNewLine) { after.append(GeneralUtils.getDefaultLineSeparator()); }  return after.toString(); }
[*] target: assertEquals(expectedString, formattedString)
[-] pred: org. junit. Assert. assertEquals ( expectedString, formattedString )
************************************
************************************
[+] input: testUpdateFreeSpace() { createPageDirectory((short) 10);  short pageSize = (short) (pageDirectory.getEffectivePageSize() - 10); Page p1 = pageDirectory.getPageWithSpace(pageSize); p1.unpin();  pageDirectory.updateFreeSpace(p1, (short) 10);  Page p2 = pageDirectory.getPageWithSpace((short) 10); p2.unpin();  "<AssertPlaceHolder>"; }
getPageWithSpace(short requiredSpace) { if (requiredSpace <= 0) { throw new IllegalArgumentException("cannot request nonpositive amount of space"); } if (requiredSpace > EFFECTIVE_PAGE_SIZE - emptyPageMetadataSize) { throw new IllegalArgumentException("requesting page with more space than the size of the page"); }  Page page = this.firstHeader.loadPageWithSpace(requiredSpace); LockContext pageContext = lockContext.childContext(page.getPageNum()); // TODO(proj4_part2): Update the following line LockUtil.ensureSufficientLockHeld(pageContext, LockType.NL);  return new DataPage(pageDirectoryId, page); }
[*] target: assertEquals(p1, p2)
[-] pred: org. junit. Assert. assertEquals ( p1, p2 )
************************************
************************************

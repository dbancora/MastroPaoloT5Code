[+] input: itShouldAccumulateProperly() { Duration smoothingWindow = Duration.ofSeconds(10); long currentTimestamp = 0; ValueStats valueStats_1 = ValueStats.create(smoothingWindow); ValueStats valueStats_2 = ValueStats.create(smoothingWindow); int inputValue_1 = 5; int inputValue_2 = 10; int iterations = 1000;  for (int i = 0; i < iterations; i++) { valueStats_1.recordValue(inputValue_1); valueStats_2.recordValue(inputValue_2); currentTimestamp += ONE_SECOND_IN_MILLIS; valueStats_1.refresh(currentTimestamp); valueStats_2.refresh(currentTimestamp); }  ValueStats accumulator = ValueStats.createAccumulator(); accumulator.add(valueStats_1); accumulator.add(valueStats_2);  double acceptableError = 10E-5; double expectedAccumulatedSmoothedAvg = (5 + 10) / 2.0; "<AssertPlaceHolder>"; }
getSmoothedAverage() { if (totalCount == 0) { return 0.0; }  return smoothedSum / smoothedCount; }
[*] target: assertEquals(expectedAccumulatedSmoothedAvg, accumulator.getSmoothedAverage(), acceptableError)
[-] pred: org. junit. Assert. assertEquals ( expectedAccumulatedSmoothedAvg, accumulator. getSmoothedAverage ( ), acceptableError )
************************************
************************************
[+] input: IOException { Map<String, FileMetadata> before = client.list("**");  Path tempDir = storagePath.resolve(DEFAULT_TEMP_DIR); Files.createDirectories(tempDir); Files.write(tempDir.resolve("systemFile.txt"), "test data".getBytes()); Path folder = tempDir.resolve("folder"); Files.createDirectories(folder); Files.write(folder.resolve("systemFile2.txt"), "test data".getBytes());  Map<String, FileMetadata> after = client.list("**");  "<AssertPlaceHolder>"; }
list(String glob) throws IOException { checkStarted(); if (glob.isEmpty()) return Map.of();  String subdir = extractSubDir(glob); Path subdirectory = resolve(subdir); String subglob = glob.substring(subdir.length());  return findMatching(tempDir, subglob, subdirectory).stream() .collect(Collector.of( (Supplier<Map<String, FileMetadata>>) HashMap::new, uncheckedOf((map, path) -> { FileMetadata metadata = toFileMetadata(path); if (metadata != null) { String filename = TO_REMOTE_NAME.apply(storage.relativize(path).toString()); map.put(filename, metadata); } }), noMergeFunction()) ); }
[*] target: assertEquals(before, after)
[-] pred: org. junit. Assert. assertEquals ( before, after )
************************************
************************************
[+] input: InterruptedException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); eventloopExecutor.execute(() -> actual.add(finalI)); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>"; }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ExecutionException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); eventloopExecutor.submit(() -> actual.add(finalI)).get(); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>"; }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: InterruptedException { int limit = 10; BlockingReactorExecutor eventloopExecutor = BlockingReactorExecutor.create(eventloop, limit); eventloop.keepAlive(true); Thread eventloopThread = new Thread(eventloop); eventloopThread.start();  List<Integer> actual = new ArrayList<>(); List<Integer> expected = new ArrayList<>();  for (int i = 0; i < 20; i++) { int finalI = i; expected.add(i); Integer actualI = eventloopExecutor.<Integer>submit(() -> cb -> cb.accept(finalI, null)).get(); actual.add(actualI); }  eventloopExecutor.execute(() -> eventloop.keepAlive(false));  eventloopThread.join();  "<AssertPlaceHolder>";  }
execute(Runnable runnable) { try { post(() -> { try { runnable.run(); } finally { complete(); } }); } catch (InterruptedException ignored) { Thread.currentThread().interrupt(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { AsyncServlet servlet = request -> request.loadBody(Integer.MAX_VALUE) .then(body -> HttpResponse.ok200().withBody(body.slice()).toPromise()); Exception exception = new Exception("TestException");  ByteBuf byteBuf = ByteBufPool.allocate(100); byteBuf.put("Test1".getBytes(UTF_8));  HttpRequest testRequest = HttpRequest.post("http://example.com") .withBodyStream(ChannelSuppliers.concat( ChannelSuppliers.ofValue(byteBuf), ChannelSuppliers.ofException(exception) )) .build();  Exception e = awaitException(servlet.serve(testRequest));  "<AssertPlaceHolder>"; }
serve(HttpRequest request) throws Exception;  /** * Wraps given {@link BlockingServlet}
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: testRenderAcceptContentType() { String expected = "text/html, application/xhtml+xml, application/xml; q=0.9, image/webp, */*; q=0.8"; ByteBuf buf = ByteBuf.wrapForWriting(new byte[expected.length()]); List<AcceptMediaType> acts = new ArrayList<>(); acts.add(AcceptMediaType.of(HTML)); acts.add(AcceptMediaType.of(XHTML_APP)); acts.add(AcceptMediaType.of(MediaTypes.XML_APP, 90)); acts.add(AcceptMediaType.of(WEBP)); acts.add(AcceptMediaType.of(MediaTypes.ANY, 80)); AcceptMediaType.render(acts, buf); String actual = asAscii(buf); "<AssertPlaceHolder>"; }
render(ContentType type, ByteBuf buf) { int pos = render(type, buf.array(), buf.tail()); buf.tail(pos); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test() { BinarySerializer<ExternalClass> serializer = SerializerFactory.builder() .with(ExternalComponent.class, ctx -> new SimpleSerializerDef<ExternalComponent>() { @Override protected BinarySerializer<ExternalComponent> createSerializer(int version, CompatibilityLevel compatibilityLevel) { return new BinarySerializer<>() { @Override public void encode(BinaryOutput out, ExternalComponent item) { out.writeVarInt(item.getX()); out.writeUTF8(item.getY()); }  @Override public ExternalComponent decode(BinaryInput in) throws CorruptedDataException { int x = in.readVarInt(); String y = in.readUTF8();  return new ExternalComponent(x, y); } }; } }) .build() .create(DEFINING_CLASS_LOADER, ExternalClass.class);  ExternalClass original = new ExternalClass( "test", new ExternalComponent( 123, "inner test 1" ), new ExternalComponent( 456, "inner test 2" ) );  ExternalClass copy = doTest(original, serializer);  "<AssertPlaceHolder>"; }
createSerializer(int version, CompatibilityLevel compatibilityLevel);  public final Class<T> getEncodeType() { return encodeType; }
[*] target: assertEquals(original, copy)
[-] pred: org. junit. Assert. assertEquals ( original, copy )
************************************
************************************
[+] input: IOException { Reactor reactor = Reactor.getCurrentReactor(); Path storageDir = temporaryFolder.newFolder().toPath(); FileSystem fs = FileSystem.create(reactor, newCachedThreadPool(), storageDir); await(fs.start()); IAggregationChunkStorage aggregationChunkStorage = AggregationChunkStorage.create( reactor, stubChunkIdGenerator(), FrameFormats.lz4(), fs);  int nChunks = 100; AggregationChunker<KeyValuePair> chunker = AggregationChunker.create( structure, structure.getMeasures(), KeyValuePair.class, singlePartition(), aggregationChunkStorage, classLoader, 1);  Set<Path> expected = IntStream.range(0, nChunks).mapToObj(i -> Paths.get((i + 1) + AggregationChunkStorage.LOG)).collect(toSet());  Random random = ThreadLocalRandom.current(); StreamSupplier<KeyValuePair> supplier = StreamSuppliers.ofStream( Stream.generate(() -> new KeyValuePair(random.nextInt(), random.nextInt(), random.nextLong())) .limit(nChunks));  List<Path> paths = await(supplier.streamTo(chunker) .then(chunker::getResult) .then(protoAggregationChunks -> aggregationChunkStorage.finish(protoAggregationChunks.stream() .map(ProtoAggregationChunk::protoChunkId) .collect(toSet()))) .map($ -> { try (Stream<Path> list = Files.list(storageDir)) { return list.filter(path -> path.toString().endsWith(AggregationChunkStorage.LOG)).collect(toList()); } catch (IOException e) { throw new AssertionError(e); } }));  Set<Path> actual = paths.stream().filter(Files::isRegularFile).map(Path::getFileName).collect(toSet());  "<AssertPlaceHolder>"; }
finish(Set<String> protoChunkIds) { checkInReactorThread(this); return idGenerator.convertToActualChunkIds(protoChunkIds) .mapException(e -> new AggregationException("Failed to convert to actual chunk IDs: " + Utils.toString(protoChunkIds), e)) .then(chunkIds -> { Map<String, String> renameMap = chunkIds.entrySet().stream() .collect(toMap(e -> toTempPath(e.getKey()), e -> toPath(e.getValue()))); return fileSystem.moveAll(renameMap) .mapException(e -> new AggregationException("Failed to finalize chunks: " + Utils.toString(protoChunkIds), e)) .map($ -> chunkIds); }) .whenResult(() -> finishChunks = protoChunkIds.size()) .whenComplete(promiseFinishChunks.recordStats()); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { manager.saveDiff(100, 10L, 25, 1L);  int integer = manager.loadDiff(25, 1L, 10L); "<AssertPlaceHolder>"; }
loadDiff(T state, Long revisionFrom, Long revisionTo) throws IOException { T loaded = tryLoadDiff(state, revisionFrom, revisionTo); if (loaded == null) { throw new IOException("Cannot find diffs between revision " + revisionFrom + " and " + revisionTo); } return loaded; }
[*] target: assertEquals(100, integer)
[-] pred: org. junit. Assert. assertEquals ( 100, integer )
************************************
************************************
[+] input: testEmptyList() { DynamicArray<Integer> list = new DynamicArray<>(); "<AssertPlaceHolder>"; }
isEmpty() { // YOUR CODE HERE return false; }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: IOException { try (StringWriter writer = new StringWriter()) { List<String[]> records = new ArrayList<String[]>() {{ add(new String[]{"1", "apple", "10", "9.99"}); add(new String[]{"2", "orange", "5", "4.99"}); }}; String expected = "1,apple,10,9.99\n2,orange,5,4.99"; new CsvWriter(writer).addLines(records); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLines(@NonNull Collection<String[]> lines) throws IOException { addLines(lines, false); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { try (StringWriter writer = new StringWriter()) { String expected = "1,apple,10,9.99"; CsvWriter csvWriter = new CsvWriter(writer); csvWriter.addField("1"); csvWriter.addField("apple"); csvWriter.addField("10"); csvWriter.addField("9.99"); csvWriter.addLine(); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLine() { initIfNotAlready(); checkFieldCountSame(); mCurrentFieldCount = 0; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { try (StringWriter writer = new StringWriter()) { String expected = "1,apple,10,9.99\n2,orange,5,4.99"; CsvWriter csvWriter = new CsvWriter(writer); csvWriter.addField("1"); csvWriter.addField("apple"); csvWriter.addField("10"); csvWriter.addField("9.99"); csvWriter.addLine(); csvWriter.addField("2"); csvWriter.addField("orange"); csvWriter.addField("5"); csvWriter.addField("4.99"); csvWriter.addLine(); String result = writer.toString(); "<AssertPlaceHolder>"; } }
addLine() { initIfNotAlready(); checkFieldCountSame(); mCurrentFieldCount = 0; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: IOException { List<Path> pathList = new ArrayList<>(); assert classLoader != null; pathList.add(Paths.get(classLoader.getResource("AppManager_v2.5.22.apks.tar.0").getFile())); pathList.add(Paths.get(classLoader.getResource("AppManager_v2.5.22.apks.tar.1").getFile()));  // Always run tests using SplitInputStream try (SplitInputStream sis = new SplitInputStream(pathList); BufferedInputStream bis = new BufferedInputStream(sis); TarArchiveInputStream tis = new TarArchiveInputStream(bis)) { ArchiveEntry entry; while ((entry = tis.getNextEntry()) != null) { // create a new path, remember check zip slip attack File file = new File("/tmp", entry.getName()); // copy TarArchiveInputStream to newPath try (OutputStream os = Paths.get(file).openOutputStream()) { IoUtils.copy(tis, os); } } }  // Check integrity List<String> expectedHashes = new ArrayList<>(); List<File> fileList = new ArrayList<>(); fileList.add(new File(classLoader.getResource("AppManager_v2.5.22.apks.0").getFile())); fileList.add(new File(classLoader.getResource("AppManager_v2.5.22.apks.1").getFile())); for (File file : fileList) { expectedHashes.add(DigestUtils.getHexDigest(DigestUtils.SHA_256, file)); } List<String> actualHashes = new ArrayList<>(); fileList.clear(); fileList.add(new File("/tmp/AppManager_v2.5.22.apks.0")); fileList.add(new File("/tmp/AppManager_v2.5.22.apks.1")); for (File file : fileList) { if (!file.exists()) { throw new FileNotFoundException(file + " does not exist."); } actualHashes.add(DigestUtils.getHexDigest(DigestUtils.SHA_256, file)); junkFiles.add(file); } "<AssertPlaceHolder>"; }
getNextEntry() throws IOException { return getNextTarEntry(); }
[*] target: assertEquals(expectedHashes, actualHashes)
[-] pred: org. junit. Assert. assertEquals ( expectedHashes, actualHashes )
************************************
************************************
[+] input: testNullPlot() { double[] nums = new double[]{2710, 2755}; BoxPlot plot = BoxPlotUtil.plot(nums); TestCase."<AssertPlaceHolder>"; }
plot(double[] data) { List<Double> collect = Arrays.stream(data).boxed().sorted().collect(Collectors.toList()); data = collect.stream().mapToDouble(i -> i).toArray(); if (data.length <= 2) { return null; }  double max; double q3; double median; double q1; double min; double iqr; if (data.length % 2 == 0) { median = (data[(data.length) / 2 - 1] + data[(data.length) / 2]) / 2; q1 = (data[(data.length) / 4 - 1] + data[(data.length) / 4]) / 2; q3 = (data[((data.length) * 3) / 4 - 1] + data[((data.length) * 3) / 4]) / 2; } else { median = data[(data.length) / 2]; q1 = data[(data.length) / 4]; q3 = data[(data.length * 3) / 4]; } max = data[data.length - 1]; min = data[0]; iqr = q3 - q1;  double maxRegion = q3 + 1.5 * iqr; double minRegion = q1 - 1.5 * iqr;  BoxPlot box = new BoxPlot(); box.setMaxRegion(maxRegion); box.setMax(max); box.setQ3(q3); box.setMedian(median); box.setQ1(q1); box.setMin(min); box.setMinRegion(minRegion); box.setIqr(iqr); return box; }
[*] target: assertNull(plot)
[-] pred: org. junit. Assert. assertNull ( plot )
************************************
************************************
[+] input: Exception { OutgoingSessionRecord sessionRecord = new OutgoingSessionRecord();  expectCheckForOrphans(); manager.eventOccurred(new TransportActiveEvent(ID));  context.checking(new Expectations() {{ oneOf(pluginManager).getPlugin(ID); will(returnValue(plugin)); oneOf(plugin).createWriter(with(any(TransportProperties.class))); will(returnValue(transportConnectionWriter)); oneOf(transportConnectionWriter).dispose(false); oneOf(connectionManager).manageOutgoingConnection(with(contactId), with(ID), with(any(TransportConnectionWriter.class)), with(sessionRecord)); // The session succeeds. We need to use an action for this, as // createAndWriteTempFileForUpload() waits for it to happen before // returning will(new ConsumeArgumentAction<>(TransportConnectionWriter.class, 2, writer -> { try { writer.dispose(false); } catch (IOException e) { fail(); } } )); }});  File f = manager.createAndWriteTempFileForUpload(contactId, sessionRecord); "<AssertPlaceHolder>"; }
createAndWriteTempFileForUpload(ContactId contactId, OutgoingSessionRecord sessionRecord) throws IOException { File f = createTempFile(UPLOAD_DIR_NAME); // We shouldn't reach this point until the plugin has been started SimplexPlugin plugin = (SimplexPlugin) requireNonNull(pluginManager.getPlugin(ID)); TransportProperties p = new TransportProperties(); p.put(PROP_PATH, f.getAbsolutePath()); TransportConnectionWriter writer = plugin.createWriter(p); if (writer == null) { delete(f); throw new IOException(); } MailboxFileWriter decorated = new MailboxFileWriter(writer); LOG.info("Writing file for upload"); connectionManager.manageOutgoingConnection(contactId, ID, decorated, sessionRecord); if (decorated.awaitDisposal()) { // An exception was thrown during the session - delete the file delete(f); throw new IOException(); } return f; }
[*] target: assertTrue(f.exists())
[-] pred: org. junit. Assert. assertTrue ( f. exists ( ) )
************************************
************************************
[+] input: testEmoji() { String webInsert = "{"emoji":"100"}"; String mobileExpected = "{"insert":"\uD83D\uDCAF"}"; LinkedHashMap emojiMap = GSON.fromJson(webInsert, LinkedHashMap.class); String res = GSON.toJson(DeltaConverter.WebToMobile.webToMobileEmoji(emojiMap)); Assert."<AssertPlaceHolder>"; }
webToMobileEmoji(Map insertMap) { LinkedHashMap mobileElement = new LinkedHashMap(); String val = (String) insertMap.get("emoji"); LOGGER.info(" webToMobileEmoji val=" + val); mobileElement.put("insert", EmojiConverter.nameToSurrogatePair(val).get()); return mobileElement; }
[*] target: assertEquals(mobileExpected, res)
[-] pred: org. junit. Assert. assertEquals ( mobileExpected, res )
************************************
************************************
[+] input: canCreateAMiss() { CacheGetResult<Object> miss = CacheGetResult.miss(); "<AssertPlaceHolder>"; }
miss() { return CacheGetResultImpl.getMiss(); }
[*] target: assertNotNull(miss)
[-] pred: org. junit. Assert. assertNotNull ( miss )
************************************
************************************
[+] input: canScanForMigrationChain() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA1.class); expectedClasses.add(MigrationA2.class); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred: org. junit. Assert. assertEquals ( expectedClasses, actualClasses )
************************************
************************************
[+] input: canLimitMigrationChainArbitrarilyBetweenVersions() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); chain = chain.startingAt(ChronosVersion.parse("0.6.0")); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred: org. junit. Assert. assertEquals ( expectedClasses, actualClasses )
************************************
************************************
[+] input: canLimitMigrationChainPreciselyAtVersion() { MigrationChain<ChronoDBInternal> chain = MigrationChain.fromPackage("org.chronos.chronodb.test.cases.migration.chainA"); chain = chain.startingAt(ChronosVersion.parse("0.5.1")); List<Class<? extends ChronosMigration<ChronoDBInternal>>> actualClasses = chain.getMigrationClasses(); List<Class<? extends ChronosMigration<ChronoDBInternal>>> expectedClasses = Lists.newArrayList(); expectedClasses.add(MigrationA2.class); expectedClasses.add(MigrationA3.class); "<AssertPlaceHolder>"; }
getMigrationClasses();  /** * Produces a sub-migration-chain from this instance by limiting the migration classes to the ones starting at or after the given version (inclusive). * * @param from *            The minimal chronos version to be migrated from in the result chain (inclusive). Must not be <code>null</code>. * @return The new migration chain with the limited scope. Never <code>null</code>, may be empty. */ public MigrationChain<DBTYPE> startingAt(ChronosVersion from);  /** * Executes this migration chain on the given {@link ChronoDBInternal ChronoDB}
[*] target: assertEquals(expectedClasses, actualClasses)
[-] pred: org. junit. Assert. assertEquals ( expectedClasses, actualClasses )
************************************
************************************
[+] input: testNoMatchTransitWithResult() { Map<States, State<States, Events>> stateMap = new HashMap<>(); Transition<States, Events> newTransition = new TransitionImpl<>(); newTransition.setSource(StateHelper.getState(stateMap,States.STATE1)); newTransition.setTarget(StateHelper.getState(stateMap,States.STATE2)); newTransition.setEvent(Events.EVENT1); newTransition.setType(TransitionType.EXTERNAL); newTransition.setCondition(context -> false); Object result = newTransition.transitWithResult(new Object(), true); Assert."<AssertPlaceHolder>"; }
transitWithResult(C request, boolean checkCondition);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: IOException { ClassLoader classLoader = this.getClass().getClassLoader(); URL resource = classLoader.getResource("test.json"); File f = new File(resource.getPath()); String s = readString(f); StructuredDataEncoder structuredData = new StructuredDataEncoder(s); byte[] msgHash = structuredData.hashStructuredData(); String ownerAddress = "0xE10AA6471B33845FaE88DD7bBeB63c250DA3a639"; String sig = "4f4e0dec5f1d6f99460fea04bc374d96a495d96c0c455d4731902cdbf95525fc77c66ee08346466fe188f521c196f0f06bebb8d1a8df44cb68792514ca24808e2a"; byte[] signatureBytes = Hex.decode(sig); byte v = signatureBytes[64]; Sign.SignatureData sd = new Sign.SignatureData( v, Arrays.copyOfRange(signatureBytes, 0, 32), Arrays.copyOfRange(signatureBytes, 32, 64));  boolean verified = false; for (int i = 0; i < 4; i++) { BigInteger publicKey = Sign.recoverFromSignature( (byte) i, new ECDSASignature( new BigInteger(1, sd.getR()), new BigInteger(1, sd.getS())), msgHash);  if (publicKey != null) { String addressRecovered = Keys.toChecksumAddress(Keys.getAddress(publicKey)); if (addressRecovered.equals(ownerAddress)) { verified = true; break; } } } "<AssertPlaceHolder>"; }
getAddress(byte[] publicKey) { byte[] hash = new Keccak.Digest256().digest(publicKey); return Arrays.copyOfRange(hash, hash.length - 20, hash.length);  // right most 160 bits }
[*] target: assertTrue(verified)
[-] pred: org. junit. Assert. assertTrue ( verified )
************************************
************************************
[+] input: sizeObject_Empty_0() { JsonMetadataView view = new JsonMetadataView(new JsonObject(), String::compareTo); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, view.size())
[-] pred: org. junit. Assert. assertEquals ( 0, view. size() )
************************************
************************************
[+] input: sizeArray_Empty_0() { JsonMetadataView view = new JsonMetadataView(new JsonArray()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, view.size())
[-] pred: org. junit. Assert. assertEquals ( 0, view. size() )
************************************
************************************
[+] input: list_NoneMatchNamespace_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "other", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: list_NoneMatchPathStart_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "other", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: list_EmptyNamespace_NoExceptionIfOriginalAccepts() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: list_NoneMatchFilter_NoneFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "textures", (file) -> file.endsWith(".jpg"));  "<AssertPlaceHolder>"; }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(0, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 0, resources. size ( ) )
************************************
************************************
[+] input: listResources_PathStartDifferent_NoMatches() { List<ResourceCollection> collections = new ArrayList<>(); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/one.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("texture/two.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("text/three.png"))));  OrderedResourceRepository repository = new OrderedResourceRepository(PackType.CLIENT_RESOURCES, collections);  Collection<ResourceLocation> results = repository.list("ext", (file) -> true); "<AssertPlaceHolder>"; }
list(String pathStart, Predicate<String> fileFilter) { requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "Path filter cannot be null");  return COLLECTIONS.stream().flatMap( (collection) -> collection.namespaces(RESOURCE_TYPE).stream().flatMap( (namespace) -> collection.list(RESOURCE_TYPE, namespace, pathStart, fileFilter).stream() ) ).collect(Collectors.toSet()); }
[*] target: assertEquals(0, results.size())
[-] pred: org. junit. Assert. assertEquals ( 0, results. size ( ) )
************************************
************************************
[+] input: listResources_FilterNoMatch_NoMatches() { List<ResourceCollection> collections = new ArrayList<>(); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/one.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/two.png")))); collections.add(new MockResourceCollection(Set.of(ResourceLocation.parse("textures/three.png"))));  OrderedResourceRepository repository = new OrderedResourceRepository(PackType.CLIENT_RESOURCES, collections);  Collection<ResourceLocation> results = repository.list("textures", (file) -> file.endsWith(".jpg")); "<AssertPlaceHolder>"; }
list(String pathStart, Predicate<String> fileFilter) { requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "Path filter cannot be null");  return COLLECTIONS.stream().flatMap( (collection) -> collection.namespaces(RESOURCE_TYPE).stream().flatMap( (namespace) -> collection.list(RESOURCE_TYPE, namespace, pathStart, fileFilter).stream() ) ).collect(Collectors.toSet()); }
[*] target: assertEquals(0, results.size())
[-] pred: org. junit. Assert. assertEquals ( 0, results. size ( ) )
************************************
************************************
[+] input: width_WidthProvided_SameWidthReturned() { CloseableImageFrame frame = new CloseableImageFrame( new FrameReader.FrameData(100, 200, 0, 0), ImmutableList.of(new MockCloseableImage(100, 200)), 1 );  "<AssertPlaceHolder>"; }
width() { checkOpen(); return WIDTH; }
[*] target: assertEquals(100, frame.width())
[-] pred: org. junit. Assert. assertEquals ( 100, frame. width() )
************************************
************************************
[+] input: runTest() { final String key = "test key"; final String plainText = "hello world input"; final String encrypted = ARIA.encrypt(plainText, key); final String decrypted = ARIA.decrypt(encrypted, key); "<AssertPlaceHolder>"; }
decrypt(String input, String key) { org.apache.commons.codec.binary.Base64 base64 = new org.apache.commons.codec.binary.Base64(); String output = ""; try { SecretKeySpec secretKey = new SecretKeySpec(getKey(key), "ARIA"); Cipher cipher = Cipher.getInstance("ARIA"); cipher.init(Cipher.DECRYPT_MODE, secretKey); output = new String(cipher.doFinal(base64.decode(input.getBytes()))); } catch (GeneralSecurityException e) { e.printStackTrace(); return e.toString(); } return output; }
[*] target: assertEquals(plainText, decrypted)
[-] pred: org. junit. Assert. assertEquals ( plainText, decrypted )
************************************
************************************
[+] input: runTest() { final String key = "key for idea"; final String plainText = "Hello world input text"; final String encrypted = IDEA.encrypt(plainText, key); final String decrypted = IDEA.decrypt(encrypted, key);  "<AssertPlaceHolder>"; }
decrypt(String input, String key) { org.apache.commons.codec.binary.Base64 base64 = new org.apache.commons.codec.binary.Base64(); String output = ""; try { SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), "IDEA"); Cipher cipher = Cipher.getInstance("IDEA"); cipher.init(Cipher.DECRYPT_MODE, secretKey); output = new String(cipher.doFinal(base64.decode(input.getBytes()))); } catch (GeneralSecurityException e) { e.printStackTrace(); return e.toString(); } return output; }
[*] target: assertEquals(plainText, decrypted)
[-] pred: org. junit. Assert. assertEquals ( plainText, decrypted )
************************************
************************************
[+] input: Exception {  String PEMContentsOriginal = "-----BEGIN PUBLIC KEY-----\n" + "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEVQ6XXBFwG9mAqijwD2DN9Pgq62l0\n" + "oJmXwpptVDHsonyZ3Wl4J5DHBKfRVgD7KUPEwN9lEMjBqVGNSYbI7KP3mw==\n" + "-----END PUBLIC KEY-----";  PublicKey publicKey = PEMToKey.getPemPublicKey(PEMContentsOriginal, "ECDSA");  String PEMContents = PEM.PublicKeyToPEMFormat(publicKey);  "<AssertPlaceHolder>"; }
PublicKeyToPEMFormat(PublicKey publicKey) { return "-----BEGIN PUBLIC KEY-----\n" + new String(encoder.encode(publicKey.getEncoded())) + "\n-----END PUBLIC KEY-----"; }
[*] target: assertEquals(PEMContentsOriginal, PEMContents)
[-] pred: org. junit. Assert. assertEquals ( PEMContentsOriginal, PEMContents )
************************************
************************************
[+] input: testChoose() { Plip p = new Plip(1.2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  //You can create new empties with new Empty(); //Despite what the spec says, you cannot test for Cloruses nearby yet. //Sorry!  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  "<AssertPlaceHolder>"; }
chooseAction(Map<Direction, Occupant> neighbors) { return new Action(Action.ActionType.STAY); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetClientValidAddress() { PeerClientPool pool = PeerClientPool.getInstance(); pool.setPort(PORT);  TraceServiceGrpc.TraceServiceBlockingStub client = pool.getClient(VALID_ADDRESS);  "<AssertPlaceHolder>"; }
getClient(final String address) { // TODO: Resolve to IP first, or is hostname good enough? return peerClients.computeIfAbsent(address, addr -> createGRPCClient(addr)); }
[*] target: assertNotNull(client)
[-] pred: org. junit. Assert. assertNotNull ( client )
************************************
************************************
[+] input: testInsert() { Temperature one = new Temperature(); one.setTs(new Timestamp(1605024000000l)); one.setTemperature(random.nextFloat() * 50); one.setLocation("望京"); int affectRows = mapper.insertOne(one); Assert."<AssertPlaceHolder>"; }
insertOne(Temperature one);
[*] target: assertEquals(1, affectRows)
[-] pred: org. junit. Assert. assertEquals ( 1, affectRows )
************************************
************************************
[+] input: testInsert() { Weather one = new Weather(); one.setTs(new Timestamp(1605024000000l)); one.setTemperature(random.nextFloat() * 50); one.setHumidity(random.nextInt(100)); one.setLocation("望京"); int affectRows = mapper.insert(one); Assert."<AssertPlaceHolder>"; }
insert(Weather weather);
[*] target: assertEquals(1, affectRows)
[-] pred: org. junit. Assert. assertEquals ( 1, affectRows )
************************************
************************************
[+] input: UnknownHostException { final InetAddress addr = controller.getInetAddress("*"); "<AssertPlaceHolder>"; }
getInetAddress(final String address) throws UnknownHostException { if ("*".equals(address)) { return null; } else { return InetAddress.getByName(address); } }
[*] target: assertNull(addr)
[-] pred: org. junit. Assert. assertNull ( addr )
************************************
************************************
[+] input: testGetNoMatchClasses() { MethodCoverageImpl m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 1); addClass(1, true, "Sample1", null, m);  m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 2); addClass(2, true, "Sample2", null, m);  m = new MethodCoverageImpl("doit", "()V", null); m.increment(CounterImpl.COUNTER_1_0, CounterImpl.COUNTER_0_0, 3); addClass(3, false, "Sample3", null, m);  final Set<String> actual = getNames(coverageBuilder.getNoMatchClasses()); final Set<String> expected = new HashSet<String>(Arrays.asList( "Sample1", "Sample2"));  "<AssertPlaceHolder>"; }
getNoMatchClasses() { final Collection<IClassCoverage> result = new ArrayList<>(); for (final IClassCoverage c : classes.values()) { if (c.isNoMatch()) { result.add(c); } } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testFixInstance() { ICounter c1 = CounterImpl.getInstance(30, 30); ICounter c2 = CounterImpl.getInstance(30, 30); "<AssertPlaceHolder>"; }
getInstance(final int missed, final int covered) { if (missed <= SINGLETON_LIMIT && covered <= SINGLETON_LIMIT) { return SINGLETONS[missed][covered]; } else { return new Var(missed, covered); } }
[*] target: assertSame(c1, c2)
[-] pred: org. junit. Assert. assertSame ( c1, c2 )
************************************
************************************
[+] input: testEquals1() { ICounter c1 = CounterImpl.getInstance(300, 123); ICounter c2 = CounterImpl.getInstance(300, 123); "<AssertPlaceHolder>"; }
getInstance(final int missed, final int covered) { if (missed <= SINGLETON_LIMIT && covered <= SINGLETON_LIMIT) { return SINGLETONS[missed][covered]; } else { return new Var(missed, covered); } }
[*] target: assertEquals(c1, c2)
[-] pred: org. junit. Assert. assertEquals ( c1, c2 )
************************************
************************************
[+] input: testEquals1() { line = line.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); LineImpl line2 = LineImpl.EMPTY; line2 = line2.increment(CounterImpl.getInstance(111, 222), CounterImpl.getInstance(333, 444)); "<AssertPlaceHolder>"; }
getInstance(final CounterImpl instructions, final CounterImpl branches) { final int im = instructions.getMissedCount(); final int ic = instructions.getCoveredCount(); final int bm = branches.getMissedCount(); final int bc = branches.getCoveredCount(); if (im <= SINGLETON_INS_LIMIT && ic <= SINGLETON_INS_LIMIT && bm <= SINGLETON_BRA_LIMIT && bc <= SINGLETON_BRA_LIMIT) { return SINGLETONS[im][ic][bm][bc]; } return new Var(instructions, branches); }
[*] target: assertEquals(line, line2)
[-] pred: org. junit. Assert. assertEquals ( line, line2 )
************************************
************************************
[+] input: Exception { generator = new OfflineInstrumentationAccessGenerator(); MethodRecorder actual = new MethodRecorder(); generator.generateDataAccessor(987654321, "foo/Bar", 17, actual.getVisitor());  MethodRecorder expected = new MethodRecorder(); expected.getVisitor().visitLdcInsn(Long.valueOf(987654321)); expected.getVisitor().visitLdcInsn("foo/Bar"); expected.getVisitor().visitIntInsn(Opcodes.BIPUSH, 17); String rtname = JaCoCo.RUNTIMEPACKAGE.replace('.', '/') + "/Offline"; expected.getVisitor().visitMethodInsn(Opcodes.INVOKESTATIC, rtname, "getProbes", "(JLjava/lang/String;I)[Z", false);  "<AssertPlaceHolder>"; }
generateDataAccessor(final long classid, final String classname, final int probecount, final MethodVisitor mv) { mv.visitLdcInsn(Long.valueOf(classid)); mv.visitLdcInsn(classname); InstrSupport.push(mv, probecount); mv.visitMethodInsn(Opcodes.INVOKESTATIC, runtimeClassName, "getProbes", "(JLjava/lang/String;I)[Z", false); return 4; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testMax0() { limit.setMaximum("0"); limit.setMaximum((String) null); "<AssertPlaceHolder>"; }
getMaximum() { return maximum == null ? null : maximum.toPlainString(); }
[*] target: assertNull(limit.getMaximum())
[-] pred: org. junit. Assert. assertNull ( limit. getMaximum() )
************************************
************************************
[+] input: testIsRootPage1() { "<AssertPlaceHolder>"; }
isRootPage() { return parent == null; }
[*] target: assertFalse(page.isRootPage())
[-] pred: org. junit. Assert. assertFalse ( page. isRootPage() )
************************************
************************************
[+] input: emptyListShouldNotFail() { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(new ArrayList<>(), null, null, null, false); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now, boolean withFederationGateway) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now, withFederationGateway); } }
[*] target: assertNull(theException)
[-] pred: org. junit. Assert. assertNull ( theException )
************************************
************************************
[+] input: Exception { Map<String, Object> values = new HashMap<String, Object>(); values.put("intValue", 1); values.put("booleanValue", true); values.put("stringArray", new String[] { "a", "b", "c" }); TypedMap map = new TypedMap(recordType, values);  map.clear(); "<AssertPlaceHolder>"; }
size() { return inner.size(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size ( ) )
************************************
************************************
[+] input: RepositoryException { PackageModel packageModelByPath = packageInfoService.getPackageModelByPath("/etc/packages/testGroup/testPackage-3.zip", resourceResolver);  "<AssertPlaceHolder>"; }
getPackageModelByPath(final String packagePath, final ResourceResolver resourceResolver) { final Session session = resourceResolver.adaptTo(Session.class); JcrPackageManager packMgr = basePackageService.getPackageManager(session);  JcrPackage jcrPackage = null; if (session == null) { return null; } try {  Node packageNode = session.getNode(packagePath); if (packageNode != null) { jcrPackage = packMgr.open(packageNode); return getPackageModel(jcrPackage); }  } catch (RepositoryException e) { LOGGER.error("Error during package opening", e); } finally { if (jcrPackage != null) { jcrPackage.close(); } } return null; }
[*] target: assertNull(packageModelByPath)
[-] pred: org. junit. Assert. assertNull ( packageModelByPath )
************************************
************************************
[+] input: shouldReturnFalseWithNonExistingPackage() { PackageInfoModel packageInfoModel = new PackageInfoModel(); packageInfoModel.setPackagePath(TEST_PACKAGE);  boolean result = packageInfoService.packageExists(resourceResolver, packageInfoModel);  "<AssertPlaceHolder>"; }
packageExists(ResourceResolver resourceResolver, PackageInfoModel packageInfoModel) { final Session session = resourceResolver.adaptTo(Session.class); final JcrPackageManager packageMgr = basePackageService.getPackageManager(session); try { List<Node> nodes = packageMgr.listPackages().stream().map(JcrPackage::getNode) .filter(Objects::nonNull).collect(Collectors.toList()); for (Node node : nodes) { if (node.getPath().equals(packageInfoModel.getPackagePath())) { return true; } } } catch (RepositoryException e) { LOGGER.error(String.format(BackpackConstants.PACKAGE_DOES_NOT_EXIST_MESSAGE, packageInfoModel.getPackagePath())); } return false; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: RepositoryException { PackageInfo packageInfo = getDefaultPackageInfo(); DefaultWorkspaceFilter defaultWorkspaceFilter = new DefaultWorkspaceFilter(); defaultWorkspaceFilter.add(new PathFilterSet(PAGE_1)); createPackage(packageInfo, defaultWorkspaceFilter);  PackageInfoModel packageInfoModel = new PackageInfoModel(); packageInfoModel.setPackagePath(PACKAGE_PATH);  boolean result = packageInfoService.packageExists(resourceResolver, packageInfoModel);  "<AssertPlaceHolder>"; }
packageExists(ResourceResolver resourceResolver, PackageInfoModel packageInfoModel) { final Session session = resourceResolver.adaptTo(Session.class); final JcrPackageManager packageMgr = basePackageService.getPackageManager(session); try { List<Node> nodes = packageMgr.listPackages().stream().map(JcrPackage::getNode) .filter(Objects::nonNull).collect(Collectors.toList()); for (Node node : nodes) { if (node.getPath().equals(packageInfoModel.getPackagePath())) { return true; } } } catch (RepositoryException e) { LOGGER.error(String.format(BackpackConstants.PACKAGE_DOES_NOT_EXIST_MESSAGE, packageInfoModel.getPackagePath())); } return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testMazeSolution() {  int ret_val = MazeClient.walk('s', 's', 's', 's', 'd', 'd', 'd', 'd', 'w', 'w', 'a', 'a', 'w', 'w', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 'd', 'd', 'w', 'w', 'w', 'w', (char) 0, (char) 0, 28); "<AssertPlaceHolder>"; }
walk(char move0, char move1, char move2, char move3, char move4, char move5, char move6, char move7, char move8, char move9, char move10, char move11, char move12, char move13, char move14, char move15, char move16, char move17, char move18, char move19, char move20, char move21, char move22, char move23, char move24, char move25, char move26, char move27, char move28, char move29, int moveLength) {  char[] moves = new char[] {move0, move1, move2, move3, move4, move5, move6, move7, move8, move9, move10, move11, move12, move13, move14, move15, move16, move17, move18, move19, move20, move21, move22, move23, move24, move25, move26, move27, move28, move29};  return walk(moves, moveLength); }
[*] target: assertEquals(1, ret_val)
[-] pred: org. junit. Assert. assertEquals ( 1, ret_val )
************************************
************************************
[+] input: testConfirmToString() { String res = new OverrideToString().toString(); String diff = res + " a different string";  OverrideToString obj = mock(OverrideToString.class); when(obj.toString()).thenReturn(diff);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(diff, obj.toString())
[-] pred: org. junit. Assert. assertEquals ( diff, obj. toString ( ) )
************************************
************************************
[+] input: testRingTopology_leftNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 2);  Chromosome exepcted_individual = population.get(1); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testRingTopology_rightNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 2);  Chromosome exepcted_individual = population.get(3); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testRingTopology_mostLeftNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 0);  Chromosome exepcted_individual = population.get(15); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testRingTopology_mostRightNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.ringTopology(population, 15);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<? extends Chromosome> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add((T) collection.get(_L)); chromosomes.add((T) collection.get(position)); chromosomes.add((T) collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(1); Chromosome returned_individual = neighbors.get(0);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(9); Chromosome returned_individual = neighbors.get(1);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(6); Chromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.linearFive(population, 5);  Chromosome exepcted_individual = population.get(4); Chromosome returned_individual = neighbors.get(3);  "<AssertPlaceHolder>"; }
linearFive(List<? extends Chromosome> collection, int position) {  _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(10); Chromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.compactNine(population, 5);  Chromosome exepcted_individual = population.get(8); Chromosome returned_individual = neighbors.get(5);  "<AssertPlaceHolder>"; }
compactNine(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testNorthNorthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 10);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(8);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSouthSouthNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 10);  Chromosome exepcted_individual = population.get(2); Chromosome returned_individual = neighbors.get(9);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testEastEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 10);  Chromosome exepcted_individual = population.get(8); Chromosome returned_individual = neighbors.get(10);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testWestWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 5);  Chromosome exepcted_individual = population.get(7); Chromosome returned_individual = neighbors.get(11);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 0);  Chromosome exepcted_individual = population.get(15); Chromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 3);  Chromosome exepcted_individual = population.get(12); Chromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostSouthWestNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 12);  Chromosome exepcted_individual = population.get(3); Chromosome returned_individual = neighbors.get(5);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testMostSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<Chromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<Chromosome> neighbors = new ArrayList<>();  neighbors = neighbourhood.CompactThirteen(population, 15);  Chromosome exepcted_individual = population.get(0); Chromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
CompactThirteen(List<? extends Chromosome> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add((T) collection.get(_N)); chromosomes.add((T) collection.get(_S)); chromosomes.add((T) collection.get(_E)); chromosomes.add((T) collection.get(_W)); chromosomes.add((T) collection.get(_NW)); chromosomes.add((T) collection.get(_SW)); chromosomes.add((T) collection.get(_NE)); chromosomes.add((T) collection.get(_SE)); chromosomes.add((T) collection.get(_NN)); chromosomes.add((T) collection.get(_SS)); chromosomes.add((T) collection.get(_EE)); chromosomes.add((T) collection.get(_WW)); chromosomes.add((T) collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testDoubleInit() { int n = ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks();  Runtime.getRuntime().addShutdownHook(new Thread(){});  //this should remove the above hook thread ShutdownHookHandler.getInstance().initHandler();  Assert."<AssertPlaceHolder>"; }
getNumberOfAllExistingHooks() { if(hooksReference==null) { return -1; } return hooksReference.size(); }
[*] target: assertEquals(n, ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks())
[-] pred: org. junit. Assert. assertEquals ( n, ShutdownHookHandler.getInstance ( ). getNumberOfAllExistingHooks() )
************************************
************************************
[+] input: testHibernateConfiguration() { EntityManagerFactory factory = MockPersistence.createEntityManagerFactory("foo"); EntityManager em = factory.createEntityManager(); factory.close(); Assert."<AssertPlaceHolder>"; }
createEntityManagerFactory(String persistenceUnitName) { return DBManager.getInstance().getDefaultFactory(); }
[*] target: assertNotNull(em)
[-] pred: org. junit. Assert. assertNotNull ( em )
************************************
************************************
[+] input: Exception {  EvoSuiteLocalAddress addr = new EvoSuiteLocalAddress("127.42.42.42",42); NetworkHandling.sendDataOnTcp(addr,null);  MockServerSocket sut = new MockServerSocket(addr.getPort(), 1, MockInetAddress.getByName(addr.getHost())); Socket socket = sut.accept(); //should not block, should not timeout Assert."<AssertPlaceHolder>"; }
sendDataOnTcp(EvoSuiteLocalAddress sutServer, byte[] data){ if(sutServer==null){ return false; }  NativeTcp connection = VirtualNetwork.getInstance().registerIncomingTcpConnection( DEFAULT_REMOTE_ADDRESS, VirtualNetwork.getInstance().getNewRemoteEphemeralPort(), sutServer.getHost(), sutServer.getPort());  /* * At this point in time the SUT has not opened a connection yet (if it did, * it would had thrown an IOException). * But we can already put the message on the buffer */  if(data != null){ for(byte b : data){ connection.writeToSUT(b); } } //TODO close connection? or should rather be in another helper function?  return true; }
[*] target: assertNotNull(socket)
[-] pred: org. junit. Assert. assertNotNull ( socket )
************************************
************************************
[+] input: Exception { String text = "Hello World!"; EvoSuiteURL url = new EvoSuiteURL("http://evosuite.org/hello.txt");  NetworkHandling.createRemoteTextFile(url,text);  URL mock = MockURL.URL(url.getUrl()); URLConnection connection = mock.openConnection(); Scanner in = new Scanner(connection.getInputStream()); String res = in.nextLine(); Assert."<AssertPlaceHolder>"; }
createRemoteTextFile(EvoSuiteURL url, String text){ if(url == null){ return false; } return VirtualNetwork.getInstance().addRemoteTextFile(url.getUrl(),text); }
[*] target: assertEquals(text,res)
[-] pred: org. junit. Assert. assertEquals ( text, res )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_FORWARDING_ROUTING_V4); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_FORWARDING_NOP_ROUTING_V4) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder().wipeDeferred().build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_FORWARDING_ROUTING_V4); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_FORWARDING_DROP_ROUTING_V4) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.emptyTreatment(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_ACL_ACL); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_ACL_NOP_ACL) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .wipeDeferred() .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_ACL_ACL); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_ACL_DROP) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { //     TrafficTreatment treatment = DefaultTrafficTreatment.builder() //             .setOutput(PORT_1) //             .build(); //     PiAction mappedAction = interpreter.mapTreatment( //             treatment, P4InfoConstants.FABRIC_INGRESS_NEXT_SIMPLE); //     PiActionParam param = new PiActionParam(P4InfoConstants.PORT_NUM, PORT_1.toLong()); //     PiAction expectedAction = PiAction.builder() //             .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_OUTPUT_SIMPLE) //             .withParameter(param) //             .build(); //     "<AssertPlaceHolder>"; // }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .setVlanId(VLAN_100) .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_NEXT_VLAN); PiActionParam vlanParam = new PiActionParam( P4InfoConstants.VLAN_ID, VLAN_100.toShort()); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_SET_VLAN) .withParameter(vlanParam) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: Exception { TrafficTreatment treatment = DefaultTrafficTreatment.builder() .setMpls(MPLS_10) .build(); PiAction mappedAction = interpreter.mapTreatment( treatment, P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_NEXT_MPLS); PiActionParam mplsParam = new PiActionParam( P4InfoConstants.LABEL, MPLS_10.toInt()); PiAction expectedAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_PRE_NEXT_SET_MPLS_LABEL) .withParameter(mplsParam) .build(); "<AssertPlaceHolder>"; }
mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException { if (FORWARDING_CTRL_TBLS.contains(piTableId)) { return mapForwardingTreatment(treatment, piTableId); } else if (PRE_NEXT_CTRL_TBLS.contains(piTableId)) { return mapPreNextTreatment(treatment, piTableId); } else if (ACL_CTRL_TBLS.contains(piTableId)) { return mapAclTreatment(treatment, piTableId); } else if (NEXT_CTRL_TBLS.contains(piTableId)) { return mapNextTreatment(treatment, piTableId); } else if (E_NEXT_CTRL_TBLS.contains(piTableId)) { return mapEgressNextTreatment(treatment, piTableId); } else { throw new PiInterpreterException(format( "Treatment mapping not supported for table '%s'", piTableId)); } }
[*] target: assertEquals(expectedAction, mappedAction)
[-] pred: org. junit. Assert. assertEquals ( expectedAction, mappedAction )
************************************
************************************
[+] input: FabricPipelinerException { TrafficTreatment treatment1 = DefaultTrafficTreatment.builder() .setOutput(PORT_1) .build(); TrafficTreatment treatment2 = DefaultTrafficTreatment.builder() .popVlan() .setOutput(PORT_2) .build(); NextObjective nextObjective = DefaultNextObjective.builder() .withId(NEXT_ID_1) .withPriority(PRIORITY) .addTreatment(treatment1) .addTreatment(treatment2) .withMeta(VLAN_META) .withType(NextObjective.Type.BROADCAST) .makePermanent() .fromApp(APP_ID) .add();  ObjectiveTranslation actualTranslation = translatorHashed.doTranslate(nextObjective);  // Should generate 3 flows: // - Multicast table flow that matches on next-id and set multicast group (1) // - Egress VLAN pop handling for treatment2 (0) // - Next VLAN flow (2) // And 2 groups: // - Multicast group  // Expected multicast table flow rule. PiCriterion nextIdCriterion = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_NEXT_ID, NEXT_ID_1) .build(); TrafficSelector nextIdSelector = DefaultTrafficSelector.builder() .matchPi(nextIdCriterion) .build(); PiAction setMcGroupAction = PiAction.builder() .withId(P4InfoConstants.FABRIC_INGRESS_NEXT_SET_MCAST_GROUP_ID) .withParameter(new PiActionParam( P4InfoConstants.GROUP_ID, NEXT_ID_1)) .build(); TrafficTreatment treatment = DefaultTrafficTreatment.builder() .piTableAction(setMcGroupAction) .build(); FlowRule expectedHashedFlowRule = DefaultFlowRule.builder() .forDevice(DEVICE_ID) .fromApp(APP_ID) .makePermanent() .withPriority(nextObjective.priority()) .forTable(P4InfoConstants.FABRIC_INGRESS_NEXT_MULTICAST) .withSelector(nextIdSelector) .withTreatment(treatment) .build();  // Expected egress VLAN_PUSH flow rule. PiCriterion egressVlanTableMatch = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_EG_PORT, PORT_1.toLong()) .build(); TrafficSelector selectorForEgressVlan = DefaultTrafficSelector.builder() .matchPi(egressVlanTableMatch) .matchVlanId(VLAN_100) .build(); PiAction piActionForEgressVlan = PiAction.builder() .withId(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_PUSH_VLAN) .build(); TrafficTreatment treatmentForEgressVlan = DefaultTrafficTreatment.builder() .piTableAction(piActionForEgressVlan) .build(); FlowRule expectedEgressVlanPushRule = DefaultFlowRule.builder() .withSelector(selectorForEgressVlan) .withTreatment(treatmentForEgressVlan) .forTable(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_EGRESS_VLAN) .makePermanent() .withPriority(nextObjective.priority()) .forDevice(DEVICE_ID) .fromApp(APP_ID) .build();  // Expected egress VLAN POP flow rule. egressVlanTableMatch = PiCriterion.builder() .matchExact(P4InfoConstants.HDR_EG_PORT, PORT_2.toLong()) .build(); selectorForEgressVlan = DefaultTrafficSelector.builder() .matchPi(egressVlanTableMatch) .matchVlanId(VLAN_100) .build(); piActionForEgressVlan = PiAction.builder() .withId(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_POP_VLAN) .build(); treatmentForEgressVlan = DefaultTrafficTreatment.builder() .piTableAction(piActionForEgressVlan) .build(); FlowRule expectedEgressVlanPopRule = DefaultFlowRule.builder() .withSelector(selectorForEgressVlan) .withTreatment(treatmentForEgressVlan) .forTable(P4InfoConstants.FABRIC_EGRESS_EGRESS_NEXT_EGRESS_VLAN) .makePermanent() .withPriority(nextObjective.priority()) .forDevice(DEVICE_ID) .fromApp(APP_ID) .build();  // Expected ALL group. TrafficTreatment allGroupTreatment1 = DefaultTrafficTreatment.builder() .setOutput(PORT_1) .build(); TrafficTreatment allGroupTreatment2 = DefaultTrafficTreatment.builder() .setOutput(PORT_2) .build(); List<TrafficTreatment> allTreatments = ImmutableList.of( allGroupTreatment1, allGroupTreatment2); List<GroupBucket> allBuckets = allTreatments.stream() .map(DefaultGroupBucket::createAllGroupBucket) .collect(Collectors.toList()); GroupBuckets allGroupBuckets = new GroupBuckets(allBuckets); GroupKey allGroupKey = new DefaultGroupKey(FabricUtils.KRYO.serialize(NEXT_ID_1)); GroupDescription expectedAllGroup = new DefaultGroupDescription( DEVICE_ID, GroupDescription.Type.ALL, allGroupBuckets, allGroupKey, NEXT_ID_1, APP_ID );  ObjectiveTranslation expectedTranslation = ObjectiveTranslation.builder() .addFlowRule(expectedHashedFlowRule) .addFlowRule(vlanMetaFlowRule) .addFlowRule(expectedEgressVlanPushRule) .addFlowRule(expectedEgressVlanPopRule) .addGroup(expectedAllGroup) .build();  "<AssertPlaceHolder>"; }
doTranslate(NextObjective obj) throws FabricPipelinerException {  final ObjectiveTranslation.Builder resultBuilder = ObjectiveTranslation.builder();  switch (obj.type()) { case SIMPLE: simpleNext(obj, resultBuilder, false); break; case HASHED: hashedNext(obj, resultBuilder); break; case BROADCAST: if (isXconnect(obj)) { // TODO: re-enable support for xconnext // xconnectNext(obj, resultBuilder); log.warn("Xconnect not supported [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); } else { multicastNext(obj, resultBuilder); } break; default: log.warn("Unsupported NextObjective type [{}]", obj); return ObjectiveTranslation.ofError(ObjectiveError.UNSUPPORTED); }  if (!isGroupModifyOp(obj)) { // Generate next VLAN rules. nextMpls(obj, resultBuilder); nextVlan(obj, resultBuilder); }  return resultBuilder.build(); }
[*] target: assertEquals(expectedTranslation, actualTranslation)
[-] pred: org. junit. Assert. assertEquals ( expectedTranslation, actualTranslation )
************************************
************************************
[+] input: formatHijriDate() { String str = UiUtils.formatHijriDate(10, "Safar", 1415); "<AssertPlaceHolder>"; }
formatHijriDate(int day, String monthName, int year) { NumberFormat numberFormat = NumberFormat.getInstance(); String date = numberFormat.format(day) + " " + monthName + " " + numberFormat.format(year); return date.replaceAll("[٬،.,]", ""); }
[*] target: assertNotNull(str)
[-] pred: org. junit. Assert. assertNotNull ( str )
************************************
************************************
[+] input: getFirstLine() { // assign variables with test data String expectedLine = "First Line";  // allocate test objects StackTrace stackTrace = new StackTrace(expectedLine, null);  // execute methods to be tested String actualLine = stackTrace.getFirstLine();  // assign result Assert."<AssertPlaceHolder>"; }
getFirstLine() { return this.firstLine; }
[*] target: assertEquals(expectedLine, actualLine)
[-] pred: org. junit. Assert. assertEquals ( expectedLine, actualLine )
************************************
************************************
[+] input: getUser() { User user = userMapper.selectByUsername("admin"); Assert."<AssertPlaceHolder>"; }
selectByUsername(@Param("username") String username);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getJobConfigById() { JobConfigDTO jobConfigDTO = jobConfigService.getJobConfigById(1L); System.out.println(jobConfigDTO); Assert."<AssertPlaceHolder>"; }
getJobConfigById(Long id);
[*] target: assertNotNull(jobConfigDTO)
[-] pred: org. junit. Assert. assertNotNull ( jobConfigDTO )
************************************
************************************
[+] input: queryJobConfig() { JobConfigParam jobConfigParam=new JobConfigParam(); jobConfigParam.setPageNum(2); PageModel<JobConfigDTO> pageModel = jobConfigService.queryJobConfig(jobConfigParam); Assert."<AssertPlaceHolder>"; }
queryJobConfig(JobConfigParam jobConfigParam);
[*] target: assertNotNull(pageModel)
[-] pred: org. junit. Assert. assertNotNull ( pageModel )
************************************
************************************
[+] input: checkLogin() { String cookieId = userService.login("admin", "123456"); Assert."<AssertPlaceHolder>"; }
login(String userName, String password);
[*] target: assertNotNull(cookieId)
[-] pred: org. junit. Assert. assertNotNull ( cookieId )
************************************
************************************
[+] input: Exception {  String userId = "u00001"; String password = "123456"; String keyName = "testKey";  PkeyInfoVO pkeyInfoVO = keysManagerService.createPrivateKey(userId, password, keyName) ; EncryptKeyInfo encryptKey = keysManagerService.getEncryptPrivateKeyByUserIdAndAddress(userId, pkeyInfoVO.getKeyAddress()); String privateKey = keysManagerService.decryptPrivateKey(password, encryptKey.getEncryptKey());  String msg = "test message"; String signStr = signatureService.sign(msg, privateKey); String publicKey = addressHandler.computePublicKey(Numeric.hexStringToByteArray(privateKey)); boolean checkResult = signatureService.verify(msg, signStr, publicKey);  Assert."<AssertPlaceHolder>"; }
verify(String msg, String signStr, String publicKey){ return privateKeySigner.verify(msg, signStr, publicKey); }
[*] target: assertTrue(checkResult)
[-] pred: org. junit. Assert. assertTrue ( checkResult )
************************************
************************************
[+] input: testAnyLabelEqualToWildcardLabel() { Label testLabel = new Label("Test");  WildcardLabel wildcardLabel = new WildcardLabel();  "<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) return true; if (o == null) return false; if (o.getClass() == WildcardLabel.class) return true; if (getClass() != o.getClass()) return false; Label label1 = (Label) o; return label.equals(label1.label); }
[*] target: assertTrue(testLabel.equals(wildcardLabel))
[-] pred: org. junit. Assert. assertTrue ( testLabel. equals ( wildcardLabel ) )
************************************
************************************
[+] input: testToStringEdgePatternWithLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"Does"}); EdgePattern edgePattern = new EdgePattern(null, label, null, Direction.LEFT_TO_RIGHT, 1);  String expectedResult = "(->, nil, {{Does}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringEdgePatternWithLabelConjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Does", "AreColleagues"}); EdgePattern edgePattern = new EdgePattern(null, labelSetList, null, Direction.UNDIRECTED, 1);  String expectedResult = "(-, nil, {{Does, AreColleagues}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringEdgePatternWithLabelDisjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"AreColleagues"}); addLabelSetTo(labelSetList, new String[]{"Does"}); EdgePattern edgePattern = new EdgePattern(null, labelSetList, null, Direction.LEFT_TO_RIGHT, 1);  String expectedResult = "(->, nil, {{AreColleagues}, {Does}}, {}, (1, 1))"; "<AssertPlaceHolder>"; }
toString() { String direction = this.direction.toString(); String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString(); String quantifier = getQuantifierString();  return "(" + direction + ", " + id + ", " + labels + ", " + properties + ", " + quantifier + ")"; }
[*] target: assertEquals(expectedResult, edgePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, edgePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"Person"}); NodePattern nodePattern = new NodePattern(null, label, null);  String expectedResult = "(nil, {{Person}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithLabelConjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); NodePattern nodePattern = new NodePattern(null, labelSetList, null);  String expectedResult = "(nil, {{Person, Professor}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithLabelDisjunction() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); addLabelSetTo(labelSetList, new String[]{"Internship"}); NodePattern nodePattern = new NodePattern(null, labelSetList, null);  String expectedResult = "(nil, {{Person, Professor}, {Internship}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithProperty() { HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); NodePattern nodePattern = new NodePattern(null, null, properties);  String expectedResult = "(nil, {}, {(name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithProperties() { HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); properties.put(new GqlIdentifier("studies"), new GqlString("Data Science")); NodePattern nodePattern = new NodePattern(null, null, properties);  String expectedResult = "(nil, {}, {(studies: "Data Science"), (name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithIdAndLabelsAndProperties() { ArrayList<ArrayList<Label>> labelSetList = new ArrayList<>(); addLabelSetTo(labelSetList, new String[]{"Person", "Professor"}); addLabelSetTo(labelSetList, new String[]{"Internship"});  HashMap<GqlIdentifier, Value> properties = new HashMap<>(); properties.put(new GqlIdentifier("name"), new GqlString("Olof Morra")); properties.put(new GqlIdentifier("studies"), new GqlString("Data Science"));  NodePattern nodePattern = new NodePattern(new VariableName("x"), labelSetList, properties);  String expectedResult = "(x, {{Person, Professor}, {Internship}}, {(studies: "Data Science"), (name: "Olof Morra")})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testToStringNodePatternWithWildCardLabel() { ArrayList<ArrayList<Label>> label = new ArrayList<>(); addLabelSetTo(label, new String[]{"%"}); NodePattern nodePattern = new NodePattern(null, label, null);  String expectedResult = "(nil, {{%}}, {})"; "<AssertPlaceHolder>"; }
toString() { String id = getIdString(); String labels = getLabelString(); String properties = getPropertyString();  return "(" + id + ", " + labels + ", " + properties + ")"; }
[*] target: assertEquals(expectedResult, nodePattern.toString())
[-] pred: org. junit. Assert. assertEquals ( expectedResult, nodePattern. toString ( ) )
************************************
************************************
[+] input: testExtractMessages_MacbookProUnderflow() { final Data raw = Data.fromHexEncodedString("02011a0aff4c001005031c0b4c"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertNull(messages)
[-] pred: org. junit. Assert. assertNull ( messages )
************************************
************************************
[+] input: testDeserializePrimitives() { Schema schema = new Schema(required(1, "string_type", Types.StringType.get()), required(2, "int_type", Types.IntegerType.get()), required(3, "long_type", Types.LongType.get()), required(4, "boolean_type", Types.BooleanType.get()), required(5, "float_type", Types.FloatType.get()), required(6, "double_type", Types.DoubleType.get()), required(7, "date_type", Types.DateType.get()));  List<?> expected = Arrays.asList("foo", 12, 3000L, true, 3.01F, 3.0D, "1998-11-13");  Record record = TestHelpers.createCustomRecord(schema, expected); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> result = (List<Object>) serDe.deserialize(writable);  "<AssertPlaceHolder>"; }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: extractWarehouseLocationRegularTable() { // This is the style of input expected from HiveConf String testLocation = "some/folder/database/table_a"; String testTableName = "database.table_a";  String expected = "some/folder/"; String result = TableResolverUtil.extractWarehousePath(testLocation, testTableName);  "<AssertPlaceHolder>"; }
extractWarehousePath(String location, String tableName) { String tablePath = tableName.replaceAll("\\.","/").replaceAll(SNAPSHOT_TABLE_SUFFIX, ""); return location.replaceAll(tablePath, ""); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: extractPropertyFromJobConf() { JobConf conf = new JobConf(); String key = "iceberg.catalog"; String value = "hadoop.tables";  conf.set(key, value);  String result = TableResolverUtil.extractProperty(conf, key);  "<AssertPlaceHolder>"; }
extractProperty(JobConf conf, String key) { String value = conf.get(key); if (value == null) { throw new IllegalArgumentException("Property not set in JobConf: " + key); } return value; }
[*] target: assertEquals(value, result)
[-] pred: org. junit. Assert. assertEquals ( value, result )
************************************
************************************
[+] input: testBssidSeen() { String protocol = "http"; String bssid = "dk/aau/netsec/hostage/fragment"; record.setProtocol(protocol); record.setBssid(bssid);  daoSession.insert(record);  boolean bssidSeen = attackRecordDAO.bssidSeen(protocol,bssid);  "<AssertPlaceHolder>"; }
bssidSeen(String protocol, String BSSID) { if(BSSID == null || protocol == null){ return false; } AttackRecordDao recordDao = this.daoSession.getAttackRecordDao();  QueryBuilder<AttackRecord> qb = recordDao.queryBuilder(); qb.where(AttackRecordDao.Properties.Protocol.eq(protocol),AttackRecordDao.Properties.Bssid.eq(BSSID)); List<AttackRecord> records = qb.list();  return !records.isEmpty(); }
[*] target: assertTrue(bssidSeen)
[-] pred: org. junit. Assert. assertTrue ( bssidSeen )
************************************
************************************
[+] input: testNullClass() { Config config = UnitTestBase.updateWithRequiredOptions( ComputerOptions.WORKER_COMBINER_CLASS, Null.class.getName() ); Object combiner = config.createObject( ComputerOptions.WORKER_COMBINER_CLASS, false); Assert."<AssertPlaceHolder>"; }
createObject(ConfigOption<Class<?>> clazzOption, boolean requiredNotNull) { Class<?> clazz = this.get(clazzOption); if (clazz == Null.class) { if (requiredNotNull) { throw new ComputerException( "Please config required option '%s'", clazzOption.name()); } return null; } try { @SuppressWarnings("unchecked") T instance = (T) clazz.newInstance(); return instance; } catch (Exception e) { throw new ComputerException("Failed to create object for option " + "'%s', class='%s'", e, clazzOption.name(), clazz.getName()); } }
[*] target: assertNull(combiner)
[-] pred: org. junit. Assert. assertNull ( combiner )
************************************
************************************
[+] input: testHashCode() { InputStruct inputStruct = Mockito.mock(InputStruct.class); FileInputSplit split1 = new FileInputSplit(ElemType.VERTEX, inputStruct, "/tmp/test"); FileInputSplit split2 = new FileInputSplit(ElemType.VERTEX, inputStruct, "/tmp/test"); Assert."<AssertPlaceHolder>"; }
hashCode() { return Objects.hashCode(super.hashCode(), this.type, this.path, this.struct); }
[*] target: assertEquals(split1.hashCode(), split2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( split1. hashCode(), split2. hashCode() )
************************************
************************************
[+] input: IOException { NettyTransportClient client = (NettyTransportClient) this.oneClient(); ConnectionId connectionId = ConnectionId.parseConnectionId(host, port); ConnectionId clientConnectionId = client.connectionId(); Assert."<AssertPlaceHolder>"; }
connectionId() { return this.connectionId; }
[*] target: assertEquals(connectionId, clientConnectionId)
[-] pred: org. junit. Assert. assertEquals ( connectionId, clientConnectionId )
************************************
************************************
[+] input: testEstimate() { OptimizationContext optimizationContext = mock(OptimizationContext.class); when(optimizationContext.getConfiguration()).thenReturn(new Configuration());  CardinalityEstimator partialEstimator1 = new DefaultCardinalityEstimator(0.9, 1, false, cards -> cards[0] * 2); CardinalityEstimator partialEstimator2 = new DefaultCardinalityEstimator(0.8, 1, false, cards -> cards[0] * 3); CardinalityEstimator estimator = new AggregatingCardinalityEstimator( Arrays.asList(partialEstimator1, partialEstimator2) );  CardinalityEstimate inputEstimate = new CardinalityEstimate(10, 100, 0.3); CardinalityEstimate outputEstimate = estimator.estimate(optimizationContext, inputEstimate); CardinalityEstimate expectedEstimate = new CardinalityEstimate(2 * 10, 2 * 100, 0.3 * 0.9);  Assert."<AssertPlaceHolder>"; }
estimate(OptimizationContext optimizationContext, CardinalityEstimate... inputEstimates) { // Simply use the estimate with the highest correctness probability. // TODO: Check if this is a good way. There are other palpable approaches (e.g., weighted average). return this.alternativeEstimators.stream() .map(alternativeEstimator -> alternativeEstimator.estimate(optimizationContext, inputEstimates)) .sorted((estimate1, estimate2) -> Double.compare(estimate2.getCorrectnessProbability(), estimate1.getCorrectnessProbability())) .findFirst() .orElseThrow(IllegalStateException::new); }
[*] target: assertEquals(expectedEstimate, outputEstimate)
[-] pred: org. junit. Assert. assertEquals ( expectedEstimate, outputEstimate )
************************************
************************************
[+] input: testDAGShapedSubplan() { // _/-\_ //  \ / final DataSetType<String> stringDataSetType = DataSetType.createDefault(String.class); TestMapOperator<String, String> map1 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map1.setName("map1"); TestMapOperator<String, String> map2 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map2.setName("map2"); TestMapOperator<String, String> map3 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map3.setName("map3"); TestJoin<String, String, String> join1 = new TestJoin<>(stringDataSetType, stringDataSetType, stringDataSetType); join1.setName("join1"); TestMapOperator<String, String> map4 = new TestMapOperator<>(stringDataSetType, stringDataSetType); map4.setName("map4");  map1.connectTo(0, map2, 0); map1.connectTo(0, map3, 0); map2.connectTo(0, join1, 0); map3.connectTo(0, join1, 1); join1.connectTo(0, map4, 0);  Subplan subplan = (Subplan) Subplan.wrap(map1, map4); OptimizationContext optimizationContext = new DefaultOptimizationContext(this.job, subplan); final OptimizationContext.OperatorContext subplanCtx = optimizationContext.getOperatorContext(subplan); final CardinalityEstimate inputCardinality = new CardinalityEstimate(10, 100, 0.9d); subplanCtx.setInputCardinality(0, inputCardinality); subplan.propagateInputCardinality(0, subplanCtx);  final CardinalityPusher pusher = SubplanCardinalityPusher.createFor(subplan, this.configuration); pusher.push(subplanCtx, this.configuration);  final CardinalityEstimate outputCardinality = subplanCtx.getOutputCardinality(0); final CardinalityEstimate expectedCardinality = new CardinalityEstimate(10 * 10, 100 * 100, 0.9d * 0.7d); Assert."<AssertPlaceHolder>"; }
createFor(OperatorContainer container, Configuration configuration) { final CompositeOperator compositeOperator = container.toOperator(); final InputSlot<?>[] outerInputs = compositeOperator.getAllInputs(); final List<InputSlot<?>> innerInputs = Arrays.stream(outerInputs) .flatMap(inputSlot -> container.followInput(inputSlot).stream()) .collect(Collectors.toList()); final Collection<Operator> sourceOperators = compositeOperator.isSource() ? Collections.singleton(container.getSource()) : Collections.emptySet(); final CardinalityEstimationTraversal traversal = CardinalityEstimationTraversal.createPushTraversal( innerInputs, sourceOperators, configuration);  return new SubplanCardinalityPusher(traversal, compositeOperator); }
[*] target: assertEquals(expectedCardinality, outputCardinality)
[-] pred: org. junit. Assert. assertEquals ( expectedCardinality, outputCardinality )
************************************
************************************
[+] input: shouldFailOnInvalidInput() { Collection<String> expressions = Arrays.asList( // TODO: For some reason this is not failing on my machine //"2x", "f(x,)", "~3", "", "*2", "f(3, x" ); for (String expression : expressions) { boolean isFailed = false; try { ExpressionBuilder.parse(expression); } catch (ParseException e) { isFailed = true; } finally { Assert."<AssertPlaceHolder>"; } } }
parse(String specification) throws ParseException { MathExLexer lexer = new MathExLexer(new ANTLRInputStream(specification)); lexer.removeErrorListeners(); lexer.addErrorListener(new BaseErrorListener() { @Override public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) { throw new ParseException("Syntax error.", e); } }); MathExParser parser = new MathExParser(new CommonTokenStream(lexer));  // Suppress console output on errors. Throw exceptions instead. parser.removeErrorListeners(); parser.addErrorListener(new BaseErrorListener() { @Override public void syntaxError(Recognizer<?, ?> recognizer, Object o, int i, int i1, String s, RecognitionException e) { throw new ParseException("Syntax error.", e); }  }); MathExParser.ExpressionContext expressionContext = parser.expression();  return new ExpressionBuilder().visit(expressionContext); }
[*] target: assertTrue(isFailed)
[-] pred: org. junit. Assert. assertTrue ( isFailed )
************************************
************************************
[+] input: Exception { final String topicPath = DEFAULT_TENANT + InlongConstants.SLASH + DEFAULT_NAMESPACE + InlongConstants.SLASH + "testGetPartitionedTopicMetadata"; PulsarUtils.createPartitionedTopic(client, pulsarCluster, topicPath, DEFAULT_PARTITIONS_NUM); Thread.sleep(500); PulsarTopicMetadata metadata = PulsarUtils.getPartitionedTopicMetadata(client, pulsarCluster, topicPath); "<AssertPlaceHolder>"; }
getPartitionedTopicMetadata(RestTemplate restTemplate, PulsarClusterInfo clusterInfo, String topicPath) throws Exception { return HttpUtils.request(restTemplate, clusterInfo.getAdminUrls(QUERY_PERSISTENT_PATH + "/" + topicPath + "/partitions"), HttpMethod.GET, null, getHttpHeaders(clusterInfo.getToken()), PulsarTopicMetadata.class); }
[*] target: assertNotNull(metadata)
[-] pred: org. junit. Assert. assertNotNull ( metadata )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.COLLECTION_NAME, "STRING METADATA FROM 'collection_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'database_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'op_ts' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_DEBEZIUM, "BYTES METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_DEBEZIUM, "STRING METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); MongoExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.COLLECTION_NAME, MetaField.DATABASE_NAME, MetaField.OP_TS, MetaField.DATA_DEBEZIUM, MetaField.DATA_BYTES_DEBEZIUM, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'meta.database_name' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'meta.schema_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.op_ts' VIRTUAL"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'meta.op_type' VIRTUAL"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES, "BYTES METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'meta.is_ddl' VIRTUAL"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.ts' VIRTUAL"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'meta.sql_type' VIRTUAL"); formatMap.put(MetaField.ORACLE_TYPE, "MAP<STRING, STRING> METADATA FROM 'meta.oracle_type' VIRTUAL"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'meta.pk_names' VIRTUAL"); OracleExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS, MetaField.OP_TYPE, MetaField.DATA, MetaField.DATA_BYTES, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL, MetaField.IS_DDL, MetaField.TS, MetaField.SQL_TYPE, MetaField.ORACLE_TYPE, MetaField.PK_NAMES); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'meta.table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'meta.database_name' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'meta.schema_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.op_ts' VIRTUAL"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'meta.op_type' VIRTUAL"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_DEBEZIUM, "STRING METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES, "BYTES METADATA FROM 'meta.data' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_CANAL, "BYTES METADATA FROM 'meta.data_canal' VIRTUAL"); formatMap.put(MetaField.DATA_BYTES_DEBEZIUM, "BYTES METADATA FROM 'meta.data_debezium' VIRTUAL"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'meta.is_ddl' VIRTUAL"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'meta.ts' VIRTUAL"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'meta.sql_type' VIRTUAL"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'meta.pk_names' VIRTUAL"); PostgresExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS, MetaField.OP_TYPE, MetaField.DATA, MetaField.DATA_BYTES, MetaField.DATA_CANAL, MetaField.DATA_BYTES_CANAL, MetaField.DATA_DEBEZIUM, MetaField.DATA_BYTES_DEBEZIUM, MetaField.IS_DDL, MetaField.TS, MetaField.SQL_TYPE, MetaField.PK_NAMES); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'table_name' VIRTUAL"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'database_name' VIRTUAL"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'op_ts' VIRTUAL"); formatMap.put(MetaField.SCHEMA_NAME, "STRING METADATA FROM 'schema_name' VIRTUAL"); SqlServerExtractNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.DATABASE_NAME, MetaField.SCHEMA_NAME, MetaField.OP_TS); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testMetaFields() { Map<MetaField, String> formatMap = new HashMap<>(); formatMap.put(MetaField.PROCESS_TIME, "AS PROCTIME()"); formatMap.put(MetaField.DATA_CANAL, "STRING METADATA FROM 'value.data_canal'"); formatMap.put(MetaField.DATA, "STRING METADATA FROM 'value.data_canal'"); formatMap.put(MetaField.TABLE_NAME, "STRING METADATA FROM 'value.table'"); formatMap.put(MetaField.DATABASE_NAME, "STRING METADATA FROM 'value.database'"); formatMap.put(MetaField.OP_TYPE, "STRING METADATA FROM 'value.type'"); formatMap.put(MetaField.OP_TS, "TIMESTAMP_LTZ(3) METADATA FROM 'value.event-timestamp'"); formatMap.put(MetaField.IS_DDL, "BOOLEAN METADATA FROM 'value.is-ddl'"); formatMap.put(MetaField.TS, "TIMESTAMP_LTZ(3) METADATA FROM 'value.ingestion-timestamp'"); formatMap.put(MetaField.SQL_TYPE, "MAP<STRING, INT> METADATA FROM 'value.sql-type'"); formatMap.put(MetaField.MYSQL_TYPE, "MAP<STRING, STRING> METADATA FROM 'value.mysql-type'"); formatMap.put(MetaField.PK_NAMES, "ARRAY<STRING> METADATA FROM 'value.pk-names'"); formatMap.put(MetaField.BATCH_ID, "BIGINT METADATA FROM 'value.batch-id'"); formatMap.put(MetaField.UPDATE_BEFORE, "ARRAY<MAP<STRING, STRING>> METADATA FROM 'value.update-before'"); KafkaLoadNode node = getTestObject(); boolean formatEquals = true; for (MetaField metaField : node.supportedMetaFields()) { formatEquals = node.format(metaField).equals(formatMap.get(metaField)); if (!formatEquals) { break; } } Assert."<AssertPlaceHolder>"; }
supportedMetaFields() { return EnumSet.of(MetaField.PROCESS_TIME, MetaField.TABLE_NAME, MetaField.OP_TYPE, MetaField.DATABASE_NAME, MetaField.SQL_TYPE, MetaField.PK_NAMES, MetaField.TS, MetaField.OP_TS, MetaField.IS_DDL, MetaField.MYSQL_TYPE, MetaField.BATCH_ID, MetaField.UPDATE_BEFORE, MetaField.DATA_CANAL, MetaField.DATA); }
[*] target: assertTrue(formatEquals)
[-] pred: org. junit. Assert. assertTrue ( formatEquals )
************************************
************************************
[+] input: testSchemaDeserializationSchema() { final JsonRowDataDeserializationSchema expectedDeser = JsonRowDataDeserializationSchema.builder(PHYSICAL_TYPE, InternalTypeInfo.of(PHYSICAL_TYPE)).build();  final DynamicTableSource actualSource = createTableSource(SCHEMA, getAllOptions()); assert actualSource instanceof TestDynamicTableFactory.DynamicTableSourceMock; TestDynamicTableFactory.DynamicTableSourceMock scanSourceMock = (TestDynamicTableFactory.DynamicTableSourceMock) actualSource;  DeserializationSchema<RowData> actualDeser = scanSourceMock.valueFormat.createRuntimeDecoder( ScanRuntimeProviderContext.INSTANCE, SCHEMA.toPhysicalRowDataType());  "<AssertPlaceHolder>"; }
createRuntimeDecoder( DynamicTableSource.Context context, DataType physicalDataType) { final RowType rowType = (RowType) physicalDataType.getLogicalType(); final TypeInformation<RowData> rowDataTypeInfo = context.createTypeInformation(physicalDataType); JsonRowDataDeserializationSchema.Builder builder = JsonRowDataDeserializationSchema.builder(rowType, rowDataTypeInfo); return builder .setFailOnMissingField(formatOptions.get(TextFormatOptions.FAIL_ON_MISSING_FIELD)) .setIgnoreParseErrors(formatOptions.get(TableFormatOptions.IGNORE_ERRORS)) .setTimestampFormat(formatOptions.get(TextFormatOptions.TIMESTAMP_FORMAT)) .setCharset(formatOptions.get(TextFormatOptions.CHARSET)) .setObjectMapperConfig(formatOptions) .build(); }
[*] target: assertEquals(expectedDeser, actualDeser)
[-] pred: org. junit. Assert. assertEquals ( expectedDeser, actualDeser )
************************************
************************************
[+] input: testSchemaSerializationSchema() { final JsonRowDataSerializationSchema expectedSer = JsonRowDataSerializationSchema.builder(PHYSICAL_TYPE).build();  final DynamicTableSink actualSink = createTableSink(SCHEMA, getAllOptions()); assert actualSink instanceof TestDynamicTableFactory.DynamicTableSinkMock; TestDynamicTableFactory.DynamicTableSinkMock sinkMock = (TestDynamicTableFactory.DynamicTableSinkMock) actualSink;  SerializationSchema<RowData> actualSer = sinkMock.valueFormat.createRuntimeEncoder( new SinkRuntimeProviderContext(false), PHYSICAL_DATA_TYPE);  "<AssertPlaceHolder>"; }
createRuntimeEncoder( DynamicTableSink.Context context, DataType physicalDataType) { RowType rowType = (RowType) physicalDataType.getLogicalType(); JsonRowDataSerializationSchema.Builder builder = JsonRowDataSerializationSchema.builder(rowType); return builder .setMapNullKeyMode(formatOptions.get(TextFormatOptions.MAP_NULL_KEY_MODE)) .setMapNullKeyLiteral(formatOptions.get(TextFormatOptions.MAP_NULL_KEY_LITERAL)) .setTimestampFormat(formatOptions.get(TextFormatOptions.TIMESTAMP_FORMAT)) .setCharset(formatOptions.get(TextFormatOptions.CHARSET)) .setIgnoreErrors(formatOptions.get(TableFormatOptions.IGNORE_ERRORS)) .setObjectMapperConfig(formatOptions) .build(); }
[*] target: assertEquals(expectedSer, actualSer)
[-] pred: org. junit. Assert. assertEquals ( expectedSer, actualSer )
************************************
************************************
[+] input: Exception { Map<String, String> map = new HashMap<String, String>(); map.put("h1", "1");  PowerMockito.doReturn(401).when(connection).getResponseCode(); PowerMockito.doReturn(new ByteArrayOutputStream()).when(connection).getOutputStream(); PowerMockito.doReturn(new ByteArrayInputStream("{}".getBytes())).when(connection).getInputStream(); HttpClientTest response = new HttpClient("http://localhost") .path("/api") .param(map) .header(map) .timeout(100) .body(new ByteArrayInputStream(new byte[]{})) .get(HttpClientTest.class); Assert."<AssertPlaceHolder>"; }
get(Class<T> returnType) { return requestRetryTimes("GET", returnType); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: Exception { Map<String, String> map = new HashMap<String, String>(); map.put("h1", "1");  PowerMockito.doReturn(401).when(connection).getResponseCode(); PowerMockito.doReturn(new ByteArrayOutputStream()).when(connection).getOutputStream(); PowerMockito.doReturn(new ByteArrayInputStream("{}".getBytes())).when(connection).getInputStream();  InputStream inputStreamBody = Mockito.spy(new ByteArrayInputStream(new byte[]{})); Mockito.doThrow(new IOException()).when(inputStreamBody).close();  HttpClientTest response = new HttpClient("http://localhost") .path("/api") .param(map) .header(map) .timeout(100) .body(inputStreamBody) .post(HttpClientTest.class); Assert."<AssertPlaceHolder>"; }
post(Class<T> returnType) { return requestRetryTimes("POST", returnType); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: Exception { File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.isAbsolute()).thenReturn(true);  DirFileScanner scanner = Mockito.mock(DirFileScanner.class); PowerMockito.whenNew(DirFileScanner.class).withAnyArguments().thenReturn(scanner); Mockito.when(scanner.scan(Mockito.anyString())).thenReturn(Arrays.asList("f1"));  Artifact artifact = new Artifact(); artifact.setPatternType(PatternType.DIR);  FileUploader fileUploader = new FileUploader() { @Override public void upload(File file, String toFile) { } };  int filesCount = new JobArtifact("u1", "ws", new SaAsyncLogger("uuid", true)) .artifact(artifact) .fileUploader(fileUploader) .toDir("d1") .upload();  Assert."<AssertPlaceHolder>"; }
upload() { FileScanner scanner; String fromDir = this.ws; switch (artifact.getPatternType()) { case DIR: if (new File(artifact.getFilePattern()).isAbsolute()) { fromDir = artifact.getFilePattern(); } else { fromDir = fromDir + File.separator + artifact.getFilePattern(); } // 当路径所指的目标是单文件时，直接读取单上传文件。 if (new File(fromDir).exists() && new File(fromDir).isFile()) { String fileName = FilenameUtils.getName(FilenameUtils.normalizeNoEndSeparator(fromDir)); String toFile = uuid + "/" + toDir + "/" + fileName; jobAsyncLogger.log("INFO", "single file uploading..."); fileUploader.upload(new File(fromDir), toFile); return 1; } scanner = new DirFileScanner(artifact.getFilePattern()); break; case ANT: scanner = new AntFileScanner(artifact.getFilePattern()); break; default: throw new AgentException("Not supported file pattern type:" + artifact.getPatternType()); } List<String> files = scanner.scan(ws); if (CollectionUtils.isEmpty(files)) { return 0; } new FilesUploader(jobAsyncLogger) .fromDir(fromDir) .files(files) .toDir(uuid + "/" + toDir) .fileUploader(fileUploader).upload(); return files.size(); }
[*] target: assertEquals(1, filesCount)
[-] pred: org. junit. Assert. assertEquals ( 1, filesCount )
************************************
************************************
[+] input: Exception {  File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.isAbsolute()).thenReturn(false); Mockito.when(file.exists()).thenReturn(true); Mockito.when(file.isFile()).thenReturn(true);  DirFileScanner scanner = Mockito.mock(DirFileScanner.class); PowerMockito.whenNew(DirFileScanner.class).withAnyArguments().thenReturn(scanner); Mockito.when(scanner.scan(Mockito.anyString())).thenReturn(Arrays.asList("f1"));  Artifact artifact = new Artifact(); artifact.setFilePattern("/sss/sss"); artifact.setPatternType(PatternType.DIR); new SaAsyncLogger("uuid", true); FileUploader fileUploader = new FileUploader() { @Override public void upload(File file, String toFile) { } };  int filesCount = new JobArtifact("u1", "ws", new SaAsyncLogger("uuid", true)) .artifact(artifact) .fileUploader(fileUploader) .toDir("d1") .upload();  Assert."<AssertPlaceHolder>"; }
upload() { FileScanner scanner; String fromDir = this.ws; switch (artifact.getPatternType()) { case DIR: if (new File(artifact.getFilePattern()).isAbsolute()) { fromDir = artifact.getFilePattern(); } else { fromDir = fromDir + File.separator + artifact.getFilePattern(); } // 当路径所指的目标是单文件时，直接读取单上传文件。 if (new File(fromDir).exists() && new File(fromDir).isFile()) { String fileName = FilenameUtils.getName(FilenameUtils.normalizeNoEndSeparator(fromDir)); String toFile = uuid + "/" + toDir + "/" + fileName; jobAsyncLogger.log("INFO", "single file uploading..."); fileUploader.upload(new File(fromDir), toFile); return 1; } scanner = new DirFileScanner(artifact.getFilePattern()); break; case ANT: scanner = new AntFileScanner(artifact.getFilePattern()); break; default: throw new AgentException("Not supported file pattern type:" + artifact.getPatternType()); } List<String> files = scanner.scan(ws); if (CollectionUtils.isEmpty(files)) { return 0; } new FilesUploader(jobAsyncLogger) .fromDir(fromDir) .files(files) .toDir(uuid + "/" + toDir) .fileUploader(fileUploader).upload(); return files.size(); }
[*] target: assertEquals(1, filesCount)
[-] pred: org. junit. Assert. assertEquals ( 1, filesCount )
************************************
************************************
[+] input: Exception { HttpDownloader downloader = Mockito.spy(new HttpDownloader()); PowerMockito.whenNew(HttpDownloader.class).withAnyArguments().thenReturn(downloader); Mockito.doNothing().when(downloader).download(); File file = Mockito.mock(File.class); PowerMockito.whenNew(File.class).withAnyArguments().thenReturn(file); Mockito.when(file.exists()).thenReturn(true); Mockito.when(file.canExecute()).thenReturn(false); Mockito.when(file.renameTo(Mockito.any(File.class))).thenReturn(true); PowerMockito.mock(FileUtils.class, new DoesNothing()); boolean result = UpgraderExecutor.prepare(Context.getServerContext().getAgentUpdateInfo()); Assert."<AssertPlaceHolder>"; }
prepare(SystemCmdInfoFactory.AgentUpdateInfo updateInfo) {  log("upgrade_prepare_start"); boolean hasJar = upgradeJarOnce(updateInfo); boolean javaExecutable = setExecutable4Java(); if (!hasJar) { log("upgrade_prepare_fail_no_jar"); return false; }  if (!javaExecutable) { log("upgrade_prepare_fail_java_cannot_executable"); return false; } log("upgrade_prepare_finish"); return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { PowerMockito.mockStatic(Watcher.class); String[] args = {"echo hello"}; Process process = PowerMockito.mock(Process.class); PowerMockito.mockStatic(Runtime.class); PowerMockito.when(Runtime.getRuntime().exec(args)).thenReturn(process); UpgradeStatus upgradeStatus = new UpgradeStatus(); PowerMockito.when(Watcher.watch(process)).thenReturn(upgradeStatus); UpgradeStatus result = UpgraderExecutor.executeUpgrade(args); Assert."<AssertPlaceHolder>"; }
executeUpgrade(String[] cmd) {  try { // 守护进程启动，则不自动更新；直接退出，由守护进程拉起 if (Launcher.isSuperviseRun()) { log("upgrade_execute_success_agent_run_by_supervise"); return new UpgradeStatus(true, true); } Process process = Runtime.getRuntime().exec(cmd); return Watcher.watch(process); } catch (Throwable e) { log("upgrade_execute_fail_error_" + e.getMessage() + "\n" + ExceptionUtils.getFullStackTrace(e)); return null; } }
[*] target: assertEquals(upgradeStatus, result)
[-] pred: org. junit. Assert. assertEquals ( upgradeStatus, result )
************************************
************************************
[+] input: testLongValue() { Currency instance = new Currency(1234567890123456L); long expResult = 1234567890123456L; long result = instance.longValue(); "<AssertPlaceHolder>"; }
longValue() { return embeddedValue.longValue(); }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: testCompareTo_Currency() { Currency anotherCurrency = new Currency(1234567890123456L); Currency instance = new Currency(1234567890000000L); int expResult = -1; int result = instance.compareTo(anotherCurrency); "<AssertPlaceHolder>"; }
compareTo(Currency anotherCurrency) { return embeddedValue.compareTo(anotherCurrency.getLongValue()); }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: testEquals() { Object o = new Object(); Currency instance = new Currency(1234567890123456L); boolean expResult = false; boolean result = instance.equals(o); "<AssertPlaceHolder>"; }
equals(Object o) { if (o == null) { return false; // Modified EJP 31/8/2023 } else if (o instanceof Currency && compareTo((Currency) o) == 0) { return true; } else { return false; } }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: Exception { Map<String, Object> javagm = this.configMap.get("javagm"); Object testdata = javagm.get("testdata"); String privateKey = (String) ((Map<String, Object>) testdata).get("private-key");  PrivateKey privKey = SM2Util.loadPrivFromString(privateKey, ""); Assert."<AssertPlaceHolder>"; }
loadPrivFromString(String privateKey, String password) throws IOException, OperatorCreationException, PKCSException { return loadPriv(password, () -> new StringReader(privateKey)); }
[*] target: assertNotNull(privKey)
[-] pred: org. junit. Assert. assertNotNull ( privKey )
************************************
************************************
[+] input: test_getmainstr1() { String s = cnid.getmainstr(f); "<AssertPlaceHolder>"; System.out.println(s); }
getmainstr(Faker f) { String cn = f.regexify( "[1-6][1-3][0-2][0-9]21-[1-2]\\d{3}[0-1][0-9][0-2][0-8]-\\d{3}"); //原理：通过正则表达式生成符合条件的 id，并且排除掉不符合的id。生成不符合的则重新生成。 //正则表达式中，\d 匹配一个数字字符。等价于 [0-9]。 boolean isValid = true; for (String invalidSSNPattern : invalidCNPatterns) { if (cn.matches(invalidSSNPattern)) { isValid = false; break; } } if (!isValid) { cn = getmainstr(f); } return cn; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: test_getmainstr2() { String s = cnid.getmainstr(f); "<AssertPlaceHolder>"; System.out.println(s); }
getmainstr(Faker f) { String cn = f.regexify( "[1-6][1-3][0-2][0-9]21-[1-2]\\d{3}[0-1][0-9][0-2][0-8]-\\d{3}"); //原理：通过正则表达式生成符合条件的 id，并且排除掉不符合的id。生成不符合的则重新生成。 //正则表达式中，\d 匹配一个数字字符。等价于 [0-9]。 boolean isValid = true; for (String invalidSSNPattern : invalidCNPatterns) { if (cn.matches(invalidSSNPattern)) { isValid = false; break; } } if (!isValid) { cn = getmainstr(f); } return cn; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: getCurrentGtidLastCommitOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtidLastCommit();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtidLastCommit() { return gtidMap.get(CURRENT_GTID_LAST_COMMIT); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getCurrentGtidOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtid();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtid() { return gtidMap.get(CURRENT_GTID_STRING); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getCurrentGtidSnOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getCurrentGtidSn();  // Assert result Assert."<AssertPlaceHolder>"; }
getCurrentGtidSn() { return gtidMap.get(CURRENT_GTID_SN); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getEventLenOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getEventLen();  // Assert result Assert."<AssertPlaceHolder>"; }
getEventLen() { return eventLen; }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: getFlagsOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getFlags();  // Assert result Assert."<AssertPlaceHolder>"; }
getFlags() { return flags; }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: getGtidSetStrOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getGtidSetStr();  // Assert result Assert."<AssertPlaceHolder>"; }
getGtidSetStr() { return gtidMap.get(GTID_SET_STRING); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getLogFileNameOutputNull() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final String actual = objectUnderTest.getLogFileName();  // Assert result Assert."<AssertPlaceHolder>"; }
getLogFileName() { return logFileName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getTypeOutputZero() {  // Arrange final LogHeader objectUnderTest = new LogHeader(0);  // Act final int actual = objectUnderTest.getType();  // Assert result Assert."<AssertPlaceHolder>"; }
getType() { return type; }
[*] target: assertEquals(0, actual)
[-] pred: org. junit. Assert. assertEquals ( 0, actual )
************************************
************************************
[+] input: testParse() { Map<String, MysqlGTIDSet> cases = new HashMap<String, MysqlGTIDSet>(5); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 2))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3:4", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 5))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3:7-9", buildForTest(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4, 7, 10))); cases.put("726757ad-4455-11e8-ae04-0242ac110002:1-3,726757ad-4455-11e8-ae04-0242ac110003:4", buildForTest(Arrays.asList(new Material("726757ad-4455-11e8-ae04-0242ac110002", 1, 4), new Material("726757ad-4455-11e8-ae04-0242ac110003", 4, 5))));  for (Map.Entry<String, MysqlGTIDSet> entry : cases.entrySet()) { MysqlGTIDSet expected = entry.getValue(); MysqlGTIDSet actual = MysqlGTIDSet.parse(entry.getKey());  "<AssertPlaceHolder>"; } }
parse(String gtidData) { Map<String, UUIDSet> m;  if (gtidData == null || gtidData.length() < 1) { m = new HashMap<String, UUIDSet>(); } else { // 存在多个GTID时会有回车符 String[] uuidStrs = gtidData.replaceAll("\n", "").split(","); m = new HashMap<String, UUIDSet>(uuidStrs.length); for (int i = 0; i < uuidStrs.length; i++) { UUIDSet uuidSet = UUIDSet.parse(uuidStrs[i]); m.put(uuidSet.SID.toString(), uuidSet); } }  MysqlGTIDSet gs = new MysqlGTIDSet(); gs.sets = m;  return gs; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: getOriSchemaNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getOriSchemaName();  // Assert result Assert."<AssertPlaceHolder>"; }
getOriSchemaName() { return oriSchemaName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getOriTableNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getOriTableName();  // Assert result Assert."<AssertPlaceHolder>"; }
getOriTableName() { return oriTableName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getRenameTableResultOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final DdlResult actual = objectUnderTest.getRenameTableResult();  // Assert result Assert."<AssertPlaceHolder>"; }
getRenameTableResult() { return renameTableResult; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getSchemaNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getSchemaName();  // Assert result Assert."<AssertPlaceHolder>"; }
getSchemaName() { return schemaName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getTableNameOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final String actual = objectUnderTest.getTableName();  // Assert result Assert."<AssertPlaceHolder>"; }
getTableName() { return tableName; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: getTypeOutputNull() {  // Arrange final DdlResult objectUnderTest = new DdlResult();  // Act final EventType actual = objectUnderTest.getType();  // Assert result Assert."<AssertPlaceHolder>"; }
getType() { return type; }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: NoSuchAlgorithmException { byte[] seed = { 1, 2, 3, 4, 5, 6, 7, 8 }; // String str = "e3619321c1a937c46a0d8bd1dac39f93b27d4458"; // canal // passwd String str = SecurityUtil.scrambleGenPass("canal".getBytes()); byte[] client = SecurityUtil.scramble411("canal".getBytes(), seed); boolean check = SecurityUtil.scrambleServerAuth(client, SecurityUtil.hexStr2Bytes(str), seed); Assert."<AssertPlaceHolder>"; }
hexStr2Bytes(String src) { if (src == null) { return null; } int offset = 0; int length = src.length(); if (length == 0) { return new byte[0]; }  boolean odd = length << 31 == Integer.MIN_VALUE; byte[] bs = new byte[odd ? (length + 1) >> 1 : length >> 1]; for (int i = offset, limit = offset + length; i < limit; ++i) { char high, low; if (i == offset && odd) { high = '0'; low = src.charAt(i); } else { high = src.charAt(i); low = src.charAt(++i); } int b; switch (high) { case '0': b = 0; break; case '1': b = 0x10; break; case '2': b = 0x20; break; case '3': b = 0x30; break; case '4': b = 0x40; break; case '5': b = 0x50; break; case '6': b = 0x60; break; case '7': b = 0x70; break; case '8': b = 0x80; break; case '9': b = 0x90; break; case 'a': case 'A': b = 0xa0; break; case 'b': case 'B': b = 0xb0; break; case 'c': case 'C': b = 0xc0; break; case 'd': case 'D': b = 0xd0; break; case 'e': case 'E': b = 0xe0; break; case 'f': case 'F': b = 0xf0; break; default: throw new IllegalArgumentException("illegal hex-string: " + src); } switch (low) { case '0': break; case '1': b += 1; break; case '2': b += 2; break; case '3': b += 3; break; case '4': b += 4; break; case '5': b += 5; break; case '6': b += 6; break; case '7': b += 7; break; case '8': b += 8; break; case '9': b += 9; break; case 'a': case 'A': b += 10; break; case 'b': case 'B': b += 11; break; case 'c': case 'C': b += 12; break; case 'd': case 'D': b += 13; break; case 'e': case 'E': b += 14; break; case 'f': case 'F': b += 15; break; default: throw new IllegalArgumentException("illegal hex-string: " + src); } bs[(i - offset) >> 1] = (byte) b; } return bs; }
[*] target: assertTrue(check)
[-] pred: org. junit. Assert. assertTrue ( check )
************************************
************************************
[+] input: evaluateWhenExpressionVarIsUndefined() { String expression = "dummy.intValue"; Map<String, Object> vars = new HashMap<>(); ExpressionEvaluator expressionEvaluator = new JexlExpressionEvaluatorNoThreadLocal(); Object result = expressionEvaluator.evaluate( expression, vars ); "<AssertPlaceHolder>"; }
evaluate(String expression, Map<String, Object> context) { JexlContext jexlContext = new MapContext(context); try { JexlExpression jexlExpression = expressionMap.get(expression); if (jexlExpression == null) { jexlExpression = jexl.createExpression(expression); expressionMap.put(expression, jexlExpression); } return jexlExpression.evaluate(jexlContext); } catch (Exception e) { throw new EvaluationException("An error occurred when evaluating expression " + expression, e); // JxlsLogger not needed here. } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: evaluateWhenExpressionVarIsUndefined() { String expression = "dummy.intValue"; Map<String, Object> vars = new HashMap<>(); ExpressionEvaluator expressionEvaluator = new JexlExpressionEvaluator(); Object result = expressionEvaluator.evaluate( expression, vars ); "<AssertPlaceHolder>"; }
evaluate(String expression, Map<String, Object> context) { JexlContext jexlContext = new MapContext(context); try { Map<String, JexlExpression> expressionMap = expressionMapThreadLocal.get(); JexlExpression jexlExpression = expressionMap.get(expression); if (jexlExpression == null) { jexlExpression = getJexlEngine().createExpression(expression); expressionMap.put(expression, jexlExpression); } return jexlExpression.evaluate(jexlContext); } catch (Exception e) { throw new EvaluationException("An error occurred when evaluating expression " + expression, e); // JxlsLogger not needed here. } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testConnectionDelayWithNoExponentialBackoff() { long now = time.milliseconds(); long delay = clientWithNoExponentialBackoff.connectionDelay(node, now);  "<AssertPlaceHolder>"; }
connectionDelay(Node node, long now) { return connectionStates.connectionDelay(node.idString(), now); }
[*] target: assertEquals(0, delay)
[-] pred: org. junit. Assert. assertEquals ( 0, delay )
************************************
************************************
[+] input: testBootstrap() { String ipAddress = "140.211.11.105"; String hostName = "www.example.com"; Cluster cluster = Cluster.bootstrap(Arrays.asList( new InetSocketAddress(ipAddress, 9002), new InetSocketAddress(hostName, 9002) )); Set<String> expectedHosts = Utils.mkSet(ipAddress, hostName); Set<String> actualHosts = new HashSet<>(); for (Node node : cluster.nodes()) actualHosts.add(node.host()); "<AssertPlaceHolder>"; }
nodes() { return this.nodes; }
[*] target: assertEquals(expectedHosts, actualHosts)
[-] pred: org. junit. Assert. assertEquals ( expectedHosts, actualHosts )
************************************
************************************
[+] input: toRst() { final ConfigDef def = new ConfigDef() .define("opt1", Type.STRING, "a", ValidString.in("a", "b", "c"), Importance.HIGH, "docs1") .define("opt2", Type.INT, Importance.MEDIUM, "docs2") .define("opt3", Type.LIST, Arrays.asList("a", "b"), Importance.LOW, "docs3");  final String expectedRst = "" + "``opt2``\n" + "  docs2\n" + "\n" + "  * Type: int\n" + "  * Importance: medium\n" + "\n" + "``opt1``\n" + "  docs1\n" + "\n" + "  * Type: string\n" + "  * Default: a\n" + "  * Valid Values: [a, b, c]\n" + "  * Importance: high\n" + "\n" + "``opt3``\n" + "  docs3\n" + "\n" + "  * Type: list\n" + "  * Default: a,b\n" + "  * Importance: low\n" + "\n";  "<AssertPlaceHolder>"; }
toRst() { StringBuilder b = new StringBuilder(); for (ConfigKey key : sortedConfigs()) { if (key.internalConfig) { continue; } getConfigKeyRst(key, b); b.append("\n"); } return b.toString(); }
[*] target: assertEquals(expectedRst, def.toRst())
[-] pred: org. junit. Assert. assertEquals ( expectedRst, def. toRst ( ) )
************************************
************************************
[+] input: testRequestHeader() { RequestHeader header = new RequestHeader(ApiKeys.FIND_COORDINATOR, (short) 1, "", 10); ByteBuffer buffer = toBuffer(header.toStruct()); RequestHeader deserialized = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { try { short apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); Schema schema = schema(apiKey, apiVersion); buffer.rewind(); return new RequestHeader(schema.read(buffer)); } catch (InvalidRequestException e) { throw e; } catch (Throwable  ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + buffer.getShort(0), ex); } }
[*] target: assertEquals(header, deserialized)
[-] pred: org. junit. Assert. assertEquals ( header, deserialized )
************************************
************************************
[+] input: Exception { String expectedMesssage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001";  Map<String, String> extensions = new HashMap<>(); extensions.put("nineteen", "42"); OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse("123.345.567", new SaslExtensions(extensions));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (extensions.length() > 0) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(expectedMesssage, message)
[-] pred: org. junit. Assert. assertEquals ( expectedMesssage, message )
************************************
************************************
[+] input: Exception { String serverMessage = "n,,\u0001auth=Bearer 123.345.567\u0001nineteen=42\u0001\u0001"; OAuthBearerClientInitialResponse response = new OAuthBearerClientInitialResponse(serverMessage.getBytes(StandardCharsets.UTF_8));  String message = new String(response.toBytes(), StandardCharsets.UTF_8);  "<AssertPlaceHolder>"; }
toBytes() { String authzid = authorizationId.isEmpty() ? "" : "a=" + authorizationId; String extensions = extensionsMessage(); if (extensions.length() > 0) extensions = SEPARATOR + extensions;  String message = String.format("n,%s,%sauth=Bearer %s%s%s%s", authzid, SEPARATOR, tokenValue, extensions, SEPARATOR, SEPARATOR);  return message.getBytes(StandardCharsets.UTF_8); }
[*] target: assertEquals(serverMessage, message)
[-] pred: org. junit. Assert. assertEquals ( serverMessage, message )
************************************
************************************
[+] input: testReadUnsignedInt() { ByteBuffer buffer = ByteBuffer.allocate(4); long writeValue = 133444; ByteUtils.writeUnsignedInt(buffer, writeValue); buffer.flip(); long readValue = ByteUtils.readUnsignedInt(buffer); "<AssertPlaceHolder>"; }
readUnsignedInt(ByteBuffer buffer) { return buffer.getInt() & 0xffffffffL; }
[*] target: assertEquals(writeValue, readValue)
[-] pred: org. junit. Assert. assertEquals ( writeValue, readValue )
************************************
************************************
[+] input: returnNullWithApiVersionMismatch() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().setNodeApiVersions(NodeApiVersions.create()); env.kafkaClient().prepareResponse(createTopicResponseWithUnsupportedVersion(newTopic)); TopicAdmin admin = new TopicAdmin(null, env.adminClient()); boolean created = admin.createTopic(newTopic); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred: org. junit. Assert. assertFalse ( created )
************************************
************************************
[+] input: returnNullWithClusterAuthorizationFailure() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(createTopicResponseWithClusterAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(null, env.adminClient()); boolean created = admin.createTopic(newTopic); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred: org. junit. Assert. assertFalse ( created )
************************************
************************************
[+] input: shouldReturnFalseWhenSuppliedNullTopicDescription() { Cluster cluster = createCluster(1); try (MockAdminClient mockAdminClient = new MockAdminClient(cluster.nodes(), cluster.nodeById(0))) { TopicAdmin admin = new TopicAdmin(null, mockAdminClient); boolean created = admin.createTopic(null); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred: org. junit. Assert. assertFalse ( created )
************************************
************************************
[+] input: updateSchemaOfNonStruct() { Object value = new Integer(1); Object updatedValue = SetSchemaMetadata.updateSchemaIn(value, Schema.INT32_SCHEMA); "<AssertPlaceHolder>"; }
updateSchemaIn(Object keyOrValue, Schema updatedSchema) { if (keyOrValue instanceof Struct) { Struct origStruct = (Struct) keyOrValue; Struct newStruct = new Struct(updatedSchema); for (Field field : updatedSchema.fields()) { // assume both schemas have exact same fields with same names and schemas ... newStruct.put(field, origStruct.get(field)); } return newStruct; } return keyOrValue; }
[*] target: assertSame(value, updatedValue)
[-] pred: org. junit. Assert. assertSame ( value, updatedValue )
************************************
************************************
[+] input: testTimeWindowSerdeFrom() { final Windowed<Integer> timeWindowed = new Windowed<>(10, new TimeWindow(0, Long.MAX_VALUE)); final Serde<Windowed<Integer>> timeWindowedSerde = WindowedSerdes.timeWindowedSerdeFrom(Integer.class); final byte[] bytes = timeWindowedSerde.serializer().serialize(topic, timeWindowed); final Windowed<Integer> windowed = timeWindowedSerde.deserializer().deserialize(topic, bytes); Assert."<AssertPlaceHolder>"; }
timeWindowedSerdeFrom(final Class<T> type) { return new TimeWindowedSerde<>(Serdes.serdeFrom(type)); }
[*] target: assertEquals(timeWindowed, windowed)
[-] pred: org. junit. Assert. assertEquals ( timeWindowed, windowed )
************************************
************************************
[+] input: testSessionWindowedSerdeFrom() { final Windowed<Integer> sessionWindowed = new Windowed<>(10, new SessionWindow(0, 1)); final Serde<Windowed<Integer>> sessionWindowedSerde = WindowedSerdes.sessionWindowedSerdeFrom(Integer.class); final byte[] bytes = sessionWindowedSerde.serializer().serialize(topic, sessionWindowed); final Windowed<Integer> windowed = sessionWindowedSerde.deserializer().deserialize(topic, bytes); Assert."<AssertPlaceHolder>"; }
sessionWindowedSerdeFrom(final Class<T> type) { return new SessionWindowedSerde<>(Serdes.serdeFrom(type)); }
[*] target: assertEquals(sessionWindowed, windowed)
[-] pred: org. junit. Assert. assertEquals ( sessionWindowed, windowed )
************************************
************************************
[+] input: testCopartitioning() { final Random rand = new Random(); final DefaultPartitioner defaultPartitioner = new DefaultPartitioner(); final WindowedSerializer<Integer> timeWindowedSerializer = new TimeWindowedSerializer<>(intSerializer); final WindowedStreamPartitioner<Integer, String> streamPartitioner = new WindowedStreamPartitioner<>(timeWindowedSerializer);  for (int k = 0; k < 10; k++) { final Integer key = rand.nextInt(); final byte[] keyBytes = intSerializer.serialize(topicName, key);  final String value = key.toString(); final byte[] valueBytes = stringSerializer.serialize(topicName, value);  final Integer expected = defaultPartitioner.partition("topic", key, keyBytes, value, valueBytes, cluster);  for (int w = 1; w < 10; w++) { final TimeWindow window = new TimeWindow(10 * w, 20 * w);  final Windowed<Integer> windowedKey = new Windowed<>(key, window); final Integer actual = streamPartitioner.partition(topicName, windowedKey, value, infos.size());  "<AssertPlaceHolder>"; } }  defaultPartitioner.close(); }
partition(final String topic, final Windowed<K> windowedKey, final V value, final int numPartitions) { final byte[] keyBytes = serializer.serializeBaseKey(topic, windowedKey);  // hash the keyBytes to choose a partition return toPositive(Utils.murmur2(keyBytes)) % numPartitions; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { final Map<TopicPartition, Long> expected = writeCheckpoint();  stateManager.initialize(); final Map<TopicPartition, Long> offsets = stateManager.checkpointed(); "<AssertPlaceHolder>"; }
checkpointed() { return Collections.unmodifiableMap(checkpointableOffsets); }
[*] target: assertEquals(expected, offsets)
[-] pred: org. junit. Assert. assertEquals ( expected, offsets )
************************************
************************************
[+] input: shouldLogAWarningIfCheckpointThrowsAnIOException() { final LogCaptureAppender appender = LogCaptureAppender.createAndRegister();  final ProcessorStateManager stateMgr; try { stateMgr = new ProcessorStateManager( taskId, noPartitions, false, stateDirectory, Collections.singletonMap(persistentStore.name(), persistentStoreTopicName), changelogReader, false, logContext); } catch (final IOException e) { e.printStackTrace(); throw new AssertionError(e); } stateMgr.register(persistentStore, persistentStore.stateRestoreCallback);  stateDirectory.clean(); stateMgr.checkpoint(Collections.singletonMap(persistentStorePartition, 10L)); LogCaptureAppender.unregister(appender);  boolean foundExpectedLogMessage = false; for (final LogCaptureAppender.Event event : appender.getEvents()) { if ("WARN".equals(event.getLevel()) && event.getMessage().startsWith("process-state-manager-test Failed to write offset checkpoint file to [") && event.getMessage().endsWith(".checkpoint]") && event.getThrowableInfo().get().startsWith("java.io.FileNotFoundException: ")) {  foundExpectedLogMessage = true; break; } } "<AssertPlaceHolder>"; }
register(final StateStore store, final StateRestoreCallback stateRestoreCallback) { final String storeName = store.name(); log.debug("Registering state store {} to its state manager", storeName);  if (CHECKPOINT_FILE_NAME.equals(storeName)) { throw new IllegalArgumentException(String.format("%sIllegal store name: %s", logPrefix, CHECKPOINT_FILE_NAME)); }  if (stores.containsKey(storeName)) { throw new IllegalArgumentException(String.format("%sStore %s has already been registered.", logPrefix, storeName)); }  // check that the underlying change log topic exist or not final String topic = storeToChangelogTopic.get(storeName); if (topic == null) { stores.put(storeName, store); return; }  final TopicPartition storePartition = new TopicPartition(topic, getPartition(topic));  final RecordConverter recordConverter = converterForStore(store);  if (isStandby) { log.trace("Preparing standby replica of persistent state store {} with changelog topic {}", storeName, topic);  restoreCallbacks.put(topic, stateRestoreCallback); recordConverters.put(topic, recordConverter); } else { log.trace("Restoring state store {} from changelog topic {} at checkpoint {}", storeName, topic, checkpointableOffsets.get(storePartition));  final StateRestorer restorer = new StateRestorer( storePartition, new CompositeRestoreListener(stateRestoreCallback), checkpointableOffsets.get(storePartition), offsetLimit(storePartition), store.persistent(), storeName, recordConverter );  changelogReader.register(restorer); } changelogPartitions.add(storePartition);  stores.put(storeName, store); }
[*] target: assertTrue(foundExpectedLogMessage)
[-] pred: org. junit. Assert. assertTrue ( foundExpectedLogMessage )
************************************
************************************
[+] input: Exception { initializeStateDirectory(false); final TaskId taskId = new TaskId(0, 0); final File taskDirectory = directory.directoryForTask(taskId); "<AssertPlaceHolder>"; }
directoryForTask(final TaskId taskId) { final File taskDir = new File(stateDir, taskId.toString()); if (createStateDirectory && !taskDir.exists() && !taskDir.mkdir()) { throw new ProcessorStateException( String.format("task directory [%s] doesn't exist and couldn't be created", taskDir.getPath())); } return taskDir; }
[*] target: assertFalse(taskDirectory.exists())
[-] pred: org. junit. Assert. assertFalse ( taskDirectory. exists ( ) )
************************************
************************************
[+] input: Exception { initializeStateDirectory(false); final File globalStateDir = directory.globalStateDir(); "<AssertPlaceHolder>"; }
globalStateDir() { final File dir = new File(stateDir, "global"); if (createStateDirectory && !dir.exists() && !dir.mkdir()) { throw new ProcessorStateException( String.format("global state directory [%s] doesn't exist and couldn't be created", dir.getPath())); } return dir; }
[*] target: assertFalse(globalStateDir.exists())
[-] pred: org. junit. Assert. assertFalse ( globalStateDir. exists ( ) )
************************************
************************************
[+] input: shouldNotCheckpointOffsetsOnCommitIfEosIsEnabled() { task = createStatefulTask(createConfig(true), true); task.initializeStateStores(); task.initializeTopology(); task.commit(); final File checkpointFile = new File( stateDirectory.directoryForTask(taskId00), ProcessorStateManager.CHECKPOINT_FILE_NAME );  "<AssertPlaceHolder>"; }
commit() { commit(true); }
[*] target: assertFalse(checkpointFile.exists())
[-] pred: org. junit. Assert. assertFalse ( checkpointFile. exists ( ) )
************************************
************************************
[+] input: shouldCallRocksDbConfigSetter() { MockRocksDbConfigSetter.called = false;  rocksDBStore.openDB(context);  "<AssertPlaceHolder>"; }
openDB(final ProcessorContext context) { // initialize the default rocksdb options  final DBOptions dbOptions = new DBOptions(); final ColumnFamilyOptions columnFamilyOptions = new ColumnFamilyOptions(); userSpecifiedOptions = new RocksDBGenericOptionsToDbOptionsColumnFamilyOptionsAdapter(dbOptions, columnFamilyOptions);  final BlockBasedTableConfig tableConfig = new BlockBasedTableConfig(); tableConfig.setBlockCacheSize(BLOCK_CACHE_SIZE); tableConfig.setBlockSize(BLOCK_SIZE); tableConfig.setFilter(new BloomFilter());  userSpecifiedOptions.optimizeFiltersForHits(); userSpecifiedOptions.setTableFormatConfig(tableConfig); userSpecifiedOptions.setWriteBufferSize(WRITE_BUFFER_SIZE); userSpecifiedOptions.setCompressionType(COMPRESSION_TYPE); userSpecifiedOptions.setCompactionStyle(COMPACTION_STYLE); userSpecifiedOptions.setMaxWriteBufferNumber(MAX_WRITE_BUFFERS); userSpecifiedOptions.setCreateIfMissing(true); userSpecifiedOptions.setErrorIfExists(false); userSpecifiedOptions.setInfoLogLevel(InfoLogLevel.ERROR_LEVEL); // this is the recommended way to increase parallelism in RocksDb // note that the current implementation of setIncreaseParallelism affects the number // of compaction threads but not flush threads (the latter remains one). Also // the parallelism value needs to be at least two because of the code in // https://github.com/facebook/rocksdb/blob/62ad0a9b19f0be4cefa70b6b32876e764b7f3c11/util/options.cc#L580 // subtracts one from the value passed to determine the number of compaction threads // (this could be a bug in the RocksDB code and their devs have been contacted). userSpecifiedOptions.setIncreaseParallelism(Math.max(Runtime.getRuntime().availableProcessors(), 2));  wOptions = new WriteOptions(); wOptions.setDisableWAL(true);  fOptions = new FlushOptions(); fOptions.setWaitForFlush(true);  final Map<String, Object> configs = context.appConfigs(); final Class<RocksDBConfigSetter> configSetterClass = (Class<RocksDBConfigSetter>) configs.get(StreamsConfig.ROCKSDB_CONFIG_SETTER_CLASS_CONFIG);  if (configSetterClass != null) { final RocksDBConfigSetter configSetter = Utils.newInstance(configSetterClass); configSetter.setConfig(name, userSpecifiedOptions, configs); }  if (prepareForBulkload) { userSpecifiedOptions.prepareForBulkLoad(); }  dbDir = new File(new File(context.stateDir(), parentDir), name);  try { Files.createDirectories(dbDir.getParentFile().toPath()); Files.createDirectories(dbDir.getAbsoluteFile().toPath()); } catch (final IOException fatal) { throw new ProcessorStateException(fatal); }  openRocksDB(dbOptions, columnFamilyOptions); open = true; }
[*] target: assertTrue(MockRocksDbConfigSetter.called)
[-] pred: org. junit. Assert. assertTrue ( MockRocksDbConfigSetter.called )
************************************
************************************
[+] input: shouldFlushDirtyEntriesForNamespace() { final ThreadCache cache = new ThreadCache(logContext, 100000, new MockStreamsMetrics(new Metrics())); final List<byte[]> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace1, new ThreadCache.DirtyEntryFlushListener() { @Override public void apply(final List<ThreadCache.DirtyEntry> dirty) { for (final ThreadCache.DirtyEntry dirtyEntry : dirty) { received.add(dirtyEntry.key().get()); } } }); final List<byte[]> expected = Arrays.asList(new byte[]{0}, new byte[]{1}, new byte[]{2}); for (final byte[] bytes : expected) { cache.put(namespace1, Bytes.wrap(bytes), dirtyEntry(bytes)); } cache.put(namespace2, Bytes.wrap(new byte[]{4}), dirtyEntry(new byte[]{4}));  cache.flush(namespace1); "<AssertPlaceHolder>"; }
flush(final String namespace) { numFlushes++;  final NamedCache cache = getCache(namespace); if (cache == null) { return; } cache.flush();  if (log.isTraceEnabled()) { log.trace("Cache stats on flush: #puts={}, #gets={}, #evicts={}, #flushes={}", puts(), gets(), evicts(), flushes()); } }
[*] target: assertEquals(expected, received)
[-] pred: org. junit. Assert. assertEquals ( expected, received )
************************************
************************************
[+] input: shouldNotForwardCleanEntryOnEviction() { final ThreadCache cache = new ThreadCache(logContext, 0, new MockStreamsMetrics(new Metrics())); final List<ThreadCache.DirtyEntry> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace, new ThreadCache.DirtyEntryFlushListener() { @Override public void apply(final List<ThreadCache.DirtyEntry> dirty) { received.addAll(dirty); } }); cache.put(namespace, Bytes.wrap(new byte[]{1}), cleanEntry(new byte[]{0})); "<AssertPlaceHolder>"; }
size() { long size = 0; for (final NamedCache cache : caches.values()) { size += cache.size(); if (isOverflowing(size)) { return Long.MAX_VALUE; } } return size; }
[*] target: assertEquals(0, received.size())
[-] pred: org. junit. Assert. assertEquals ( 0, received. size ( ) )
************************************
************************************
[+] input: shouldParseSingleKeyValuePairString() { final Map<String, String> expectedSinglePairMap = new HashMap<>(); expectedSinglePairMap.put("foo", "bar"); final String singleValueString = "foo=bar"; final Map<String, String> parsedMap = SystemTestUtil.parseConfigs(singleValueString); "<AssertPlaceHolder>"; }
parseConfigs(final String formattedConfigs) { Objects.requireNonNull(formattedConfigs, "Formatted config String can't be null");  if (formattedConfigs.indexOf('=') == -1) { throw new IllegalStateException(String.format("Provided string [ %s ] does not have expected key-value separator of '='", formattedConfigs)); }  final String[] parts = formattedConfigs.split(","); final Map<String, String> configs = new HashMap<>(); for (final String part : parts) { final String[] keyValue = part.split("="); if (keyValue.length > 2) { throw new IllegalStateException( String.format("Provided string [ %s ] does not have expected key-value pair separator of ','", formattedConfigs)); } configs.put(keyValue[KEY], keyValue[VALUE]); } return configs; }
[*] target: assertEquals(expectedSinglePairMap, parsedMap)
[-] pred: org. junit. Assert. assertEquals ( expectedSinglePairMap, parsedMap )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) { CoordinatorClient coordinatorClient = cluster.coordinatorClient();  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); coordinatorClient.createTask(new CreateTaskRequest("foo", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("foo").taskState(new TaskPending(fooSpec)).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("foo")); "<AssertPlaceHolder>";   time.sleep(2); new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskRunning(fooSpec, 2, new TextNode("active"))). workerState(new WorkerRunning("foo", fooSpec, 2, new TextNode("active"))). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); time.sleep(550); // coordinator heartbeat sees that the agent is back up, re-schedules the task but the agent expires it new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). workerState(new WorkerDone("foo", fooSpec, 552, 552, null, "worker expired")). build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02"));  cluster.restartAgent("node02"); // coordinator heartbeat sees that the agent is back up but does not re-schedule the task as it is DONE new ExpectedTasks(). addTask(new ExpectedTaskBuilder("foo"). taskState(new TaskDone(fooSpec, 2, 552, "worker expired", false, null)). // no worker states build()). waitFor(coordinatorClient). waitFor(cluster.agentClient("node02")); } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1, 500); time.sleep(552);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); NoOpTaskSpec updatedSpec = new NoOpTaskSpec(552, 500); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskRunning(updatedSpec, 552, new TextNode("receiving")) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: Exception { MockTime time = new MockTime(0, 0, 0); Scheduler scheduler = new MockScheduler(time); try (MiniTrogdorCluster cluster = new MiniTrogdorCluster.Builder(). addCoordinator("node01"). addAgent("node02"). scheduler(scheduler). build()) {  NoOpTaskSpec fooSpec = new NoOpTaskSpec(1000, 500); time.sleep(999);  CoordinatorClient coordinatorClient = cluster.coordinatorClient(); coordinatorClient.createTask(new CreateTaskRequest("fooSpec", fooSpec)); TaskState expectedState = new ExpectedTaskBuilder("fooSpec").taskState( new TaskPending(fooSpec) ).build().taskState();  TaskState resp = coordinatorClient.task(new TaskRequest("fooSpec")); "<AssertPlaceHolder>"; } }
task(TaskRequest request) throws Exception { return taskManager.task(request); }
[*] target: assertEquals(expectedState, resp)
[-] pred: org. junit. Assert. assertEquals ( expectedState, resp )
************************************
************************************
[+] input: testGetDistributedId() { String distributedId = distributedIdManager.getDistributedId(); Assert."<AssertPlaceHolder>"; }
getDistributedId();
[*] target: assertNotNull(distributedId)
[-] pred: org. junit. Assert. assertNotNull ( distributedId )
************************************
************************************
[+] input: IOException { JKongAdmin admin = new JKongAdmin(adminUrl); boolean contains = admin .containsTarget("ba4ccac7-8d9c-4d05-b282-e0e113c29852", "192.168.0.120:8800"); Assert."<AssertPlaceHolder>"; System.out.println(contains); }
containsTarget(String upstreamNameOrId, String target) throws IOException { TargetPageResp pageResp = listTargets(upstreamNameOrId, null);  if (pageResp.getData().size() == 0) { return false; }  for (TargetResp resp : pageResp.getData()) { if (resp.getTarget().equals(target)) { return true; } }  return false; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
************************************
[+] input: testValueOfNull() { // test：when passValue is null ParamTracking paramTracking1 = ParamTracking.build( "param", "source", ScopeTypeEnum.REQUEST, null, String.class, "converter" );  FieldSerializeTracking fieldSerializeTracking1 = new FieldSerializeTracking(); String serializedValue1 = fieldSerializeTracking1.valueSerialize(paramTracking1); Assert."<AssertPlaceHolder>"; }
valueSerialize(FieldTracking fieldTracking) { Object passValue = fieldTracking.getPassValue(); if (passValue == null) { return null; }  String v; if (passValue instanceof String) { v = (String) passValue; } else { v = JSON.toJSONString(passValue, SerializerFeature.DisableCircularReferenceDetect); } if (GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT == -1 || (v.length() <= GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT)) { return v; } else { try { return v.substring(0, GlobalProperties.KSTRY_STORY_TRACKING_PARAMS_LENGTH_LIMIT); } catch (Exception e) { LOGGER.error("build ParamTracking error! tracking: {}", fieldTracking, e); } } return null; }
[*] target: assertNull(serializedValue1)
[-] pred: org. junit. Assert. assertNull ( serializedValue1 )
************************************
************************************
[+] input: testSendMessage_toUser_success() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToUserUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  List<String> weComIds = ImmutableList.of("user1", "user2"); String msg = "test msg"; boolean result = weComSender.sendMessageToUsers(weComIds, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToUsers(List<String> weComUserIds, String msg) { if (CollectionUtils.isEmpty(weComUserIds)) { log.warn("Prepare to send messages to weCom users, but `weComUserIds` is empty"); return false; }  String token = getToken(); String url = String.format(sendToUserUrl, token); WeComToUserMessage weComToUserMessage = WeComToUserMessage.from(StringUtils.join(weComUserIds, "|"), agentid, msg); log.debug("ready to send message: {} to wecom users: {}", msg, weComToUserMessage.getTouser()); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToUserMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom users: {} failed.", msg, weComToUserMessage.getTouser()); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testSendMessage_toUser_failed() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToUserUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(1, "invalid token"); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  List<String> weComIds = ImmutableList.of("user1", "user2"); String msg = "test msg"; boolean result = weComSender.sendMessageToUsers(weComIds, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToUsers(List<String> weComUserIds, String msg) { if (CollectionUtils.isEmpty(weComUserIds)) { log.warn("Prepare to send messages to weCom users, but `weComUserIds` is empty"); return false; }  String token = getToken(); String url = String.format(sendToUserUrl, token); WeComToUserMessage weComToUserMessage = WeComToUserMessage.from(StringUtils.join(weComUserIds, "|"), agentid, msg); log.debug("ready to send message: {} to wecom users: {}", msg, weComToUserMessage.getTouser()); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToUserMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom users: {} failed.", msg, weComToUserMessage.getTouser()); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testSendMessage_toChat_success() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToChatUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  String chatid = "1"; String msg = "test msg"; boolean result = weComSender.sendMessageToChat(chatid, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToChat(String chatid, String msg) { if (StringUtils.isBlank(chatid)) { log.warn("Prepare to send messages to weCom chat, but `chatid` is empty"); return false; }  String token = getToken(); String url = String.format(sendToChatUrl, token); WeComToChatMessage weComToChatMessage = WeComToChatMessage.from(chatid, msg); log.debug("ready to send message: {} to wecom chat: {}", msg, chatid); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToChatMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom chat: {} failed.", msg, chatid); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testSendMessage_toChat_failed() { // mock get token String getTokenUrl = String.format(this.getTokenUrl, corpid, corpsecret); WeComGetTokenResult weComGetTokenResult = MockWeComGetTokenResultFactory.create(); ResponseEntity<WeComGetTokenResult> weComGetTokenResultResponseEntity = new ResponseEntity(weComGetTokenResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(getTokenUrl), Mockito.eq(HttpMethod.GET), Mockito.any(), Mockito.any(Class.class))).willReturn(weComGetTokenResultResponseEntity);  // mock send msg to user String url = String.format(sendToChatUrl, weComGetTokenResult.getAccessToken()); WeComBaseResult weComBaseResult = MockWeComBaseResultFactory.create(1, "invalid token"); ResponseEntity<WeComBaseResult> weComBaseResultResponseEntity = new ResponseEntity(weComBaseResult, HttpStatus.OK); BDDMockito.given(restTemplate.exchange(Mockito.eq(url), Mockito.eq(HttpMethod.POST), Mockito.any(), Mockito.any(Class.class))).willReturn(weComBaseResultResponseEntity);  String chatid = "1"; String msg = "test msg"; boolean result = weComSender.sendMessageToChat(chatid, msg);  Assert."<AssertPlaceHolder>"; }
sendMessageToChat(String chatid, String msg) { if (StringUtils.isBlank(chatid)) { log.warn("Prepare to send messages to weCom chat, but `chatid` is empty"); return false; }  String token = getToken(); String url = String.format(sendToChatUrl, token); WeComToChatMessage weComToChatMessage = WeComToChatMessage.from(chatid, msg); log.debug("ready to send message: {} to wecom chat: {}", msg, chatid); WeComBaseResult weComBaseResult = restTemplate.exchange(url, HttpMethod.POST, new HttpEntity<>(weComToChatMessage), WeComBaseResult.class).getBody(); if (!weComBaseResult.isSuccess()) { log.error("send message: {} to wecom chat: {} failed.", msg, chatid); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: generateToken() { SingleJWT jwt = new SingleJWT("secret", 1000); String token = jwt.generateToken("test", 1, "test", 1000); "<AssertPlaceHolder>"; log.info(token); }
generateToken(String tokenType, long identity, String scope, long expire) { Date expireDate = DateUtil.getDurationDate(expire); return builder .withClaim("type", tokenType) .withClaim("identity", identity) .withClaim("scope", scope) .withExpiresAt(expireDate) .sign(algorithm); }
[*] target: assertNotNull(token)
[-] pred: org. junit. Assert. assertNotNull ( token )
************************************
************************************
[+] input: SemanticException { ValueExpression abcd = new Constant(StringType.INSTANCE, "abcd", SyntheticLocation.INSTANCE); ValueExpression ab = new Constant(StringType.INSTANCE, "ab", SyntheticLocation.INSTANCE); ValueExpression cd = new Constant(StringType.INSTANCE, "cd", SyntheticLocation.INSTANCE); ValueExpression ABConcatCD = new BinaryExpression(StringType.INSTANCE, ab, cd, StringConcat.INSTANCE, SyntheticLocation.INSTANCE);  SubstringDomain empty = new SubstringDomain(); SubstringDomain assigned1 = empty.assign(x, abcd, null, null); SubstringDomain assigned2 = empty.assign(x, ABConcatCD, null, null);  "<AssertPlaceHolder>"; }
assign( Identifier id, ValueExpression expression, ProgramPoint pp, SemanticOracle oracle) throws SemanticException {  /* * If the assigned expression is not dynamically typed as a string (or * untyped) return this. */ if (oracle != null && pp != null && oracle.getRuntimeTypesOf(expression, pp, oracle).stream() .allMatch(t -> !t.isStringType() && !t.isUntyped())) return this;  /* * The string type is unique and can be retrieved from the type system. */ Type strType; if (pp != null) // Correct: get the string type from the program point strType = pp.getProgram().getTypes().getStringType(); else // Used in tests where pp is null, get the string type from the // expression strType = expression.getStaticType();  Set<SymbolicExpression> expressions = extrPlus(expression, pp, oracle, strType); SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.remove(expressions, id); result = result.add(expressions, id); result = result.interasg(id, expression); result = result.closure(id); return result.clear(); }
[*] target: assertEquals(assigned1, assigned2)
[-] pred: org. junit. Assert. assertEquals ( assigned1, assigned2 )
************************************
************************************
[+] input: SemanticException { List<Brick> bricksList = new ArrayList<>(); List<Brick> bricksList1 = new ArrayList<>();  Set<String> treeSet = new TreeSet<>(); treeSet.add("mo"); treeSet.add("de");  Brick brick = new Brick(1, 4, treeSet);  Set<String> treeSet1 = new TreeSet<>(); treeSet1.add("mo"); treeSet1.add("de"); treeSet1.add("re");  Brick brick1 = new Brick(0, 5, treeSet1);  Set<String> treeSet2 = new TreeSet<>(); treeSet2.add("ge"); treeSet2.add("ze");  Brick brick2 = new Brick(1, 3, treeSet2);  Set<String> treeSet3 = new TreeSet<>(); treeSet3.add("ge"); treeSet3.add("ze"); treeSet3.add("le");  Brick brick3 = new Brick(1, 4, treeSet3);  bricksList.add(brick); bricksList.add(brick2);  bricksList1.add(brick1); bricksList1.add(brick3);  Bricks bricks = new Bricks(bricksList); Bricks bricks1 = new Bricks(bricksList1);  "<AssertPlaceHolder>"; }
lessOrEqualAux( Bricks other) throws SemanticException { List<Brick> thisPaddedList = this.bricks; List<Brick> otherPaddedList = other.bricks;  if (this.bricks.size() < other.bricks.size()) thisPaddedList = this.padList(other); else if (other.bricks.size() < this.bricks.size()) otherPaddedList = other.padList(this);  for (int i = 0; i < thisPaddedList.size(); ++i) { Brick first = thisPaddedList.get(i); Brick second = otherPaddedList.get(i); if (!first.lessOrEqual(second)) return false; }  return true; }
[*] target: assertTrue(bricks.lessOrEqualAux(bricks1))
[-] pred: org. junit. Assert. assertTrue ( bricks. lessOrEqualAux ( bricks1 ) )
************************************
************************************
[+] input: testGetSlotsForAParticularCarColorWhenNoCarMatches() { final Map<Integer, Slot> allSlots = new HashMap<>(); final Slot slot1 = new Slot(1); slot1.assignCar(new Car("test-car-no1", "blue")); final Slot slot2 = new Slot(2); final Slot slot3 = new Slot(3); slot3.assignCar(new Car("test-car-no2", "red"));  allSlots.put(1, slot1); allSlots.put(2, slot2); allSlots.put(3, slot3);  when(parkingLot.getSlots()).thenReturn(allSlots); when(parkingLot.getCapacity()).thenReturn(10);  final List<Slot> slots = parkingLotService.getSlotsForColor("white"); "<AssertPlaceHolder>"; }
getSlotsForColor(final String color) { final List<Slot> occupiedSlots = getOccupiedSlots(); return occupiedSlots.stream() .filter(slot -> slot.getParkedCar().getColor().equals(color)) .collect(Collectors.toList()); }
[*] target: assertEquals(0, slots.size())
[-] pred: org. junit. Assert. assertEquals ( 0, slots. size ( ) )
************************************
************************************
[+] input: InterruptedException { for (int i = 0; i < (Integer.MAX_VALUE - 500); i+=100) { BigInteger s = BigInteger.valueOf(i);  byte[] bytes = ConverterUtil.bigIntegerToByte(s); BigInteger l = ConverterUtil.byteToBigInteger(bytes); Assert."<AssertPlaceHolder>"; }  }
byteToBigInteger(byte[] bytes) { BigInteger res = BigInteger.valueOf(0); for (byte b : bytes) { res = res.shiftLeft(8); res = res.or(BigInteger.valueOf(b & 0xff)); } return res; }
[*] target: assertEquals(s, l)
[-] pred: org. junit. Assert. assertEquals ( s, l )
************************************
************************************
[+] input: Exception { var bout = new ByteArrayOutputStream(); var out = new BytesOut(bout, 8); out.flush();  byte[] b1 = "hello".getBytes("UTF-8"); out.write(b1, 0, b1.length);  byte[] b2 = "world".getBytes("UTF-8"); out.write(b2, 0, b2.length);  byte[] b3 = "hello, world!!!".getBytes("UTF-8"); out.write(b3, 0, b3.length);  out.flush(); byte[] result = bout.toByteArray(); byte[] expect = "helloworldhello, world!!!".getBytes("UTF-8"); "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertArrayEquals(expect, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, result )
************************************
************************************
[+] input: Exception { var bout = new ByteArrayOutputStream(); var out = new BytesOut(bout, 15);  out.writeLong(Long.MAX_VALUE); out.writeLong(Long.MIN_VALUE);  out.flush(); byte[] result = bout.toByteArray(); byte[] expect = {127, -1, -1, -1, -1, -1, -1, -1, -128, 0, 0, 0, 0, 0, 0, 0}; "<AssertPlaceHolder>"; }
toByteArray() { return Arrays.copyOf(mBuffer, mSize); }
[*] target: assertArrayEquals(expect, result)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, result )
************************************
************************************
[+] input: IOException { String testStr = "( defun test () "hi there")"; Sexp parsedExpression = SexpFactory.parse(testStr); Sexp expectedExpression = SexpFactory.newNonAtomicSexp(); expectedExpression.add(SexpFactory.newAtomicSexp("defun")); expectedExpression.add(SexpFactory.newAtomicSexp("test")); expectedExpression.add(SexpFactory.newNonAtomicSexp()); expectedExpression.add(SexpFactory.newAtomicSexp(""hi there"")); Assert."<AssertPlaceHolder>"; }
add(Sexp item);
[*] target: assertEquals(expectedExpression, parsedExpression)
[-] pred: org. junit. Assert. assertEquals ( expectedExpression, parsedExpression )
************************************
************************************
[+] input: mergeReduceFile() { CommonFile.mergeReduceOutFiles(Collections.singletonList(MR_EXPECT_REDUCE)); String expect = FileUtil.readFile(MR_EXPECT_OUT); String act = FileUtil.readFile(CommonFile.MR_MERGE_OUT); Assert."<AssertPlaceHolder>"; }
mergeReduceOutFiles(List<String> reduceFiles) { Map<String, String> kvs = new HashMap<>(); reduceFiles.forEach(reduceFile -> { Stream<String> stream = FileUtil.stream(reduceFile); if (stream == null) { return; } stream.forEach(s -> { KeyValue keyValue = JSON.parseObject(s.getBytes(StandardCharsets.UTF_8), KeyValue.class); kvs.put(keyValue.getKey(), keyValue.getValue()); } ); }); List<String> keys = new ArrayList<>(kvs.keySet()); keys.sort(String::compareTo); keys.forEach(key -> { FileUtil.append(MR_MERGE_OUT, key + ": " + kvs.get(key)); }); LogUtil.log("ok to merge all files"); }
[*] target: assertEquals(expect, act)
[-] pred: org. junit. Assert. assertEquals ( expect, act )
************************************
************************************
[+] input: initModel() { boolean res = activityActivityTestRule.getActivity().initModel(); Log.d("EnhancementTest", "res:" + res); "<AssertPlaceHolder>"; }
initModel() { enhancement = new com.sensifai.enhancement.tflite.Enhancement(true); return enhancement.init(this, ENHANCEMENT_TFLITE_MODEL_NAME, Device.GPU, 1); }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: testSaveToString() { FileConfiguration config = getConfig();  for (Map.Entry<String, Object> entry : getTestValues().entrySet()) { config.set(entry.getKey(), entry.getValue()); }  String result = config.saveToString(); String expected = getTestValuesString();  "<AssertPlaceHolder>"; }
saveToString();  /** * Loads this {@link FileConfiguration}
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testSaveToStringWithIndent() { YamlConfiguration config = getConfig(); config.options().indent(9);  config.set("section.key", 1);  String result = config.saveToString(); String expected = "section:\n         key: 1\n";  "<AssertPlaceHolder>"; }
saveToString() { yamlOptions.setIndent(options().indent()); yamlOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK); yamlOptions.setAllowUnicode(SYSTEM_UTF); yamlRepresenter.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);  String header = buildHeader(); String dump = yaml.dump(getValues(false));  if (dump.equals(BLANK_CONFIG)) { dump = ""; }  return header + dump; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: UnsupportedEncodingException { BigDecimal decimal = new BigDecimal("1234567890123456789012345678901234567890.1234567809"); byte[] bytes = SerializeUtils.bigDecimal2Bytes(decimal); BigDecimal decimal1 = SerializeUtils.bytes2BigDecimal(bytes); "<AssertPlaceHolder>"; }
bytes2BigDecimal(byte[] bytes) throws UnsupportedEncodingException { String val = new String(bytes, "UTF-8"); return new BigDecimal(val); }
[*] target: assertEquals(decimal,decimal1)
[-] pred: org. junit. Assert. assertEquals ( decimal, decimal1 )
************************************
************************************
[+] input: Exception { Account account = AccountTool.createAccount(chainId); boolean result = accountStorageService.saveAccount(new AccountPO(account)); "<AssertPlaceHolder>"; }
saveAccount(AccountPO account);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { int start = 1; int count = 10; List<Block> blocks = new ArrayList<>();  GenesisBlock genesisBlock = GenesisBlock.getInstance(0, 0); blocks.add(genesisBlock);  Block preBlock = genesisBlock; do{ Block block = BlockGenerator.generate(preBlock); blocks.add(block); preBlock = block; start++; } while (start < count);  for (int i = 0; i < blocks.size()-1; i++) { NulsHash prehash = blocks.get(i).getHeader().getHash(); NulsHash hash = blocks.get(i+1).getHeader().getPreHash(); Assert."<AssertPlaceHolder>"; } }
generate(Block latestBlock) throws Exception { return generate(latestBlock, 1, "1"); }
[*] target: assertEquals(prehash, hash)
[-] pred: org. junit. Assert. assertEquals ( prehash, hash )
************************************
************************************
[+] input: Exception { List<TransactionConfirmedPO> list = new ArrayList<>(); for (int i = 0; i < 5; i++) { Transaction tx = TestConstant.getTransaction2(); tx.setRemark(StringUtils.bytes("tx remark" + i)); list.add(new TransactionConfirmedPO(tx, 1, (byte)1)); } boolean result = confirmedTxStorageService.saveTxList(chainId, list); Assert."<AssertPlaceHolder>"; }
saveTxList(int chainId, List<TransactionConfirmedPO> txList);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { Transaction tx = TestConstant.getTransaction2(); boolean result = unconfirmedTxStorageService.putTx(chainId, tx); Assert."<AssertPlaceHolder>"; }
putTx(int chainId, Transaction tx);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testParseJson() { String json = "[\n" + "{\n" + ""id": "Source__TableSourceScan(table=[[default_catalog__default_database__nexmark]]__fi.numRecordsOutPerSecond",\n" + ""min": 5003.2,\n" + ""max": 5003.2,\n" + ""avg": 5003.2,\n" + ""sum": 10006.3\n" + "}\n" + "]";  TpsMetric tps = TpsMetric.fromJson(json); TpsMetric expected = new TpsMetric( "Source__TableSourceScan(table=[[default_catalog__default_database__nexmark]]__fi.numRecordsOutPerSecond", 5003.2, 5003.2, 5003.2, 10006.3); "<AssertPlaceHolder>"; }
fromJson(String json) { try { JsonNode jsonNode = NexmarkUtils.MAPPER.readTree(json); return NexmarkUtils.MAPPER.convertValue(jsonNode.get(0), TpsMetric.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } }
[*] target: assertEquals(expected, tps)
[-] pred: org. junit. Assert. assertEquals ( expected, tps )
************************************
************************************
[+] input: authorize() { Mockito.when(session.principal()).thenReturn(customPrincipal); Mockito.when(customPrincipal.getOauthBearerTokenJwt()).thenReturn(jwt);  Set<String> set = new HashSet<>(); set.add("urn:kafka:topic:test:write");  Mockito.when(jwt.scope()).thenReturn(set); Mockito.when(resource.name()).thenReturn("test"); Mockito.when(resource.resourceType()).thenReturn(ResourceType.fromString("topic")); Mockito.when(operation.toJava()).thenReturn(AclOperation.fromString("write")); boolean result = customAuthorizer.authorize(session, operation, resource);  "<AssertPlaceHolder>"; }
authorize(Session session, Operation operation, Resource resource) { try { log.info("Starting Authorization."); // log.info("Session Info: {}", session.toString()); log.info("Operation request Info: {}", operation.toString()); log.info("Resource request Info: {}", resource.toString()); if (!(session.principal() instanceof CustomPrincipal)) { log.error("Session Principal is not using the proper class. Should be instance of CustomPrincipal."); return false; }  CustomPrincipal principal = (CustomPrincipal) session.principal(); if (principal.getOauthBearerTokenJwt() == null) { log.error("Custom Principal does not contain token information."); return false; }  OAuthBearerTokenJwt jwt = principal.getOauthBearerTokenJwt(); if (jwt.scope() == null || jwt.scope().isEmpty()) { log.error("No scopes provided in JWT. Unable to Authorize."); return false; }  java.util.Set<String> scopes = jwt.scope(); List<OAuthScope> scopeInfo = parseScopes(scopes); String operationStr = operation.toJava().toString(); return checkAuthorization(scopeInfo, resource, operationStr); } catch (Exception e) { log.error("Error in authorization. ", e); } return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: checkAuthorization() { List<OAuthScope> list = new ArrayList<>(); OAuthScope scope = new OAuthScope(); scope.setOperation("Write"); scope.setResourceName("test"); scope.setResourceType("topic"); list.add(scope);  Resource resource = new Resource(ResourceType.fromString("Topic"), "TEST");  CustomAuthorizer authorizer = new CustomAuthorizer();  boolean result = authorizer.checkAuthorization(list, resource, "write");  "<AssertPlaceHolder>";  }
checkAuthorization(List<OAuthScope> scopeInfo, Resource resource, String operation) { for (int i = 0; i < scopeInfo.size(); i++) { OAuthScope scope = scopeInfo.get(i); String lowerCaseOperation = operation.toLowerCase(); String lowerCaseResourceName = resource.name().toLowerCase(); String lowerCaseCaseResourceType = resource.resourceType().toString().toLowerCase();  boolean operationVal = scope.getOperation().toLowerCase().equals(lowerCaseOperation); boolean nameVal = scope.getResourceName().toLowerCase().equals(lowerCaseResourceName); boolean typeVal = scope.getResourceType().toLowerCase().equals(lowerCaseCaseResourceType);  if (operationVal && nameVal && typeVal) { log.info("Successfully Authorized."); return true; } } log.info("Not Authorized to operate on the given resource."); return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testServicesEmpty() { Collection<Service> services = collector.services(); Assert."<AssertPlaceHolder>"; }
services() { return Collections.unmodifiableMap(services).values(); }
[*] target: assertEquals(0, services.size())
[-] pred: org. junit. Assert. assertEquals ( 0, services. size ( ) )
************************************
************************************
[+] input: if_validator_data_missing_then_retrieved_via_radix_engine() { var self = BFTNode.random(); var radixEngine = TypedMocks.cmock(new TypeLiteral<RadixEngine<LedgerAndBFTProof>>() {}); var systemInfo = new InMemorySystemInfo(null, null, self, radixEngine); var validatorBFTData = Optional.of(new ValidatorBFTDataEvent(self.getKey(), 10, 1));  when(radixEngine.read(any())).thenReturn(validatorBFTData);  var result = systemInfo.getValidatorBFTData(); var expected = Optional.of(new ValidatorBFTDataEvent(self.getKey(), 10, 1));  "<AssertPlaceHolder>"; }
getValidatorBFTData() { if (!missedProposals.isMarked()) { // There were no relevant events yet missedProposals.set(getProposalStats(), true); }  return missedProposals.getReference(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: verify_that_tobytearray_returns_same_as_passed_in_constructor() { byte[] bytes = Bytes.fromHexString("dead000000000000000000000000beef"); EUID euid = new EUID(bytes); "<AssertPlaceHolder>"; }
toByteArray() { return value.toByteArray(); }
[*] target: assertArrayEquals(bytes, euid.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( bytes, euid. toByteArray ( ) )
************************************
************************************
[+] input: InactiveSensorException { sensor = new TempSensor("TEST"); String testString = "TempSensor{name='TEST', alias='test', address='28-456A123654xxx', sensorOffset=2, gpio=null, lastReadTime=null, lastTempRead=0}"; "<AssertPlaceHolder>"; }
toString() { return "TempSensor{" + "name='" + name + ''' + ", alias='" + alias + ''' + ", address='" + address + ''' + ", sensorOffset=" + sensorOffset + ", lastReadTime=" + lastReadTime + ", lastTempRead=" + lastTempRead + '}'; }
[*] target: assertEquals(testString,sensor.toString())
[-] pred: org. junit. Assert. assertEquals ( testString, sensor. toString ( ) )
************************************
************************************
[+] input: shouldReturnNullForInvalidUrl() { PatientIdentifierType actualIdentifierType = dao.getPatientIdentifierTypeByUrl("invalidUrl"); "<AssertPlaceHolder>"; }
getPatientIdentifierTypeByUrl(String url) { return (PatientIdentifierType) sessionFactory.getCurrentSession().createCriteria(FhirPatientIdentifierSystem.class) .add(eq("url", url)).setProjection(Projections.property("patientIdentifierType")).uniqueResult(); }
[*] target: assertNull(actualIdentifierType)
[-] pred: org. junit. Assert. assertNull ( actualIdentifierType )
************************************
************************************
[+] input: shouldReturnNullForNullUrl() { PatientIdentifierType actualIdentifierType = dao.getPatientIdentifierTypeByUrl(null); "<AssertPlaceHolder>"; }
getPatientIdentifierTypeByUrl(String url) { return (PatientIdentifierType) sessionFactory.getCurrentSession().createCriteria(FhirPatientIdentifierSystem.class) .add(eq("url", url)).setProjection(Projections.property("patientIdentifierType")).uniqueResult(); }
[*] target: assertNull(actualIdentifierType)
[-] pred: org. junit. Assert. assertNull ( actualIdentifierType )
************************************
************************************
[+] input: shouldMergeDriveOrders() { DriveOrder orderA = createDriveOrder(10, "A", "B", "C", "D", "E", "F", "G"); DriveOrder orderB = createDriveOrder(10, "D", "H", "I", "J");  when(router.getCosts(any(Vehicle.class), any(Point.class), any(Point.class))).thenReturn(20L);  Route expected = createDriveOrder(20, "A", "B", "C", "D", "H", "I", "J").getRoute(); Route actual = rerouteUtil.mergeDriveOrders(orderA, orderB, new Vehicle("Vehicle")).getRoute();  "<AssertPlaceHolder>"; }
mergeDriveOrders(DriveOrder orderA, DriveOrder orderB, Vehicle vehicle) { // Merge the drive order routes Route mergedRoute = mergeRoutes(vehicle, orderA.getRoute(), orderB.getRoute());  DriveOrder mergedOrder = new DriveOrder(orderA.getDestination()) .withState(orderA.getState()) .withTransportOrder(orderA.getTransportOrder()) .withRoute(mergedRoute);  return mergedOrder; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldReturnFutureSteps() { List<DriveOrder> driveOrders = Arrays.asList(createDriveOrder(10, "A", "B", "C"), createDriveOrder(20, "C", "D", "E", "F", "G", "H"), createDriveOrder(20, "H", "I", "J", "K", "L")); TransportOrder transportOrder = new TransportOrder("TransportOrder", driveOrders) .withCurrentDriveOrderIndex(1); Vehicle vehicle = new Vehicle("Vehicle") .withTransportOrder(transportOrder.getReference());  VehicleController controller = mock(VehicleController.class); when(transportOrderService.fetchObject(TransportOrder.class, transportOrder.getReference())) .thenReturn(transportOrder); when(vehicleControllerPool.getVehicleController(vehicle.getName())).thenReturn(controller); when(controller.getCommandsSent()).thenReturn(commandsSentToVehicle(driveOrders));  List<String> expected = Arrays.asList("H", "I", "J", "K", "L"); List<String> actual = rerouteUtil.getFutureSteps(vehicle).stream() .map(step -> step.getDestinationPoint().getName()) .collect(Collectors.toList());  "<AssertPlaceHolder>"; }
getFutureSteps(Vehicle vehicle) { TCSObjectReference<TransportOrder> orderRef = vehicle.getTransportOrder(); if (orderRef == null) { LOG.debug("Vehicle {} isn't processing any order. Can't determine future steps.", vehicle.getName()); return new ArrayList<>(); }  TransportOrder order = transportOrderService.fetchObject(TransportOrder.class, orderRef); VehicleController controller = vehicleControllerPool.getVehicleController(vehicle.getName());  // Get the steps for the drive order the vehicle is currently processing // The transport order's drive orders and their routes can't be null at this point List<Step> currentSteps = order.getCurrentDriveOrder().getRoute().getSteps();  // If movement commands have been sent to the comm adapter, trim the current steps by these. // Movement commands may have not been sent to the comm adapter yet, i.e. if needed resources // are already allocated by another vehicle. if (!controller.getCommandsSent().isEmpty()) { List<MovementCommand> commandsSent = new ArrayList<>(controller.getCommandsSent()); MovementCommand lastCommandSent = commandsSent.get(commandsSent.size() - 1);  // Trim the current steps / Get the steps that haven't been sent to the comm adapter yet currentSteps = currentSteps.subList( currentSteps.indexOf(lastCommandSent.getStep()) + 1, currentSteps.size()); }  List<Step> futureSteps = new ArrayList<>(); futureSteps.addAll(currentSteps);  // Add the steps from all future drive orders order.getFutureDriveOrders().stream() .map(driveOrder -> driveOrder.getRoute()) .map(route -> route.getSteps()) .forEach(steps -> futureSteps.addAll(steps));  return futureSteps; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: verifyExporterWorksWithDefaultConfiguration() { try (MockedStatic<ServiceOptions> mockedServiceOptions = Mockito.mockStatic(ServiceOptions.class); MockedStatic<MetricServiceClient> mockedMetricServiceClient = Mockito.mockStatic(MetricServiceClient.class); MockedStatic<GoogleCredentials> mockedGoogleCredentials = Mockito.mockStatic(GoogleCredentials.class)) { mockedServiceOptions.when(ServiceOptions::getDefaultProjectId).thenReturn(PROJECT_ID); mockedMetricServiceClient .when(() -> MetricServiceClient.create(Mockito.any(MetricServiceSettings.class))) .thenReturn(this.mockMetricServiceClient); mockedGoogleCredentials .when(GoogleCredentials::getApplicationDefault) .thenReturn(Mockito.mock(GoogleCredentials.class));  MetricExporter metricExporter = GoogleCloudMetricExporter.createWithDefaultConfiguration(); "<AssertPlaceHolder>"; generateOpenTelemetryUsingGoogleCloudMetricExporter(metricExporter); simulateExport(metricExporter);  mockedMetricServiceClient.verify( Mockito.times(1), () -> MetricServiceClient.create((MetricServiceSettings) Mockito.any())); mockedServiceOptions.verify(Mockito.times(1), ServiceOptions::getDefaultProjectId); Mockito.verify(this.mockMetricServiceClient) .createTimeSeries((ProjectName) Mockito.any(), Mockito.anyList()); } finally { GlobalOpenTelemetry.resetForTest(); } }
createWithDefaultConfiguration() { return new GoogleCloudMetricExporter(MetricConfiguration.builder().build()); }
[*] target: assertNotNull(metricExporter)
[-] pred: org. junit. Assert. assertNotNull ( metricExporter )
************************************
************************************
[+] input: testMapMetricWithWierdAttributeNameSucceeds() { String type = DEFAULT_PREFIX + "/" + anInstrumentationLibraryInfo.getName(); Attributes attributes = io.opentelemetry.api.common.Attributes.of(stringKey("test.bad"), "value"); Metric expectedMetric = Metric.newBuilder().setType(type).putLabels("test_bad", "value").build(); Metric actualMetric = MetricTranslator.mapMetric(attributes, type); "<AssertPlaceHolder>"; }
mapMetric(Attributes attributes, String type) { Metric.Builder metricBuilder = Metric.newBuilder().setType(type); attributes.forEach( (key, value) -> metricBuilder.putLabels(cleanAttributeKey(key.getKey()), value.toString())); return metricBuilder.build(); }
[*] target: assertEquals(expectedMetric, actualMetric)
[-] pred: org. junit. Assert. assertEquals ( expectedMetric, actualMetric )
************************************
************************************
[+] input: testMapConstantLabelWithStringValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(stringKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.STRING).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel )
************************************
************************************
[+] input: testMapConstantLabelWithLongValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(longKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.INT64).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel )
************************************
************************************
[+] input: testMapLabelWithPeriodInNameSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(longKey("label.test"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label_test").setValueType(ValueType.INT64).build(); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel )
************************************
************************************
[+] input: IOException { String binaryFile = "laptop.bin"; Laptop laptop1 = new Generator().NewLaptop();  Serializer serializer = new Serializer(); serializer.WriteBinaryFile(laptop1, binaryFile);  Laptop laptop2 = serializer.ReadBinaryFile(binaryFile); Assert."<AssertPlaceHolder>"; }
ReadBinaryFile(String filename) throws IOException { FileInputStream inStream = new FileInputStream(filename); Laptop laptop = Laptop.parseFrom(inStream); inStream.close(); return laptop; }
[*] target: assertEquals(laptop1, laptop2)
[-] pred: org. junit. Assert. assertEquals ( laptop1, laptop2 )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test1234"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeAll(null, createSchemaSql, false, false, false); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("plugin_test1"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeOneUpdate(null, createSchemaSql); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test123"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(DEFAULT_CREATE_SCHEMA, schema); this.executeAll(null, createSchemaSql, false, false, false); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: testSchemaCreate() { boolean schemaCreateFlag = driverSession.schemaCreate("test123"); "<AssertPlaceHolder>"; }
schemaCreate(String schema) { String createSchemaSql = String.format(CREATE_SCHEMA, schema); this.executeOneUpdate(null, createSchemaSql); // 执行失败即抛异常结束 return true; }
[*] target: assertTrue(schemaCreateFlag)
[-] pred: org. junit. Assert. assertTrue ( schemaCreateFlag )
************************************
************************************
[+] input: ExpressionException { graalJsExpressionHandler.evaluateExpression("var what = true", pugModel); boolean what = (boolean) pugModel.get("what"); "<AssertPlaceHolder>"; }
public Object evaluateExpression(String expression, PugModel model) throws ExpressionException { Context context = contextThreadLocal.get(); Map<String,Value> cache = cacheThreadLocal.get(); //        context.enter(); try{ saveLocalVariableName(expression, model); Value jsContextBindings = context.getBindings("js"); for (Map.Entry<String, Object> objectEntry : model.entrySet()) { String key = objectEntry.getKey(); if(!PugModel.LOCAL_VARS.equals(key)) { jsContextBindings.putMember(key, objectEntry.getValue()); } }  Source js; Value eval = cache.get(expression); if(eval==null){ if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } eval = context.parse(js); cache.put(expression,eval); } eval = eval.execute(); Set<String> memberKeys = jsContextBindings.getMemberKeys(); for (String memberKey : memberKeys) { if (model.knowsKey(memberKey)){ if (!memberKey.startsWith(PUG4J_MODEL_PREFIX)) { Value member = jsContextBindings.getMember(memberKey); model.put(memberKey, member.as(Object.class)); try { jsContextBindings.removeMember(memberKey); }catch(UnsupportedOperationException e){ //                            e.printStackTrace(); jsContextBindings.putMember(memberKey, null); } } } } return eval.as(Object.class); } catch (Exception ex){ if(ex.getMessage()!=null && ex.getMessage().startsWith("ReferenceError:")){ return null; } throw new ExpressionException(expression, ex); }finally { //            context.leave(); } }  @Override public String evaluateStringExpression(String expression, PugModel model) throws ExpressionException { Object result = evaluateExpression(expression, model); return result == null ? "" : result.toString(); }  @Override public void assertExpression(String expression) throws ExpressionException { Context context = contextThreadLocal.get(); Source js; if(expression.startsWith("{")){ js = Source.create("js", "(" + expression + ")"); }else{ js = Source.create("js", expression); } try { Value parse = context.eval(js); }catch(PolyglotException e){ if(e.getMessage().startsWith("SyntaxError:")){ throw new ExpressionException(e.getMessage()); } } }  @Override public void setCache(boolean cache) {  }  @Override public void clearCache() {  } public Context getContext(){ return contextThreadLocal.get(); } }
[*] target: assertTrue(what)
[-] pred: org. junit. Assert. assertTrue ( what )
************************************
************************************
[+] input: URISyntaxException { PugConfiguration config = new PugConfiguration(); config.setTemplateLoader(new FileTemplateLoader(TestFileHelper.getRootResourcePath() + "/parser/", "jade")); PugTemplate template = config.getTemplate("assignment"); "<AssertPlaceHolder>"; }
getTemplate(String name) throws IOException, PugException { if (caching) { long lastModified = templateLoader.getLastModified(name); PugTemplate template = cache.get(getKeyValue(name, lastModified)); if (template != null) { return template; }  String key = getCachedKey(name, lastModified); synchronized (key) { PugTemplate newTemplate = createTemplate(name); cache.put(key, newTemplate); return newTemplate; } }  return createTemplate(name); }
[*] target: assertNotNull(template)
[-] pred: org. junit. Assert. assertNotNull ( template )
************************************
************************************
[+] input: IOException { PugConfiguration config = new PugConfiguration(); config.setPrettyPrint(true); PugTemplate template = config.getTemplate(templatePath); "<AssertPlaceHolder>"; }
isPrettyPrint() { return prettyPrint; }
[*] target: assertTrue(template.isPrettyPrint())
[-] pred: org. junit. Assert. assertTrue ( template. isPrettyPrint() )
************************************
************************************
[+] input: emptyListShouldNotFail() { Object theException = null; try { InsertManager manager = new InsertManager( new MockDataSource(), new ValidationUtils(16, Duration.ofDays(14), Duration.ofHours(2).toMillis())); manager.insertIntoDatabase(new ArrayList<>(), null, null, null); } catch (Exception ex) { theException = ex; } "<AssertPlaceHolder>"; }
insertIntoDatabase( List<GaenKey> keys, String header, Object principal, UTCInstant now) throws InsertException {  if (keys == null || keys.isEmpty()) { return; } var internalKeys = filterAndModify(keys, header, principal, now); // if no keys remain or this is a fake request, just return. Else, insert the // remaining keys. if (!internalKeys.isEmpty() && !validationUtils.jwtIsFake(principal)) { dataService.upsertExposees(internalKeys, now); } }
[*] target: assertNull(theException)
[-] pred: org. junit. Assert. assertNull ( theException )
************************************
************************************
[+] input: failedConsensusMessage() { ConsensusEventMessage msg1 = new ConsensusEventMessage(); "<AssertPlaceHolder>"; }
getConsensusMessage() { ConsensusEvent event = consensusMessageInternal(); if (event == null) { throw new IllegalStateException("No consensus message."); } return event; }
[*] target: assertNotNull(msg1.getConsensusMessage())
[-] pred: org. junit. Assert. assertNotNull ( msg1. getConsensusMessage ( ) )
************************************
************************************
[+] input: test_atom_content_transformation_to_byte_array_and_back() { LedgerHeader ledgerHeader = LedgerHeader.genesis(HashUtils.zero256(), null); VerifiedLedgerHeaderAndProof proof = new VerifiedLedgerHeaderAndProof( new BFTHeader(View.of(1), HashUtils.random256(), ledgerHeader), new BFTHeader(View.of(1), HashUtils.random256(), ledgerHeader), 1L, HashUtils.random256(), ledgerHeader, new TimestampedECDSASignatures() ); StoredCommittedCommand committedCommand = new StoredCommittedCommand( new Command(new byte[] {0, 1, 2, 3}), proof );  byte[] serializedCommand = commandToBinaryConverter.toLedgerEntryContent(committedCommand); StoredCommittedCommand deserializedCommand = commandToBinaryConverter.toCommand(serializedCommand); "<AssertPlaceHolder>"; }
toCommand(byte[] ledgerEntryContent) { try { return serializer.fromDson(ledgerEntryContent, StoredCommittedCommand.class); } catch (DeserializeException e) { throw new IllegalStateException("Deserialization of Command failed", e); } }
[*] target: assertEquals(committedCommand, deserializedCommand)
[-] pred: org. junit. Assert. assertEquals ( committedCommand, deserializedCommand )
************************************
************************************
[+] input: ExecutionException { Context ctx = ContextAdapter.adapt(studioContext); List<Callable<String>> callables = new ArrayList<>(); for (int i = 0; i < 20; i++) { String val = "" + i; callables.add(() -> val); } List<String> result = ctx.call(callables); List<String> expected = IntStream.range(0, 20).mapToObj(i -> "" + i).collect(Collectors.toList()); TestCase."<AssertPlaceHolder>"; }
call(List<Callable<T>> list) throws ExecutionException { // ensure that NPE is thrown instead of IllegalArgumentException by ConcurrencyContext#call if (list == null) { throw new NullPointerException("callables must not be null"); } // check for null tasks for (Callable<T> callable : list) { if (callable == null) { throw new NullPointerException("callables must not contain null"); } } try { return studioContext.call(list); } catch (ExecutionStoppedException e) { throw new ExecutionAbortedException("Execution was aborted", e); } catch (ExecutionException e) { if (e.getCause() instanceof ExecutionAbortedException) { throw (ExecutionAbortedException) e.getCause(); } throw e; } }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: acceptingNullInputs() { final ConnectionConfiguration accept = new ConnectionConfigurationBuilder("accept nulls", CONFIGURATION_TYPE_TEST) .withDescription(null) .withTags(null) .withValueProviders(null) .withKeys(null) .build(); "<AssertPlaceHolder>"; }
build() { ConnectionConfiguration configuration = object; object = null; return configuration; }
[*] target: assertNotNull(accept)
[-] pred: org. junit. Assert. assertNotNull ( accept )
************************************
************************************
[+] input: testInjectValuesSuccessful() { MacroValueProviderHandler handler = MacroValueProviderHandler.getInstance(); ValueProvider provider = handler.createNewProvider("provider", PREFIX); Operator operator = getOperatorWithMacros(); Map<String, String> result = handler.injectValues(provider, REQUESTED, operator, null);  Map<String, String> expected = new HashMap<>(); expected.put("first", "first"); expected.put("second", "other");  // Test equals "<AssertPlaceHolder>"; }
injectValues(ValueProvider vp, Map<String, String> injectables, Operator operator, ConnectionInformation connection) { if (!isValid(vp, operator) || injectables == null || injectables.isEmpty()) { return Collections.emptyMap(); }  String prefix = getPrefix(vp); Map<String, String> result = new LinkedHashMap<>(); for (Entry<String, String> entry : injectables.entrySet()) { String fullKey = entry.getKey(); String needed = entry.getValue(); String value = null; String key = prefix + needed; try { value = operator.getProcess().getMacroHandler().getMacro(key, operator); } catch (Exception e) { // this can only happen with detached operators LogService.log(LogService.getRoot(), Level.WARNING, e, "com.rapidminer.connection.valueprovider.handler.MacroValueProviderHandler.retrieval_failed", key, vp.getName()); } if (value != null) { result.put(fullKey, value); } else { LogService.getRoot().log(Level.WARNING, "com.rapidminer.connection.valueprovider.handler.MacroValueProviderHandler.macro_not_found", key); } }  return result; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnParameterPrecondition precondition = new ColumnParameterPrecondition(generateDummyInputPort(errors), handler, "some_parameter"); final ExampleSetMetaData emd = FromTableMetaDataConverter.convert(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); precondition.check(emd); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd == null) { return; } String columnName = getName(); if (columnName != null) { // checking if attribute with name and type exists MetaDataInfo containsRelation = tmd.contains(columnName); if (containsRelation == MetaDataInfo.YES) { checkExistingColumn(tmd, columnName); } else if (containsRelation == MetaDataInfo.UNKNOWN) { createError(Severity.WARNING, "missing_attribute", columnName); } else { createError(Severity.ERROR, "missing_attribute", columnName); } } makeAdditionalChecks(tmd);  }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key")); final ExampleSetMetaData emd = FromTableMetaDataConverter.convert(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); precondition.check(emd); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { // checking column names checkColumnNames(requiredNames, tmd);  // checking provider names if (requiredNameProvider != null) { checkColumnNames(requiredNameProvider.getRequiredColumnNames(), tmd); } makeAdditionalChecks(tmd); } }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterAsString(anyString())).thenReturn("real"); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameter(handler, "some_key"), ColumnType.REAL); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameter(ParameterHandler handler, String... parameterKeys) { return new ParameterColumnNameProvider(handler, parameterKeys); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.isParameterSet(anyString())).thenReturn(true); when(handler.getParameterList(anyString())).thenReturn(Collections.singletonList(new String[]{"bla","real"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key", 1), ColumnType.REAL); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.isParameterSet(anyString())).thenReturn(true); when(handler.getParameterList(anyString())).thenReturn(Arrays.asList(new String[]{"bla","real"}, new String[]{"bla","int"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key",1), Column.Category.NUMERIC); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: UndefinedParameterError { ParameterHandler handler = mock(ParameterHandler.class); when(handler.getParameterList(anyString())).thenReturn(Arrays.asList(new String[]{"bla","real"}, new String[]{"bla","int"})); List<MetaDataError> errors = new ArrayList<>(); final ColumnSetPrecondition precondition = new ColumnSetPrecondition(generateDummyInputPort(errors), ColumnSetPrecondition.getColumnsByParameterListEntry(handler, "some_key",1), Column.Category.OBJECT); precondition.check(new TableMetaDataBuilder(10) .addReal("real", null, SetRelation.EQUAL, null) .addInteger("int", null, SetRelation.EQUAL, null) .add("nominal", ColumnType.NOMINAL, null) .addColumnMetaData("nominal", ColumnRole.LABEL) .build()); "<AssertPlaceHolder>"; }
getColumnsByParameterListEntry(ParameterHandler handler, String parameterListKey, int entry) { return new ParameterListColumnNameProvider(handler, parameterListKey, entry); }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: testOther() { final TablePassThroughRule tablePassThroughRule = new TablePassThroughRule(generateDummyInputPort(), generateDummyOutputPort(), SetRelation.SUBSET); final PredictionModelMetaData modelMetaData = new PredictionModelMetaData(PredictionModel.class); final MetaData result = tablePassThroughRule.modifyMetaData(modelMetaData); "<AssertPlaceHolder>"; }
modifyMetaData(MetaData metaData) { TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { if (relation != null && relation != SetRelation.EQUAL) { TableMetaDataBuilder builder = new TableMetaDataBuilder(tmd); builder.mergeColumnSetRelation(relation); tmd = builder.build(); } try { return modifyTableMetaData(tmd); } catch (UndefinedParameterError e) { //ignore return tmd; } } else { return metaData; } }
[*] target: assertSame(modelMetaData, result)
[-] pred: org. junit. Assert. assertSame ( modelMetaData, result )
************************************
************************************
[+] input: testExampleSetMD() { List<MetaDataError> errors = new ArrayList<>(); final TablePrecondition tablePrecondition = new TablePrecondition(generateDummyInputPort(errors)); tablePrecondition.check(new ExampleSetMetaData()); "<AssertPlaceHolder>"; }
check(MetaData metaData) { final InputPort inputPort = getInputPort(); if (metaData == null) { if (!optional) { // on purpose using ExampleSet for consistent display inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, null)); } } else { TableMetaData tmd = BeltConversionTools.asTableMetaDataOrNull(metaData); if (tmd != null) { checkColumnNames(tmd); checkTypes(tmd); checkRoles(inputPort, tmd); try { makeAdditionalChecks(tmd); } catch (UndefinedParameterError e) { //ignore } } else { inputPort.addError(new InputMissingMetaDataError(inputPort, ExampleSet.class, metaData.getObjectClass())); } } }
[*] target: assertEquals(0, errors.size())
[-] pred: org. junit. Assert. assertEquals ( 0, errors. size ( ) )
************************************
************************************
[+] input: RepositoryException { JwtClaim jwtClaim = jwtReader.readClaim(null); Assert."<AssertPlaceHolder>"; }
readClaim(RemoteRepository source) throws RepositoryException, IOException { try { JwtWrapper wrapper = loadJwtWrapper(source); if (wrapper == null) { return null; } //Split the token into header, payload and signature String[] token = wrapper.getIdToken().split(JWT_SEPARATOR_REGEX); //Verify the structure of the Token if (token.length == JWT_STRUCTURE.length) { //Extract the payload String base64Body = token[JWT_PAYLOAD]; //Base64 Decode byte[] jsonBody = Base64.getDecoder().decode(base64Body); //Read the decoded JSON return mapper.readValue(jsonBody, JwtClaim.class); } else { throw new RepositoryException("Invalid response from TokenService."); } } catch (IllegalArgumentException | JsonMappingException e) { throw new RepositoryException("Invalid response from TokenService.", e); } }
[*] target: assertNull(jwtClaim)
[-] pred: org. junit. Assert. assertNull ( jwtClaim )
************************************
************************************
[+] input: shouldNotFindInvalidCountryCode() { CountryCode cc = OnfidoSdkModule.findCountryCodeByAlpha2("12"); "<AssertPlaceHolder>"; }
findCountryCodeByAlpha2(String countryCodeString) { CountryCode countryCode = null; // We'll use a loop to find the value, because streams are not supported in Java 7. for (CountryCode cc : CountryCode.values()) { if (cc.name().equals(countryCodeString)) { countryCode = cc; } } return countryCode; }
[*] target: assertNull(cc)
[-] pred: org. junit. Assert. assertNull ( cc )
************************************
************************************
[+] input: isMale() { mockServerReturnString(true); Boolean male = userService.isMale(Long100); "<AssertPlaceHolder>"; }
isMale(@Query("id") Long id);
[*] target: assertTrue(male)
[-] pred: org. junit. Assert. assertTrue ( male )
************************************
************************************
[+] input: CodingException { ScheduledTask original = TaskTestUtil.makeTask("id", TaskTestUtil.JOB).newBuilder();  byte[] deflated = ThriftBinaryCodec.deflateNonNull(original);  ScheduledTask inflated = ThriftBinaryCodec.inflateNonNull(ScheduledTask.class, deflated);  "<AssertPlaceHolder>"; }
inflateNonNull(Class<T> clazz, byte[] buffer) throws CodingException {  requireNonNull(clazz); requireNonNull(buffer);  T tBase = newInstance(clazz); TTransport transport = new TIOStreamTransport( new InflaterInputStream(new ByteArrayInputStream(buffer))); try { TProtocol protocol = PROTOCOL_FACTORY.getProtocol(transport); tBase.read(protocol); return tBase; } catch (TException e) { throw new CodingException("Failed to deserialize: " + e, e); } finally { transport.close(); } }
[*] target: assertEquals(original, inflated)
[-] pred: org. junit. Assert. assertEquals ( original, inflated )
************************************
************************************
[+] input: IOException { // Making a task that is not in PENDING state. IJobKey jobKey = IJobKey.build(new JobKey("role", "test", "nonPendingJob")); IScheduledTask task = TestUtils.makeTask(jobKey, "task0", 0, ScheduleStatus.ASSIGNED, 10, 10, 10);  PubsubEvent.TaskStateChange taskStateChange = PubsubEvent.TaskStateChange.transition( task, ScheduleStatus.INIT);  pendingTaskGroups.taskChangedState(taskStateChange); expectLastCall();  // Recording the return value of pendingTaskGroups.getGroups(). List<TaskGroup> taskGroupList = new ArrayList<>(); expect(pendingTaskGroups.getGroups()).andReturn(taskGroupList).anyTimes();  replay(pendingTaskGroups);  // Testing. pendingTaskGroups.taskChangedState(taskStateChange); PendingTasks pendingTasks = new PendingTasks(pendingTaskGroups, nearestFit); JsonNode mimicResponseNoPendingTaskJson = new ObjectMapper().createArrayNode(); JsonNode actualResponseJson = new ObjectMapper().valueToTree( pendingTasks.getOffers().getEntity()); "<AssertPlaceHolder>"; }
getOffers() throws IOException { Map<TaskGroupKey, List<String>> taskGroupReasonMap = nearestFit.getPendingReasons(taskGroups.getGroups());  ObjectMapper mapper = new ObjectMapper(); ArrayNode jsonNode = mapper.createArrayNode();  // Add the attribute "reason" to each serialized taskgroup for (TaskGroup group : taskGroups.getGroups()) { ObjectNode pendingTask = (ObjectNode) mapper.valueToTree(group);  pendingTask.put("reason", taskGroupReasonMap.get(group.getKey()).toString()); jsonNode.add(pendingTask); } return Response.ok(jsonNode).build(); }
[*] target: assertEquals(mimicResponseNoPendingTaskJson, actualResponseJson)
[-] pred: org. junit. Assert. assertEquals ( mimicResponseNoPendingTaskJson, actualResponseJson )
************************************
************************************
[+] input: shouldNotReturnChangesetWithIdZero() { ChangesetPagingResult result = createCommand().getChangesets(new LogCommandRequest()); boolean found = StreamSupport.stream(result.spliterator(), false).anyMatch(c -> "0".equals(c.getId())); "<AssertPlaceHolder>"; }
getChangesets(LogCommandRequest request) { if (LOG.isDebugEnabled()) { LOG.debug("fetch changesets for {}", request); }  ChangesetPagingResult changesets; int start = request.getPagingStart(); int limit = request.getPagingLimit(); long startRevision = parseRevision(request.getStartChangeset(), repository); long endRevision = parseRevision(request.getEndChangeset(), repository); String[] pathArray = null;  if (!Strings.isNullOrEmpty(request.getPath())) { pathArray = new String[]{request.getPath()}; }  try { SVNRepository repo = open();  if ((startRevision > 0) || (pathArray != null)) { changesets = getChangesets(repo, startRevision, endRevision, start, limit, pathArray); } else { changesets = getChangesets(repo, start, limit); } } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not open repository", ex); }  return changesets; }
[*] target: assertFalse(found)
[-] pred: org. junit. Assert. assertFalse ( found )
************************************
************************************
[+] input: Exception { ActivityRuleConfig config = new ActivityRuleConfig(); config.setActivityId(1L); config.setConfigKey("city"); config.setConfigValue("1,2,3");  ActivityRule activityRule = ActivityRuleRegistrar.parseRule(config); Assert."<AssertPlaceHolder>"; }
parseRule(ActivityRuleConfig config) { String configKey = config.getConfigKey();  try { ActivityRule activityRule = ruleClassMap.get(configKey).newInstance(); activityRule.decode(config); return activityRule; } catch (Exception e) { throw new CustomException(BizStatusCode.ACTIVITY_RULE_CONFIG_ERROR, configKey); } }
[*] target: assertNotNull(activityRule)
[-] pred: org. junit. Assert. assertNotNull ( activityRule )
************************************
************************************
[+] input: Exception { ActivityRuleConfig config = new ActivityRuleConfig(); config.setActivityId(1L); config.setConfigKey("abc"); config.setConfigValue("1,2,3");  ActivityRule activityRule = ActivityRuleRegistrar.parseRule(config); Assert."<AssertPlaceHolder>"; }
parseRule(ActivityRuleConfig config) { String configKey = config.getConfigKey();  try { ActivityRule activityRule = ruleClassMap.get(configKey).newInstance(); activityRule.decode(config); return activityRule; } catch (Exception e) { throw new CustomException(BizStatusCode.ACTIVITY_RULE_CONFIG_ERROR, configKey); } }
[*] target: assertNotNull(activityRule)
[-] pred: org. junit. Assert. assertNotNull ( activityRule )
************************************
************************************
[+] input: test_isStartWithHttpOrHttps() { boolean start = ShortUrlManager.isStartWithHttpOrHttps("http://www.yefan813.github.io"); Assert."<AssertPlaceHolder>"; }
isStartWithHttpOrHttps(String url) { String regex = "^((https|http)?://)"; Pattern p = Pattern.compile(regex); Matcher matcher = p.matcher(url); return matcher.find(); }
[*] target: assertTrue(start)
[-] pred: org. junit. Assert. assertTrue ( start )
************************************
************************************
[+] input: builderOneMatcherAndMultipleNegatedMatchers() { var nonNegatedMatcher = Mockito.mock(Matcher.class); when(nonNegatedMatcher.isNegated()).thenReturn(false); when(matcher.isNegated()).thenReturn(true); rule = Rule.builder() .matchers(List.of(matcher, matcher, nonNegatedMatcher, matcher, matcher)) .name(name) .version(version) .tags(constants) .protections(protections) .build(); Assert."<AssertPlaceHolder>"; }
builder() {  return new Builder<>() { @Override protected Rule buildInternally() { prepareBuild(); return new Rule(this); } }; }
[*] target: assertNotNull(rule)
[-] pred: org. junit. Assert. assertNotNull ( rule )
************************************
************************************
[+] input: Exception { ConfigSchemaService service = EnrichmentSchemaService .createEnrichmentsSchemaService(new ConfigEditorUiLayout()); Assert."<AssertPlaceHolder>"; }
createEnrichmentsSchemaService(ConfigEditorUiLayout uiLayout) throws Exception { LOG.info("Initialising enrichment config schema service"); ConfigSchemaServiceContext context = new ConfigSchemaServiceContext(); EnrichmentCompiler compiler = EnrichmentCompilerImpl.createEnrichmentCompiler(); String rulesSchema = compiler.getSchema().getAttributes().getRulesSchema(); String testSchema = compiler.getTestSpecificationSchema().getAttributes().getTestSchema();  Optional<String> rulesSchemaUi = ConfigEditorUtils.patchJsonSchema(rulesSchema, uiLayout.getConfigLayout()); Optional<String> testSchemaUi = ConfigEditorUtils.patchJsonSchema(testSchema, uiLayout.getTestLayout()); SiembolJsonSchemaValidator adminConfigValidator = new SiembolJsonSchemaValidator( StormEnrichmentAttributesDto.class); Optional<String> adminConfigSchemaUi = ConfigEditorUtils.patchJsonSchema( adminConfigValidator.getJsonSchema().getAttributes().getJsonSchema(), uiLayout.getAdminConfigLayout());  if (!rulesSchemaUi.isPresent() || !testSchemaUi.isPresent() || !adminConfigSchemaUi.isPresent()) { LOG.error(INIT_ERROR); throw new IllegalArgumentException(INIT_ERROR); }  context.setConfigSchema(rulesSchemaUi.get()); context.setTestSchema(testSchemaUi.get()); context.setAdminConfigSchema(adminConfigSchemaUi.get()); context.setAdminConfigValidator(adminConfigValidator); var defaultConfigTester = new EnrichmentConfigTester( new SiembolJsonSchemaValidator(EnrichmentTestingSpecificationDto.class), testSchemaUi.get(), compiler); context.setConfigTesters(List.of(defaultConfigTester)); LOG.info("Initialising enrichment config schema service completed"); return new EnrichmentSchemaService(compiler, context); }
[*] target: assertNotNull(service)
[-] pred: org. junit. Assert. assertNotNull ( service )
************************************
************************************
[+] input: IOException { when(httpProvider.post(any(), any())).thenReturn(null); boolean response = stormProvider.killTopology("topology"); Assert."<AssertPlaceHolder>"; }
killTopology(String id) { LOG.info("Stopping topology: {}", id); String url = String.format(StormApplicationPaths.KILL_TOPOLOGY.getName(), id, killWaitSeconds); try { StormResponseDto response = post(url, ""); if (response != null && response.getStatus() != null) return response.getStatus().equals(STORM_RESPONSE_SUCCESS); } catch (IllegalArgumentException | IOException e){ LOG.error("Exception killing storm topology: ", e); } return false; }
[*] target: assertFalse(response)
[-] pred: org. junit. Assert. assertFalse ( response )
************************************
************************************
[+] input: IOException { when(httpProvider.post(any(), any())).thenReturn("{"status": "success"}"); boolean response = stormProvider.killTopology("topology"); Assert."<AssertPlaceHolder>"; }
killTopology(String id) { LOG.info("Stopping topology: {}", id); String url = String.format(StormApplicationPaths.KILL_TOPOLOGY.getName(), id, killWaitSeconds); try { StormResponseDto response = post(url, ""); if (response != null && response.getStatus() != null) return response.getStatus().equals(STORM_RESPONSE_SUCCESS); } catch (IllegalArgumentException | IOException e){ LOG.error("Exception killing storm topology: ", e); } return false; }
[*] target: assertTrue(response)
[-] pred: org. junit. Assert. assertTrue ( response )
************************************
************************************
[+] input: testNoOutputField() { RegexSelectExtractor extractor = RegexSelectExtractor.builder() .patterns(patterns) .outputField(null) .defaultValue("default_topic") .extractorFlags(extractorFlags) .name(name) .field(field) .build(); Map<String, Object> out = extractor.extract(simpleMessage.trim()); Assert."<AssertPlaceHolder>"; }
build() { if (this.outputField == null || patterns == null) { throw new IllegalArgumentException(MISSING_ARGUMENTS); } return new RegexSelectExtractor(this); }
[*] target: assertNull(out)
[-] pred: org. junit. Assert. assertNull ( out )
************************************
************************************
[+] input: testFindOne() { dao.insert(entity);  ActivityInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: copyConstructorTest() { PlayerState source = new PlayerState(); source.setPlayProgress(1000); source.setPlayProgressUpdateTime(SystemClock.elapsedRealtime()); source.setMusicItem(new MusicItem()); source.setPlayPosition(15); source.setPlayMode(PlayMode.LOOP); source.setPlaybackState(PlaybackState.ERROR); source.setPreparing(false); source.setPrepared(true); source.setAudioSessionId(12); source.setBufferedProgress(100); source.setStalled(true); source.setErrorCode(ErrorCode.PLAYER_ERROR); source.setErrorMessage("player error"); source.setSleepTimerStarted(true); source.setSleepTimerTime(60_000); source.setSleepTimerStartTime(System.currentTimeMillis()); source.setTimeoutAction(SleepTimer.TimeoutAction.STOP);  PlayerState copy = new PlayerState(source);  "<AssertPlaceHolder>"; }
setTimeoutAction(@NonNull SleepTimer.TimeoutAction action) { Preconditions.checkNotNull(timeoutAction); this.timeoutAction = action; }
[*] target: assertEquals(source, copy)
[-] pred: org. junit. Assert. assertEquals ( source, copy )
************************************
************************************
[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier(); try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL();  Properties p = new Properties(); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder( p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph(); Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv"); expected.add("test.json"); expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, null, null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier();   //		System.out.println("test/".matches("[^t]*"));   try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL();  Properties p = new Properties(); p.setProperty(ZipTriplifier.MATCHES.toString(), ".*(?<!\\.json)"); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder(p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph();  Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv");  expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, null, null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: MalformedURLException { FolderTriplifier tt = new FolderTriplifier(); try { URL url = getClass().getClassLoader().getResource("test").toURI().toURL(); Properties p = new Properties(); p.setProperty(IRIArgument.BLANK_NODES.toString(), "false"); p.setProperty(IRIArgument.LOCATION.toString(), url.toString()); FacadeXGraphBuilder builder = new BaseFacadeXGraphBuilder( p); tt.triplify(p, builder); DatasetGraph dg = builder.getDatasetGraph(); //			ModelFactory.createModelForGraph(dg.getDefaultGraph()).write(System.out, "TTL");  Set<String> expected = new HashSet<>();  expected.add(""); expected.add("test.csv"); expected.add("test.json"); expected.add("test.xml"); expected.add("test.txt");  Set<String> actual = new HashSet<>(); dg.find(null, NodeFactory.createURI(Path.of(url.toURI()).toUri() + "#"), null, null).forEachRemaining(q -> { if (q.getObject().isLiteral()) { try { actual.add(q.getObject().getLiteralLexicalForm() .replace(Paths.get(url.toURI()).toUri().toString(), "")); } catch (URISyntaxException e) { L.error("", e); } } });  "<AssertPlaceHolder>";  } catch (IOException | URISyntaxException e) { L.error("", e); } }
triplify(Properties properties, FacadeXGraphBuilder builder) throws IOException { URL url = Triplifier.getLocation(properties); if(url == null){ logger.warn("No location provided"); return; } String dataSourceId = ""; String matches = PropertyUtils.getStringProperty(properties, MATCHES);  logger.trace("Matches {}", matches);  builder.addRoot(dataSourceId);  try { Path path = Paths.get(url.toURI()); AtomicInteger i = new AtomicInteger(1); Files.walk(path).forEach(p -> { logger.trace("{} matches? {}", p.toString(), path.toString().matches(matches)); if (p.toString().matches(matches)) { builder.addValue(dataSourceId, SPARQLAnythingConstants.ROOT_ID, i.getAndIncrement(), p.toUri().toString()); } });  } catch (URISyntaxException e) { logger.error("",e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ScriptException { LarkyScriptEngineFactory factory = new LarkyScriptEngineFactory(); LarkyScriptEngine engine = (LarkyScriptEngine) factory.getScriptEngine(); String script = "print("Hello World!!!")"; LarkyCompiledScript instance = (LarkyCompiledScript) engine.compile(script);  Object expResult = "Larky ScriptEngine"; Object result = instance.getEngine().getFactory().getEngineName(); "<AssertPlaceHolder>"; }
getEngine() { return engine; }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: Exception { LarkyScriptEngineFactory factory = new LarkyScriptEngineFactory(); LarkyScriptEngine engine = (LarkyScriptEngine) factory.getScriptEngine(); ScriptContext context = new SimpleScriptContext(); StringWriter writer = new StringWriter(); StringWriter errorWriter = new StringWriter(); context.setWriter(writer); context.setErrorWriter(errorWriter);  context.setAttribute("message", "Hello World!!!!!", ScriptContext.ENGINE_SCOPE); engine.setContext(context); String script = "print(message)"; LarkyCompiledScript instance = (LarkyCompiledScript) engine.compile(script); Object expResult = "Hello World!!!!!"; instance.eval(context); Object result = writer.toString().trim(); "<AssertPlaceHolder>"; writer.close(); errorWriter.close(); }
eval(ScriptContext context) throws LarkyEvaluationScriptException { ParsedStarFile result; Bindings globalBindings = context.getBindings(ScriptContext.GLOBAL_SCOPE); Bindings engineBindings = context.getBindings(ScriptContext.ENGINE_SCOPE);  try (Reader reader = context.getReader()) { final StarFile script = InMemMapBackedStarFile.createStarFile(DEFAULT_SCRIPT_NAME, CharStreams.toString(reader)); final DefaultLarkyInterpreter larkyInterpreter = new DefaultLarkyInterpreter(LARKY_MODE, globalBindings, engineBindings); result = larkyInterpreter.evaluate(script, context.getWriter()); } catch (IOException | StarlarkEvalWrapper.Exc.RuntimeEvalException | Starlark.UncheckedEvalException | EvalException e) { throw LarkyEvaluationScriptException.of(e); } setBindingsValue(globalBindings, engineBindings, result.getGlobals()); return result; }
[*] target: assertEquals(expResult, result)
[-] pred: org. junit. Assert. assertEquals ( expResult, result )
************************************
************************************
[+] input: optionsForNoAttendees() { MeetingRequest request = new MeetingRequest(NO_ATTENDEES, DURATION_1_HOUR);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: noOptionsForTooLongOfARequest() { // The duration should be longer than a day. This means there should be no options. int duration = TimeRange.WHOLE_DAY.duration() + 1; MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), duration);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList();  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: eventSplitsRestriction() { // The event should split the day into two options (before and after the event). Collection<Event> events = Arrays.asList(new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: everyAttendeeIsConsidered() { // Have each person have different events. We should see two options because each person has // split the restricted times. // // Events  :       |--A--|     |--B--| // Day     : |-----------------------------| // Options : |--1--|     |--2--|     |--3--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0800AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0800AM, false), TimeRange.fromStartEnd(TIME_0830AM, TIME_0900AM, false), TimeRange.fromStartEnd(TIME_0930AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: overlappingEvents() { // Have an event for each person, but have their events overlap. We should only see two options. // // Events  :       |--A--| //                     |--B--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_60_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_60_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_1000AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: nestedEvents() { // Have an event for each person, but have one person's event fully contain another's event. We // should see two options. // // Events  :       |----A----| //                   |--B--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_90_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_B)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_1000AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: doubleBookedPeople() { // Have one person, but have them registered to attend two events at the same time. // // Events  :       |----A----| //                     |--A--| // Day     : |---------------------| // Options : |--1--|         |--2--|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartDuration(TIME_0830AM, DURATION_60_MINUTES), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), TimeRange.fromStartEnd(TIME_0930AM, TimeRange.END_OF_DAY, true));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: justEnoughRoom() { // Have one person, but make it so that there is just enough room at one point in the day to // have the meeting. // // Events  : |--A--|     |----A----| // Day     : |---------------------| // Options :       |-----|  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.fromStartDuration(TIME_0830AM, DURATION_30_MINUTES));  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ignoresPeopleNotAttending() { // Add an event, but make the only attendee someone different from the person looking to book // a meeting. This event should not affect the booking. Collection<Event> events = Arrays.asList(new Event("Event 1", TimeRange.fromStartDuration(TIME_0900AM, DURATION_30_MINUTES), Arrays.asList(PERSON_A))); MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: noConflicts() { MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A, PERSON_B), DURATION_30_MINUTES);  Collection<TimeRange> actual = query.query(NO_EVENTS, request); Collection<TimeRange> expected = Arrays.asList(TimeRange.WHOLE_DAY);  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: notEnoughRoom() { // Have one person, but make it so that there is not enough room at any point in the day to // have the meeting. // // Events  : |--A-----| |-----A----| // Day     : |---------------------| // Options :  Collection<Event> events = Arrays.asList( new Event("Event 1", TimeRange.fromStartEnd(TimeRange.START_OF_DAY, TIME_0830AM, false), Arrays.asList(PERSON_A)), new Event("Event 2", TimeRange.fromStartEnd(TIME_0900AM, TimeRange.END_OF_DAY, true), Arrays.asList(PERSON_A)));  MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_60_MINUTES);  Collection<TimeRange> actual = query.query(events, request); Collection<TimeRange> expected = Arrays.asList();  Assert."<AssertPlaceHolder>"; }
query(Collection<Event> events, MeetingRequest request) { throw new UnsupportedOperationException("TODO: Implement this method."); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: CantAddOptionalAttendeeWhoIsAlsoMandatory() { MeetingRequest request = new MeetingRequest(Arrays.asList(PERSON_A), DURATION_1_HOUR); request.addOptionalAttendee(PERSON_A);  int actual = request.getOptionalAttendees().size(); int expected = 0; Assert."<AssertPlaceHolder>"; }
getOptionalAttendees() { return Collections.unmodifiableCollection(optional_attendees); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testNormalizeInvalidPhoneNumber() { String inputPhoneNumber = "  johndoe@gmail.com  "; String expectedTrimmedPhoneNumber = inputPhoneNumber.trim(); String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); "<AssertPlaceHolder>"; }
normalizeIfPhoneNumber(String phoneNumber) { if (phoneNumber == null) { return null; }  PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();  try { // Attempt to parse the phone number with default region code "ZZ" (unknown // region) Phonenumber.PhoneNumber parsedPhoneNumber = phoneNumberUtil.parse(phoneNumber.trim(), "ZZ");  // Format the parsed phone number according to E.164 standard phoneNumber = phoneNumberUtil.format(parsedPhoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164); } catch (NumberParseException e) { // Parsing failed, use the original trimmed phone number phoneNumber = phoneNumber.trim(); }  return phoneNumber; }
[*] target: assertEquals(expectedTrimmedPhoneNumber, actualNormalizedPhoneNumber)
[-] pred: org. junit. Assert. assertEquals ( expectedTrimmedPhoneNumber, actualNormalizedPhoneNumber )
************************************
************************************
[+] input: givenClientSessionDetails_whenGetSessionInfo_thenReturnExpectedResult() { UUID sessionId = UUID.randomUUID(); String clientId = "clientId"; MqttConnectMsg msg = getMqttConnectMsg(sessionId, clientId); SessionInfo actualSessionInfo = connectService.getSessionInfo(msg, sessionId, clientId, ClientType.DEVICE, 0, BrokerConstants.LOCAL_ADR);  SessionInfo expectedSessionInfo = ClientSessionInfoFactory.getSessionInfo( sessionId, false, SERVICE_ID, getClientInfo(clientId), getConnectionInfo(1000, actualSessionInfo.getConnectionInfo().getConnectedAt()), 0);  Assert."<AssertPlaceHolder>"; }
getSessionInfo(MqttConnectMsg msg, UUID sessionId, String clientId, ClientType clientType, int sessionExpiryInterval, byte[] clientIpAdr) { return ClientSessionInfoFactory.getSessionInfo( sessionId, msg.isCleanStart(), serviceInfoProvider.getServiceId(), new ClientInfo(clientId, clientType, clientIpAdr), ClientSessionInfoFactory.getConnectionInfo(msg.getKeepAliveTimeSeconds()), sessionExpiryInterval); }
[*] target: assertEquals(expectedSessionInfo, actualSessionInfo)
[-] pred: org. junit. Assert. assertEquals ( expectedSessionInfo, actualSessionInfo )
************************************
************************************
[+] input: givenSuccessReasonCode_whenCheckIfReasonCodeFailure_thenReturnFalse() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.SUCCESS)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenFailureReasonCode_whenCheckIfReasonCodeFailure_thenReturnTrue() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenOtherFailureReasonCode_whenCheckIfReasonCodeFailure_thenReturnTrue() { boolean result = mqttPubRecHandler.reasonCodeFailure(newMqttPubRecMsg(MqttReasonCodes.PubRec.PAYLOAD_FORMAT_INVALID)); "<AssertPlaceHolder>"; }
reasonCodeFailure(MqttPubRecMsg msg) { return Byte.toUnsignedInt(msg.getReasonCode().byteValue()) >= Byte.toUnsignedInt(MqttReasonCodes.PubRec.UNSPECIFIED_ERROR.byteValue()); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenNoDelayedMessages_whenProcessDelayedMsg_thenRemoveClientFromDelayedProcessing() { publishedInFlightCtx.getPublishedInFlightMsgCounter().set(5);  boolean result = publishedInFlightCtx.processMsg(1);  verify(flowControlService, times(1)).removeFromMap("test");  "<AssertPlaceHolder>"; }
processMsg(long ttlMs) { lock.lock(); try { if (!allowedToSendMsg()) { if (log.isDebugEnabled()) { log.debug("[{}] Still reaching clientReceiveMax... Waiting for more ack messages", clientId); } return false; }  while (true) { MqttPubMsgWithCreatedTime head = delayedMsgQueue.poll(); if (head == null) { if (log.isDebugEnabled()) { log.debug("[{}] Delayed queue is empty!", clientId); } flowControlService.removeFromMap(clientId); return false; } delayedMsgCounter.decrementAndGet(); if (head.getCreatedTime() + ttlMs < System.currentTimeMillis()) { if (log.isDebugEnabled()) { log.debug("[{}] Msg expired in delayed queue {}", clientId, head); } continue; }  addPublishedInFlightMsg(head.getMqttPublishMessage()); sendDelayedMsg(head.getMqttPublishMessage()); break; } return true; } finally { lock.unlock(); } }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testTryConsumeDevicePersistedMsg() { // Set up bucket proxy Bandwidth limit = Bandwidth.builder().capacity(10).refillGreedy(10, Duration.ofMinutes(1)).build(); BucketConfiguration bucketConfig = BucketConfiguration.builder().addLimit(limit).build(); when(jedisBasedProxyManager.getProxy(anyString(), any())).thenReturn(bucketProxy); rateLimitRedisCacheService = new RateLimitRedisCacheServiceImpl(redisTemplate, jedisBasedProxyManager, bucketConfig, null); setCachePrefixAndInit();  when(bucketProxy.tryConsume(1)).thenReturn(true);  boolean result = rateLimitRedisCacheService.tryConsumeDevicePersistedMsg();  "<AssertPlaceHolder>"; verify(bucketProxy, times(1)).tryConsume(1); }
tryConsumeDevicePersistedMsg() { return devicePersistedMsgsBucketProxy.tryConsume(1); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testTryConsumeTotalMsg() { // Set up bucket proxy Bandwidth limit = Bandwidth.builder().capacity(10).refillGreedy(10, Duration.ofMinutes(1)).build(); BucketConfiguration bucketConfig = BucketConfiguration.builder().addLimit(limit).build(); when(jedisBasedProxyManager.getProxy(anyString(), any())).thenReturn(bucketProxy); rateLimitRedisCacheService = new RateLimitRedisCacheServiceImpl(redisTemplate, jedisBasedProxyManager, null, bucketConfig); setCachePrefixAndInit();  when(bucketProxy.tryConsume(1)).thenReturn(true);  boolean result = rateLimitRedisCacheService.tryConsumeTotalMsg();  "<AssertPlaceHolder>"; verify(bucketProxy, times(1)).tryConsume(1); }
tryConsumeTotalMsg() { return totalMsgsBucketProxy.tryConsume(1); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenIncomingRateLimitsDisabled_whenCheckIncomingLimits_thenSuccess() { when(incomingRateLimitsConfiguration.isEnabled()).thenReturn(false);  boolean result = rateLimitService.checkIncomingLimits(CLIENT_ID, UUID.randomUUID(), null); Assert."<AssertPlaceHolder>"; }
checkIncomingLimits(String clientId, UUID sessionId, MqttMessage msg) { if (!incomingRateLimitsConfiguration.isEnabled()) { return true; } TbRateLimits rateLimits = incomingPublishClientLimits.computeIfAbsent(clientId, id -> new TbRateLimits(incomingRateLimitsConfiguration.getClientConfig())); if (!rateLimits.tryConsume()) { if (log.isTraceEnabled()) { log.trace("[{}][{}] Client level incoming PUBLISH rate limit detected: {}", clientId, sessionId, msg); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenNoSessionsLimit_whenCheckSessionsLimit_thenSuccess() { rateLimitService.setSessionsLimit(0);  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenSessionsLimitReached_whenCheckSessionsLimit_thenFailure() { rateLimitService.setSessionsLimit(1); when(rateLimitCacheService.incrementSessionCount()).thenReturn(2L);  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenSessionsLimitReached_whenCheckSessionsLimitForExistingClient_thenSuccess() { rateLimitService.setSessionsLimit(1); when(rateLimitCacheService.incrementSessionCount()).thenReturn(2L); when(clientSessionService.getClientSessionInfo(CLIENT_ID)).thenReturn(ClientSessionInfo.builder().build());  boolean result = rateLimitService.checkSessionsLimit(CLIENT_ID); Assert."<AssertPlaceHolder>"; }
checkSessionsLimit(String clientId) { if (sessionsLimit <= 0) { return true; }  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(clientId); if (clientSessionInfo != null) { return true; }  long newSessionCount = rateLimitCacheService.incrementSessionCount();  if (newSessionCount > sessionsLimit) { log.trace("Client sessions count limit detected! Allowed: {} sessions", sessionsLimit); rateLimitCacheService.decrementSessionCount(); return false; }  return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenNoApplicationClientsLimit_whenCheckApplicationClientsLimit_thenSuccess() { rateLimitService.setApplicationClientsLimit(0);  SessionInfo sessionInfo = SessionInfo.builder().build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenApplicationClientsLimitReached_whenCheckApplicationClientsLimit_thenFailure() { rateLimitService.setApplicationClientsLimit(1); when(rateLimitCacheService.incrementApplicationClientsCount()).thenReturn(2L);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).clientId(CLIENT_ID).build()).cleanStart(false).build(); boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenApplicationClientsLimitReached_whenCheckApplicationClientsLimitForExistingClient_thenSuccess() { rateLimitService.setApplicationClientsLimit(1); when(rateLimitCacheService.incrementApplicationClientsCount()).thenReturn(2L);  SessionInfo sessionInfo = SessionInfo.builder().clientInfo(ClientInfo.builder().type(ClientType.APPLICATION).clientId(CLIENT_ID).build()).cleanStart(false).build(); ClientSessionInfo clientSessionInfo = ClientSessionInfo.builder().type(ClientType.APPLICATION).cleanStart(false).build(); when(clientSessionService.getClientSessionInfo(CLIENT_ID)).thenReturn(clientSessionInfo);  boolean result = rateLimitService.checkApplicationClientsLimit(sessionInfo); Assert."<AssertPlaceHolder>"; }
checkApplicationClientsLimit(SessionInfo sessionInfo) { if (applicationClientsLimit <= 0) { return true; } if (sessionInfo.isPersistentAppClient()) {  ClientSessionInfo clientSessionInfo = clientSessionService.getClientSessionInfo(sessionInfo.getClientId()); if (clientSessionInfo != null && clientSessionInfo.isPersistentAppClient()) { return true; }  long newAppClientsCount = rateLimitCacheService.incrementApplicationClientsCount();  if (newAppClientsCount > applicationClientsLimit) { log.trace("Application clients count limit detected! Allowed: {} App clients", applicationClientsLimit); rateLimitCacheService.decrementApplicationClientsCount(); return false; }  } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenDevicePersistedMsgsRateLimitsEnabled_whenRateLimitNotReached_thenSuccess() { when(devicePersistedMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeDevicePersistedMsg()).thenReturn(true);  boolean result = rateLimitService.checkDevicePersistedMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkDevicePersistedMsgsLimit() { if (!devicePersistedMsgsRateLimitsConfiguration.isEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeDevicePersistedMsg()) { if (log.isTraceEnabled()) { log.trace("Device persisted messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenDevicePersistedMsgsRateLimitsEnabled_whenRateLimitReached_thenFailure() { when(devicePersistedMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeDevicePersistedMsg()).thenReturn(false);  boolean result = rateLimitService.checkDevicePersistedMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkDevicePersistedMsgsLimit() { if (!devicePersistedMsgsRateLimitsConfiguration.isEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeDevicePersistedMsg()) { if (log.isTraceEnabled()) { log.trace("Device persisted messages rate limit detected!"); } return false; } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: givenTotalMsgsRateLimitsEnabled_whenRateLimitNotReached_thenSuccess() { when(totalMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeTotalMsg()).thenReturn(true);  boolean result = rateLimitService.checkTotalMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkTotalMsgsLimit() { if (!isTotalMsgsLimitEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeTotalMsg()) { if (log.isTraceEnabled()) { log.trace("Total incoming and outgoing messages rate limit detected!"); } return false; } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenTotalMsgsRateLimitsEnabled_whenRateLimitReached_thenFailure() { when(totalMsgsRateLimitsConfiguration.isEnabled()).thenReturn(true); when(rateLimitCacheService.tryConsumeTotalMsg()).thenReturn(false);  boolean result = rateLimitService.checkTotalMsgsLimit(); Assert."<AssertPlaceHolder>"; }
checkTotalMsgsLimit() { if (!isTotalMsgsLimitEnabled()) { return true; } if (!rateLimitCacheService.tryConsumeTotalMsg()) { if (log.isTraceEnabled()) { log.trace("Total incoming and outgoing messages rate limit detected!"); } return false; } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: loadPersistedMsgCtxTest() { ApplicationSessionCtx applicationSessionCtx = buildApplicationSessionCtx(); when(sessionCtxService.findApplicationSessionCtx(CLIENT_ID)).thenReturn(Optional.of(applicationSessionCtx));  ApplicationPersistedMsgCtx actual = applicationPersistedMsgCtxService.loadPersistedMsgCtx(CLIENT_ID); ApplicationPersistedMsgCtx expected = new ApplicationPersistedMsgCtx(getPendingMsgIdsMap(), getPendingMsgIdsMap()); Assert."<AssertPlaceHolder>"; }
loadPersistedMsgCtx(String clientId) { if (log.isTraceEnabled()) { log.trace("[{}] Loading persisted messages context.", clientId); } ApplicationSessionCtx applicationSessionCtx = findApplicationSessionCtx(clientId); if (applicationSessionCtx == null) { return new ApplicationPersistedMsgCtx(Collections.emptyMap(), Collections.emptyMap()); } Map<Long, Integer> publishMsgIds = getPendingMsgsFromApplicationCtx(applicationSessionCtx.getPublishMsgInfos()); Map<Long, Integer> pubRelMsgIds = getPendingMsgsFromApplicationCtx(applicationSessionCtx.getPubRelMsgInfos()); return new ApplicationPersistedMsgCtx(publishMsgIds, pubRelMsgIds); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: givenClientContextAndAllowPublishToTopic_whenValidateClientAccess_thenSuccess() { when(authorizationRuleService.isPubAuthorized(any(), any(), any())).thenReturn(true); boolean result = publishMsgValidationService.validateClientAccess(ctx, "clientId", "topic/1"); Assert."<AssertPlaceHolder>"; }
validateClientAccess(ClientSessionCtx ctx, String clientId, String topic) { boolean isClientAuthorized = authorizationRuleService.isPubAuthorized(clientId, topic, ctx.getAuthRulePatterns()); if (!isClientAuthorized) { log.warn("[{}][{}][{}] Client is not authorized to publish to the topic {}", clientId, ctx.getSessionId(), ctx.getAuthRulePatterns(), topic); } return isClientAuthorized; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: givenClientContextAndNotAllowPublishToTopic_whenValidateClientAccess_thenFailure() { when(authorizationRuleService.isPubAuthorized(any(), any(), any())).thenReturn(false); boolean result = publishMsgValidationService.validateClientAccess(ctx, "clientId", "topic/1"); Assert."<AssertPlaceHolder>"; }
validateClientAccess(ClientSessionCtx ctx, String clientId, String topic) { boolean isClientAuthorized = authorizationRuleService.isPubAuthorized(clientId, topic, ctx.getAuthRulePatterns()); if (!isClientAuthorized) { log.warn("[{}][{}][{}] Client is not authorized to publish to the topic {}", clientId, ctx.getSessionId(), ctx.getAuthRulePatterns(), topic); } return isClientAuthorized; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testApplyTotalMsgsRateLimits_whenTotalMsgsLimitDisabled() { when(rateLimitService.isTotalMsgsLimitEnabled()).thenReturn(false);  List<ValueWithTopicFilter<ClientSubscription>> list = List.of( newValueWithTopicFilter("c1", 0, "t1"), newValueWithTopicFilter("c2", 1, "t2"), newValueWithTopicFilter("c3", 2, "t3") ); List<ValueWithTopicFilter<ClientSubscription>> result = msgDispatcherService.applyTotalMsgsRateLimits(list);  "<AssertPlaceHolder>"; }
applyTotalMsgsRateLimits(List<ValueWithTopicFilter<ClientSubscription>> clientSubscriptions) { if (rateLimitService.isTotalMsgsLimitEnabled() && clientSubscriptions.size() > 1) { int availableTokens = (int) rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(clientSubscriptions.size()); if (availableTokens == 0) { log.debug("No available tokens left for total msgs bucket"); return Collections.emptyList(); } if (log.isDebugEnabled() && availableTokens < clientSubscriptions.size()) { log.debug("Hitting total messages rate limits on subscriptions processing. Skipping {} messages", clientSubscriptions.size() - availableTokens); } return clientSubscriptions.subList(0, availableTokens); } return clientSubscriptions; }
[*] target: assertEquals(list, result)
[-] pred: org. junit. Assert. assertEquals ( list, result )
************************************
************************************
[+] input: testApplyTotalMsgsRateLimits_whenTotalMsgsLimitEnabledAndLimitNotUsed() { when(rateLimitService.isTotalMsgsLimitEnabled()).thenReturn(true); when(rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(eq(3L))).thenReturn(3L);  List<ValueWithTopicFilter<ClientSubscription>> list = List.of( newValueWithTopicFilter("c1", 0, "t1"), newValueWithTopicFilter("c2", 1, "t2"), newValueWithTopicFilter("c3", 2, "t3") ); List<ValueWithTopicFilter<ClientSubscription>> result = msgDispatcherService.applyTotalMsgsRateLimits(list);  "<AssertPlaceHolder>"; }
applyTotalMsgsRateLimits(List<ValueWithTopicFilter<ClientSubscription>> clientSubscriptions) { if (rateLimitService.isTotalMsgsLimitEnabled() && clientSubscriptions.size() > 1) { int availableTokens = (int) rateLimitService.tryConsumeAsMuchAsPossibleTotalMsgs(clientSubscriptions.size()); if (availableTokens == 0) { log.debug("No available tokens left for total msgs bucket"); return Collections.emptyList(); } if (log.isDebugEnabled() && availableTokens < clientSubscriptions.size()) { log.debug("Hitting total messages rate limits on subscriptions processing. Skipping {} messages", clientSubscriptions.size() - availableTokens); } return clientSubscriptions.subList(0, availableTokens); } return clientSubscriptions; }
[*] target: assertEquals(list, result)
[-] pred: org. junit. Assert. assertEquals ( list, result )
************************************
************************************
[+] input: givenPubMsgAndSubscriptionWithSameQosAndFalseRetainAsPublish_whenProcessUpdatePublishMsg_thenReturnSameMsg() { Subscription subscription = new Subscription("test/topic", 1, ClientSessionInfo.builder().build()); QueueProtos.PublishMsgProto beforePublishMsgProto = QueueProtos.PublishMsgProto.newBuilder().setQos(1).setRetain(false).build();  QueueProtos.PublishMsgProto afterPublishMsgProto = downLinkProxy.updatePublishMsg(subscription, beforePublishMsgProto);  Assert."<AssertPlaceHolder>"; }
updatePublishMsg(Subscription subscription, PublishMsgProto publishMsgProto) { var minQos = Math.min(subscription.getQos(), publishMsgProto.getQos()); var retain = subscription.getOptions().isRetain(publishMsgProto.getRetain());  if (minQos != publishMsgProto.getQos() || retain != publishMsgProto.getRetain()) { return publishMsgProto.toBuilder() .setQos(minQos) .setRetain(retain) .build(); } else { return publishMsgProto; } }
[*] target: assertEquals(beforePublishMsgProto, afterPublishMsgProto)
[-] pred: org. junit. Assert. assertEquals ( beforePublishMsgProto, afterPublishMsgProto )
************************************
************************************
[+] input: givenSameClient_whenCheckIsAnyOtherDeviceClientConnected_thenFalse() { when(clientSessionInfo1.isConnected()).thenReturn(true); when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_1, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertFalse(anyDeviceClientConnected)
[-] pred: org. junit. Assert. assertFalse ( anyDeviceClientConnected )
************************************
************************************
[+] input: givenDisconnectedClients_whenCheckIsAnyOtherDeviceClientConnected_thenFalse() { when(clientSessionInfo1.isConnected()).thenReturn(false); when(clientSessionInfo2.isConnected()).thenReturn(false);  when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1); when(clientSessionInfo2.getClientId()).thenReturn(CLIENT_ID_2);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") )); sharedSubscriptionCache.put(CLIENT_ID_2, List.of( new TopicSubscription("something", 2, "g1") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_3, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertFalse(anyDeviceClientConnected)
[-] pred: org. junit. Assert. assertFalse ( anyDeviceClientConnected )
************************************
************************************
[+] input: givenConnectedClient_whenCheckIsAnyOtherDeviceClientConnected_thenTrue() { when(clientSessionInfo1.isConnected()).thenReturn(true); when(clientSessionInfo2.isConnected()).thenReturn(false);  when(clientSessionInfo1.getClientId()).thenReturn(CLIENT_ID_1); when(clientSessionInfo2.getClientId()).thenReturn(CLIENT_ID_2);  sharedSubscriptionCache.put(CLIENT_ID_1, List.of( new TopicSubscription("something", 2, "g1"), new TopicSubscription("#", 0, "g2") )); sharedSubscriptionCache.put(CLIENT_ID_2, List.of( new TopicSubscription("something", 2, "g1") ));  TopicSharedSubscription topicSharedSubscription = new TopicSharedSubscription("something", "g1"); boolean anyDeviceClientConnected = sharedSubscriptionCache.isAnyOtherDeviceClientConnected(CLIENT_ID_3, topicSharedSubscription); "<AssertPlaceHolder>"; }
isAnyOtherDeviceClientConnected(String clientId, TopicSharedSubscription topicSharedSubscription) { if (log.isTraceEnabled()) { log.trace("[{}] Executing isAnyOtherDeviceClientConnected!", topicSharedSubscription); } SharedSubscriptions sharedSubscriptions = sharedSubscriptionsMap.get(topicSharedSubscription); if (sharedSubscriptions == null) { log.error("Failed to find any shared subscriptions for the key {}", topicSharedSubscription); throw new RuntimeException("Failed to find any shared subscriptions for the key " + topicSharedSubscription); }  Set<Subscription> deviceSubscriptions = sharedSubscriptions.getDeviceSubscriptions(); long count = deviceSubscriptions .stream() .filter(subscription -> !subscription.getClientSessionInfo().getClientId().equals(clientId)) .filter(subscription -> findClientSessionInfo(subscription.getClientSessionInfo().getClientId()).isConnected()) .filter(subscription -> subscription.getQos() > 0) .count(); return count > 0; }
[*] target: assertTrue(anyDeviceClientConnected)
[-] pred: org. junit. Assert. assertTrue ( anyDeviceClientConnected )
************************************
************************************
[+] input: givenPubMsgWithoutTopicAlias_whenGetTopicNameByAlias_thenNoTopicReturned() { topicAliasCtx = new TopicAliasCtx(true, 5);  MqttProperties properties = new MqttProperties(); PublishMsg publishMsg = PublishMsg.builder().properties(properties).build(); String topicNameByAlias = topicAliasCtx.getTopicNameByAlias(publishMsg);  Assert."<AssertPlaceHolder>"; }
getTopicNameByAlias(PublishMsg publishMsg) { if (enabled) { var receivedTopicName = publishMsg.getTopicName(); var topicAliasProperty = MqttPropertiesUtil.getTopicAliasProperty(publishMsg.getProperties()); if (topicAliasProperty != null) { int topicAlias = topicAliasProperty.value(); validateTopicAlias(topicAlias);  if (receivedTopicName.isEmpty()) { var topicName = getTopicByAlias(topicAlias); if (topicName == null) { throw new MqttException(UNKNOWN_TOPIC_ALIAS_MSG); } else { return topicName; } } else { saveMapping(topicAlias, receivedTopicName); return receivedTopicName; } } } return null; }
[*] target: assertNull(topicNameByAlias)
[-] pred: org. junit. Assert. assertNull ( topicNameByAlias )
************************************
************************************
[+] input: givenMaxAliasesReached_whenGetNextTopicAlias_thenDoNotReturnNewAlias() { topicAliasCtx = new TopicAliasCtx(true, 2, new ConcurrentHashMap<>(Map.of(1, "1", 2, "2")), new ConcurrentHashMap<>());  int topicAlias = topicAliasCtx.getNextTopicAlias("test/topic/1"); Assert."<AssertPlaceHolder>"; }
getNextTopicAlias(String topicName) { if (isMoreTopicAliasAvailable()) { int lastTopicAlias = serverMappings.size(); int nextTopicAlias = lastTopicAlias + 1; serverMappings.put(topicName, nextTopicAlias); return nextTopicAlias; } return 0; }
[*] target: assertEquals(0, topicAlias)
[-] pred: org. junit. Assert. assertEquals ( 0, topicAlias )
************************************
************************************
[+] input: givenMaxAliasesNotReached_whenGetNextTopicAlias_thenReturnNewAlias() { topicAliasCtx = new TopicAliasCtx(true, 2, new ConcurrentHashMap<>(), new ConcurrentHashMap<>(Map.of("1", 1)));  int topicAlias = topicAliasCtx.getNextTopicAlias("test/topic/1"); Assert."<AssertPlaceHolder>"; }
getNextTopicAlias(String topicName) { if (isMoreTopicAliasAvailable()) { int lastTopicAlias = serverMappings.size(); int nextTopicAlias = lastTopicAlias + 1; serverMappings.put(topicName, nextTopicAlias); return nextTopicAlias; } return 0; }
[*] target: assertEquals(2, topicAlias)
[-] pred: org. junit. Assert. assertEquals ( 2, topicAlias )
************************************
************************************
[+] input: JSONException { final JSONObject o = new JSONObject(); final FeatureList list = FeatureList.parse(o); Assert."<AssertPlaceHolder>"; }
isEmpty() { return this.features.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty ( ) )
************************************
************************************
[+] input: testLabelTreeKeyRegressionShare_sharedNodesShouldBeEqual() { int depth = 20; int from = 2000; int to = 3000; IPRF aesni = PRFFactory.getDefaultPRF(); TreeKeyRegression reg = (TreeKeyRegression) TreeKeyRegressionFactory.getNewDefaultTESTKeyRegression(aesni, depth); LabelTreeKeyRegression reg2 = new LabelTreeKeyRegression(aesni, depth, new byte[16]); ArrayList<SeedNode> nodes = reg.revealSeeds(from, to); List<SeedNode> nodes2 = reg2.constrainNodes(from, to + 1);  for (SeedNode tn : nodes2) { boolean ok = false; for (SeedNode sn : nodes) { if (Arrays.equals(sn.getSeed(), tn.getSeed())) { ok = true; break; } } "<AssertPlaceHolder>"; } }
revealSeeds(long from, long to) { assert isOwner; ArrayList<SeedNode> seedNodes = new ArrayList<SeedNode>(); if (from > to || rootSeed == null) throw new RuntimeException(String.format("%d is not smaller than %d", from, to)); for (int d = depth; d >= 0; d--) { for (int i = 0; i < kFactor - 1; i++) { if (from == to) { TreeKeyRegressionNode node = reveal(d, from); if (!seedNodes.contains(node)) seedNodes.add(node); } if (from % kFactor != 0) { TreeKeyRegressionNode node = reveal(d, from); if (!seedNodes.contains(node)) seedNodes.add(node); from++; } if (to % kFactor != kFactor - 1) { TreeKeyRegressionNode node = reveal(d, to); if (!seedNodes.contains(node)) seedNodes.add(node); to--; } if (from > to) { break; } } if (from > to) { break; } from /= kFactor; to /= kFactor; } sortNodeArray(seedNodes); return seedNodes; }
[*] target: assertTrue(ok)
[-] pred: org. junit. Assert. assertTrue ( ok )
************************************
************************************
[+] input: DecodingException { AlfenSignatureVerifier verifier = new AlfenSignatureVerifier(); AlfenReader reader = new AlfenReader(); AlfenSignature signature = reader.parseString(ALFEN_TEST_STRING); String publicKey = signature.getPublicKey();  boolean result = verifier.verify(EncodingType.base32Decode(publicKey), signature.getSignature(), signature.getDataset()); Assert."<AssertPlaceHolder>"; }
verify(byte[] publicKey, byte[] signature, byte[] payloadData) throws ValidationException { ECDSASigner signer = new ECDSASigner(); X9ECParameters ecParameters = SECNamedCurves.getByName(ELLIPTIC_CURVE_ALGORITHM); ECCurve curve = ecParameters.getCurve();  //create the public key paramters for init of the signing lib ECDomainParameters ecDomainParameters = new ECDomainParameters(curve, ecParameters.getG(), ecParameters.getN(), ecParameters.getH(), ecParameters.getSeed()); ECPublicKeyParameters publicKeyParsed; try { publicKeyParsed = new ECPublicKeyParameters(curve.decodePoint(publicKey), ecDomainParameters); } catch (IllegalArgumentException e) { LOGGER.error("Invalid point given for public key", e); //is thrown if point is not valid e.g. not on curve throw new ValidationException("Invalid public key point given", "error.invalid.public.key"); }  if (signature.length != SIGNATURE_LENGTH) { throw new ValidationException("Invalid length of signature given", "error.invalid.signature.length"); } //verify the signature divided in two coordinates, r and s BigInteger signatureR = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 0, 24)); BigInteger signatureS = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 24, 24));  byte[] hashedData = Utils.hashSHA256(payloadData);  signer.init(false, publicKeyParsed); boolean verify = signer.verifySignature(hashedData, signatureR, signatureS); VerificationLogger.log("ALFEN", ELLIPTIC_CURVE_ALGORITHM, publicKey, hashedData, signature, verify); return verify;  }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: DecodingException { AlfenSignatureVerifier verifier = new AlfenSignatureVerifier(); AlfenReader reader = new AlfenReader(); AlfenSignature signature = reader.parseString(ALFEN_TEST_STRING_2); boolean result = verifier.verify(EncodingType.base32Decode(signature.getPublicKey()), signature.getSignature(), signature.getDataset()); Assert."<AssertPlaceHolder>"; }
verify(byte[] publicKey, byte[] signature, byte[] payloadData) throws ValidationException { ECDSASigner signer = new ECDSASigner(); X9ECParameters ecParameters = SECNamedCurves.getByName(ELLIPTIC_CURVE_ALGORITHM); ECCurve curve = ecParameters.getCurve();  //create the public key paramters for init of the signing lib ECDomainParameters ecDomainParameters = new ECDomainParameters(curve, ecParameters.getG(), ecParameters.getN(), ecParameters.getH(), ecParameters.getSeed()); ECPublicKeyParameters publicKeyParsed; try { publicKeyParsed = new ECPublicKeyParameters(curve.decodePoint(publicKey), ecDomainParameters); } catch (IllegalArgumentException e) { LOGGER.error("Invalid point given for public key", e); //is thrown if point is not valid e.g. not on curve throw new ValidationException("Invalid public key point given", "error.invalid.public.key"); }  if (signature.length != SIGNATURE_LENGTH) { throw new ValidationException("Invalid length of signature given", "error.invalid.signature.length"); } //verify the signature divided in two coordinates, r and s BigInteger signatureR = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 0, 24)); BigInteger signatureS = new BigInteger(PLUS_SIGN, Utils.copyFromWithLength(signature, 24, 24));  byte[] hashedData = Utils.hashSHA256(payloadData);  signer.init(false, publicKeyParsed); boolean verify = signer.verifySignature(hashedData, signatureR, signatureS); VerificationLogger.log("ALFEN", ELLIPTIC_CURVE_ALGORITHM, publicKey, hashedData, signature, verify); return verify;  }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: test_read_public_key() { final SignatureOnlyVerificationParser parser = new SignatureOnlyVerificationParser(); final String s = parser.parsePublicKey(TestUtils.TEST_SIG_ONLY); Assert."<AssertPlaceHolder>"; }
parsePublicKey(String data) { try { final SignedMeterValue signedMeterValue = smlReader.readFromString(Utils.unescapeXML(data)); return signedMeterValue.getPublicKey() != null ? signedMeterValue.getPublicKey().getCleanedValue() : null; } catch (final ValidationException e) { return null; } }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: InterruptedException {  long second = Instant.parse("2021-12-31T23:59:59.000Z").getEpochSecond(); long leapSecond = second - 1; // simulate a leap second long times[] = { second, leapSecond };  Clock clock = new Clock() { private int i;  @Override public long millis() { return times[i++ % times.length] * 1000; }  @Override public ZoneId getZone() { return null; }  @Override public Clock withZone(ZoneId zone) { return null; }  @Override public Instant instant() { return null; } };  // a function that forces the clock to restart to ZERO IntFunction<byte[]> randomFunction = x -> new byte[x];  TsidFactory factory = TsidFactory.builder().withClock(clock).withRandomFunction(randomFunction).build();  long ms1 = factory.create().getUnixMilliseconds(); // second long ms2 = factory.create().getUnixMilliseconds(); // leap second  "<AssertPlaceHolder>"; // LEAP SECOND! DON'T MOVE BACKWARDS! }
create() { lock.lock(); try { final long _time = getTime() << RANDOM_BITS; final long _node = (long) this.node << this.counterBits; final long _counter = (long) this.counter & this.counterMask;  return new Tsid(_time | _node | _counter); } finally { lock.unlock(); } }
[*] target: assertEquals(ms1, ms2)
[-] pred: org. junit. Assert. assertEquals ( ms1, ms2 )
************************************
************************************
[+] input: testToString() { for (int i = 0; i < LOOP_MAX; i++) { final long number = ThreadLocalRandom.current().nextLong(); final String string0 = toString(number); final String string1 = Tsid.from(number).toString(); "<AssertPlaceHolder>"; } }
toString() { return toString(ALPHABET_UPPERCASE); }
[*] target: assertEquals(string0, string1)
[-] pred: org. junit. Assert. assertEquals ( string0, string1 )
************************************
************************************
[+] input: InterruptedException { Node node1 = Node.instanceOf("127.0.0.1:10001"); NodeEntry ne1 = new NodeEntry(node1); Thread.sleep(1); Node node2 = Node.instanceOf("127.0.0.1:10002"); NodeEntry ne2 = new NodeEntry(node2); TimeComparator tc = new TimeComparator(); int result = tc.compare(ne1, ne2); Assert."<AssertPlaceHolder>";  }
compare(NodeEntry e1, NodeEntry e2) { long t1 = e1.getModified(); long t2 = e2.getModified();  if (t1 < t2) { return 1; } else if (t1 > t2) { return -1; } else { return 0; } }
[*] target: assertEquals(1, result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: test2() { List<MahjongTileDef> mahjongInHand = List.of( MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._4_TIAO, MahjongTileDef._6_TIAO, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._4_BING, MahjongTileDef._4_BING, MahjongTileDef._4_BING, MahjongTileDef._5_BING, MahjongTileDef._5_BING );  boolean canHu = HuFormula.test( mahjongInHand, MahjongTileDef._5_TIAO );  Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: test3() { List<MahjongTileDef> mahjongInHand = List.of( MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._5_WAN, MahjongTileDef._1_TIAO, MahjongTileDef._2_TIAO, MahjongTileDef._3_TIAO, MahjongTileDef._4_TIAO, MahjongTileDef._5_TIAO, MahjongTileDef._6_TIAO, MahjongTileDef._7_TIAO );  boolean canHu = HuFormula.test( mahjongInHand, MahjongTileDef._1_TIAO );  Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: test4() { List<MahjongTileDef> mahjongInHand = Arrays.asList( MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._1_WAN, MahjongTileDef._2_WAN, MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._5_WAN, MahjongTileDef._6_WAN, MahjongTileDef._7_WAN, MahjongTileDef._8_WAN, MahjongTileDef._9_WAN, MahjongTileDef._9_WAN, MahjongTileDef._9_WAN );  // 测试是否可以胡牌 boolean canHu = HuFormula.test(mahjongInHand, MahjongTileDef._5_WAN); Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: test5() { List<MahjongTileDef> mahjongInHand = Arrays.asList( MahjongTileDef._2_WAN, MahjongTileDef._3_WAN, MahjongTileDef._4_WAN, MahjongTileDef._6_TIAO, MahjongTileDef._7_TIAO, MahjongTileDef._1_BING, MahjongTileDef._2_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._3_BING, MahjongTileDef._4_BING, MahjongTileDef._5_BING, MahjongTileDef._6_BING );  // 测试是否可以胡牌 boolean canHu = HuFormula.test(mahjongInHand, MahjongTileDef._5_TIAO); Assert."<AssertPlaceHolder>"; }
test(final List<MahjongTileDef> mahjongInHand, final MahjongTileDef mahjongAtLast) { if (null == mahjongInHand || mahjongInHand.size() <= 0 || null == mahjongAtLast) { return false; }  if (1 != mahjongInHand.size() % 3) { // 手里的麻将牌的数量必须是 13、10、7、4、1, // 否则无法执行接下来的逻辑... return false; }  if (1 == mahjongInHand.size()) { // 如果手里就剩下最后一张牌了, // 那就看看能不能凑成对子 return mahjongInHand.get(0) == mahjongAtLast; }  // 不可能的数量 int impossibleCount = 0;  for (MahjongTileDef currT : mahjongInHand) { if (null != currT && currT == mahjongAtLast) { // 统计一下手里的麻将牌有多少张和最后的麻将牌是一样的 ++impossibleCount; } }  if (impossibleCount >= 4) { // 如果手里已有 4 张牌和最后的麻将牌一样, // 那么最后的这张牌不可能胡牌! // 例如手里有 4 张一饼, // 那么就不可能摸到第 5 张一饼胡牌... return false; }  // 测试列表 final List<MahjongTileDef> tTestList = new ArrayList<>(14); tTestList.addAll(mahjongInHand); tTestList.add(mahjongAtLast); tTestList.sort(Comparator.comparingInt(MahjongTileDef::getIntVal));  // 看看是不是七小对... if (isQiXiaoDui(tTestList)) { return true; }  // 最大测试次数 final int maxTestTimez = tTestList.size(); // 创建临时列表 final List<MahjongTileDef> tTempList = new ArrayList<>(maxTestTimez); // 已经测试的对子 final Set<MahjongTileDef> testedDuiZi = new HashSet<>();  for (int i = 0; i < maxTestTimez - 1; i++) { // 首先找到对子出现的位置, if (tTestList.get(i) != tTestList.get(i + 1)) { continue; }  // 要移除的对子 MahjongTileDef removingDuiZi = tTestList.get(i);  if (testedDuiZi.contains(removingDuiZi)) { // 如果已经测试过这个对子, continue; }  testedDuiZi.add(removingDuiZi);  // 检查剩下的牌是否可以凑成顺子或者刻子 // for (int j = 0; j < maxTestTimez - 4; j++) { // 重新初始化临时列表 tTempList.clear(); tTempList.addAll(tTestList);  // 移除指定的对子 tTempList.remove(removingDuiZi); tTempList.remove(removingDuiZi);  // 剪切掉从指定位置开始所有的顺子 cutAllShunZi(tTempList, j); // 剪切掉所有的刻子 cutAllKeZi(tTempList);  if (tTempList.size() > 2) { // 如果出现这种情况, // 则说明在当前位置 i 之前还存在顺子, // 尝试剪切掉剩下的顺子... cutAllShunZi(tTempList, 0); // 为什么还要再次剪掉顺子, // 可以思考这样的情况: // 81, 82, 83, 83, 83, 83, 84, 85, 86, }  if (tTempList.isEmpty()) { return true; } } }  return false; }
[*] target: assertTrue(canHu)
[-] pred: org. junit. Assert. assertTrue ( canHu )
************************************
************************************
[+] input: Exception { IPath workspacePath = new Path("/noSuchProject/andNoFolder"); IPath osPath = ProjectUtils.getOSPath(workspacePath); "<AssertPlaceHolder>"; }
getOSPath(IPath path) { IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot(); IResource resource = workspaceRoot.findMember(path); return resource != null ? resource.getLocation() : null; }
[*] target: assertNull(osPath)
[-] pred: org. junit. Assert. assertNull ( osPath )
************************************
************************************
[+] input: Exception { Object imageDescriptor = null; Object image = ReflectionUtils.invokeMethod( ManagerClass, "getImage(org.eclipse.jface.resource.ImageDescriptor)", imageDescriptor); "<AssertPlaceHolder>"; }
getImage(ImageDescriptor descriptor) { if (descriptor == null) { return null; } Image image = m_descriptorImageMap.get(descriptor); if (image == null) { image = descriptor.createImage(); m_descriptorImageMap.put(descriptor, image); } return image; }
[*] target: assertNull(image)
[-] pred: org. junit. Assert. assertNull ( image )
************************************
************************************
[+] input: testShouldProduceTheSameMnemonic() { final String expected = "clinic excuse minimum until indoor flower fun concert inquiry letter audit patrol"; final String actual = MnemonicUtils.generateMnemonic(MnemonicUtils.generateEntropy(expected)); "<AssertPlaceHolder>"; }
generateEntropy(String mnemonic) { final BitSet bits = new BitSet(); final int size = mnemonicToBits(mnemonic, bits); if (size == 0) { throw new IllegalArgumentException("Empty mnemonic"); }  final int ent = 32 * size / 33; if (ent % 8 != 0) { throw new IllegalArgumentException("Wrong mnemonic size"); } final byte[] entropy = new byte[ent / 8]; for (int i = 0; i < entropy.length; i++) { entropy[i] = readByte(bits, i); } validateEntropy(entropy);  final byte expectedChecksum = calculateChecksum(entropy); final byte actualChecksum = readByte(bits, entropy.length); if (expectedChecksum != actualChecksum) { throw new IllegalArgumentException("Wrong checksum"); }  return entropy; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { final String html = "<html><head>\n" + "  <script src='script.js'></script>\n" + "</head>\n" + "<body>\n" + "</body>\n" + "</html>";  final WebClient webClient = getWebClient();  final List<String> collectedIncorrectness = new ArrayList<>(); final IncorrectnessListener listener = new IncorrectnessListener() { @Override public void notify(final String message, final Object origin) { collectedIncorrectness.add(message); } }; webClient.setIncorrectnessListener(listener);  final MockWebConnection webConnection = new MockWebConnection(); webClient.setWebConnection(webConnection); webConnection.setResponse(URL_FIRST, html); webConnection.setDefaultResponse("alert('Hello');", "application/x-javascript"); webClient.getPage(URL_FIRST);  final String[] expectedIncorrectness = { "Obsolete content type encountered: 'application/x-javascript' for " + "remotely loaded JavaScript element at 'http://localhost:22222/script.js'." }; "<AssertPlaceHolder>"; }
notify(String message, Object origin);
[*] target: assertEquals(expectedIncorrectness, collectedIncorrectness)
[-] pred: org. junit. Assert. assertEquals ( expectedIncorrectness, collectedIncorrectness )
************************************
************************************
[+] input: isInNetRange() { final boolean isInNet = ProxyAutoConfig.isInNet("172.22.0.7", "172.16.0.0", "255.240.0.0"); "<AssertPlaceHolder>"; }
isInNet(final String host, final String pattern, final String mask) { final String dnsResolve = dnsResolve(host); if (null == dnsResolve) { return false; }  final SubnetUtils subnetUtils = new SubnetUtils(pattern, mask); return subnetUtils.getInfo().isInRange(dnsResolve); }
[*] target: assertTrue(isInNet)
[-] pred: org. junit. Assert. assertTrue ( isInNet )
************************************
************************************
[+] input: Exception { final WebClient client = getWebClient(); final WebWindow window = client.openWindow(null, "TestingWindow"); "<AssertPlaceHolder>"; }
openWindow(final URL url, final String windowName) { WebAssert.notNull("windowName", windowName); return openWindow(url, windowName, getCurrentWindow()); }
[*] target: assertNotNull(window)
[-] pred: org. junit. Assert. assertNotNull ( window )
************************************
************************************
[+] input: Exception { final WebClient client = getWebClient(); final WebWindow window = client.openWindow(UrlUtils.URL_ABOUT_BLANK, "TestingWindow"); "<AssertPlaceHolder>"; }
openWindow(final URL url, final String windowName) { WebAssert.notNull("windowName", windowName); return openWindow(url, windowName, getCurrentWindow()); }
[*] target: assertNotNull(window)
[-] pred: org. junit. Assert. assertNotNull ( window )
************************************
************************************
[+] input: Exception { final String html = "<html><head><title>foo</title></head><body>\n" + "<form id='form1' method='post'>\n" + "  <input type='text' name='textfield' value='*'/>\n" + "  <input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(html); final MockWebConnection webConnection = getMockConnection(page);  final HtmlForm form = page.getHtmlElementById("form1");  final HtmlSubmitInput button = form.getInputByName("button"); button.click();  final List<NameValuePair> expectedParameters = Arrays.asList(new NameValuePair[]{ new NameValuePair("textfield", "*"), new NameValuePair("button", "foo") }); final List<NameValuePair> collectedParameters = webConnection.getLastParameters();  "<AssertPlaceHolder>"; }
getInputByName(final String name) throws ElementNotFoundException { final List<HtmlInput> inputs = getInputsByName(name);  if (inputs.isEmpty()) { throw new ElementNotFoundException(HtmlInput.TAG_NAME, NAME_ATTRIBUTE, name); } return (I) inputs.get(0); }
[*] target: assertEquals(expectedParameters, collectedParameters)
[-] pred: org. junit. Assert. assertEquals ( expectedParameters, collectedParameters )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html>\n" + "<head><title>foo</title></head>\n" + "<body>\n" + "<form><p>hello world</p>\n" + "<input name='foo' type='submit' disabled='disabled' id='foo'/>\n" + "<input name='bar' type='submit' id='bar'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final List<HtmlElement> expectedElements = new ArrayList<>(); expectedElements.add(page.getHtmlElementById("bar"));  "<AssertPlaceHolder>"; }
getTabbableElements() { final List<HtmlElement> tabbableElements = new ArrayList<>(); for (final HtmlElement element : getHtmlElementDescendants()) { final String tagName = element.getTagName(); if (TABBABLE_TAGS.contains(tagName)) { final boolean disabled = element.hasAttribute(ATTRIBUTE_DISABLED); if (!disabled && !HtmlElement.TAB_INDEX_OUT_OF_BOUNDS.equals(element.getTabIndex())) { tabbableElements.add(element); } } } tabbableElements.sort(createTabOrderComparator()); return Collections.unmodifiableList(tabbableElements); }
[*] target: assertEquals(expectedElements, page.getTabbableElements())
[-] pred: org. junit. Assert. assertEquals ( expectedElements, page. getTabbableElements ( ) )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html>\n" + "<head><title>foo</title></head><body>\n" + "<a id='a' accesskey='a'>foo</a>\n" + "<a id='b' accesskey='a'>foo</a>\n" + "<form>\n" + "<a id='c' accesskey='c'>foo</a>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final List<HtmlElement> expectedElements = Arrays.asList(new HtmlElement[] {page.getHtmlElementById("a"), page.getHtmlElementById("b")}); final List<HtmlElement> collectedElements = page.getHtmlElementsByAccessKey('a'); "<AssertPlaceHolder>"; }
getHtmlElementsByAccessKey(final char accessKey) { final List<HtmlElement> elements = new ArrayList<>();  final String searchString = Character.toString(accessKey).toLowerCase(Locale.ROOT); for (final HtmlElement element : getHtmlElementDescendants()) { if (ACCEPTABLE_TAG_NAMES.contains(element.getTagName())) { final String accessKeyAttribute = element.getAttributeDirect("accesskey"); if (searchString.equalsIgnoreCase(accessKeyAttribute)) { elements.add(element); } } }  return elements; }
[*] target: assertEquals(expectedElements, collectedElements)
[-] pred: org. junit. Assert. assertEquals ( expectedElements, collectedElements )
************************************
************************************
[+] input: Exception { final String html = "<html>\n" + "<head>\n" + "<base href='" + URL_SECOND + "'>\n" + "<base href='" + URL_THIRD + "'>\n" + "</head>\n" + "<body>\n" + "  <a href='somepage.html'>\n" + "</body></html>";  final WebClient webClient = getWebClient(); final List<String> collectedIncorrectness = new ArrayList<>(); final IncorrectnessListener listener = new IncorrectnessListener() { @Override public void notify(final String message, final Object origin) { collectedIncorrectness.add(message); } }; webClient.setIncorrectnessListener(listener);  final MockWebConnection webConnection = new MockWebConnection(); webClient.setWebConnection(webConnection); webConnection.setDefaultResponse(html); final HtmlPage page = webClient.getPage(URL_FIRST); page.getAnchors().get(0).click();  final String[] expectedIncorrectness = {"Multiple 'base' detected, only the first is used.", "Multiple 'base' detected, only the first is used."}; "<AssertPlaceHolder>"; }
getAnchors() { return getDocumentElement().getElementsByTagNameImpl("a"); }
[*] target: assertEquals(expectedIncorrectness, collectedIncorrectness)
[-] pred: org. junit. Assert. assertEquals ( expectedIncorrectness, collectedIncorrectness )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html><head><title>foo</title></head><body>\n" + "<form id='form1'><select name='select1' id='select1' multiple>\n" + "<option value='option1'>Option1</option>\n" + "<option value='option2' >Option2</option>\n" + "<option value='option3'>Option3</option>\n" + "</select>\n" + "<input type='submit' name='button' value='foo'/>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlSelect select = page.getHtmlElementById("select1"); "<AssertPlaceHolder>"; }
isMultipleSelectEnabled() { return getAttributeDirect("multiple") != ATTRIBUTE_NOT_DEFINED; }
[*] target: assertTrue(select.isMultipleSelectEnabled())
[-] pred: org. junit. Assert. assertTrue ( select. isMultipleSelectEnabled ( ) )
************************************
************************************
[+] input: Exception { final String firstContent = "<html><head>\n" + "<script>\n" + "var foo = 'foo';\n" + "var test = new Function('alert(foo);');\n" + "</script>\n" + "</head>\n" + "<body onload='test()'>\n" + "  <iframe src='page2.html'/>\n" + "</body>\n" + "</html>";  final String secondContent = "<html><head><script>\n" + "var foo = 'foo2';\n" + "parent.test();\n" + "var f = parent.test;\n" + "f();\n" + "</script></head></html>";  final WebClient client = getWebClient(); final MockWebConnection webConnection = new MockWebConnection(); webConnection.setDefaultResponse(secondContent); webConnection.setResponse(URL_FIRST, firstContent); client.setWebConnection(webConnection);  final String[] expectedAlerts = {"foo", "foo", "foo"};  final List<String> collectedAlerts = new ArrayList<>(); client.setAlertHandler(new CollectingAlertHandler(collectedAlerts)); client.getPage(URL_FIRST);  "<AssertPlaceHolder>"; }
getWebClient() { return webClient_; }
[*] target: assertEquals(expectedAlerts, collectedAlerts)
[-] pred: org. junit. Assert. assertEquals ( expectedAlerts, collectedAlerts )
************************************
************************************
[+] input: testParseJSONtoHdbtiSuccessfullyWithFileNameWithoutPath() { XSKHDBTIImportConfigModel model = new XSKHDBTIImportConfigModel(); model.setDelimEnclosing("'"); model.setSchemaName("schema"); model.setHeader(true); model.setTableName("table"); model.setFileName("myData2.csv");  String expectedValue = "import = [\n" + "{\n" + "\tdelimEnclosing="'";\n" + "\tschema = "schema";\n" + "\theader = true;\n" + "\ttable = "table";\n" + "\tfile = "myData2.csv";\n" + "}];";  String actualResult = processor.parseJSONtoHdbti(new ArrayList<>(Arrays.asList(model))); "<AssertPlaceHolder>"; }
parseJSONtoHdbti(ArrayList<XSKHDBTIImportConfigModel> json) { for (XSKHDBTIImportConfigModel el : json) { try { el.setFileName(XSKHDBTIUtils.convertPathToHDBTIFileProperty(el.getFileName())); } catch (IllegalArgumentException ex) { XSKCommonsUtils.logProcessorErrors(ex.getMessage(), XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw ex; } if (!el.getTableName().contains("::") && el.getSchemaName() == null) { String errMsg = "Missing schema property"; XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (el.getSchemaName() != null && !XSKHDBTIUtils.isCorrectPropertySyntax(el.getSchemaName())) { String errMsg = "Schema property contains unsupported symbols: " + el.getSchemaName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (!XSKHDBTIUtils.isCorrectTablePropertySyntax(el.getTableName())) { String errMsg = "Table property contains unsupported symbols: " + el.getTableName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } for (Pair key : el.getKeys()) { if (!XSKHDBTIUtils.isCorrectPropertySyntax(key.getColumn())) { String errMsg = "key column property contains unsupported symbols: " + key.getColumn(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } } }  XSKHDBTIImportModel model = new XSKHDBTIImportModel(); model.setConfigModels(json); return model.toString(); }
[*] target: assertEquals(expectedValue, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualResult )
************************************
************************************
[+] input: testParseJSONtoHdbtiSuccessfullyWithMissingSchemaName() { XSKHDBTIImportConfigModel model = new XSKHDBTIImportConfigModel();  model.setDelimEnclosing("'"); model.setHeader(true); model.setTableName("sap_xsk.test::c_users"); model.setFileName("myData2.csv");  String actualValue = processor.parseJSONtoHdbti(new ArrayList<>(Arrays.asList(model)));  String expectedValue = "import = [\n" + "{\n" + "\tdelimEnclosing="'";\n" + "\theader = true;\n" + "\ttable = "sap_xsk.test::c_users";\n" + "\tfile = "myData2.csv";\n" + "}];";  "<AssertPlaceHolder>"; }
parseJSONtoHdbti(ArrayList<XSKHDBTIImportConfigModel> json) { for (XSKHDBTIImportConfigModel el : json) { try { el.setFileName(XSKHDBTIUtils.convertPathToHDBTIFileProperty(el.getFileName())); } catch (IllegalArgumentException ex) { XSKCommonsUtils.logProcessorErrors(ex.getMessage(), XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw ex; } if (!el.getTableName().contains("::") && el.getSchemaName() == null) { String errMsg = "Missing schema property"; XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (el.getSchemaName() != null && !XSKHDBTIUtils.isCorrectPropertySyntax(el.getSchemaName())) { String errMsg = "Schema property contains unsupported symbols: " + el.getSchemaName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } if (!XSKHDBTIUtils.isCorrectTablePropertySyntax(el.getTableName())) { String errMsg = "Table property contains unsupported symbols: " + el.getTableName(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } for (Pair key : el.getKeys()) { if (!XSKHDBTIUtils.isCorrectPropertySyntax(key.getColumn())) { String errMsg = "key column property contains unsupported symbols: " + key.getColumn(); XSKCommonsUtils.logProcessorErrors(errMsg, XSKCommonsConstants.PROCESSOR_ERROR, el.getFileName(), XSKCommonsConstants.HDBTI_PARSER); throw new IllegalArgumentException(errMsg); } } }  XSKHDBTIImportModel model = new XSKHDBTIImportModel(); model.setConfigModels(json); return model.toString(); }
[*] target: assertEquals(expectedValue, actualValue)
[-] pred: org. junit. Assert. assertEquals ( expectedValue, actualValue )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/multipleTableDeclarations.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/duplicateKeys.hdbti", hdbtiSample); } catch (DuplicateFieldNameException duplicateFieldNameException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/invalidSyntax.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/invalidSyntax.hdbti", hdbtiSample); } catch (XSKArtifactParserException parseErrorException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/invalidTablePropertySyntax.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/invalidTablePropertySyntax.hdbti", hdbtiSample); } catch (TablePropertySyntaxException parseErrorException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: IOException { String hdbtiSample = org.apache.commons.io.IOUtils .toString(XSKHDBTIParserTest.class.getResourceAsStream("/duplicateKeys.hdbti"), StandardCharsets.UTF_8); XSKHDBTIParser xskhdbtiParser = new XSKHDBTIParser();  try { xskhdbtiParser.parse("/test/xsk/com/sap/duplicateKeys.hdbti", hdbtiSample); } catch (DuplicateFieldNameException duplicateFieldNameException) { "<AssertPlaceHolder>"; } catch (Exception e) { fail(); } }
parse(String location, String content) throws IOException, XSKHDBTISyntaxErrorException, XSKArtifactParserException { ByteArrayInputStream is = new ByteArrayInputStream(content.getBytes()); ANTLRInputStream inputStream = new ANTLRInputStream(is); HdbtiLexer hdbtiLexer = new HdbtiLexer(inputStream); XSKHDBTISyntaxErrorListener lexerErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiLexer.removeErrorListeners(); hdbtiLexer.addErrorListener(lexerErrorListener); CommonTokenStream tokenStream = new CommonTokenStream(hdbtiLexer);  HdbtiParser hdbtiParser = new HdbtiParser(tokenStream); hdbtiParser.setBuildParseTree(true); XSKHDBTISyntaxErrorListener parseErrorListener = new XSKHDBTISyntaxErrorListener(); hdbtiParser.removeErrorListeners(); hdbtiParser.addErrorListener(parseErrorListener);  ParseTree parseTree = hdbtiParser.importArr(); XSKCommonsUtils.logParserErrors(parseErrorListener.getErrors(), XSKCommonsConstants.PARSER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER); XSKCommonsUtils.logParserErrors(lexerErrorListener.getErrors(), XSKCommonsConstants.LEXER_ERROR, location, XSKCommonsConstants.HDBTI_PARSER);  XSKHDBTICoreListener XSKHDBTICoreListener = new XSKHDBTICoreListener(); ParseTreeWalker parseTreeWalker = new ParseTreeWalker(); parseTreeWalker.walk(XSKHDBTICoreListener, parseTree);  XSKHDBTIImportModel importModel = XSKHDBTICoreListener.getImportModel(); try { importModel.checkMandatoryFieldsInAllConfigModels(); } catch (Exception e) { XSKCommonsUtils.logCustomErrors(location, XSKCommonsConstants.PARSER_ERROR, "", "", e.getMessage(), XSKCommonsConstants.EXPECTED_FIELDS, XSKCommonsConstants.HDBTI_PARSER,XSKCommonsConstants.MODULE_PARSERS, XSKCommonsConstants.SOURCE_PUBLISH_REQUEST, XSKCommonsConstants.PROGRAM_XSK); throw new XSKHDBTIMissingPropertyException(String.format("Wrong format of hdbti definition: [%s]. [%s]", location, e.getMessage())); }  return importModel; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: run() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  // trigger data final TriggerParam triggerParam = new TriggerParam(); triggerParam.setJobId(1); triggerParam.setExecutorHandler("demoJobHandler"); triggerParam.setExecutorParams(null); triggerParam.setExecutorBlockStrategy(ExecutorBlockStrategyEnum.COVER_EARLY.name()); triggerParam.setGlueType(GlueTypeEnum.BEAN.name()); triggerParam.setGlueSource(null); triggerParam.setGlueUpdatetime(System.currentTimeMillis()); triggerParam.setLogId(1); triggerParam.setLogDateTime(System.currentTimeMillis());  // Act final ReturnT<String> retval = executorBiz.run(triggerParam);  // Assert result Assert."<AssertPlaceHolder>"; }
run(TriggerParam triggerParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
[+] input: readPropertiesFileMissingTest() { Map<String, String> properties = ResourceUtil.readProperties(ResourceUtilTest.class, "missing.properties");  Assertions."<AssertPlaceHolder>"; }
readProperties(Class<?> clazz, String fileName) { return Objects.requireNonNull(getResourceStream(clazz, fileName).map(inputStream -> { Properties properties = new Properties(); try { properties.load(inputStream); return properties.entrySet().stream() .collect(Collectors.toMap(e -> (String) e.getKey(), e -> (String) e.getValue())); } catch (IOException e) { LOGGER.warn("Could not read resource file '{}', binding will probably fail: {}", fileName, e.getMessage()); return new HashMap<String, String>(); } }).orElse(Map.of())); }
[*] target: assertEquals(0, properties.size())
[-] pred: org. junit. Assert. assertEquals ( 0, properties. size ( ) )
************************************
************************************
[+] input: getName_ofCtorValue() { final var expected = "A"; final var obj = new ActivityType(expected); final var actual = obj.getName(); "<AssertPlaceHolder>"; }
getName() { return this.name; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testLatchFilters() { final var horizon = Interval.between(Duration.of(0, Duration.SECONDS), Duration.of(50, Duration.SECONDS)); final var horizonW = new Windows(horizon, true); final var simResults = new SimulationResults( Instant.EPOCH, Interval.between(0, 20, SECONDS), List.of(), Map.of(), Map.of( "smallState1", smallState1(horizon), "smallState2", smallState2(horizon) ) );  final var ste = new Equal<>(new DiscreteResource("smallState1"), new DiscreteValue(SerializedValue.of(true))); final var ste2 = new And( new Equal<>(new DiscreteResource("smallState1"), new DiscreteValue(SerializedValue.of(true))), new Equal<>(new DiscreteResource("smallState2"), new DiscreteValue(SerializedValue.of(true))) );  final var tre = new TimeRangeExpression.Builder() .from(ste) .name("withinEach") .build();  final var filter = new Filters.LatchingBuilder() .withinEach(tre) .filterFirstBy(Filters.minDuration(Duration.of(3, Duration.SECONDS))) .thenFilterBy(Filters.minDuration(Duration.of(4, Duration.SECONDS))) .build();  final var tre2 = new TimeRangeExpression.Builder() .name("tre2") .from(ste2) .thenFilter(filter) .build();  final var res = tre2.computeRange(simResults, null, horizonW);  final var expected = new Windows(interval(0, Inclusive, 20, Exclusive, SECONDS), false) .set(List.of( interval(3, Inclusive, 6, Exclusive, SECONDS), interval(11, Inclusive, 15, Exclusive, SECONDS) ), true);  "<AssertPlaceHolder>"; }
build() { return Filters.withinEach(expr, new FilterLatching(filter1, filter2)); }
[*] target: assertEquals(expected, res)
[-] pred: org. junit. Assert. assertEquals ( expected, res )
************************************
************************************
[+] input: NoSuchAlgorithmException { var originalData = "12345678910!".repeat(1000); var responseInputStream = originalData.getBytes(StandardCharsets.UTF_16);   var md5Hash = MessageDigest.getInstance("MD5").digest(responseInputStream);  var expectedDigestString = Base64.getEncoder().encodeToString(md5Hash);  var checksum = new Md5Checksum().getChecksum(responseInputStream); var digest = checksum.getChecksum();  "<AssertPlaceHolder>";  }
getChecksum(byte[] objectResponse) throws NoSuchAlgorithmException {  MessageDigest md; md = MessageDigest.getInstance(ALGORITHM); var digest = md.digest(objectResponse);  var checksum = Base64.getEncoder().encodeToString(digest); return new Checksum(ALGORITHM, checksum); }
[*] target: assertEquals(expectedDigestString, digest)
[-] pred: org. junit. Assert. assertEquals ( expectedDigestString, digest )
************************************
************************************
[+] input: testSuma1() { int res = Calculadora.suma(2, 3); "<AssertPlaceHolder>"; }
suma(int a, int b) { return a + b; }
[*] target: assertEquals(5, res)
[-] pred: org. junit. Assert. assertEquals ( 5, res )
************************************
************************************
[+] input: testSuma3() { int algo = 7; int res = Calculadora.suma(algo, 0); "<AssertPlaceHolder>"; }
suma(int a, int b) { return a + b; }
[*] target: assertEquals(algo, res)
[-] pred: org. junit. Assert. assertEquals ( algo, res )
************************************
************************************
[+] input: testSuma4() { int res = Calculadora.suma(0, 0); "<AssertPlaceHolder>"; }
suma(int a, int b) { return a + b; }
[*] target: assertEquals(0, res)
[-] pred: org. junit. Assert. assertEquals ( 0, res )
************************************
************************************
[+] input: testResta1() { int res = Calculadora.resta(8, 3); "<AssertPlaceHolder>"; }
resta(int a, int b) { return a + b; }
[*] target: assertEquals(5, res)
[-] pred: org. junit. Assert. assertEquals ( 5, res )
************************************
************************************
[+] input: testResta3() { int algo = 8; int res = Calculadora.resta(algo, 0); "<AssertPlaceHolder>"; }
resta(int a, int b) { return a + b; }
[*] target: assertEquals(algo, res)
[-] pred: org. junit. Assert. assertEquals ( algo, res )
************************************
************************************
[+] input: testResta4() { int res = Calculadora.resta(0, 0); "<AssertPlaceHolder>"; }
resta(int a, int b) { return a + b; }
[*] target: assertEquals(0, res)
[-] pred: org. junit. Assert. assertEquals ( 0, res )
************************************
************************************
[+] input: testMultiplica2() { int algo = 9; int res = Calculadora.multiplica(algo, 1); "<AssertPlaceHolder>"; }
multiplica(int a, int b) { return a * b; }
[*] target: assertEquals(algo, res)
[-] pred: org. junit. Assert. assertEquals ( algo, res )
************************************
************************************
[+] input: testMultiplica6() { int algo = 4; int res = Calculadora.multiplica(0, algo); "<AssertPlaceHolder>"; }
multiplica(int a, int b) { return a * b; }
[*] target: assertEquals(0, res)
[-] pred: org. junit. Assert. assertEquals ( 0, res )
************************************
************************************
[+] input: testMultiplica7() { int res = Calculadora.multiplica(0, 0); "<AssertPlaceHolder>"; }
multiplica(int a, int b) { return a * b; }
[*] target: assertEquals(0, res)
[-] pred: org. junit. Assert. assertEquals ( 0, res )
************************************
************************************
[+] input: testDivide1() { int res = Calculadora.divide(8, 2); "<AssertPlaceHolder>"; }
divide(int a, int b) { return a / b; }
[*] target: assertEquals(4, res)
[-] pred: org. junit. Assert. assertEquals ( 4, res )
************************************
************************************
[+] input: testDivide2() { int algo = 7; int res = Calculadora.divide(algo, 1); "<AssertPlaceHolder>"; }
divide(int a, int b) { return a / b; }
[*] target: assertEquals(algo, res)
[-] pred: org. junit. Assert. assertEquals ( algo, res )
************************************
************************************
[+] input: testDivide3() { int a = 3; int b = 5; int res = Calculadora.divide(Calculadora.multiplica(a, b), b); "<AssertPlaceHolder>"; }
multiplica(int a, int b) { return a * b; }
[*] target: assertEquals(a, res)
[-] pred: org. junit. Assert. assertEquals ( a, res )
************************************
************************************
[+] input: testDivide4() { int a = 3; int b = 5; int res = Calculadora.divide(Calculadora.multiplica(a, b) + 1, b); "<AssertPlaceHolder>"; }
multiplica(int a, int b) { return a * b; }
[*] target: assertEquals(a, res)
[-] pred: org. junit. Assert. assertEquals ( a, res )
************************************
************************************
[+] input: validateNameLargoTest() { try { RecordsManager.validateName(ALEJANDRO); "<AssertPlaceHolder>"; } catch (PlayerNameTooShortException e) { fail(e.getMessage()); } }
validateName(String name) throws PlayerNameTooShortException { /// (5) Validamos la longitud del nombre if (name.length() < MIN_NAME_LENGTH) { throw new PlayerNameTooShortException(name); } }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: validateScore1000Test() { try { RecordsManager.validateScore(ALEJANDRO, 1000); "<AssertPlaceHolder>"; } catch (ScoreTooLowException e) { fail(e.getMessage()); } }
validateScore(String name, int score) throws ScoreTooLowException { /// (6) Validamos la puntuación mínima if (score < MIN_SCORE) { throw new ScoreTooLowException(name, score); } }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: jsonNullIsHandledSafely() { fakeStorage.setJsonData("last_used_dir", "null"); LastUsedDirPref pref = new LastUsedDirPref(fakeStorage);  "<AssertPlaceHolder>"; }
get() { return lastUsedDir; }
[*] target: assertNull(pref.get())
[-] pred: org. junit. Assert. assertNull ( pref. get() )
************************************
************************************
[+] input: testSend() {  //        // params //        final SendRequest sendRequest = new SendRequest("send", 1L, //                new MessageParam("13711111111", new HashMap<>(), new HashMap<>())); // //        // predict result //        final ProcessContext<SendTaskModel> processContext = new ProcessContext<>(sendRequest.getCode(), new SendTaskModel(), false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")); //        final SendResponse expectedResult = new SendResponse(processContext.getResponse().getStatus(), processContext.getResponse().getMsg()); // // //        // stub //        Map<String, ProcessTemplate> templateConfig = new HashMap<>(4); //        processTemplate.setProcessList(Arrays.asList(businessProcess)); //        templateConfig.put(BusinessCode.COMMON_SEND.getCode(), processTemplate); // //        processController.setTemplateConfig(templateConfig); // // //        // Run the test //        final SendResponse result = sendServiceImplUnderTest.send(sendRequest); // //        // Verify the results //        "<AssertPlaceHolder>"; }
send(SendRequest sendRequest) { if (ObjectUtils.isEmpty(sendRequest)) { return new SendResponse(RespStatusEnum.CLIENT_BAD_PARAMETERS.getCode(), RespStatusEnum.CLIENT_BAD_PARAMETERS.getMsg(), null); }  SendTaskModel sendTaskModel = SendTaskModel.builder() .messageTemplateId(sendRequest.getMessageTemplateId()) .messageParamList(Collections.singletonList(sendRequest.getMessageParam())) .build();  ProcessContext context = ProcessContext.builder() .code(sendRequest.getCode()) .processModel(sendTaskModel) .needBreak(false) .response(BasicResultVO.success()).build();  ProcessContext process = processController.process(context);  return new SendResponse(process.getResponse().getStatus(), process.getResponse().getMsg(), (List<SimpleTaskInfo>) process.getResponse().getData()); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testBatchSend() { //        // Setup //        final BatchSendRequest batchSendRequest = new BatchSendRequest("code", 0L, //                Arrays.asList(new MessageParam("receiver", new HashMap<>(), new HashMap<>()))); //        final SendResponse expectedResult = new SendResponse("status", "msg"); // //        // Configure ProcessController.process(...). //        final ProcessContext processContext = new ProcessContext<>("code", null, false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")); //        when(processController.process(new ProcessContext<>("code", null, false, new BasicResultVO<>( //                RespStatusEnum.SUCCESS, "data")))).thenReturn(processContext); // //        // Run the test //        final SendResponse result = sendServiceImplUnderTest.batchSend(batchSendRequest); // //        // Verify the results //        "<AssertPlaceHolder>"; }
batchSend(BatchSendRequest batchSendRequest) { if (ObjectUtils.isEmpty(batchSendRequest)) { return new SendResponse(RespStatusEnum.CLIENT_BAD_PARAMETERS.getCode(), RespStatusEnum.CLIENT_BAD_PARAMETERS.getMsg(), null); }  SendTaskModel sendTaskModel = SendTaskModel.builder() .messageTemplateId(batchSendRequest.getMessageTemplateId()) .messageParamList(batchSendRequest.getMessageParamList()) .build();  ProcessContext context = ProcessContext.builder() .code(batchSendRequest.getCode()) .processModel(sendTaskModel) .needBreak(false) .response(BasicResultVO.success()).build();  ProcessContext process = processController.process(context);  return new SendResponse(process.getResponse().getStatus(), process.getResponse().getMsg(), (List<SimpleTaskInfo>) process.getResponse().getData()); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: readServiceVersionFromEnv() { final String version = "1.2.3"; final Map<String, String> env = new HashMap<>(); env.put("VERSION", version); final TracingAttributes attributes = instance(env); final String actual = attributes.get(ResourceAttributes.SERVICE_VERSION); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(version, actual)
[-] pred: org. junit. Assert. assertEquals ( version, actual )
************************************
************************************
[+] input: readServiceVersionFromSystemProperty() { final String version = "1.2.9"; final Properties properties = new Properties(); properties.put("service.version", version); final TracingAttributes attributes = instance(properties); final String actual = attributes.get(ResourceAttributes.SERVICE_VERSION); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(version, actual)
[-] pred: org. junit. Assert. assertEquals ( version, actual )
************************************
************************************
[+] input: IOException { final String expected = new UUID(0L, 0L).toString(); writeStringToFile(expected, TracingAttributes.getServiceIdFilePath(fileSystem, APP_NAME)); final TracingAttributes attributes = instance(); final String actual = attributes.get(ResourceAttributes.SERVICE_INSTANCE_ID); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { final String rawCpuSetInfo = "/docker/1bfde5a828d33da2aeb5aab0d340f3a032b46bc1d0ca5765c502828b6f148c91"; writeStringToFile(rawCpuSetInfo, TracingAttributes.PROC_1_CPUSET_FILE_PATH); final String expected = "1bfde5a828d33da2aeb5aab0d340f3a032b46bc1d0ca5765c502828b6f148c91"; final TracingAttributes attributes = instance(); final String actual = attributes.get(ResourceAttributes.CONTAINER_ID); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { final String rawCpuSetInfo = "/kubepods/besteffort/pod72832d24-7655-487c-8b85-3f01844639a9/" + "5046b447f1dacb1849cff896e47e3d9b1aa5bcfd513a98e382eae3343e6ab5c2"; writeStringToFile(rawCpuSetInfo, TracingAttributes.PROC_1_CPUSET_FILE_PATH); final String expected = "5046b447f1dacb1849cff896e47e3d9b1aa5bcfd513a98e382eae3343e6ab5c2"; final TracingAttributes attributes = instance(); final String actual = attributes.get(ResourceAttributes.CONTAINER_ID); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { final String machineId = "9bcc0df29af9454298607489a54040e2"; writeStringToFile(machineId, TracingAttributes.MACHINE_ID_FILE_PATH); final TracingAttributes attributes = instance(); final String actual = attributes.get(TracingAttributes.MACHINE_ID); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(machineId, actual)
[-] pred: org. junit. Assert. assertEquals ( machineId, actual )
************************************
************************************
[+] input: readPodNameValid() { final String hostnameThatIsPodName = "fooservice-b55497fc6-x9f56"; final Map<String, String> env = new HashMap<>(); env.put("HOSTNAME", hostnameThatIsPodName); final TracingAttributes attributes = instance(env); final String actual = attributes.get(ResourceAttributes.K8S_POD_NAME); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(hostnameThatIsPodName, actual)
[-] pred: org. junit. Assert. assertEquals ( hostnameThatIsPodName, actual )
************************************
************************************
[+] input: readContainerNameValid() { final String hostnameThatIsPodName = "fooservice-b55497fc6-x9f56"; final Map<String, String> env = new HashMap<>(); env.put("HOSTNAME", hostnameThatIsPodName); final TracingAttributes attributes = instance(env); final String actual = attributes.get(ResourceAttributes.K8S_CONTAINER_NAME); final String expected = "fooservice"; "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: readContainerNameInvalid() { final String hostnameThatIsNotPodName = "generic-hostname"; final Map<String, String> env = new HashMap<>(); env.put("HOSTNAME", hostnameThatIsNotPodName); final TracingAttributes attributes = instance(env); final String actual = attributes.get(ResourceAttributes.K8S_CONTAINER_NAME); "<AssertPlaceHolder>"; }
get(final AttributeKey<T> key) { return inner.get(key); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: queryUnmodifiedWhenNoTrace() { TracingStatementInspector inspector = new TracingStatementInspector(null); String sql = "--latest_transaction_id \n" + "SELECT MAX(transaction_id) FROM transactions"; String actual = inspector.inspect(sql); "<AssertPlaceHolder>"; }
inspect(final String sql) { final Span span = findSpan();  if (span == null) { return sql; }  final String traceId = span.context().traceId(); final String spanId = span.context().spanId(); final boolean traceIdUnknown = UNKNOWN_TRACE_ID.equals(traceId) || isInvalidId(traceId); final boolean spanIdUnknown = UNKNOWN_SPAN_ID.equals(spanId) || isInvalidId(spanId);  span.tag("query", sql);  // There is no trace id and there is no span id if (traceIdUnknown && spanIdUnknown) { return sql; }  final StringBuilder sqlWithTraceIds = new StringBuilder();  /* Allow existing comments to be persisted at the top of the SQL statement * then insert tracing comments below those comments. */ try (Scanner scanner = new Scanner(sql)) { boolean inTopLevelComments = true;  while (scanner.hasNextLine()) { final String line = scanner.nextLine();  if (inTopLevelComments && !line.startsWith("--")) { appendTraceIds(sqlWithTraceIds, traceId, spanId, traceIdUnknown, spanIdUnknown); inTopLevelComments = false; }  sqlWithTraceIds.append(line);  if (scanner.hasNextLine()) { sqlWithTraceIds.append(System.lineSeparator()); } } }  return sqlWithTraceIds.toString(); }
[*] target: assertEquals(sql, actual)
[-] pred: org. junit. Assert. assertEquals ( sql, actual )
************************************
************************************
[+] input: queryUnmodifiedWhenNoSpan() { TracingStatementInspector inspector = new TracingStatementInspector(tracer); String sql = "--latest_transaction_id \n" + "SELECT MAX(transaction_id) FROM transactions"; String actual = inspector.inspect(sql); "<AssertPlaceHolder>"; }
inspect(final String sql) { final Span span = findSpan();  if (span == null) { return sql; }  final String traceId = span.context().traceId(); final String spanId = span.context().spanId(); final boolean traceIdUnknown = UNKNOWN_TRACE_ID.equals(traceId) || isInvalidId(traceId); final boolean spanIdUnknown = UNKNOWN_SPAN_ID.equals(spanId) || isInvalidId(spanId);  span.tag("query", sql);  // There is no trace id and there is no span id if (traceIdUnknown && spanIdUnknown) { return sql; }  final StringBuilder sqlWithTraceIds = new StringBuilder();  /* Allow existing comments to be persisted at the top of the SQL statement * then insert tracing comments below those comments. */ try (Scanner scanner = new Scanner(sql)) { boolean inTopLevelComments = true;  while (scanner.hasNextLine()) { final String line = scanner.nextLine();  if (inTopLevelComments && !line.startsWith("--")) { appendTraceIds(sqlWithTraceIds, traceId, spanId, traceIdUnknown, spanIdUnknown); inTopLevelComments = false; }  sqlWithTraceIds.append(line);  if (scanner.hasNextLine()) { sqlWithTraceIds.append(System.lineSeparator()); } } }  return sqlWithTraceIds.toString(); }
[*] target: assertEquals(sql, actual)
[-] pred: org. junit. Assert. assertEquals ( sql, actual )
************************************
************************************
[+] input: queryUnmodifiedWhenUnknownTracingAndSpanId() { when(traceContext.traceId()).thenReturn(TracingStatementInspector.UNKNOWN_TRACE_ID); when(traceContext.spanId()).thenReturn(TracingStatementInspector.UNKNOWN_SPAN_ID);  TracingStatementInspector inspector = new TracingStatementInspector(tracer); String sql = "--latest_transaction_id \n" + "SELECT MAX(transaction_id) FROM transactions"; String actual = inspector.inspect(sql); "<AssertPlaceHolder>"; }
inspect(final String sql) { final Span span = findSpan();  if (span == null) { return sql; }  final String traceId = span.context().traceId(); final String spanId = span.context().spanId(); final boolean traceIdUnknown = UNKNOWN_TRACE_ID.equals(traceId) || isInvalidId(traceId); final boolean spanIdUnknown = UNKNOWN_SPAN_ID.equals(spanId) || isInvalidId(spanId);  span.tag("query", sql);  // There is no trace id and there is no span id if (traceIdUnknown && spanIdUnknown) { return sql; }  final StringBuilder sqlWithTraceIds = new StringBuilder();  /* Allow existing comments to be persisted at the top of the SQL statement * then insert tracing comments below those comments. */ try (Scanner scanner = new Scanner(sql)) { boolean inTopLevelComments = true;  while (scanner.hasNextLine()) { final String line = scanner.nextLine();  if (inTopLevelComments && !line.startsWith("--")) { appendTraceIds(sqlWithTraceIds, traceId, spanId, traceIdUnknown, spanIdUnknown); inTopLevelComments = false; }  sqlWithTraceIds.append(line);  if (scanner.hasNextLine()) { sqlWithTraceIds.append(System.lineSeparator()); } } }  return sqlWithTraceIds.toString(); }
[*] target: assertEquals(sql, actual)
[-] pred: org. junit. Assert. assertEquals ( sql, actual )
************************************
************************************
[+] input: queryWithUnknownTraceId() { String spanId = "1234567890abcdef"; when(traceContext.traceId()).thenReturn(TracingStatementInspector.UNKNOWN_TRACE_ID); when(traceContext.spanId()).thenReturn(spanId);  TracingStatementInspector inspector = new TracingStatementInspector(tracer); String sql = "--latest_transaction_id \n" + "SELECT MAX(transaction_id) FROM transactions"; String expected = String.format("--latest_transaction_id \n" + "-- span_id: %s\n" + "SELECT MAX(transaction_id) FROM transactions", spanId); String actual = inspector.inspect(sql); "<AssertPlaceHolder>"; }
inspect(final String sql) { final Span span = findSpan();  if (span == null) { return sql; }  final String traceId = span.context().traceId(); final String spanId = span.context().spanId(); final boolean traceIdUnknown = UNKNOWN_TRACE_ID.equals(traceId) || isInvalidId(traceId); final boolean spanIdUnknown = UNKNOWN_SPAN_ID.equals(spanId) || isInvalidId(spanId);  span.tag("query", sql);  // There is no trace id and there is no span id if (traceIdUnknown && spanIdUnknown) { return sql; }  final StringBuilder sqlWithTraceIds = new StringBuilder();  /* Allow existing comments to be persisted at the top of the SQL statement * then insert tracing comments below those comments. */ try (Scanner scanner = new Scanner(sql)) { boolean inTopLevelComments = true;  while (scanner.hasNextLine()) { final String line = scanner.nextLine();  if (inTopLevelComments && !line.startsWith("--")) { appendTraceIds(sqlWithTraceIds, traceId, spanId, traceIdUnknown, spanIdUnknown); inTopLevelComments = false; }  sqlWithTraceIds.append(line);  if (scanner.hasNextLine()) { sqlWithTraceIds.append(System.lineSeparator()); } } }  return sqlWithTraceIds.toString(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: queryWithUnknownSpanId() { String traceId = "12345678901234567890123456789abc"; when(traceContext.traceId()).thenReturn(traceId); when(traceContext.spanId()).thenReturn(TracingStatementInspector.UNKNOWN_SPAN_ID);  TracingStatementInspector inspector = new TracingStatementInspector(tracer); String sql = "--latest_transaction_id \n" + "SELECT MAX(transaction_id) FROM transactions"; String expected = String.format("--latest_transaction_id \n" + "-- trace_id: %s\n" + "SELECT MAX(transaction_id) FROM transactions", traceId); String actual = inspector.inspect(sql); "<AssertPlaceHolder>"; }
inspect(final String sql) { final Span span = findSpan();  if (span == null) { return sql; }  final String traceId = span.context().traceId(); final String spanId = span.context().spanId(); final boolean traceIdUnknown = UNKNOWN_TRACE_ID.equals(traceId) || isInvalidId(traceId); final boolean spanIdUnknown = UNKNOWN_SPAN_ID.equals(spanId) || isInvalidId(spanId);  span.tag("query", sql);  // There is no trace id and there is no span id if (traceIdUnknown && spanIdUnknown) { return sql; }  final StringBuilder sqlWithTraceIds = new StringBuilder();  /* Allow existing comments to be persisted at the top of the SQL statement * then insert tracing comments below those comments. */ try (Scanner scanner = new Scanner(sql)) { boolean inTopLevelComments = true;  while (scanner.hasNextLine()) { final String line = scanner.nextLine();  if (inTopLevelComments && !line.startsWith("--")) { appendTraceIds(sqlWithTraceIds, traceId, spanId, traceIdUnknown, spanIdUnknown); inTopLevelComments = false; }  sqlWithTraceIds.append(line);  if (scanner.hasNextLine()) { sqlWithTraceIds.append(System.lineSeparator()); } } }  return sqlWithTraceIds.toString(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: queryWithTraceIdAndSpanId() { String traceId = "12345678901234567890123456789abc"; String spanId = "1234567890abcdef"; when(traceContext.traceId()).thenReturn(traceId); when(traceContext.spanId()).thenReturn(spanId);  TracingStatementInspector inspector = new TracingStatementInspector(tracer); String sql = "--latest_transaction_id \n" + "SELECT MAX(transaction_id) FROM transactions"; String expected = String.format("--latest_transaction_id \n" + "-- trace_id: %s span_id: %s\n" + "SELECT MAX(transaction_id) FROM transactions", traceId, spanId); String actual = inspector.inspect(sql); "<AssertPlaceHolder>"; }
inspect(final String sql) { final Span span = findSpan();  if (span == null) { return sql; }  final String traceId = span.context().traceId(); final String spanId = span.context().spanId(); final boolean traceIdUnknown = UNKNOWN_TRACE_ID.equals(traceId) || isInvalidId(traceId); final boolean spanIdUnknown = UNKNOWN_SPAN_ID.equals(spanId) || isInvalidId(spanId);  span.tag("query", sql);  // There is no trace id and there is no span id if (traceIdUnknown && spanIdUnknown) { return sql; }  final StringBuilder sqlWithTraceIds = new StringBuilder();  /* Allow existing comments to be persisted at the top of the SQL statement * then insert tracing comments below those comments. */ try (Scanner scanner = new Scanner(sql)) { boolean inTopLevelComments = true;  while (scanner.hasNextLine()) { final String line = scanner.nextLine();  if (inTopLevelComments && !line.startsWith("--")) { appendTraceIds(sqlWithTraceIds, traceId, spanId, traceIdUnknown, spanIdUnknown); inTopLevelComments = false; }  sqlWithTraceIds.append(line);  if (scanner.hasNextLine()) { sqlWithTraceIds.append(System.lineSeparator()); } } }  return sqlWithTraceIds.toString(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: GeneralSecurityException { String password = "test_password"; ScryptKeyDeriver scryptKeyDeriver1 = new ScryptKeyDeriver(); ScryptParameters scryptParameters = scryptKeyDeriver1.getScryptParameters(); AesSecretKey key1 = scryptKeyDeriver1.deriveKeyFromPassword(password); byte[] plainText = "test_data".getBytes(); byte[] iv = AesGcm.generateIv().getIV(); byte[] cipherText = AesGcm.encrypt(key1, iv, plainText); EncryptedData encryptedData = new EncryptedData(iv, cipherText);  ScryptKeyDeriver scryptKeyDeriver2 = new ScryptKeyDeriver(scryptParameters); AesSecretKey key2 = scryptKeyDeriver2.deriveKeyFromPassword(password); byte[] decryptedData = AesGcm.decrypt(key2, encryptedData.getIv(), encryptedData.getCipherText()); "<AssertPlaceHolder>"; }
decrypt(SecretKey secretKey, byte[] iv, byte[] cipherText) throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException { Cipher cipher = Cipher.getInstance(AES_GCM_NO_PADDING_CIPHER_NAME, BouncyCastleProvider.PROVIDER_NAME); GCMParameterSpec spec = new GCMParameterSpec(MAX_TAG_LENGTH, iv); cipher.init(Cipher.DECRYPT_MODE, secretKey, spec); return cipher.doFinal(cipherText); }
[*] target: assertArrayEquals(plainText, decryptedData)
[-] pred: org. junit. Assert. assertArrayEquals ( plainText, decryptedData )
************************************
************************************
[+] input: shouldFindExistingMessageTemplate() { MessageTemplate messageTemplate = MESSAGE_TEMPLATE_PROVIDER.getMessageTemplate("connector-hint"); "<AssertPlaceHolder>"; }
getMessageTemplate(String templateName) { MessageTemplate template; synchronized (MESSAGE_TEMPLATES) { template = MESSAGE_TEMPLATES.get(templateName); } if (template == null) { throw new IllegalStateException("No template found for name '" + templateName + "'"); } return template; }
[*] target: assertNotNull(messageTemplate)
[-] pred: org. junit. Assert. assertNotNull ( messageTemplate )
************************************
************************************
[+] input: Exception { CountDownLatch latch = new CountDownLatch(1); s1.registerCallback(new CountDownCallback(latch)); s2.registerCallback(new CountDownCallback(latch)); Exception e = null; try { c.getPeer("bogus").sendMessage(messages[0]); fail("bogus config"); } catch (IOChannelException ex) { e = ex; } "<AssertPlaceHolder>"; }
registerCallback(NotifyCallback cb) { callback = cb; }
[*] target: assertNotNull(e)
[-] pred: org. junit. Assert. assertNotNull ( e )
************************************
************************************
[+] input: shouldFormatCorrectlyWhenCalledProcessComplexStat() {  StringBuilder buf = new StringBuilder(); String[] header = {"command", "exec_count", "exec_ms_avg"}; String[] stats = {"NoOpRequest", "2", "0"};  PrometheusFormatter.processComplexStats("soap", buf, header, stats);  String expected = "soap_exec_count {command="NoOpRequest"} 2\n" + "soap_exec_ms_avg {command="NoOpRequest"} 0\n";  "<AssertPlaceHolder>"; }
processComplexStats( String statFilePrefix, StringBuilder logBuffer, final String[] headers, String[] stats) { final String command = stats[0]; final String header = headers[0]; IntStream.range(1, headers.length) .forEach( i -> logBuffer .append(statFilePrefix) .append("_") .append(sanitizeHeader(headers[i])) .append(" ") .append("{") .append(header) .append("="") .append(command) .append(""}") .append(" ") .append("".equals(stats[i]) ? "0" : stats[i]) .append("\n")); }
[*] target: assertEquals(expected, buf.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, buf. toString ( ) )
************************************
************************************
[+] input: shouldFormatCorrectlyWhenCalledProcessNormalStats() { String[] headers = { "AnonymousIoService", "CloudRoutingReaderThread", "GC", "ImapSSLServer", "ImapServer", "LmtpServer", "Pop3SSLServer", "Pop3Server", "ScheduledTask", "SocketAcceptor", "Thread", "Timer", "btpool", "pool" };  String[] stats = {"0", "0", "0", "0", "0", "2", "0", "0", "10", "0", "2", "5", "0", "0"};  StringBuilder buf = new StringBuilder(); PrometheusFormatter.processNormalStats("threads", buf, headers, stats); String expected = "threads_AnonymousIoService 0\n" + "threads_CloudRoutingReaderThread 0\n" + "threads_GC 0\n" + "threads_ImapSSLServer 0\n" + "threads_ImapServer 0\n" + "threads_LmtpServer 2\n" + "threads_Pop3SSLServer 0\n" + "threads_Pop3Server 0\n" + "threads_ScheduledTask 10\n" + "threads_SocketAcceptor 0\n" + "threads_Thread 2\n" + "threads_Timer 5\n" + "threads_btpool 0\n" + "threads_pool 0\n"; "<AssertPlaceHolder>"; }
processNormalStats( String statFilePrefix, StringBuilder logBuffer, final String[] headers, String[] stats) { IntStream.range(0, stats.length) .forEach( i -> logBuffer .append(statFilePrefix) .append("_") .append(sanitizeHeader(headers[i])) .append(" ") .append(("".equals(stats[i]) ? "0" : stats[i])) .append("\n")); }
[*] target: assertEquals(expected, buf.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, buf. toString ( ) )
************************************
************************************
[+] input: IOException { File tempDir = createTempDir(); FileUtil.deleteDir(tempDir); "<AssertPlaceHolder>"; }
deleteDir(File directory) throws IOException { deleteDirContents(directory); if (directory.exists() && !directory.delete()) { throw new IOException("Cannot remove " + directory.getPath()); } }
[*] target: assertFalse(tempDir.exists())
[-] pred: org. junit. Assert. assertFalse ( tempDir. exists ( ) )
************************************
************************************
[+] input: testFillTemplate() { String template = "The quick ${COLOR} ${ANIMAL}\njumped over the ${ADJECTIVE} dogs.\n"; Map<String, String> vars = new HashMap<String, String>(); vars.put("COLOR", "brown"); vars.put("ANIMAL", "fox"); vars.put("ADJECTIVE", "lazy"); String result = StringUtil.fillTemplate(template, vars); String expected = "The quick brown fox\njumped over the lazy dogs.\n"; "<AssertPlaceHolder>"; }
fillTemplate(String template, Map<String, ? extends Object> vars) { return fillTemplate(template, vars, varPattern); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testFillTemplateWithBraces() { String template = "Beginning ${VAR} { end }"; Map<String, String> vars = new HashMap<String, String>(); vars.put("VAR", "middle"); String result = StringUtil.fillTemplate(template, vars); String expected = "Beginning middle { end }"; "<AssertPlaceHolder>"; }
fillTemplate(String template, Map<String, ? extends Object> vars) { return fillTemplate(template, vars, varPattern); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: test_provideCollector() { MetricsServletModule module = new MetricsServletModule(); Assertions."<AssertPlaceHolder>"; }
provideCollector() { CarbonioMetricRegisterer.register(Metrics.COLLECTOR_REGISTRY); return Metrics.COLLECTOR_REGISTRY; }
[*] target: assertNotNull(module.provideCollector())
[-] pred: org. junit. Assert. assertNotNull ( module. provideCollector() )
************************************
************************************
[+] input: Exception { String inputString = new String(ByteUtil.getContent(new File(EMAIL_BASE_DIR + "bug_100966.txt"))); String expectedResult = new String(ByteUtil.getContent(new File(EMAIL_BASE_DIR + "bug_100966_op.txt"))); String result = new DefangFilter(false).extractAndSanitizeAsciiData(inputString); "<AssertPlaceHolder>"; }
extractAndSanitizeAsciiData(String data) { char[] c = data.toCharArray(); StringBuilder sanitizedStrg = new StringBuilder(); StringBuilder asciiData = new StringBuilder(); for (char value : c) { if (value <= ASCII_DATA_VALUE) { asciiData.append(value);  } else { String temp = asciiData.toString(); if (!StringUtil.isNullOrEmpty(temp)) { temp = sanitizeStyleValue(temp); sanitizedStrg.append(temp); asciiData = new StringBuilder(); } sanitizedStrg.append(value); } } // Append the asciiData to the sanitizedStrg sanitizedStrg.append(asciiData); return sanitizedStrg.toString(); }
[*] target: assertEquals(result, expectedResult)
[-] pred: org. junit. Assert. assertEquals ( result, expectedResult )
************************************
************************************
[+] input: Exception { String html = "<div id="noticias"><div class="bloque">BLOQUESSS</div></div>"; String result = new OwaspHtmlSanitizer(html, true, null).sanitize(); // check that the id and class attributes are not removed "<AssertPlaceHolder>"; }
sanitize() { OwaspThreadLocal threadLocalInstance = new OwaspThreadLocal(); threadLocalInstance.setVHost(vHost); OwaspHtmlSanitizer.zThreadLocal.set(threadLocalInstance); if (StringUtil.isNullOrEmpty(html)) { return null; } // create the builder into which the sanitized email will be written final StringBuilder htmlBuilder = new StringBuilder(html.length()); // create the renderer that will write the sanitized HTML to the builder final HtmlStreamRenderer renderer = HtmlStreamRenderer.create(htmlBuilder, Handler.PROPAGATE, // log errors resulting from exceptionally bizarre inputs x -> { throw new AssertionError(x); }); // create a thread-specific policy instantiatePolicy(); final Policy policy = POLICY_DEFINITION.apply(new StyleTagReceiver(renderer)); // run the html through the sanitizer HtmlSanitizer.sanitize(html, policy); // return the resulting HTML from the builder OwaspHtmlSanitizer.zThreadLocal.remove(); return htmlBuilder.toString(); }
[*] target: assertEquals(result, html)
[-] pred: org. junit. Assert. assertEquals ( result, html )
************************************
************************************
[+] input: Exception { Account acct1 = Provisioning.getInstance().get(Key.AccountBy.name, "testZCS3546@zimbra.com"); acct1.setPrefOutOfOfficeSuppressExternalReply(true); acct1.unsetInternalSendersDomain(); acct1.unsetPrefExternalSendersType(); Mailbox mbox1 = MailboxManager.getInstance().getMailboxByAccount(acct1); boolean skipOOO = Notification.skipOutOfOfficeMsg("test3@synacor.com", acct1, mbox1); "<AssertPlaceHolder>"; }
skipOutOfOfficeMsg(String senderAddr, Account account, Mailbox mbox) { return account.isPrefOutOfOfficeSuppressExternalReply() && isOfExternalSenderType(senderAddr, account, mbox) &&  !isInternalSender(senderAddr, account) && !isOfSpecificDomainSenderType(senderAddr, account); }
[*] target: assertEquals(true, skipOOO)
[-] pred: org. junit. Assert. assertEquals ( true, skipOOO )
************************************
************************************
[+] input: shouldCreateCommandForLongChain() { final String expectedCommand = "certbot certonly --agree-tos " + "--email admin@example.com " + "-n --keep --webroot -w /opt/zextras " + "--cert-name example.com " + "-d public.example.com " + "-d virtual1.example.com -d virtual2.example.com"; final String actualCommand = remoteCertbot.createCommand(RemoteCommands.CERTBOT_CERTONLY, mail, AdminConstants.DEFAULT_CHAIN, domainName, publicServiceHostName, virtualHostName); "<AssertPlaceHolder>"; }
createCommand(String remoteCommand, String email, String chain, String domainName, String publicServiceHostName, String[] virtualHosts) {  this.stringBuilder = new StringBuilder();  stringBuilder.append(remoteCommand);  if (Objects.equals(chain, CHAIN_TYPE)) { addSubCommand(" ", CHAIN, SHORT_CHAIN); }  addSubCommand(" ", AGREEMENT, EMAIL, email, NON_INTERACTIVELY, KEEP, WEBROOT, WEBROOT_PATH, CERT_NAME, domainName);  addSubCommand(D, publicServiceHostName); addSubCommand(D, virtualHosts);  return stringBuilder.toString(); }
[*] target: assertEquals(expectedCommand, actualCommand)
[-] pred: org. junit. Assert. assertEquals ( expectedCommand, actualCommand )
************************************
************************************
[+] input: shouldCreateCommandWithLongChainForRandomText() { final String expectedCommand = "certbot certonly --agree-tos " + "--email admin@example.com " + "-n --keep --webroot -w /opt/zextras " + "--cert-name example.com " + "-d public.example.com " + "-d virtual1.example.com -d virtual2.example.com"; final String actualCommand = remoteCertbot.createCommand(RemoteCommands.CERTBOT_CERTONLY, mail, "random", domainName, publicServiceHostName, virtualHostName); "<AssertPlaceHolder>"; }
createCommand(String remoteCommand, String email, String chain, String domainName, String publicServiceHostName, String[] virtualHosts) {  this.stringBuilder = new StringBuilder();  stringBuilder.append(remoteCommand);  if (Objects.equals(chain, CHAIN_TYPE)) { addSubCommand(" ", CHAIN, SHORT_CHAIN); }  addSubCommand(" ", AGREEMENT, EMAIL, email, NON_INTERACTIVELY, KEEP, WEBROOT, WEBROOT_PATH, CERT_NAME, domainName);  addSubCommand(D, publicServiceHostName); addSubCommand(D, virtualHosts);  return stringBuilder.toString(); }
[*] target: assertEquals(expectedCommand, actualCommand)
[-] pred: org. junit. Assert. assertEquals ( expectedCommand, actualCommand )
************************************
************************************
[+] input: shouldCreateCommandForShortChain() { final String expectedCommand = "certbot certonly --preferred-chain "ISRG Root X1" " + "--agree-tos --email admin@example.com -n --keep --webroot -w /opt/zextras " + "--cert-name example.com " + "-d public.example.com " + "-d virtual1.example.com -d virtual2.example.com"; final String actualCommand = remoteCertbot.createCommand(RemoteCommands.CERTBOT_CERTONLY, mail, "short", domainName, publicServiceHostName, virtualHostName); "<AssertPlaceHolder>"; }
createCommand(String remoteCommand, String email, String chain, String domainName, String publicServiceHostName, String[] virtualHosts) {  this.stringBuilder = new StringBuilder();  stringBuilder.append(remoteCommand);  if (Objects.equals(chain, CHAIN_TYPE)) { addSubCommand(" ", CHAIN, SHORT_CHAIN); }  addSubCommand(" ", AGREEMENT, EMAIL, email, NON_INTERACTIVELY, KEEP, WEBROOT, WEBROOT_PATH, CERT_NAME, domainName);  addSubCommand(D, publicServiceHostName); addSubCommand(D, virtualHosts);  return stringBuilder.toString(); }
[*] target: assertEquals(expectedCommand, actualCommand)
[-] pred: org. junit. Assert. assertEquals ( expectedCommand, actualCommand )
************************************
************************************
[+] input: testIsValidCsrfTokenForAccountWithMultipleTokens() { try { Account acct = Provisioning.getInstance().getAccountByName( "test@zimbra.com"); AuthToken authToken = new ZimbraAuthToken(acct);  String csrfToken1 = CsrfUtil.generateCsrfToken(acct.getId(), AUTH_TOKEN_EXPR, CSRFTOKEN_SALT, authToken); boolean validToken = CsrfUtil.isValidCsrfToken(csrfToken1, authToken); "<AssertPlaceHolder>";   } catch (ServiceException  e) { fail("Should not throw exception."); } }
isValidCsrfToken(String csrfToken, AuthToken authToken) { if (StringUtil.isNullOrEmpty(csrfToken) || null == authToken) { return false; }  String hmacFromToken = null; String crumb = null; String keyVersion = null; boolean validToken = false; boolean loadFromLdap = false;  try { Pair<String, String> data = parseCsrfToken(csrfToken); hmacFromToken = data.getFirst(); keyVersion = data.getSecond(); crumb  = authToken.getCrumb(); Account account = getAccount(authToken, loadFromLdap); if(account == null) { return false; } validToken = validateCsrfToken(hmacFromToken, crumb, keyVersion, validToken, account); if (!validToken) { // just recheck that we are looking at the latest Account object // cache of this server might be stale ZimbraLog.misc.info("CSRF token was invalid, rechecking with account object from LDAP."); loadFromLdap = true; account = getAccount(authToken, loadFromLdap); validToken = validateCsrfToken(hmacFromToken, crumb, keyVersion, validToken, account); if (ZimbraLog.misc.isDebugEnabled()) { ZimbraLog.misc.debug("The csrfToken second check: " + (validToken ? "is valid." : " is invalid.")); } } } catch (AuthTokenException | ServiceException e) { ZimbraLog.misc.info("Error decoding CSRF token, " + e.getMessage()); validToken = false; }  if (ZimbraLog.misc.isDebugEnabled() ) { ZimbraLog.misc.debug("The csrfToken: " + (validToken ? "is valid." : " is invalid.")); } return validToken; }
[*] target: assertTrue(validToken)
[-] pred: org. junit. Assert. assertTrue ( validToken )
************************************
************************************
[+] input: removeNFT() { String policyId_1 = "1e80fa1859c59b18ff4895a2c481cced459c6b4fcd6c445b5e907a92"; String policyId_2 = "2222221859c59b18ff4895a2c481cced459c6b4fcd6c445b5e907a92";  NFT nft1 = NFT.create() .assetName("assetname-nft1") .name("nft1") .image("ipfs://someimageurl-1") .mediaType("image/png") .description("NFT-1 description") .addFile(NFTFile.create() .name("nft1-file1") .mediaType("plain/text") .src("http://nft1-file1")) .addFile(NFTFile.create() .name("nft1-file2") .mediaType("plain/text") .src("http://nft1-file2"));  NFT nft2 = NFT.create() .assetName("assetname-nft2") .name("nft2") .image("ipfs://someimageurl-2") .mediaType("image/png") .description("NFT-2 description");  NFT nft3 = NFT.create() .assetName("assetname-nft3") .name("nft2") .image("ipfs://someimageurl-3") .mediaType("image/png") .description("NFT-3 description");  NFTMetadata metadata = NFTMetadata.create() .addNFT(policyId_1, nft1) .addNFT(policyId_1, nft2) .addNFT(policyId_2, nft3);  //remove nft2 metadata.removeNFT(policyId_1, nft2.getAssetName());  //asserts NFT removeNFT = metadata.getNFT(policyId_1, nft2.getAssetName()); "<AssertPlaceHolder>"; }
getNFT(String policyId, String assetName) { CBORMetadataMap nftListMap = (CBORMetadataMap) policyMap.get(policyId); if (nftListMap == null) return null;  CBORMetadataMap nftMap = (CBORMetadataMap) nftListMap.get(assetName); if (nftMap != null) { NFT nft = NFT.create(nftMap.getMap()); nft.assetName(assetName); return nft; } else { return null; } }
[*] target: assertNull(removeNFT)
[-] pred: org. junit. Assert. assertNull ( removeNFT )
************************************
************************************
[+] input: isAndroid_whenNotSetInConfig() { boolean isAndroid = OSUtil.isAndroid();  "<AssertPlaceHolder>"; }
isAndroid() { //If isAndroid is set programmatically if (android) return true;  String javaVendor = System.getProperty("java.vm.vendor");  if (javaVendor != null && "The Android Project".equalsIgnoreCase(javaVendor)) { return true; } else { return false; } }
[*] target: assertFalse(isAndroid)
[-] pred: org. junit. Assert. assertFalse ( isAndroid )
************************************
************************************
[+] input: isAndroid_whenSetInJavaVMVendor() { String actualVendor = System.getProperty("java.vm.vendor"); System.setProperty("java.vm.vendor", "The Android Project"); boolean isAndroid = OSUtil.isAndroid(); System.setProperty("java.vm.vendor", actualVendor); "<AssertPlaceHolder>"; }
isAndroid() { //If isAndroid is set programmatically if (android) return true;  String javaVendor = System.getProperty("java.vm.vendor");  if (javaVendor != null && "The Android Project".equalsIgnoreCase(javaVendor)) { return true; } else { return false; } }
[*] target: assertTrue(isAndroid)
[-] pred: org. junit. Assert. assertTrue ( isAndroid )
************************************
************************************
[+] input: getStakeAddressFromMnemonic_whenTestnet() { String phrase24W = "coconut you order found animal inform tent anxiety pepper aisle web horse source indicate eyebrow viable lawsuit speak dragon scheme among animal slogan exchange"; String expectedRewardAddress = "stake_test1uq06d3cktqn4z9tv8rr9723fvrxdnh44an9tjvjftw6krscamyncv";  Account account = new Account(Networks.testnet(), phrase24W); String rewardAddress = account.stakeAddress();  "<AssertPlaceHolder>"; }
stakeAddress() { if (stakeAddress == null || stakeAddress.isEmpty()) { HdKeyPair stakeKeyPair = getStakeKeyPair(); Address address = AddressProvider.getRewardAddress(stakeKeyPair.getPublicKey(), network); stakeAddress = address.toBech32(); }  return stakeAddress; }
[*] target: assertEquals(expectedRewardAddress, rewardAddress)
[-] pred: org. junit. Assert. assertEquals ( expectedRewardAddress, rewardAddress )
************************************
************************************
[+] input: getStakeAddressFromMnemonic_whenMainnet() { String phrase24W = "damp wish scrub sentence vibrant gauge tumble raven game extend winner acid side amused vote edge affair buzz hospital slogan patient drum day vital"; String expectedRewardAddress = "stake1u9xeg0r67z4wca682l28ghg69jxaxgswdmpvnher7at697quawequ";  Account account = new Account(Networks.mainnet(), phrase24W); String rewardAddress = account.stakeAddress();  "<AssertPlaceHolder>"; }
stakeAddress() { if (stakeAddress == null || stakeAddress.isEmpty()) { HdKeyPair stakeKeyPair = getStakeKeyPair(); Address address = AddressProvider.getRewardAddress(stakeKeyPair.getPublicKey(), network); stakeAddress = address.toBech32(); }  return stakeAddress; }
[*] target: assertEquals(expectedRewardAddress, rewardAddress)
[-] pred: org. junit. Assert. assertEquals ( expectedRewardAddress, rewardAddress )
************************************
************************************
[+] input: isAndroid() { Configuration.INSTANCE.setAndroid(true); boolean isAndroid = Configuration.INSTANCE.isAndroid(); Configuration.INSTANCE.setAndroid(false);  "<AssertPlaceHolder>"; }
setAndroid(boolean android) { OSUtil.setAndroid(android); }
[*] target: assertTrue(isAndroid)
[-] pred: org. junit. Assert. assertTrue ( isAndroid )
************************************
************************************
[+] input: isAndroid_whenSetThroughOSUtil() { OSUtil.setAndroid(true); boolean isAndroid = OSUtil.isAndroid(); Configuration.INSTANCE.setAndroid(false);  "<AssertPlaceHolder>"; }
setAndroid(boolean android) { OSUtil.setAndroid(android); }
[*] target: assertTrue(isAndroid)
[-] pred: org. junit. Assert. assertTrue ( isAndroid )
************************************
************************************
[+] input: isAndroid_whenNotSetInConfig() { boolean isAndroid = Configuration.INSTANCE.isAndroid();  "<AssertPlaceHolder>"; }
isAndroid() { return OSUtil.isAndroid(); }
[*] target: assertFalse(isAndroid)
[-] pred: org. junit. Assert. assertFalse ( isAndroid )
************************************
************************************
[+] input: testValidShelleyAddress() { boolean isValid = AddressUtil.isValidAddress("addr1qxkeutm43mhc8jpqg6sk4cqtypzy3ez6z8k7qlfwa97h2acz7xprvuysll04e5gaa65vavyj0wvd0v99lhpntm7c03us8wk6xc");  "<AssertPlaceHolder>"; }
isValidAddress(String addr) { try { addressToBytes(addr);  return true; } catch (AddressExcepion e) { return false; } catch (AddressRuntimeException e) { return false; } }
[*] target: assertTrue(isValid)
[-] pred: org. junit. Assert. assertTrue ( isValid )
************************************
************************************
[+] input: testValidByronAddr() { boolean isValid = AddressUtil.isValidAddress("DdzFFzCqrhszg6cqZvDhEwUX7cZyNzdycAVpm4Uo2vjKMgTLrVqiVKi3MBt2tFAtDe7NkptK6TAhVkiYzhavmKV5hE79CWwJnPCJTREK");  "<AssertPlaceHolder>"; }
isValidAddress(String addr) { try { addressToBytes(addr);  return true; } catch (AddressExcepion e) { return false; } catch (AddressRuntimeException e) { return false; } }
[*] target: assertTrue(isValid)
[-] pred: org. junit. Assert. assertTrue ( isValid )
************************************
************************************
[+] input: getNomeDosAtributosDoObjeto_test03() { final List<String> nomeDosAtributosDoObjeto = JavaReflection.getNomeDosAtributosDoObjeto(new Object()); "<AssertPlaceHolder>"; }
getNomeDosAtributosDoObjeto(Object objeto) { throw new UnsupportedOperationException(); }
[*] target: assertTrue(nomeDosAtributosDoObjeto.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( nomeDosAtributosDoObjeto. isEmpty ( ) )
************************************
************************************
[+] input: getQuantidadeDePessoasQueComecamComALetra_test02() { List<String> pessoas = new ArrayList<>(asList("Felix", "Daiane", "Erivelto", "Paulo", "Maycon", "Elizandro")); long quantidade = ArrayLists.getQuantidadeDePessoasQueComecamComALetra(pessoas, "A");  "<AssertPlaceHolder>"; }
getQuantidadeDePessoasQueComecamComALetra(List<String> pessoas, String letra) { return 0; }
[*] target: assertEquals(0, quantidade)
[-] pred: org. junit. Assert. assertEquals ( 0, quantidade )
************************************
************************************
[+] input: getQuantidadeDePessoasQueComecamComALetra_test03() { List<String> pessoas = new ArrayList<>(); long quantidade = ArrayLists.getQuantidadeDePessoasQueComecamComALetra(pessoas, "A");  "<AssertPlaceHolder>"; }
getQuantidadeDePessoasQueComecamComALetra(List<String> pessoas, String letra) { return 0; }
[*] target: assertEquals(0, quantidade)
[-] pred: org. junit. Assert. assertEquals ( 0, quantidade )
************************************
************************************
[+] input: getMaior_test01() { int maior = Calculadora.getMaior(20, 10); "<AssertPlaceHolder>"; }
getMaior(int a, int b) { return 0; }
[*] target: assertEquals(20, maior)
[-] pred: org. junit. Assert. assertEquals ( 20, maior )
************************************
************************************
[+] input: getMaior_test03() { int maior = Calculadora.getMaior(10, -20); "<AssertPlaceHolder>"; }
getMaior(int a, int b) { return 0; }
[*] target: assertEquals(10, maior)
[-] pred: org. junit. Assert. assertEquals ( 10, maior )
************************************
************************************
[+] input: getMaior_test04() { int maior = Calculadora.getMaior(0, 0); "<AssertPlaceHolder>"; }
getMaior(int a, int b) { return 0; }
[*] target: assertEquals(0, maior)
[-] pred: org. junit. Assert. assertEquals ( 0, maior )
************************************
************************************
[+] input: getAbsoluto_test02() { int absoluto = Calculadora.getAbsoluto(-10);  "<AssertPlaceHolder>"; }
getAbsoluto(int n) { return 0; }
[*] target: assertEquals(10, absoluto)
[-] pred: org. junit. Assert. assertEquals ( 10, absoluto )
************************************
************************************
[+] input: getAbsoluto_test03() { int absoluto = Calculadora.getAbsoluto(20);  "<AssertPlaceHolder>"; }
getAbsoluto(int n) { return 0; }
[*] target: assertEquals(20, absoluto)
[-] pred: org. junit. Assert. assertEquals ( 20, absoluto )
************************************
************************************
[+] input: getDataAnosAFrente_test01() { LocalDate inicio = LocalDate.of(2021, 5, 29); LocalDate dataEsperada = LocalDate.of(2023, 5, 29); LocalDate dataObtida = LocalDates.getDataAnosAFrente(inicio, 2); "<AssertPlaceHolder>"; }
getDataAnosAFrente(LocalDate inicio, long anos) { return null; }
[*] target: assertEquals(dataEsperada, dataObtida)
[-] pred: org. junit. Assert. assertEquals ( dataEsperada, dataObtida )
************************************
************************************
[+] input: getDataMesesAtras_test01() { LocalDate inicio = LocalDate.of(2021, 5, 13); LocalDate dataEsperada = LocalDate.of(2020, 12, 13); LocalDate dataObtida = LocalDates.getDataMesesAtras(inicio, 5); "<AssertPlaceHolder>"; }
getDataMesesAtras(LocalDate inicio, long meses) { return null; }
[*] target: assertEquals(dataEsperada, dataObtida)
[-] pred: org. junit. Assert. assertEquals ( dataEsperada, dataObtida )
************************************
************************************
[+] input: getStringTruncada_test05() { String stringTruncada = Strings.getStringTruncada(null, 0); "<AssertPlaceHolder>"; }
getStringTruncada(String s, int tamanho) { return null; }
[*] target: assertNull(stringTruncada)
[-] pred: org. junit. Assert. assertNull ( stringTruncada )
************************************
************************************
[+] input: getQuantidadeLetrasMaiusculas_test01() { int quantidadeLetrasMaiusculas = Strings.getQuantidadeLetrasMaiusculas("Felix"); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMaiusculas(String str) { return 0; }
[*] target: assertEquals(1, quantidadeLetrasMaiusculas)
[-] pred: org. junit. Assert. assertEquals ( 1, quantidadeLetrasMaiusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMaiusculas_test02() { int quantidadeLetrasMaiusculas = Strings.getQuantidadeLetrasMaiusculas("Felix Gilioli"); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMaiusculas(String str) { return 0; }
[*] target: assertEquals(2, quantidadeLetrasMaiusculas)
[-] pred: org. junit. Assert. assertEquals ( 2, quantidadeLetrasMaiusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMaiusculas_test03() { int quantidadeLetrasMaiusculas = Strings.getQuantidadeLetrasMaiusculas("testandoOTesteDoTestador"); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMaiusculas(String str) { return 0; }
[*] target: assertEquals(4, quantidadeLetrasMaiusculas)
[-] pred: org. junit. Assert. assertEquals ( 4, quantidadeLetrasMaiusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMaiusculas_test04() { int quantidadeLetrasMaiusculas = Strings.getQuantidadeLetrasMaiusculas(""); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMaiusculas(String str) { return 0; }
[*] target: assertEquals(0, quantidadeLetrasMaiusculas)
[-] pred: org. junit. Assert. assertEquals ( 0, quantidadeLetrasMaiusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMaiusculas_test05() { int quantidadeLetrasMaiusculas = Strings.getQuantidadeLetrasMaiusculas("FELIX"); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMaiusculas(String str) { return 0; }
[*] target: assertEquals(5, quantidadeLetrasMaiusculas)
[-] pred: org. junit. Assert. assertEquals ( 5, quantidadeLetrasMaiusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMaiusculas_test06() { int quantidadeLetrasMaiusculas = Strings.getQuantidadeLetrasMaiusculas(null); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMaiusculas(String str) { return 0; }
[*] target: assertEquals(0, quantidadeLetrasMaiusculas)
[-] pred: org. junit. Assert. assertEquals ( 0, quantidadeLetrasMaiusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMaiusculas_test07() { int quantidadeLetrasMaiusculas = Strings.getQuantidadeLetrasMaiusculas("felix"); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMaiusculas(String str) { return 0; }
[*] target: assertEquals(0, quantidadeLetrasMaiusculas)
[-] pred: org. junit. Assert. assertEquals ( 0, quantidadeLetrasMaiusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMinusculas_test01() { int quantidadeLetrasMinusculas = Strings.getQuantidadeLetrasMinusculas("Felix"); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMinusculas(String str) { return 0; }
[*] target: assertEquals(4, quantidadeLetrasMinusculas)
[-] pred: org. junit. Assert. assertEquals ( 4, quantidadeLetrasMinusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMinusculas_test02() { int quantidadeLetrasMinusculas = Strings.getQuantidadeLetrasMinusculas("Felix Gilioli"); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMinusculas(String str) { return 0; }
[*] target: assertEquals(10, quantidadeLetrasMinusculas)
[-] pred: org. junit. Assert. assertEquals ( 10, quantidadeLetrasMinusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMinusculas_test03() { int quantidadeLetrasMinusculas = Strings.getQuantidadeLetrasMinusculas("testandoOTesteDoTestador"); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMinusculas(String str) { return 0; }
[*] target: assertEquals(20, quantidadeLetrasMinusculas)
[-] pred: org. junit. Assert. assertEquals ( 20, quantidadeLetrasMinusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMinusculas_test04() { int quantidadeLetrasMinusculas = Strings.getQuantidadeLetrasMinusculas(""); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMinusculas(String str) { return 0; }
[*] target: assertEquals(0, quantidadeLetrasMinusculas)
[-] pred: org. junit. Assert. assertEquals ( 0, quantidadeLetrasMinusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMinusculas_test05() { int quantidadeLetrasMinusculas = Strings.getQuantidadeLetrasMinusculas("FELIX"); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMinusculas(String str) { return 0; }
[*] target: assertEquals(0, quantidadeLetrasMinusculas)
[-] pred: org. junit. Assert. assertEquals ( 0, quantidadeLetrasMinusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMinusculas_test06() { int quantidadeLetrasMinusculas = Strings.getQuantidadeLetrasMinusculas(null); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMinusculas(String str) { return 0; }
[*] target: assertEquals(0, quantidadeLetrasMinusculas)
[-] pred: org. junit. Assert. assertEquals ( 0, quantidadeLetrasMinusculas )
************************************
************************************
[+] input: getQuantidadeLetrasMinusculas_test07() { int quantidadeLetrasMinusculas = Strings.getQuantidadeLetrasMinusculas("felix"); "<AssertPlaceHolder>"; }
getQuantidadeLetrasMinusculas(String str) { return 0; }
[*] target: assertEquals(5, quantidadeLetrasMinusculas)
[-] pred: org. junit. Assert. assertEquals ( 5, quantidadeLetrasMinusculas )
************************************
************************************
[+] input: getQuantidadeCaracteresEspeciais_test01() { int quantidadeCaracteresEspeciais = Strings.getQuantidadeCaracteresEspeciais("Felix"); "<AssertPlaceHolder>"; }
getQuantidadeCaracteresEspeciais(String str) { return 0; }
[*] target: assertEquals(0, quantidadeCaracteresEspeciais)
[-] pred: org. junit. Assert. assertEquals ( 0, quantidadeCaracteresEspeciais )
************************************
************************************
[+] input: getQuantidadeCaracteresEspeciais_test03() { int quantidadeCaracteresEspeciais = Strings.getQuantidadeCaracteresEspeciais(""); "<AssertPlaceHolder>"; }
getQuantidadeCaracteresEspeciais(String str) { return 0; }
[*] target: assertEquals(0, quantidadeCaracteresEspeciais)
[-] pred: org. junit. Assert. assertEquals ( 0, quantidadeCaracteresEspeciais )
************************************
************************************
[+] input: getQuantidadeCaracteresEspeciais_test04() { int quantidadeCaracteresEspeciais = Strings.getQuantidadeCaracteresEspeciais(null); "<AssertPlaceHolder>"; }
getQuantidadeCaracteresEspeciais(String str) { return 0; }
[*] target: assertEquals(0, quantidadeCaracteresEspeciais)
[-] pred: org. junit. Assert. assertEquals ( 0, quantidadeCaracteresEspeciais )
************************************
************************************
[+] input: getQuantidadeCaracteresEspeciais_test05() { int quantidadeCaracteresEspeciais = Strings.getQuantidadeCaracteresEspeciais("!@#)("); "<AssertPlaceHolder>"; }
getQuantidadeCaracteresEspeciais(String str) { return 0; }
[*] target: assertEquals(5, quantidadeCaracteresEspeciais)
[-] pred: org. junit. Assert. assertEquals ( 5, quantidadeCaracteresEspeciais )
************************************
************************************
[+] input: incrementAndGet() { DefaultIdSegment segment = new DefaultIdSegment(1, 1); long id = segment.incrementAndGet(); Assertions."<AssertPlaceHolder>"; }
incrementAndGet() { if (isOverflow()) { return SEQUENCE_OVERFLOW; }  final long nextSeq = S.incrementAndGet(this);  if (isOverflow(nextSeq)) { return SEQUENCE_OVERFLOW; } GroupedAccessor.setIfNotNever(group()); return nextSeq; }
[*] target: assertEquals(1, id)
[-] pred: org. junit. Assert. assertEquals ( 1, id )
************************************
************************************
[+] input: statUuidGenerator() { var stat = UuidGenerator.INSTANCE.stat(); Assertions."<AssertPlaceHolder>"; }
stat();
[*] target: assertNotNull(stat)
[-] pred: org. junit. Assert. assertNotNull ( stat )
************************************
************************************
[+] input: isEnabled() { CosIdProperties properties = new CosIdProperties(); Assertions."<AssertPlaceHolder>"; }
isEnabled() { return enabled; }
[*] target: assertTrue(properties.isEnabled())
[-] pred: org. junit. Assert. assertTrue ( properties. isEnabled() )
************************************
************************************
[+] input: setEnabled() { CosIdProperties properties = new CosIdProperties(); properties.setEnabled(false); Assertions."<AssertPlaceHolder>"; }
isEnabled() { return enabled; }
[*] target: assertFalse(properties.isEnabled())
[-] pred: org. junit. Assert. assertFalse ( properties. isEnabled() )
************************************
************************************
[+] input: setNamespace() { String namespace = "test"; CosIdProperties properties = new CosIdProperties(); properties.setNamespace(namespace); Assertions."<AssertPlaceHolder>"; }
getNamespace() { return namespace; }
[*] target: assertEquals(namespace, properties.getNamespace())
[-] pred: org. junit. Assert. assertEquals ( namespace, properties. getNamespace() )
************************************
************************************
[+] input: setPrefix() { String prefix = "test"; IdConverterDefinition definition = new IdConverterDefinition(); definition.setPrefix(prefix); Assertions."<AssertPlaceHolder>"; }
getPrefix() { return prefix; }
[*] target: assertEquals(prefix, definition.getPrefix())
[-] pred: org. junit. Assert. assertEquals ( prefix, definition. getPrefix() )
************************************
************************************
[+] input: setSuffix() { String suffix = "test"; IdConverterDefinition definition = new IdConverterDefinition(); definition.setSuffix(suffix); Assertions."<AssertPlaceHolder>"; }
getSuffix() { return suffix; }
[*] target: assertEquals(suffix, definition.getSuffix())
[-] pred: org. junit. Assert. assertEquals ( suffix, definition. getSuffix() )
************************************
************************************
[+] input: setEnabled() { CosIdGeneratorProperties properties = new CosIdGeneratorProperties(); properties.setEnabled(true); Assertions."<AssertPlaceHolder>"; }
isEnabled() { return enabled; }
[*] target: assertTrue(properties.isEnabled())
[-] pred: org. junit. Assert. assertTrue ( properties. isEnabled() )
************************************
************************************
[+] input: setNamespace() { CosIdGeneratorProperties properties = new CosIdGeneratorProperties(); String namespace = "wow cosid"; properties.setNamespace(namespace); Assertions."<AssertPlaceHolder>"; }
getNamespace() { return namespace; }
[*] target: assertEquals(namespace, properties.getNamespace())
[-] pred: org. junit. Assert. assertEquals ( namespace, properties. getNamespace() )
************************************
************************************
[+] input: setTimestampBit() { CosIdGeneratorProperties properties = new CosIdGeneratorProperties(); int timestampBit = 50; properties.setTimestampBit(50); Assertions."<AssertPlaceHolder>"; }
getTimestampBit() { return timestampBit; }
[*] target: assertEquals(timestampBit, properties.getTimestampBit())
[-] pred: org. junit. Assert. assertEquals ( timestampBit, properties. getTimestampBit() )
************************************
************************************
[+] input: setClockBackwards() { MachineProperties.ClockBackwards clockBackwards = new MachineProperties.ClockBackwards(); MachineProperties properties = new MachineProperties(); properties.setClockBackwards(clockBackwards); Assertions."<AssertPlaceHolder>"; }
getClockBackwards() { return clockBackwards; }
[*] target: assertEquals(clockBackwards, properties.getClockBackwards())
[-] pred: org. junit. Assert. assertEquals ( clockBackwards, properties. getClockBackwards() )
************************************
************************************
[+] input: setInstanceId() { String instanceId = MockIdGenerator.INSTANCE.generateAsString(); MachineProperties properties = new MachineProperties(); properties.setInstanceId(instanceId); Assertions."<AssertPlaceHolder>"; }
getInstanceId() { return instanceId; }
[*] target: assertEquals(instanceId, properties.getInstanceId())
[-] pred: org. junit. Assert. assertEquals ( instanceId, properties. getInstanceId() )
************************************
************************************
[+] input: setMachineBit() { int machineBit = 9; MachineProperties properties = new MachineProperties(); properties.setMachineBit(machineBit); Assertions."<AssertPlaceHolder>"; }
getMachineBit() { return machineBit; }
[*] target: assertEquals(machineBit, properties.getMachineBit())
[-] pred: org. junit. Assert. assertEquals ( machineBit, properties. getMachineBit() )
************************************
************************************
[+] input: setSpinThreshold() { int spinThreshold = 100; MachineProperties.ClockBackwards clockBackwards = new MachineProperties.ClockBackwards(); clockBackwards.setSpinThreshold(spinThreshold); Assertions."<AssertPlaceHolder>"; }
getSpinThreshold() { return spinThreshold; }
[*] target: assertEquals(spinThreshold, clockBackwards.getSpinThreshold())
[-] pred: org. junit. Assert. assertEquals ( spinThreshold, clockBackwards. getSpinThreshold() )
************************************
************************************
[+] input: setBrokenThreshold() { int brokenThreshold = 10; MachineProperties.ClockBackwards clockBackwards = new MachineProperties.ClockBackwards(); clockBackwards.setBrokenThreshold(brokenThreshold); Assertions."<AssertPlaceHolder>"; }
getBrokenThreshold() { return brokenThreshold; }
[*] target: assertEquals(brokenThreshold, clockBackwards.getBrokenThreshold())
[-] pred: org. junit. Assert. assertEquals ( brokenThreshold, clockBackwards. getBrokenThreshold() )
************************************
************************************
[+] input: setStateLocation() { String stateLocation = MockIdGenerator.INSTANCE.generateAsString(); MachineProperties.StateStorage.Local local = new MachineProperties.StateStorage.Local(); local.setStateLocation(stateLocation); Assertions."<AssertPlaceHolder>"; }
getStateLocation() { return stateLocation; }
[*] target: assertEquals(stateLocation, local.getStateLocation())
[-] pred: org. junit. Assert. assertEquals ( stateLocation, local. getStateLocation() )
************************************
************************************
[+] input: setType() { MachineProperties.Distributor.Type type = MachineProperties.Distributor.Type.JDBC; MachineProperties.Distributor distributor = new MachineProperties.Distributor(); distributor.setType(type); Assertions."<AssertPlaceHolder>"; }
getType() { return type; }
[*] target: assertEquals(type, distributor.getType())
[-] pred: org. junit. Assert. assertEquals ( type, distributor. getType() )
************************************
************************************
[+] input: setManual() { MachineProperties.Manual manual = new MachineProperties.Manual(); MachineProperties.Distributor distributor = new MachineProperties.Distributor(); distributor.setManual(manual); Assertions."<AssertPlaceHolder>"; }
getManual() { return manual; }
[*] target: assertEquals(manual, distributor.getManual())
[-] pred: org. junit. Assert. assertEquals ( manual, distributor. getManual() )
************************************
************************************
[+] input: getRedis() { MachineProperties.Distributor distributor = new MachineProperties.Distributor(); Assertions."<AssertPlaceHolder>"; }
getRedis() { return redis; }
[*] target: assertNotNull(distributor.getRedis())
[-] pred: org. junit. Assert. assertNotNull ( distributor. getRedis() )
************************************
************************************
[+] input: setMachineId() { Integer machineId = 1; MachineProperties.Manual manual = new MachineProperties.Manual(); manual.setMachineId(machineId); Assertions."<AssertPlaceHolder>"; }
getMachineId() { return machineId; }
[*] target: assertEquals(machineId, manual.getMachineId())
[-] pred: org. junit. Assert. assertEquals ( machineId, manual. getMachineId() )
************************************
************************************
[+] input: setTimeout() { Duration timeout = Duration.ofSeconds(2); MachineProperties.Redis redis = new MachineProperties.Redis(); redis.setTimeout(timeout); Assertions."<AssertPlaceHolder>"; }
getTimeout() { return timeout; }
[*] target: assertEquals(timeout, redis.getTimeout())
[-] pred: org. junit. Assert. assertEquals ( timeout, redis. getTimeout() )
************************************
************************************
[+] input: setShare() { SegmentIdProperties.ShardIdDefinition idDefinition = new SegmentIdProperties.ShardIdDefinition(); SegmentIdProperties properties = new SegmentIdProperties(); properties.setShare(idDefinition); Assertions."<AssertPlaceHolder>"; }
getShare() { return share; }
[*] target: assertEquals(idDefinition, properties.getShare())
[-] pred: org. junit. Assert. assertEquals ( idDefinition, properties. getShare() )
************************************
************************************
[+] input: setProvider() { Map<String, SegmentIdProperties.IdDefinition> provider = new HashMap<>(); SegmentIdProperties properties = new SegmentIdProperties(); properties.setProvider(provider); Assertions."<AssertPlaceHolder>"; }
getProvider() { return provider; }
[*] target: assertEquals(provider, properties.getProvider())
[-] pred: org. junit. Assert. assertEquals ( provider, properties. getProvider() )
************************************
************************************
[+] input: setSafeDistance() { int safeDistance = 1; SegmentIdProperties.Chain chain = new SegmentIdProperties.Chain(); chain.setSafeDistance(safeDistance); Assertions."<AssertPlaceHolder>"; }
getSafeDistance() { return safeDistance; }
[*] target: assertEquals(safeDistance, chain.getSafeDistance())
[-] pred: org. junit. Assert. assertEquals ( safeDistance, chain. getSafeDistance() )
************************************
************************************
[+] input: getPrefetchWorker() { SegmentIdProperties.Chain chain = new SegmentIdProperties.Chain(); Assertions."<AssertPlaceHolder>"; }
getPrefetchWorker() { return prefetchWorker; }
[*] target: assertNotNull(chain.getPrefetchWorker())
[-] pred: org. junit. Assert. assertNotNull ( chain. getPrefetchWorker() )
************************************
************************************
[+] input: setPrefetchWorker() { SegmentIdProperties.Chain.PrefetchWorker prefetchWorker = new SegmentIdProperties.Chain.PrefetchWorker(); SegmentIdProperties.Chain chain = new SegmentIdProperties.Chain(); chain.setPrefetchWorker(prefetchWorker); Assertions."<AssertPlaceHolder>"; }
getPrefetchWorker() { return prefetchWorker; }
[*] target: assertEquals(prefetchWorker, chain.getPrefetchWorker())
[-] pred: org. junit. Assert. assertEquals ( prefetchWorker, chain. getPrefetchWorker() )
************************************
************************************
[+] input: setPrefetchPeriod() { Duration prefetchPeriod = Duration.ZERO; SegmentIdProperties.Chain.PrefetchWorker prefetchWorker = new SegmentIdProperties.Chain.PrefetchWorker(); prefetchWorker.setPrefetchPeriod(prefetchPeriod); Assertions."<AssertPlaceHolder>"; }
getPrefetchPeriod() { return prefetchPeriod; }
[*] target: assertEquals(prefetchPeriod, prefetchWorker.getPrefetchPeriod())
[-] pred: org. junit. Assert. assertEquals ( prefetchPeriod, prefetchWorker. getPrefetchPeriod() )
************************************
************************************
[+] input: setCorePoolSize() { int corePoolSize = 1; SegmentIdProperties.Chain.PrefetchWorker prefetchWorker = new SegmentIdProperties.Chain.PrefetchWorker(); prefetchWorker.setCorePoolSize(corePoolSize); Assertions."<AssertPlaceHolder>"; }
getCorePoolSize() { return corePoolSize; }
[*] target: assertEquals(corePoolSize, prefetchWorker.getCorePoolSize())
[-] pred: org. junit. Assert. assertEquals ( corePoolSize, prefetchWorker. getCorePoolSize() )
************************************
************************************
[+] input: isShutdownHook() { SegmentIdProperties.Chain.PrefetchWorker prefetchWorker = new SegmentIdProperties.Chain.PrefetchWorker(); Assertions."<AssertPlaceHolder>"; }
isShutdownHook() { return shutdownHook; }
[*] target: assertTrue(prefetchWorker.isShutdownHook())
[-] pred: org. junit. Assert. assertTrue ( prefetchWorker. isShutdownHook() )
************************************
************************************
[+] input: setShutdownHook() { SegmentIdProperties.Chain.PrefetchWorker prefetchWorker = new SegmentIdProperties.Chain.PrefetchWorker(); prefetchWorker.setShutdownHook(false); Assertions."<AssertPlaceHolder>"; }
isShutdownHook() { return shutdownHook; }
[*] target: assertFalse(prefetchWorker.isShutdownHook())
[-] pred: org. junit. Assert. assertFalse ( prefetchWorker. isShutdownHook() )
************************************
************************************
[+] input: setType() { SegmentIdProperties.Distributor.Type type = SegmentIdProperties.Distributor.Type.JDBC; SegmentIdProperties.Distributor distributor = new SegmentIdProperties.Distributor(); distributor.setType(type); Assertions."<AssertPlaceHolder>"; }
getType() { return type; }
[*] target: assertEquals(type, distributor.getType())
[-] pred: org. junit. Assert. assertEquals ( type, distributor. getType() )
************************************
************************************
[+] input: getRedis() { SegmentIdProperties.Distributor distributor = new SegmentIdProperties.Distributor(); Assertions."<AssertPlaceHolder>"; }
getRedis() { return redis; }
[*] target: assertNotNull(distributor.getRedis())
[-] pred: org. junit. Assert. assertNotNull ( distributor. getRedis() )
************************************
************************************
[+] input: getJdbc() { SegmentIdProperties.Distributor distributor = new SegmentIdProperties.Distributor(); Assertions."<AssertPlaceHolder>"; }
getJdbc() { return jdbc; }
[*] target: assertNotNull(distributor.getJdbc())
[-] pred: org. junit. Assert. assertNotNull ( distributor. getJdbc() )
************************************
************************************
[+] input: setJdbc() { SegmentIdProperties.Distributor.Jdbc jdbc = new SegmentIdProperties.Distributor.Jdbc(); SegmentIdProperties.Distributor distributor = new SegmentIdProperties.Distributor(); distributor.setJdbc(jdbc); Assertions."<AssertPlaceHolder>"; }
getJdbc() { return jdbc; }
[*] target: assertEquals(jdbc, distributor.getJdbc())
[-] pred: org. junit. Assert. assertEquals ( jdbc, distributor. getJdbc() )
************************************
************************************
[+] input: setTimeout() { Duration timeout = Duration.ZERO; SegmentIdProperties.Distributor.Redis redis = new SegmentIdProperties.Distributor.Redis(); redis.setTimeout(timeout); Assertions."<AssertPlaceHolder>"; }
getTimeout() { return timeout; }
[*] target: assertEquals(timeout, redis.getTimeout())
[-] pred: org. junit. Assert. assertEquals ( timeout, redis. getTimeout() )
************************************
************************************
[+] input: setIncrementMaxIdSql() { String incrementMaxIdSql = "Great CosId!"; SegmentIdProperties.Distributor.Jdbc jdbc = new SegmentIdProperties.Distributor.Jdbc(); jdbc.setIncrementMaxIdSql(incrementMaxIdSql); Assertions."<AssertPlaceHolder>"; }
getIncrementMaxIdSql() { return incrementMaxIdSql; }
[*] target: assertEquals(incrementMaxIdSql, jdbc.getIncrementMaxIdSql())
[-] pred: org. junit. Assert. assertEquals ( incrementMaxIdSql, jdbc. getIncrementMaxIdSql() )
************************************
************************************
[+] input: setFetchMaxIdSql() { String fetchMaxIdSql = "Great CosId!"; SegmentIdProperties.Distributor.Jdbc jdbc = new SegmentIdProperties.Distributor.Jdbc(); jdbc.setFetchMaxIdSql(fetchMaxIdSql); Assertions."<AssertPlaceHolder>"; }
getFetchMaxIdSql() { return fetchMaxIdSql; }
[*] target: assertEquals(fetchMaxIdSql, jdbc.getFetchMaxIdSql())
[-] pred: org. junit. Assert. assertEquals ( fetchMaxIdSql, jdbc. getFetchMaxIdSql ( ) )
************************************
************************************
[+] input: setInitCosidTableSql() { String initCosidTableSql = "Great CosId!"; SegmentIdProperties.Distributor.Jdbc jdbc = new SegmentIdProperties.Distributor.Jdbc(); jdbc.setInitCosidTableSql(initCosidTableSql); Assertions."<AssertPlaceHolder>"; }
getInitCosidTableSql() { return initCosidTableSql; }
[*] target: assertEquals(initCosidTableSql, jdbc.getInitCosidTableSql())
[-] pred: org. junit. Assert. assertEquals ( initCosidTableSql, jdbc. getInitCosidTableSql() )
************************************
************************************
[+] input: setInitIdSegmentSql() { String initIdSegmentSql = "Great CosId!"; SegmentIdProperties.Distributor.Jdbc jdbc = new SegmentIdProperties.Distributor.Jdbc(); jdbc.setInitIdSegmentSql(initIdSegmentSql); Assertions."<AssertPlaceHolder>"; }
getInitIdSegmentSql() { return initIdSegmentSql; }
[*] target: assertEquals(initIdSegmentSql, jdbc.getInitIdSegmentSql())
[-] pred: org. junit. Assert. assertEquals ( initIdSegmentSql, jdbc. getInitIdSegmentSql() )
************************************
************************************
[+] input: getNamespace() { SegmentIdProperties.IdDefinition idDefinition = new SegmentIdProperties.IdDefinition(); Assertions."<AssertPlaceHolder>"; }
getNamespace() { return namespace; }
[*] target: assertNull(idDefinition.getNamespace())
[-] pred: org. junit. Assert. assertNull ( idDefinition. getNamespace() )
************************************
************************************
[+] input: setNamespace() { String namespace = "segment-namespace"; SegmentIdProperties.IdDefinition idDefinition = new SegmentIdProperties.IdDefinition(); idDefinition.setNamespace(namespace); Assertions."<AssertPlaceHolder>"; }
getNamespace() { return namespace; }
[*] target: assertEquals(namespace, idDefinition.getNamespace())
[-] pred: org. junit. Assert. assertEquals ( namespace, idDefinition. getNamespace() )
************************************
************************************
[+] input: setOffset() { long offset = 100; SegmentIdProperties.IdDefinition idDefinition = new SegmentIdProperties.IdDefinition(); idDefinition.setOffset(offset); Assertions."<AssertPlaceHolder>"; }
getOffset() { return offset; }
[*] target: assertEquals(offset, idDefinition.getOffset())
[-] pred: org. junit. Assert. assertEquals ( offset, idDefinition. getOffset() )
************************************
************************************
[+] input: setStep() { long step = 1; SegmentIdProperties.IdDefinition idDefinition = new SegmentIdProperties.IdDefinition(); idDefinition.setStep(step); Assertions."<AssertPlaceHolder>"; }
getStep() { return step; }
[*] target: assertEquals(step, idDefinition.getStep())
[-] pred: org. junit. Assert. assertEquals ( step, idDefinition. getStep() )
************************************
************************************
[+] input: setConverter() { IdConverterDefinition converter = new IdConverterDefinition(); SegmentIdProperties.IdDefinition idDefinition = new SegmentIdProperties.IdDefinition(); idDefinition.setConverter(converter); Assertions."<AssertPlaceHolder>"; }
getConverter() { return converter; }
[*] target: assertEquals(converter, idDefinition.getConverter())
[-] pred: org. junit. Assert. assertEquals ( converter, idDefinition. getConverter() )
************************************
************************************
[+] input: getProvider() { SnowflakeIdProperties properties = new SnowflakeIdProperties(); Assertions."<AssertPlaceHolder>"; }
getProvider() { return provider; }
[*] target: assertNotNull(properties.getProvider())
[-] pred: org. junit. Assert. assertNotNull ( properties. getProvider() )
************************************
************************************
[+] input: setProvider() { Map<String, SnowflakeIdProperties.IdDefinition> provider = new HashMap<>(); SnowflakeIdProperties properties = new SnowflakeIdProperties(); properties.setProvider(provider); Assertions."<AssertPlaceHolder>"; }
getProvider() { return provider; }
[*] target: assertEquals(provider, properties.getProvider())
[-] pred: org. junit. Assert. assertEquals ( provider, properties. getProvider() )
************************************
************************************
[+] input: setNamespace() { String namespace = "snowflake-namespace"; SnowflakeIdProperties.IdDefinition idDefinition = new SnowflakeIdProperties.IdDefinition(); idDefinition.setNamespace(namespace); Assertions."<AssertPlaceHolder>"; }
getNamespace() { return namespace; }
[*] target: assertEquals(namespace, idDefinition.getNamespace())
[-] pred: org. junit. Assert. assertEquals ( namespace, idDefinition. getNamespace() )
************************************
************************************
[+] input: isClockSync() { SnowflakeIdProperties.IdDefinition idDefinition = new SnowflakeIdProperties.IdDefinition(); Assertions."<AssertPlaceHolder>"; }
isClockSync() { return clockSync; }
[*] target: assertTrue(idDefinition.isClockSync())
[-] pred: org. junit. Assert. assertTrue ( idDefinition. isClockSync() )
************************************
************************************
[+] input: setClockSync() { SnowflakeIdProperties.IdDefinition idDefinition = new SnowflakeIdProperties.IdDefinition(); idDefinition.setClockSync(false); Assertions."<AssertPlaceHolder>"; }
isClockSync() { return clockSync; }
[*] target: assertFalse(idDefinition.isClockSync())
[-] pred: org. junit. Assert. assertFalse ( idDefinition. isClockSync() )
************************************
************************************
[+] input: isFriendly() { SnowflakeIdProperties.IdDefinition idDefinition = new SnowflakeIdProperties.IdDefinition(); Assertions."<AssertPlaceHolder>"; }
isFriendly() { return friendly; }
[*] target: assertTrue(idDefinition.isFriendly())
[-] pred: org. junit. Assert. assertTrue ( idDefinition. isFriendly() )
************************************
************************************
[+] input: setFriendly() { SnowflakeIdProperties.IdDefinition idDefinition = new SnowflakeIdProperties.IdDefinition(); idDefinition.setFriendly(false); Assertions."<AssertPlaceHolder>"; }
isFriendly() { return friendly; }
[*] target: assertFalse(idDefinition.isFriendly())
[-] pred: org. junit. Assert. assertFalse ( idDefinition. isFriendly() )
************************************
************************************
[+] input: setMachineBit() { int machineBit = 6; SnowflakeIdProperties.IdDefinition idDefinition = new SnowflakeIdProperties.IdDefinition(); idDefinition.setMachineBit(machineBit); Assertions."<AssertPlaceHolder>"; }
getMachineBit() { return machineBit; }
[*] target: assertEquals(machineBit, idDefinition.getMachineBit())
[-] pred: org. junit. Assert. assertEquals ( machineBit, idDefinition. getMachineBit() )
************************************
************************************
[+] input: setTimestampBit() { int timestampBit = 45; SnowflakeIdProperties.IdDefinition idDefinition = new SnowflakeIdProperties.IdDefinition(); idDefinition.setTimestampBit(timestampBit); Assertions."<AssertPlaceHolder>"; }
getTimestampBit() { return timestampBit; }
[*] target: assertEquals(timestampBit, idDefinition.getTimestampBit())
[-] pred: org. junit. Assert. assertEquals ( timestampBit, idDefinition. getTimestampBit() )
************************************
************************************
[+] input: setSequenceBit() { int sequenceBit = 10; SnowflakeIdProperties.IdDefinition idDefinition = new SnowflakeIdProperties.IdDefinition(); idDefinition.setSequenceBit(sequenceBit); Assertions."<AssertPlaceHolder>"; }
getSequenceBit() { return sequenceBit; }
[*] target: assertEquals(sequenceBit, idDefinition.getSequenceBit())
[-] pred: org. junit. Assert. assertEquals ( sequenceBit, idDefinition. getSequenceBit() )
************************************
************************************
[+] input: getConverter() { SnowflakeIdProperties.IdDefinition idDefinition = new SnowflakeIdProperties.IdDefinition(); Assertions."<AssertPlaceHolder>"; }
getConverter() { return converter; }
[*] target: assertNotNull(idDefinition.getConverter())
[-] pred: org. junit. Assert. assertNotNull ( idDefinition. getConverter() )
************************************
************************************
[+] input: isEnabled() { CosIdZookeeperProperties properties = new CosIdZookeeperProperties(); Assertions."<AssertPlaceHolder>"; }
isEnabled() { return enabled; }
[*] target: assertTrue(properties.isEnabled())
[-] pred: org. junit. Assert. assertTrue ( properties. isEnabled() )
************************************
************************************
[+] input: setEnabled() { CosIdZookeeperProperties properties = new CosIdZookeeperProperties(); properties.setEnabled(false); Assertions."<AssertPlaceHolder>"; }
isEnabled() { return enabled; }
[*] target: assertFalse(properties.isEnabled())
[-] pred: org. junit. Assert. assertFalse ( properties. isEnabled() )
************************************
************************************
[+] input: setConnectString() { String connectString = "localhost:2182"; CosIdZookeeperProperties properties = new CosIdZookeeperProperties(); properties.setConnectString(connectString); Assertions."<AssertPlaceHolder>"; }
getConnectString() { return connectString; }
[*] target: assertEquals(connectString, properties.getConnectString())
[-] pred: org. junit. Assert. assertEquals ( connectString, properties. getConnectString() )
************************************
************************************
[+] input: getSessionTimeout() { Duration sessionTimeout = Duration.ofSeconds(60); CosIdZookeeperProperties properties = new CosIdZookeeperProperties(); Assertions."<AssertPlaceHolder>"; }
getSessionTimeout() { return sessionTimeout; }
[*] target: assertEquals(sessionTimeout, properties.getSessionTimeout())
[-] pred: org. junit. Assert. assertEquals ( sessionTimeout, properties. getSessionTimeout() )
************************************
************************************
[+] input: setSessionTimeout() { Duration sessionTimeout = Duration.ofSeconds(10); CosIdZookeeperProperties properties = new CosIdZookeeperProperties(); properties.setSessionTimeout(sessionTimeout); Assertions."<AssertPlaceHolder>"; }
getSessionTimeout() { return sessionTimeout; }
[*] target: assertEquals(sessionTimeout, properties.getSessionTimeout())
[-] pred: org. junit. Assert. assertEquals ( sessionTimeout, properties. getSessionTimeout() )
************************************
************************************
[+] input: generateAccessToken() { String accessToken = accessTokenService.generateAccessToken(UUID.randomUUID().toString()); PayloadDTO payloadDTO = generatePayloadDTO(accessToken); boolean result = accessTokenService.validateAccessToken(accessToken, payloadDTO); "<AssertPlaceHolder>"; }
validateAccessToken(String token, PayloadDTO payloadDTO) { String[] parts = token.split("\\."); if (parts.length != 3 || payloadDTO == null) return false;  String payload = parts[1]; String signature = parts[2]; return generateSignature(payload).equals(signature); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: generateAccessTokenFromNonUUID() { String accessToken = accessTokenService.generateAccessToken("testetstetstetstestste"); PayloadDTO payloadDTO = generatePayloadDTO(accessToken); boolean result = accessTokenService.validateAccessToken(accessToken, payloadDTO); "<AssertPlaceHolder>"; }
validateAccessToken(String token, PayloadDTO payloadDTO) { String[] parts = token.split("\\."); if (parts.length != 3 || payloadDTO == null) return false;  String payload = parts[1]; String signature = parts[2]; return generateSignature(payload).equals(signature); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: inValidateAccessToken() { PayloadDTO dto = PayloadDTO.builder().exp(16868291L).sub(UUID.randomUUID().toString()).build(); boolean result = accessTokenService.validateAccessToken("test",dto); "<AssertPlaceHolder>"; }
validateAccessToken(String token, PayloadDTO payloadDTO) { String[] parts = token.split("\\."); if (parts.length != 3 || payloadDTO == null) return false;  String payload = parts[1]; String signature = parts[2]; return generateSignature(payload).equals(signature); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: inValidatePayLoadOfNull() { boolean payloadOfNull = accessTokenService .validateAccessToken(accessTokenService.generateAccessToken(UUID.randomUUID().toString()), null); "<AssertPlaceHolder>"; }
generateAccessToken(String userId) { long expirationTime = System.currentTimeMillis() + expirationTimeMillis; String token = UUID.randomUUID().toString(); String payload = generatePayload(userId,expirationTime); String signature = generateSignature(payload); return token + "." +payload + "." + signature; }
[*] target: assertFalse(payloadOfNull)
[-] pred: org. junit. Assert. assertFalse ( payloadOfNull )
************************************
************************************
[+] input: inValidateSignature() {  String accessToken = accessTokenService.generateAccessToken(UUID.randomUUID().toString()); String[] parts = accessToken.split("\\."); String token = parts[0]; String payload = parts[1]; PayloadDTO payloadDTO = generatePayloadDTO(accessToken); String forgedToken = token + "." + payload + "." + "checksumTest"; boolean result = accessTokenService .validateAccessToken(forgedToken, payloadDTO); "<AssertPlaceHolder>"; }
validateAccessToken(String token, PayloadDTO payloadDTO) { String[] parts = token.split("\\."); if (parts.length != 3 || payloadDTO == null) return false;  String payload = parts[1]; String signature = parts[2]; return generateSignature(payload).equals(signature); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: isAccessTokenExpired() {  long expirationTime = System.currentTimeMillis() - 62 * 60 *1000L; String token = UUID.randomUUID().toString(); String userId = UUID.randomUUID().toString(); String payload = accessTokenService.generatePayload(userId,expirationTime); String signature = accessTokenService.generateSignature(payload); String signedToken = token + "." +payload + "." + signature; PayloadDTO payloadDTO = generatePayloadDTO(signedToken); boolean result = accessTokenService .isAccessTokenExpired(payloadDTO); "<AssertPlaceHolder>"; }
isAccessTokenExpired(PayloadDTO payloadDTO) { return System.currentTimeMillis() > payloadDTO.getExp(); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: shouldWorkWithNoCronSet() { dateUtils.setCurrentNow(WINTER_TIME_DATE);  service.switchToSummerTime(); service.switchToWinterTime(); Assertions."<AssertPlaceHolder>"; }
switchToWinterTime() { logger.info("Sunday of October. Is it Winter Time?"); if(dateUtils.isLastSundayOfMonth()) { logger.info("Winter Time");  String cronStart = kubernetesService.getCronStartAsString(); String cronStop = kubernetesService.getCronStopAsString();  String newCronStart = getCronWithWinterTimeAsString(cronStart); String newCronStop = getCronWithWinterTimeAsString(cronStop);  kubernetesService.deleteCronJobs();  kubernetesService.createStartCronJob(newCronStart); kubernetesService.createStopCronJob(newCronStop); } }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: Exception { InputCodec objectUnderTest = new InputCodec() { @Override public void parse(InputStream inputStream, Consumer<Record<Event>> eventConsumer) throws IOException {  } };  inputFile = mock(InputFile.class); inputStream = mock(SeekableInputStream.class); decompressionEngine = mock(DecompressionEngine.class); when(inputFile.newStream()).thenReturn(inputStream); closeCalled = false; doAnswer(a -> { closeCalled = true; return null; }).when(inputStream).close(); when(decompressionEngine.createInputStream(any(InputStream.class))).thenReturn(inputStream); objectUnderTest.parse(inputFile, decompressionEngine, rec -> {}); "<AssertPlaceHolder>"; }
parse( InputFile inputFile, DecompressionEngine decompressionEngine, Consumer<Record<Event>> eventConsumer) throws IOException { Objects.requireNonNull(inputFile); Objects.requireNonNull(eventConsumer); try (InputStream inputStream = inputFile.newStream()) { parse(decompressionEngine.createInputStream(inputStream), eventConsumer); } }
[*] target: assertTrue(closeCalled)
[-] pred: org. junit. Assert. assertTrue ( closeCalled )
************************************
************************************
[+] input: testBufferIsEmpty_without_write() { final PeerForwarderReceiveBuffer<Record<String>> peerForwarderReceiveBuffer = createObjectUnderTest(TEST_BUFFER_SIZE);  Assertions."<AssertPlaceHolder>"; }
isEmpty() { return blockingQueue.isEmpty() && recordsInFlight == 0; }
[*] target: assertTrue(peerForwarderReceiveBuffer.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( peerForwarderReceiveBuffer. isEmpty ( ) )
************************************
************************************
[+] input: Exception { String pluginName = "test-plugin";  // Load the actual resource InputStream inputStream = transformersFactory.getPluginTemplateFileStream(pluginName);  "<AssertPlaceHolder>"; inputStream.close(); }
getPluginTemplateFileStream(String pluginName) { if (pluginName == null || pluginName.isEmpty()) { throw new RuntimeException("Transformation plugin not found"); }  // Construct the expected file name String templateFileName = pluginName + TEMPLATE_FILE_NAME_PATTERN;  // Use the ClassLoader to find the template file on the classpath ClassLoader classLoader = getClass().getClassLoader(); URL templateURL = classLoader.getResource(TEMPLATES_PATH + templateFileName);  if (templateURL == null) { throw new RuntimeException("Template file not found for plugin: " + pluginName); }  try { // Convert the URL to a URI, then to a Path to read the file Path templatePath; try { templatePath = Paths.get(templateURL.toURI()); } catch (FileSystemNotFoundException e) { // Handle the case where the file system is not accessible (e.g., in a JAR) FileSystem fileSystem = FileSystems.newFileSystem(templateURL.toURI(), Collections.emptyMap()); templatePath = fileSystem.getPath(TEMPLATES_PATH + templateFileName); }  // Return an InputStream for the found file return Files.newInputStream(templatePath);  } catch (IOException | URISyntaxException e) { throw new RuntimeException("Failed to load template file for plugin: " + pluginName, e); } }
[*] target: assertNotNull(inputStream)
[-] pred: org. junit. Assert. assertNotNull ( inputStream )
************************************
************************************
[+] input: IOException { when(buffer.getSize()).thenReturn(maxBytes.getBytes() - 1000); when(buffer.getEventCount()).thenReturn(maxEvents + 1); when(buffer.getDuration()).thenReturn(maxCollectionDuration.minusSeconds(1)); Boolean isBatchEnabled = false;  boolean isThresholdExceed = ThresholdCheck.checkThresholdExceed(buffer, maxEvents, maxBytes, maxCollectionDuration, isBatchEnabled);  "<AssertPlaceHolder>"; }
checkThresholdExceed(final Buffer currentBuffer, final int maxEvents, final ByteCount maxBytes, final Duration maxCollectionDuration, final Boolean isBatchEnabled) { if (!isBatchEnabled) return true;  if (maxEvents > 0) { return currentBuffer.getEventCount() + 1 > maxEvents || currentBuffer.getDuration().compareTo(maxCollectionDuration) > 0 || currentBuffer.getSize() > maxBytes.getBytes(); } else { return currentBuffer.getDuration().compareTo(maxCollectionDuration) > 0 || currentBuffer.getSize() > maxBytes.getBytes(); } }
[*] target: assertTrue(isThresholdExceed)
[-] pred: org. junit. Assert. assertTrue ( isThresholdExceed )
************************************
************************************
[+] input: GIVEN_greater_than_limit_method_WHEN_event_size_greater_than_max_event_size_THEN_return_true() { boolean isEventGreater = cloudWatchLogsLimits.isGreaterThanMaxEventSize((thresholdConfig.getMaxEventSizeBytes() + 1) - CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanMaxEventSize(final long eventSize) { return (eventSize + APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE) > maxEventSizeBytes; }
[*] target: assertTrue(isEventGreater)
[-] pred: org. junit. Assert. assertTrue ( isEventGreater )
************************************
************************************
[+] input: GIVEN_greater_than_limit_method_WHEN_event_size_less_than_max_event_size_THEN_return_false() { boolean isEventGreater = cloudWatchLogsLimits.isGreaterThanMaxEventSize(((thresholdConfig.getMaxEventSizeBytes()) - 1) - CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanMaxEventSize(final long eventSize) { return (eventSize + APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE) > maxEventSizeBytes; }
[*] target: assertFalse(isEventGreater)
[-] pred: org. junit. Assert. assertFalse ( isEventGreater )
************************************
************************************
[+] input: GIVEN_greater_than_limit_method_WHEN_event_size_equal_to_max_event_size_THEN_return_false() { boolean isEventGreater = cloudWatchLogsLimits.isGreaterThanMaxEventSize((thresholdConfig.getMaxEventSizeBytes()) - CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanMaxEventSize(final long eventSize) { return (eventSize + APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE) > maxEventSizeBytes; }
[*] target: assertFalse(isEventGreater)
[-] pred: org. junit. Assert. assertFalse ( isEventGreater )
************************************
************************************
[+] input: GIVEN_greater_than_limit_method_WHEN_log_send_interval_equal_to_max_log_send_interval_THEN_return_true() { boolean thresholdMetTime = cloudWatchLogsLimits.isGreaterThanLimitReached(ThresholdConfig.DEFAULT_LOG_SEND_INTERVAL_TIME, thresholdConfig.getMaxRequestSizeBytes(),ThresholdConfig.DEFAULT_BATCH_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanLimitReached(final long currentTime, final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isGreaterThanBatchSize(batchSize) || isGreaterEqualToLogSendInterval(currentTime) || isGreaterThanMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertTrue(thresholdMetTime)
[-] pred: org. junit. Assert. assertTrue ( thresholdMetTime )
************************************
************************************
[+] input: SGIVEN_greater_than_limit_method_WHEN_log_send_interval_greater_than_max_log_send_interval_THEN_return_true() { boolean thresholdMetTime = cloudWatchLogsLimits.isGreaterThanLimitReached(ThresholdConfig.DEFAULT_LOG_SEND_INTERVAL_TIME + 1, thresholdConfig.getMaxRequestSizeBytes(),ThresholdConfig.DEFAULT_BATCH_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanLimitReached(final long currentTime, final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isGreaterThanBatchSize(batchSize) || isGreaterEqualToLogSendInterval(currentTime) || isGreaterThanMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertTrue(thresholdMetTime)
[-] pred: org. junit. Assert. assertTrue ( thresholdMetTime )
************************************
************************************
[+] input: GIVEN_greater_than_limit_method_WHEN_log_send_interval_less_than_max_log_send_interval_THEN_return_false() { long validRequestSize = thresholdConfig.getMaxRequestSizeBytes() - ((ThresholdConfig.DEFAULT_BATCH_SIZE) * CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); boolean thresholdMetTime = cloudWatchLogsLimits.isGreaterThanLimitReached(ThresholdConfig.DEFAULT_LOG_SEND_INTERVAL_TIME - 1, validRequestSize ,ThresholdConfig.DEFAULT_BATCH_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanLimitReached(final long currentTime, final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isGreaterThanBatchSize(batchSize) || isGreaterEqualToLogSendInterval(currentTime) || isGreaterThanMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertFalse(thresholdMetTime)
[-] pred: org. junit. Assert. assertFalse ( thresholdMetTime )
************************************
************************************
[+] input: GIVEN_greater_than_limit_method_WHEN_request_size_greater_than_max_request_size_THEN_return_true() { long requestSizeWithoutOverhead = (thresholdConfig.getMaxRequestSizeBytes() + 1) - ThresholdConfig.DEFAULT_BATCH_SIZE * (CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); boolean thresholdMetRequestSize = cloudWatchLogsLimits.isGreaterThanLimitReached(ThresholdConfig.DEFAULT_LOG_SEND_INTERVAL_TIME - 1, requestSizeWithoutOverhead, ThresholdConfig.DEFAULT_BATCH_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanLimitReached(final long currentTime, final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isGreaterThanBatchSize(batchSize) || isGreaterEqualToLogSendInterval(currentTime) || isGreaterThanMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertTrue(thresholdMetRequestSize)
[-] pred: org. junit. Assert. assertTrue ( thresholdMetRequestSize )
************************************
************************************
[+] input: GIVEN_greater_than_limit_method_WHEN_request_size_equal_to_max_request_size_THEN_return_false() { long requestSizeWithoutOverhead = (thresholdConfig.getMaxRequestSizeBytes()) - ThresholdConfig.DEFAULT_BATCH_SIZE * (CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); boolean thresholdMetRequestSize = cloudWatchLogsLimits.isGreaterThanLimitReached(ThresholdConfig.DEFAULT_LOG_SEND_INTERVAL_TIME - 1, requestSizeWithoutOverhead, ThresholdConfig.DEFAULT_BATCH_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanLimitReached(final long currentTime, final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isGreaterThanBatchSize(batchSize) || isGreaterEqualToLogSendInterval(currentTime) || isGreaterThanMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertFalse(thresholdMetRequestSize)
[-] pred: org. junit. Assert. assertFalse ( thresholdMetRequestSize )
************************************
************************************
[+] input: GIVEN_greater_than_limit_method_WHEN_request_size_less_than_max_request_size_THEN_return_false() { long requestSizeWithoutOverhead = (thresholdConfig.getMaxRequestSizeBytes() - 1) - ThresholdConfig.DEFAULT_BATCH_SIZE * (CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); boolean thresholdMetRequestSize = cloudWatchLogsLimits.isGreaterThanLimitReached(ThresholdConfig.DEFAULT_LOG_SEND_INTERVAL_TIME - 1, requestSizeWithoutOverhead, ThresholdConfig.DEFAULT_BATCH_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanLimitReached(final long currentTime, final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isGreaterThanBatchSize(batchSize) || isGreaterEqualToLogSendInterval(currentTime) || isGreaterThanMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertFalse(thresholdMetRequestSize)
[-] pred: org. junit. Assert. assertFalse ( thresholdMetRequestSize )
************************************
************************************
[+] input: GIVEN_greater_than_limit_method_WHEN_batch_size_greater_than_max_batch_size_THEN_return_true() { long requestSizeWithoutOverhead = (thresholdConfig.getMaxRequestSizeBytes()) - ThresholdConfig.DEFAULT_BATCH_SIZE * (CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); boolean thresholdMetBatchSize = cloudWatchLogsLimits.isGreaterThanLimitReached(ThresholdConfig.DEFAULT_LOG_SEND_INTERVAL_TIME -1, requestSizeWithoutOverhead, ThresholdConfig.DEFAULT_BATCH_SIZE + 1); "<AssertPlaceHolder>"; }
isGreaterThanLimitReached(final long currentTime, final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isGreaterThanBatchSize(batchSize) || isGreaterEqualToLogSendInterval(currentTime) || isGreaterThanMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertTrue(thresholdMetBatchSize)
[-] pred: org. junit. Assert. assertTrue ( thresholdMetBatchSize )
************************************
************************************
[+] input: GIVEN_greater_than_limit_method_WHEN_batch_size_equal_to_max_batch_size_THEN_return_false() { long validRequestSize = thresholdConfig.getMaxRequestSizeBytes() - ((ThresholdConfig.DEFAULT_BATCH_SIZE) * CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); boolean thresholdMetBatchSize = cloudWatchLogsLimits.isGreaterThanLimitReached(ThresholdConfig.DEFAULT_LOG_SEND_INTERVAL_TIME -1, validRequestSize, ThresholdConfig.DEFAULT_BATCH_SIZE); "<AssertPlaceHolder>"; }
isGreaterThanLimitReached(final long currentTime, final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isGreaterThanBatchSize(batchSize) || isGreaterEqualToLogSendInterval(currentTime) || isGreaterThanMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertFalse(thresholdMetBatchSize)
[-] pred: org. junit. Assert. assertFalse ( thresholdMetBatchSize )
************************************
************************************
[+] input: GIVEN_greater_than_limit_method_WHEN_batch_size_less_than_max_batch_size_THEN_return_false() { long validRequestSize = thresholdConfig.getMaxRequestSizeBytes()- ((ThresholdConfig.DEFAULT_BATCH_SIZE) * CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); boolean thresholdMetBatchSize = cloudWatchLogsLimits.isGreaterThanLimitReached(ThresholdConfig.DEFAULT_LOG_SEND_INTERVAL_TIME -1, validRequestSize, ThresholdConfig.DEFAULT_BATCH_SIZE - 1); "<AssertPlaceHolder>"; }
isGreaterThanLimitReached(final long currentTime, final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isGreaterThanBatchSize(batchSize) || isGreaterEqualToLogSendInterval(currentTime) || isGreaterThanMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertFalse(thresholdMetBatchSize)
[-] pred: org. junit. Assert. assertFalse ( thresholdMetBatchSize )
************************************
************************************
[+] input: GIVEN_equal_to_limit_method_WHEN_request_size_equal_to_max_batch_size_THEN_return_true() { long validRequestSize = thresholdConfig.getMaxRequestSizeBytes() - ((ThresholdConfig.DEFAULT_BATCH_SIZE) * CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE); boolean thresholdMetRequestSize = cloudWatchLogsLimits.isEqualToLimitReached(validRequestSize, ThresholdConfig.DEFAULT_BATCH_SIZE); "<AssertPlaceHolder>"; }
isEqualToLimitReached(final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isEqualBatchSize(batchSize) || isEqualMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertTrue(thresholdMetRequestSize)
[-] pred: org. junit. Assert. assertTrue ( thresholdMetRequestSize )
************************************
************************************
[+] input: GIVEN_equal_to_limit_method_WHEN_request_size_greater_than_max_batch_size_THEN_return_false() { long validRequestSize = ((thresholdConfig.getMaxRequestSizeBytes() + 1) - ((ThresholdConfig.DEFAULT_BATCH_SIZE - 1) * CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); boolean thresholdMetRequestSize = cloudWatchLogsLimits.isEqualToLimitReached(validRequestSize, ThresholdConfig.DEFAULT_BATCH_SIZE - 1); "<AssertPlaceHolder>"; }
isEqualToLimitReached(final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isEqualBatchSize(batchSize) || isEqualMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertFalse(thresholdMetRequestSize)
[-] pred: org. junit. Assert. assertFalse ( thresholdMetRequestSize )
************************************
************************************
[+] input: GIVEN_equal_to_limit_method_WHEN_request_size_less_than_max_batch_size_THEN_return_false() { long validRequestSize = ((thresholdConfig.getMaxRequestSizeBytes() - 1) - ((ThresholdConfig.DEFAULT_BATCH_SIZE - 1) * CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); boolean thresholdMetRequestSize = cloudWatchLogsLimits.isEqualToLimitReached(validRequestSize, ThresholdConfig.DEFAULT_BATCH_SIZE - 1); "<AssertPlaceHolder>"; }
isEqualToLimitReached(final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isEqualBatchSize(batchSize) || isEqualMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertFalse(thresholdMetRequestSize)
[-] pred: org. junit. Assert. assertFalse ( thresholdMetRequestSize )
************************************
************************************
[+] input: GIVEN_equal_to_limit_method_WHEN_batch_size_equal_to_max_batch_size_THEN_return_true() { long validRequestSize = ((thresholdConfig.getMaxRequestSizeBytes() - 1) - ((ThresholdConfig.DEFAULT_BATCH_SIZE - 1) * CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); boolean thresholdMetBatchSize = cloudWatchLogsLimits.isEqualToLimitReached(thresholdConfig.getMaxRequestSizeBytes(), ThresholdConfig.DEFAULT_BATCH_SIZE); "<AssertPlaceHolder>"; }
isEqualToLimitReached(final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isEqualBatchSize(batchSize) || isEqualMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertTrue(thresholdMetBatchSize)
[-] pred: org. junit. Assert. assertTrue ( thresholdMetBatchSize )
************************************
************************************
[+] input: GIVEN_equal_to_limit_method_WHEN_batch_size_greater_than_max_batch_size_THEN_return_false() { long validRequestSize = ((thresholdConfig.getMaxRequestSizeBytes() - 1) - ((ThresholdConfig.DEFAULT_BATCH_SIZE - 1) * CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); boolean thresholdMetBatchSize = cloudWatchLogsLimits.isEqualToLimitReached(validRequestSize, ThresholdConfig.DEFAULT_BATCH_SIZE + 1); "<AssertPlaceHolder>"; }
isEqualToLimitReached(final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isEqualBatchSize(batchSize) || isEqualMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertFalse(thresholdMetBatchSize)
[-] pred: org. junit. Assert. assertFalse ( thresholdMetBatchSize )
************************************
************************************
[+] input: GIVEN_equal_to_limit_method_WHEN_batch_size_less_than_max_batch_size_THEN_return_false() { long validRequestSize = ((thresholdConfig.getMaxRequestSizeBytes() - 1) - ((ThresholdConfig.DEFAULT_BATCH_SIZE - 1) * CloudWatchLogsLimits.APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); boolean thresholdMetBatchSize = cloudWatchLogsLimits.isEqualToLimitReached(validRequestSize, ThresholdConfig.DEFAULT_BATCH_SIZE - 1); "<AssertPlaceHolder>"; }
isEqualToLimitReached(final long currentRequestSize, final int batchSize) { long bufferSizeWithOverhead = (currentRequestSize + ((long) (batchSize) * APPROXIMATE_LOG_EVENT_OVERHEAD_SIZE)); return (isEqualBatchSize(batchSize) || isEqualMaxRequestSize(bufferSizeWithOverhead)); }
[*] target: assertFalse(thresholdMetBatchSize)
[-] pred: org. junit. Assert. assertFalse ( thresholdMetBatchSize )
************************************
************************************
[+] input: IOException { final String inputString = "a".repeat(100); final byte[] inputBytes = inputString.getBytes(StandardCharsets.UTF_8);  outputStream.write(inputBytes); outputStream.close();  String actualContent = Files.readString(testDataFile.toPath());  "<AssertPlaceHolder>"; }
close() throws IOException { if (!this.closed) { fileStream.close(); this.closed = true; } }
[*] target: assertEquals(inputString, actualContent)
[-] pred: org. junit. Assert. assertEquals ( inputString, actualContent )
************************************
************************************
[+] input: IOException { int data = 123;  outputStream.write(data);  outputStream.close();  final String stringContent = Files.readString(testDataFile.toPath()); final byte[] bytesContent = stringContent.getBytes(StandardCharsets.UTF_8); int actualContent = bytesContent[0] & 0xFF;   "<AssertPlaceHolder>"; }
close() throws IOException { if (!this.closed) { fileStream.close(); this.closed = true; } }
[*] target: assertEquals(data, actualContent)
[-] pred: org. junit. Assert. assertEquals ( data, actualContent )
************************************
************************************
[+] input: IOException { final String inputString = "a".repeat(100); final byte[] inputBytes = inputString.getBytes(StandardCharsets.UTF_8);  try (PositionOutputStream outputStream = localOutputFile.create(8192L)) { outputStream.write(inputBytes); }  final String actualContent = Files.readString(testDataFile.toPath());  "<AssertPlaceHolder>"; }
create(long blockSizeHint) throws IOException { try { return LocalFilePositionOutputStream.create(file); } catch (FileNotFoundException e) { throw new IOException("Failed to create file: " + file.toString(), e); } }
[*] target: assertEquals(inputString, actualContent)
[-] pred: org. junit. Assert. assertEquals ( inputString, actualContent )
************************************
************************************
[+] input: test_normal_field_failure_without_delimiters() { Dissector dissector = createObjectUnderTest("dm1 %{field1} %{field2} dm2");  boolean result = dissector.dissectText("dm1 foo bar"); "<AssertPlaceHolder>"; }
dissectText(String text){ try { if (!setDelimiterIndexes(text)) { return false; } Field head = fieldsList.getFirst(); for (final Delimiter delimiter : delimiterList) { int fieldStart = 0; int fieldEnd = delimiter.getStart(); if (delimiter.getPrev() == null && delimiter.getStart() == 0) { continue; } if (delimiter.getPrev() != null || delimiter.getStart() == 0) { fieldStart = delimiter.getPrev().getEnd() + 1; } head.setValue(text.substring(fieldStart, fieldEnd)); head = head.getNext(); } if (delimiterList.getLast().getEnd() != text.length() - 1) { int fieldStart = delimiterList.getLast().getEnd() + 1; int fieldEnd = text.length(); head.setValue(text.substring(fieldStart, fieldEnd)); } return true; } catch (Exception e) { return false; } }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: test_with_valid_endpoint_should_download_file() { when(maxMindDatabaseConfig.getDatabasePaths()).thenReturn(Map.of("geolite2-city", path)); final ManifestDownloadService objectUnderTest = createObjectUnderTest(); objectUnderTest.initiateDownload();  final File file = new File(OUTPUT_DIR + File.separator + "geolite2-city.mmdb"); "<AssertPlaceHolder>";  file.deleteOnExit(); final File directory = new File(OUTPUT_DIR); directory.deleteOnExit(); }
initiateDownload() { final Set<String> databasePaths = maxMindDatabaseConfig.getDatabasePaths().keySet(); for (final String key: databasePaths) { final Manifest manifest = deserializeManifestFile(maxMindDatabaseConfig.getDatabasePaths().get(key));  final String manifestFilePath = manifest.getDbName(); final String zipFileName = manifestFilePath.substring(0, manifestFilePath.lastIndexOf(".")).concat(ZIP_FILE_EXTENSION); final String zipFilePath = directoryName + File.separator + zipFileName;  downloadZipFile(manifest.getUrl(), zipFilePath); unzipDownloadedFile(zipFilePath, directoryName, key + MAXMIND_DATABASE_EXTENSION); } }
[*] target: assertTrue(file.exists())
[-] pred: org. junit. Assert. assertTrue ( file. exists ( ) )
************************************
************************************
[+] input: isReadyForShutdownTest() { GeoIPProcessor geoIPProcessor = createObjectUnderTest(); "<AssertPlaceHolder>"; }
isReadyForShutdown() { geoIPProcessorService.shutdown(); return true; }
[*] target: assertTrue(geoIPProcessor.isReadyForShutdown())
[-] pred: org. junit. Assert. assertTrue ( geoIPProcessor. isReadyForShutdown ( ) )
************************************
************************************
[+] input: JsonProcessingException {  final String SINK_YAML = "        url: "https://eihycslfo6g2hwrrytyckjkkok.lambda-url.us-east-2.on.aws/"\n"; final HttpSinkConfiguration httpSinkConfiguration = objectMapper.readValue(SINK_YAML, HttpSinkConfiguration.class);  "<AssertPlaceHolder>"; }
isValidAWSUrl() { URL parsedUrl = HttpSinkUtil.getURLByUrlString(url); if(parsedUrl.getProtocol().equals(HTTPS) && (parsedUrl.getHost().contains(AWS_HOST_AMAZONAWS_COM) ||parsedUrl.getHost().contains(AWS_HOST_API_AWS) || parsedUrl.getHost().contains(AWS_HOST_ON_AWS))){ return true; } return false; }
[*] target: assertTrue(httpSinkConfiguration.isValidAWSUrl())
[-] pred: org. junit. Assert. assertTrue ( httpSinkConfiguration. isValidAWSUrl ( ) )
************************************
************************************
[+] input: serialize_WithEmptyRecord_ReturnsEmptyJson() { // Test for serializing an empty record GenericRecord record = new GenericData.Record(SCHEMA); String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: serialize_WithNestedRecord_ReturnsCorrectJson() { // Test for serializing a nested record Schema schema = new Schema.Parser().parse( "{" + "  "type": "record"," + "  "name": "ParentRecord"," + "  "fields": [" + "    {" + "      "name": "child"," + "      "type": {" + "        "type": "record"," + "        "name": "ChildRecord"," + "        "fields": [" + "          {"name": "name", "type": "string"}" + "        ]" + "      }" + "    }" + "  ]" + "}" ); GenericRecord childRecord = new GenericData.Record(schema.getField("child").schema()); childRecord.put("name", "John Doe"); GenericRecord parentRecord = new GenericData.Record(schema); parentRecord.put("child", childRecord);  String expectedJson = "{"child": {"name": "John Doe"}}";  String json = encoder.serialize(parentRecord);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: serialize_WithCircularReference_ReturnsErrorMessage() { // Test for circular reference handling GenericRecord record1 = new GenericData.Record(SCHEMA); record1.put("nested", record1);  String expectedErrorMessage = "{"nested":  ">>> CIRCULAR REFERENCE CANNOT BE PUT IN JSON STRING, ABORTING RECURSION <<<" , "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record1);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedErrorMessage, json)
[-] pred: org. junit. Assert. assertEquals ( expectedErrorMessage, json )
************************************
************************************
[+] input: serialize_WithArray_ReturnsCorrectJson() { // Test for serializing an array GenericRecord record = new GenericData.Record(SCHEMA); record.put("alternateIds", new GenericData.Array<>(SCHEMA.getField("alternateIds").schema(), java.util.Arrays.asList("one", "two", "three")));  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": ["one", "two", "three"], "metadata": null, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: serialize_WithMap_ReturnsCorrectJson() { // Test for serializing a map GenericRecord record = new GenericData.Record(SCHEMA); Map<String, String> map = new HashMap<>(); map.put("one", "valueOne"); map.put("two", "valueTwo"); map.put("three", "valueThree"); record.put("metadata", map);  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": {"one": "valueOne", "two": "valueTwo", "three": "valueThree"}, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: serialize_WithEnum_ReturnsCorrectJson() { // Test for serializing an enum GenericRecord record = new GenericData.Record(SCHEMA); record.put("suit", new GenericData.EnumSymbol(SCHEMA.getField("suit").schema(), "SPADES"));  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": null, "suit": "SPADES"}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: serialize_WithNullValue_ReturnsCorrectJson() { // Test for serializing null value GenericRecord record = new GenericData.Record(SCHEMA); record.put("nested", null);  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: serialize_WithBytesValue_ReturnsCorrectJson() { // Test for serializing bytes value GenericRecord record = new GenericData.Record(SCHEMA); record.put("rawData", ByteBuffer.wrap(new byte[]{1, 2, 3}));  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": {"bytes": "\\u0001\\u0002\\u0003"}, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: serialize_WithFloatNaNValue_ReturnsQuotedJson() { // Test for serializing float NaN value GenericRecord record = new GenericData.Record(SCHEMA); record.put("floatValue", Float.NaN);  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": "NaN", "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: serialize_WithFloatInfinityValue_ReturnsQuotedJson() { // Test for serializing float Infinity value GenericRecord record = new GenericData.Record(SCHEMA); record.put("floatValue", Float.POSITIVE_INFINITY);  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": "Infinity", "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: serialize_WithBytesContainingSpecialCharacters_ReturnsEscapedJson() { // Test for serializing bytes with special characters GenericRecord record = new GenericData.Record(SCHEMA); record.put("rawData", ByteBuffer.wrap(new byte[]{34, 92, 13, 10, 9}));  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": null, "rawData": {"bytes": "\\"\\\\\\r\\n\\t"}, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: registerLogicalTypeConverter_WithLogicalType_ConvertsValueUsingConverter() { GenericRecord record = new GenericData.Record(SCHEMA); record.put("lastUpdated", Instant.ofEpochMilli(1685483879));  String expectedJson = "{"nested": null, "id": null, "value": null, "floatValue": null, "alternateIds": null, "metadata": null, "lastUpdated": 1970-01-20T12:11:23.879Z, "rawData": null, "suit": null}";  String json = encoder.serialize(record);  "<AssertPlaceHolder>"; }
serialize(GenericRecord value) { StringBuilder buffer = new StringBuilder(); serialize(value, buffer, new IdentityHashMap<>(128) ); String result = buffer.toString(); return result; }
[*] target: assertEquals(expectedJson, json)
[-] pred: org. junit. Assert. assertEquals ( expectedJson, json )
************************************
************************************
[+] input: isValidDatasetArn_returns_true_for_valid_dataset_arn() { final String datasetArn = "arn:aws:personalize::123456789012:dataset/test"; final Map<String, Object> jsonMap = Map.of("dataset_arn", datasetArn); final PersonalizeSinkConfiguration objectUnderTest = objectMapper.convertValue(jsonMap, PersonalizeSinkConfiguration.class); "<AssertPlaceHolder>"; }
isValidDatasetArn() { if (datasetArn == null) { return true; } final Arn arn = getArn(); boolean status = true; if (!AWS_PERSONALIZE.equals(arn.service())) { status = false; } final Optional<String> resourceType = arn.resource().resourceType(); if (resourceType.isEmpty() || !resourceType.get().equals(AWS_PERSONALIZE_DATASET)) { status = false; } return status; }
[*] target: assertTrue(objectUnderTest.isValidDatasetArn())
[-] pred: org. junit. Assert. assertTrue ( objectUnderTest. isValidDatasetArn ( ) )
************************************
************************************
[+] input: isValidDatasetArn_returns_false_when_arn_service_is_not_personalize() { final String datasetArn = "arn:aws:iam::123456789012:dataset/test"; final Map<String, Object> jsonMap = Map.of("dataset_arn", datasetArn); final PersonalizeSinkConfiguration objectUnderTest = objectMapper.convertValue(jsonMap, PersonalizeSinkConfiguration.class); "<AssertPlaceHolder>"; }
isValidDatasetArn() { if (datasetArn == null) { return true; } final Arn arn = getArn(); boolean status = true; if (!AWS_PERSONALIZE.equals(arn.service())) { status = false; } final Optional<String> resourceType = arn.resource().resourceType(); if (resourceType.isEmpty() || !resourceType.get().equals(AWS_PERSONALIZE_DATASET)) { status = false; } return status; }
[*] target: assertFalse(objectUnderTest.isValidDatasetArn())
[-] pred: org. junit. Assert. assertFalse ( objectUnderTest. isValidDatasetArn() )
************************************
************************************
[+] input: isValidDatasetArn_returns_false_when_arn_resource_is_not_dataset() { final String datasetArn = "arn:aws:personalize::123456789012:role/test"; final Map<String, Object> jsonMap = Map.of("dataset_arn", datasetArn); final PersonalizeSinkConfiguration objectUnderTest = objectMapper.convertValue(jsonMap, PersonalizeSinkConfiguration.class); "<AssertPlaceHolder>"; }
isValidDatasetArn() { if (datasetArn == null) { return true; } final Arn arn = getArn(); boolean status = true; if (!AWS_PERSONALIZE.equals(arn.service())) { status = false; } final Optional<String> resourceType = arn.resource().resourceType(); if (resourceType.isEmpty() || !resourceType.get().equals(AWS_PERSONALIZE_DATASET)) { status = false; } return status; }
[*] target: assertFalse(objectUnderTest.isValidDatasetArn())
[-] pred: org. junit. Assert. assertFalse ( objectUnderTest. isValidDatasetArn() )
************************************
************************************
[+] input: IOException { InputStream inputStream = new ByteArrayInputStream("Test data".getBytes()); when(s3Client.getObject(any(GetObjectRequest.class), any(ResponseTransformer.class))).thenReturn(inputStream); final S3InputStream s3InputStream = createObjectUnderTest(); createObjectUnderTest().seek(0);  int availableBytes = s3InputStream.available(); "<AssertPlaceHolder>"; }
available() throws IOException { Preconditions.checkState(!closed, "Cannot read: already closed"); positionStream();  return stream.available(); }
[*] target: assertEquals(9, availableBytes)
[-] pred: org. junit. Assert. assertEquals ( 9, availableBytes )
************************************
************************************
[+] input: testAddToAcknowledgementSetFromOriginEvent() { Map<String, Object> data = Map.of("k1","v1"); EventMetadata eventMetadata = mock(EventMetadata.class); Event originRecordEvent = JacksonEvent.builder() .withEventMetadata(eventMetadata) .withEventType("event") .withData(data) .build(); Event spyEvent = spy(originRecordEvent);  DefaultEventHandle mockEventHandle = mock(DefaultEventHandle.class); when(spyEvent.getEventHandle()).thenReturn(mockEventHandle);  Record record = splitEventProcessor .createNewRecordFromEvent(spyEvent, "v1");  Event recordEvent = (Event) record.getData(); splitEventProcessor.addToAcknowledgementSetFromOriginEvent(recordEvent, spyEvent);  DefaultEventHandle spyEventHandle = (DefaultEventHandle) spyEvent.getEventHandle(); // Verify that the add method is called on the acknowledgement set verify(spyEventHandle).getAcknowledgementSet();  AcknowledgementSet spyAckSet = spyEventHandle.getAcknowledgementSet(); DefaultEventHandle eventHandle = (DefaultEventHandle) recordEvent.getEventHandle(); AcknowledgementSet ackSet1 = eventHandle.getAcknowledgementSet();  "<AssertPlaceHolder>"; }
addToAcknowledgementSetFromOriginEvent(Event recordEvent, Event originRecordEvent) { DefaultEventHandle eventHandle = (DefaultEventHandle) originRecordEvent.getEventHandle(); if (eventHandle != null && eventHandle.getAcknowledgementSet() != null) { eventHandle.getAcknowledgementSet().add(recordEvent); } }
[*] target: assertEquals(spyAckSet, ackSet1)
[-] pred: org. junit. Assert. assertEquals ( spyAckSet, ackSet1 )
************************************
************************************
[+] input: create() { DatabaseTypeCreateRequest request = new DatabaseTypeCreateRequest(); request.setDatabaseType("ut-mysql"); request.setIcon(""); request.setDescription("integration test"); request.setJdbcDriverFileUrl("some url"); request.setJdbcDriverClassName("com.mysql.jdbc.Driver"); request.setJdbcProtocol("jdbc:mysql"); request.setUrlPattern("{{jdbc.protocol}}//{{db.url}}/{{db.schema}}"); Integer id = databaseTypeService.create(request); Assertions."<AssertPlaceHolder>"; }
create(DatabaseTypeCreateRequest request) { databaseTypeUpdateValidator.validRequestRequiredParams(request); String databaseType = request.getDatabaseType(); if (databaseTypeDao.existsByDatabaseType(databaseType)) { throw DomainErrors.DATABASE_TYPE_NAME_DUPLICATE.exception(); } DriverResult result = loadAndValidate(request.getJdbcDriverFileUrl(), request.getJdbcDriverFilePath(), request.getJdbcDriverClassName()); String targetPath = driverResources.copyToStandardDirectory(result.getDriverFile(), databaseType); DatabaseType pojo = databaseTypeConverter.of(request, targetPath); // TODO workaround pojo.setJdbcDriverFileUrl(StringUtils.defaultIfBlank(request.getJdbcDriverFileUrl(), "")); try { return databaseTypeDao.insertAndReturnId(pojo); } catch (DuplicateKeyException e) { throw DomainErrors.DATABASE_TYPE_NAME_DUPLICATE.exception(); } }
[*] target: assertNotNull(id)
[-] pred: org. junit. Assert. assertNotNull ( id )
************************************
************************************
[+] input: testApplySimpleObject() { SimpleObject that = SimpleObject.builder() .id(1) .height(180L) .name("test") .build();  SimpleObject other = SimpleObject.builder() .id(1) .height(180L) .name("test") .build();  BaseTypeFieldEqualFunction equalFunction = new BaseTypeFieldEqualFunction(List.of()); final Boolean result = equalFunction.apply(that, other); "<AssertPlaceHolder>"; }
apply(Object that, Object other) { if (Objects.equals(that, other)) { return true; } if (that == null || other == null) { return false; } try { BeanInfo thatBean = Introspector.getBeanInfo(that.getClass()); BeanInfo otherBean = Introspector.getBeanInfo(other.getClass()); Map<String, PropertyDescriptor> otherBeanPropertyMap = Arrays.stream(otherBean.getPropertyDescriptors()) .collect(Collectors.toMap(PropertyDescriptor::getName, p -> p)); for (PropertyDescriptor thatProperty : thatBean.getPropertyDescriptors()) { if (thatProperty.getReadMethod() == null || thatProperty.getWriteMethod() == null) { continue; } if (ignoreFields.contains(thatProperty.getName())) { continue; } if (!otherBeanPropertyMap.containsKey(thatProperty.getName())) { return false; } if (Collection.class.isAssignableFrom(thatProperty.getPropertyType())) { Collection thatValue = (Collection) thatProperty.getReadMethod().invoke(that); Collection otherValue = (Collection) otherBeanPropertyMap.get(thatProperty.getName()) .getReadMethod().invoke(other); return handleCollection(thatValue, otherValue); } if (!thatProperty.getPropertyType().isPrimitive()) { Object thatValue = thatProperty.getReadMethod().invoke(that); Object otherValue = otherBeanPropertyMap.get(thatProperty.getName()).getReadMethod().invoke(other); if (!apply(thatValue, otherValue)) { return false; } } Object thatValue = thatProperty.getReadMethod().invoke(that); Object otherValue = otherBeanPropertyMap.get(thatProperty.getName()).getReadMethod().invoke(other); if (!Objects.equals(thatValue, otherValue)) { return false; } } } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) { log.error("Error comparing objects", e); throw new RuntimeException(e); } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testApplyComplexObject() { SimpleObject thatItem = SimpleObject.builder() .id(1) .height(180L) .name("test") .build(); ComplexObject thatObj = new ComplexObject(); thatObj.setId(1); thatObj.setName("eq"); thatObj.setItems(List.of(thatItem));  SimpleObject otherItem = SimpleObject.builder() .id(1) .height(180L) .name("test") .build(); ComplexObject otherObj = new ComplexObject(); otherObj.setId(1); otherObj.setName("eq"); otherObj.setItems(List.of(otherItem));  BaseTypeFieldEqualFunction equalFunction = new BaseTypeFieldEqualFunction(List.of()); final Boolean result = equalFunction.apply(thatObj, otherObj); "<AssertPlaceHolder>"; }
apply(Object that, Object other) { if (Objects.equals(that, other)) { return true; } if (that == null || other == null) { return false; } try { BeanInfo thatBean = Introspector.getBeanInfo(that.getClass()); BeanInfo otherBean = Introspector.getBeanInfo(other.getClass()); Map<String, PropertyDescriptor> otherBeanPropertyMap = Arrays.stream(otherBean.getPropertyDescriptors()) .collect(Collectors.toMap(PropertyDescriptor::getName, p -> p)); for (PropertyDescriptor thatProperty : thatBean.getPropertyDescriptors()) { if (thatProperty.getReadMethod() == null || thatProperty.getWriteMethod() == null) { continue; } if (ignoreFields.contains(thatProperty.getName())) { continue; } if (!otherBeanPropertyMap.containsKey(thatProperty.getName())) { return false; } if (Collection.class.isAssignableFrom(thatProperty.getPropertyType())) { Collection thatValue = (Collection) thatProperty.getReadMethod().invoke(that); Collection otherValue = (Collection) otherBeanPropertyMap.get(thatProperty.getName()) .getReadMethod().invoke(other); return handleCollection(thatValue, otherValue); } if (!thatProperty.getPropertyType().isPrimitive()) { Object thatValue = thatProperty.getReadMethod().invoke(that); Object otherValue = otherBeanPropertyMap.get(thatProperty.getName()).getReadMethod().invoke(other); if (!apply(thatValue, otherValue)) { return false; } } Object thatValue = thatProperty.getReadMethod().invoke(that); Object otherValue = otherBeanPropertyMap.get(thatProperty.getName()).getReadMethod().invoke(other); if (!Objects.equals(thatValue, otherValue)) { return false; } } } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) { log.error("Error comparing objects", e); throw new RuntimeException(e); } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testApplyComplexObject2() { SimpleObject thatItem = SimpleObject.builder() .id(1) .height(180L) .name("test") .build(); ComplexObject thatObj = new ComplexObject(); thatObj.setId(1); thatObj.setName("eq"); thatObj.setItems(List.of(thatItem));  ComplexObject otherObj = new ComplexObject(); otherObj.setId(1); otherObj.setName("eq"); otherObj.setItems(List.of());  BaseTypeFieldEqualFunction equalFunction = new BaseTypeFieldEqualFunction(List.of()); final Boolean result = equalFunction.apply(thatObj, otherObj); "<AssertPlaceHolder>"; }
apply(Object that, Object other) { if (Objects.equals(that, other)) { return true; } if (that == null || other == null) { return false; } try { BeanInfo thatBean = Introspector.getBeanInfo(that.getClass()); BeanInfo otherBean = Introspector.getBeanInfo(other.getClass()); Map<String, PropertyDescriptor> otherBeanPropertyMap = Arrays.stream(otherBean.getPropertyDescriptors()) .collect(Collectors.toMap(PropertyDescriptor::getName, p -> p)); for (PropertyDescriptor thatProperty : thatBean.getPropertyDescriptors()) { if (thatProperty.getReadMethod() == null || thatProperty.getWriteMethod() == null) { continue; } if (ignoreFields.contains(thatProperty.getName())) { continue; } if (!otherBeanPropertyMap.containsKey(thatProperty.getName())) { return false; } if (Collection.class.isAssignableFrom(thatProperty.getPropertyType())) { Collection thatValue = (Collection) thatProperty.getReadMethod().invoke(that); Collection otherValue = (Collection) otherBeanPropertyMap.get(thatProperty.getName()) .getReadMethod().invoke(other); return handleCollection(thatValue, otherValue); } if (!thatProperty.getPropertyType().isPrimitive()) { Object thatValue = thatProperty.getReadMethod().invoke(that); Object otherValue = otherBeanPropertyMap.get(thatProperty.getName()).getReadMethod().invoke(other); if (!apply(thatValue, otherValue)) { return false; } } Object thatValue = thatProperty.getReadMethod().invoke(that); Object otherValue = otherBeanPropertyMap.get(thatProperty.getName()).getReadMethod().invoke(other); if (!Objects.equals(thatValue, otherValue)) { return false; } } } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) { log.error("Error comparing objects", e); throw new RuntimeException(e); } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: save() { var request = OperationLogRequest.builder() .operatorUserId(-1000) .operatorUsername("ut") .operatorNickname("ut") .operationModule("system") .operationCode("updateEmail") .operationName("更新邮箱") .operationResponse(JsonData.ok()) .isSuccess(true) .involvedProjectId(null) .involvedGroupId(null) .involvedUserId(null) .build(); Long id = operationLogService.save(request); Assertions."<AssertPlaceHolder>"; }
save(OperationLogRequest request) { OperationLog pojo = operationLogRequestConverter.toPojo(request); return operationLogDao.insertAndReturnId(pojo); }
[*] target: assertNotNull(id)
[-] pred: org. junit. Assert. assertNotNull ( id )
************************************
************************************
[+] input: create() { doNothing().when(userEventSubscriber).onUserCreated(any());  String username = UUID.randomUUID().toString().replace("-", ""); UserCreateRequest request = new UserCreateRequest(); request.setAvatar(username); request.setUsername(username); request.setNickname(username); request.setEmail(username + "@Databasir-ut.com"); request.setPassword("123456"); request.setEnabled(true); Integer id = userService.create(request, UserSource.MANUAL); "<AssertPlaceHolder>"; verify(userEventSubscriber, times(1)).onUserCreated(any()); }
create(UserCreateRequest userCreateRequest, String source) { userDao.selectByEmailOrUsername(userCreateRequest.getUsername()).ifPresent(data -> { throw DomainErrors.USERNAME_OR_EMAIL_DUPLICATE.exception(); }); String hashedPassword = bCryptPasswordEncoder.encode(userCreateRequest.getPassword()); User pojo = userConverter.of(userCreateRequest, hashedPassword); try { Integer id = userDao.insertAndReturnId(pojo); // publish event UserCreated event = userEventConverter.userCreated(pojo, source, userCreateRequest.getPassword(), id); eventPublisher.publish(event); return id; } catch (DuplicateKeyException e) { throw DomainErrors.USERNAME_OR_EMAIL_DUPLICATE.exception(); } }
[*] target: assertNotNull(id)
[-] pred: org. junit. Assert. assertNotNull ( id )
************************************
************************************
[+] input: isDatasetNameUnique_whenDatasetNameIsNotUnique_returnTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // Given Dataset testDataset = DatasetUtils.createTestDataset(DATASET_ID);  //When when(datasetRepositoryMock.findByName(anyString())).thenReturn(java.util.Optional.empty());  boolean actual = datasetService.isDatasetNameUnique(DATASET_NAME);  //Then Assertions."<AssertPlaceHolder>"; verify(datasetRepositoryMock).findByName(anyString()); verify(datasetRepositoryMock, times(1)).findByName(anyString()); }
isDatasetNameUnique(String datasetName) { return datasetRepository .findByName(datasetName).isEmpty(); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: isDatasetNameUniqueAndDeletedFalse_whenDatasetNameIsNotUnique_returnTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // Given Dataset testDataset = DatasetUtils.createTestDataset(DATASET_ID);  //When when(datasetRepositoryMock.findByNameAndDeletedFalseAndOwner(anyString(), anyString())).thenReturn(java.util.Optional.empty());  boolean actual = datasetService.isDatasetNameUniqueAndDeletedFalse(DATASET_NAME, "eforce");  //Then Assertions."<AssertPlaceHolder>"; verify(datasetRepositoryMock).findByNameAndDeletedFalseAndOwner(anyString(), anyString()); verify(datasetRepositoryMock, times(1)).findByNameAndDeletedFalseAndOwner(anyString(), anyString()); }
isDatasetNameUniqueAndDeletedFalse(String datasetName, String owner) { return datasetRepository .findByNameAndDeletedFalseAndOwner(datasetName, owner).isEmpty(); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: getAllImages_WhenZeroImages_returnEmptyList() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  //Given Dataset testDataset = DatasetUtils.createTestDataset(DATASET_ID);  //When when(datasetRepositoryMock.findById(anyString())).thenReturn(java.util.Optional.of(testDataset)); when(datasetRepositoryMock.getAllMediasByDatasetId(DATASET_ID)).thenReturn(new ArrayList<>()); List<MediaViewModel> allImages = datasetService.getAllMedia(DATASET_ID);  //Then "<AssertPlaceHolder>";  verify(datasetRepositoryMock).getAllMediasByDatasetId(anyString()); verify(datasetRepositoryMock, times(1)).getAllMediasByDatasetId(anyString()); }
getAllMedia(String datasetId) { Dataset datasetById = getDatasetById(datasetId);  //Permissions check String owner = datasetById.getOwner(); DataGymSecurity.isAdminOrUser(owner, false);  List<Media> allMediaByDatasetId = datasetRepository.getAllMediasByDatasetId(datasetId);  return MediaMapper.mapToMediaViewModel(allMediaByDatasetId); }
[*] target: assertTrue(allImages.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( allImages. isEmpty ( ) )
************************************
************************************
[+] input: getAllDatasetsFromOrganisationAndLoggedInUserIsAdmin_WhenNoProjects_returnEmptyList() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  //When when(datasetRepositoryMock.findAllByDeletedIsFalseAndOwner("datagym")).thenReturn(new ArrayList<>()); List<DatasetViewModel> allDatasets = datasetService.getAllDatasetsFromOrganisationAndLoggedInUserIsAdmin();  //Then "<AssertPlaceHolder>";  verify(datasetRepositoryMock).findAllByDeletedIsFalseAndOwner("eforce21"); verify(datasetRepositoryMock, times(1)).findAllByDeletedIsFalseAndOwner("eforce21"); }
getAllDatasetsFromOrganisationAndLoggedInUserIsAdmin() { //Permissions check DataGymSecurity.isAuthenticated();  OauthUser user = SecurityContext.get(); Map<String, String> orgs = user.orgs();  List<DatasetViewModel> result = new ArrayList<>();  for (Map.Entry<String, String> orgsEntry : orgs.entrySet()) { String currentUserOrg = orgsEntry.getKey();  boolean isAdminInCurrentOrg = DataGymSecurity.checkIfUserIsAdmin(currentUserOrg, false);  if (isAdminInCurrentOrg) { List<DatasetViewModel> currentOrgDatasetViewModels = datasetRepository .findAllByDeletedIsFalseAndOwner(currentUserOrg) .stream() .map(dataset -> DatasetMapper.mapToDatasetViewModel(dataset, true)) .collect(Collectors.toList());  result.addAll(currentOrgDatasetViewModels); } }  return result; }
[*] target: assertTrue(allDatasets.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( allDatasets. isEmpty ( ) )
************************************
************************************
[+] input: IOException { SecurityContext.clear();  String taskId = "not used here"; String lcEntryKey = "not used here"; String expectedErrorMessage = "Forbidden."; final HttpServletResponse response = Mockito.mock(HttpServletResponse.class);  try { underTest.streamSegmentationBitmap(taskId, lcEntryKey, response); fail("ForbiddenException should be thrown."); } catch (ForbiddenException e) { "<AssertPlaceHolder>"; } }
streamSegmentationBitmap(String taskId, String lcEntryKey, HttpServletResponse response) throws IOException {  // Permission check: authenticated user DataGymSecurity.isAuthenticatedAndHasAnyScope(TOKEN_SCOPE_TYPE, OAUTH_SCOPE_TYPE, SUPER_ADMIN_SCOPE_TYPE);  List<LabelTaskState> labelTaskStateList = new ArrayList<>(); labelTaskStateList.add(LabelTaskState.COMPLETED); labelTaskStateList.add(LabelTaskState.SKIPPED); labelTaskStateList.add(LabelTaskState.REVIEWED);  LabelTask labelTask =  labelTaskRepository .findById(taskId) .orElseThrow(() -> new NotFoundException(LABEL_TASK_PLACEHOLDER, "id", "" + taskId));  if (!labelTaskStateList.contains(labelTask.getLabelTaskState())) { // The task is not in allowed / supported state. throw new GenericException(WRONG_LABEL_TASK_STATE, null, null, labelTask.getId()); }  // Permission check: is the user admin or user of the project. Project project = labelTask.getProject(); String owner = project.getOwner(); DataGymSecurity.isAdminOrUser(owner, true);  /* * Check if a LcEntry with the given export key exists within the documentation. */ Optional<LcEntry> optionalLcEntry = project.getLabelConfiguration().getEntries().stream() .filter(entry -> URLDecoder.decode(entry.getEntryKey(), StandardCharsets.UTF_8).equals(lcEntryKey)) .findFirst();  if (optionalLcEntry.isEmpty()) { // no entry with the given key is defined. throw new NotFoundException(LC_ENTRY_PLACEHOLDER, "entry_key", lcEntryKey); }  Media taskMedia = labelTask.getMedia(); if (taskMedia.isDeleted()) { throw new NotFoundException(IMAGE_PLACEHOLDER, "id", taskMedia.getId()); }  List<LcEntryValue> values = lcEntryValueRepository .findAllByTaskIdAndEntryKeyAndEntryType(taskId, lcEntryKey, LcEntryType.IMAGE_SEGMENTATION);  List<List<PointCollection>> pointCollections = values.stream() .filter(value -> value instanceof LcEntryImageSegmentationValue) .map(value -> ((LcEntryImageSegmentationValue) value).getPointsCollection()) .collect(Collectors.toList());  ImageSize image = (new ImageSizeReader(tika)).getSize(taskMedia); int height = image.getHeight(); int width = image.getWidth();  BufferedImage img = (new SegmentationBitmap(height, width)).addSegmentations(pointCollections).apply().asBufferedImage();  // Stream the Image String mimeType = "image/bmp"; String formatName = mimeType.split("/")[1].toLowerCase(Locale.ENGLISH);  // Stream the Image response.setHeader("Content-Type", mimeType); ImageIO.write(img, formatName, response.getOutputStream()); }
[*] target: assertEquals(expectedErrorMessage, e.getMessage())
[-] pred: org. junit. Assert. assertEquals ( expectedErrorMessage, e. getMessage ( ) )
************************************
************************************
[+] input: IOException { // Given String taskId = "not-existing"; String lcEntryKey = "not used here"; String expectedErrorMessage = "Item task with id not-existing not found."; HttpServletResponse response = Mockito.mock(HttpServletResponse.class);  // When try { underTest.streamSegmentationBitmap(taskId, lcEntryKey, response); // Then fail("NotFoundException should be thrown."); } catch (NotFoundException e) { "<AssertPlaceHolder>"; } }
streamSegmentationBitmap(String taskId, String lcEntryKey, HttpServletResponse response) throws IOException {  // Permission check: authenticated user DataGymSecurity.isAuthenticatedAndHasAnyScope(TOKEN_SCOPE_TYPE, OAUTH_SCOPE_TYPE, SUPER_ADMIN_SCOPE_TYPE);  List<LabelTaskState> labelTaskStateList = new ArrayList<>(); labelTaskStateList.add(LabelTaskState.COMPLETED); labelTaskStateList.add(LabelTaskState.SKIPPED); labelTaskStateList.add(LabelTaskState.REVIEWED);  LabelTask labelTask =  labelTaskRepository .findById(taskId) .orElseThrow(() -> new NotFoundException(LABEL_TASK_PLACEHOLDER, "id", "" + taskId));  if (!labelTaskStateList.contains(labelTask.getLabelTaskState())) { // The task is not in allowed / supported state. throw new GenericException(WRONG_LABEL_TASK_STATE, null, null, labelTask.getId()); }  // Permission check: is the user admin or user of the project. Project project = labelTask.getProject(); String owner = project.getOwner(); DataGymSecurity.isAdminOrUser(owner, true);  /* * Check if a LcEntry with the given export key exists within the documentation. */ Optional<LcEntry> optionalLcEntry = project.getLabelConfiguration().getEntries().stream() .filter(entry -> URLDecoder.decode(entry.getEntryKey(), StandardCharsets.UTF_8).equals(lcEntryKey)) .findFirst();  if (optionalLcEntry.isEmpty()) { // no entry with the given key is defined. throw new NotFoundException(LC_ENTRY_PLACEHOLDER, "entry_key", lcEntryKey); }  Media taskMedia = labelTask.getMedia(); if (taskMedia.isDeleted()) { throw new NotFoundException(IMAGE_PLACEHOLDER, "id", taskMedia.getId()); }  List<LcEntryValue> values = lcEntryValueRepository .findAllByTaskIdAndEntryKeyAndEntryType(taskId, lcEntryKey, LcEntryType.IMAGE_SEGMENTATION);  List<List<PointCollection>> pointCollections = values.stream() .filter(value -> value instanceof LcEntryImageSegmentationValue) .map(value -> ((LcEntryImageSegmentationValue) value).getPointsCollection()) .collect(Collectors.toList());  ImageSize image = (new ImageSizeReader(tika)).getSize(taskMedia); int height = image.getHeight(); int width = image.getWidth();  BufferedImage img = (new SegmentationBitmap(height, width)).addSegmentations(pointCollections).apply().asBufferedImage();  // Stream the Image String mimeType = "image/bmp"; String formatName = mimeType.split("/")[1].toLowerCase(Locale.ENGLISH);  // Stream the Image response.setHeader("Content-Type", mimeType); ImageIO.write(img, formatName, response.getOutputStream()); }
[*] target: assertEquals(expectedErrorMessage, e.getMessage())
[-] pred: org. junit. Assert. assertEquals ( expectedErrorMessage, e. getMessage ( ) )
************************************
************************************
[+] input: IOException { // Given final String taskId = "mocked task id"; final String lcEntryKey = "not-existing"; final String expectedErrorMessage = String.format("Item lcEntry with entry_key %s not found.", lcEntryKey); final HttpServletResponse response = Mockito.mock(HttpServletResponse.class); final LabelTask labelTask = Mockito.mock(LabelTask.class); final Project project = ProjectUtils.createTestProject(PROJECT_ID); project.setOwner(loggedInUserId);  // When Mockito.when(labelTaskRepositoryMock.findById(taskId)) .thenReturn(Optional.of(labelTask)); Mockito.when(labelTask.getProject()) .thenReturn(project); Mockito.when(labelTask.getLabelTaskState()) .thenReturn(LabelTaskState.COMPLETED);  try { underTest.streamSegmentationBitmap(taskId, lcEntryKey, response); fail("NotFoundException should be thrown."); } catch (NotFoundException e) { "<AssertPlaceHolder>"; } }
streamSegmentationBitmap(String taskId, String lcEntryKey, HttpServletResponse response) throws IOException {  // Permission check: authenticated user DataGymSecurity.isAuthenticatedAndHasAnyScope(TOKEN_SCOPE_TYPE, OAUTH_SCOPE_TYPE, SUPER_ADMIN_SCOPE_TYPE);  List<LabelTaskState> labelTaskStateList = new ArrayList<>(); labelTaskStateList.add(LabelTaskState.COMPLETED); labelTaskStateList.add(LabelTaskState.SKIPPED); labelTaskStateList.add(LabelTaskState.REVIEWED);  LabelTask labelTask =  labelTaskRepository .findById(taskId) .orElseThrow(() -> new NotFoundException(LABEL_TASK_PLACEHOLDER, "id", "" + taskId));  if (!labelTaskStateList.contains(labelTask.getLabelTaskState())) { // The task is not in allowed / supported state. throw new GenericException(WRONG_LABEL_TASK_STATE, null, null, labelTask.getId()); }  // Permission check: is the user admin or user of the project. Project project = labelTask.getProject(); String owner = project.getOwner(); DataGymSecurity.isAdminOrUser(owner, true);  /* * Check if a LcEntry with the given export key exists within the documentation. */ Optional<LcEntry> optionalLcEntry = project.getLabelConfiguration().getEntries().stream() .filter(entry -> URLDecoder.decode(entry.getEntryKey(), StandardCharsets.UTF_8).equals(lcEntryKey)) .findFirst();  if (optionalLcEntry.isEmpty()) { // no entry with the given key is defined. throw new NotFoundException(LC_ENTRY_PLACEHOLDER, "entry_key", lcEntryKey); }  Media taskMedia = labelTask.getMedia(); if (taskMedia.isDeleted()) { throw new NotFoundException(IMAGE_PLACEHOLDER, "id", taskMedia.getId()); }  List<LcEntryValue> values = lcEntryValueRepository .findAllByTaskIdAndEntryKeyAndEntryType(taskId, lcEntryKey, LcEntryType.IMAGE_SEGMENTATION);  List<List<PointCollection>> pointCollections = values.stream() .filter(value -> value instanceof LcEntryImageSegmentationValue) .map(value -> ((LcEntryImageSegmentationValue) value).getPointsCollection()) .collect(Collectors.toList());  ImageSize image = (new ImageSizeReader(tika)).getSize(taskMedia); int height = image.getHeight(); int width = image.getWidth();  BufferedImage img = (new SegmentationBitmap(height, width)).addSegmentations(pointCollections).apply().asBufferedImage();  // Stream the Image String mimeType = "image/bmp"; String formatName = mimeType.split("/")[1].toLowerCase(Locale.ENGLISH);  // Stream the Image response.setHeader("Content-Type", mimeType); ImageIO.write(img, formatName, response.getOutputStream()); }
[*] target: assertEquals(expectedErrorMessage, e.getMessage())
[-] pred: org. junit. Assert. assertEquals ( expectedErrorMessage, e. getMessage ( ) )
************************************
************************************
[+] input: IOException { // Given final String taskId = "mocked task id"; final String lcEntryKey = "existingEntryId"; final String deletedImageId = "deleted image"; final HttpServletResponse response = Mockito.mock(HttpServletResponse.class); final LabelTask labelTask = Mockito.mock(LabelTask.class); final Media media = Mockito.mock(Media.class); final String expectedErrorMessage = String.format("Item image with id %s not found.", deletedImageId); final LcEntry lcEntry = Mockito.mock(LcEntry.class); final Project project = ProjectUtils.createTestProject(PROJECT_ID); project.setOwner(loggedInUserId); project.getLabelConfiguration().setEntries(Set.of(lcEntry));  // When Mockito.when(labelTaskRepositoryMock.findById(taskId)).thenReturn(Optional.of(labelTask)); Mockito.when(labelTask.getProject()).thenReturn(project); Mockito.when(labelTask.getLabelTaskState()).thenReturn(LabelTaskState.COMPLETED); Mockito.when(labelTask.getMedia()).thenReturn(media); Mockito.when(lcEntry.getEntryKey()).thenReturn(lcEntryKey); Mockito.when(media.isDeleted()).thenReturn(true); Mockito.when(media.getId()).thenReturn(deletedImageId);  try { underTest.streamSegmentationBitmap(taskId, lcEntryKey, response); fail("NotFoundException should be thrown."); } catch (NotFoundException e) { "<AssertPlaceHolder>"; } }
streamSegmentationBitmap(String taskId, String lcEntryKey, HttpServletResponse response) throws IOException {  // Permission check: authenticated user DataGymSecurity.isAuthenticatedAndHasAnyScope(TOKEN_SCOPE_TYPE, OAUTH_SCOPE_TYPE, SUPER_ADMIN_SCOPE_TYPE);  List<LabelTaskState> labelTaskStateList = new ArrayList<>(); labelTaskStateList.add(LabelTaskState.COMPLETED); labelTaskStateList.add(LabelTaskState.SKIPPED); labelTaskStateList.add(LabelTaskState.REVIEWED);  LabelTask labelTask =  labelTaskRepository .findById(taskId) .orElseThrow(() -> new NotFoundException(LABEL_TASK_PLACEHOLDER, "id", "" + taskId));  if (!labelTaskStateList.contains(labelTask.getLabelTaskState())) { // The task is not in allowed / supported state. throw new GenericException(WRONG_LABEL_TASK_STATE, null, null, labelTask.getId()); }  // Permission check: is the user admin or user of the project. Project project = labelTask.getProject(); String owner = project.getOwner(); DataGymSecurity.isAdminOrUser(owner, true);  /* * Check if a LcEntry with the given export key exists within the documentation. */ Optional<LcEntry> optionalLcEntry = project.getLabelConfiguration().getEntries().stream() .filter(entry -> URLDecoder.decode(entry.getEntryKey(), StandardCharsets.UTF_8).equals(lcEntryKey)) .findFirst();  if (optionalLcEntry.isEmpty()) { // no entry with the given key is defined. throw new NotFoundException(LC_ENTRY_PLACEHOLDER, "entry_key", lcEntryKey); }  Media taskMedia = labelTask.getMedia(); if (taskMedia.isDeleted()) { throw new NotFoundException(IMAGE_PLACEHOLDER, "id", taskMedia.getId()); }  List<LcEntryValue> values = lcEntryValueRepository .findAllByTaskIdAndEntryKeyAndEntryType(taskId, lcEntryKey, LcEntryType.IMAGE_SEGMENTATION);  List<List<PointCollection>> pointCollections = values.stream() .filter(value -> value instanceof LcEntryImageSegmentationValue) .map(value -> ((LcEntryImageSegmentationValue) value).getPointsCollection()) .collect(Collectors.toList());  ImageSize image = (new ImageSizeReader(tika)).getSize(taskMedia); int height = image.getHeight(); int width = image.getWidth();  BufferedImage img = (new SegmentationBitmap(height, width)).addSegmentations(pointCollections).apply().asBufferedImage();  // Stream the Image String mimeType = "image/bmp"; String formatName = mimeType.split("/")[1].toLowerCase(Locale.ENGLISH);  // Stream the Image response.setHeader("Content-Type", mimeType); ImageIO.write(img, formatName, response.getOutputStream()); }
[*] target: assertEquals(expectedErrorMessage, e.getMessage())
[-] pred: org. junit. Assert. assertEquals ( expectedErrorMessage, e. getMessage ( ) )
************************************
************************************
[+] input: getAllProjects_WhenNoProjects_returnEmptyList() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  //When when(projectRepositoryMock.findAllByDeletedIsFalseAndOwner("eforce21")).thenReturn(new ArrayList<>()); List<ProjectViewModel> allProjects = projectService.getAllProjects();  //Then "<AssertPlaceHolder>";  verify(projectRepositoryMock).findAllByDeletedIsFalseAndOwner("eforce21"); verify(projectRepositoryMock, times(1)).findAllByDeletedIsFalseAndOwner("eforce21"); }
getAllProjects() { OauthUser user = SecurityContext.get(); Map<String, String> orgs = user.orgs();  List<ProjectViewModel> result = new ArrayList<>();  for (Map.Entry<String, String> orgsEntry : orgs.entrySet()) { String currentUserOrg = orgsEntry.getKey();  List<ProjectViewModel> currentOrgProjectViewModels = projectRepository .findAllByDeletedIsFalseAndOwner(currentUserOrg).stream() .map(currentProject -> { ProjectViewModel projectViewModel = ProjectMapper.mapToProjectViewModel(currentProject, mediaRepository::countAllByDatasetsContainingAndDeletedFalse);  boolean projectExportable = isProjectExportable(currentProject.getId()); projectViewModel.setExportable(projectExportable); return projectViewModel; }) .collect(Collectors.toList());  result.addAll(currentOrgProjectViewModels); }  return result; }
[*] target: assertTrue(allProjects.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( allProjects. isEmpty ( ) )
************************************
************************************
[+] input: isProjectNameUniqueAndDeletedFalse_whenUsernameIsNotUnique_returnFalse() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // Given Project testProject = ProjectUtils.createTestProject(PROJECT_ID);  //When when(projectRepositoryMock.findByNameAndDeletedFalseAndOwner(anyString(), anyString())).thenReturn(java.util.Optional.empty());  boolean actual = projectService.isProjectNameUniqueAndDeletedFalse(PROJECT_NAME, "eforce");  //Then Assertions."<AssertPlaceHolder>"; verify(projectRepositoryMock).findByNameAndDeletedFalseAndOwner(anyString(), anyString()); verify(projectRepositoryMock, times(1)).findByNameAndDeletedFalseAndOwner(anyString(), anyString()); }
isProjectNameUniqueAndDeletedFalse(String projectName, String owner) { return projectRepository .findByNameAndDeletedFalseAndOwner(projectName, owner).isEmpty(); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: getAllProjectsFromOrganisation_WhenNoProjects_returnEmptyList() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  //When when(projectRepositoryMock.findAllByDeletedIsFalseAndOwner(anyString())).thenReturn(new ArrayList<>()); List<ProjectViewModel> allProjects = projectService.getAllProjectsFromOrganisation("eforce21");  //Then "<AssertPlaceHolder>";  verify(projectRepositoryMock).findAllByDeletedIsFalseAndOwner(anyString()); verify(projectRepositoryMock, times(1)).findAllByDeletedIsFalseAndOwner(anyString()); }
getAllProjectsFromOrganisation(String orgId) { //Permissions check DataGymSecurity.isAdminOrUser(orgId, false);  return projectRepository .findAllByDeletedIsFalseAndOwner(orgId).stream() .filter(project -> !project.getName().equals(DUMMY_PROJECT_PLACEHOLDER)) .map(currentProject -> { ProjectViewModel projectViewModel = ProjectMapper.mapToProjectViewModel(currentProject, mediaRepository::countAllByDatasetsContainingAndDeletedFalse);  boolean projectExportable = isProjectExportable(currentProject.getId()); projectViewModel.setExportable(projectExportable); return projectViewModel; }) .collect(Collectors.toList()); }
[*] target: assertTrue(allProjects.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( allProjects. isEmpty ( ) )
************************************
************************************
[+] input: getAllProjectsFromOrganisationAndLoggedInUserIsAdmin_WhenNoProjects_returnEmptyList() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  //When when(projectRepositoryMock.findAllByDeletedIsFalseAndOwner(anyString())).thenReturn(new ArrayList<>()); List<ProjectViewModel> allProjects = projectService .getAllProjectsFromOrganisationAndLoggedInUserIsAdmin();  //Then "<AssertPlaceHolder>";  verify(projectRepositoryMock).findAllByDeletedIsFalseAndOwner(anyString()); verify(projectRepositoryMock, times(1)).findAllByDeletedIsFalseAndOwner(anyString()); }
getAllProjectsFromOrganisationAndLoggedInUserIsAdmin() { //Permissions check DataGymSecurity.isAuthenticated();  OauthUser user = SecurityContext.get(); Map<String, String> orgs = user.orgs();  List<ProjectViewModel> result = new ArrayList<>();  for (Map.Entry<String, String> orgsEntry : orgs.entrySet()) { String currentUserOrg = orgsEntry.getKey();  boolean isAdminInCurrentOrg = DataGymSecurity.checkIfUserIsAdmin(currentUserOrg, false);  if (isAdminInCurrentOrg) { List<ProjectViewModel> currentOrgProjectViewModels = projectRepository .findAllByDeletedIsFalseAndOwner(currentUserOrg).stream() .map(currentProject -> { ProjectViewModel projectViewModel = ProjectMapper.mapToProjectViewModel(currentProject, mediaRepository::countAllByDatasetsContainingAndDeletedFalse);  boolean projectExportable = isProjectExportable(currentProject.getId()); projectViewModel.setExportable(projectExportable); return projectViewModel; }) .collect(Collectors.toList());  result.addAll(currentOrgProjectViewModels); } }  return result; }
[*] target: assertTrue(allProjects.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( allProjects. isEmpty ( ) )
************************************
************************************
[+] input: isAdmin_whenUserIsAuthenticatedAndIsAdmin_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdmin = DataGymSecurity.isAdmin("eforce21", false);  // Then "<AssertPlaceHolder>"; }
isAdmin(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); }  boolean hasAdminRole = orgs.get(owner).equals(ADMIN_ROLE);  if (!hasAdminRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdmin)
[-] pred: org. junit. Assert. assertTrue ( isAdmin )
************************************
************************************
[+] input: isAdmin_whenUserIsNotInTheOrgAndUserIsSuperAdminAndMethodIsAllowedForSuperAdmins_throwException() { // Set Security Context OauthUser oauthUser = SecurityUtils.createSuperAdminUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdmin = DataGymSecurity.isAdmin("test_org", true);  // Then "<AssertPlaceHolder>"; }
isAdmin(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); }  boolean hasAdminRole = orgs.get(owner).equals(ADMIN_ROLE);  if (!hasAdminRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdmin)
[-] pred: org. junit. Assert. assertTrue ( isAdmin )
************************************
************************************
[+] input: checkIfUserIsAdmin_whenUserIsAuthenticatedAndIsAdmin_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdmin = DataGymSecurity.checkIfUserIsAdmin("eforce21", false);  // Then "<AssertPlaceHolder>"; }
checkIfUserIsAdmin(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); } return orgs.get(owner).equals(ADMIN_ROLE); }  return true; }
[*] target: assertTrue(isAdmin)
[-] pred: org. junit. Assert. assertTrue ( isAdmin )
************************************
************************************
[+] input: checkIfUserIsAdmin_whenUserIsNotInTheOrgAndUserIsSuperAdminAndMethodIsAllowedForSuperAdmins_throwException() { // Set Security Context OauthUser oauthUser = SecurityUtils.createSuperAdminUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdmin = DataGymSecurity.checkIfUserIsAdmin("test_org", true);  // Then "<AssertPlaceHolder>"; }
checkIfUserIsAdmin(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); } return orgs.get(owner).equals(ADMIN_ROLE); }  return true; }
[*] target: assertTrue(isAdmin)
[-] pred: org. junit. Assert. assertTrue ( isAdmin )
************************************
************************************
[+] input: checkIfUserIsAdmin_whenUserHasBasicScope_throwException() { // Set Security Context OauthUser oauthUser = SecurityUtils.createUserWithBasicScope(); SecurityContext.set(oauthUser);  // When boolean isAdmin = DataGymSecurity.checkIfUserIsAdmin("test_org", true);  // Then "<AssertPlaceHolder>"; }
checkIfUserIsAdmin(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); } return orgs.get(owner).equals(ADMIN_ROLE); }  return true; }
[*] target: assertTrue(isAdmin)
[-] pred: org. junit. Assert. assertTrue ( isAdmin )
************************************
************************************
[+] input: isAdminOrUser_whenUserIsAuthenticatedAndIsAdmin_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdminOrUser = DataGymSecurity.isAdminOrUser("eforce21", false);  // Then "<AssertPlaceHolder>"; }
isAdminOrUser(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); }  boolean hasAdminOrUserRole = orgs.get(owner).equals(ADMIN_ROLE) || orgs.get(owner).equals(USER_ROLE);  if (!hasAdminOrUserRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrUser)
[-] pred: org. junit. Assert. assertTrue ( isAdminOrUser )
************************************
************************************
[+] input: isAdminOrUser_whenUserHasUserRole_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdminOrUser = DataGymSecurity.isAdminOrUser("datagym", false);  // Then "<AssertPlaceHolder>"; }
isAdminOrUser(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); }  boolean hasAdminOrUserRole = orgs.get(owner).equals(ADMIN_ROLE) || orgs.get(owner).equals(USER_ROLE);  if (!hasAdminOrUserRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrUser)
[-] pred: org. junit. Assert. assertTrue ( isAdminOrUser )
************************************
************************************
[+] input: isAdminOrUser_whenUserIsNotInTheOrgAndUserIsSuperAdminAndMethodIsAllowedForSuperAdmins_throwException() { // Set Security Context OauthUser oauthUser = SecurityUtils.createSuperAdminUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdminOrUser = DataGymSecurity.isAdminOrUser("test_org", true);  // Then "<AssertPlaceHolder>"; }
isAdminOrUser(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); }  boolean hasAdminOrUserRole = orgs.get(owner).equals(ADMIN_ROLE) || orgs.get(owner).equals(USER_ROLE);  if (!hasAdminOrUserRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrUser)
[-] pred: org. junit. Assert. assertTrue ( isAdminOrUser )
************************************
************************************
[+] input: isAdminOrUser_whenUserHasBasicScope_throwException() { // Set Security Context OauthUser oauthUser = SecurityUtils.createUserWithBasicScope(); SecurityContext.set(oauthUser);  // When boolean isAdminOrUser = DataGymSecurity.isAdminOrUser("test_org", true);  // Then "<AssertPlaceHolder>"; }
isAdminOrUser(String owner, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(owner)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!scopes.contains(BASIC_SCOPE_TYPE)) { if (!orgs.containsKey(owner)) { throw new ForbiddenException(); }  boolean hasAdminOrUserRole = orgs.get(owner).equals(ADMIN_ROLE) || orgs.get(owner).equals(USER_ROLE);  if (!hasAdminOrUserRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrUser)
[-] pred: org. junit. Assert. assertTrue ( isAdminOrUser )
************************************
************************************
[+] input: isAdminOrLabeler_whenUserIsAuthenticatedAndIsAdmin_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdminOrLabeler = DataGymSecurity.isAdminOrLabeler("eforce21", null, false);  // Then "<AssertPlaceHolder>"; }
isAdminOrLabeler(String projectOrganisation, String currentTaskLabelerId, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(projectOrganisation)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!orgs.containsKey(projectOrganisation)) { throw new ForbiddenException(); }  boolean hasAdminRole = orgs.get(projectOrganisation).equals(ADMIN_ROLE);  if (scopes.contains(TOKEN_SCOPE_TYPE)) { if (!hasAdminRole) { throw new ForbiddenException(); } } else { String userId = user.id();  if (!userId.equals(currentTaskLabelerId) && !hasAdminRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrLabeler)
[-] pred: org. junit. Assert. assertTrue ( isAdminOrLabeler )
************************************
************************************
[+] input: isAdminOrLabeler_whenUserIsAuthenticatedAndIsLabeler_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdminOrLabeler = DataGymSecurity.isAdminOrLabeler("datagym", "eforce21", false);  // Then "<AssertPlaceHolder>"; }
isAdminOrLabeler(String projectOrganisation, String currentTaskLabelerId, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(projectOrganisation)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!orgs.containsKey(projectOrganisation)) { throw new ForbiddenException(); }  boolean hasAdminRole = orgs.get(projectOrganisation).equals(ADMIN_ROLE);  if (scopes.contains(TOKEN_SCOPE_TYPE)) { if (!hasAdminRole) { throw new ForbiddenException(); } } else { String userId = user.id();  if (!userId.equals(currentTaskLabelerId) && !hasAdminRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrLabeler)
[-] pred: org. junit. Assert. assertTrue ( isAdminOrLabeler )
************************************
************************************
[+] input: isAdminOrLabeler_whenUserIsNotInTheOrgAndUserIsSuperAdminAndMethodIsAllowedForSuperAdmins_throwException() { // Set Security Context OauthUser oauthUser = SecurityUtils.createSuperAdminUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isAdminOrLabeler = DataGymSecurity.isAdminOrLabeler("test_org", null, true);  // Then "<AssertPlaceHolder>"; }
isAdminOrLabeler(String projectOrganisation, String currentTaskLabelerId, boolean allowForSuperUser) { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  Set<String> scopes = user.scopes(); Map<String, String> orgs = user.orgs();  // Check if User is in the current Organisation. If not, check if user is SuperAdmin if (!orgs.containsKey(projectOrganisation)) { // Check if user is SuperAdmin and whether the method is allowed for a SuperAdmin if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && allowForSuperUser) { return true; } else if (scopes.contains(SUPER_ADMIN_SCOPE_TYPE) && !allowForSuperUser) { throw new ForbiddenException(); } }  if (!orgs.containsKey(projectOrganisation)) { throw new ForbiddenException(); }  boolean hasAdminRole = orgs.get(projectOrganisation).equals(ADMIN_ROLE);  if (scopes.contains(TOKEN_SCOPE_TYPE)) { if (!hasAdminRole) { throw new ForbiddenException(); } } else { String userId = user.id();  if (!userId.equals(currentTaskLabelerId) && !hasAdminRole) { throw new ForbiddenException(); } }  return true; }
[*] target: assertTrue(isAdminOrLabeler)
[-] pred: org. junit. Assert. assertTrue ( isAdminOrLabeler )
************************************
************************************
[+] input: isAuthenticated_whenUserIsAuthenticated_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  boolean isAuthenticated = DataGymSecurity.isAuthenticated();  // Then "<AssertPlaceHolder>"; }
isAuthenticated() { OauthUser user = SecurityContext.get();  if (user == null) { throw new ForbiddenException(); }  return true; }
[*] target: assertTrue(isAuthenticated)
[-] pred: org. junit. Assert. assertTrue ( isAuthenticated )
************************************
************************************
[+] input: isUserInCurrentOrg_whenUserIsAuthenticatedAndIsMemberOfTheOrg_returnsTrue() { // Set Security Context OauthUser oauthUser = SecurityUtils.createOauthUserWithTwoOrgsAndWithValues(); SecurityContext.set(oauthUser);  // When boolean isUserInCurrentOrg = DataGymSecurity.isUserInCurrentOrg("datagym");  // Then "<AssertPlaceHolder>"; }
isUserInCurrentOrg(String org) { OauthUser user = SecurityContext.get();  if (user == null || !user.orgs().containsKey(org)) { throw new ForbiddenException(); }  return true; }
[*] target: assertTrue(isUserInCurrentOrg)
[-] pred: org. junit. Assert. assertTrue ( isUserInCurrentOrg )
************************************
************************************
[+] input: haveTheSameOwner_whenFirstOwnerEqualsSecondOwner_returnsTrue() { // When boolean haveTheSameOwner = DataGymSecurity.haveTheSameOwner("eforce21", "eforce21");  // Then "<AssertPlaceHolder>"; }
haveTheSameOwner(String firstOwner, String secondOwner) { if (!firstOwner.equals(secondOwner)) { throw new ForbiddenException(); }  return true; }
[*] target: assertTrue(haveTheSameOwner)
[-] pred: org. junit. Assert. assertTrue ( haveTheSameOwner )
************************************
************************************
[+] input: visualizeGraphTest() { final var graph = new DirectedAcyclicGraph<>(); graph.addVertex("A"); graph.addVertex("B"); graph.addVertex("C"); graph.addVertex("D"); graph.addEdge("A", "B"); graph.addEdge("A", "C"); graph.addEdge("B", "D");  final var visualizer = new HorizontalGraphVisualizer<>(); final var config = new GraphLayoutConfig<>() { @NotNull @Override public Dimension getSize(@NotNull Object vertex) { return new Dimension(20, 10); }  @NotNull @Override public Dimension getSpacing() { return new Dimension(5, 5); } };  final var layouts = visualizer.create(graph, config); final var expected = List.of( new DefaultGraphLayout<>("A", new Point(0, 0), new Dimension(20, 10)), new DefaultGraphLayout<>("B", new Point(25, 0), new Dimension(20, 10)), new DefaultGraphLayout<>("C", new Point(25, 15), new Dimension(20, 10)), new DefaultGraphLayout<>("D", new Point(50, 0), new Dimension(20, 10)) );  Assertions."<AssertPlaceHolder>"; }
create(@NotNull Graph<V> graph, @NotNull C config);
[*] target: assertEquals(expected, layouts)
[-] pred: org. junit. Assert. assertEquals ( expected, layouts )
************************************
************************************
[+] input: getCreateTableSql() {  PostgreSqlDriver postgreSqlDriver = new PostgreSqlDriver(); String tableDDL = postgreSqlDriver.getCreateTableSql(table); String expect = "CREATE TABLE "public"."user" (\n" + "\t"id" BIGINT NOT NULL,\n" + "\t"username" VARCHAR(255) NOT NULL,\n" + "\t"password" VARCHAR(255) NOT NULL,\n" + "\t"email" VARCHAR(255) NOT NULL,\n" + "\t"phone" VARCHAR(20) NOT NULL,\n" + "\t"age" INT,\n" + "\t"gender" BOOLEAN,\n" + "\t"height" DECIMAL(5,2),\n" + "\t"birthday" DATE,\n" + "\t"register_time" TIMESTAMP NOT NULL, \n" + "\tPRIMARY KEY ("id")\n" + ");\n" + "COMMENT ON TABLE "public"."user" IS '用户表';\n" + "COMMENT ON COLUMN "public"."user"."id" IS '用户id';\n" + "COMMENT ON COLUMN "public"."user"."username" IS '用户名';\n" + "COMMENT ON COLUMN "public"."user"."password" IS '密码';\n" + "COMMENT ON COLUMN "public"."user"."email" IS '邮箱';\n" + "COMMENT ON COLUMN "public"."user"."phone" IS '电话号码';\n" + "COMMENT ON COLUMN "public"."user"."age" IS '年龄';\n" + "COMMENT ON COLUMN "public"."user"."gender" IS '性别';\n" + "COMMENT ON COLUMN "public"."user"."height" IS '身高';\n" + "COMMENT ON COLUMN "public"."user"."birthday" IS '生日';\n" + "COMMENT ON COLUMN "public"."user"."register_time" IS '注册时间';\n"; "<AssertPlaceHolder>"; }
getCreateTableSql(Table table) { String tableName = table.getName(); String schema = table.getSchema(); List<Column> columns = table.getColumns();  String columnDefinitions = columns.stream().map(this::getColumnDefinition).collect(Collectors.joining(",\n"));  // comment table:COMMENT ON TABLE "schemaName"."tableName" IS 'comment'; String comment = String.format("COMMENT ON TABLE "%s"."%s" IS '%s';\n", schema, tableName, table.getComment());  // get primaryKeys List<String> columnKeys = table.getColumns().stream() .filter(Column::isKeyFlag) .map(Column::getName) .map(t -> String.format(""%s"", t)) .collect(Collectors.toList());  // add primaryKey String primaryKeyStr = columnKeys.isEmpty() ? "" : columnKeys.stream().collect(Collectors.joining(",", ", \n\tPRIMARY KEY (", ")\n"));  // CREATE TABLE "schemaName"."tableName" ( columnDefinitions ); comment String ddl = String.format( "CREATE TABLE "%s"."%s" (\n%s%s);\n%s", schema, tableName, columnDefinitions, primaryKeyStr, comment);  ddl += columns.stream() // COMMENT ON COLUMN "schemaName"."tableName"."columnName" IS 'comment' .map(c -> String.format( "COMMENT ON COLUMN "%s"."%s"."%s" IS '%s';\n", schema, tableName, c.getName(), c.getComment())) .collect(Collectors.joining());  return ddl; }
[*] target: assertEquals(expect, tableDDL)
[-] pred: org. junit. Assert. assertEquals ( expect, tableDDL )
************************************
************************************
[+] input: testGivenPersonDTOThenReturnSavedMessage() { PersonDTO personDTO = createFakeDTO(); Person expectedSavedPerson = createFakeEntity();  when(personMapper.toModel(personDTO)).thenReturn(expectedSavedPerson); when(personRepository.save(any(Person.class))).thenReturn(expectedSavedPerson); //        when(personRepository.save(any(Person.class))) //                .thenReturn(expectedSavedPerson);  MessageResponseDTO expectedMessage = createExpectedResponse(expectedSavedPerson.getId()); MessageResponseDTO successMessage = personService.createPerson(personDTO);  "<AssertPlaceHolder>";  }
createPerson(PersonDTO personDTO) { Person personToSave = personMapper.toModel(personDTO); Person savedPerson = personRepository.save(personToSave);  return createMessageResponseDTO(savedPerson.getId(), "Created Person with ID "); }
[*] target: assertEquals(expectedMessage, successMessage)
[-] pred: org. junit. Assert. assertEquals ( expectedMessage, successMessage )
************************************
************************************
[+] input: testIfMethodReturnsPositivePairsUntilNumber() { final int randomNumber = (new Random()).nextInt(100) + 1; List<String> expectedPairNumbers = intStreamToListString( IntStream.rangeClosed(1, randomNumber).filter(number -> number % 2 == 0)); List<String> actualPairNumbers = intStreamToListString( ExibindoNumerosPares.getPositivePairsUntilNumber(randomNumber)); "<AssertPlaceHolder>"; }
getPositivePairsUntilNumber(int number) { IntStream pairNumbers = IntStream.rangeClosed(1, number); return pairNumbers.filter(x -> x % 2 == 0); }
[*] target: assertEquals(expectedPairNumbers, actualPairNumbers)
[-] pred: org. junit. Assert. assertEquals ( expectedPairNumbers, actualPairNumbers )
************************************
************************************
[+] input: testGetMethodInvalidName() { MockMethods obj = new MockMethods(); Method method = ReflectionUtils.getMethod(obj.getClass(), "notExisting");  "<AssertPlaceHolder>"; }
getMethod(@Nonnull Class<?> c, @Nonnull String method) { for (Method m : c.getMethods()) { if (m.getName().equals(method)) { return m; } }  return null; }
[*] target: assertNull(method)
[-] pred: org. junit. Assert. assertNull ( method )
************************************
************************************
[+] input: testGetMethodWithInvalidParams() { MockMethods obj = new MockMethods(); Method method = ReflectionUtils.getMethod(obj.getClass(), "returnInteger", String.class);  "<AssertPlaceHolder>"; }
getMethod(@Nonnull Class<?> c, @Nonnull String method, Class<?>... paramTypes) { Class<?>[] expectParamTypes = toPrimitiveTypeArray(paramTypes);  for (Method m : c.getMethods()) { Class<?>[] methodParameters = toPrimitiveTypeArray(m.getParameterTypes());  if ((m.getName().equals(method)) && (equalsTypeArray(methodParameters, expectParamTypes))) { return m; } }  return null; }
[*] target: assertNull(method)
[-] pred: org. junit. Assert. assertNull ( method )
************************************
************************************
[+] input: testGetEnumConstants() { List<MockEnum> constants = ReflectionUtils.getEnumConstants(MockEnum.class);  "<AssertPlaceHolder>"; }
getEnumConstants(@Nonnull Class<T> c) { return Arrays.asList(c.getEnumConstants()); }
[*] target: assertEquals(4, constants.size())
[-] pred: org. junit. Assert. assertEquals ( 4, constants. size ( ) )
************************************
************************************
[+] input: testGetNotExistingEnumConstant() { MockEnum constant = ReflectionUtils.getEnumConstant(MockEnum.class, "CHOCOLATE");  "<AssertPlaceHolder>"; }
getEnumConstant(Class<T> c, String name) { for (T field : c.getEnumConstants()) { if (field.toString().equals(name)) { return field; } }  return null; }
[*] target: assertNull(constant)
[-] pred: org. junit. Assert. assertNull ( constant )
************************************
************************************
[+] input: testCreateIndexByMap() { // 演示通过自定义map创建索引,最为灵活,若我提供的创建索引API不能满足时可用此方法 LambdaEsIndexWrapper<Document> wrapper = new LambdaEsIndexWrapper<>(); wrapper.indexName(Document.class.getSimpleName().toLowerCase()); wrapper.settings(3, 2); Map<String, Object> map = new HashMap<>(); Map<String, Object> prop = new HashMap<>(); Map<String, String> field = new HashMap<>(); field.put("type", FieldType.KEYWORD.getType()); prop.put("this_is_field", field); map.put("properties", prop); wrapper.mapping(map); boolean isOk = documentMapper.createIndex(wrapper); Assertions."<AssertPlaceHolder>"; }
mapping(Map<String, Object> mapping);  /** * 设置mapping信息 * * @param column    列 * @param fieldType es中的索引类型 * @return wrapper */ default Children mapping(R column, FieldType fieldType) { return mapping(column, fieldType, null, null, null, null, null); }
[*] target: assertTrue(isOk)
[-] pred: org. junit. Assert. assertTrue ( isOk )
************************************
************************************
[+] input: getHostIP() { String hostIP = HostUtils.getHostIP(); "<AssertPlaceHolder>"; }
getHostIP() { return IP; }
[*] target: assertNotNull(hostIP)
[-] pred: org. junit. Assert. assertNotNull ( hostIP )
************************************
************************************
[+] input: Exception {  Location location1 = locationRepository.save(Location.builder() .locationName("location1") .isUse(true) .sortSeq(1) .build()).block(); "<AssertPlaceHolder>";  webTestClient.get() .uri(API_URL+"/{locationId}", location1.getLocationId()) .exchange() .expectStatus().isOk() .expectBody() .jsonPath("$.locationName").isEqualTo(location1.getLocationName()); }
save(@Valid @RequestBody LocationSaveRequestDto saveRequestDto) { return locationService.save(saveRequestDto); }
[*] target: assertNotNull(location1)
[-] pred: org. junit. Assert. assertNotNull ( location1 )
************************************
************************************
[+] input: Exception {  Location location1 = locationRepository.save(Location.builder() .locationName("location1") .isUse(true) .sortSeq(1) .build()).block(); "<AssertPlaceHolder>";  webTestClient.get() .uri(API_URL+"?keywordType=locationName&keyword=location&page=0&size=3") .exchange() .expectStatus().isOk() .expectBody() .jsonPath("$.totalElements").isEqualTo(1) .jsonPath("$.content[0].locationName").isEqualTo(location1.getLocationName()); }
save(@Valid @RequestBody LocationSaveRequestDto saveRequestDto) { return locationService.save(saveRequestDto); }
[*] target: assertNotNull(location1)
[-] pred: org. junit. Assert. assertNotNull ( location1 )
************************************
************************************
[+] input: Exception { Location location1 = locationRepository.save(Location.builder() .locationName("location1") .isUse(true) .sortSeq(1) .build()).block(); "<AssertPlaceHolder>";  webTestClient.get() .uri(API_URL+"?page=0&size=3") .exchange() .expectStatus().isOk() .expectBody() .jsonPath("$.totalElements").isEqualTo(1) .jsonPath("$.content[0].locationName").isEqualTo(location1.getLocationName()); }
save(@Valid @RequestBody LocationSaveRequestDto saveRequestDto) { return locationService.save(saveRequestDto); }
[*] target: assertNotNull(location1)
[-] pred: org. junit. Assert. assertNotNull ( location1 )
************************************
************************************
[+] input: Exception { Location location1 = locationRepository.save(Location.builder() .locationName("location1") .isUse(true) .sortSeq(1) .build()).block(); "<AssertPlaceHolder>";  webTestClient.delete() .uri(API_URL+"/{locationId}", location1.getLocationId()) .exchange() .expectStatus().isNoContent();  }
save(@Valid @RequestBody LocationSaveRequestDto saveRequestDto) { return locationService.save(saveRequestDto); }
[*] target: assertNotNull(location1)
[-] pred: org. junit. Assert. assertNotNull ( location1 )
************************************
************************************
[+] input: 사용자목록조회_성공() {  ReserveItem saved = reserveItemRepository.save(reserveItem).block(); "<AssertPlaceHolder>";  webTestClient.method(HttpMethod.GET) .uri("/api/v1/"+category.getCodeId()+"/reserve-items"+"?page=0&size=3&isUse=true") .exchange() .expectStatus().isOk() .expectBody() .jsonPath("$.totalElements").isEqualTo(1) .jsonPath("$.content[0].reserveItemName").isEqualTo(reserveItem.getReserveItemName()); }
save(@Valid @RequestBody ReserveItemSaveRequestDto saveRequestDto) { return reserveItemService.save(saveRequestDto); }
[*] target: assertNotNull(saved)
[-] pred: org. junit. Assert. assertNotNull ( saved )
************************************
************************************
[+] input: 관리자목록조회_성공() {  ReserveItem saved = reserveItemRepository.save(reserveItem).block(); "<AssertPlaceHolder>";  webTestClient.method(HttpMethod.GET) .uri(API_URL+"?page=0&size=3&isUse=false") .exchange() .expectStatus().isOk() .expectBody() .jsonPath("$.totalElements").isEqualTo(1) .jsonPath("$.content[0].reserveItemName").isEqualTo(reserveItem.getReserveItemName()); }
save(@Valid @RequestBody ReserveItemSaveRequestDto saveRequestDto) { return reserveItemService.save(saveRequestDto); }
[*] target: assertNotNull(saved)
[-] pred: org. junit. Assert. assertNotNull ( saved )
************************************
************************************
[+] input: testCopy() { // Tests round-tripping a json document that contains all event types and various kinds of nesting  String json = "{\n" + "  "p1": "str1",\n" + "  "p2": 42,\n" + "  "p3": ["str31", "str32"],\n" + "  "p4": {\n" + "    "p41": "str41",\n" + "    "p42": ["str421", "str422"],\n" + "    "p43": {\n" + "      "p431": "str431"\n" + "    },\n" + "    "p44": true,\n" + "    "p45": false,\n" + "    "p46": 3.14\n" + "  },\n" + "  "p5": [{\n" + "    "p51": {\n" + "      "p511": "str511"\n" + "    }\n" + "  }],\n" + "  "p6": null\n" + "}\n";  json = normalizeIndent(json);  JsonProvider provider = JsonpUtils.provider();  JsonParser parser = provider.createParser(new StringReader(json)); StringWriter sw = new StringWriter(); JsonGenerator generator = provider.createGenerator(sw);  JsonpUtils.copy(parser, generator); parser.close(); generator.close();  "<AssertPlaceHolder>"; }
toString() { return "(in object at " + super.toString().substring(1); }
[*] target: assertEquals(json, sw.toString())
[-] pred: org. junit. Assert. assertEquals ( json, sw. toString ( ) )
************************************
************************************
[+] input: IOException { KeyManager km = SingleConnectorServicesProvider.getKeyFromKeyStoreUri(new File(keystoreFileName).toURI().toString(), keystoreFilePass); "<AssertPlaceHolder>"; }
getKeyFromKeyStoreUri(String keystoreUri, String keystorePassword) throws URISyntaxException, KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { if(keystorePassword== null) { keystorePassword = ""; } String keyAlias = null; KeyStore store = KeyStore.getInstance("pkcs12");  URI uriParser = new URI(keystoreUri); String scheme = uriParser.getScheme();  if (scheme.equalsIgnoreCase("data")){ // example: "data:application/x-pkcs12;base64,MIACAQMwgAY...gtc/qoCAwGQAAAA" String[] schemeSpecificParts = uriParser.getSchemeSpecificPart().split(";"); String contentType = schemeSpecificParts[0]; if (contentType.equalsIgnoreCase("application/x-pkcs12") || contentType.equalsIgnoreCase("application/octet-stream")){ String[] dataParts = schemeSpecificParts[1].split(","); String encodingType = dataParts[0]; if (encodingType.equalsIgnoreCase("base64")){ String keystoreBase64 = dataParts[1]; ByteArrayInputStream keystoreInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(keystoreBase64)); store.load(keystoreInputStream, keystorePassword.toCharArray()); } } } else if (scheme.equalsIgnoreCase("file")) { String keystoreFile = uriParser.getPath(); String query = uriParser.getRawQuery(); try { String[] queryParts = query.split("="); String parameterName = queryParts[0]; String parameterValue = queryParts[1]; if (parameterName.equalsIgnoreCase("alias")){ // example: "file:src/test/resources/certs/keystore.p12?alias=key2" keyAlias = parameterValue; } } catch (NullPointerException|PatternSyntaxException e){ // take the first key from KeyStore, whichever it is // example: "file:src/test/resources/certs/keystore.p12" } FileInputStream in = new FileInputStream(keystoreFile); store.load(in, keystorePassword.toCharArray()); }  KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); try { kmf.init(store, keystorePassword.toCharArray()); final X509KeyManager origKm = (X509KeyManager)kmf.getKeyManagers()[0]; if(keyAlias == null) { return origKm; } else { final String finalKeyAlias = keyAlias; return new X509KeyManager() {  @Override public String chooseClientAlias(String[] arg0, Principal[] arg1, Socket arg2) { return finalKeyAlias; }  @Override public String chooseServerAlias(String arg0, Principal[] arg1, Socket arg2) { return origKm.chooseServerAlias(arg0, arg1, arg2); }  @Override public X509Certificate[] getCertificateChain(String alias) { return origKm.getCertificateChain(alias); }  @Override public String[] getClientAliases(String arg0, Principal[] arg1) { return origKm.getClientAliases(arg0, arg1); }  @Override public PrivateKey getPrivateKey(String alias) { return origKm.getPrivateKey(alias); }  @Override public String[] getServerAliases(String arg0, Principal[] arg1) { return origKm.getServerAliases(arg0, arg1); } }; } } catch (UnrecoverableKeyException e) { log.log(Level.WARNING, "Could not create KeyManager", e); return null; } }
[*] target: assertNotNull(km)
[-] pred: org. junit. Assert. assertNotNull ( km )
************************************
************************************
[+] input: IOException { KeyManager km = SingleConnectorServicesProvider.getKeyFromKeyStoreUri(new File(keystoreFileName).toURI().toString()+"?alias=key2", keystoreFilePass); "<AssertPlaceHolder>"; }
getKeyFromKeyStoreUri(String keystoreUri, String keystorePassword) throws URISyntaxException, KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { if(keystorePassword== null) { keystorePassword = ""; } String keyAlias = null; KeyStore store = KeyStore.getInstance("pkcs12");  URI uriParser = new URI(keystoreUri); String scheme = uriParser.getScheme();  if (scheme.equalsIgnoreCase("data")){ // example: "data:application/x-pkcs12;base64,MIACAQMwgAY...gtc/qoCAwGQAAAA" String[] schemeSpecificParts = uriParser.getSchemeSpecificPart().split(";"); String contentType = schemeSpecificParts[0]; if (contentType.equalsIgnoreCase("application/x-pkcs12") || contentType.equalsIgnoreCase("application/octet-stream")){ String[] dataParts = schemeSpecificParts[1].split(","); String encodingType = dataParts[0]; if (encodingType.equalsIgnoreCase("base64")){ String keystoreBase64 = dataParts[1]; ByteArrayInputStream keystoreInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(keystoreBase64)); store.load(keystoreInputStream, keystorePassword.toCharArray()); } } } else if (scheme.equalsIgnoreCase("file")) { String keystoreFile = uriParser.getPath(); String query = uriParser.getRawQuery(); try { String[] queryParts = query.split("="); String parameterName = queryParts[0]; String parameterValue = queryParts[1]; if (parameterName.equalsIgnoreCase("alias")){ // example: "file:src/test/resources/certs/keystore.p12?alias=key2" keyAlias = parameterValue; } } catch (NullPointerException|PatternSyntaxException e){ // take the first key from KeyStore, whichever it is // example: "file:src/test/resources/certs/keystore.p12" } FileInputStream in = new FileInputStream(keystoreFile); store.load(in, keystorePassword.toCharArray()); }  KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); try { kmf.init(store, keystorePassword.toCharArray()); final X509KeyManager origKm = (X509KeyManager)kmf.getKeyManagers()[0]; if(keyAlias == null) { return origKm; } else { final String finalKeyAlias = keyAlias; return new X509KeyManager() {  @Override public String chooseClientAlias(String[] arg0, Principal[] arg1, Socket arg2) { return finalKeyAlias; }  @Override public String chooseServerAlias(String arg0, Principal[] arg1, Socket arg2) { return origKm.chooseServerAlias(arg0, arg1, arg2); }  @Override public X509Certificate[] getCertificateChain(String alias) { return origKm.getCertificateChain(alias); }  @Override public String[] getClientAliases(String arg0, Principal[] arg1) { return origKm.getClientAliases(arg0, arg1); }  @Override public PrivateKey getPrivateKey(String alias) { return origKm.getPrivateKey(alias); }  @Override public String[] getServerAliases(String arg0, Principal[] arg1) { return origKm.getServerAliases(arg0, arg1); } }; } } catch (UnrecoverableKeyException e) { log.log(Level.WARNING, "Could not create KeyManager", e); return null; } }
[*] target: assertNotNull(km)
[-] pred: org. junit. Assert. assertNotNull ( km )
************************************
************************************
[+] input: testDeserialize() { Language expectedLanguage = new Language("en", List.of("en_us", "en_gb")); String serializedLanguage = "en|en_us|en_gb";  Language actualLanguage = this.composer.deserialize(serializedLanguage).get(); "<AssertPlaceHolder>"; }
deserialize(String source) { List<String> arguments = Arrays.asList(source.split("\\|"));  return Result.ok(new Language(arguments.get(0), arguments.subList(1, arguments.size()))); }
[*] target: assertEquals(expectedLanguage, actualLanguage)
[-] pred: org. junit. Assert. assertEquals ( expectedLanguage, actualLanguage )
************************************
************************************
[+] input: testSerialize() { Language language = new Language("en", List.of("en_us", "en_gb")); String expectedSerializedLanguage = "en|en_us|en_gb";  String actualSerializedLanguage = this.composer.serialize(language).get(); "<AssertPlaceHolder>"; }
serialize(Language entity) { List<String> all = new ArrayList<>();  all.add(entity.getLang()); all.addAll(entity.getAliases());  return Result.ok(Joiner.on("|").join(all).toString()); }
[*] target: assertEquals(expectedSerializedLanguage, actualSerializedLanguage)
[-] pred: org. junit. Assert. assertEquals ( expectedSerializedLanguage, actualSerializedLanguage )
************************************
************************************
[+] input: ReflectiveOperationException { final boolean[] bools = new boolean[2]; final PojoMapper<TestProperties> pojoMapper = PojoMapper.create(TestProperties.class); pojoMapper.addListener(new PojoListener() { @Override public void onPropertyAdded(PojoMapper<?> pojoMapper, PojoProperty pojoProperty) { bools[0] = true; }  @Override public void onMapperInitialized(PojoMapper<?> pojoMapper) { bools[1] = true; } }); pojoMapper.init();  for (boolean bool : bools) { Assertions."<AssertPlaceHolder>"; } }
init() throws ReflectiveOperationException;  Map<String, PojoProperty> properties();  default PojoProperty getProperty(String name) { return properties().getOrDefault(name, null); }
[*] target: assertTrue(bool)
[-] pred: org. junit. Assert. assertTrue ( bool )
************************************
************************************
[+] input: findOrCacheSerializerShouldFindIfExists() { final SerializerFactory serializerFactory = Containers.get(SerializerFactory.class); final ObjectSerializerStringStringMock serializer = new ObjectSerializerStringStringMock(); serializerFactory.registerSerializer(serializer);  final ObjectSerializer<?, ?> cacheSerializer = serializerFactory.findOrCacheSerializer(ObjectSerializerStringStringMock.class);  Assertions."<AssertPlaceHolder>"; }
findOrCacheSerializer(@NotNull Class<?> serializerClass) { ConditionUtils.is(ObjectSerializer.class.isAssignableFrom(serializerClass), "Cannot findOrCacheSerializer() by a non-serializer class."); final SerializerData serializerData = this.serializerBySerializerType.get(serializerClass); if (serializerData == null) { ObjectSerializer<?, ?> serializer = ThrowingSupplier .sneaky(() -> (ObjectSerializer<?, ?>) serializerClass.getDeclaredConstructor().newInstance()) .get(); this.registerSerializer(serializer); return serializer; } return serializerData.getSerializer(); }
[*] target: assertEquals(serializer, cacheSerializer)
[-] pred: org. junit. Assert. assertEquals ( serializer, cacheSerializer )
************************************
************************************
[+] input: signalWithSameNameShouldBeEqual() { Signal a = Signal.of("signal"); Signal b = Signal.of("signal");  Assertions."<AssertPlaceHolder>"; }
of(String name) { return new SignalImpl(name); }
[*] target: assertEquals(a, b)
[-] pred: org. junit. Assert. assertEquals ( a, b )
************************************
************************************
[+] input: stateWithSameNameShouldBeEqual() { State a = State.of("state"); State b = State.of("state");  Assertions."<AssertPlaceHolder>"; }
of(String name) { return new StateImpl(name); }
[*] target: assertEquals(a, b)
[-] pred: org. junit. Assert. assertEquals ( a, b )
************************************
************************************
[+] input: Throwable { String str = "abc"; String encoding = "UTF-8"; byte[] bytes = str.getBytes(encoding); FastConstructor<String> fc = FastConstructor.create(String.class.getConstructor(byte[].class, String.class)); String result = (String) fc.invoke(bytes, encoding); "<AssertPlaceHolder>"; }
create(Constructor<T> constructor, boolean toSetAccessible) { return create(constructor, FastMemberLoader.getDefaultLoader(), toSetAccessible); }
[*] target: assertEquals(str, result)
[-] pred: org. junit. Assert. assertEquals ( str, result )
************************************
************************************
[+] input: NoSuchMethodException { Constructor<String> stringCtor = String.class.getConstructor(char[].class); FastConstructor<String> fc = FastConstructor.create(stringCtor); "<AssertPlaceHolder>"; }
toString() { return constructor.toString(); }
[*] target: assertEquals(stringCtor.toString(), fc.toString())
[-] pred: org. junit. Assert. assertEquals ( stringCtor. toString ( ), fc. toString ( ) )
************************************
************************************
[+] input: NoSuchFieldException { String fieldName = "name"; FastField ff = FastField.create(Person.class.getField(fieldName)); "<AssertPlaceHolder>"; }
getName() { return field.getName(); }
[*] target: assertEquals(fieldName, ff.getName())
[-] pred: org. junit. Assert. assertEquals ( fieldName, ff. getName() )
************************************
************************************
[+] input: NoSuchFieldException { Field field = Person.class.getField("name"); FastField ff = FastField.create(field); "<AssertPlaceHolder>"; }
toString() { return field.toString(); }
[*] target: assertEquals(field.toString(), ff.toString())
[-] pred: org. junit. Assert. assertEquals ( field. toString ( ), ff. toString ( ) )
************************************
************************************
[+] input: Throwable { FastMethod fm = FastMethod.create(String.class.getMethod("startsWith", String.class)); boolean result = (boolean) fm.invoke("abc", "a"); "<AssertPlaceHolder>"; }
invoke(Object obj, Object... args) throws Throwable;  public static FastMethod create(Method method) { return create(method, false); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: NoSuchMethodException { Method startsWithMethod = String.class.getMethod("startsWith", String.class); FastMethod fm = FastMethod.create(startsWithMethod); "<AssertPlaceHolder>"; }
getModifiers() { return method.getModifiers(); }
[*] target: assertEquals(startsWithMethod.getModifiers(), fm.getModifiers())
[-] pred: org. junit. Assert. assertEquals ( startsWithMethod. getModifiers(), fm. getModifiers() )
************************************
************************************
[+] input: searchTest() { var result = wishListService.search("갈비집"); System.out.println(result); Assertions."<AssertPlaceHolder>";  }
search(String query){ // 지역검색 var searchLocalReq = new SearchLocalReq(); searchLocalReq.setQuery(query); var searchLocalRes = naverClient.searchLocal(searchLocalReq);  if(searchLocalRes.getTotal() > 0){ var localItem = searchLocalRes.getItems().stream().findFirst().get(); var imageQuery = localItem.getTitle().replaceAll("<[^>]*>",""); var searchImageReq = new SearchImageReq(); searchImageReq.setQuery(imageQuery);  // 이미지 검색 var searchImageRes = naverClient.searchImage(searchImageReq);  if(searchImageRes.getTotal() > 0){ var imageItem = searchImageRes.getItems().stream().findFirst().get();  // 결과를 리턴 var result = new WishListDto(); result.setTitle(localItem.getTitle()); result.setCategory(localItem.getCategory()); result.setAddress(localItem.getAddress()); result.setRoadAddress(localItem.getRoadAddress()); result.setHomePageLink(localItem.getLink()); result.setImageLink(imageItem.getLink()); return result; } }  return new WishListDto(); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { String masterAddresses = harness.getMasterAddressesAsString();  KuduTableInfo tableInfo = KuduTableInfo .forTable("test_speed") .createTableIfNotExists( () -> Lists.newArrayList( new ColumnSchema .ColumnSchemaBuilder("id", Type.INT32) .key(true) .build(), new ColumnSchema .ColumnSchemaBuilder("uuid", Type.STRING) .build() ), () -> new CreateTableOptions() .setNumReplicas(3) .addHashPartitions(Lists.newArrayList("id"), 6));  KuduWriterConfig writerConfig = KuduWriterConfig.Builder .setMasters(masterAddresses) .setEventualConsistency() .build(); KuduSink<Row> sink = new KuduSink<>(writerConfig, tableInfo, new RowOperationMapper(columns, AbstractSingleOperationMapper.KuduOperation.INSERT));  sink.setRuntimeContext(context); sink.open(new Configuration());  int totalRecords = 100000; for (int i = 0; i < totalRecords; i++) { Row kuduRow = new Row(2); kuduRow.setField(0, i); kuduRow.setField(1, UUID.randomUUID().toString()); sink.invoke(kuduRow); }  // sleep to allow eventual consistency to finish Thread.sleep(1000);  sink.close();  List<Row> rows = readRows(tableInfo); Assertions."<AssertPlaceHolder>"; }
close() throws Exception { if (kuduWriter != null) { kuduWriter.close(); } }
[*] target: assertEquals(totalRecords, rows.size())
[-] pred: org. junit. Assert. assertEquals ( totalRecords, rows. size ( ) )
************************************
************************************
[+] input: cacheReturnsNewValueFromCallback() { LayeredMatchedOptionCache<String, Integer> cache = new LayeredMatchedOptionCache<>(Duration.ofMinutes(1), 10);  Integer result = cache.get("test", () -> 42, value -> false);  "<AssertPlaceHolder>"; }
get(K key, Supplier<V> callback, Predicate<V> matcher) { Deque<CacheEntry<V>> entries = prepareMap(key);  cleanUpEntries(entries, key);  return findValidEntry(entries, matcher) .map(CacheEntry::value) .orElseGet(() -> addNewEntry(entries, callback.get())); }
[*] target: assertEquals(42, result)
[-] pred: org. junit. Assert. assertEquals ( 42, result )
************************************
************************************
[+] input: testCompareEquals() { DateTimeStamp object1 = new DateTimeStamp("2018-04-04T10:10:00.586-0100"); DateTimeStamp object2 = new DateTimeStamp("2018-04-04T10:10:00.586-0100"); "<AssertPlaceHolder>"; }
compareTo(DateTimeStamp dateTimeStamp) { return  comparator.compare(this,dateTimeStamp); }
[*] target: assertEquals(0, object1.compareTo(object2))
[-] pred: org. junit. Assert. assertEquals ( 0, object1. compareTo ( object2 ) )
************************************
************************************
[+] input: has_to_create_DataFecher_By_Path() { // Given final SwaggerGraphQLSchemaBuilder swaggerGraphQLSchemaBuilder = new SwaggerGraphQLSchemaBuilder(); final Swagger swagger = new SwaggerParser().read(SWAGGER_LOCATION);  // When final GraphQLSchema graphQLSchema = swaggerGraphQLSchemaBuilder.swagger(swagger).build();  // Then /** * TODO * Define mock for http://localhost:8080/books and http://localhost:8080/books({id} * Use https://github.com/square/okhttp/tree/master/mockwebserver */ FieldCoordinates fieldCoordinates = coordinates("Query", "books"); DataFetcher dataFetcher = graphQLSchema.getCodeRegistry().getDataFetcher(fieldCoordinates, graphQLSchema.getQueryType().getFieldDefinition("books")); "<AssertPlaceHolder>"; }
build() { return schemaBuilder.build(); }
[*] target: assertNotNull(dataFetcher)
[-] pred: org. junit. Assert. assertNotNull ( dataFetcher )
************************************
************************************
[+] input: InterruptedException { HBrowser hBrowser = new HBrowser(); try (PlaywrightWindow window = hBrowser.openCustomWindow().debugOutputStream(System.out).headless(false).buildPlaywrightWindow()) { window.load(new File(System.getProperty("user.dir") + "/test.html")); String expected = "This is the expected value!"; String actual = null; window.fill("id=input__text", expected); window.fill("id=input__password", expected); actual = window.getOuterHtml().getElementById("input__text").attr("value"); // TODO seems like it sets the text correctly. // TODO Just got to find a way of retrieving the value from the form, because it wont work with the regular form.value thing. //"<AssertPlaceHolder>"; } }
getOuterHtml() { String rawHtml = jsContext.executeJSAndGetResult("" + "var result = await page.evaluate(() => document.getElementsByTagName("html")[0].outerHTML);\n"); return Jsoup.parse(rawHtml); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: emptyIsCorrect() { Set<Integer> testSet = Empty.apply();  "<AssertPlaceHolder>"; }
isEmpty() { return new IsEmpty().term(); }
[*] target: assertTrue(testSet.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( testSet. isEmpty() )
************************************
************************************
[+] input: createConnectionViaUserPwdGood() { Connection connectionMock = Mockito.mock(Connection.class); try (MockedStatic<DriverManager> driverMgr = Mockito.mockStatic(DriverManager.class)) { driverMgr.when(() -> DriverManager.getConnection(Mockito.anyString(), Mockito.anyString(), Mockito.anyString())) .thenReturn(connectionMock);  Connection conn = DbUtil.createConnectionViaUserPwd("a", "b", "c"); "<AssertPlaceHolder>"; } }
createConnectionViaUserPwd( @NonNull String username, @NonNull String pwd, @NonNull String dbEndpoint) { Connection connection;  try { connection = DriverManager.getConnection(JDBC_PREFIX + dbEndpoint, username, pwd); logger.info("Connection Established"); return connection;  } catch (SQLException e) { logger.info("Connection FAILED"); logger.error(e.getMessage(), e); }  return null; }
[*] target: assertNotNull(conn)
[-] pred: org. junit. Assert. assertNotNull ( conn )
************************************
************************************
[+] input: createConnectionViaUserPwdSqlException() { try (MockedStatic<DriverManager> driverMgr = Mockito.mockStatic(DriverManager.class)) { driverMgr.when(() -> DriverManager.getConnection(Mockito.anyString(), Mockito.anyString(), Mockito.anyString())) .thenThrow(SQLException.class);  Connection conn = DbUtil.createConnectionViaUserPwd("a", "b", "c"); "<AssertPlaceHolder>"; } }
createConnectionViaUserPwd( @NonNull String username, @NonNull String pwd, @NonNull String dbEndpoint) { Connection connection;  try { connection = DriverManager.getConnection(JDBC_PREFIX + dbEndpoint, username, pwd); logger.info("Connection Established"); return connection;  } catch (SQLException e) { logger.info("Connection FAILED"); logger.error(e.getMessage(), e); }  return null; }
[*] target: assertNull(conn)
[-] pred: org. junit. Assert. assertNull ( conn )
************************************
************************************
[+] input: testIsProviderCodeUniqueSameExists() { Provider provider = new Provider(1, "name-a", LocalDate.now(), "nationality-a", "code-a"); Mockito.when(dao.findProviderByCode(Mockito.any())).thenReturn(provider);  boolean retVal = service.isProviderCodeUnique(1, "a"); "<AssertPlaceHolder>"; }
isProviderCodeUnique(Integer id, String code) { Provider provider = findProviderByCode(code); return ( provider == null || ((id != null) && (provider.getId() == id))); }
[*] target: assertTrue(retVal)
[-] pred: org. junit. Assert. assertTrue ( retVal )
************************************
************************************
[+] input: testIsProviderCodeUniqueDoesntExist() { boolean retVal = service.isProviderCodeUnique(1, "a"); "<AssertPlaceHolder>"; }
isProviderCodeUnique(Integer id, String code) { Provider provider = findProviderByCode(code); return ( provider == null || ((id != null) && (provider.getId() == id))); }
[*] target: assertTrue(retVal)
[-] pred: org. junit. Assert. assertTrue ( retVal )
************************************
************************************
[+] input: testIsProviderCodeUniqueOtherExists() { Provider provider = new Provider(1, "name-a", LocalDate.now(), "nationality-a", "code-a"); Mockito.when(dao.findProviderByCode(Mockito.any())).thenReturn(provider);  boolean retVal = service.isProviderCodeUnique(2, "a"); "<AssertPlaceHolder>"; }
isProviderCodeUnique(Integer id, String code) { Provider provider = findProviderByCode(code); return ( provider == null || ((id != null) && (provider.getId() == id))); }
[*] target: assertFalse(retVal)
[-] pred: org. junit. Assert. assertFalse ( retVal )
************************************
************************************
[+] input: acceptDelivery() { // Arrange var delivery = makeValidDelivery(); delivery.setId("delivery-1234"); // Stub when(deliveryService.acceptDelivery(any(Delivery.class))).thenReturn(Mono.just(delivery)); // Act var result = testClient .put() .uri(DELIVERY_URL + "/accept") .bodyValue(delivery) .exchange() .expectStatus() .isOk() .expectBody(Delivery.class) .returnResult() .getResponseBody(); // Assert Assertions."<AssertPlaceHolder>"; }
acceptDelivery(@RequestBody @Valid Delivery delivery) { return deliveryService.acceptDelivery(delivery); }
[*] target: assertEquals(delivery, result)
[-] pred: org. junit. Assert. assertEquals ( delivery, result )
************************************
************************************
[+] input: getLocation_test() { // given var location = new RiderLocation("rider-1234", "delivery-1234", 23.0f, 190f); var uri = UriComponentsBuilder.fromUriString(riderLocationMapping) .queryParam("deliveryId", location.getDeliveryId()) .buildAndExpand() .toUriString();  // when when(riderLocationService.getLocation(location.getDeliveryId())) .thenReturn(Mono.just(location));  var result = testClient .get() .uri(uri) .exchange() .expectStatus() .isOk() .expectBody(RiderLocation.class) .returnResult() .getResponseBody(); // then "<AssertPlaceHolder>"; }
getLocation(@RequestParam(name = "deliveryId") String deliveryId) { return locationService.getLocation(deliveryId); }
[*] target: assertEquals(location, result)
[-] pred: org. junit. Assert. assertEquals ( location, result )
************************************
************************************
[+] input: testCreateAccount() { Account expected = new Account("Gigi", 2100, "223311"); when(mockRepo.findOne("Gigi")).thenReturn(Optional.empty()); when(mockRepo.save(any(Account.class))).thenReturn(expected);  Account result = service.createAccount("Gigi", "223311", "2100"); "<AssertPlaceHolder>"; }
createAccount(String holder, String accountNumber, String amount);  /** * returns sum in the account after adding the amount * @param holder * @param amount * @return amount in the account */ int debit(String holder, int amount);  /** * returns sum in the account after subtracting the amount * @param holder * @param amount * @return amount in the account */ int credit(String holder, int amount);  /** * deletes the account for this holder * @param holder * @returns {@code true}
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testDense() {  BooleanSparseNdArray instance = new BooleanSparseNdArray(indices, values, DimensionalSpace.create(shape)); BooleanNdArray denseInstance = instance.toDense(); BooleanNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { BooleanDataBuffer dataBuffer = DataBuffers.ofBooleans(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred: org. junit. Assert. assertEquals ( expectedDense, denseInstance )
************************************
************************************
[+] input: testDense() {  ByteSparseNdArray instance = new ByteSparseNdArray(indices, values, DimensionalSpace.create(shape)); ByteNdArray denseInstance = instance.toDense(); ByteNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { ByteDataBuffer dataBuffer = DataBuffers.ofBytes(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred: org. junit. Assert. assertEquals ( expectedDense, denseInstance )
************************************
************************************
[+] input: testDense() {  DoubleSparseNdArray instance = new DoubleSparseNdArray(indices, values, DimensionalSpace.create(shape)); DoubleNdArray denseInstance = instance.toDense(); DoubleNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { DoubleDataBuffer dataBuffer = DataBuffers.ofDoubles(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred: org. junit. Assert. assertEquals ( expectedDense, denseInstance )
************************************
************************************
[+] input: testDense() { float[][] dense2DArray = {{1, 0, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 0}};  FloatSparseNdArray instance = new FloatSparseNdArray(indices, values, DimensionalSpace.create(shape)); FloatNdArray denseInstance = instance.toDense(); FloatNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { FloatDataBuffer dataBuffer = DataBuffers.ofFloats(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred: org. junit. Assert. assertEquals ( expectedDense, denseInstance )
************************************
************************************
[+] input: testDense() { int[][] dense2DArray = {{1, 0, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 0}};  IntSparseNdArray instance = new IntSparseNdArray(indices, values, DimensionalSpace.create(shape)); IntNdArray denseInstance = instance.toDense(); IntNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { IntDataBuffer dataBuffer = DataBuffers.ofInts(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred: org. junit. Assert. assertEquals ( expectedDense, denseInstance )
************************************
************************************
[+] input: testDense() { long[][] dense2DArray = {{1, 0, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 0}};  LongSparseNdArray instance = new LongSparseNdArray(indices, values, DimensionalSpace.create(shape)); LongNdArray denseInstance = instance.toDense(); LongNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { LongDataBuffer dataBuffer = DataBuffers.ofLongs(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred: org. junit. Assert. assertEquals ( expectedDense, denseInstance )
************************************
************************************
[+] input: testDense() { short[][] dense2DArray = {{1, 0, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 0}};  ShortSparseNdArray instance = new ShortSparseNdArray(indices, values, DimensionalSpace.create(shape)); ShortNdArray denseInstance = instance.toDense(); ShortNdArray expectedDense = StdArrays.ndCopyOf(dense2DArray); "<AssertPlaceHolder>"; }
toDense() { ShortDataBuffer dataBuffer = DataBuffers.ofShorts(shape().size()); copyTo(dataBuffer); return NdArrays.wrap(shape(), dataBuffer); }
[*] target: assertEquals(expectedDense, denseInstance)
[-] pred: org. junit. Assert. assertEquals ( expectedDense, denseInstance )
************************************
************************************
[+] input: testLength() { byte [] bytes = { 'a', 'b', 'c', 'd', 'e', 'f',}; BinaryString bs = new BinaryString(bytes, 2, 3); "<AssertPlaceHolder>"; }
length() { return usedLen; }
[*] target: assertEquals(3, bs.length())
[-] pred: org. junit. Assert. assertEquals ( 3, bs. length() )
************************************
************************************
[+] input: JsonProcessingException { String endpoint = this.computeEndpoint(ConnectorEndpoint.CONNECTOR_STATUS); JsonNode expected = jsonMapper.createObjectNode().put("status", "OK"); byte[] responseBody = jsonMapper.writeValueAsBytes(expected); this.mockRestCall(endpoint, null, responseBody, HttpMethod.GET, HttpStatus.OK); JsonNode actual = connectorService.getConnectorStatus(NAMESPACE, NAME, CONNECTOR); "<AssertPlaceHolder>"; }
getConnectorStatus( String namespace, String name, String connector) {  String connectorStatusEndpoint = String.format("%s/status", this.computeConnectorsEndpoint(namespace, name, connector)); return this.executeRest(connectorStatusEndpoint, HttpMethod.GET, HttpStatus.OK); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: JsonProcessingException { Map<String, String> headers = this.computeHeaders(IMPORT_SCHEMA);  JoyceURI expectedRawUri = JoyceURI.createURI(MESSAGE_KEY).get(); JoyceURI actualRawUri = importService.computeRawURI(MESSAGE_KEY, headers);  "<AssertPlaceHolder>"; }
computeRawURI( @RawUri String messageKey, Map<String, String> headers) throws JsonProcessingException {  if (headers.get(KafkaCustomHeaders.IMPORT_SCHEMA) == null) {  ConnectKeyPayload key = jsonMapper.readValue(messageKey, ConnectKeyPayload.class); checkValidKey(key); return JoyceURI.make(JoyceURI.Type.RAW, JoyceURI.Subtype.OTHER, key.getSource(), key.getUid()); }  return JoyceURI.createURI(messageKey) .orElseThrow(() -> new InvalidJoyceUriException(String.format("Uri [%s] is not a valid Joyce Uri", messageKey))); }
[*] target: assertEquals(expectedRawUri, actualRawUri)
[-] pred: org. junit. Assert. assertEquals ( expectedRawUri, actualRawUri )
************************************
************************************
[+] input: JsonProcessingException { Map<String, String> headers = this.computeHeaders(null); String messageKey = this.computeResourceAsString(TEST_COMPLEX_MESSAGE_KEY_CORRECT);  JoyceURI expectedRawUri = JoyceURI.createURI(MESSAGE_KEY).get(); JoyceURI actualRawUri = importService.computeRawURI(messageKey, headers);  "<AssertPlaceHolder>"; }
computeRawURI( @RawUri String messageKey, Map<String, String> headers) throws JsonProcessingException {  if (headers.get(KafkaCustomHeaders.IMPORT_SCHEMA) == null) {  ConnectKeyPayload key = jsonMapper.readValue(messageKey, ConnectKeyPayload.class); checkValidKey(key); return JoyceURI.make(JoyceURI.Type.RAW, JoyceURI.Subtype.OTHER, key.getSource(), key.getUid()); }  return JoyceURI.createURI(messageKey) .orElseThrow(() -> new InvalidJoyceUriException(String.format("Uri [%s] is not a valid Joyce Uri", messageKey))); }
[*] target: assertEquals(expectedRawUri, actualRawUri)
[-] pred: org. junit. Assert. assertEquals ( expectedRawUri, actualRawUri )
************************************
************************************
[+] input: JsonProcessingException { Map<String, String> headers = this.computeHeaders(IMPORT_SCHEMA);  JoyceURI expectedSchemaUri = JoyceURI.createURI(IMPORT_SCHEMA).get(); JoyceURI actualSchemaUri = importService.computeValidSchemaUri(null, headers, null);  "<AssertPlaceHolder>"; }
computeValidSchemaUri( String messageKey, Map<String, String> headers, @RawUri JoyceURI rawUri) throws JsonProcessingException {  return this.computeSchemaUri(messageKey, headers) .filter(joyceURI -> JoyceURI.Subtype.IMPORT.equals(joyceURI.getSubtype())) .orElseThrow( () -> new InvalidJoyceUriException( String.format("Schema is not a valid schema uri. key: %s", messageKey)) ); }
[*] target: assertEquals(expectedSchemaUri, actualSchemaUri)
[-] pred: org. junit. Assert. assertEquals ( expectedSchemaUri, actualSchemaUri )
************************************
************************************
[+] input: JsonProcessingException { Map<String, String> headers = this.computeHeaders(null); String messageKey = this.computeResourceAsString(TEST_COMPLEX_MESSAGE_KEY_CORRECT);  JoyceURI expectedSchemaUri = JoyceURI.createURI(IMPORT_SCHEMA).get(); JoyceURI actualSchemaUri = importService.computeValidSchemaUri(messageKey, headers, null);  "<AssertPlaceHolder>"; }
computeValidSchemaUri( String messageKey, Map<String, String> headers, @RawUri JoyceURI rawUri) throws JsonProcessingException {  return this.computeSchemaUri(messageKey, headers) .filter(joyceURI -> JoyceURI.Subtype.IMPORT.equals(joyceURI.getSubtype())) .orElseThrow( () -> new InvalidJoyceUriException( String.format("Schema is not a valid schema uri. key: %s", messageKey)) ); }
[*] target: assertEquals(expectedSchemaUri, actualSchemaUri)
[-] pred: org. junit. Assert. assertEquals ( expectedSchemaUri, actualSchemaUri )
************************************
************************************
[+] input: IOException {  // mocking and stubbing data for test execution SchemaEntity schema = computeSchema(TEST_SCHEMA_JSON_USER); JoyceURI rawURI = JoyceURI.createURI(MESSAGE_KEY).orElseThrow(); when(schemaUtils.metadataFromSchemaOrElseThrow(any())).thenReturn(schema.getMetadata()); when(jsonLogicService.filter(any(), any())).thenReturn(true); when(schemaEngine.process(any(SchemaEntity.class), any(), any())) .thenReturn(objectMapper.valueToTree(Map.of("code", "1337")));  // Subject under test SingleImportResult expected = new SingleImportResult(rawURI, ProcessStatus.IMPORTED, null); SingleImportResult actual = importService.processImport(rawURI, computeDocument(TEST_USER_JSON), schema);  // Asserts "<AssertPlaceHolder>"; }
processImport( @RawUri JoyceURI rawUri, @EventPayload JsonNode document, SchemaEntity schema) {  JoyceSchemaMetadata metadata = schemaUtils.metadataFromSchemaOrElseThrow(schema); if (jsonLogicService.filter(document, metadata)) {  Span span = GlobalTracer.get().buildSpan("process").start(); span.setTag("uri", this.computeTracerUri(rawUri));  JsonNode result = schemaEngine.process(schema, document, null);  computeParentMetadata(metadata, result, true) .ifPresent(parentMetadata -> { metadata.setUidKey(parentMetadata.getUidKey()); metadata.setCollection(parentMetadata.getCollection()); metadata.setNamespace(parentMetadata.getNamespace()); });  JoyceURI contentURI = computeContentURI(result, metadata); span.finish();  contentProducer.publish(schema, rawUri, contentURI, result, metadata); return SingleImportResult.builder().uri(rawUri).processStatus(ProcessStatus.IMPORTED).build();  } else { log.info("Document with uri {} wasn't processed cause it didn't pass metadata filter.", rawUri); return SingleImportResult.builder().uri(rawUri).processStatus(ProcessStatus.SKIPPED).build(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { // mocking and stubbing data for test execution SchemaEntity schema = computeSchema(TEST_SCHEMA_JSON_ENHANCED_USER); JoyceURI rawURI = JoyceURI.createURI(MESSAGE_KEY).orElseThrow(); when(schemaUtils.metadataFromSchemaOrElseThrow(any())).thenReturn(schema.getMetadata()); when(jsonLogicService.filter(any(), any())).thenReturn(true); when(schemaEngine.process(any(SchemaEntity.class), any(), any())) .thenReturn(objectMapper.valueToTree(Map.of("code", "1337"))); when(schemaService.get(any())) .thenReturn(Optional.of(computeSchema(TEST_SCHEMA_JSON_USER)));  SingleImportResult expected = new SingleImportResult(rawURI, ProcessStatus.IMPORTED, null); SingleImportResult actual = importService.processImport(rawURI, null, schema);  // asserts "<AssertPlaceHolder>"; }
processImport( @RawUri JoyceURI rawUri, @EventPayload JsonNode document, SchemaEntity schema) {  JoyceSchemaMetadata metadata = schemaUtils.metadataFromSchemaOrElseThrow(schema); if (jsonLogicService.filter(document, metadata)) {  Span span = GlobalTracer.get().buildSpan("process").start(); span.setTag("uri", this.computeTracerUri(rawUri));  JsonNode result = schemaEngine.process(schema, document, null);  computeParentMetadata(metadata, result, true) .ifPresent(parentMetadata -> { metadata.setUidKey(parentMetadata.getUidKey()); metadata.setCollection(parentMetadata.getCollection()); metadata.setNamespace(parentMetadata.getNamespace()); });  JoyceURI contentURI = computeContentURI(result, metadata); span.finish();  contentProducer.publish(schema, rawUri, contentURI, result, metadata); return SingleImportResult.builder().uri(rawUri).processStatus(ProcessStatus.IMPORTED).build();  } else { log.info("Document with uri {} wasn't processed cause it didn't pass metadata filter.", rawUri); return SingleImportResult.builder().uri(rawUri).processStatus(ProcessStatus.SKIPPED).build(); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldCallTheArrayMatcherIfTheTwoObjectAreArray() { final var array1 = new ArrayNode(null); final var array2 = new ArrayNode(null);  final var arrayMatcher = (PartialJsonMatcher<ArrayNode>) Mockito.mock(PartialJsonMatcher.class); final var compositeMatcher = new CompositeJsonMatcher( arrayMatcher, (PartialJsonMatcher<ObjectNode>) Mockito.mock(PartialJsonMatcher.class), (PartialJsonMatcher<ValueNode>) Mockito.mock(PartialJsonMatcher.class) ); final var expectedJsonDiff = Mockito.mock(JsonDiff.class); Mockito.when(arrayMatcher.jsonDiff(path, array1, array2, compositeMatcher)).thenReturn(expectedJsonDiff);  final var result = compositeMatcher.diff(path, array1, array2);  "<AssertPlaceHolder>"; }
diff(Path path, JsonNode expected, JsonNode received) { if (expected instanceof ObjectNode  && received instanceof ObjectNode) { return this.jsonObjectPartialMatcher.jsonDiff(path, (ObjectNode) expected, (ObjectNode) received, this); } else if (expected instanceof ArrayNode && received instanceof ArrayNode) { return this.jsonArrayPartialMatcher.jsonDiff(path, (ArrayNode) expected, (ArrayNode) received, this); } else if (expected instanceof ValueNode && received instanceof ValueNode){ return this.primitivePartialMatcher.jsonDiff(path, (ValueNode) expected, (ValueNode) received, this); } else { return new UnMatchedPrimaryDiff(path, expected, received); } }
[*] target: assertEquals(expectedJsonDiff, result)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonDiff, result )
************************************
************************************
[+] input: shouldCallTheObjectMatcherIfTheTwoObjectAreObject() { final var object1 = new ObjectNode(null); final var object2 = new ObjectNode(null);  final var objectMatcher = (PartialJsonMatcher<ObjectNode>) Mockito.mock(PartialJsonMatcher.class); final var compositeMatcher = new CompositeJsonMatcher( (PartialJsonMatcher<ArrayNode>) Mockito.mock(PartialJsonMatcher.class), objectMatcher, (PartialJsonMatcher<ValueNode>) Mockito.mock(PartialJsonMatcher.class) ); final var expectedJsonDiff = Mockito.mock(JsonDiff.class); Mockito.when(objectMatcher.jsonDiff(path, object1, object2, compositeMatcher)).thenReturn(expectedJsonDiff);  final var result = compositeMatcher.diff(path, object1, object2);  "<AssertPlaceHolder>"; }
diff(Path path, JsonNode expected, JsonNode received) { if (expected instanceof ObjectNode  && received instanceof ObjectNode) { return this.jsonObjectPartialMatcher.jsonDiff(path, (ObjectNode) expected, (ObjectNode) received, this); } else if (expected instanceof ArrayNode && received instanceof ArrayNode) { return this.jsonArrayPartialMatcher.jsonDiff(path, (ArrayNode) expected, (ArrayNode) received, this); } else if (expected instanceof ValueNode && received instanceof ValueNode){ return this.primitivePartialMatcher.jsonDiff(path, (ValueNode) expected, (ValueNode) received, this); } else { return new UnMatchedPrimaryDiff(path, expected, received); } }
[*] target: assertEquals(expectedJsonDiff, result)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonDiff, result )
************************************
************************************
[+] input: shouldCallThePrimitiveMatcherIfTheTwoObjectAreValue() { final var value1 = TextNode.valueOf(""); final var value2 = IntNode.valueOf(10);  final var primitiveMatcher = (PartialJsonMatcher<ValueNode>) Mockito.mock(PartialJsonMatcher.class); final var compositeMatcher = new CompositeJsonMatcher( (PartialJsonMatcher<ArrayNode>) Mockito.mock(PartialJsonMatcher.class), (PartialJsonMatcher<ObjectNode>) Mockito.mock(PartialJsonMatcher.class), primitiveMatcher ); final var expectedJsonDiff = Mockito.mock(JsonDiff.class); Mockito.when(primitiveMatcher.jsonDiff(path, value1, value2, compositeMatcher)).thenReturn(expectedJsonDiff);  final var result = compositeMatcher.diff(path, value1, value2);  "<AssertPlaceHolder>"; }
diff(Path path, JsonNode expected, JsonNode received) { if (expected instanceof ObjectNode  && received instanceof ObjectNode) { return this.jsonObjectPartialMatcher.jsonDiff(path, (ObjectNode) expected, (ObjectNode) received, this); } else if (expected instanceof ArrayNode && received instanceof ArrayNode) { return this.jsonArrayPartialMatcher.jsonDiff(path, (ArrayNode) expected, (ArrayNode) received, this); } else if (expected instanceof ValueNode && received instanceof ValueNode){ return this.primitivePartialMatcher.jsonDiff(path, (ValueNode) expected, (ValueNode) received, this); } else { return new UnMatchedPrimaryDiff(path, expected, received); } }
[*] target: assertEquals(expectedJsonDiff, result)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonDiff, result )
************************************
************************************
[+] input: shouldCallTheDelegatedIfNodeHaveDifferentType() { final var value1 = IntNode.valueOf(100); final var value2 = TextNode.valueOf("100"); final var jsonMatcher = Mockito.mock(JsonMatcher.class); final var delegated = Mockito.mock(PartialJsonMatcher.class); final var expectedJsonDiff = Mockito.mock(JsonDiff.class); Mockito.when(delegated.jsonDiff(expectedPath, value1, value2, jsonMatcher)).thenReturn(expectedJsonDiff);  final var jsonDiff = new LenientNumberPrimitivePartialMatcher(delegated) .jsonDiff(expectedPath, value1, value2, jsonMatcher);  "<AssertPlaceHolder>"; }
jsonDiff(Path path, ValueNode expectedValue, ValueNode receivedValue, JsonMatcher jsonMatcher) { if (expectedValue instanceof NumericNode && receivedValue instanceof NumericNode) { final var expectedIntValue = expectedValue.intValue(); final var actualIntValue = receivedValue.intValue(); final var expectedDecimalValue = receivedValue.doubleValue() % 1; final var actualDecimalValue = expectedValue.doubleValue() % 1;  if (expectedIntValue != actualIntValue || expectedDecimalValue != actualDecimalValue) { return new UnMatchedPrimaryDiff(path, expectedValue, receivedValue); } else { return new MatchedPrimaryDiff(path, expectedValue); } }  return delegated.jsonDiff(path, expectedValue, receivedValue, jsonMatcher); }
[*] target: assertEquals(expectedJsonDiff, jsonDiff)
[-] pred: org. junit. Assert. assertEquals ( expectedJsonDiff, jsonDiff )
************************************
************************************
[+] input: canBuildAnOnlyErrorDiffViewerFromJsonDiff() { final var jsonDiff = new UnMatchedPrimaryDiff(path, TextNode.valueOf("a"), TextNode.valueOf("b"));  final var result = OnlyErrorDiffViewer.from(jsonDiff);  final var expected = "The property "$.a" didn't match. Expected "a", Received: "b"\n"; "<AssertPlaceHolder>"; }
toString() { return stringBuilder.toString(); }
[*] target: assertEquals(expected, result.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, result. toString ( ) )
************************************
************************************
[+] input: convertToDatabaseColumnNull() { AnimalClassificacaoEtariaConverter animalConverter = new AnimalClassificacaoEtariaConverter(); String s = animalConverter.convertToDatabaseColumn(null); "<AssertPlaceHolder>"; }
convertToDatabaseColumn(AnimalClassificacaoEtaria classificacaoEtaria) { if(classificacaoEtaria == null) { return null; } return classificacaoEtaria.getDescricao(); }
[*] target: assertNull(s)
[-] pred: org. junit. Assert. assertNull ( s )
************************************
************************************
[+] input: convertToEntityAttributeNull() { AnimalClassificacaoEtariaConverter animalConverter = new AnimalClassificacaoEtariaConverter(); AnimalClassificacaoEtaria convert = animalConverter.convertToEntityAttribute(null); "<AssertPlaceHolder>"; }
convertToEntityAttribute(String descricao) { if(descricao == null) { return null; }  return AnimalClassificacaoEtaria.of(descricao); }
[*] target: assertNull(convert)
[-] pred: org. junit. Assert. assertNull ( convert )
************************************
************************************
[+] input: convertToDatabaseColumnNull() { AnimalPorteConverter converter = new AnimalPorteConverter(); String convert = converter.convertToDatabaseColumn(null); "<AssertPlaceHolder>"; }
convertToDatabaseColumn(AnimalPorte porte) { if(porte == null) { return null; } return porte.getDescricao(); }
[*] target: assertNull(convert)
[-] pred: org. junit. Assert. assertNull ( convert )
************************************
************************************
[+] input: convertToEntityAttributeNull() { AnimalPorteConverter converter = new AnimalPorteConverter(); AnimalPorte convert = converter.convertToEntityAttribute(null); "<AssertPlaceHolder>"; }
convertToEntityAttribute(String descricao) { if(descricao == null) { return null; }  return AnimalPorte.of(descricao); }
[*] target: assertNull(convert)
[-] pred: org. junit. Assert. assertNull ( convert )
************************************
************************************
[+] input: convertToDatabaseColumnNull() { AnimalSexoConverter converter = new AnimalSexoConverter(); String s = converter.convertToDatabaseColumn(null); "<AssertPlaceHolder>"; }
convertToDatabaseColumn(AnimalSexo sexo) { if(sexo == null) { return null; } return sexo.getDescricao(); }
[*] target: assertNull(s)
[-] pred: org. junit. Assert. assertNull ( s )
************************************
************************************
[+] input: convertToEntityAttributeNull() { AnimalSexoConverter converter = new AnimalSexoConverter(); AnimalSexo convert = converter.convertToEntityAttribute(null); "<AssertPlaceHolder>"; }
convertToEntityAttribute(String descricao) { if(descricao == null) { return null; }  return AnimalSexo.of(descricao); }
[*] target: assertNull(convert)
[-] pred: org. junit. Assert. assertNull ( convert )
************************************
************************************
[+] input: convertToDatabaseColumnNull() { AnimalTipoConverter converter = new AnimalTipoConverter(); String convert = converter.convertToDatabaseColumn(null); "<AssertPlaceHolder>"; }
convertToDatabaseColumn(AnimalTipo tipo) { if(tipo == null) { return null; } return tipo.getDescricao(); }
[*] target: assertNull(convert)
[-] pred: org. junit. Assert. assertNull ( convert )
************************************
************************************
[+] input: convertToEntityAttributeNull() { AnimalTipoConverter converter = new AnimalTipoConverter(); AnimalTipo convert = converter.convertToEntityAttribute(null); "<AssertPlaceHolder>"; }
convertToEntityAttribute(String descricao) { if(descricao == null) { return null; }  return AnimalTipo.of(descricao); }
[*] target: assertNull(convert)
[-] pred: org. junit. Assert. assertNull ( convert )
************************************
************************************
[+] input: convertToDatabaseColumnNull() { AnuncioStatusConverter converter = new AnuncioStatusConverter(); String convert = converter.convertToDatabaseColumn(null); "<AssertPlaceHolder>"; }
convertToDatabaseColumn(AnuncioStatus status) { if(status == null) { return null; } return status.getDescricao(); }
[*] target: assertNull(convert)
[-] pred: org. junit. Assert. assertNull ( convert )
************************************
************************************
[+] input: convertToEntityAttributeNull() { AnuncioStatusConverter converter = new AnuncioStatusConverter(); AnuncioStatus convert = converter.convertToEntityAttribute(null); "<AssertPlaceHolder>"; }
convertToEntityAttribute(String descricao) { if(descricao == null) { return null; }  return AnuncioStatus.of(descricao); }
[*] target: assertNull(convert)
[-] pred: org. junit. Assert. assertNull ( convert )
************************************
************************************
[+] input: loadUserByUsername() { UserDetails nome = this.autenticacaoService.loadUserByUsername("testeautenticacaoservice@example.com"); "<AssertPlaceHolder>"; }
loadUserByUsername(String username) { Optional<Pessoa> p = service.getPersonByEmail(username);  if (p.isPresent()) { return p.get(); }  throw new UsernameNotFoundException("Dados inválidos!"); }
[*] target: assertNotNull(nome)
[-] pred: org. junit. Assert. assertNotNull ( nome )
************************************
************************************
[+] input: testIsClusterExists() { when(mockClusterPhyService.isClusterExists(CLUSTER)).thenReturn(false);  final boolean result = clusterPhyManager.isClusterExists(CLUSTER);  "<AssertPlaceHolder>"; }
isClusterExists(String clusterName);  /** * 获取控制台物理集群信息列表(ZH有使用) * @param param 查询参数 * @return 物理集群列表 */ List<ClusterPhyVO> listClusterPhys(ClusterPhyDTO param);  /** * 构建客户端需要的数据 * * @param clusterPhyList  集群列表源数据 * @return */ List<ClusterPhyVO> buildClusterInfo(List<ClusterPhy> clusterPhyList);  /** * 获取单个物理集群overView信息 * @param clusterId 物理集群id * @param currentProjectId 当前登录项目 * @return 物理集群信息 */ ClusterPhyVO getClusterPhyOverview(Integer clusterId, Integer currentProjectId);  /** * 获取逻辑集群可关联region的物理集群名称列表 * @param clusterLogicType 逻辑集群类型 * @param clusterLogicId   逻辑集群Id * @see ClusterResourceTypeEnum * @return 物理集群名称 */ Result<List<String>> listCanBeAssociatedRegionOfClustersPhys(Integer clusterLogicType, Long clusterLogicId);  /** * 获取新建逻辑集群可关联的物理集群名称 * @param clusterLogicType  逻辑集群类型 * @see ClusterResourceTypeEnum * @return 物理集群名称 */ Result<List<String>> listCanBeAssociatedClustersPhys(Integer clusterLogicType);  /** * 集群接入 * * @param param     逻辑集群Id, 物理集群名称 * @param operator  操作人 * @param projectId * @return ClusterPhyVO */ Result<ClusterPhyVO> joinCluster(ClusterJoinDTO param, String operator, Integer projectId);  /** * 删除接入集群 删除顺序: region ——> clusterLogic ——> clusterHost ——> clusterRole  ——> cluster * * @param clusterId 集群id * @param operator  操作人 * @param projectId * @return {@link Result}
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testUpdatePhyClusterDynamicConfig() { final ClusterSettingDTO param = new ClusterSettingDTO("clusterName", "key", "value"); final Result<Boolean> expectedResult = Result.buildFail(false); when(mockClusterPhyService.updatePhyClusterDynamicConfig(new ClusterSettingDTO("clusterName", "key", "value"))) .thenReturn(Result.buildFail(false)); Integer projectId = 1; final Result<Boolean> result; try { result = clusterPhyManager.updatePhyClusterDynamicConfig(param, "operator", projectId); } catch (ESOperateException e) { throw new RuntimeException(e); }  "<AssertPlaceHolder>"; }
updatePhyClusterDynamicConfig(ClusterSettingDTO param, String operator, Integer projectId) throws ESOperateException ;  /** * 获取集群下的属性配置 * @param cluster 集群名称 * @return result */ Result<Set<String>> getRoutingAllocationAwarenessAttributes(String cluster);  /** * 获取APP有管理、读写、读权限的物理集群名称列表 * * @param projectId projectId * @return {@link List}
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testListClusterRolesByClusterId() { // Setup final List<ClusterRoleInfo> expectedResult = Arrays.asList(new ClusterRoleInfo(0L, 0L, "roleClusterName", "role", 0, 0, "machineSpec", "esVersion", 0, "plugIds", false, Arrays.asList(new ClusterRoleHost(0L, 0L, "hostname", "ip", CLUSTER, "port", 0, 0, "rack", "nodeSet", "machineSpec", 0, "attributes"))));  // Configure ClusterRoleService.getAllRoleClusterByClusterId(...). final List<ClusterRoleInfo> clusterRoleInfos = Arrays.asList(new ClusterRoleInfo(0L, 0L, "roleClusterName", "role", 0, 0, "machineSpec", "esVersion", 0, "plugIds", false, Arrays.asList(new ClusterRoleHost(0L, 0L, "hostname", "ip", CLUSTER, "port", 0, 0, "rack", "nodeSet", "machineSpec", 0, "attributes")))); when(mockClusterRoleService.getAllRoleClusterByClusterId(0)).thenReturn(clusterRoleInfos);  // Run the test final List<ClusterRoleInfo> result = clusterPhyManager.listClusterRolesByClusterId(0);  // Verify the results "<AssertPlaceHolder>"; }
listClusterRolesByClusterId(Integer clusterId);  /** * 根据集群名称获获取集群节点列表 * * @param cluster 集群名称 * @return {@link List}
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: returnsNullWhenNicknameDoesntExist() { var cm = CoinmasterRegistry.findCoinmasterByNickname("thisdoesntexist"); "<AssertPlaceHolder>"; }
findCoinmasterByNickname(final String nickname) { List<String> matchingNames = StringUtilities.getMatchingNames(NICKNAMES, nickname);  if (matchingNames.size() != 1) { return null; }  String name = matchingNames.get(0);  return Arrays.stream(COINMASTERS) .filter(data -> name.equalsIgnoreCase(data.getNickname())) .findAny() .orElse(null); }
[*] target: assertNull(cm)
[-] pred: org. junit. Assert. assertNull ( cm )
************************************
************************************
[+] input: returnsNullWhenBuyerDoesntExist() { var cm = CoinmasterRegistry.findBuyer(ItemPool.SEAL_CLUB); "<AssertPlaceHolder>"; }
findBuyer(final int itemId) { if (itemId == -1) { return null; }  return Arrays.stream(COINMASTERS) .filter(data -> data.canSellItem(itemId)) .findAny() .orElse(null); }
[*] target: assertNull(cm)
[-] pred: org. junit. Assert. assertNull ( cm )
************************************
************************************
[+] input: returnsNullWhenSellerDoesntExist() { var cm = CoinmasterRegistry.findSeller(ItemPool.SEAL_CLUB); "<AssertPlaceHolder>"; }
findSeller(final int itemId) { return Arrays.stream(COINMASTERS) .filter(data -> data.canBuyItem(itemId)) .findAny() .orElse(null); }
[*] target: assertNull(cm)
[-] pred: org. junit. Assert. assertNull ( cm )
************************************
************************************
[+] input: mustBeOnElVibratoIsland() { var cleanups = new Cleanups( withLastLocation("Haunted Pantry"), withFight(1), withNextMonster("lonely construct")); try (cleanups) { String input = html; StringBuffer page = new StringBuffer(input); ElVibratoManager.decorate(page); String result = page.toString(); // Undecorated "<AssertPlaceHolder>"; } }
decorate(final StringBuffer buffer) { // If we are not on El Vibrato Island, nothing to do. KoLAdventure location = KoLAdventure.lastVisitedLocation; if (location == null || location.getAdventureNumber() != AdventurePool.EL_VIBRATO_ISLAND) { return; }  // If the fight is over, punt if (FightRequest.getCurrentRound() == 0) { return; }  MonsterData monster = MonsterStatusTracker.getLastMonster(); if (!isElVibratoConstruct(monster)) { // Unfortunately, wanders can intrude return; }  int index = buffer.lastIndexOf("</table></center></td>"); if (index != -1) { StringBuilder table = new StringBuilder("<tr><td><center>"); generateTable(table, monster); table.append("</center></td></tr>"); buffer.insert(index, table); } }
[*] target: assertEquals(input, result)
[-] pred: org. junit. Assert. assertEquals ( input, result )
************************************
************************************
[+] input: mustBeInFight() { var cleanups = new Cleanups( withLastLocation("El Vibrato Island"), withFight(0), withNextMonster("lonely construct")); try (cleanups) { String input = html; StringBuffer page = new StringBuffer(input); ElVibratoManager.decorate(page); String result = page.toString(); // Undecorated "<AssertPlaceHolder>"; } }
decorate(final StringBuffer buffer) { // If we are not on El Vibrato Island, nothing to do. KoLAdventure location = KoLAdventure.lastVisitedLocation; if (location == null || location.getAdventureNumber() != AdventurePool.EL_VIBRATO_ISLAND) { return; }  // If the fight is over, punt if (FightRequest.getCurrentRound() == 0) { return; }  MonsterData monster = MonsterStatusTracker.getLastMonster(); if (!isElVibratoConstruct(monster)) { // Unfortunately, wanders can intrude return; }  int index = buffer.lastIndexOf("</table></center></td>"); if (index != -1) { StringBuilder table = new StringBuilder("<tr><td><center>"); generateTable(table, monster); table.append("</center></td></tr>"); buffer.insert(index, table); } }
[*] target: assertEquals(input, result)
[-] pred: org. junit. Assert. assertEquals ( input, result )
************************************
************************************
[+] input: mustBeFightingConstruct() { var cleanups = new Cleanups( withLastLocation("El Vibrato Island"), withFight(1), withNextMonster("migratory pirate")); try (cleanups) { String input = html; StringBuffer page = new StringBuffer(input); ElVibratoManager.decorate(page); String result = page.toString(); // Undecorated "<AssertPlaceHolder>"; } }
decorate(final StringBuffer buffer) { // If we are not on El Vibrato Island, nothing to do. KoLAdventure location = KoLAdventure.lastVisitedLocation; if (location == null || location.getAdventureNumber() != AdventurePool.EL_VIBRATO_ISLAND) { return; }  // If the fight is over, punt if (FightRequest.getCurrentRound() == 0) { return; }  MonsterData monster = MonsterStatusTracker.getLastMonster(); if (!isElVibratoConstruct(monster)) { // Unfortunately, wanders can intrude return; }  int index = buffer.lastIndexOf("</table></center></td>"); if (index != -1) { StringBuilder table = new StringBuilder("<tr><td><center>"); generateTable(table, monster); table.append("</center></td></tr>"); buffer.insert(index, table); } }
[*] target: assertEquals(input, result)
[-] pred: org. junit. Assert. assertEquals ( input, result )
************************************
************************************
[+] input: mustHaveNormalPage() { var cleanups = new Cleanups( withLastLocation("El Vibrato Island"), withFight(1), withNextMonster("lonely construct")); try (cleanups) { String input = "hello"; StringBuffer page = new StringBuffer(input); ElVibratoManager.decorate(page); String result = page.toString(); // Undecorated "<AssertPlaceHolder>"; } }
decorate(final StringBuffer buffer) { // If we are not on El Vibrato Island, nothing to do. KoLAdventure location = KoLAdventure.lastVisitedLocation; if (location == null || location.getAdventureNumber() != AdventurePool.EL_VIBRATO_ISLAND) { return; }  // If the fight is over, punt if (FightRequest.getCurrentRound() == 0) { return; }  MonsterData monster = MonsterStatusTracker.getLastMonster(); if (!isElVibratoConstruct(monster)) { // Unfortunately, wanders can intrude return; }  int index = buffer.lastIndexOf("</table></center></td>"); if (index != -1) { StringBuilder table = new StringBuilder("<tr><td><center>"); generateTable(table, monster); table.append("</center></td></tr>"); buffer.insert(index, table); } }
[*] target: assertEquals(input, result)
[-] pred: org. junit. Assert. assertEquals ( input, result )
************************************
************************************
[+] input: testCompileAndEvaluateWithConstants() { boolean result = SimpleProposition.compileAndEvaluate("1 == 1", null); "<AssertPlaceHolder>"; }
compileAndEvaluate(String expression, Map<String, Object> context) { String[] tokens = tokenize(expression); if (tokens.length == 0) { throw new ExpressionException("[EL] No supporting operators found", expression); } if (context == null) { context = Collections.emptyMap(); }  String[] literals = Arrays.copyOfRange(tokens, 1, tokens.length); Object[] operands = parse(literals, context); return evaluate(tokens[0], operands); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testFinalPositionOfSnakeAllCommands() { List<String> commands = List.of("UP", "DOWN", "LEFT", "RIGHT"); int result = new Solution().finalPositionOfSnake(3, commands); "<AssertPlaceHolder>"; }
finalPositionOfSnake(int n, List<String> commands) { int x = 0; int y = 0; for (String command : commands) { switch (command) { case "UP": if (x > 0) { x--; } break; case "DOWN": if (x < n - 1) { x++; } break; case "LEFT": if (y > 0) { y--; } break; case "RIGHT": if (y < n - 1) { y++; } break; default: break; } } return (x * n) + y; }
[*] target: assertEquals(4, result)
[-] pred: org. junit. Assert. assertEquals ( 4, result )
************************************
************************************
[+] input: testFinalPositionOfSnakeOnlyUp() { List<String> commands = List.of("UP", "UP"); int result = new Solution().finalPositionOfSnake(3, commands); "<AssertPlaceHolder>"; }
finalPositionOfSnake(int n, List<String> commands) { int x = 0; int y = 0; for (String command : commands) { switch (command) { case "UP": if (x > 0) { x--; } break; case "DOWN": if (x < n - 1) { x++; } break; case "LEFT": if (y > 0) { y--; } break; case "RIGHT": if (y < n - 1) { y++; } break; default: break; } } return (x * n) + y; }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 0, result )
************************************
************************************
[+] input: testFinalPositionOfSnakeOnlyDown() { List<String> commands = List.of("DOWN", "DOWN"); int result = new Solution().finalPositionOfSnake(3, commands); "<AssertPlaceHolder>"; }
finalPositionOfSnake(int n, List<String> commands) { int x = 0; int y = 0; for (String command : commands) { switch (command) { case "UP": if (x > 0) { x--; } break; case "DOWN": if (x < n - 1) { x++; } break; case "LEFT": if (y > 0) { y--; } break; case "RIGHT": if (y < n - 1) { y++; } break; default: break; } } return (x * n) + y; }
[*] target: assertEquals(6, result)
[-] pred: org. junit. Assert. assertEquals ( 6, result )
************************************
************************************
[+] input: testFinalPositionOfSnakeOnlyLeft() { List<String> commands = List.of("LEFT", "LEFT"); int result = new Solution().finalPositionOfSnake(3, commands); "<AssertPlaceHolder>"; }
finalPositionOfSnake(int n, List<String> commands) { int x = 0; int y = 0; for (String command : commands) { switch (command) { case "UP": if (x > 0) { x--; } break; case "DOWN": if (x < n - 1) { x++; } break; case "LEFT": if (y > 0) { y--; } break; case "RIGHT": if (y < n - 1) { y++; } break; default: break; } } return (x * n) + y; }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 0, result )
************************************
************************************
[+] input: testFinalPositionOfSnakeEmptyCommands() { List<String> commands = List.of(); int result = new Solution().finalPositionOfSnake(3, commands); "<AssertPlaceHolder>"; }
finalPositionOfSnake(int n, List<String> commands) { int x = 0; int y = 0; for (String command : commands) { switch (command) { case "UP": if (x > 0) { x--; } break; case "DOWN": if (x < n - 1) { x++; } break; case "LEFT": if (y > 0) { y--; } break; case "RIGHT": if (y < n - 1) { y++; } break; default: break; } } return (x * n) + y; }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 0, result )
************************************
************************************
[+] input: testFinalPositionOfSnakeMixedCommands() { List<String> commands = List.of("DOWN", "RIGHT", "UP", "LEFT", "UP", "DOWN", "RIGHT"); int result = new Solution().finalPositionOfSnake(3, commands); "<AssertPlaceHolder>"; }
finalPositionOfSnake(int n, List<String> commands) { int x = 0; int y = 0; for (String command : commands) { switch (command) { case "UP": if (x > 0) { x--; } break; case "DOWN": if (x < n - 1) { x++; } break; case "LEFT": if (y > 0) { y--; } break; case "RIGHT": if (y < n - 1) { y++; } break; default: break; } } return (x * n) + y; }
[*] target: assertEquals(4, result)
[-] pred: org. junit. Assert. assertEquals ( 4, result )
************************************
************************************
[+] input: testFinalPositionOfSnakeInvalidCommands() { List<String> commands = List.of("DOWN", "RIGHT", "JUMP", "LEFT", "UP", "DOWN", "RIGHT"); int result = new Solution().finalPositionOfSnake(3, commands); "<AssertPlaceHolder>"; }
finalPositionOfSnake(int n, List<String> commands) { int x = 0; int y = 0; for (String command : commands) { switch (command) { case "UP": if (x > 0) { x--; } break; case "DOWN": if (x < n - 1) { x++; } break; case "LEFT": if (y > 0) { y--; } break; case "RIGHT": if (y < n - 1) { y++; } break; default: break; } } return (x * n) + y; }
[*] target: assertEquals(4, result)
[-] pred: org. junit. Assert. assertEquals ( 4, result )
************************************
************************************
[+] input: QueryParam() { //       OrderSearchParams orderSearchParams = new OrderSearchParams(); //       orderSearchParams.setPageSize(0); //       orderSearchParams.setPageNumber(10); //       IPage<OrderSimpleVO> orderVOIPage = orderService.queryByParams(orderSearchParams); //       Assertions."<AssertPlaceHolder>"; //       orderVOIPage.getRecords().forEach(System.out::println); }
queryByParams(OrderSearchParams orderSearchParams);
[*] target: assertNotNull(orderVOIPage)
[-] pred: org. junit. Assert. assertNotNull ( orderVOIPage )
************************************
************************************
[+] input: testShouldNotFilterShouldReturnTrueWhenRequestBaseUriIsPing() { //given when(request.getRequestURI()).thenReturn("/ping");  //when final boolean actual = underTest.shouldNotFilter(request);  //then Assertions."<AssertPlaceHolder>"; verify(request, atLeastOnce()).getRequestURI(); }
shouldNotFilter(@NonNull final HttpServletRequest request) { return skipUrisIfMatch.stream() .anyMatch(pattern -> antPathMatcher.matchStart(pattern, request.getRequestURI())); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: testConvertShouldReturnNullWhenCalledWithNull() { //given  //when final VaultModel actual = underTest.convert(null);  //then Assertions."<AssertPlaceHolder>"; }
convert(@Nullable final VaultFake source) { return Optional.ofNullable(source) .map(this::convertNonNull) .orElse(null); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: testConvertShouldReturnNullWhenCalledWithEmptyModel() { //given final KeyEntityId keyEntityId = TestConstantsKeys.UNVERSIONED_KEY_ENTITY_ID_1;  final KeyRotationPolicyModel model = new KeyRotationPolicyModel(); model.setId(keyEntityId.asRotationPolicyUri(HTTPS_LOCALHOST_8443)); model.setKeyEntityId(keyEntityId);  final KeyConverterRegistry registry = mock(KeyConverterRegistry.class); final KeyRotationPolicyV73ModelToEntityConverter underTest = new KeyRotationPolicyV73ModelToEntityConverter(registry);  //when final RotationPolicy actual = underTest.convert(model);  //then Assertions."<AssertPlaceHolder>"; }
convert(@Nullable final KeyRotationPolicyModel source) { return Optional.ofNullable(source) .filter(this::isNotEmpty) .map(this::convertNonNull) .orElse(null); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: testConvertShouldReturnNullWhenCalledWithoutAttributesAndEmptyList() { //given final KeyEntityId keyEntityId = TestConstantsKeys.UNVERSIONED_KEY_ENTITY_ID_1;  final KeyRotationPolicyModel model = new KeyRotationPolicyModel(); model.setId(keyEntityId.asRotationPolicyUri(HTTPS_LOCALHOST_8443)); model.setLifetimeActions(List.of()); model.setKeyEntityId(keyEntityId);  final KeyConverterRegistry registry = mock(KeyConverterRegistry.class); final KeyRotationPolicyV73ModelToEntityConverter underTest = new KeyRotationPolicyV73ModelToEntityConverter(registry);  //when final RotationPolicy actual = underTest.convert(model);  //then Assertions."<AssertPlaceHolder>"; }
convert(@Nullable final KeyRotationPolicyModel source) { return Optional.ofNullable(source) .filter(this::isNotEmpty) .map(this::convertNonNull) .orElse(null); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: testAsUriNoVersionShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = UNVERSIONED_CERT_ENTITY_ID_1;  //when final URI actual = underTest.asUriNoVersion(HTTPS_LOOP_BACK_IP);  //then final String expected = HTTPS_LOOP_BACK_IP + "/certificates/" + CERT_NAME_1; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, actual. toString ( ) )
************************************
************************************
[+] input: testAsUriShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = VERSIONED_CERT_ENTITY_ID_1_VERSION_3;  //when final URI actual = underTest.asUri(HTTPS_LOOP_BACK_IP);  //then final String expected = HTTPS_LOOP_BACK_IP + "/certificates/" + CERT_NAME_1 + "/" + CERT_VERSION_3; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, actual. toString ( ) )
************************************
************************************
[+] input: testAsUriWithQueryShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = VERSIONED_CERT_ENTITY_ID_1_VERSION_3; final String query = "?query=1";  //when final URI actual = underTest.asUri(HTTPS_LOOP_BACK_IP, query);  //then final String expected = HTTPS_LOOP_BACK_IP + "/certificates/" + CERT_NAME_1 + "/" + CERT_VERSION_3 + query; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, actual. toString ( ) )
************************************
************************************
[+] input: testAsRecoveryUriShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = VERSIONED_CERT_ENTITY_ID_1_VERSION_3;  //when final URI actual = underTest.asRecoveryUri(HTTPS_LOOP_BACK_IP);  //then final String expected = HTTPS_LOOP_BACK_IP + "/deletedcertificates/" + CERT_NAME_1; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, actual. toString ( ) )
************************************
************************************
[+] input: testAsPolicyUriShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = VERSIONED_CERT_ENTITY_ID_1_VERSION_3;  //when final URI actual = underTest.asPolicyUri(HTTPS_LOOP_BACK_IP);  //then final String expected = HTTPS_LOOP_BACK_IP + "/certificates/" + CERT_NAME_1 + "/" + CERT_VERSION_3 + "/policy"; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, actual. toString ( ) )
************************************
************************************
[+] input: testAsPendingOperationUriShouldReturnUriUsingAliasWhenCalledWithValidAlias() { //given final CertificateEntityId underTest = VERSIONED_CERT_ENTITY_ID_1_VERSION_3;  //when final URI actual = underTest.asPendingOperationUri(HTTPS_LOOP_BACK_IP);  //then final String expected = HTTPS_LOOP_BACK_IP + "/certificates/" + CERT_NAME_1 + "/pending"; Assertions."<AssertPlaceHolder>"; }
toString() { return asString(); }
[*] target: assertEquals(expected, actual.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, actual. toString ( ) )
************************************
************************************
[+] input: testGetLifetimeActionsShouldReturnTheMapSetPreviouslyWhenCalled() { //given final Map<CertificateLifetimeActionActivity, CertificateLifetimeActionTrigger> expected = Map.of(EMAIL_CONTACTS, new CertificateLifetimeActionTrigger(DAYS_BEFORE_EXPIRY, 10)); final CertificateLifetimeActionPolicy underTest = new CertificateLifetimeActionPolicy(UNVERSIONED_CERT_ENTITY_ID_1, expected);  //when final Map<CertificateLifetimeActionActivity, CertificateLifetimeActionTrigger> actual = underTest.getLifetimeActions();  //then Assertions."<AssertPlaceHolder>"; }
getLifetimeActions() { return lifetimeActions; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testSetLifetimeActionsShouldOverwriteTheMapWhenCalledWithValidData() { //given final Map<CertificateLifetimeActionActivity, CertificateLifetimeActionTrigger> expected = Map.of(EMAIL_CONTACTS, new CertificateLifetimeActionTrigger(DAYS_BEFORE_EXPIRY, 10)); final CertificateLifetimeActionPolicy underTest = new CertificateLifetimeActionPolicy(UNVERSIONED_CERT_ENTITY_ID_1, Map.of());  //when underTest.setLifetimeActions(expected);  //then final Map<CertificateLifetimeActionActivity, CertificateLifetimeActionTrigger> actual = underTest.getLifetimeActions(); Assertions."<AssertPlaceHolder>"; }
getLifetimeActions() { return lifetimeActions; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testIsAutoRenewShouldReturnFalseWhenCalledWithOnlyEmailContactsSet() { //given final Map<CertificateLifetimeActionActivity, CertificateLifetimeActionTrigger> expected = Map.of(EMAIL_CONTACTS, new CertificateLifetimeActionTrigger(DAYS_BEFORE_EXPIRY, 10)); final CertificateLifetimeActionPolicy underTest = new CertificateLifetimeActionPolicy(UNVERSIONED_CERT_ENTITY_ID_1, expected);  //when final boolean actual = underTest.isAutoRenew();  //then Assertions."<AssertPlaceHolder>"; }
isAutoRenew() { return getLifetimeActions().containsKey(CertificateLifetimeActionActivity.AUTO_RENEW); }
[*] target: assertFalse(actual)
[-] pred: org. junit. Assert. assertFalse ( actual )
************************************
************************************
[+] input: testIsAutoRenewShouldReturnTrueWhenCalledWithBothTypesInMap() { //given final CertificateLifetimeActionTrigger trigger = new CertificateLifetimeActionTrigger(DAYS_BEFORE_EXPIRY, 10); final Map<CertificateLifetimeActionActivity, CertificateLifetimeActionTrigger> expected = Map .of(EMAIL_CONTACTS, trigger, AUTO_RENEW, trigger); final CertificateLifetimeActionPolicy underTest = new CertificateLifetimeActionPolicy(UNVERSIONED_CERT_ENTITY_ID_1, expected);  //when final boolean actual = underTest.isAutoRenew();  //then Assertions."<AssertPlaceHolder>"; }
isAutoRenew() { return getLifetimeActions().containsKey(CertificateLifetimeActionActivity.AUTO_RENEW); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: testGetEncodedCertificateSignRequestShouldReturnNullWhenCsrIsMissing() { //given final CertificateCreationInput input = CertificateCreationInput.builder() .validityStart(NOW) .subject("CN=" + LOCALHOST) .upns(Set.of(LOOP_BACK_IP)) .name(CERT_NAME_1) .dnsNames(Set.of(LOWKEY_VAULT)) .enableTransparency(false) .certAuthorityType(UNKNOWN) .contentType(CertContentType.PEM) .certificateType(null) .keyType(KeyType.EC) .keyCurveName(KeyCurveName.P_521) .extendedKeyUsage(Set.of("1.3.6.1.5.5.7.3.1", "1.3.6.1.5.5.7.3.2")) .keyUsage(Set.of(KeyUsageEnum.KEY_ENCIPHERMENT)) .reuseKeyOnRenewal(true) .validityMonths(VALIDITY_MONTHS) .exportablePrivateKey(true) .build();  final VaultFake vault = new VaultFakeImpl(HTTPS_LOCALHOST_8443); final KeyVaultCertificateEntity entity = spy(new KeyVaultCertificateEntity(CERT_NAME_1, input, vault)); doReturn(null).when(entity).getCertificateSigningRequest();  //when final byte[] actual = entity.getEncodedCertificateSigningRequest();  //then Assertions."<AssertPlaceHolder>"; }
getEncodedCertificateSigningRequest() { try { byte[] encoded = null; if (getCertificateSigningRequest() != null) { encoded = getCertificateSigningRequest().getEncoded(); } return encoded; } catch (final Exception e) { throw new CryptoException("Failed to obtain encoded certificate signing request: " + getId().toString(), e); } }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: testContainsNameShouldReturnTrueWhenCalledWithExistingKey() { //given putAllMocks();  //when final boolean actual = underTest.containsName(KEY_NAME_1);  //then Assertions."<AssertPlaceHolder>"; }
containsName(@NonNull final String name) { return entities.containsKey(name); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: testContainsNameShouldReturnFalseWhenCalledWithNonExistingKey() { //given underTest.put(VERSIONED_KEY_ENTITY_ID_1_VERSION_1, key1Version1Mock);  //when final boolean actual = underTest.containsName(KEY_NAME_2);  //then Assertions."<AssertPlaceHolder>"; }
containsName(@NonNull final String name) { return entities.containsKey(name); }
[*] target: assertFalse(actual)
[-] pred: org. junit. Assert. assertFalse ( actual )
************************************
************************************
[+] input: testContainsEntityShouldReturnTrueWhenCalledWithExistingKey() { //given putAllMocks();  //when final boolean actual = underTest.containsEntity(VERSIONED_KEY_ENTITY_ID_1_VERSION_1);  //then Assertions."<AssertPlaceHolder>"; }
containsEntity(@NonNull final K entityId) { return containsName(entityId.id()) && entities.get(entityId.id()).containsKey(entityId.version()); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: testContainsEntityShouldReturnFalseWhenCalledWithNonExistingKeyVersion() { //given putAllMocks();  //when final boolean actual = underTest.containsEntity(VERSIONED_KEY_ENTITY_ID_3_VERSION_3);  //then Assertions."<AssertPlaceHolder>"; }
containsEntity(@NonNull final K entityId) { return containsName(entityId.id()) && entities.get(entityId.id()).containsKey(entityId.version()); }
[*] target: assertFalse(actual)
[-] pred: org. junit. Assert. assertFalse ( actual )
************************************
************************************
[+] input: testContainsEntityShouldReturnFalseWhenCalledWithNonExistingKeyName() { //given  //when final boolean actual = underTest.containsEntity(VERSIONED_KEY_ENTITY_ID_3_VERSION_3);  //then Assertions."<AssertPlaceHolder>"; }
containsEntity(@NonNull final K entityId) { return containsName(entityId.id()) && entities.get(entityId.id()).containsKey(entityId.version()); }
[*] target: assertFalse(actual)
[-] pred: org. junit. Assert. assertFalse ( actual )
************************************
************************************
[+] input: testKeyVaultFakeShouldNeverBeNullWhenCalled() { //given final VaultFakeImpl underTest = new VaultFakeImpl(HTTPS_LOCALHOST);  //when final KeyVaultFake actual = underTest.keyVaultFake();  //then Assertions."<AssertPlaceHolder>"; }
keyVaultFake() { return keys; }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: testSecretVaultFakeShouldNeverBeNullWhenCalled() { //given final VaultFakeImpl underTest = new VaultFakeImpl(HTTPS_LOCALHOST);  //when final SecretVaultFake actual = underTest.secretVaultFake();  //then Assertions."<AssertPlaceHolder>"; }
secretVaultFake() { return secrets; }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: testGetCryptoClientShouldReturnClientWhenCalled() { //given final ApacheHttpClientProvider underTest = new ApacheHttpClientProvider(HTTPS_SPECIAL_LOCALHOST_8443, new AuthorityOverrideFunction(SPECIAL_LOCALHOST, LOCALHOST));  //when final CryptographyClient client = underTest.getCryptoClient(WEB_KEY_ID);  //then Assertions."<AssertPlaceHolder>"; }
getCryptoClient(final String webKeyId) { return getCryptoClient(webKeyId, CryptographyServiceVersion.V7_4); }
[*] target: assertNotNull(client)
[-] pred: org. junit. Assert. assertNotNull ( client )
************************************
************************************
[+] input: createsEmptyList() { final TodoList todoList = new TodoList(); "<AssertPlaceHolder>"; }
size() { return tasks.size(); }
[*] target: assertEquals(0, todoList.size())
[-] pred: org. junit. Assert. assertEquals ( 0, todoList. size() )
************************************
************************************
[+] input: ignoresCompletingNonExistingTask() { final TodoList todoList = new TodoList(); todoList.toggleTaskCompletion(TaskId.of(UUID.randomUUID())); "<AssertPlaceHolder>"; }
size() { return tasks.size(); }
[*] target: assertEquals(0, todoList.size())
[-] pred: org. junit. Assert. assertEquals ( 0, todoList. size() )
************************************
************************************
[+] input: filterCompletedTasksOfEmptyList() { final TodoList todoList = new TodoList(); final List<Task> tasks = todoList.filterTasks(true); "<AssertPlaceHolder>"; }
size() { return tasks.size(); }
[*] target: assertEquals(0, tasks.size())
[-] pred: org. junit. Assert. assertEquals ( 0, tasks. size ( ) )
************************************
************************************
[+] input: filterCompletedTasksOfOneUncompletedTaskList() { final String task1Name = "TaskOne";  final TodoList todoList = new TodoList(); todoList.addTask(task1Name);  final List<Task> tasks = todoList.filterTasks(true); "<AssertPlaceHolder>"; }
size() { return tasks.size(); }
[*] target: assertEquals(0, tasks.size())
[-] pred: org. junit. Assert. assertEquals ( 0, tasks. size ( ) )
************************************
************************************
[+] input: filterUncompletedTasksOfEmptyList() { final TodoList todoList = new TodoList(); final List<Task> tasks = todoList.filterTasks(false); "<AssertPlaceHolder>"; }
size() { return tasks.size(); }
[*] target: assertEquals(0, tasks.size())
[-] pred: org. junit. Assert. assertEquals ( 0, tasks. size ( ) )
************************************
************************************
[+] input: createUser() { var createdUser = userRepository.createUser(randomUser()); Assertions."<AssertPlaceHolder>"; }
createUser(User user) { return save(user); }
[*] target: assertNotNull(createdUser)
[-] pred: org. junit. Assert. assertNotNull ( createdUser )
************************************
************************************
[+] input: testCreateWorkId() { var created = workIDApplication.createWorkId(randomWorkIdDto()); Assertions."<AssertPlaceHolder>"; }
createWorkId(WorkIdDto workIdDto);
[*] target: assertNotNull(created)
[-] pred: org. junit. Assert. assertNotNull ( created )
************************************
************************************
[+] input: testSaveEntity() { User user = randomUser();  User created = repository.save(user); Assertions."<AssertPlaceHolder>"; }
save(T entity);
[*] target: assertNotNull(created)
[-] pred: org. junit. Assert. assertNotNull ( created )
************************************
************************************
[+] input: testGetInstances() { Set<Fly> flies =  instanceProvider.getInstances(Fly.class); Assertions."<AssertPlaceHolder>"; }
getInstances(Class<T> beanType);
[*] target: assertEquals(2,flies.size())
[-] pred: org. junit. Assert. assertEquals ( 2, flies. size ( ) )
************************************
************************************
[+] input: testSaveEntity() { User user = randomUser(); User created = repository.save(user); Assertions."<AssertPlaceHolder>"; }
save(T entity);
[*] target: assertNotNull(created)
[-] pred: org. junit. Assert. assertNotNull ( created )
************************************
************************************
[+] input: SQLException { try (NebulaConnection connection = (NebulaConnection) DriverManager.getConnection(RunMeBeforeTest.URL, RunMeBeforeTest.USERNAME, RunMeBeforeTest.PASSWORD)) { "<AssertPlaceHolder>"; } }
getMetaData() throws SQLException { return new NebulaDatabaseMetaData(this); }
[*] target: assertNotNull(connection.getMetaData())
[-] pred: org. junit. Assert. assertNotNull ( connection. getMetaData() )
************************************
************************************
[+] input: testInit() { NebulaPreparedStatementImpl statement = new NebulaPreparedStatementImpl(null, ""); "<AssertPlaceHolder>"; }
getParameters() { return parameters; }
[*] target: assertNotNull(statement.getParameters())
[-] pred: org. junit. Assert. assertNotNull ( statement. getParameters() )
************************************
************************************
[+] input: SQLException { String nql = "INSERT VERTEX vert (prop) VALUES "v1":(?))"; String expected = "INSERT VERTEX vert (prop) VALUES "v1":(null))"; NebulaPreparedStatementImpl stmt = new NebulaPreparedStatementImpl(null, nql); stmt.setNull(1, Types.OTHER); String resultNql = stmt.replacePlaceHolderWithParam(nql); "<AssertPlaceHolder>"; }
replacePlaceHolderWithParam(String rawNGQL) throws SQLException { Integer index = 1; String digested = rawNGQL;  Matcher matcher = NAMED_PARAMETER_REGEX.matcher(digested);  while (matcher.find()) { if(!parameters.containsKey(index)){ throw new SQLException(String.format("Can not get param in index [%d], please check your nGql.", index)); } Object param = parameters.get(index);  if(param != null) { String paramTypeName = param.getClass().getTypeName(); switch (paramTypeName) { case ("java.lang.String"): param = String.format(""%s"", param); break; case ("java.sql.Date"): param = String.format("date("%s")", param); break; case ("java.sql.Time"): param = String.format("time("%s")", param); break; case ("java.util.Date"): SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.sss"); String datetimeString = formatter.format(param); param = String.format("datetime("%s")", datetimeString); break; default: break; } }  digested = NAMED_PARAMETER_REGEX.matcher(digested).replaceFirst(Objects.toString(param)); index++; }  return digested; }
[*] target: assertEquals(expected, resultNql)
[-] pred: org. junit. Assert. assertEquals ( expected, resultNql )
************************************
************************************
[+] input: testFunctionNames9() { List<String> names = NextflowScript.getFunctionNames("def      { some content }"); "<AssertPlaceHolder>"; }
getFunctionNames(String content) {  List<String> names = new Vector<String>();  String patternFunctionName = "(?i)^\\s*def\\s*(.+)(\\s*\\(|\\()";  Pattern r = Pattern.compile(patternFunctionName, Pattern.MULTILINE);  Matcher m = r.matcher(content); while (m.find()) { names.add(m.group(1).trim()); }  return names; }
[*] target: assertEquals(0, names.size())
[-] pred: org. junit. Assert. assertEquals ( 0, names. size ( ) )
************************************
************************************
[+] input: testGetWorkflowNames9() { List<String> names = NextflowScript.getWorkflowNames("workflow      { some content }"); "<AssertPlaceHolder>"; }
public static List<String> getWorkflowNames(String content) {  List<String> names = new Vector<String>();  String patternProcessName = "(?i)^\\s*workflow\\s*(.+)(\\s*\\{|\\{)";  Pattern r = Pattern.compile(patternProcessName, Pattern.MULTILINE);  Matcher m = r.matcher(content); while (m.find()) { if (!m.group(1).trim().isEmpty()) { names.add(m.group(1).trim()); } }  return names; }  public Set<String> getDependencies() { return dependencies; }  @Override public MetaFileType getType() { return MetaFileType.SOURCE_FILE; }  public static Set<String> getDependencies(File file, String content) {  Set<String> dependencies = new HashSet<String>();  String regex = "(?i)include\\s*\\{\\s*([A-Z_1-9]+(?:\\s+as\\s+[A-Z_]+)?)\\s*\\}\\s*from\\s*['"](.+?)['"]";  Pattern pattern = Pattern.compile(regex,  Pattern.MULTILINE); Matcher matcher = pattern.matcher(content); while (matcher.find()) { String dependency = matcher.group(2).trim(); if (dependency.startsWith("/") || dependency.startsWith("plugin/")) { continue; }  Path path = resolve(file, dependency); if (path.toFile().isDirectory()) { path = resolve(file, dependency + "/main.nf"); }  if (!path.toFile().exists()){ path = resolve(file, dependency + ".nf"); }  if (!path.toFile().exists()){ log.warn("Module " + file.getAbsolutePath() + ": Dependency '" + path.toAbsolutePath() + "' not found." ); continue; } dependencies.add(path.normalize().toFile().getAbsolutePath()); }  return dependencies;  }  @Override public TargetType getTarget() { return TargetType.UNDEFINED; }  protected static Path resolve(File file, String dependency) { if (dependency.startsWith("./") || dependency.startsWith("../")) { return Paths.get(file.getParentFile().getAbsolutePath()).resolve(dependency); } else { return Paths.get(dependency); } }  public static boolean accepts(Path path) { return path.getFileName().toString().endsWith(".nf"); }  }
[*] target: assertEquals(0, names.size())
[-] pred: org. junit. Assert. assertEquals ( 0, names. size ( ) )
************************************
************************************
[+] input: testGetWorkflowNames10() { List<String> names = NextflowScript.getWorkflowNames("echo workflow ${value}"); "<AssertPlaceHolder>"; }
public static List<String> getWorkflowNames(String content) {  List<String> names = new Vector<String>();  String patternProcessName = "(?i)^\\s*workflow\\s*(.+)(\\s*\\{|\\{)";  Pattern r = Pattern.compile(patternProcessName, Pattern.MULTILINE);  Matcher m = r.matcher(content); while (m.find()) { if (!m.group(1).trim().isEmpty()) { names.add(m.group(1).trim()); } }  return names; }  public Set<String> getDependencies() { return dependencies; }  @Override public MetaFileType getType() { return MetaFileType.SOURCE_FILE; }  public static Set<String> getDependencies(File file, String content) {  Set<String> dependencies = new HashSet<String>();  String regex = "(?i)include\\s*\\{\\s*([A-Z_1-9]+(?:\\s+as\\s+[A-Z_]+)?)\\s*\\}\\s*from\\s*['"](.+?)['"]";  Pattern pattern = Pattern.compile(regex,  Pattern.MULTILINE); Matcher matcher = pattern.matcher(content); while (matcher.find()) { String dependency = matcher.group(2).trim(); if (dependency.startsWith("/") || dependency.startsWith("plugin/")) { continue; }  Path path = resolve(file, dependency); if (path.toFile().isDirectory()) { path = resolve(file, dependency + "/main.nf"); }  if (!path.toFile().exists()){ path = resolve(file, dependency + ".nf"); }  if (!path.toFile().exists()){ log.warn("Module " + file.getAbsolutePath() + ": Dependency '" + path.toAbsolutePath() + "' not found." ); continue; } dependencies.add(path.normalize().toFile().getAbsolutePath()); }  return dependencies;  }  @Override public TargetType getTarget() { return TargetType.UNDEFINED; }  protected static Path resolve(File file, String dependency) { if (dependency.startsWith("./") || dependency.startsWith("../")) { return Paths.get(file.getParentFile().getAbsolutePath()).resolve(dependency); } else { return Paths.get(dependency); } }  public static boolean accepts(Path path) { return path.getFileName().toString().endsWith(".nf"); }  }
[*] target: assertEquals(0, names.size())
[-] pred: org. junit. Assert. assertEquals ( 0, names. size ( ) )
************************************
************************************
[+] input: testOnTickPriceDiffAbort() { when(priceDiffConditionToAbort.test(anyDouble())).thenReturn(true); tradeIntent.onTick(tick); "<AssertPlaceHolder>"; verify(context, never()).submitOrderReq(any(), any(), any(), anyInt(), anyDouble()); }
hasTerminated() { return terminated || accVol >= volume; }
[*] target: assertTrue(tradeIntent.hasTerminated())
[-] pred: org. junit. Assert. assertTrue ( tradeIntent. hasTerminated() )
************************************
************************************
[+] input: testHasTerminated() { when(priceDiffConditionToAbort.test(anyDouble())).thenReturn(true); tradeIntent.onTick(tick); "<AssertPlaceHolder>"; }
hasTerminated() { return terminated || accVol >= volume; }
[*] target: assertTrue(tradeIntent.hasTerminated())
[-] pred: org. junit. Assert. assertTrue ( tradeIntent. hasTerminated() )
************************************
************************************
[+] input: equals_false_when_null() { // Arrange Vec3Comparable vec3c = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c.equals(null);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred: org. junit. Assert. assertFalse ( areEqual )
************************************
************************************
[+] input: equals_true_when_same_object() { // Arrange Vec3Comparable vec3c = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c.equals(vec3c);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertTrue(areEqual)
[-] pred: org. junit. Assert. assertTrue ( areEqual )
************************************
************************************
[+] input: equals_true_when_same_value() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertTrue(areEqual)
[-] pred: org. junit. Assert. assertTrue ( areEqual )
************************************
************************************
[+] input: equals_false_when_vec3_equals() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3 vec3c2 = new Vec3(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred: org. junit. Assert. assertFalse ( areEqual )
************************************
************************************
[+] input: equals_false_when_different_object_type() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); BlockPos blockPos = new BlockPos(1.0, 2.0, 3.0);  // Act boolean areEqual = vec3c1.equals(blockPos);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred: org. junit. Assert. assertFalse ( areEqual )
************************************
************************************
[+] input: equals_false_when_different_value() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(3.0, 2.0, 1.0);  // Act boolean areEqual = vec3c1.equals(vec3c2);  // Assert "<AssertPlaceHolder>"; }
equals(Object other) { if (this == other) { return true; } else if (!(other instanceof Vec3Comparable)) { return false; } else { Vec3Comparable vec3c = (Vec3Comparable) other; return this.xCoord == vec3c.xCoord && this.yCoord == vec3c.yCoord && this.zCoord == vec3c.zCoord; } }
[*] target: assertFalse(areEqual)
[-] pred: org. junit. Assert. assertFalse ( areEqual )
************************************
************************************
[+] input: hashCode_same_when_same_value() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(1.0, 2.0, 3.0);  // Act double vec3c1Hash = vec3c1.hashCode(); double vec3c2Hash = vec3c2.hashCode();  // Assert "<AssertPlaceHolder>"; }
hashCode() { long bits = 1L; bits = 31L * bits + doubleToLongBits(xCoord); bits = 31L * bits + doubleToLongBits(yCoord); bits = 31L * bits + doubleToLongBits(zCoord); return (int) (bits ^ (bits >> 32)); }
[*] target: assertEquals(vec3c1Hash, vec3c2Hash)
[-] pred: org. junit. Assert. assertEquals ( vec3c1Hash, vec3c2Hash )
************************************
************************************
[+] input: compareTo_zero_when_equal() { // Arrange Vec3Comparable vec3c1 = new Vec3Comparable(1.0, 2.0, 3.0); Vec3Comparable vec3c2 = new Vec3Comparable(1.0, 2.0, 3.0);  // Act int result = vec3c1.compareTo(vec3c2);  // Assert "<AssertPlaceHolder>"; }
compareTo(Vec3Comparable other) { return this.yCoord == other.yCoord ? (this.zCoord == other.zCoord ? (int) (this.xCoord - other.xCoord) : (int) (this.zCoord - other.zCoord)) : (int) (this.yCoord - other.yCoord); }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 0, result )
************************************
************************************
[+] input: shouldValidateWithNoClassValidationConstraint() { ConnectValidator validator = ConnectValidator.builder() .validationConstraints(Map.of( "key.converter", new ResourceValidator.NonEmptyString(), "value.converter", new ResourceValidator.NonEmptyString(), "connector.class", new ResourceValidator.ValidString( List.of("io.confluent.connect.jdbc.JdbcSourceConnector", "io.confluent.connect.jdbc.JdbcSinkConnector", "com.splunk.kafka.connect.SplunkSinkConnector", "org.apache.kafka.connect.file.FileStreamSinkConnector"), false))) .sourceValidationConstraints(Map.of( "producer.override.sasl.jaas.config", new ResourceValidator.NonEmptyString())) .sinkValidationConstraints(Map.of( "consumer.override.sasl.jaas.config", new ResourceValidator.NonEmptyString())) .build();  Connector connector = Connector.builder() .metadata(Metadata.builder() .name("connect2") .build()) .spec(Connector.ConnectorSpec.builder() .connectCluster("cluster1") .config(Map.of( "connector.class", "io.confluent.connect.jdbc.JdbcSourceConnector", "key.converter", "test", "value.converter", "test", "consumer.override.sasl.jaas.config", "test")) .build()) .build();  List<String> actual = validator.validate(connector, "sink"); "<AssertPlaceHolder>"; }
validate(Connector connector, String connectorType) { List<String> validationErrors = new ArrayList<>();  if (!StringUtils.hasText(connector.getMetadata().getName())) { return List.of(invalidNameEmpty()); }  if (connector.getMetadata().getName().length() > 249) { validationErrors.add(invalidNameLength(connector.getMetadata().getName())); }  if (!connector.getMetadata().getName().matches("[a-zA-Z0-9._-]+")) { validationErrors.add(invalidNameSpecChars(connector.getMetadata().getName())); }  validationConstraints.forEach((key, value) -> { try { value.ensureValid(key, connector.getSpec().getConfig().get(key)); } catch (FieldValidationException e) { validationErrors.add(e.getMessage()); } });  if (connectorType.equals("sink")) { sinkValidationConstraints.forEach((key, value) -> { try { value.ensureValid(key, connector.getSpec().getConfig().get(key)); } catch (FieldValidationException e) { validationErrors.add(e.getMessage()); } }); }  if (connectorType.equals("source")) { sourceValidationConstraints.forEach((key, value) -> { try { value.ensureValid(key, connector.getSpec().getConfig().get(key)); } catch (FieldValidationException e) { validationErrors.add(e.getMessage()); } }); }  if (classValidationConstraints.containsKey(connector.getSpec().getConfig().get(CONNECTOR_CLASS))) { classValidationConstraints.get(connector.getSpec().getConfig().get(CONNECTOR_CLASS)) .forEach((key, value) -> { try { value.ensureValid(key, connector.getSpec().getConfig().get(key)); } catch (FieldValidationException e) { validationErrors.add(e.getMessage()); } }); } return validationErrors; }
[*] target: assertTrue(actual.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( actual. isEmpty ( ) )
************************************
************************************
[+] input: shouldValidateSourceConnector() { ConnectValidator validator = ConnectValidator.builder() .validationConstraints(Map.of( "key.converter", new ResourceValidator.NonEmptyString(), "value.converter", new ResourceValidator.NonEmptyString(), "connector.class", new ResourceValidator.ValidString( List.of("io.confluent.connect.jdbc.JdbcSourceConnector", "io.confluent.connect.jdbc.JdbcSinkConnector", "com.splunk.kafka.connect.SplunkSinkConnector", "org.apache.kafka.connect.file.FileStreamSinkConnector"), false))) .sourceValidationConstraints(Map.of( "producer.override.sasl.jaas.config", new ResourceValidator.NonEmptyString())) .sinkValidationConstraints(Map.of( "consumer.override.sasl.jaas.config", new ResourceValidator.NonEmptyString())) .classValidationConstraints(Map.of( "io.confluent.connect.jdbc.JdbcSinkConnector", Map.of( "db.timezone", new ResourceValidator.NonEmptyString()))) .build();  Connector connector = Connector.builder() .metadata(Metadata.builder() .name("connect2") .build()) .spec(Connector.ConnectorSpec.builder() .connectCluster("cluster1") .config(Map.of( "connector.class", "io.confluent.connect.jdbc.JdbcSourceConnector", "key.converter", "test", "value.converter", "test", "producer.override.sasl.jaas.config", "test")) .build()) .build();  List<String> actual = validator.validate(connector, "source"); "<AssertPlaceHolder>"; }
validate(Connector connector, String connectorType) { List<String> validationErrors = new ArrayList<>();  if (!StringUtils.hasText(connector.getMetadata().getName())) { return List.of(invalidNameEmpty()); }  if (connector.getMetadata().getName().length() > 249) { validationErrors.add(invalidNameLength(connector.getMetadata().getName())); }  if (!connector.getMetadata().getName().matches("[a-zA-Z0-9._-]+")) { validationErrors.add(invalidNameSpecChars(connector.getMetadata().getName())); }  validationConstraints.forEach((key, value) -> { try { value.ensureValid(key, connector.getSpec().getConfig().get(key)); } catch (FieldValidationException e) { validationErrors.add(e.getMessage()); } });  if (connectorType.equals("sink")) { sinkValidationConstraints.forEach((key, value) -> { try { value.ensureValid(key, connector.getSpec().getConfig().get(key)); } catch (FieldValidationException e) { validationErrors.add(e.getMessage()); } }); }  if (connectorType.equals("source")) { sourceValidationConstraints.forEach((key, value) -> { try { value.ensureValid(key, connector.getSpec().getConfig().get(key)); } catch (FieldValidationException e) { validationErrors.add(e.getMessage()); } }); }  if (classValidationConstraints.containsKey(connector.getSpec().getConfig().get(CONNECTOR_CLASS))) { classValidationConstraints.get(connector.getSpec().getConfig().get(CONNECTOR_CLASS)) .forEach((key, value) -> { try { value.ensureValid(key, connector.getSpec().getConfig().get(key)); } catch (FieldValidationException e) { validationErrors.add(e.getMessage()); } }); } return validationErrors; }
[*] target: assertTrue(actual.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( actual. isEmpty ( ) )
************************************
************************************
[+] input: shouldReturnUnknownWhenMissingClaims() { Map<String, Object> claims = Map.of(SUBJECT, "user", ROLES, List.of()); Authentication auth = Authentication.build("user", claims);  SecurityRuleResult actual = resourceBasedSecurityRule.checkSecurity(HttpRequest.GET("/anything"), auth); "<AssertPlaceHolder>"; }
checkSecurity(HttpRequest<?> request, @Nullable Authentication authentication) { if (authentication == null) { return SecurityRuleResult.UNKNOWN; }  if (!authentication.getAttributes().containsKey(ROLE_BINDINGS)) { log.debug("No authentication available for path [{}]. Returning unknown.", request.getPath()); return SecurityRuleResult.UNKNOWN; }  // Request to a URL that is not in the scope of this SecurityRule Matcher matcher = namespacedResourcePattern.matcher(request.getPath()); if (!matcher.find()) { log.debug("Invalid namespaced resource for path [{}]. Returning unknown.", request.getPath()); return SecurityRuleResult.UNKNOWN; }  String namespace = matcher.group("namespace"); String resourceSubtype = matcher.group("resourceSubtype"); String resourceType;  // Subresource handling ie. connects/restart or groups/reset if (StringUtils.isNotEmpty(resourceSubtype)) { resourceType = matcher.group("resourceType") + "/" + resourceSubtype; } else { resourceType = matcher.group("resourceType"); }  // Namespace doesn't exist String sub = authentication.getName(); if (namespaceRepository.findByName(namespace).isEmpty()) { log.debug("Namespace not found for user "{}" on path "{}"", sub, request.getPath()); throw new UnknownNamespaceException(namespace); }  // Admin are allowed everything (provided that the namespace exists) Collection<String> roles = authentication.getRoles(); if (roles.contains(IS_ADMIN)) { log.debug("Authorized admin "{}" on path "{}"", sub, request.getPath()); return SecurityRuleResult.ALLOWED; }  AuthenticationInfo authenticationInfo = AuthenticationInfo.of(authentication);  // No role binding for the target namespace. User is targeting a namespace that he is not allowed to access List<AuthenticationRoleBinding> namespaceRoleBindings = authenticationInfo.getRoleBindings() .stream() .filter(roleBinding -> roleBinding.getNamespace().equals(namespace)) .toList();  if (namespaceRoleBindings.isEmpty()) { log.debug("No matching role binding for user "{}" and namespace "{}" on path "{}"", sub, namespace, request.getPath()); throw new ForbiddenNamespaceException(namespace); }  List<AuthenticationRoleBinding> authorizedRoleBindings = namespaceRoleBindings .stream() .filter(roleBinding -> roleBinding.getResourceTypes().contains(resourceType)) .filter(roleBinding -> roleBinding.getVerbs().contains(RoleBinding.Verb.valueOf(request.getMethodName()))) .toList();  // User not authorized to access requested resource if (authorizedRoleBindings.isEmpty()) { log.debug("No matching role binding for user "{}", namespace "{}", resource type "{}" " + "and HTTP verb "{}" on path "{}"", sub, namespace, resourceType, request.getMethodName(), request.getPath()); return SecurityRuleResult.UNKNOWN; }  if (log.isDebugEnabled()) { authorizedRoleBindings.forEach( roleBinding -> log.debug("Found matching role binding "{}"", roleBinding.toString())); log.debug("Authorized user "{}" on path "{}"", sub, request.getPath()); }  return SecurityRuleResult.ALLOWED; }
[*] target: assertEquals(SecurityRuleResult.UNKNOWN, actual)
[-] pred: org. junit. Assert. assertEquals ( SecurityRuleResult. UNKNOWN, actual )
************************************
************************************
[+] input: shouldCreateConnectCluster() { ConnectCluster connectCluster = ConnectCluster.builder() .metadata(Metadata.builder() .name("prefix.connect-cluster") .build()) .spec(ConnectCluster.ConnectClusterSpec.builder() .url("https://after") .build()) .build();  when(connectClusterRepository.create(connectCluster)) .thenReturn(connectCluster);  ConnectCluster actual = connectClusterService.create(connectCluster); "<AssertPlaceHolder>"; }
create(ConnectCluster connectCluster) { if (StringUtils.hasText(connectCluster.getSpec().getPassword())) { connectCluster.getSpec() .setPassword(EncryptionUtils.encryptAes256Gcm(connectCluster.getSpec().getPassword(), securityProperties.getAes256EncryptionKey())); }  // encrypt aes256 key if present if (StringUtils.hasText(connectCluster.getSpec().getAes256Key())) { connectCluster.getSpec() .setAes256Key(EncryptionUtils.encryptAes256Gcm(connectCluster.getSpec().getAes256Key(), securityProperties.getAes256EncryptionKey())); }  // encrypt aes256 salt if present if (StringUtils.hasText(connectCluster.getSpec().getAes256Salt())) { connectCluster.getSpec() .setAes256Salt(EncryptionUtils.encryptAes256Gcm(connectCluster.getSpec().getAes256Salt(), securityProperties.getAes256EncryptionKey())); }  return connectClusterRepository.create(connectCluster); }
[*] target: assertEquals(connectCluster, actual)
[-] pred: org. junit. Assert. assertEquals ( connectCluster, actual )
************************************
************************************
[+] input: shouldValidateNamespaceOwnerOfConnectCluster() { Namespace namespace = Namespace.builder() .metadata(Metadata.builder() .name("myNamespace") .cluster("local") .build()) .spec(Namespace.NamespaceSpec.builder() .build()) .build();  when(aclService.isNamespaceOwnerOfResource(any(), any(), any())) .thenReturn(true);  boolean actual = connectClusterService.isNamespaceOwnerOfConnectCluster(namespace, "prefix.connect-cluster");  "<AssertPlaceHolder>"; }
isNamespaceOwnerOfConnectCluster(Namespace namespace, String connectCluster) { return aclService.isNamespaceOwnerOfResource(namespace.getMetadata().getName(), AccessControlEntry.ResourceType.CONNECT_CLUSTER, connectCluster); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: shouldListAllNamespaceResourcesWhenEmpty() { Namespace ns = Namespace.builder() .metadata(Metadata.builder() .name("namespace") .cluster("local") .build()) .spec(NamespaceSpec.builder() .connectClusters(List.of("local-name")) .kafkaUser("user") .build()) .build();  when(topicService.findAllForNamespace(ns)) .thenReturn(List.of()); when(connectorService.findAllForNamespace(ns)) .thenReturn(List.of()); when(roleBindingService.findAllForNamespace("namespace")) .thenReturn(List.of()); when(aclService.findAllForNamespace(ns)) .thenReturn(List.of()); when(connectClusterService.findAllForNamespaceWithOwnerPermission(ns)) .thenReturn(List.of()); when(resourceQuotaService.findForNamespace("namespace")) .thenReturn(Optional.empty());  List<String> result = namespaceService.findAllResourcesByNamespace(ns); "<AssertPlaceHolder>"; }
findAllResourcesByNamespace(Namespace namespace) { return Stream.of( topicService.findAllForNamespace(namespace).stream() .map(topic -> TOPIC + "/" + topic.getMetadata().getName()), connectorService.findAllForNamespace(namespace).stream() .map(connector -> CONNECTOR + "/" + connector.getMetadata().getName()), connectClusterService.findAllForNamespaceWithOwnerPermission(namespace).stream() .map(connectCluster -> CONNECT_CLUSTER + "/" + connectCluster.getMetadata().getName()), aclService.findAllForNamespace(namespace).stream() .map(ace -> ACCESS_CONTROL_ENTRY + "/" + ace.getMetadata().getName()), resourceQuotaService.findForNamespace(namespace.getMetadata().getName()).stream() .map(resourceQuota -> RESOURCE_QUOTA + "/" + resourceQuota.getMetadata().getName()), roleBindingService.findAllForNamespace(namespace.getMetadata().getName()).stream() .map(roleBinding -> ROLE_BINDING + "/" + roleBinding.getMetadata().getName()) ) .reduce(Stream::concat) .orElseGet(Stream::empty) .toList(); }
[*] target: assertTrue(result.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( result. isEmpty ( ) )
************************************
************************************
[+] input: shouldValidateUpdateTopicCleanupPolicyDeleteToCompactOnSelfManaged() { Namespace ns = Namespace.builder() .metadata(Metadata.builder() .name("namespace") .cluster("local") .build()) .build();  Topic existing = Topic.builder() .metadata(Metadata.builder() .name("test.topic") .build()) .spec(Topic.TopicSpec.builder() .replicationFactor(3) .partitions(3) .configs(Map.of("cleanup.policy", "delete", "min.insync.replicas", "2", "retention.ms", "60000")) .build()) .build();  Topic topic = Topic.builder() .metadata(Metadata.builder() .name("test.topic") .build()) .spec(Topic.TopicSpec.builder() .replicationFactor(3) .partitions(3) .configs(Map.of("cleanup.policy", "compact", "min.insync.replicas", "2", "retention.ms", "60000")) .build()) .build();  when(managedClusterProperties.stream()).thenReturn( Stream.of(new ManagedClusterProperties("local", ManagedClusterProperties.KafkaProvider.SELF_MANAGED)));  List<String> actual = topicService.validateTopicUpdate(ns, existing, topic);  "<AssertPlaceHolder>"; }
validateTopicUpdate(Namespace namespace, Topic existingTopic, Topic newTopic) { List<String> validationErrors = new ArrayList<>();  if (existingTopic.getSpec().getPartitions() != newTopic.getSpec().getPartitions()) { validationErrors.add(invalidImmutableValue("partitions", String.valueOf(newTopic.getSpec().getPartitions()))); }  if (existingTopic.getSpec().getReplicationFactor() != newTopic.getSpec().getReplicationFactor()) { validationErrors.add(invalidImmutableValue("replication.factor", String.valueOf(newTopic.getSpec().getReplicationFactor()))); }  Optional<ManagedClusterProperties> topicCluster = managedClusterProperties .stream() .filter(cluster -> namespace.getMetadata().getCluster().equals(cluster.getName())) .findFirst();  boolean isConfluentCloud = topicCluster.isPresent() && topicCluster.get().isConfluentCloud();  if (isConfluentCloud && existingTopic.getSpec().getConfigs().get(CLEANUP_POLICY_CONFIG).equals(CLEANUP_POLICY_DELETE) && newTopic.getSpec().getConfigs().get(CLEANUP_POLICY_CONFIG).equals(CLEANUP_POLICY_COMPACT)) { validationErrors.add(invalidTopicCleanupPolicy(newTopic.getSpec().getConfigs().get(CLEANUP_POLICY_CONFIG))); }  return validationErrors; }
[*] target: assertEquals(0, actual.size())
[-] pred: org. junit. Assert. assertEquals ( 0, actual. size ( ) )
************************************
************************************
[+] input: shouldValidateEncryptAndDecryptAes256GcmNullText() { String keyEncryptionKey = "myKeyEncryptionKeyWrongSize";  String stillNullText = EncryptionUtils.encryptAes256Gcm(null, keyEncryptionKey); "<AssertPlaceHolder>"; }
encryptAes256Gcm(String clearText, String key) { try { if (!StringUtils.hasText(clearText)) { return clearText; }  AESEncrypter encrypter = new AESEncrypter(key.getBytes(StandardCharsets.UTF_8)); JWECryptoParts encryptedData = encrypter.encrypt(new JWEHeader(JWEAlgorithm.A256KW, EncryptionMethod.A256GCM), clearText.getBytes(StandardCharsets.UTF_8));  ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); outputStream.write(encryptedData.getEncryptedKey().decode()); outputStream.write(encryptedData.getInitializationVector().decode()); outputStream.write(encryptedData.getAuthenticationTag().decode()); outputStream.write(encryptedData.getCipherText().decode());  return Base64URL.encode(outputStream.toByteArray()).toString(); } catch (JOSEException | IOException e) { log.error("An error occurred during Connect cluster password encryption", e); }  return clearText; }
[*] target: assertNull(stillNullText)
[-] pred: org. junit. Assert. assertNull ( stillNullText )
************************************
************************************
[+] input: shouldValidateEncryptAndDecryptAes256GcmWrongKeySize() { String clearText = "myClearText"; String keyEncryptionKey = "myKeyEncryptionKeyWrongSize"; String myClearText = EncryptionUtils.encryptAes256Gcm(clearText, keyEncryptionKey);  "<AssertPlaceHolder>"; }
encryptAes256Gcm(String clearText, String key) { try { if (!StringUtils.hasText(clearText)) { return clearText; }  AESEncrypter encrypter = new AESEncrypter(key.getBytes(StandardCharsets.UTF_8)); JWECryptoParts encryptedData = encrypter.encrypt(new JWEHeader(JWEAlgorithm.A256KW, EncryptionMethod.A256GCM), clearText.getBytes(StandardCharsets.UTF_8));  ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); outputStream.write(encryptedData.getEncryptedKey().decode()); outputStream.write(encryptedData.getInitializationVector().decode()); outputStream.write(encryptedData.getAuthenticationTag().decode()); outputStream.write(encryptedData.getCipherText().decode());  return Base64URL.encode(outputStream.toByteArray()).toString(); } catch (JOSEException | IOException e) { log.error("An error occurred during Connect cluster password encryption", e); }  return clearText; }
[*] target: assertEquals(clearText, myClearText)
[-] pred: org. junit. Assert. assertEquals ( clearText, myClearText )
************************************
************************************
[+] input: shouldValidateEncryptAndDecryptAes256Gcm() { String clearText = "myClearText"; String keyEncryptionKey = "olDeandATEDiCenSiTurThrepASTrole"; String encryptedText = EncryptionUtils.encryptAes256Gcm(clearText, keyEncryptionKey); String clearTextDecrypted = EncryptionUtils.decryptAes256Gcm(encryptedText, keyEncryptionKey);  "<AssertPlaceHolder>"; }
decryptAes256Gcm(String encryptedText, String key) { try { if (!StringUtils.hasText(encryptedText)) { return encryptedText; }  AESDecrypter decrypter = new AESDecrypter(key.getBytes(StandardCharsets.UTF_8)); byte[] encryptedData = Base64URL.from(encryptedText).decode();  Base64URL encryptedKey = Base64URL.encode(Arrays.copyOfRange(encryptedData, 0, 40)); Base64URL iv = Base64URL.encode(Arrays.copyOfRange(encryptedData, 40, 52)); Base64URL auth = Base64URL.encode(Arrays.copyOfRange(encryptedData, 52, 68)); Base64URL text = Base64URL.encode(Arrays.copyOfRange(encryptedData, 68, encryptedData.length));  byte[] clearTextAsBytes = decrypter.decrypt(new JWEHeader(JWEAlgorithm.A256KW, EncryptionMethod.A256GCM), encryptedKey, iv, text, auth);  return new String(clearTextAsBytes); } catch (JOSEException e) { log.error("An error occurred during Connect cluster password decryption", e); }  return encryptedText; }
[*] target: assertEquals(clearText, clearTextDecrypted)
[-] pred: org. junit. Assert. assertEquals ( clearText, clearTextDecrypted )
************************************
************************************
[+] input: shouldValidateEncryptAndDecryptAes256NullText() { final String encryptionKey = "myKeyEncryption"; final String encryptionSalt = "p8t42EhY9z2eSUdpGeq7HX7RboMrsJAhUnu3EEJJVS";  final String stillBlankText = EncryptionUtils.encryptAesWithPrefix(null, encryptionKey, encryptionSalt); "<AssertPlaceHolder>"; }
encryptAesWithPrefix(final String clearText, final String key, final String salt) { if (!StringUtils.hasText(clearText)) { return clearText; }  try { final SecretKey secret = getAesSecretKey(key, salt); final byte[] iv = getRandomIv(); final var cipher = Cipher.getInstance(ENCRYPT_ALGO); cipher.init(Cipher.ENCRYPT_MODE, secret, new GCMParameterSpec(TAG_LENGTH_BIT, iv)); final byte[] cipherText = cipher.doFinal(clearText.getBytes(StandardCharsets.UTF_8)); final byte[] prefix = NS4KAFKA_PREFIX.getBytes(StandardCharsets.UTF_8); final byte[] cipherTextWithIv = ByteBuffer.allocate(prefix.length + iv.length + cipherText.length) .put(prefix) .put(iv) .put(cipherText) .array(); return Base64.getEncoder().encodeToString(cipherTextWithIv); } catch (Exception e) { log.error("An error occurred during Connect cluster AES256 string encryption", e); }  return clearText; }
[*] target: assertNull(stillBlankText)
[-] pred: org. junit. Assert. assertNull ( stillBlankText )
************************************
************************************
[+] input: shouldValidateEncryptAndDecryptAes256() { String clearText = "myClearText"; String encryptionKey = "myKeyEncryption"; String encryptionSalt = "p8t42EhY9z2eSUdpGeq7HX7RboMrsJAhUnu3EEJJVS"; String encryptedText = EncryptionUtils.encryptAesWithPrefix(clearText, encryptionKey, encryptionSalt); String clearTextDecrypted = EncryptionUtils.decryptAesWithPrefix(encryptedText, encryptionKey, encryptionSalt);  "<AssertPlaceHolder>"; }
decryptAesWithPrefix(final String encryptedText, final String key, final String salt) { if (!StringUtils.hasText(encryptedText)) { return encryptedText; }  try { // Get IV and cipherText from encrypted text. final byte[] prefix = NS4KAFKA_PREFIX.getBytes(StandardCharsets.UTF_8); final var byteBuffer = ByteBuffer.wrap(Base64.getDecoder().decode(encryptedText)); final byte[] iv = new byte[IV_LENGTH_BYTE]; byteBuffer.position(prefix.length); byteBuffer.get(iv); final byte[] cipherText = new byte[byteBuffer.remaining()]; byteBuffer.get(cipherText);  // decrypt the cipher text. final SecretKey secret = getAesSecretKey(key, salt); final var cipher = Cipher.getInstance(ENCRYPT_ALGO); cipher.init(Cipher.DECRYPT_MODE, secret, new GCMParameterSpec(TAG_LENGTH_BIT, iv)); return new String(cipher.doFinal(cipherText), StandardCharsets.UTF_8); } catch (Exception e) { log.error("An error occurred during Connect cluster AES256 string decryption", e); }  return encryptedText; }
[*] target: assertEquals(clearText, clearTextDecrypted)
[-] pred: org. junit. Assert. assertEquals ( clearText, clearTextDecrypted )
************************************
************************************
[+] input: testGetTargetCopy() { TreeNode original = new TreeNode(7); original.left = new TreeNode(4); original.right = new TreeNode(3); original.right.left = new TreeNode(6); original.right.right = new TreeNode(19); TreeNode target = original.right; TreeNode expected = testObject.getTargetCopy(original, original, target); "<AssertPlaceHolder>"; }
getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) { // Special case if (original == null) { return cloned; } // Queues to traverse through the tree in the BFS Queue<TreeNode> q1 = new LinkedList<>(); Queue<TreeNode> q2 = new LinkedList<>(); // Add root nodes to the queues q1.offer(original); q2.offer(cloned); // Loop until the queues are empty while (!q1.isEmpty() && !q2.isEmpty()) { // Get the nodes in the front of the queues TreeNode c1 = q1.remove(); TreeNode c2 = q2.remove(); // If the current front is equal to the target node, // we will return the corresponding node from the // clone tree if (c1 == target) { return c2; } // Add childrent nodes if they are available if (c1.left != null && c2.left != null) { q1.offer(c1.left); q2.offer(c2.left); } if (c1.right != null && c2.right != null) { q1.offer(c1.right); q2.offer(c2.right); } } return null; }
[*] target: assertEquals(expected, target)
[-] pred: org. junit. Assert. assertEquals ( expected, target )
************************************
************************************
[+] input: callWithRetryRetriableError() { final int[] attempt = new int[1]; final int maxRetries = 3; final int res = RetryUtil.callWithRetry("test callWithRetryRetriableError", () -> { if (attempt[0] < maxRetries) { ++attempt[0]; throw new ArithmeticException(); } return attempt[0]; }, maxRetries, 1L, RuntimeException.class);  "<AssertPlaceHolder>"; }
callWithRetry(final String callName, final Callable<T> callable, final int maxRetries, final long retryBackoffMs, final Class<E> repeatableException) { final var time = Time.SYSTEM; final int maxAttempts = maxRetries + 1; for (int attempts = 1, retryAttempts = 0; true; ++attempts, ++retryAttempts) { try { LOGGER.trace("Try {} with attempt {}/{}", callName, attempts, maxAttempts); return callable.call(); } catch (final Exception e) { if (!repeatableException.isAssignableFrom(e.getClass())) { final var msg = String.format("Non-repeatable exception trown by %s", callName); LOGGER.error(msg, e); throw new ConnectException(msg, e); } else if (attempts < maxAttempts) { final long sleepTimeMs = computeRandomRetryWaitTimeInMillis(retryAttempts, retryBackoffMs); final var msg = String.format("Failed to %s with attempt %s/%s, will attempt retry after %s ms. ", callName, attempts, maxAttempts, sleepTimeMs); LOGGER.warn(msg + "Failure reason: {}", e); time.sleep(sleepTimeMs); } else { final var msg = String.format("Failed to %s after total of %s attempt(s)", callName, attempts); LOGGER.error(msg, e); throw new ConnectException(msg, e); } } } }
[*] target: assertEquals(maxRetries, res)
[-] pred: org. junit. Assert. assertEquals ( maxRetries, res )
************************************
************************************
[+] input: deveRetornarAlunoValido() { AlunoBuilder alunoBuilder = new AlunoBuilder(); Aluno aluno = alunoBuilder .setMatricula(1) .setNome("Aluno 1") .setEmail("aluno1@email.com") .build();  "<AssertPlaceHolder>"; }
build() { if (aluno.getMatricula() == 0) { throw new IllegalArgumentException("Matrícula inválida"); } if (aluno.getNome().equals("")) { throw new IllegalArgumentException("Nome inválido"); } return aluno; }
[*] target: assertNotNull(aluno)
[-] pred: org. junit. Assert. assertNotNull ( aluno )
************************************
************************************
[+] input: Exception { // /// * // { // "ID": "intelligentGraph.PathQL1", // "query": "getPaths?pathQL=(<http://ex.org/REPORTSTO>){1,2}", // "type": "read", // "roles": ["user"], // "arguments" : { // "subject" : iri("http://ex.org/1"), // "object" : null // } // } // */ // // QueryMeta queryMeta =QueryMeta.ofQuery("getPaths?pathQL=(<http://ex.org/REPORTSTO>){1,2}"); // queryMeta.ID= "testPath"; // queryMeta.database = "dj/junit"; // Map<String, Object> arguments = new HashMap<>(); // arguments.put("subject", iri("http://ex.org/1")); // arguments.put("object", null); // queryMeta.arguments=arguments; // // // AbstractDatabase database = services.getConfig().getDatabase( queryMeta.database); // // List<Map<String, Object>> res = database.queryGraph(queryMeta, null); // // ObjectMapper mapper = new ObjectMapper(); // String resJSON = // mapper.writerWithDefaultPrettyPrinter().writeValueAsString(mapper.convertValue(res, // JsonNode.class)); // // String expectedJSON = Files.readString( Paths.get("./src/test/resources/results/", "junit", // queryMeta.ID +".json")); // // "<AssertPlaceHolder>"; // }
queryGraph(QueryMeta info, Map<String, Object> arguments) throws Exception { List<Map<String, Object>> res = new ArrayList<>(); String[] queryParts = info.query.split(IntelligentGraphConstants.PATH_QL_REGEX); switch (queryParts[0]) { case "getFact": case "getFacts": break; case "getPath": case "getPaths": IRI predicate = iri( PATHQL.NAMESPACE + URLEncoder.encode(info.query, StandardCharsets.UTF_8.toString())); // PathQL queries have an implicit subject and object parameter (subject is optionally null) IRI subject = arguments == null || arguments.get("subject") == null ? null : iri(arguments.get("subject")); Value object = arguments == null || arguments.get("object") == null ? null : iri(arguments.get("object")); PathResults pathsIterator = null; try (RepositoryConnection con = getConnection()) { RepositoryResult<Statement> resultsIterator = con.getStatements(subject, predicate, object); Thing subjectThing = subject == null ? null : Thing.create(null, subject, null); pathsIterator = new PathResults(resultsIterator, subjectThing, null, null);  while (pathsIterator.hasNext()) { Path path = pathsIterator.next(); PathSteps pathSteps = new PathSteps(info.database, path); @SuppressWarnings("rawtypes") // assume an implicit path variable Map row = MapUtil.of("path", pathSteps); res.add(row); } } finally { // exceptions are thrown but close iter in all cases if (pathsIterator != null) pathsIterator.close(); } break; default: res = queryInternal(info, arguments, true);  } return res; }
[*] target: assertEquals( expectedJSON, resJSON)
[-] pred: org. junit. Assert. assertEquals ( expectedJSON, resJSON )
************************************
************************************
[+] input: existTest() { //given Team teamA = new Team("TeamA"); em.persist(teamA); Member member1 = new Member("member1", 10, teamA); em.persist(member1); //when Boolean exist = woowahwanMemberRepository.exist(member1.getId()); //then "<AssertPlaceHolder>"; }
exist(Long memberId) { Integer fetchOne = queryFactory .selectOne() .from(member) .where(member.id.eq(memberId)) .fetchFirst();  return fetchOne != null; }
[*] target: assertTrue(exist)
[-] pred: org. junit. Assert. assertTrue ( exist )
************************************
************************************
[+] input: testCountOnMappedField() { long count = entityStream // .of(Company.class) // .filter( // Company$.NAME.notEq("RedisInc") // .and(Company$.NAME.notEq("Microsoft")) // ) // .map(Company$.NAME) // .sequential() // .count();  "<AssertPlaceHolder>"; }
count() { return backingStream.count(); }
[*] target: assertEquals(1, count)
[-] pred: org. junit. Assert. assertEquals ( 1, count )
************************************
************************************
[+] input: Exception { //given Statement statement = new Statement();  List<Performance> performances = new ArrayList<>(); performances.add(new Performance("hamlet",55)); performances.add(new Performance("as-like",35)); performances.add(new Performance("othello",40)); Invoice invoice = new Invoice("BigCo", performances);  Map<String, Play> playMap = new HashMap<>(); playMap.put("hamlet", new Play("hamlet", PlayType.TRAGEDY)); playMap.put("as-like", new Play("As You Like It", PlayType.COMEDY)); playMap.put("othello", new Play("Othello", PlayType.TRAGEDY)); Plays plays = new Plays(playMap);  String answer = "청구내역 (고객명: BigCo)\n" + "hamlet: $650 55석\n" + "As You Like It: $580 35석\n" + "Othello: $500 40석\n" + "총액: $1730\n" + "적립 포인트: 47점"; //when String result = statement.statement(invoice, plays); //then "<AssertPlaceHolder>"; }
statement(Invoice invoice, Plays plays) throws Exception { StatementData statementData = new StatementData(invoice, plays); return renderPlainText(statementData); }
[*] target: assertEquals(answer, result)
[-] pred: org. junit. Assert. assertEquals ( answer, result )
************************************
************************************
[+] input: shortfallTest() { //given int answer = 5; //when int result = sampleProvince.shortFall(); //then "<AssertPlaceHolder>"; }
shortFall() { return this.demand - this.totalProduction; }
[*] target: assertEquals(answer, result)
[-] pred: org. junit. Assert. assertEquals ( answer, result )
************************************
************************************
[+] input: profitTest() { //given int answer = 230; //when int result = sampleProvince.profit(); //then "<AssertPlaceHolder>"; }
profit() { return demandValue() - demandCost(); }
[*] target: assertEquals(answer, result)
[-] pred: org. junit. Assert. assertEquals ( answer, result )
************************************
************************************
[+] input: testHash() { for (int i = 0; i < 10; i++) { System.out.println(random.nextHex()); }  for (int i = 0; i < 10; i++) { String string = random.nextHex(i); System.out.println(string); Assertions."<AssertPlaceHolder>"; } }
nextHex(int length) { StringBuilder sb = new StringBuilder(); while (sb.length() < length) { sb.append(Integer.toHexString(nextInt())); } sb.setLength(length); return sb.toString(); }
[*] target: assertEquals(string.length(), i)
[-] pred: org. junit. Assert. assertEquals ( string. length ( ), i )
************************************
************************************
[+] input: testPhrase() { for (int i = 0; i < 10; i++) { System.out.println(random.nextPhrase()); }  for (int i = 100; i < 150; i++) { String s = random.nextPhrase(i); System.out.println(s); Assertions."<AssertPlaceHolder>"; } }
nextPhrase(int length) { StringBuilder s = new StringBuilder(); while (s.length() < length) { s.append(nextWord(nextIntBetweenInclusive(1, Math.min(length - s.length() + 1, 19)))).append(" "); } s.setLength(length); return s.toString(); }
[*] target: assertEquals(s.length(), i)
[-] pred: org. junit. Assert. assertEquals ( s. length ( ), i )
************************************
************************************
[+] input: CannotParseOpenApiException { logger.info("Test specification type inference"); OpenApiParser openAPIParser = new OpenApiParser(ApiUnderTest.loadTestApiFromFile("type-inference")); openAPIParser.parse();  File solvedSpecification = new File("apis/.test-apis/type-inference/specifications/solved.json"); Map<String, Object> parsed = Helper.getParserMap (openAPIParser); Gson gson = new Gson(); Reader reader = Files.newBufferedReader(Paths.get(solvedSpecification.getAbsolutePath())); Map<String, Object> rightMap = gson.fromJson(reader, Map.class);  "<AssertPlaceHolder>"; }
parse() throws InvalidOpenApiException {  // The specification is invalid in case it does not contain servers or path properties if (!this.openAPIMap.containsKey("servers")) { throw new InvalidOpenApiException("Missing 'servers' field."); } if (!this.openAPIMap.containsKey("paths")) { throw new InvalidOpenApiException("Missing 'paths' field."); }  /* * Add extension with schema names to enrich the specification and keep track of the specification fields * that have exactly the same schema */ addSchemasNames(); // Solve all the refs normalizing (replace refs with their actual schema) solveOpenAPIrefs(); // Normalize common parameters normalizeCommonParameters(); // Infer parameter type where missing inferParameterTypes(); // Normalize 'required' attribute in request/response bodies unfoldRequiredAttributes();  // Start parsing specification fields OpenApi openAPI = new OpenApi();  // Read servers List<Map<String, Object>> servers = (List<Map<String, Object>>) this.openAPIMap.get("servers"); servers.forEach(server -> { try { openAPI.addServer(new URL((String) server.get("url"))); } catch (MalformedURLException|ClassCastException e) { logger.error(e); } }); if (openAPI.getServers().isEmpty()) { throw new InvalidOpenApiException("No valid server found within the OpenAPI specification."); }  // Read paths and create operations Map<String, Object> paths = (Map<String, Object>) this.openAPIMap.get("paths");  // Fetch paths for (Map.Entry<String, Object> path : paths.entrySet()) {  if (path.getKey().startsWith("x-")) { continue; }  // Fetch operations for (Map.Entry<String, Object> operation : ((Map<String, Object>) path.getValue()).entrySet()) {  if (operation.getKey().startsWith("x-")) { continue; }  Operation o = new Operation(path.getKey(), HttpMethod.getMethod(operation.getKey()), (Map<String, Object>) operation.getValue()); o.setReadOnly(); openAPI.addOperation(o); } }  // Finally, parse specification information Map<String, Object> infoMap = safeGet(this.openAPIMap, "info", LinkedTreeMap.class); Map<String, Object> contactMap = safeGet(infoMap, "contact", LinkedTreeMap.class); Map<String, Object> licenseMap = safeGet(infoMap, "license", LinkedTreeMap.class); openAPI.setTitle(safeGet(infoMap, "title", String.class)); openAPI.setSummary(safeGet(infoMap, "summary", String.class)); openAPI.setDescription(safeGet(infoMap, "description", String.class)); openAPI.setTermsOfService(safeGet(infoMap, "termsOfService", String.class)); openAPI.setContactName(safeGet(contactMap, "name", String.class)); openAPI.setContactUrl(safeGet(contactMap, "url", String.class)); openAPI.setContactEmail(safeGet(contactMap, "email", String.class)); openAPI.setLicenseName(safeGet(licenseMap, "name", String.class)); openAPI.setLicenseUrl(safeGet(licenseMap, "url", String.class)); openAPI.setVersion(safeGet(infoMap, "version", String.class));  logger.info("OpenAPI specification correctly parsed."); return openAPI; }
[*] target: assertEquals(rightMap, parsed)
[-] pred: org. junit. Assert. assertEquals ( rightMap, parsed )
************************************
************************************
[+] input: IOException { List<? extends JavaFileObject> files = List.of( testFiles.get("/workspace/com/gazelle/java/javaparser/generators/ExportingClass.java")); parser.parseClasses(files);  Set<String> expected = Set.of( "example.external.PackageReturn", "example.external.ProtectedReturn", "example.external.PublicReturn"); "<AssertPlaceHolder>"; }
getExportedTypes() { return ImmutableSet.copyOf(exportedTypes); }
[*] target: assertEquals(expected, parser.getExportedTypes())
[-] pred: org. junit. Assert. assertEquals ( expected, parser. getExportedTypes() )
************************************
************************************
[+] input: testHashCode() { JavaIdentifier id = new JavaIdentifier( "com.gazelle.java.javaparser.generators", "JavaIdentifier", "artifact("com.gazelle.java.javaparser:generators")"); int hashCode = 1986351184; "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(packageName, className); }
[*] target: assertEquals(id.hashCode(), hashCode)
[-] pred: org. junit. Assert. assertEquals ( id. hashCode(), hashCode )
************************************
************************************
[+] input: testGetExpression_noLoginUser() { // 准备参数 String tableName = randomString(); Alias tableAlias = new Alias(randomString()); // mock 方法  // 调用 Expression expression = rule.getExpression(tableName, tableAlias); // 断言 "<AssertPlaceHolder>"; }
getExpression(String tableName, Alias tableAlias) { // 只有有登陆用户的情况下，才进行数据权限的处理 LoginUser loginUser = SecurityFrameworkUtils.getLoginUser(); if (loginUser == null) { return null; } // 只有管理员类型的用户，才进行数据权限的处理 if (ObjectUtil.notEqual(loginUser.getUserType(), UserTypeEnum.ADMIN.getValue())) { return null; }  // 获得数据权限 DeptDataPermissionRespDTO deptDataPermission = loginUser.getContext(CONTEXT_KEY, DeptDataPermissionRespDTO.class); // 从上下文中拿不到，则调用逻辑进行获取 if (deptDataPermission == null) { deptDataPermission = permissionApi.getDeptDataPermission(loginUser.getId()); if (deptDataPermission == null) { log.error("[getExpression][LoginUser({}) 获取数据权限为 null]", JsonUtils.toJsonString(loginUser)); throw new NullPointerException(String.format("LoginUser(%d) Table(%s/%s) 未返回数据权限", loginUser.getId(), tableName, tableAlias.getName())); } // 添加到上下文中，避免重复计算 loginUser.setContext(CONTEXT_KEY, deptDataPermission); }  // 情况一，如果是 ALL 可查看全部，则无需拼接条件 if (deptDataPermission.getAll()) { return null; }  // 情况二，即不能查看部门，又不能查看自己，则说明 100% 无权限 if (CollUtil.isEmpty(deptDataPermission.getDeptIds()) && Boolean.FALSE.equals(deptDataPermission.getSelf())) { return new EqualsTo(null, null); // WHERE null = null，可以保证返回的数据为空 }  // 情况三，拼接 Dept 和 User 的条件，最后组合 Expression deptExpression = buildDeptExpression(tableName,tableAlias, deptDataPermission.getDeptIds()); Expression userExpression = buildUserExpression(tableName, tableAlias, deptDataPermission.getSelf(), loginUser.getId()); if (deptExpression == null && userExpression == null) { // TODO 芋艿：获得不到条件的时候，暂时不抛出异常，而是不返回数据 log.warn("[getExpression][LoginUser({}) Table({}/{}) DeptDataPermission({}) 构建的条件为空]", JsonUtils.toJsonString(loginUser), tableName, tableAlias, JsonUtils.toJsonString(deptDataPermission)); //            throw new NullPointerException(String.format("LoginUser(%d) Table(%s/%s) 构建的条件为空", //                    loginUser.getId(), tableName, tableAlias.getName())); return EXPRESSION_NULL; } if (deptExpression == null) { return userExpression; } if (userExpression == null) { return deptExpression; } // 目前，如果有指定部门 + 可查看自己，采用 OR 条件。即，WHERE (dept_id IN ? OR user_id = ?) return new Parenthesis(new OrExpression(deptExpression, userExpression)); }
[*] target: assertNull(expression)
[-] pred: org. junit. Assert. assertNull ( expression )
************************************
************************************
[+] input: testCalculateUsers_noDept() { // 准备参数 DelegateExecution execution = mockDelegateExecution(1L); // mock 方法(startUser) AdminUserRespDTO startUser = randomPojo(AdminUserRespDTO.class, o -> o.setDeptId(10L)); when(adminUserApi.getUser(eq(1L))).thenReturn(startUser); // mock 方法(getStartUserDept)没有部门 when(deptApi.getDept(eq(10L))).thenReturn(null);  // 调用 Set<Long> result = expression.calculateUsers(execution, 1); // 断言 "<AssertPlaceHolder>"; }
calculateUsers(DelegateExecution execution, int level) { Assert.isTrue(level > 0, "level 必须大于 0"); // 获得发起人 ProcessInstance processInstance = processInstanceService.getProcessInstance(execution.getProcessInstanceId()); Long startUserId = NumberUtils.parseLong(processInstance.getStartUserId()); // 获得对应 leve 的部门 DeptRespDTO dept = null; for (int i = 0; i < level; i++) { // 获得 level 对应的部门 if (dept == null) { dept = getStartUserDept(startUserId); if (dept == null) { // 找不到发起人的部门，所以无法使用该规则 return emptySet(); } } else { DeptRespDTO parentDept = deptApi.getDept(dept.getParentId()); if (parentDept == null) { // 找不到父级部门，所以只好结束寻找。原因是：例如说，级别比较高的人，所在部门层级比较少 break; } dept = parentDept; } } return dept.getLeaderUserId() != null ? asSet(dept.getLeaderUserId()) : emptySet(); }
[*] target: assertEquals(0, result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: Exception { // 准备参数 Long configId = 10L; String path = "tudou.jpg"; // mock 方法 FileClient client = mock(FileClient.class); when(fileConfigService.getFileClient(eq(10L))).thenReturn(client); byte[] content = new byte[]{}; when(client.getContent(eq("tudou.jpg"))).thenReturn(content);  // 调用 byte[] result = fileService.getFileContent(configId, path); // 断言 "<AssertPlaceHolder>"; }
getFileContent(Long configId, String path) throws Exception { FileClient client = fileConfigService.getFileClient(configId); Assert.notNull(client, "客户端({}) 不能为空", configId); return client.getContent(path); }
[*] target: assertSame(result, content)
[-] pred: org. junit. Assert. assertSame ( result, content )
************************************
************************************
[+] input: testUpdateNickName_success() { //        // mock 数据 //        MemberUserDO userDO = randomUserDO(); //        userMapper.insert(userDO); // //        // 随机昵称 //        String newNickName = randomString(); // //        // 调用接口修改昵称 //        memberUserService.updateUser(userDO.getId(),newNickName); //        // 查询新修改后的昵称 //        String nickname = memberUserService.getUser(userDO.getId()).getNickname(); //        // 断言 //        "<AssertPlaceHolder>"; //    }
getUser(Long id) { return memberUserMapper.selectById(id); }
[*] target: assertEquals(newNickName,nickname)
[-] pred: org. junit. Assert. assertEquals ( newNickName, nickname )
************************************
************************************
[+] input: checkForPreApproval_approve() { // 准备参数 Long userId = randomLongId(); Integer userType = randomEle(UserTypeEnum.values()).getValue(); String clientId = randomString(); List<String> requestedScopes = Lists.newArrayList("read"); // mock 方法 when(oauth2ClientService.validOAuthClientFromCache(eq(clientId))) .thenReturn(randomPojo(OAuth2ClientDO.class).setAutoApproveScopes(null)); // mock 数据 OAuth2ApproveDO approve = randomPojo(OAuth2ApproveDO.class).setUserId(userId) .setUserType(userType).setClientId(clientId).setScope("read") .setExpiresTime(LocalDateTimeUtil.offset(LocalDateTime.now(), 1L, ChronoUnit.DAYS)).setApproved(true); // 同意 oauth2ApproveMapper.insert(approve);  // 调用 boolean success = oauth2ApproveService.checkForPreApproval(userId, userType, clientId, requestedScopes); // 断言 "<AssertPlaceHolder>"; }
checkForPreApproval(Long userId, Integer userType, String clientId, Collection<String> requestedScopes) { // 第一步，基于 Client 的自动授权计算，如果 scopes 都在自动授权中，则返回 true 通过 OAuth2ClientDO clientDO = oauth2ClientService.validOAuthClientFromCache(clientId); Assert.notNull(clientDO, "客户端不能为空"); // 防御性编程 if (CollUtil.containsAll(clientDO.getAutoApproveScopes(), requestedScopes)) { // gh-877 - if all scopes are auto approved, approvals still need to be added to the approval store. LocalDateTime expireTime = LocalDateTime.now().plusSeconds(TIMEOUT); for (String scope : requestedScopes) { saveApprove(userId, userType, clientId, scope, true, expireTime); } return true; }  // 第二步，算上用户已经批准的授权。如果 scopes 都包含，则返回 true List<OAuth2ApproveDO> approveDOs = getApproveList(userId, userType, clientId); Set<String> scopes = convertSet(approveDOs, OAuth2ApproveDO::getScope, OAuth2ApproveDO::getApproved); // 只保留未过期的 + 同意的 return CollUtil.containsAll(scopes, requestedScopes); }
[*] target: assertTrue(success)
[-] pred: org. junit. Assert. assertTrue ( success )
************************************
************************************
[+] input: checkForPreApproval_reject() { // 准备参数 Long userId = randomLongId(); Integer userType = randomEle(UserTypeEnum.values()).getValue(); String clientId = randomString(); List<String> requestedScopes = Lists.newArrayList("read"); // mock 方法 when(oauth2ClientService.validOAuthClientFromCache(eq(clientId))) .thenReturn(randomPojo(OAuth2ClientDO.class).setAutoApproveScopes(null)); // mock 数据 OAuth2ApproveDO approve = randomPojo(OAuth2ApproveDO.class).setUserId(userId) .setUserType(userType).setClientId(clientId).setScope("read") .setExpiresTime(LocalDateTimeUtil.offset(LocalDateTime.now(), 1L, ChronoUnit.DAYS)).setApproved(false); // 拒绝 oauth2ApproveMapper.insert(approve);  // 调用 boolean success = oauth2ApproveService.checkForPreApproval(userId, userType, clientId, requestedScopes); // 断言 "<AssertPlaceHolder>"; }
checkForPreApproval(Long userId, Integer userType, String clientId, Collection<String> requestedScopes) { // 第一步，基于 Client 的自动授权计算，如果 scopes 都在自动授权中，则返回 true 通过 OAuth2ClientDO clientDO = oauth2ClientService.validOAuthClientFromCache(clientId); Assert.notNull(clientDO, "客户端不能为空"); // 防御性编程 if (CollUtil.containsAll(clientDO.getAutoApproveScopes(), requestedScopes)) { // gh-877 - if all scopes are auto approved, approvals still need to be added to the approval store. LocalDateTime expireTime = LocalDateTime.now().plusSeconds(TIMEOUT); for (String scope : requestedScopes) { saveApprove(userId, userType, clientId, scope, true, expireTime); } return true; }  // 第二步，算上用户已经批准的授权。如果 scopes 都包含，则返回 true List<OAuth2ApproveDO> approveDOs = getApproveList(userId, userType, clientId); Set<String> scopes = convertSet(approveDOs, OAuth2ApproveDO::getScope, OAuth2ApproveDO::getApproved); // 只保留未过期的 + 同意的 return CollUtil.containsAll(scopes, requestedScopes); }
[*] target: assertFalse(success)
[-] pred: org. junit. Assert. assertFalse ( success )
************************************
************************************
[+] input: testDeleteMenu_success() { // mock 数据 MenuDO menuDO = randomPojo(MenuDO.class); menuMapper.insert(menuDO); // 准备参数 Long id = menuDO.getId();  // 调用 menuService.deleteMenu(id); // 断言 MenuDO dbMenuDO = menuMapper.selectById(id); "<AssertPlaceHolder>"; verify(permissionService).processMenuDeleted(id); }
deleteMenu(Long id) { // 校验是否还有子菜单 if (menuMapper.selectCountByParentId(id) > 0) { throw exception(MENU_EXISTS_CHILDREN); } // 校验删除的菜单是否存在 if (menuMapper.selectById(id) == null) { throw exception(MENU_NOT_EXISTS); } // 标记删除 menuMapper.deleteById(id); // 删除授予给角色的权限 permissionService.processMenuDeleted(id); }
[*] target: assertNull(dbMenuDO)
[-] pred: org. junit. Assert. assertNull ( dbMenuDO )
************************************
************************************
[+] input: WxErrorException { // 准备参数 Integer userType = randomPojo(UserTypeEnum.class).getValue(); String url = randomString(); // mock 方法 WxJsapiSignature signature = randomPojo(WxJsapiSignature.class); when(wxMpService.createJsapiSignature(eq(url))).thenReturn(signature);  // 调用 WxJsapiSignature result = socialClientService.createWxMpJsapiSignature(userType, url); // 断言 "<AssertPlaceHolder>"; }
createWxMpJsapiSignature(Integer userType, String url) { WxMpService service = getWxMpService(userType); return service.createJsapiSignature(url); }
[*] target: assertSame(signature, result)
[-] pred: org. junit. Assert. assertSame ( signature, result )
************************************
************************************
[+] input: WxErrorException { // 准备参数 Integer userType = randomPojo(UserTypeEnum.class).getValue(); String phoneCode = randomString(); // mock 方法 WxMaUserService userService = mock(WxMaUserService.class); when(wxMaService.getUserService()).thenReturn(userService); WxMaPhoneNumberInfo phoneNumber = randomPojo(WxMaPhoneNumberInfo.class); when(userService.getPhoneNoInfo(eq(phoneCode))).thenReturn(phoneNumber);  // 调用 WxMaPhoneNumberInfo result = socialClientService.getWxMaPhoneNumberInfo(userType, phoneCode); // 断言 "<AssertPlaceHolder>"; }
getWxMaPhoneNumberInfo(Integer userType, String phoneCode) { WxMaService service = getWxMaService(userType); try { return service.getUserService().getPhoneNoInfo(phoneCode); } catch (WxErrorException e) { log.error("[getPhoneNoInfo][userType({}) phoneCode({}) 获得手机号失败]", userType, phoneCode, e); throw exception(SOCIAL_CLIENT_WEIXIN_MINI_APP_PHONE_CODE_ERROR); } }
[*] target: assertSame(phoneNumber, result)
[-] pred: org. junit. Assert. assertSame ( phoneNumber, result )
************************************
************************************
[+] input: testRawToArrayMsgTest() { val msg = "[CQ:at,qq=1122334455]测试消息1[CQ:face,id=1]测试消息2[CQ:video,file=https://test.com/1.mp4][CQ:image,file=test1.image,url=https://test.com/1.jpg]\n[CQ:image,file=test2.image,url=https://test.com/2.jpg]"; val expected = Arrays.asList( new ArrayMsg().setType(MsgTypeEnum.at).setData(Map.of("qq", "1122334455")), new ArrayMsg().setType(MsgTypeEnum.text).setData(Map.of("text", "测试消息1")), new ArrayMsg().setType(MsgTypeEnum.face).setData(Map.of("id", "1")), new ArrayMsg().setType(MsgTypeEnum.text).setData(Map.of("text", "测试消息2")), new ArrayMsg().setType(MsgTypeEnum.video).setData(Map.of("file", "https://test.com/1.mp4")), new ArrayMsg().setType(MsgTypeEnum.image).setData(Map.of("file", "test1.image", "url", "https://test.com/1.jpg")), new ArrayMsg().setType(MsgTypeEnum.text).setData(Map.of("text", "\n")), new ArrayMsg().setType(MsgTypeEnum.image).setData(Map.of("file", "test2.image", "url", "https://test.com/2.jpg")) ); val actual = ShiroUtils.rawToArrayMsg(msg); "<AssertPlaceHolder>"; }
rawToArrayMsg(@NonNull String msg) { List<ArrayMsg> chain = new ArrayList<>(); try { Arrays.stream(msg.split(CQ_CODE_SPLIT)).filter(s -> !s.isEmpty()).forEach(s -> { Optional<Matcher> matcher = RegexUtils.matcher(CQ_CODE_REGEX, s); ArrayMsg item = new ArrayMsg(); Map<String, String> data = new HashMap<>(); if (matcher.isEmpty()) { item.setType(MsgTypeEnum.text); data.put("text", ShiroUtils.unescape(s)); item.setData(data); } if (matcher.isPresent()) { MsgTypeEnum type = MsgTypeEnum.typeOf(matcher.get().group(1)); String[] params = matcher.get().group(2).split(","); item.setType(type); Arrays.stream(params).filter(args -> !args.isEmpty()).forEach(args -> { String k = args.substring(0, args.indexOf("=")); String v = ShiroUtils.unescape(args.substring(args.indexOf("=") + 1)); data.put(k, v); }); item.setData(data); } chain.add(item); }); } catch (Exception e) { log.error("Conversion failed: {}", e.getMessage()); } return chain; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: drawImageWithNullTransform() { Image img = new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB); g2.drawImage(img, null, null); "<AssertPlaceHolder>"; // won't get here if there's an exception above }
drawImage(Image img, AffineTransform xform, ImageObserver obs) { if (LOG_ENABLED) { LOGGER.debug("drawImage(Image, AffineTransform, ImageObserver)"); } AffineTransform savedTransform = getTransform(); if (xform != null) { transform(xform); } boolean result = drawImage(img, 0, 0, obs); if (xform != null) { setTransform(savedTransform); } return result; }
[*] target: assertTrue(true)
[-] pred: org. junit. Assert. assertTrue ( true )
************************************
************************************
[+] input: testToSkytilsBase64() { List<WaypointCategory> waypointCategories = List.of(new WaypointCategory("category", "hub", List.of(new NamedWaypoint(BlockPos.ORIGIN, "waypoint", new float[]{0f, 0.5f, 1f}, 0.8f, false), new NamedWaypoint(new BlockPos(-1, 0, 1), "1", new float[]{0f, 0f, 0f}, true)))); String waypointCategoriesSkytilsBase64 = Waypoints.toSkytilsBase64(waypointCategories); String expectedWaypointCategoriesSkytilsBase64 = "eyJjYXRlZ29yaWVzIjpbeyJuYW1lIjoiY2F0ZWdvcnkiLCJpc2xhbmQiOiJodWIiLCJ3YXlwb2ludHMiOlt7Im5hbWUiOiJ3YXlwb2ludCIsImNvbG9yIjotODcyMzgyNDY1LCJlbmFibGVkIjpmYWxzZSwieCI6MCwieSI6MCwieiI6MH0seyJuYW1lIjoiMSIsImNvbG9yIjoyMTMwNzA2NDMyLCJlbmFibGVkIjp0cnVlLCJ4IjotMSwieSI6MCwieiI6MX1dfV19";  Assertions."<AssertPlaceHolder>"; }
toSkytilsBase64(List<WaypointCategory> waypointCategories) { return Base64.getEncoder().encodeToString(toSkytilsJson(waypointCategories).getBytes()); }
[*] target: assertEquals(expectedWaypointCategoriesSkytilsBase64, waypointCategoriesSkytilsBase64)
[-] pred: org. junit. Assert. assertEquals ( expectedWaypointCategoriesSkytilsBase64, waypointCategoriesSkytilsBase64 )
************************************
************************************
[+] input: testOnlyNumberValueProvided() { Duration expectedDuration = Duration.ofSeconds(3); Duration actualDuration = DurationUtils.parseDuration("3", "refresh-period"); "<AssertPlaceHolder>"; }
parseDuration(String duration, String parameter) { if (duration.startsWith("-")) { throw new IllegalArgumentException("Negative " + parameter + " specified for service discovery: " + duration); } if (DIGITS.asPredicate().test(duration)) { return Duration.ofSeconds(Long.parseLong(duration)); } return Duration.parse("PT" + duration);  }
[*] target: assertEquals(expectedDuration, actualDuration)
[-] pred: org. junit. Assert. assertEquals ( expectedDuration, actualDuration )
************************************
************************************
[+] input: testNumberWithUnitValueProvided() { Duration expectedDuration = Duration.ofMinutes(3); Duration actualDuration = DurationUtils.parseDuration("3M", "refresh-period"); "<AssertPlaceHolder>"; }
parseDuration(String duration, String parameter) { if (duration.startsWith("-")) { throw new IllegalArgumentException("Negative " + parameter + " specified for service discovery: " + duration); } if (DIGITS.asPredicate().test(duration)) { return Duration.ofSeconds(Long.parseLong(duration)); } return Duration.parse("PT" + duration);  }
[*] target: assertEquals(expectedDuration, actualDuration)
[-] pred: org. junit. Assert. assertEquals ( expectedDuration, actualDuration )
************************************
************************************
[+] input: ensureFreeSpace_underLimit() { File mockFile = mock(File.class); when(spanStorage.provideSpansDirectory()).thenReturn(mockFile);  when(spanStorage.getTotalFileSizeInBytes()).thenReturn(MAX_STORAGE_USE_BYTES - 1); when(mockFile.getFreeSpace()).thenReturn(MAX_STORAGE_USE_BYTES + 1); boolean result = limiter.ensureFreeSpace(); "<AssertPlaceHolder>"; verify(fileUtils, never()).safeDelete(any()); }
ensureFreeSpace() { tryFreeingSpace(); // play nice if disk is getting full return fileProvider.provideSpansDirectory().getFreeSpace() > limitInBytes(); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: ensureFreeSpace_overLimitHappyDeletion() { File file1 = new File("oldest"); File file2 = new File("younger"); File file3 = new File("newest");  File mockFile = mock(File.class); when(spanStorage.provideSpansDirectory()).thenReturn(mockFile); when(spanStorage.getTotalFileSizeInBytes()).thenReturn(MAX_STORAGE_USE_BYTES + 1); when(fileUtils.getModificationTime(file1)).thenReturn(1000L); when(fileUtils.getModificationTime(file2)).thenReturn(1001L); when(fileUtils.getModificationTime(file3)).thenReturn(1002L); when(fileUtils.getFileSize(isA(File.class))).thenReturn(1L); when(spanStorage.getAllSpanFiles()).thenReturn(Stream.of(file3, file1, file2)); when(mockFile.getFreeSpace()).thenReturn(MAX_STORAGE_USE_BYTES + 1); boolean result = limiter.ensureFreeSpace();  verify(fileUtils).safeDelete(file1); verify(fileUtils).safeDelete(file2); verify(fileUtils, never()).safeDelete(file3); "<AssertPlaceHolder>"; }
ensureFreeSpace() { tryFreeingSpace(); // play nice if disk is getting full return fileProvider.provideSpansDirectory().getFreeSpace() > limitInBytes(); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: happyPathSendSpans() { FileSender sender = buildFileSender(); boolean result = sender.handleFileOnDisk(file); "<AssertPlaceHolder>"; verify(bandwidthTracker).tick(fileSpans); }
handleFileOnDisk(File file) { Log.d(LOG_TAG, "Reading file content for ingest: " + file); List<byte[]> encodedSpans = readFileCompletely(file); if (encodedSpans.isEmpty()) { fileUtils.safeDelete(file); return false; }  boolean sentOk = attemptSend(file, encodedSpans); if (!sentOk) { retryTracker.trackFailure(file); } if (sentOk || retryTracker.exceededRetries(file)) { retryTracker.clear(file); fileUtils.safeDelete(file); } return sentOk; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: IOException { Mockito.reset(fileUtils); Mockito.reset(delegate); when(fileUtils.readFileCompletely(file)).thenThrow(new IOException("boom")); FileSender sender = buildFileSender(); boolean result = sender.handleFileOnDisk(file); "<AssertPlaceHolder>"; verifyNoMoreInteractions(bandwidthTracker); verifyNoMoreInteractions(delegate); }
handleFileOnDisk(File file) { Log.d(LOG_TAG, "Reading file content for ingest: " + file); List<byte[]> encodedSpans = readFileCompletely(file); if (encodedSpans.isEmpty()) { fileUtils.safeDelete(file); return false; }  boolean sentOk = attemptSend(file, encodedSpans); if (!sentOk) { retryTracker.trackFailure(file); } if (sentOk || retryTracker.exceededRetries(file)) { retryTracker.clear(file); fileUtils.safeDelete(file); } return sentOk; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: initialization_onlyOnce() { Application application = mock(Application.class, RETURNS_DEEP_STUBS); Context context = mock(Context.class);  SplunkRumBuilder splunkRumBuilder = new SplunkRumBuilder() .setApplicationName("appName") .setBeaconEndpoint("http://backend") .setRumAccessToken("abracadabra") .disableAnrDetection();  when(application.getApplicationContext()).thenReturn(context);  SplunkRum singleton = SplunkRum.initialize(splunkRumBuilder, application); SplunkRum sameInstance = splunkRumBuilder.build(application);  "<AssertPlaceHolder>"; }
initialize(SplunkRumBuilder builder, Application application) { if (INSTANCE != null) { Log.w(LOG_TAG, "Singleton SplunkRum instance has already been initialized."); return INSTANCE; }  if (builder.isSubprocessInstrumentationDisabled() && builder.isSubprocess) { INSTANCE = SplunkRum.noop(); } else { INSTANCE = new RumInitializer(builder, application, startupTimer) .initialize(Looper.getMainLooper()); }  if (builder.isDebugEnabled()) { Log.i( LOG_TAG, "Splunk RUM monitoring initialized with session ID: " + INSTANCE.getRumSessionId()); }  return INSTANCE; }
[*] target: assertSame(singleton, sameInstance)
[-] pred: org. junit. Assert. assertSame ( singleton, sameInstance )
************************************
************************************
[+] input: shouldReturnTrueWhenExistProductOfOwnerBefore() { var ownerId = 1L; var productStatus = ProductStatus.WAITING;  when(productRepository.existsByOwnerIdAndStatus(ownerId, productStatus)).thenReturn(true);  boolean existWaitingProduct = createProductService.existWaitingProductByOwnerId(ownerId);  verify(productRepository).existsByOwnerIdAndStatus(ownerId, productStatus);  "<AssertPlaceHolder>"; }
existWaitingProductByOwnerId(Long ownerId) { return productRepository.existsByOwnerIdAndStatus(ownerId, ProductStatus.WAITING); }
[*] target: assertTrue(existWaitingProduct)
[-] pred: org. junit. Assert. assertTrue ( existWaitingProduct )
************************************
************************************
[+] input: shouldReturnFalseWhenNotExistProductOfOwnerBefore() { var ownerId = 1L; var productStatus = ProductStatus.WAITING;  when(productRepository.existsByOwnerIdAndStatus(ownerId, productStatus)).thenReturn(false);  boolean existWaitingProduct = createProductService.existWaitingProductByOwnerId(ownerId);  verify(productRepository).existsByOwnerIdAndStatus(ownerId, productStatus);  "<AssertPlaceHolder>"; }
existWaitingProductByOwnerId(Long ownerId) { return productRepository.existsByOwnerIdAndStatus(ownerId, ProductStatus.WAITING); }
[*] target: assertFalse(existWaitingProduct)
[-] pred: org. junit. Assert. assertFalse ( existWaitingProduct )
************************************
************************************
[+] input: NoSuchAlgorithmException { DES des = new DES(); byte[] key = des.getKey(); "<AssertPlaceHolder>"; }
getKey(){ return key.getEncoded(); }
[*] target: assertNotNull(key)
[-] pred: org. junit. Assert. assertNotNull ( key )
************************************
************************************
[+] input: NoSuchAlgorithmException { RSA rsa = new RSA(); "<AssertPlaceHolder>"; Base64.Encoder encoder = Base64.getEncoder(); System.out.println("publicKey:" + encoder.encodeToString(rsa.getPublicKey())); }
getPublicKey() { return publicKey.getEncoded(); }
[*] target: assertNotNull(rsa.getPublicKey())
[-] pred: org. junit. Assert. assertNotNull ( rsa. getPublicKey() )
************************************
************************************
[+] input: test() { SessionClient client = new SessionClient(); String html = client.getHtml("https://www.baidu.com"); "<AssertPlaceHolder>"; }
getHtml(String url){ return getHtml(url,null); }
[*] target: assertNotNull(html)
[-] pred: org. junit. Assert. assertNotNull ( html )
************************************
************************************
[+] input: createTrustAnyHttpClient() { ClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(TrustAnyHttpClientFactory.createTrustAnyHttpClient()); RestTemplate restTemplate = new RestTemplate(factory); String response = restTemplate.getForObject("https://www.baidu.com",String.class); "<AssertPlaceHolder>"; }
createTrustAnyHttpClient() { SSLContext sslContext = SSLContext.getInstance("TLS"); TrustAnyTrustManager trustAnyTrustManager = new TrustAnyTrustManager(); sslContext.init(null, new TrustManager[] {trustAnyTrustManager}, null); SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory(sslContext, NoopHostnameVerifier.INSTANCE);  final Registry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory> create() .register("https", sslConnectionSocketFactory) .register("http", new PlainConnectionSocketFactory()) .build();  RequestConfig requestConfig = RequestConfig.custom() .setCircularRedirectsAllowed(true) .build();  BasicHttpClientConnectionManager connectionManager = new BasicHttpClientConnectionManager(socketFactoryRegistry);  return HttpClients.custom() .setDefaultRequestConfig(requestConfig) .setConnectionManager(connectionManager) .build(); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: validateVerificationToken_returnsExpiredIfTokenExpired() { testToken.setExpiryDate(getExpirationDate(0)); when(verificationTokenRepository.findByToken(anyString())).thenReturn(testToken); UserService.TokenValidationResult result = userVerificationService.validateVerificationToken(anyString()); Assertions."<AssertPlaceHolder>"; }
validateVerificationToken(String token) { final VerificationToken verificationToken = tokenRepository.findByToken(token); if (verificationToken == null) { return UserService.TokenValidationResult.INVALID_TOKEN; }  final User user = verificationToken.getUser(); final Calendar cal = Calendar.getInstance(); if (verificationToken.getExpiryDate().before(cal.getTime())) { tokenRepository.delete(verificationToken); return UserService.TokenValidationResult.EXPIRED; }  user.setEnabled(true); userRepository.save(user); return UserService.TokenValidationResult.VALID; }
[*] target: assertEquals(result, UserService.TokenValidationResult.EXPIRED)
[-] pred: org. junit. Assert. assertEquals ( result, UserService.TokenValidationResult.EXPIRED )
************************************
************************************
[+] input: deleteFlintIndexStateModel() { when(mockStateStore.delete(any(), any())).thenReturn(true);  boolean result = openSearchFlintIndexStateModelService.deleteFlintIndexStateModel( ID, DATASOURCE, asyncQueryRequestContext);  "<AssertPlaceHolder>"; }
deleteFlintIndexStateModel( String id, String datasourceName, AsyncQueryRequestContext asyncQueryRequestContext) { return stateStore.delete(id, OpenSearchStateStoreUtil.getIndexName(datasourceName)); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testGetJobRunner() { ScheduledJobRunner jobRunner = OpenSearchAsyncQueryScheduler.getJobRunner(); "<AssertPlaceHolder>"; }
getJobRunner() { return OpenSearchRefreshIndexJob.getJobRunnerInstance(); }
[*] target: assertNotNull(jobRunner)
[-] pred: org. junit. Assert. assertNotNull ( jobRunner )
************************************
************************************
[+] input: sessionEnable() { SessionManager sessionManager = new SessionManager( sessionStorageService, statementStorageService, emrServerlessClientFactory, sessionConfigSupplier, sessionIdProvider);  Assertions."<AssertPlaceHolder>"; }
isEnabled() { return true; }
[*] target: assertTrue(sessionManager.isEnabled())
[-] pred: org. junit. Assert. assertTrue ( sessionManager. isEnabled() )
************************************
************************************
[+] input: testBuildWithoutExtraParameters() { String params = sparkSubmitParametersBuilder.toString();  "<AssertPlaceHolder>"; }
toString() { return sparkSubmitParameters.toString(); }
[*] target: assertNotNull(params)
[-] pred: org. junit. Assert. assertNotNull ( params )
************************************
************************************
[+] input: testBuildQueryStringNestedQuote() { String rawQuery = "SELECT '"1"'"; String expectedQueryInParams = ""SELECT '\\"1\\"'""; String params = sparkSubmitParametersBuilder.query(rawQuery).toString(); "<AssertPlaceHolder>"; }
toString() { return sparkSubmitParameters.toString(); }
[*] target: assertTrue(params.contains(expectedQueryInParams))
[-] pred: org. junit. Assert. assertTrue ( params. contains ( expectedQueryInParams ) )
************************************
************************************
[+] input: can_visit_all_types_of_expression_node() { Expression expr = DSL.regex( DSL.castString(DSL.sum(DSL.add(ref("balance", INTEGER), literal(10)))), DSL.literal("(?<group>\\d+)"), DSL.literal("group"));  Expression actual = expr.accept( new ExpressionNodeVisitor<Expression, Object>() { @Override public Expression visitLiteral(LiteralExpression node, Object context) { return node; }  @Override public Expression visitReference(ReferenceExpression node, Object context) { return node; }  @Override public Expression visitParse(ParseExpression node, Object context) { return node; }  @Override public Expression visitFunction(FunctionExpression node, Object context) { return DSL.add(visitArguments(node.getArguments(), context)); }  @Override public Expression visitAggregator(Aggregator<?> node, Object context) { return DSL.sum(visitArguments(node.getArguments(), context)); }  private Expression[] visitArguments(List<Expression> arguments, Object context) { return arguments.stream() .map(arg -> arg.accept(this, context)) .toArray(Expression[]::new); } }, null);  "<AssertPlaceHolder>"; }
visitAggregator(Aggregator<?> node, C context) { return visitChildren(node, context); }
[*] target: assertEquals(expr, actual)
[-] pred: org. junit. Assert. assertEquals ( expr, actual )
************************************
************************************
[+] input: testGetFieldTypes() { DataSourceTable dataSourceTable = new DataSourceTable(dataSourceService); Map<String, ExprType> fieldTypes = dataSourceTable.getFieldTypes(); Map<String, ExprType> expectedTypes = new HashMap<>(); expectedTypes.put("DATASOURCE_NAME", ExprCoreType.STRING); expectedTypes.put("CONNECTOR_TYPE", ExprCoreType.STRING); "<AssertPlaceHolder>"; }
getFieldTypes() { return DataSourceTableSchema.DATASOURCE_TABLE_SCHEMA.getMapping(); }
[*] target: assertEquals(expectedTypes, fieldTypes)
[-] pred: org. junit. Assert. assertEquals ( expectedTypes, fieldTypes )
************************************
************************************
[+] input: testEncryptAndDecrypt() { String masterKey = "1234567890123456"; String input = "This is a test input"; Encryptor encryptor = new EncryptorImpl(masterKey);  String encrypted = encryptor.encrypt(input); String decrypted = encryptor.decrypt(encrypted);  "<AssertPlaceHolder>"; }
decrypt(String encryptedText) { validate(masterKey); final AwsCrypto crypto = AwsCrypto.builder() .withCommitmentPolicy(CommitmentPolicy.RequireEncryptRequireDecrypt) .build();  JceMasterKey jceMasterKey = JceMasterKey.getInstance( new SecretKeySpec(masterKey.getBytes(), "AES"), "Custom", "opensearch.config.master.key", "AES/GCM/NoPadding");  final CryptoResult<byte[], JceMasterKey> decryptedResult = crypto.decryptData(jceMasterKey, Base64.getDecoder().decode(encryptedText)); return new String(decryptedResult.getResult()); }
[*] target: assertEquals(input, decrypted)
[-] pred: org. junit. Assert. assertEquals ( input, decrypted )
************************************
************************************
[+] input: schedule() { AtomicBoolean isRun = new AtomicBoolean(false); client.schedule( () -> { isRun.set(true); }); "<AssertPlaceHolder>"; }
schedule(Runnable task) { // at that time, task already running the sql-worker ThreadPool. task.run(); }
[*] target: assertTrue(isRun.get())
[-] pred: org. junit. Assert. assertTrue ( isRun. get ( ) )
************************************
************************************
[+] input: schedule() { AtomicBoolean isRun = new AtomicBoolean(false); client.schedule(() -> isRun.set(true)); "<AssertPlaceHolder>"; }
schedule(Runnable task) { task.run(); }
[*] target: assertTrue(isRun.get())
[-] pred: org. junit. Assert. assertTrue ( isRun. get ( ) )
************************************
************************************
[+] input: IOException { when(restClient.indices().get(any(GetIndexRequest.class), any(RequestOptions.class))) .thenReturn(getIndexResponse); when(getIndexResponse.getIndices()).thenReturn(new String[] {"index"});  final List<String> indices = client.indices(); "<AssertPlaceHolder>"; }
indices() { try { GetIndexResponse indexResponse = client.indices().get(new GetIndexRequest(), RequestOptions.DEFAULT); final Stream<String> aliasStream = ImmutableList.copyOf(indexResponse.getAliases().values()).stream() .flatMap(Collection::stream) .map(AliasMetadata::alias); return Stream.concat(Arrays.stream(indexResponse.getIndices()), aliasStream) .collect(Collectors.toList()); } catch (IOException e) { throw new IllegalStateException("Failed to get indices", e); } }
[*] target: assertFalse(indices.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( indices. isEmpty ( ) )
************************************
************************************
[+] input: submitQuery() { NodeClient nodeClient = mock(NodeClient.class); ThreadPool threadPool = mock(ThreadPool.class); when(nodeClient.threadPool()).thenReturn(threadPool);  AtomicBoolean isRun = new AtomicBoolean(false); AbstractPlan queryPlan = new QueryPlan(queryId, plan, queryService, listener) { @Override public void execute() { isRun.set(true); } };  doAnswer( invocation -> { Runnable task = invocation.getArgument(0); task.run(); return null; }) .when(threadPool) .schedule(any(), any(), any()); new OpenSearchQueryManager(nodeClient).submit(queryPlan);  "<AssertPlaceHolder>"; }
submit(AbstractPlan queryPlan) { schedule(nodeClient, () -> queryPlan.execute());  return queryPlan.getQueryId(); }
[*] target: assertTrue(isRun.get())
[-] pred: org. junit. Assert. assertTrue ( isRun. get ( ) )
************************************
************************************
[+] input: getPlanForSerialization() { plan = mock(PhysicalPlan.class, withSettings().extraInterfaces(SerializablePlan.class)); monitorPlan = new ResourceMonitorPlan(plan, resourceMonitor); "<AssertPlaceHolder>"; }
getPlanForSerialization() { return (SerializablePlan) delegate; }
[*] target: assertEquals(plan, monitorPlan.getPlanForSerialization())
[-] pred: org. junit. Assert. assertEquals ( plan, monitorPlan. getPlanForSerialization() )
************************************
************************************
[+] input: isHealthy() { when(memoryMonitor.isMemoryHealthy(anyLong())).thenReturn(true);  OpenSearchResourceMonitor resourceMonitor = new OpenSearchResourceMonitor(settings, memoryMonitor); "<AssertPlaceHolder>"; }
isHealthy() { try { ByteSizeValue limit = settings.getSettingValue(Settings.Key.QUERY_MEMORY_LIMIT); Supplier<Boolean> booleanSupplier = Retry.decorateSupplier(retry, () -> memoryMonitor.isMemoryHealthy(limit.getBytes())); return booleanSupplier.get(); } catch (Exception e) { return false; } }
[*] target: assertTrue(resourceMonitor.isHealthy())
[-] pred: org. junit. Assert. assertTrue ( resourceMonitor. isHealthy() )
************************************
************************************
[+] input: notHealthyFastFailure() { when(memoryMonitor.isMemoryHealthy(anyLong())) .thenThrow(OpenSearchMemoryHealthy.MemoryUsageExceedFastFailureException.class);  OpenSearchResourceMonitor resourceMonitor = new OpenSearchResourceMonitor(settings, memoryMonitor); "<AssertPlaceHolder>"; verify(memoryMonitor, times(1)).isMemoryHealthy(anyLong()); }
isHealthy() { try { ByteSizeValue limit = settings.getSettingValue(Settings.Key.QUERY_MEMORY_LIMIT); Supplier<Boolean> booleanSupplier = Retry.decorateSupplier(retry, () -> memoryMonitor.isMemoryHealthy(limit.getBytes())); return booleanSupplier.get(); } catch (Exception e) { return false; } }
[*] target: assertFalse(resourceMonitor.isHealthy())
[-] pred: org. junit. Assert. assertFalse ( resourceMonitor. isHealthy() )
************************************
************************************
[+] input: notHealthyWithRetry() { when(memoryMonitor.isMemoryHealthy(anyLong())) .thenThrow(OpenSearchMemoryHealthy.MemoryUsageExceedException.class);  OpenSearchResourceMonitor resourceMonitor = new OpenSearchResourceMonitor(settings, memoryMonitor); "<AssertPlaceHolder>"; verify(memoryMonitor, times(3)).isMemoryHealthy(anyLong()); }
isHealthy() { try { ByteSizeValue limit = settings.getSettingValue(Settings.Key.QUERY_MEMORY_LIMIT); Supplier<Boolean> booleanSupplier = Retry.decorateSupplier(retry, () -> memoryMonitor.isMemoryHealthy(limit.getBytes())); return booleanSupplier.get(); } catch (Exception e) { return false; } }
[*] target: assertFalse(resourceMonitor.isHealthy())
[-] pred: org. junit. Assert. assertFalse ( resourceMonitor. isHealthy() )
************************************
************************************
[+] input: healthyWithRetry() {  when(memoryMonitor.isMemoryHealthy(anyLong())) .thenThrow(OpenSearchMemoryHealthy.MemoryUsageExceedException.class) .thenReturn(true);  OpenSearchResourceMonitor resourceMonitor = new OpenSearchResourceMonitor(settings, memoryMonitor); "<AssertPlaceHolder>"; verify(memoryMonitor, times(2)).isMemoryHealthy(anyLong()); }
isHealthy() { try { ByteSizeValue limit = settings.getSettingValue(Settings.Key.QUERY_MEMORY_LIMIT); Supplier<Boolean> booleanSupplier = Retry.decorateSupplier(retry, () -> memoryMonitor.isMemoryHealthy(limit.getBytes())); return booleanSupplier.get(); } catch (Exception e) { return false; } }
[*] target: assertTrue(resourceMonitor.isHealthy())
[-] pred: org. junit. Assert. assertTrue ( resourceMonitor. isHealthy() )
************************************
************************************
[+] input: response_is_aggregation_when_aggregation_not_empty() { when(searchResponse.getAggregations()).thenReturn(aggregations);  OpenSearchResponse response = new OpenSearchResponse(searchResponse, factory, includes); "<AssertPlaceHolder>"; }
isAggregationResponse() { return aggregations != null; }
[*] target: assertTrue(response.isAggregationResponse())
[-] pred: org. junit. Assert. assertTrue ( response. isAggregationResponse ( ) )
************************************
************************************
[+] input: response_isnot_aggregation_when_aggregation_is_empty() { when(searchResponse.getAggregations()).thenReturn(null);  OpenSearchResponse response = new OpenSearchResponse(searchResponse, factory, includes); "<AssertPlaceHolder>"; }
isAggregationResponse() { return aggregations != null; }
[*] target: assertFalse(response.isAggregationResponse())
[-] pred: org. junit. Assert. assertFalse ( response. isAggregationResponse ( ) )
************************************
************************************
[+] input: getSettingValue() { when(clusterSettings.get(ClusterName.CLUSTER_NAME_SETTING)).thenReturn(ClusterName.DEFAULT); when(clusterSettings.get(not((eq(ClusterName.CLUSTER_NAME_SETTING))))).thenReturn(null); OpenSearchSettings settings = new OpenSearchSettings(clusterSettings); ByteSizeValue sizeValue = settings.getSettingValue(Settings.Key.QUERY_MEMORY_LIMIT);  "<AssertPlaceHolder>"; }
getSettingValue(Settings.Key key) { return (T) latestSettings.getOrDefault(key, defaultSettings.get(key).getDefault(EMPTY)); }
[*] target: assertNotNull(sizeValue)
[-] pred: org. junit. Assert. assertNotNull ( sizeValue )
************************************
************************************
[+] input: can_serialize_and_deserialize_literals() { Expression original = literal(10); Expression actual = serializer.deserialize(serializer.serialize(original)); "<AssertPlaceHolder>"; }
serialize(Expression expr) { try { ByteArrayOutputStream output = new ByteArrayOutputStream(); ObjectOutputStream objectOutput = new ObjectOutputStream(output); objectOutput.writeObject(expr); objectOutput.flush(); return Base64.getEncoder().encodeToString(output.toByteArray()); } catch (IOException e) { throw new IllegalStateException("Failed to serialize expression: " + expr, e); } }
[*] target: assertEquals(original, actual)
[-] pred: org. junit. Assert. assertEquals ( original, actual )
************************************
************************************
[+] input: can_serialize_and_deserialize_references() { Expression original = ref("name", STRING); Expression actual = serializer.deserialize(serializer.serialize(original)); "<AssertPlaceHolder>"; }
serialize(Expression expr) { try { ByteArrayOutputStream output = new ByteArrayOutputStream(); ObjectOutputStream objectOutput = new ObjectOutputStream(output); objectOutput.writeObject(expr); objectOutput.flush(); return Base64.getEncoder().encodeToString(output.toByteArray()); } catch (IOException e) { throw new IllegalStateException("Failed to serialize expression: " + expr, e); } }
[*] target: assertEquals(original, actual)
[-] pred: org. junit. Assert. assertEquals ( original, actual )
************************************
************************************
[+] input: can_serialize_and_deserialize_predicates() { Expression original = DSL.or(literal(true), DSL.less(literal(1), literal(2))); Expression actual = serializer.deserialize(serializer.serialize(original)); "<AssertPlaceHolder>"; }
serialize(Expression expr) { try { ByteArrayOutputStream output = new ByteArrayOutputStream(); ObjectOutputStream objectOutput = new ObjectOutputStream(output); objectOutput.writeObject(expr); objectOutput.flush(); return Base64.getEncoder().encodeToString(output.toByteArray()); } catch (IOException e) { throw new IllegalStateException("Failed to serialize expression: " + expr, e); } }
[*] target: assertEquals(original, actual)
[-] pred: org. junit. Assert. assertEquals ( original, actual )
************************************
************************************
[+] input: can_serialize_and_deserialize_functions() { Expression original = DSL.abs(literal(30.0)); Expression actual = serializer.deserialize(serializer.serialize(original)); "<AssertPlaceHolder>"; }
serialize(Expression expr) { try { ByteArrayOutputStream output = new ByteArrayOutputStream(); ObjectOutputStream objectOutput = new ObjectOutputStream(output); objectOutput.writeObject(expr); objectOutput.flush(); return Base64.getEncoder().encodeToString(output.toByteArray()); } catch (IOException e) { throw new IllegalStateException("Failed to serialize expression: " + expr, e); } }
[*] target: assertEquals(original, actual)
[-] pred: org. junit. Assert. assertEquals ( original, actual )
************************************
************************************
[+] input: testIsExist() { Table systemIndex = new OpenSearchSystemIndex(client, TABLE_INFO); "<AssertPlaceHolder>"; }
exists() { return true; // TODO: implement for system index later }
[*] target: assertTrue(systemIndex.exists())
[-] pred: org. junit. Assert. assertTrue ( systemIndex. exists() )
************************************
************************************
[+] input: should_support_query() { SQLQueryRequest request = SQLQueryRequestBuilder.request("SELECT 1").build(); "<AssertPlaceHolder>"; }
isSupported() { boolean hasCursor = isCursor(); boolean hasQuery = query != null; boolean hasContent = jsonContent != null && !jsonContent.isEmpty();  Predicate<String> supportedParams = Set.of(QUERY_PARAMS_FORMAT, QUERY_PARAMS_PRETTY)::contains; boolean hasUnsupportedParams = (!params.isEmpty()) && params.keySet().stream().dropWhile(supportedParams).findAny().isPresent();  boolean validCursor = hasCursor && !hasQuery && !hasUnsupportedParams && !hasContent; boolean validQuery = !hasCursor && hasQuery;  return (validCursor || validQuery) // It's a valid cursor or a valid query && isOnlySupportedFieldInPayload() // and request must contain supported fields only && isSupportedFormat(); // and request must be a supported format }
[*] target: assertTrue(request.isSupported())
[-] pred: org. junit. Assert. assertTrue ( request. isSupported ( ) )
************************************
************************************
[+] input: should_support_query_without_parameters() { SQLQueryRequest requestWithNoParams = SQLQueryRequestBuilder.request("SELECT 1").params(Map.of()).build(); "<AssertPlaceHolder>"; }
isSupported() { boolean hasCursor = isCursor(); boolean hasQuery = query != null; boolean hasContent = jsonContent != null && !jsonContent.isEmpty();  Predicate<String> supportedParams = Set.of(QUERY_PARAMS_FORMAT, QUERY_PARAMS_PRETTY)::contains; boolean hasUnsupportedParams = (!params.isEmpty()) && params.keySet().stream().dropWhile(supportedParams).findAny().isPresent();  boolean validCursor = hasCursor && !hasQuery && !hasUnsupportedParams && !hasContent; boolean validQuery = !hasCursor && hasQuery;  return (validCursor || validQuery) // It's a valid cursor or a valid query && isOnlySupportedFieldInPayload() // and request must contain supported fields only && isSupportedFormat(); // and request must be a supported format }
[*] target: assertTrue(requestWithNoParams.isSupported())
[-] pred: org. junit. Assert. assertTrue ( requestWithNoParams. isSupported ( ) )
************************************
************************************
[+] input: should_support_query_with_zero_fetch_size() { SQLQueryRequest request = SQLQueryRequestBuilder.request("SELECT 1") .jsonContent("{"query": "SELECT 1", "fetch_size": 0}") .build(); "<AssertPlaceHolder>"; }
isSupported() { boolean hasCursor = isCursor(); boolean hasQuery = query != null; boolean hasContent = jsonContent != null && !jsonContent.isEmpty();  Predicate<String> supportedParams = Set.of(QUERY_PARAMS_FORMAT, QUERY_PARAMS_PRETTY)::contains; boolean hasUnsupportedParams = (!params.isEmpty()) && params.keySet().stream().dropWhile(supportedParams).findAny().isPresent();  boolean validCursor = hasCursor && !hasQuery && !hasUnsupportedParams && !hasContent; boolean validQuery = !hasCursor && hasQuery;  return (validCursor || validQuery) // It's a valid cursor or a valid query && isOnlySupportedFieldInPayload() // and request must contain supported fields only && isSupportedFormat(); // and request must be a supported format }
[*] target: assertTrue(request.isSupported())
[-] pred: org. junit. Assert. assertTrue ( request. isSupported ( ) )
************************************
************************************
[+] input: should_support_query_with_parameters_and_zero_fetch_size() { SQLQueryRequest request = SQLQueryRequestBuilder.request("SELECT 1") .jsonContent("{"query": "SELECT 1", "fetch_size": 0, "parameters":[]}") .build(); "<AssertPlaceHolder>"; }
isSupported() { boolean hasCursor = isCursor(); boolean hasQuery = query != null; boolean hasContent = jsonContent != null && !jsonContent.isEmpty();  Predicate<String> supportedParams = Set.of(QUERY_PARAMS_FORMAT, QUERY_PARAMS_PRETTY)::contains; boolean hasUnsupportedParams = (!params.isEmpty()) && params.keySet().stream().dropWhile(supportedParams).findAny().isPresent();  boolean validCursor = hasCursor && !hasQuery && !hasUnsupportedParams && !hasContent; boolean validQuery = !hasCursor && hasQuery;  return (validCursor || validQuery) // It's a valid cursor or a valid query && isOnlySupportedFieldInPayload() // and request must contain supported fields only && isSupportedFormat(); // and request must be a supported format }
[*] target: assertTrue(request.isSupported())
[-] pred: org. junit. Assert. assertTrue ( request. isSupported ( ) )
************************************
************************************
[+] input: should_not_support_request_with_unknown_field() { SQLQueryRequest request = SQLQueryRequestBuilder.request("SELECT 1").jsonContent("{"pewpew": 42}").build(); "<AssertPlaceHolder>"; }
isSupported() { boolean hasCursor = isCursor(); boolean hasQuery = query != null; boolean hasContent = jsonContent != null && !jsonContent.isEmpty();  Predicate<String> supportedParams = Set.of(QUERY_PARAMS_FORMAT, QUERY_PARAMS_PRETTY)::contains; boolean hasUnsupportedParams = (!params.isEmpty()) && params.keySet().stream().dropWhile(supportedParams).findAny().isPresent();  boolean validCursor = hasCursor && !hasQuery && !hasUnsupportedParams && !hasContent; boolean validQuery = !hasCursor && hasQuery;  return (validCursor || validQuery) // It's a valid cursor or a valid query && isOnlySupportedFieldInPayload() // and request must contain supported fields only && isSupportedFormat(); // and request must be a supported format }
[*] target: assertFalse(request.isSupported())
[-] pred: org. junit. Assert. assertFalse ( request. isSupported ( ) )
************************************
************************************
[+] input: testUpdateWithTypeEmbed() { var intCell = RecordCellDesc.builder().dataStoreValueType(ColumnType.INT32).scalarValue("00000001").build(); var rows = List.of( RecordRowDesc.builder().cells(Map.of("key", intCell)).build() ); var req = UpdateTableEmbeddedRequest.builder() .tableName("t") .keyColumn("key") .rows(rows) .build();  // update with type this.dataStore.updateWithTypeEmbed(req); var result = this.dataStore.scan(DataStoreScanRequest.builder() .tables(List.of(DataStoreScanRequest.TableInfo.builder() .tableName("t") .keepNone(true) .build())) .keepNone(true) .encodeWithType(true) .build()); var expected = new RecordList( null, Map.of("key", ColumnHintsDesc.builder() .typeHints(List.of("INT32")) .columnValueHints(List.of("1")) .build()), List.of(Map.of("key", Map.of("type", "INT32", "value", "00000001"))), "00000001", "INT32" ); "<AssertPlaceHolder>"; }
scan(DataStoreScanRequest req) { var limit = req.getLimit(); if (limit > QUERY_LIMIT) { throw new SwValidationException(SwValidationException.ValidSubject.DATASTORE, "limit must be less or equal to " + QUERY_LIMIT + ". request=" + req); } if (limit < 0) { limit = QUERY_LIMIT; } int finalLimit = limit; return scanRecords(req, new ResultResolver<>() { @Override public RecordList apply( List<TableMeta> tables, Map<String, ColumnSchema> columnSchemaMap, List<TableRecords> records ) { BaseValue lastKey = null; List<Map<String, Object>> ret = new ArrayList<>(); while (!records.isEmpty() && ret.size() < finalLimit) { lastKey = Collections.min(records, (a, b) -> { var x = a.record.getKey(); var y = b.record.getKey(); return x.compareTo(y); }).record.getKey(); Map<String, Object> record = null; for (var r : records) { if (r.record.getKey().equals(lastKey)) { if (r.record.isDeleted()) { record = null; } else { if (record == null) { record = new HashMap<>(); } record.putAll( RecordEncoder.encodeRecord(r.record.getValues(), req.isRawResult(), req.isEncodeWithType())); } if (r.iterator.hasNext()) { r.record = r.iterator.next(); } else { r.record = null; } } } if (record != null) { if (!req.isKeepNone()) { record.entrySet().removeIf(x -> x.getValue() == null); } ret.add(record); } records.removeIf(r -> r.record == null); } var columnStatistics = new HashMap<String, ColumnStatistics>(); for (var table : tables) { table.table.getColumnStatistics(table.columns).forEach((k, v) -> columnStatistics.computeIfAbsent(k, x -> new ColumnStatistics()).merge(v)); } return new RecordList( columnSchemaMap, columnStatistics.entrySet().stream().collect( Collectors.toMap(Entry::getKey, entry -> entry.getValue().toColumnHintsDesc())), ret, (String) BaseValue.encode(lastKey, false, false), BaseValue.getColumnType(lastKey).name() ); }  @Override public boolean stop(int recordSize) { return recordSize >= finalLimit; }  @Override public RecordList empty() { return new RecordList( Collections.emptyMap(), Collections.emptyMap(), Collections.emptyList(), null, null); } } ); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testFindTag() { var entity = BundleVersionTagEntity.builder() .type("MODEL") .bundleId(1L) .versionId(2L) .tag("tag") .build(); when(bundleVersionTagMapper.findTag("MODEL", 1L, "tag")).thenReturn(entity); var get = bundleVersionTagDao.findTag(BundleAccessor.Type.MODEL, 1L, "tag"); verify(bundleVersionTagMapper).findTag("MODEL", 1L, "tag"); "<AssertPlaceHolder>"; }
findTag(BundleAccessor.Type type, Long bundleId, String tag) { return bundleVersionTagMapper.findTag(type.name(), bundleId, tag); }
[*] target: assertEquals(entity, get)
[-] pred: org. junit. Assert. assertEquals ( entity, get )
************************************
************************************
[+] input: testAddAndGetWithId() { var step = StepEntity.builder() .uuid("uuid") .name("name") .jobId(4L) .lastStepId(5L) .status(StepStatus.RUNNING) .concurrency(3) .taskNum(10) .originJson("{"foo": "bar"}") .build();  stepMapper.save(step); var step2 = stepMapper.findById(step.getId()); step.setCreatedTime(step2.getCreatedTime()); step.setModifiedTime(step2.getModifiedTime()); Assertions."<AssertPlaceHolder>"; }
findById(@Param("id") Long id);  @Update("update step set last_step_id = #{lastStepId}
[*] target: assertEquals(step, step2)
[-] pred: org. junit. Assert. assertEquals ( step, step2 )
************************************
************************************
[+] input: testAddAndGet() { String taskUuid = UUID.randomUUID().toString(); TaskEntity task = TaskEntity.builder() .taskStatus(TaskStatus.CREATED).retryNum(0).taskUuid(taskUuid).stepId(1L).build(); taskMapper.addTask(task); TaskEntity db2Memory = taskMapper.findTaskById(task.getId()); Assertions."<AssertPlaceHolder>"; }
findTaskById(@Param("taskId") Long taskId);  @Select("select " + COLUMNS + " from task_info where task_uuid = #{taskUuid}
[*] target: assertEquals(task, db2Memory)
[-] pred: org. junit. Assert. assertEquals ( task, db2Memory )
************************************
************************************
[+] input: shouldGetFirstMatchingLabelNodeInstruction() {  List<Integer[]> labelIndexPairs = ImmutableList.of( new Integer[] { 0, 6 }, new Integer[] { 6, 12 }, new Integer[] { 12, 23 }, new Integer[] { 23, 27 } ); for (int i1 = 0; i1 < labelIndexPairs.size(); i1++) { List<AbstractInsnNode> insnToMatch = new ArrayList<>(); Integer[] labelIndexPair = labelIndexPairs.get(i1); for (int i2 = labelIndexPair[0]; i2 < labelIndexPair[1]; i2++) { insnToMatch.add(instructions.get(i2)); } LabelNode expectedLabel = LABELS[i1]; LabelNode actualLabel = AsmUtils.getFirstMatchingLabelNode(createInstructionList(), insnToMatch); Assertions."<AssertPlaceHolder>"; } }
getFirstMatchingLabelNode(InsnList list, List<AbstractInsnNode> match) {  //@formatter:off for (int i1 = 0; i1 < list.size(); i1++) { AbstractInsnNode instruction = list.get(i1); if (instruction instanceof LabelNode) { int i3 = i1 + 1; boolean matchedInstructions = true; for (int i2 = 0; i2 < match.size() && i3 < list.size(); i2++, i3++) { AbstractInsnNode a = list.get(i3); // ignore line number nodes if (!(a instanceof LineNumberNode)) { AbstractInsnNode b = match.get(i2); // ignore label and line number nodes if (!(b instanceof LabelNode) && !(b instanceof LineNumberNode)) { if (!AsmUtils.equalNodes(a, b)) { matchedInstructions = false; break; } } else i3 -= 1;	// when ignoring nodes counter variables }					// need to be adjusted to compensate for else i2 -= 1;		// the for-loop auto-incremental operation } if (matchedInstructions) { return (LabelNode) instruction; } } }//@formatter:on return null; }
[*] target: assertEquals(expectedLabel, actualLabel)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel )
************************************
************************************
[+] input: basic() { String realCode = """ int x=5; String y =foo("bar");""";  List<TokenType> expectedTypes = List.of(TokenType.INT, TokenType.WHITESPACE, TokenType.IDENTIFIER, TokenType.ASSIGN, TokenType.NUMBER, TokenType.SEMICOLON, TokenType.WHITESPACE, TokenType.IDENTIFIER, TokenType.WHITESPACE, TokenType.IDENTIFIER, TokenType.WHITESPACE, TokenType.ASSIGN, TokenType.IDENTIFIER, TokenType.OPEN_PARENTHESIS, TokenType.STRING, TokenType.CLOSE_PARENTHESIS, TokenType.SEMICOLON);  List<TokenType> actualTypes = tokenize(realCode);  "<AssertPlaceHolder>"; }
tokenize(CharSequence code) { if (code.isEmpty()) { return List.of(); }  List<Token> tokens = new ArrayList<>(); CharBuffer remainingCode = CharBuffer.wrap(code);  while (!remainingCode.isEmpty()) { Token token = nextToken(remainingCode); tokens.add(token);  advancePosition(remainingCode, token.content().length()); }  return tokens; }
[*] target: assertEquals(expectedTypes, actualTypes)
[-] pred: org. junit. Assert. assertEquals ( expectedTypes, actualTypes )
************************************
************************************
[+] input: testOneProvider() { Set<Service<MyService>> services = ServiceRegistry.INSTANCE.allServicesFor(MyService.class); System.out.println(services); Assertions."<AssertPlaceHolder>"; }
allServicesFor(@NotNull Class<T> clazz) { Objects.requireNonNull(clazz, "clazz"); if (!hasRegistration(clazz)) { return Collections.emptySet(); }  List<Service<?>> services = servicesMap.get(clazz); if (services == null || services.isEmpty()) { return Collections.emptySet(); }  Set<Service<T>> ret = new HashSet<>(); for (Service<?> service : services) { ret.add((Service<T>) service); }  return ret; }
[*] target: assertEquals(1, services.size())
[-] pred: org. junit. Assert. assertEquals ( 1, services. size ( ) )
************************************
************************************
[+] input: Exception { helper.createTestDocument(); ExportDocumentsParameters exportDocumentsParameters = new ExportDocumentsParameters(); exportDocumentsParameters.setExcludeFields("id,publication_year,authors"); String exportStr = client.collections("books").documents().export(exportDocumentsParameters); String expectedExportStr = "{"average_rating":3.2,"ratings_count":124,"title":"Romeo and juliet"}"; "<AssertPlaceHolder>"; }
export(ExportDocumentsParameters exportDocumentsParameters) throws Exception { return this.apiCall.get(getEndPoint("export"), exportDocumentsParameters, String.class); }
[*] target: assertEquals(expectedExportStr, exportStr)
[-] pred: org. junit. Assert. assertEquals ( expectedExportStr, exportStr )
************************************
************************************
[+] input: removeNode() { consistentHashRouter.removeNode(() -> "1"); Node node = consistentHashRouter.routeNode("1"); "<AssertPlaceHolder>"; }
routeNode(String businessKey) { if (ring.isEmpty()) { logger.debug("哈希环为空"); return null; } Long hashOfBusinessKey = this.hashAlgorithm.hash(businessKey); // 截取哈希环中比当前业务值哈希大的部分环 map SortedMap<Long, VirtualNode<T>> biggerTailMap = ring.tailMap(hashOfBusinessKey); // 获取路由到的虚拟节点的 hash Long nodeHash; if (biggerTailMap.isEmpty()) { // 没有，回到整个哈希环的环首 nodeHash = ring.firstKey(); } else { // 存在，则为被截取后的 tailMap 的首个节点 key nodeHash = biggerTailMap.firstKey(); } VirtualNode<T> virtualNode = ring.get(nodeHash); return virtualNode.getPhysicalNode(); }
[*] target: assertNull(node)
[-] pred: org. junit. Assert. assertNull ( node )
************************************
************************************
[+] input: getNamingService() { NacosNamingService namingService = namingServiceConfig.getNamingService(); "<AssertPlaceHolder>"; }
getNamingService() { logger.info("注入 Nacos ({}) 名称服务", webSocketProperties.getNacosServerAddress()); NacosNamingService namingService = null; Properties properties = new Properties(); properties.put("namespace", webSocketProperties.getNacosNamespace()); properties.put("serverAddr", webSocketProperties.getNacosServerAddress()); try { namingService = new NacosNamingService(properties); } catch (NacosException e) { logger.error("NacosNamingService 创建异常: {}", e.toString()); } return namingService; }
[*] target: assertNotNull(namingService)
[-] pred: org. junit. Assert. assertNotNull ( namingService )
************************************
************************************
[+] input: run() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  // trigger data final TriggerParam triggerParam = new TriggerParam(); triggerParam.setJobId(1); triggerParam.setExecutorHandler("demoJobHandler"); triggerParam.setExecutorParams(null); triggerParam.setExecutorBlockStrategy(ExecutorBlockStrategyEnum.COVER_EARLY.name()); triggerParam.setGlueType(GlueTypeEnum.BEAN.name()); triggerParam.setGlueSource(null); triggerParam.setGlueUpdatetime(System.currentTimeMillis()); triggerParam.setLogId(1); triggerParam.setLogDateTime(System.currentTimeMillis());  // Act final ReturnT<String> retval = executorBiz.run(triggerParam);  // Assert result Assertions."<AssertPlaceHolder>"; }
run(TriggerParam triggerParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: shouldCompareEqualArraysAsZero() { // given final OffsetDateTime date = OffsetDateTime.of(2023, 10, 5, 15, 50, 0, 0, ZoneOffset.of("+02:00"));  final OffsetDateTime sameDate = OffsetDateTime.of(2023, 10, 5, 15, 50, 0, 0, ZoneOffset.of("+02:00"));  final ExpandableArrayBuffer dateKeyBuffer = new ExpandableArrayBuffer(); dateKeyBuffer.putLong(0, date.toInstant().toEpochMilli(), ZeebeDbConstants.ZB_DB_BYTE_ORDER);  final ExpandableArrayBuffer sameDateKeyBuffer = new ExpandableArrayBuffer(); sameDateKeyBuffer.putLong( 0, sameDate.toInstant().toEpochMilli(), ZeebeDbConstants.ZB_DB_BYTE_ORDER);  final Bytes dateBytes = Bytes.fromExpandableArrayBuffer(dateKeyBuffer); final Bytes sameDateBytes = Bytes.fromExpandableArrayBuffer(sameDateKeyBuffer);  // when final int result = dateBytes.compareTo(sameDateBytes);  // then Assertions."<AssertPlaceHolder>"; }
compareTo(final Bytes other) { return Arrays.compareUnsigned(byteArray, other.byteArray); }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 0, result )
************************************
************************************
[+] input: testVerifySignedTypedData() { final String signature = "0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b915621c";  boolean verified = key.verifyTypedData(domain, message, signature).join();  "<AssertPlaceHolder>"; }
verifyTypedData(Eip712Domain domain, S typedData, String signature) { return this.verifySignature(signature, Eip712Encoder.typedDataToSignedBytes(domain, typedData), false); }
[*] target: assertTrue(verified)
[-] pred: org. junit. Assert. assertTrue ( verified )
************************************
************************************
[+] input: hashBytecode() { String expected = "0x010000517112c421df08d7b49e4dc1312f4ee62268ee4f5683b11d9e2d33525a";  byte[] result = ContractDeployer.hashBytecode(Numeric.hexStringToByteArray(CounterContract.BINARY)); String resultHex = Numeric.toHexString(result);  Assertions."<AssertPlaceHolder>"; }
hashBytecode(byte[] bytecode) { byte[] bytecodeHash = Hash.sha256(bytecode);  if (bytecode.length % 32 != 0) { throw new IllegalArgumentException("The bytecode length in bytes must be divisible by 32"); }  BigInteger length = BigInteger.valueOf(bytecode.length / 32); if (length.compareTo(MAX_BYTECODE_SIZE) > 0) { throw new IllegalArgumentException("Bytecode length must be less than 2^16 bytes"); }  byte[] codeHashVersion = new byte[] { 1, 0 }; byte[] bytecodeLength = Numeric.toBytesPadded(length, 2);  System.arraycopy(codeHashVersion, 0, bytecodeHash, 0, codeHashVersion.length); System.arraycopy(bytecodeLength, 0, bytecodeHash, 2, bytecodeLength.length);  return bytecodeHash; }
[*] target: assertEquals(expected, resultHex)
[-] pred: org. junit. Assert. assertEquals ( expected, resultHex )
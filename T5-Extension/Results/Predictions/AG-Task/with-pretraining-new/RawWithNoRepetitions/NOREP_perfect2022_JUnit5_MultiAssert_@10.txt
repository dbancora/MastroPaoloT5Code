[+] input: testCheckWhenParameterNull() { CustomDataPermissionChecker customChecker = new CustomDataPermissionChecker(deptService);  boolean check1 = customChecker.check(null, null); boolean check2 = customChecker.check(loginUser, null); boolean check3 = customChecker.check(null, new DataCondition());  "<AssertPlaceHolder>"; assertFalse(check2); assertFalse(check3); }
check(SystemLoginUser loginUser, DataCondition condition) { if (condition == null || loginUser == null) { return false; }  if (loginUser.getRoleInfo() == null) { return false; }  Set<Long> deptIdSet = loginUser.getRoleInfo().getDeptIdSet(); Long targetDeptId = condition.getTargetDeptId();  return condition.getTargetDeptId() != null && CollUtil.safeContains(deptIdSet, targetDeptId); }
[*] target: assertFalse(check1)
[-] pred: org. junit. Assert. assertFalse ( check1 )
************************************
************************************
[+] input: testGetIpRegionWithIpv6() { IpRegion ipRegion = IpRegionUtil.getIpRegion("2001:0DB8:0000:0023:0008:0800:200C:417A");  Assertions."<AssertPlaceHolder>"; Assertions.assertNull(ipRegion.getCountry()); Assertions.assertEquals("未知 未知", ipRegion.briefLocation()); }
getIpRegion(String ip) { if (StrUtil.isEmpty(ip)) { return new IpRegion(); }  if (IpUtil.isInnerIp(ip)) { return new IpRegion("", "内网IP"); }  IpRegion ipRegionOffline = OfflineIpRegionUtil.getIpRegion(ip); if (ipRegionOffline != null) { return ipRegionOffline; }  IpRegion ipRegionOnline = OnlineIpRegionUtil.getIpRegion(ip); if (ipRegionOnline != null) { return ipRegionOnline; }  return new IpRegion(); }
[*] target: assertNotNull(ipRegion)
[-] pred: org. junit. Assert. assertNotNull ( ipRegion )
************************************
************************************
[+] input: testGetIpRegionWithEmpty() { IpRegion ipRegion = IpRegionUtil.getIpRegion("");  Assertions."<AssertPlaceHolder>"; Assertions.assertNull(ipRegion.getCountry()); Assertions.assertEquals("未知 未知", ipRegion.briefLocation()); }
getIpRegion(String ip) { if (StrUtil.isEmpty(ip)) { return new IpRegion(); }  if (IpUtil.isInnerIp(ip)) { return new IpRegion("", "内网IP"); }  IpRegion ipRegionOffline = OfflineIpRegionUtil.getIpRegion(ip); if (ipRegionOffline != null) { return ipRegionOffline; }  IpRegion ipRegionOnline = OnlineIpRegionUtil.getIpRegion(ip); if (ipRegionOnline != null) { return ipRegionOnline; }  return new IpRegion(); }
[*] target: assertNotNull(ipRegion)
[-] pred: org. junit. Assert. assertNotNull ( ipRegion )
************************************
************************************
[+] input: testGetIpRegionWithNull() { IpRegion ipRegion = IpRegionUtil.getIpRegion(null);  Assertions."<AssertPlaceHolder>"; Assertions.assertNull(ipRegion.getCountry()); Assertions.assertEquals("未知 未知", ipRegion.briefLocation()); }
getIpRegion(String ip) { if (StrUtil.isEmpty(ip)) { return new IpRegion(); }  if (IpUtil.isInnerIp(ip)) { return new IpRegion("", "内网IP"); }  IpRegion ipRegionOffline = OfflineIpRegionUtil.getIpRegion(ip); if (ipRegionOffline != null) { return ipRegionOffline; }  IpRegion ipRegionOnline = OnlineIpRegionUtil.getIpRegion(ip); if (ipRegionOnline != null) { return ipRegionOnline; }  return new IpRegion(); }
[*] target: assertNotNull(ipRegion)
[-] pred: org. junit. Assert. assertNotNull ( ipRegion )
************************************
************************************
[+] input: Exception { String someConfigServiceUrl = " someConfigServiceUrl "; String anotherConfigServiceUrl = " anotherConfigServiceUrl ";  System.setProperty(ApolloClientSystemConsts.APOLLO_CONFIG_SERVICE, someConfigServiceUrl + "," + anotherConfigServiceUrl);  ConfigServiceLocator configServiceLocator = new ConfigServiceLocator();  List<ServiceDTO> result = configServiceLocator.getConfigServices();  "<AssertPlaceHolder>";  assertEquals(someConfigServiceUrl.trim(), result.get(0).getHomepageUrl()); assertEquals(anotherConfigServiceUrl.trim(), result.get(1).getHomepageUrl()); }
getConfigServices() { if (m_configServices.get().isEmpty()) { trySubmitUpdateTask(); // quick fail throw new ApolloConfigException( "No available config service, " + "server side maybe crash or network cannot connect to server from this ip, " + "one of meta service url is " + assembleMetaServiceUrl() ); }  return m_configServices.get(); }
[*] target: assertEquals(2, result.size())
[-] pred: org. junit. Assert. assertEquals ( 2, result. size ( ) )
************************************
************************************
[+] input: Exception { String someConfigServiceUrl = " someConfigServiceUrl "; String anotherConfigServiceUrl = " anotherConfigServiceUrl ";  System.setProperty(ApolloClientSystemConsts.DEPRECATED_APOLLO_CONFIG_SERVICE, someConfigServiceUrl + "," + anotherConfigServiceUrl);  ConfigServiceLocator configServiceLocator = new ConfigServiceLocator();  List<ServiceDTO> result = configServiceLocator.getConfigServices();  "<AssertPlaceHolder>";  assertEquals(someConfigServiceUrl.trim(), result.get(0).getHomepageUrl()); assertEquals(anotherConfigServiceUrl.trim(), result.get(1).getHomepageUrl()); }
getConfigServices() { if (m_configServices.get().isEmpty()) { trySubmitUpdateTask(); // quick fail throw new ApolloConfigException( "No available config service, " + "server side maybe crash or network cannot connect to server from this ip, " + "one of meta service url is " + assembleMetaServiceUrl() ); }  return m_configServices.get(); }
[*] target: assertEquals(2, result.size())
[-] pred: org. junit. Assert. assertEquals ( 2, result. size ( ) )
************************************
************************************
[+] input: givenValidExchangeRequestWithInvalidUserJson_whenCreatingTokenExchangeParams_thenParamsAreParsedAndNormalized() { MultivaluedMap<String, String> params = new MultivaluedMapBuilder().subjectToken("myFancyAppleAuthorizationCode").userJson("  ").build(); TokenExchangeParams exchangeParams = new TokenExchangeParams(params);  assertEquals("myFancyAppleAuthorizationCode", exchangeParams.getSubjectToken()); assertEquals(AppleIdentityProvider.APPLE_AUTHZ_CODE, exchangeParams.getSubjectTokenType()); assertNull(exchangeParams.getUserJson()); "<AssertPlaceHolder>"; }
getAppIdentifier() { return this.appIdentifier; }
[*] target: assertNull(exchangeParams.getAppIdentifier())
[-] pred: org. junit. Assert. assertNull ( exchangeParams. getAppIdentifier() )
************************************
************************************
[+] input: givenValidExchangeRequestWithNullUserJson_whenCreatingTokenExchangeParams_thenParamsAreParsedAndNormalized() { MultivaluedMap<String, String> params = new MultivaluedMapBuilder().subjectToken("myFancyAppleAuthorizationCode").userJson(null).build(); TokenExchangeParams exchangeParams = new TokenExchangeParams(params);  assertEquals("myFancyAppleAuthorizationCode", exchangeParams.getSubjectToken()); assertEquals(AppleIdentityProvider.APPLE_AUTHZ_CODE, exchangeParams.getSubjectTokenType()); assertNull(exchangeParams.getUserJson()); "<AssertPlaceHolder>"; }
getAppIdentifier() { return this.appIdentifier; }
[*] target: assertNull(exchangeParams.getAppIdentifier())
[-] pred: org. junit. Assert. assertNull ( exchangeParams. getAppIdentifier() )
************************************
************************************
[+] input: givenValidParametersAndTypeParameters() { List<String> errorMessages = new ArrayList<>();  List<Parameter> parameters = asList( Parameter.of(COMPARATOR.with(T), "left"), Parameter.of(COMPARATOR.with(U), "right"), Parameter.of(FUNCTION.with(V.asType().contravariant(), I.asType().covariant()), "toIntermediate"), Parameter.of(FUNCTION.with(I.asType().contravariant(), T.asType().covariant()), "extractLeft"), Parameter.of(FUNCTION.with(I.asType().contravariant(), U.asType().covariant()), "extractRight") );  List<TypeParameter> typeParameters = asList(T.asTypeParameter(), U.asTypeParameter(), I.asTypeParameter(), V.asTypeParameter());  ContravariantParametersAndTypeParametersValidator.Result result = new ContravariantParametersAndTypeParametersValidator().validateTypeParametersAndParameters( typeParameters, parameters, errorMessages );  ParametersAndTypeParametersValidator.Result expectedResult = ParametersAndTypeParametersValidator.Result.of( T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter(), COMPARATOR.with(T), COMPARATOR.with(U) );  "<AssertPlaceHolder>"; assertTrue(errorMessages.isEmpty()); }
validateTypeParametersAndParameters(List<TypeParameter> typeParameters, List<Parameter> parameters, List<String> errorMessages) {  List<String> additionalErrorMessages = new ArrayList<>();  verifyParameterCount(parameters, 5, additionalErrorMessages); verifyTypeParameterCount(typeParameters, 4, additionalErrorMessages);  if (!additionalErrorMessages.isEmpty()) { errorMessages.addAll(additionalErrorMessages); return null; }  TypeParameter leftInputTypeConstructorArgument = typeParameters.get(0); TypeParameter rightInputTypeConstructorArgument = typeParameters.get(1); TypeParameter intermediateTypeConstructorArgument = typeParameters.get(2); TypeParameter returnTypeConstructorArgument = typeParameters.get(3);  Parameter leftParameter = parameters.get(0); Parameter rightParameter = parameters.get(1); Parameter toIntermediateParameter = parameters.get(2); Parameter extractLeftParameter = parameters.get(3); Parameter extractRightParameter = parameters.get(4);  // Check if the third parameter is as expected: Type expectedToIntermediateType = FUNCTION.with(returnTypeConstructorArgument.asType().contravariant(), intermediateTypeConstructorArgument.asType().covariant()); if (!Objects.equals(toIntermediateParameter.getType(), expectedToIntermediateType)) { additionalErrorMessages.add("Expected third argument to be a " + generateFrom(expectedToIntermediateType) + " but was " + generateFrom(toIntermediateParameter.getType())); }  // Check if the fourth parameter is as expected: Type expectedExtractLeftType = FUNCTION.with(intermediateTypeConstructorArgument.asType().contravariant(), leftInputTypeConstructorArgument.asType().covariant()); if (!Objects.equals(extractLeftParameter.getType(), expectedExtractLeftType)) { additionalErrorMessages.add("Expected fourth argument to be a " + generateFrom(expectedExtractLeftType) + " but was " + generateFrom(extractLeftParameter.getType())); }  // Check if the fourth parameter is as expected: Type expectedExtractRightType = FUNCTION.with(intermediateTypeConstructorArgument.asType().contravariant(), rightInputTypeConstructorArgument.asType().covariant()); if (!Objects.equals(extractRightParameter.getType(), expectedExtractRightType)) { additionalErrorMessages.add("Expected fifth argument to be a " + generateFrom(expectedExtractRightType) + " but was " + generateFrom(extractRightParameter.getType())); }  if (additionalErrorMessages.isEmpty()) { return Result.of( leftInputTypeConstructorArgument, rightInputTypeConstructorArgument, returnTypeConstructorArgument, leftParameter.getType(), rightParameter.getType() ); } else { errorMessages.addAll(additionalErrorMessages); return null; } }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: givenValidParametersAndTypeParameters() { List<String> errorMessages = new ArrayList<>();  List<Parameter> parameters = asList( Parameter.of(OPTIONAL.with(T), "left"), Parameter.of(OPTIONAL.with(U), "right"), Parameter.of(BI_FUNCTION.with(T.asType().contravariant(), U.asType().contravariant(), V.asType().covariant()), "compose") );  List<TypeParameter> typeParameters = asList(T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter());  ContravariantParametersAndTypeParametersValidator.Result result = new CovariantParametersAndTypeParametersValidator().validateTypeParametersAndParameters( typeParameters, parameters, errorMessages );  ParametersAndTypeParametersValidator.Result expectedResult = ParametersAndTypeParametersValidator.Result.of( T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter(), OPTIONAL.with(T), OPTIONAL.with(U) );  "<AssertPlaceHolder>"; assertTrue(errorMessages.isEmpty()); }
validateTypeParametersAndParameters(List<TypeParameter> typeParameters, List<Parameter> parameters, List<String> errorMessages) { List<String> additionalErrorMessages = new ArrayList<>();  verifyParameterCount(parameters, 3, additionalErrorMessages); verifyTypeParameterCount(typeParameters, 3, additionalErrorMessages);  if (!additionalErrorMessages.isEmpty()) { errorMessages.addAll(additionalErrorMessages); return null; }  TypeParameter leftInputTypeConstructorArgument = typeParameters.get(0); TypeParameter rightInputTypeConstructorArgument = typeParameters.get(1); TypeParameter returnTypeConstructorArgument = typeParameters.get(2);  Parameter leftParameter = parameters.get(0); Parameter rightParameter = parameters.get(1); Parameter combinatorParameter = parameters.get(2);  // Check if the third parameter is as expected: Type expectedCombinatorType = BI_FUNCTION.with(leftInputTypeConstructorArgument.asType().contravariant(), rightInputTypeConstructorArgument.asType().contravariant(), returnTypeConstructorArgument.asType().covariant()); if (!Objects.equals(combinatorParameter.getType(), expectedCombinatorType)) { additionalErrorMessages.add("Expected third argument to be a " + generateFrom(expectedCombinatorType) + " but was " + generateFrom(combinatorParameter.getType())); }  if (additionalErrorMessages.isEmpty()) { return Result.of( leftInputTypeConstructorArgument, rightInputTypeConstructorArgument, returnTypeConstructorArgument, leftParameter.getType(), rightParameter.getType() ); } else { errorMessages.addAll(additionalErrorMessages); return null; } }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: givenValidParametersAndTypeParameters() { List<String> errorMessages = new ArrayList<>();  List<Parameter> parameters = asList( Parameter.of(UNARY_OPERATOR.with(T), "left"), Parameter.of(UNARY_OPERATOR.with(U), "right"), Parameter.of(BI_FUNCTION.with(T.asType().contravariant(), U.asType().contravariant(), V.asType().covariant()), "combinator"), Parameter.of(FUNCTION.with(V.asType().contravariant(), I.asType().covariant()), "toIntermediate"), Parameter.of(FUNCTION.with(I.asType().contravariant(), T.asType().covariant()), "extractLeft"), Parameter.of(FUNCTION.with(I.asType().contravariant(), U.asType().covariant()), "extractRight") );  List<TypeParameter> typeParameters = asList(T.asTypeParameter(), U.asTypeParameter(), I.asTypeParameter(), V.asTypeParameter());  InvariantParametersAndTypeParametersValidator.Result result = new InvariantParametersAndTypeParametersValidator().validateTypeParametersAndParameters( typeParameters, parameters, errorMessages );  ParametersAndTypeParametersValidator.Result expectedResult = ParametersAndTypeParametersValidator.Result.of( T.asTypeParameter(), U.asTypeParameter(), V.asTypeParameter(), UNARY_OPERATOR.with(T), UNARY_OPERATOR.with(U) );  "<AssertPlaceHolder>"; assertTrue(errorMessages.isEmpty()); }
validateTypeParametersAndParameters(List<TypeParameter> typeParameters, List<Parameter> parameters, List<String> errorMessages) { List<String> additionalErrorMessages = new ArrayList<>();  verifyParameterCount(parameters, 6, additionalErrorMessages); verifyTypeParameterCount(typeParameters, 4, additionalErrorMessages);  if (!additionalErrorMessages.isEmpty()) { errorMessages.addAll(additionalErrorMessages); return null; }  TypeParameter leftInputTypeConstructorArgument = typeParameters.get(0); TypeParameter rightInputTypeConstructorArgument = typeParameters.get(1); TypeParameter intermediateTypeConstructorArgument = typeParameters.get(2); TypeParameter returnTypeConstructorArgument = typeParameters.get(3);  Parameter leftParameter = parameters.get(0); Parameter rightParameter = parameters.get(1); Parameter combinatorParameter = parameters.get(2); Parameter toIntermediateParameter = parameters.get(3); Parameter extractLeftParameter = parameters.get(4); Parameter extractRightParameter = parameters.get(5);  // Check if the third parameter is as expected: Type expectedCombinatorType = BI_FUNCTION.with(leftInputTypeConstructorArgument.asType().contravariant(), rightInputTypeConstructorArgument.asType().contravariant(), returnTypeConstructorArgument.asType().covariant()); if (!Objects.equals(combinatorParameter.getType(), expectedCombinatorType)) { additionalErrorMessages.add("Expected third argument to be a " + generateFrom(expectedCombinatorType) + " but was " + generateFrom(combinatorParameter.getType())); }  // Check if the fourth parameter is as expected: Type expectedToIntermediateType = FUNCTION.with(returnTypeConstructorArgument.asType().contravariant(), intermediateTypeConstructorArgument.asType().covariant()); if (!Objects.equals(toIntermediateParameter.getType(), expectedToIntermediateType)) { additionalErrorMessages.add("Expected fourth argument to be a " + generateFrom(expectedToIntermediateType) + " but was " + generateFrom(toIntermediateParameter.getType())); }  // Check if the fifth parameter is as expected: Type expectedExtractLeftType = FUNCTION.with(intermediateTypeConstructorArgument.asType().contravariant(), leftInputTypeConstructorArgument.asType().covariant()); if (!Objects.equals(extractLeftParameter.getType(), expectedExtractLeftType)) { additionalErrorMessages.add("Expected fifth argument to be a " + generateFrom(expectedExtractLeftType) + " but was " + generateFrom(extractLeftParameter.getType())); }  // Check if the sixth parameter is as expected: Type expectedExtractRightType = FUNCTION.with(intermediateTypeConstructorArgument.asType().contravariant(), rightInputTypeConstructorArgument.asType().covariant()); if (!Objects.equals(extractRightParameter.getType(), expectedExtractRightType)) { additionalErrorMessages.add("Expected sixth argument to be a " + generateFrom(expectedExtractRightType) + " but was " + generateFrom(extractRightParameter.getType())); }  if (additionalErrorMessages.isEmpty()) { return Result.of( leftInputTypeConstructorArgument, rightInputTypeConstructorArgument, returnTypeConstructorArgument, leftParameter.getType(), rightParameter.getType() ); } else { errorMessages.addAll(additionalErrorMessages); return null; } }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: extractInnerJar() { List<File> fileList = JarUtils.extractNestedBootStrapJar(jarFile); "<AssertPlaceHolder>"; assertTrue(fileList.get(0).getName().endsWith("bootstrap-test.jar")); }
extractNestedBootStrapJar(File file) { try (JarFile jarFile = new JarFile(file)) { String nestedBootStrapJarsPath = jarFile.getManifest().getMainAttributes().getValue(NESTED_BOOTSTRAP_JARS_PATH); if (nestedBootStrapJarsPath == null || nestedBootStrapJarsPath.isEmpty()) { return Collections.emptyList(); } String[] jarPaths = nestedBootStrapJarsPath.split(DELIMITER); List<File> jarFiles = new ArrayList<>(jarPaths.length); for (String jarPath : jarPaths) { JarEntry jarEntry = jarFile.getJarEntry(jarPath); if (jarEntry.getName().endsWith(JAR_SUFFIX)) { jarFiles.add(extractNestedBootStrapJar(jarFile, jarEntry, jarEntry.getName())); } } return jarFiles; } catch (IOException e) { System.err.printf("extract nested bootstrap jar failed, file: %s%n", file.getAbsolutePath()); return Collections.emptyList(); } }
[*] target: assertEquals(1, fileList.size())
[-] pred: org. junit. Assert. assertEquals ( 1, fileList. size ( ) )
************************************
************************************
[+] input: IOException { JarFile tempJarFile = new JarFile(CreateFileCommon.getJarInJarFile()); JarEntry jarEntry = tempJarFile.getJarEntry("internal-test.jar"); File extractNestedJar = JarUtils.extractNestedJar(tempJarFile, jarEntry, jarEntry.getName()); "<AssertPlaceHolder>"; assertTrue(extractNestedJar.getName().endsWith("internal-test.jar")); }
extractNestedJar(JarFile file, JarEntry entry, String entryName) throws IOException { File outputFile = createFile(AREX_TEMP_DIR + File.separator + entryName); try(InputStream inputStream = file.getInputStream(entry); FileOutputStream outputStream = new FileOutputStream(outputFile)) { byte[] buffer = new byte[1024]; int length; while ((length = inputStream.read(buffer)) > 0) { outputStream.write(buffer, 0, length); } } return outputFile; }
[*] target: assertNotNull(extractNestedJar)
[-] pred: org. junit. Assert. assertNotNull ( extractNestedJar )
************************************
************************************
[+] input: NoSuchMethodException { Method test1 = TestArexMock.class.getDeclaredMethod("testWithCacheableAnnotation", String.class, int.class); try(MockedConstruction ignored = Mockito.mockConstruction(DynamicClassExtractor.class, ((extractor, context) -> { Mockito.when(extractor.replayOrRealCall()).thenReturn(MockResult.success("test")); }))) { Method testReturnVoid = TestArexMock.class.getDeclaredMethod("testReturnVoid"); boolean actualResult = SpringCacheInstrumentation.SpringCacheAdvice.onEnter(testReturnVoid, null, null, null); assertFalse(actualResult);  // not record Mockito.when(CacheLoaderUtil.needRecordOrReplay(any())).thenReturn(false); actualResult = SpringCacheInstrumentation.SpringCacheAdvice.onEnter(test1, new Object[]{ "name", 18 }, null, null); assertFalse(actualResult);  // record Mockito.when(CacheLoaderUtil.needRecordOrReplay(any())).thenReturn(true); Mockito.when(ContextManager.needRecord()).thenReturn(true); DynamicClassExtractor extractor = new DynamicClassExtractor(test1, new Object[]{"mock"}, "#val", null); actualResult = SpringCacheInstrumentation.SpringCacheAdvice.onEnter(test1, new Object[]{ "name", 18 }, extractor, null); assertFalse(actualResult);  // replay Mockito.when(ContextManager.needRecord()).thenReturn(false); Mockito.when(ContextManager.needReplay()).thenReturn(true); actualResult = SpringCacheInstrumentation.SpringCacheAdvice.onEnter(test1, new Object[]{ "name", 18 }, extractor, null); "<AssertPlaceHolder>"; } }
onEnter(@Advice.Argument(2) Method method, @Advice.Argument(3) Object[] args, @Advice.Local("extractor") DynamicClassExtractor extractor, @Advice.Local("mockResult") MockResult mockResult) { // only record and replay non-void method if (Void.TYPE.equals(method.getReturnType())) { return false; }  if (ContextManager.needRecordOrReplay() && CacheLoaderUtil.needRecordOrReplay(method)) { Cacheable cacheable = method.getDeclaredAnnotation(Cacheable.class); String keyExpression = cacheable != null ? cacheable.key() : null; extractor = new DynamicClassExtractor(method, args, keyExpression, null); } if (extractor != null && ContextManager.needReplay()) { mockResult = extractor.replayOrRealCall(); return mockResult != null && mockResult.notIgnoreMockResult(); } if (ContextManager.needRecord()) { RepeatedCollectManager.enter(); } return false; }
[*] target: assertTrue(actualResult)
[-] pred: org. junit. Assert. assertTrue ( actualResult )
************************************
************************************
[+] input: Throwable { IgnoreUtils.clearInvalidOperation(); Method testWithArexMock = DynamicClassExtractorTest.class.getDeclaredMethod("testWithArexMock", String.class); DynamicClassExtractor extractor = new DynamicClassExtractor(testWithArexMock, null, "#val", String.class);  // args is empty String actualResult = extractor.buildMethodKey(testWithArexMock, new Object[0]); assertNull(actualResult);  // getDynamicClassSignatureMap is empty ConfigBuilder.create("mock-service").enableDebug(true).build(); Mockito.when(Serializer.serializeWithException(any(), anyString())).thenReturn("mock Serializer.serialize"); actualResult = extractor.buildMethodKey(testWithArexMock, new Object[]{"mock"}); assertEquals("mock Serializer.serialize", actualResult);  // getDynamicClassSignatureMap is not empty, additionalSignature is empty List<DynamicClassEntity> list = new ArrayList<>(); list.add(new DynamicClassEntity("io.arex.inst.dynamic.common.DynamicClassExtractorTest", "testWithArexMock", "mock", "")); ConfigBuilder.create("mock-service").enableDebug(true).dynamicClassList(list).build(); actualResult = extractor.buildMethodKey(testWithArexMock, new Object[]{"mock"}); assertEquals("mock Serializer.serialize", actualResult);  // additionalSignature is not empty list.clear(); list.add(new DynamicClassEntity("io.arex.inst.dynamic.common.DynamicClassExtractorTest", "testWithArexMock", "", "$1")); ConfigBuilder.create("mock-service").enableDebug(true).dynamicClassList(list).build(); actualResult = extractor.buildMethodKey(testWithArexMock, new Object[]{"mock-method-key"}); assertEquals("mock-method-key", actualResult);  // additionalSignature is not empty extractor = new DynamicClassExtractor(testWithArexMock, new Object[]{"mock"}, "#val", String.class); list.clear(); list.add(new DynamicClassEntity("io.arex.inst.dynamic.common.DynamicClassExtractorTest", "testWithArexMock", "mock", "$1")); ConfigBuilder.create("mock-service").enableDebug(true).dynamicClassList(list).build(); actualResult = extractor.buildMethodKey(testWithArexMock, new Object[]{"mock-method-key"}); assertEquals("mock-method-key", actualResult);  // express is null Method testWithArexMockList = DynamicClassExtractorTest.class.getDeclaredMethod("testWithArexMock", List.class); extractor = new DynamicClassExtractor(testWithArexMockList, new Object[]{new ArrayList<>()}, null, String.class); list.clear(); list.add(new DynamicClassEntity("io.arex.inst.dynamic.common.DynamicClassExtractorTest", "testWithArexMock", "mock", "$1.get(0)")); ConfigBuilder.create("mock-service").enableDebug(true).dynamicClassList(list).build(); actualResult = extractor.buildMethodKey(testWithArexMockList, new Object[]{new ArrayList<>()}); "<AssertPlaceHolder>"; }
buildMethodKey(Method method, Object[] args) { if (ArrayUtils.isEmpty(args)) { return null; }  if (Config.get() == null || Config.get().getDynamicClassSignatureMap().isEmpty()) { return serialize(args, ArexConstants.GSON_REQUEST_SERIALIZER); }  DynamicClassEntity dynamicEntity = Config.get().getDynamicEntity(dynamicSignature); if (dynamicEntity == null || StringUtil.isEmpty(dynamicEntity.getAdditionalSignature())) { return serialize(args, ArexConstants.GSON_REQUEST_SERIALIZER); }  String keyExpression = ExpressionParseUtil.replaceToExpression(method, dynamicEntity.getAdditionalSignature());  return buildMethodKey(method, args, keyExpression); }
[*] target: assertNull(actualResult)
[-] pred: org. junit. Assert. assertNull ( actualResult )
************************************
************************************
[+] input: methodAdvicesTest() { List<?> actResult = okHttpCallInstrumentation.methodAdvices(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(2, actResult.size()); }
methodAdvices() { MethodInstrumentation executeMethod = new MethodInstrumentation( named("execute").and(takesNoArguments()), ExecuteAdvice.class.getName()); MethodInstrumentation enqueueMethod = new MethodInstrumentation( named("enqueue").and(takesArguments(1)), EnqueueAdvice.class.getName()); return asList(executeMethod, enqueueMethod);  }
[*] target: assertNotNull(actResult)
[-] pred: org. junit. Assert. assertNotNull ( actResult )
************************************
************************************
[+] input: asHttpServletRequest() { assertNotNull(instance.asHttpServletRequest(mockRequest)); "<AssertPlaceHolder>"; }
asHttpServletRequest(Object servletRequest) { if (servletRequest instanceof HttpServletRequest) { HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; try { if (httpServletRequest.getCharacterEncoding() == null) { httpServletRequest.setCharacterEncoding(StandardCharsets.UTF_8.name()); } } catch (Exception e) { // ignore } return httpServletRequest; } return null; }
[*] target: assertNull(instance.asHttpServletRequest(null))
[-] pred: org. junit. Assert. assertNull ( instance. asHttpServletRequest ( null ) )
************************************
************************************
[+] input: isSupported() { ComparableVersion current = ComparableVersion.of("0.9"); assertTrue(MODULE_DESCRIPTION_JUST_FORM.isSupported(current)); assertTrue(MODULE_DESCRIPTION_FROM_TO.isSupported(current));  current = ComparableVersion.of("1.11"); assertTrue(MODULE_DESCRIPTION_JUST_FORM.isSupported(current)); assertTrue(MODULE_DESCRIPTION_FROM_TO.isSupported(current));  current = ComparableVersion.of("1.12"); assertTrue(MODULE_DESCRIPTION_JUST_FORM.isSupported(current)); assertFalse(MODULE_DESCRIPTION_FROM_TO.isSupported(current));  current = ComparableVersion.of("0.8"); assertFalse(MODULE_DESCRIPTION_JUST_FORM.isSupported(current)); assertFalse(MODULE_DESCRIPTION_FROM_TO.isSupported(current));  current = ComparableVersion.of("1.5.1.2"); assertTrue(MODULE_DESCRIPTION_JUST_FORM.isSupported(current)); assertTrue(MODULE_DESCRIPTION_FROM_TO.isSupported(current));  current = ComparableVersion.of("0.1"); final ModuleDescription emptyVersion = ModuleDescription.builder() .name("emptyVersion").supportFrom(ComparableVersion.of("")).build(); "<AssertPlaceHolder>"; }
isSupported(ComparableVersion current) { boolean isSupported = current.compareTo(from) >= 0; if (isSupported && to != null) { isSupported = current.compareTo(to) <= 0; } return isSupported; }
[*] target: assertTrue(emptyVersion.isSupported(current))
[-] pred: org. junit. Assert. assertTrue ( emptyVersion. isSupported ( current ) )
************************************
************************************
[+] input: SQLException { when(mockHostSpec.getUrl()).thenReturn("url"); final Set<String> expectedUrls = new HashSet<>(Collections.singletonList("url")); final Set<PoolKey> expectedKeys = new HashSet<>( Collections.singletonList(new PoolKey("url", user1)));  provider = spy(new HikariPooledConnectionProvider((hostSpec, properties) -> mockConfig));  doReturn(mockDataSource).when(provider).createHikariDataSource(any(), any(), any(), any()); doReturn(new ConnectInfo("url", new Properties())) .when(mockTargetDriverDialect).prepareConnectInfo(anyString(), any(), any());  Properties props = new Properties(); props.setProperty(PropertyDefinition.USER.name, user1); props.setProperty(PropertyDefinition.PASSWORD.name, password); try (Connection conn = provider.connect(protocol, mockDialect, mockTargetDriverDialect, mockHostSpec, props)) { assertEquals(mockConnection, conn); assertEquals(1, provider.getHostCount()); final Set<String> hosts = provider.getHosts(); assertEquals(expectedUrls, hosts); final Set<PoolKey> keys = provider.getKeys(); "<AssertPlaceHolder>"; } }
getKeys() { return databasePools.getEntries().keySet(); }
[*] target: assertEquals(expectedKeys, keys)
[-] pred: org. junit. Assert. assertEquals ( expectedKeys, keys )
************************************
************************************
[+] input: SQLException { when(mockHostSpec.getUrl()).thenReturn("url"); final Set<PoolKey> expectedKeys = new HashSet<>( Collections.singletonList(new PoolKey("url", "url+someUniqueKey")));  provider = spy(new HikariPooledConnectionProvider( (hostSpec, properties) -> mockConfig, (hostSpec, properties) -> hostSpec.getUrl() + "+someUniqueKey"));  doReturn(mockDataSource).when(provider).createHikariDataSource(any(), any(), any(), any());  Properties props = new Properties(); props.setProperty(PropertyDefinition.USER.name, user1); props.setProperty(PropertyDefinition.PASSWORD.name, password); try (Connection conn = provider.connect(protocol, mockDialect, mockTargetDriverDialect, mockHostSpec, props)) { assertEquals(mockConnection, conn); assertEquals(1, provider.getHostCount()); final Set<PoolKey> keys = provider.getKeys(); "<AssertPlaceHolder>"; } }
getKeys() { return databasePools.getEntries().keySet(); }
[*] target: assertEquals(expectedKeys, keys)
[-] pred: org. junit. Assert. assertEquals ( expectedKeys, keys )
************************************
************************************
[+] input: SQLException { final List<HostSpec> expectedMySQL = Collections.singletonList( new HostSpecBuilder(new SimpleHostAvailabilityStrategy()).host("mysql").port(HostSpec.NO_PORT) .role(HostRole.WRITER).availability(HostAvailability.AVAILABLE).weight(0).build()); final List<HostSpec> expectedPostgres = Collections.singletonList( new HostSpecBuilder(new SimpleHostAvailabilityStrategy()).host("postgresql").port(HostSpec.NO_PORT) .role(HostRole.WRITER).availability(HostAvailability.AVAILABLE).weight(0).build()); when(mockResultSet.next()).thenReturn(true, false); when(mockResultSet.getBoolean(eq(2))).thenReturn(true); when(mockResultSet.getString(eq(1))).thenReturn("mysql");   rdsHostListProvider = getRdsHostListProvider(mockHostListProviderService, "mysql://url/");  List<HostSpec> hosts = rdsHostListProvider.queryForTopology(mockConnection); assertEquals(expectedMySQL, hosts);  when(mockResultSet.next()).thenReturn(true, false); when(mockResultSet.getString(eq(1))).thenReturn("postgresql");  rdsHostListProvider = getRdsHostListProvider(mockHostListProviderService, "postgresql://url/"); hosts = rdsHostListProvider.queryForTopology(mockConnection); "<AssertPlaceHolder>"; }
queryForTopology(final Connection conn) throws SQLException { int networkTimeout = -1; try { networkTimeout = conn.getNetworkTimeout(); // The topology query is not monitored by the EFM plugin, so it needs a socket timeout if (networkTimeout == 0) { conn.setNetworkTimeout(networkTimeoutExecutor, defaultTopologyQueryTimeoutMs); } } catch (SQLException e) { LOGGER.warning(() -> Messages.get("RdsHostListProvider.errorGettingNetworkTimeout", new Object[] {e.getMessage()})); }  try (final Statement stmt = conn.createStatement(); final ResultSet resultSet = stmt.executeQuery(this.topologyQuery)) { return processQueryResults(resultSet); } catch (final SQLSyntaxErrorException e) { throw new SQLException(Messages.get("RdsHostListProvider.invalidQuery"), e); } finally { if (networkTimeout == 0 && !conn.isClosed()) { conn.setNetworkTimeout(networkTimeoutExecutor, networkTimeout); } } }
[*] target: assertEquals(expectedPostgres, hosts)
[-] pred: org. junit. Assert. assertEquals ( expectedPostgres, hosts )
************************************
************************************
[+] input: SQLException { rdsHostListProvider = getRdsHostListProvider(mockHostListProviderService, "jdbc:someprotocol://url"); // Test getCachedTopology with empty topology. assertNull(rdsHostListProvider.getCachedTopology()); rdsHostListProvider.clear();  rdsHostListProvider = getRdsHostListProvider(mockHostListProviderService, "jdbc:someprotocol://url"); final long refreshRateOneNanosecond = 1; RdsHostListProvider.topologyCache.put(rdsHostListProvider.clusterId, hosts, refreshRateOneNanosecond); TimeUnit.NANOSECONDS.sleep(1);  // Test getCachedTopology with expired cache. "<AssertPlaceHolder>"; }
getCachedTopology() { return topologyCache.get(this.clusterId); }
[*] target: assertNull(rdsHostListProvider.getCachedTopology())
[-] pred: org. junit. Assert. assertNull ( rdsHostListProvider. getCachedTopology ( ) )
************************************
************************************
[+] input: SQLException { RdsHostListProvider.clearAll();  RdsHostListProvider provider1 = Mockito.spy( getRdsHostListProvider(mockHostListProviderService, "jdbc:something://cluster-a.cluster-xyz.us-east-2.rds.amazonaws.com/")); provider1.init(); final List<HostSpec> topologyClusterA = Arrays.asList( new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-a-1.xyz.us-east-2.rds.amazonaws.com") .port(HostSpec.NO_PORT) .role(HostRole.WRITER) .build(), new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-a-2.xyz.us-east-2.rds.amazonaws.com") .port(HostSpec.NO_PORT) .role(HostRole.READER) .build(), new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-a-3.xyz.us-east-2.rds.amazonaws.com") .port(HostSpec.NO_PORT) .role(HostRole.READER) .build());  doReturn(topologyClusterA).when(provider1).queryForTopology(any(Connection.class));  assertEquals(0, RdsHostListProvider.topologyCache.size());  final List<HostSpec> topologyProvider1 = provider1.refresh(Mockito.mock(Connection.class)); assertEquals(topologyClusterA, topologyProvider1);  RdsHostListProvider provider2 = Mockito.spy( getRdsHostListProvider(mockHostListProviderService, "jdbc:something://cluster-a.cluster-xyz.us-east-2.rds.amazonaws.com/")); provider2.init();  assertEquals(provider1.clusterId, provider2.clusterId); assertTrue(provider1.isPrimaryClusterId); assertTrue(provider2.isPrimaryClusterId);  final List<HostSpec> topologyProvider2 = provider2.refresh(Mockito.mock(Connection.class)); "<AssertPlaceHolder>";  assertEquals(1, RdsHostListProvider.topologyCache.size()); }
refresh(final Connection connection) throws SQLException { init(); final Connection currentConnection = connection != null ? connection : this.hostListProviderService.getCurrentConnection();  final FetchTopologyResult results = getTopology(currentConnection, false); LOGGER.finest(() -> Utils.logTopology(results.hosts, results.isCachedData ? "[From cache] " : ""));  this.hostList = results.hosts; return Collections.unmodifiableList(hostList); }
[*] target: assertEquals(topologyClusterA, topologyProvider2)
[-] pred: org. junit. Assert. assertEquals ( topologyClusterA, topologyProvider2 )
************************************
************************************
[+] input: SQLException { RdsHostListProvider.clearAll();  RdsHostListProvider provider1 = Mockito.spy( getRdsHostListProvider(mockHostListProviderService, "jdbc:something://cluster-a.cluster-xyz.us-east-2.rds.amazonaws.com/")); provider1.init(); final List<HostSpec> topologyClusterA = Arrays.asList( new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-a-1.xyz.us-east-2.rds.amazonaws.com") .port(HostSpec.NO_PORT) .role(HostRole.WRITER) .build(), new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-a-2.xyz.us-east-2.rds.amazonaws.com") .port(HostSpec.NO_PORT) .role(HostRole.READER) .build(), new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-a-3.xyz.us-east-2.rds.amazonaws.com") .port(HostSpec.NO_PORT) .role(HostRole.READER) .build());  doReturn(topologyClusterA).when(provider1).queryForTopology(any(Connection.class));  assertEquals(0, RdsHostListProvider.topologyCache.size());  final List<HostSpec> topologyProvider1 = provider1.refresh(Mockito.mock(Connection.class)); assertEquals(topologyClusterA, topologyProvider1);  RdsHostListProvider provider2 = Mockito.spy( getRdsHostListProvider(mockHostListProviderService, "jdbc:something://instance-a-3.xyz.us-east-2.rds.amazonaws.com/")); provider2.init();  assertEquals(provider1.clusterId, provider2.clusterId); assertTrue(provider1.isPrimaryClusterId); assertTrue(provider2.isPrimaryClusterId);  final List<HostSpec> topologyProvider2 = provider2.refresh(Mockito.mock(Connection.class)); "<AssertPlaceHolder>";  assertEquals(1, RdsHostListProvider.topologyCache.size()); }
refresh(final Connection connection) throws SQLException { init(); final Connection currentConnection = connection != null ? connection : this.hostListProviderService.getCurrentConnection();  final FetchTopologyResult results = getTopology(currentConnection, false); LOGGER.finest(() -> Utils.logTopology(results.hosts, results.isCachedData ? "[From cache] " : ""));  this.hostList = results.hosts; return Collections.unmodifiableList(hostList); }
[*] target: assertEquals(topologyClusterA, topologyProvider2)
[-] pred: org. junit. Assert. assertEquals ( topologyClusterA, topologyProvider2 )
************************************
************************************
[+] input: SQLException { RdsMultiAzDbClusterListProvider.clearAll();  RdsMultiAzDbClusterListProvider provider1 = Mockito.spy( getRdsMazDbClusterHostListProvider(mockHostListProviderService, "jdbc:something://instance-a-2.xyz.us-east-2.rds.amazonaws.com/")); provider1.init(); final List<HostSpec> topologyClusterA = Arrays.asList( new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-a-1.xyz.us-east-2.rds.amazonaws.com") .port(HostSpec.NO_PORT) .role(HostRole.WRITER) .build(), new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-a-2.xyz.us-east-2.rds.amazonaws.com") .port(HostSpec.NO_PORT) .role(HostRole.READER) .build(), new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("instance-a-3.xyz.us-east-2.rds.amazonaws.com") .port(HostSpec.NO_PORT) .role(HostRole.READER) .build());  doAnswer(a -> topologyClusterA).when(provider1).queryForTopology(any(Connection.class));  assertEquals(0, RdsMultiAzDbClusterListProvider.topologyCache.size());  List<HostSpec> topologyProvider1 = provider1.refresh(Mockito.mock(Connection.class)); assertEquals(topologyClusterA, topologyProvider1);  // RdsMultiAzDbClusterListProvider.logCache();  RdsMultiAzDbClusterListProvider provider2 = Mockito.spy( getRdsMazDbClusterHostListProvider(mockHostListProviderService, "jdbc:something://cluster-a.cluster-xyz.us-east-2.rds.amazonaws.com/")); provider2.init();  doAnswer(a -> topologyClusterA).when(provider2).queryForTopology(any(Connection.class));  final List<HostSpec> topologyProvider2 = provider2.refresh(Mockito.mock(Connection.class)); "<AssertPlaceHolder>";  assertNotEquals(provider1.clusterId, provider2.clusterId); assertFalse(provider1.isPrimaryClusterId); assertTrue(provider2.isPrimaryClusterId); assertEquals(2, RdsMultiAzDbClusterListProvider.topologyCache.size()); assertEquals("cluster-a.cluster-xyz.us-east-2.rds.amazonaws.com", RdsMultiAzDbClusterListProvider.suggestedPrimaryClusterIdCache.get(provider1.clusterId));  // RdsMultiAzDbClusterListProvider.logCache();  topologyProvider1 = provider1.forceRefresh(Mockito.mock(Connection.class)); assertEquals(topologyClusterA, topologyProvider1); assertEquals(provider1.clusterId, provider2.clusterId); assertTrue(provider1.isPrimaryClusterId); assertTrue(provider2.isPrimaryClusterId);  // RdsMultiAzDbClusterListProvider.logCache(); }
queryForTopology(final Connection conn) throws SQLException { int networkTimeout = -1; try { networkTimeout = conn.getNetworkTimeout(); // The topology query is not monitored by the EFM plugin, so it needs a socket timeout if (networkTimeout == 0) { conn.setNetworkTimeout(networkTimeoutExecutor, defaultTopologyQueryTimeoutMs); } } catch (SQLException e) { LOGGER.warning(() -> Messages.get("RdsHostListProvider.errorGettingNetworkTimeout", new Object[] {e.getMessage()})); }  try { final Statement stmt = conn.createStatement(); String writerNodeId = processWriterNodeId(stmt.executeQuery(this.fetchWriterNodeQuery)); if (writerNodeId == null) { final ResultSet nodeIdResultSet = stmt.executeQuery(this.nodeIdQuery); while (nodeIdResultSet.next()) { writerNodeId = nodeIdResultSet.getString(1); } } final ResultSet topologyResultSet = stmt.executeQuery(this.topologyQuery); return processTopologyQueryResults(topologyResultSet, writerNodeId); } catch (final SQLSyntaxErrorException e) { throw new SQLException(Messages.get("RdsHostListProvider.invalidQuery"), e); } finally { if (networkTimeout == 0 && !conn.isClosed()) { conn.setNetworkTimeout(networkTimeoutExecutor, networkTimeout); } } }
[*] target: assertEquals(topologyClusterA, topologyProvider2)
[-] pred: org. junit. Assert. assertEquals ( topologyClusterA, topologyProvider2 )
************************************
************************************
[+] input: test_getMonitorCalledWithDifferentNodeKeys() { final Set<String> nodeKeys = new HashSet<>(); nodeKeys.add("nodeNEW.domain");  final Monitor monitorOne = monitorService.getMonitor(nodeKeys, hostSpec, properties); assertNotNull(monitorOne);  // Ensuring monitor is the same one and not creating a new one final Monitor monitorOneDupe = monitorService.getMonitor(nodeKeys, hostSpec, properties); assertEquals(monitorOne, monitorOneDupe);  // Ensuring monitors are not the same as they have different keys // "any.node.domain" compared to "nodeNEW.domain" final Monitor monitorTwo = monitorService.getMonitor(NODE_KEYS, hostSpec, properties); "<AssertPlaceHolder>"; assertNotEquals(monitorOne, monitorTwo); }
getMonitor(final Set<String> nodeKeys, final HostSpec hostSpec, final Properties properties) { return this.threadContainer.getOrCreateMonitor( nodeKeys, () -> monitorInitializer.createMonitor(hostSpec, properties, this.threadContainer)); }
[*] target: assertNotNull(monitorTwo)
[-] pred: org. junit. Assert. assertNotNull ( monitorTwo )
************************************
************************************
[+] input: testHostFailoverStrictReaderEnabled() {  final HostSpec writer = new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("writer").port(1234).role(HostRole.WRITER).build(); final HostSpec reader = new HostSpecBuilder(new SimpleHostAvailabilityStrategy()) .host("reader1").port(1234).role(HostRole.READER).build(); final List<HostSpec> hosts = Arrays.asList(writer, reader);  Dialect mockDialect = Mockito.mock(Dialect.class); when(mockDialect.getFailoverRestrictions()).thenReturn(EnumSet.noneOf(FailoverRestriction.class)); when(mockPluginService.getDialect()).thenReturn(mockDialect); final ClusterAwareReaderFailoverHandler target = new ClusterAwareReaderFailoverHandler( mockPluginService, properties, DEFAULT_FAILOVER_TIMEOUT, DEFAULT_READER_CONNECT_TIMEOUT, true);  // We expect only reader nodes to be chosen. List<HostSpec> expectedReaderHost = Collections.singletonList(reader);  List<HostSpec> hostsByPriority = target.getHostsByPriority(hosts); assertEquals(expectedReaderHost, hostsByPriority);  // Should pick the reader even if unavailable. reader.setAvailability(HostAvailability.NOT_AVAILABLE);  hostsByPriority = target.getHostsByPriority(hosts); assertEquals(expectedReaderHost, hostsByPriority);  // Writer node will only be picked if it is the only node in topology; List<HostSpec> expectedWriterHost = Collections.singletonList(writer);  hostsByPriority = target.getHostsByPriority(Collections.singletonList(writer)); "<AssertPlaceHolder>"; }
getHostsByPriority(final List<HostSpec> hosts) { final List<HostSpec> activeReaders = new ArrayList<>(); final List<HostSpec> downHostList = new ArrayList<>(); HostSpec writerHost = null;  for (final HostSpec host : hosts) { if (host.getRole() == HostRole.WRITER) { writerHost = host; continue; } if (host.getRawAvailability() == HostAvailability.AVAILABLE) { activeReaders.add(host); } else { downHostList.add(host); } } Collections.shuffle(activeReaders); Collections.shuffle(downHostList);  final List<HostSpec> hostsByPriority = new ArrayList<>(activeReaders); final int numOfReaders = activeReaders.size() + downHostList.size(); if (writerHost != null && (!this.enableFailoverStrictReader || numOfReaders == 0)) { hostsByPriority.add(writerHost); } hostsByPriority.addAll(downHostList);  return hostsByPriority; }
[*] target: assertEquals(expectedWriterHost, hostsByPriority)
[-] pred: org. junit. Assert. assertEquals ( expectedWriterHost, hostsByPriority )
************************************
************************************
[+] input: SQLException { when(mockHttpClient.execute(any(HttpUriRequest.class))).thenReturn( mockHttpGetSignInPageResponse, mockHttpPostSignInResponse); final String correctSamlAssertion = IOUtils.toString( Objects.requireNonNull( this.getClass().getClassLoader().getResourceAsStream("federated_auth/saml-assertion.txt")), "UTF-8") .replace("\n", "") .replace("\r", ""); final String samlAssertion = this.adfsCredentialsProviderFactory.getSamlAssertion(props); "<AssertPlaceHolder>";  final ArgumentCaptor<HttpUriRequest> httpPostArgumentCaptor = ArgumentCaptor.forClass(HttpUriRequest.class); verify(mockHttpClient, times(2)).execute(httpPostArgumentCaptor.capture()); final HttpEntityEnclosingRequest actualHttpPost = (HttpEntityEnclosingRequest) httpPostArgumentCaptor.getValue(); final String content = EntityUtils.toString(actualHttpPost.getEntity()); final String[] params = content.split("&"); assertEquals("UserName=" + USERNAME.replace("@", "%40"), params[0]); assertEquals("Password=" + PASSWORD, params[1]); assertEquals("Kmsi=true", params[2]); assertEquals("AuthMethod=FormsAuthentication", params[3]); }
getSamlAssertion(final @NonNull Properties props) throws SQLException { this.telemetryContext = telemetryFactory.openTelemetryContext(TELEMETRY_FETCH_SAML, TelemetryTraceLevel.NESTED);  try (final CloseableHttpClient httpClient = httpClientSupplier.get()) { String uri = getSignInPageUrl(props); final String signInPageBody = getSignInPageBody(httpClient, uri); final String action = getFormActionFromHtmlBody(signInPageBody);  if (!StringUtils.isNullOrEmpty(action) && action.startsWith("/")) { uri = getFormActionUrl(props, action); }  final List<NameValuePair> params = getParametersFromHtmlBody(signInPageBody, props); final String content = getFormActionBody(httpClient, uri, params);  final Matcher matcher = FederatedAuthPlugin.SAML_RESPONSE_PATTERN.matcher(content); if (!matcher.find()) { throw new IOException(Messages.get("AdfsCredentialsProviderFactory.failedLogin", new Object[] {content})); }  // return SAML Response value return matcher.group(FederatedAuthPlugin.SAML_RESPONSE_PATTERN_GROUP); } catch (final IOException e) { LOGGER.severe(Messages.get("SAMLCredentialsProviderFactory.getSamlAssertionFailed", new Object[] {e})); this.telemetryContext.setSuccess(false); this.telemetryContext.setException(e); throw new SQLException(e); } finally { this.telemetryContext.closeContext(); } }
[*] target: assertEquals(correctSamlAssertion, samlAssertion)
[-] pred: org. junit. Assert. assertEquals ( correctSamlAssertion, samlAssertion )
************************************
************************************
[+] input: URISyntaxException { final String sessionTokenResponse = getResource("okta/session.txt"); final String samlAssertionResponse = getResource("okta/saml-assertion.html"); final String expectedSessionToken = getResource("okta/expected-session-token.txt"); final String expectedAssertion = getResource("okta/assertion.txt"); final URI expectedUri = new URI( "https://example.okta.com/app/amazon_aws/example.okta.com/sso/saml?onetimetoken=" + expectedSessionToken); final HttpEntity sessionTokenEntity = new StringEntity(sessionTokenResponse); final HttpEntity samlAssertionEntity = new StringEntity(samlAssertionResponse); final String expectedSessionTokenEndpoint = "https://" + ENDPOINT + "/api/v1/authn"; final String expectedSessionTokenRequestEntity = "{"username":"" + USERNAME + "","password":"" + PASSWORD + ""}";  when(mockResponse.getEntity()).thenReturn(sessionTokenEntity, samlAssertionEntity);  final String samlAssertion = this.oktaCredentialsProviderFactory.getSamlAssertion(props); "<AssertPlaceHolder>";  final ArgumentCaptor<HttpUriRequest> httpPostArgumentCaptor = ArgumentCaptor.forClass(HttpUriRequest.class); verify(mockHttpClient, times(2)).execute(httpPostArgumentCaptor.capture()); final List<HttpUriRequest> actualCaptures = httpPostArgumentCaptor.getAllValues(); final HttpEntityEnclosingRequest sessionTokenRequest = (HttpEntityEnclosingRequest) actualCaptures.get(0); final String content = EntityUtils.toString(sessionTokenRequest.getEntity()); final HttpUriRequest samlRequest = actualCaptures.get(1); assertEquals(expectedSessionTokenEndpoint, sessionTokenRequest.getRequestLine().getUri()); assertEquals(expectedSessionTokenRequestEntity, content); assertEquals(expectedUri, samlRequest.getURI()); }
getSamlAssertion(@NonNull Properties props) throws SQLException { this.telemetryContext = telemetryFactory.openTelemetryContext(TELEMETRY_FETCH_SAML, TelemetryTraceLevel.NESTED);  try (final CloseableHttpClient httpClient = httpClientSupplier.get()) { final String sessionToken = getSessionToken(props); final String baseUri = getSamlUrl(props); final HttpUriRequest samlRequest = RequestBuilder .get() .setUri(baseUri) .addParameter(ONE_TIME_TOKEN, sessionToken) .build();  try (final CloseableHttpResponse resp = httpClient.execute(samlRequest)) { final StatusLine statusLine = resp.getStatusLine(); // Check HTTP Status Code is 2xx Success if (statusLine.getStatusCode() / 100 != 2) { throw new IOException(Messages.get("OktaCredentialsProviderFactory.samlRequestFailed", new Object[] { statusLine.getStatusCode(), statusLine.getReasonPhrase(), EntityUtils.toString(resp.getEntity())})); }  final HttpEntity responseEntity = resp.getEntity(); final String responseHTMLAsString = EntityUtils.toString(responseEntity, "UTF-8");  final Document document = Jsoup.parse(responseHTMLAsString); final Optional<String> samlResponseValue = Optional .ofNullable(document.selectFirst("[name=SAMLResponse]")) .map(field -> field.attr("value")); if (!samlResponseValue.isPresent()) { throw new SQLException(Messages.get("OktaCredentialsProviderFactory.invalidSamlResponse")); }  return samlResponseValue.get(); }  } catch (final IOException e) { LOGGER.severe(Messages.get("SAMLCredentialsProviderFactory.getSamlAssertionFailed", new Object[] {e})); this.telemetryContext.setSuccess(false); this.telemetryContext.setException(e); throw new SQLException(e); } finally { this.telemetryContext.closeContext(); } }
[*] target: assertEquals(expectedAssertion, samlAssertion)
[-] pred: org. junit. Assert. assertEquals ( expectedAssertion, samlAssertion )
************************************
************************************
[+] input: SQLException { when(this.mockPluginService.getHosts()).thenReturn(singleReaderTopology); when(mockPluginService.getCurrentConnection()).thenReturn(mockWriterConn); when(mockPluginService.getCurrentHostSpec()).thenReturn(writerHostSpec);  final ReadWriteSplittingPlugin plugin = new ReadWriteSplittingPlugin( mockPluginService, defaultProps, mockHostListProviderService, mockWriterConn, null); plugin.switchConnectionIfRequired(false);  verify(mockPluginService, times(0)) .setCurrentConnection(any(Connection.class), any(HostSpec.class)); assertEquals(mockWriterConn, plugin.getWriterConnection()); "<AssertPlaceHolder>"; }
getReaderConnection() { return this.readerConnection; }
[*] target: assertNull(plugin.getReaderConnection())
[-] pred: org. junit. Assert. assertNull ( plugin. getReaderConnection() )
************************************
************************************
[+] input: SQLException { when(this.mockPluginService.getHosts()).thenReturn(Collections.singletonList(writerHostSpec));  final ReadWriteSplittingPlugin plugin = new ReadWriteSplittingPlugin( mockPluginService, defaultProps, mockHostListProviderService, mockWriterConn, null); plugin.switchConnectionIfRequired(true);  verify(mockPluginService, times(0)) .setCurrentConnection(any(Connection.class), any(HostSpec.class)); assertEquals(mockWriterConn, plugin.getWriterConnection()); "<AssertPlaceHolder>"; }
getReaderConnection() { return this.readerConnection; }
[*] target: assertNull(plugin.getReaderConnection())
[-] pred: org. junit. Assert. assertNull ( plugin. getReaderConnection() )
************************************
************************************
[+] input: Exception { final Statement mockClosedStatement = mock(Statement.class); when(mockClosedStatement.isClosed()).thenReturn(true); when(mockClosedStatement.getConnection()).thenThrow(IllegalStateException.class);  final ResultSet mockResultSet = mock(ResultSet.class); when(mockResultSet.getStatement()).thenReturn(mockClosedStatement);  final Connection stmtConn = WrapperUtils.getConnectionFromSqlObject(mockClosedStatement); assertNull(stmtConn); final Connection rsConn = WrapperUtils.getConnectionFromSqlObject(mockClosedStatement); "<AssertPlaceHolder>"; }
getConnectionFromSqlObject(final Object obj) { if (obj == null) { return null; } try { if (obj instanceof Connection) { return (Connection) obj; } else if (obj instanceof Statement) { final Statement stmt = (Statement) obj; return !stmt.isClosed() ? stmt.getConnection() : null; } else if (obj instanceof ResultSet) { final ResultSet rs = (ResultSet) obj; final Statement stmt = rs.getStatement(); return stmt != null && !stmt.isClosed() ? stmt.getConnection() : null; } } catch (final SQLException | UnsupportedOperationException e) { // Do nothing. The UnsupportedOperationException comes from ResultSets returned by // DataCacheConnectionPlugin and will be triggered when getStatement is called. }  return null; }
[*] target: assertNull(rsConn)
[-] pred: org. junit. Assert. assertNull ( rsConn )
************************************
************************************
[+] input: initialization() { final var s3ClientProvider = new S3ClientProvider(null);  assertNotNull(s3ClientProvider.configuration);  S3AsyncClient t = s3ClientProvider.universalClient(); "<AssertPlaceHolder>";  var config = new S3NioSpiConfiguration(); assertSame(config, new S3ClientProvider(config).configuration); }
universalClient() { return universalClient; }
[*] target: assertNotNull(t)
[-] pred: org. junit. Assert. assertNotNull ( t )
************************************
************************************
[+] input: IOException { var foo = fs.getPath("/foo"); when(mockClient.headObject(anyConsumer())).thenReturn(completedFuture( HeadObjectResponse.builder() .lastModified(Instant.EPOCH) .contentLength(100L) .eTag("abcdef") .build())); final var basicFileAttributes = provider.readAttributes(foo, BasicFileAttributes.class); "<AssertPlaceHolder>"; assertThat(basicFileAttributes).isInstanceOf(S3BasicFileAttributes.class); }
getPath(URI uri) throws IllegalArgumentException, FileSystemNotFoundException, SecurityException { Objects.requireNonNull(uri); return getFileSystem(uri).getPath(uri.getScheme() + ":/" + uri.getPath()); }
[*] target: assertNotNull(basicFileAttributes)
[-] pred: org. junit. Assert. assertNotNull ( basicFileAttributes )
************************************
************************************
[+] input: getRootDirectories() { final var rootDirectories = s3FileSystem.getRootDirectories(); "<AssertPlaceHolder>";  final var rootDirectoriesIterator = rootDirectories.iterator();  assertTrue(rootDirectoriesIterator.hasNext()); assertEquals(PATH_SEPARATOR, rootDirectoriesIterator.next().toString()); assertFalse(rootDirectoriesIterator.hasNext()); }
getRootDirectories() { return Collections.singleton(S3Path.getPath(this, "/")); }
[*] target: assertNotNull(rootDirectories)
[-] pred: org. junit. Assert. assertNotNull ( rootDirectories )
************************************
************************************
[+] input: IOException { VideoDetail videoDetail = client.getVideoDetail("BV1Jx411o7aW"); Assertions."<AssertPlaceHolder>"; VideoInfo videoInfo = videoDetail.getVideoInfo(); Assertions.assertNotNull(videoInfo); VideoData videoData = videoInfo.getVideoData(); Assertions.assertNotNull(videoData); BilibiliResponse<PlayInfo> playInfoResponse = videoDetail.getPlayInfoResponse(); Assertions.assertNotNull(playInfoResponse); Assertions.assertNotNull(playInfoResponse.getCode()); if (ErrorCode.SUCCESS == playInfoResponse.getCode()) { PlayInfo playInfo = playInfoResponse.getData(); Assertions.assertNotNull(playInfo); PlayDash dash = playInfo.getDash(); Assertions.assertNotNull(dash); List<PlayDashInfo> videoList = dash.getVideo(); List<PlayDashInfo> audioList = dash.getAudio(); Assertions.assertNotNull(videoList); Assertions.assertFalse(videoList.isEmpty()); Assertions.assertNotNull(audioList); Assertions.assertFalse(audioList.isEmpty()); String videoDataMessage = String.format("BV:%s, title:%s, desc:%s", videoInfo.getBvid(), videoData.getTitle(), videoData.getDesc()); logger.info(videoDataMessage); Season season = videoData.getUgcSeason(); if (Objects.nonNull(season)) { String seasonMessage = String.format("Season title:%s, intro:%s, cover:%s", season.getTitle(), season.getIntro(), season.getCover()); logger.info(seasonMessage); if (Objects.nonNull(season.getSections())) { for (SeasonSection section : season.getSections()) { String sectionMessage = String.format("Section title:%s, type:%d, isActive:%b", section.getTitle(), section.getType(), section.getActive()); logger.info(sectionMessage); if (Objects.nonNull(section.getEpisodes())) { for (SectionEpisode episode : section.getEpisodes()) { String episodeMessage = String.format("Episode title:%s, bv:%s", episode.getTitle(), episode.getBvId()); if (Objects.nonNull(episode.getArc())) { episodeMessage += String.format(", arc.pic:%s", episode.getArc().getPic()); } logger.info(episodeMessage); } } } } } for (PlayDashInfo video : videoList) { String message = String.format("mimeType:%s, codecs:%s, quality:%s, baseUrl:%s", video.getMimeType(), video.getCodecs(), video.getId(), video.getBaseUrl()); logger.info(message); } for (PlayDashInfo audio : audioList) { String message = String.format("mimeType:%s, codecs:%s, quality:%s, baseUrl:%s", audio.getMimeType(), audio.getCodecs(), audio.getId(), audio.getBaseUrl()); logger.info(message); } } else { logger.info("get play info fail:" + playInfoResponse.getMessage()); } }
getVideoDetail(String bv) throws IOException { checkBuVid3BuVid4(); return getVideoDetail(bv, 1); }
[*] target: assertNotNull(videoDetail)
[-] pred: org. junit. Assert. assertNotNull ( videoDetail )
************************************
************************************
[+] input: IOException { VideoDetail videoDetail = client.getVideoDetail("BV1Jx411o7aW", 19); Assertions."<AssertPlaceHolder>"; VideoInfo videoInfo = videoDetail.getVideoInfo(); Assertions.assertNotNull(videoInfo); VideoData videoData = videoInfo.getVideoData(); Assertions.assertNotNull(videoData); BilibiliResponse<PlayInfo> playInfoResponse = videoDetail.getPlayInfoResponse(); Assertions.assertNotNull(playInfoResponse); Assertions.assertNotNull(playInfoResponse.getCode()); if (ErrorCode.SUCCESS == playInfoResponse.getCode()) { PlayInfo playInfo = playInfoResponse.getData(); Assertions.assertNotNull(playInfo); PlayDash dash = playInfo.getDash(); Assertions.assertNotNull(dash); List<PlayDashInfo> videoList = dash.getVideo(); List<PlayDashInfo> audioList = dash.getAudio(); Assertions.assertNotNull(videoList); Assertions.assertFalse(videoList.isEmpty()); Assertions.assertNotNull(audioList); Assertions.assertFalse(audioList.isEmpty()); String videoDataMessage = String.format("BV:%s, title:%s, desc:%s", videoInfo.getBvid(), videoData.getTitle(), videoData.getDesc()); logger.info(videoDataMessage); Season season = videoData.getUgcSeason(); if (Objects.nonNull(season)) { String seasonMessage = String.format("Season title:%s, intro:%s, cover:%s", season.getTitle(), season.getIntro(), season.getCover()); logger.info(seasonMessage); if (Objects.nonNull(season.getSections())) { for (SeasonSection section : season.getSections()) { String sectionMessage = String.format("Section title:%s, type:%d, isActive:%b", section.getTitle(), section.getType(), section.getActive()); logger.info(sectionMessage); if (Objects.nonNull(section.getEpisodes())) { for (SectionEpisode episode : section.getEpisodes()) { String episodeMessage = String.format("Episode title:%s, bv:%s", episode.getTitle(), episode.getBvId()); if (Objects.nonNull(episode.getArc())) { episodeMessage += String.format(", arc.pic:%s", episode.getArc().getPic()); } logger.info(episodeMessage); } } } } } for (PlayDashInfo video : videoList) { String message = String.format("mimeType:%s, codecs:%s, quality:%s, baseUrl:%s", video.getMimeType(), video.getCodecs(), video.getId(), video.getBaseUrl()); logger.info(message); } for (PlayDashInfo audio : audioList) { String message = String.format("mimeType:%s, codecs:%s, quality:%s, baseUrl:%s", audio.getMimeType(), audio.getCodecs(), audio.getId(), audio.getBaseUrl()); logger.info(message); } } else { logger.info("get play info fail:" + playInfoResponse.getMessage()); } }
getVideoDetail(String bv, int page) throws IOException { // todo get subtitle_url from https://api.bilibili.com/x/player/wbi/v2?aid=xxxx&cid=xxx String url = ApiUtil.fillUrl(ApiUrlContainer.VIDEO_URL, bv, page); String html = httpJsonClient.get(url, requestHeader); VideoInfo videoInfo = parseVideoInfo(html); BilibiliResponse<PlayInfo> playInfo = parsePlayInfo(html); VideoDetail videoDetail = new VideoDetail(); videoDetail.setVideoInfo(videoInfo); videoDetail.setPlayInfoResponse(playInfo); videoDetail.setUrl(url); return videoDetail; }
[*] target: assertNotNull(videoDetail)
[-] pred: org. junit. Assert. assertNotNull ( videoDetail )
************************************
************************************
[+] input: IOException { DmWebViewReply dmWebViewReply = client.videoDanmakuView(885244431); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(dmWebViewReply.hasDmSge()); Assertions.assertTrue(dmWebViewReply.getDmSge().hasTotal()); logger.info("count:" + dmWebViewReply.getCount()); for (CommandDm commandDm : dmWebViewReply.getCommandDmsList()) { logger.info(commandDm.getMtime() + ">" + commandDm.getContent()); } }
videoDanmakuView(long oid) throws IOException { checkBuVid3BuVid4(); String url = ApiUtil.fillUrl(ApiUrlContainer.VIDEO_DANMAKU_VIEW, oid); byte[] data = httpJsonClient.getByteArray(url, requestHeader); return DmWebViewReply.parseFrom(data); }
[*] target: assertNotNull(dmWebViewReply)
[-] pred: org. junit. Assert. assertNotNull ( dmWebViewReply )
************************************
************************************
[+] input: IOException { BilibiliResponse<BilibiliPageInfo<VideoData>> response = client.popular(1, 50); Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(response.getCode()); Assertions.assertEquals(response.getCode(), ErrorCode.SUCCESS); Assertions.assertNotNull(response.getData()); List<VideoData> list = response.getData().getList(); Assertions.assertNotNull(list); Assertions.assertFalse(list.isEmpty()); for (VideoData videoData : list) { Assertions.assertNotNull(videoData); Assertions.assertNotNull(videoData.getOwner()); logger.info("推荐视频:" + videoData.getTitle() + "[" + videoData.getBvid() + "]" + " " + videoData.getOwner().getName()); } }
popular(int pageNum, int pageSize) throws IOException { checkBuVid3BuVid4(); String url = ApiUtil.fillUrl(ApiUrlContainer.POPULAR, pageNum, pageSize); return httpJsonClient.getJson(url, new TypeReference<BilibiliResponse<BilibiliPageInfo<VideoData>>>() { }, requestHeader); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: IOException { BilibiliResponse<UserNav> navResponse = client.nav(); Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(navResponse.getData()); WbiImg wbiImg = navResponse.getData().getWbiImg(); Assertions.assertNotNull(wbiImg); BilibiliResponse<SpaceSearchResult> response = client.spaceSearch(1, 50, 423895, WbiUtil.getMixinKey(wbiImg.getImgKey(), wbiImg.getSubKey())); Assertions.assertNotNull(response); Assertions.assertEquals(response.getCode(), 0, response.getMessage()); Assertions.assertNotNull(response.getData()); Assertions.assertNotNull(response.getData().getList()); List<SearchVideoInfo> list = response.getData().getList().getVlist(); if (list != null) { for (SearchVideoInfo video : list) { String message = String.format("BV:%s, title:%s, author:%s", video.getBvId(), ApiUtil.removeSearchHighlight(video.getTitle()), ApiUtil.removeSearchHighlight(video.getAuthor())); logger.info(message); } } }
nav() throws IOException { checkBuVid3BuVid4(); return httpJsonClient.getJson(ApiUrlContainer.USER_NAV, new TypeReference<BilibiliResponse<UserNav>>() { }, requestHeader); }
[*] target: assertNotNull(navResponse)
[-] pred: org. junit. Assert. assertNotNull ( navResponse )
************************************
************************************
[+] input: ibgeMunicipiosPass() { IBGEMunicipio[] ibgeMunicipios1 = BrasilAPI.ibgeMunicipios("SE"); IBGEMunicipio[] ibgeMunicipios2 = BrasilAPI.ibgeMunicipios("SE", new String[] { "dados-abertos-br" }); "<AssertPlaceHolder>"; assertNotNull(ibgeMunicipios2); }
ibgeMunicipios(String siglaUF, String[] providers) { String providesParameter = "?providers=dados-abertos-br,gov,wikipedia"; if (providers != null) { providesParameter = "?providers="; for (String provider : providers) { providesParameter += provider + ","; } providesParameter = providesParameter.substring(0, providesParameter.length() - 1); }  IBGEMunicipio[] obj = (IBGEMunicipio[]) api(IBGEMunicipio[].class, "ibge/municipios/v1/", siglaUF + providesParameter); return obj != null ? (IBGEMunicipio[]) obj.clone() : null; }
[*] target: assertNotNull(ibgeMunicipios1)
[-] pred: org. junit. Assert. assertNotNull ( ibgeMunicipios1 )
************************************
************************************
[+] input: mappedSchemaRequiresPreprocessingTest() { final var tableSchema = mock(TableSchema.class); doCallRealMethod().when(tableSchema).requiresPreprocessing();  final List<ColumnSchema> noPreProcessingSchemas = List.of(GeneralTestUtility.cleartextColumn("u1")); when(tableSchema.getColumns()).thenReturn(noPreProcessingSchemas); assertFalse(tableSchema.requiresPreprocessing());  final List<ColumnSchema> sealedRequiresPreProcessing = List.of(GeneralTestUtility.sealedColumn("s1"), GeneralTestUtility.sealedColumn("s2", "t2", PadType.FIXED, 50)); when(tableSchema.getColumns()).thenReturn(sealedRequiresPreProcessing); assertTrue(tableSchema.requiresPreprocessing());  final List<ColumnSchema> fingerprintRequiresPreProcessing = List.of(GeneralTestUtility.fingerprintColumn("j1")); when(tableSchema.getColumns()).thenReturn(fingerprintRequiresPreProcessing); "<AssertPlaceHolder>"; }
requiresPreprocessing() { return getColumns().stream().anyMatch(ColumnSchema::requiresPreprocessing); }
[*] target: assertTrue(tableSchema.requiresPreprocessing())
[-] pred: org. junit. Assert. assertTrue ( tableSchema. requiresPreprocessing() )
************************************
************************************
[+] input: parseAndToStringCompareTest() { String original = "$test($arg1, $arg2, $arg3, $arg4) -> 'SIEMA'"; Result<Template, String> result = Template.parse(original);  assertTrue(result.isOk());  Template template = result.get(); String deserialized = template.toString();  "<AssertPlaceHolder>"; }
toString() { return String.format(TEMPLATE_FORMAT, this.name, Joiner.on(SEPARATOR_FORMAT).join(this.arguments, arg -> String.format(ARGUMENT_FORMAT, arg)), this.content); }
[*] target: assertEquals(original, deserialized)
[-] pred: org. junit. Assert. assertEquals ( original, deserialized )
************************************
************************************
[+] input: Exception { SlackWebhookProperties props = new SlackWebhookProperties( "slackTest", SLACK_SIGNING_KEY, CHALLENGE_RESPONSE_VERIFICATION_FUNCTION); SlackConnectorPropertiesWrapper wrapper = new SlackConnectorPropertiesWrapper(props); when(ctx.bindProperties(SlackConnectorPropertiesWrapper.class)).thenReturn(wrapper); testObject = new SlackInboundWebhookExecutable(); final var requestTimeStamp = String.valueOf(now().toInstant().toEpochMilli()); Map<String, String> headers = Map.of( HEADER_SLACK_SIGNATURE, slackCurrentSignature(requestTimeStamp, URL_VERIFICATION_REQUEST), HEADER_SLACK_REQUEST_TIMESTAMP, requestTimeStamp); final var payload = mock(WebhookProcessingPayload.class); when(payload.method()).thenReturn("POST"); when(payload.headers()).thenReturn(headers); when(payload.rawBody()).thenReturn(URL_VERIFICATION_REQUEST.getBytes(UTF_8));  testObject.activate(ctx); final var result = testObject.verify(payload);  "<AssertPlaceHolder>"; assertThat(result.body()).isInstanceOf(Map.class); assertThat((Map) result.body()).containsEntry(FIELD_CHALLENGE, "aAaAaAaAaAaAaAaAaAaA"); }
verify(WebhookProcessingPayload payload) { verifySlackRequestAuthentic(payload); return Optional.ofNullable(props.verificationExpression()) .orElse(stringObjectMap -> null) .apply( Map.of( "body", bodyAsMap(payload.headers(), payload.rawBody()), "headers", payload.headers(), "params", payload.params())); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { String testDataset = "id,date,location\n" + "x,2020-10-11,loc1\n" + "x,2020-10-11,loc2\n" + "y,2020-10-11,loc2\n" + "z,2020-10-11,loc1\n" + "y,2020-10-11,loc1\n" + "y,2020-10-11,loc3\n" + "y,2020-10-11,loc5\n" + "z,2020-10-11,loc2";  // "id,timestamp,location,amount"  try ( InputStream conf = TransactionUniquenessTaskTest.class.getResourceAsStream("/transaction-uniqueness-ok.json"); InputStream input = new ByteArrayInputStream(testDataset.getBytes()); ByteArrayOutputStream output = new ByteArrayOutputStream() ) {  TransactionUniquenessTask uniqueness = mapper.readValue(conf, TransactionUniquenessTask.class);  uniqueness.processFile(input, output);  System.out.println(output);  TransactionUniquenessReport report = mapper.readValue(output.toString(), TransactionUniquenessReport.class);  "<AssertPlaceHolder>";  assertEquals(report.getTotalIDs(), 3); assertEquals(report.getTotalTransactions(), 8); assertEquals(report.getUniqueTransactions(), 2); assertEquals(report.getUniqueIDs(), 1); } }
processFile(InputStream input, OutputStream output) throws MisconfigurationException, IOException { final IPVDataset dataset = readInputDataset(input); final int threshold = getTaskOptions().getThreshold();  Map<Integer, Set<Integer>> idsByTransaction = groupTransactionIdByTargetValues(dataset, getTaskOptions().getIdentityFields(), getTaskOptions().getExternallyObservableFields());  List<Integer> totalIDs = countNumberOfTotalIDs(idsByTransaction); List<Set<Integer>> uniqueTransactionCombinations = identifyUniqueTransactions(idsByTransaction, threshold); List<Integer> uniqueIDs = extractIDsOfUniqueTransactions(uniqueTransactionCombinations);  if (this.getTaskOptions().isExploreExternallyObservableFields()) { List<TransactionUniquenessReportColumnContribution> columnsContributions = new ArrayList<>(getTaskOptions().getExternallyObservableFields().size()); for(String column : getTaskOptions().getExternallyObservableFields()) { Map<Integer, Set<Integer>> contribIdsByTransaction = groupTransactionIdByTargetValues(dataset, getTaskOptions().getIdentityFields(), Collections.singletonList((column))); List<Set<Integer>> contribUniqueTransactionCombinations = identifyUniqueTransactions(contribIdsByTransaction, threshold); List<Integer> contribUniqueIDs = extractIDsOfUniqueTransactions(contribUniqueTransactionCombinations); columnsContributions.add(new TransactionUniquenessReportColumnContribution( column, contribUniqueTransactionCombinations.size(), contribUniqueIDs.size() )); } mapper.writeValue(output, new TransactionUniquenessReport( totalIDs.size(), dataset.getNumberOfRows(), uniqueTransactionCombinations.size(), uniqueIDs.size(), columnsContributions )); } else { mapper.writeValue(output, new TransactionUniquenessReport( totalIDs.size(), dataset.getNumberOfRows(), uniqueTransactionCombinations.size(), uniqueIDs.size(), null )); } }
[*] target: assertNotNull(report)
[-] pred: org. junit. Assert. assertNotNull ( report )
************************************
************************************
[+] input: Exception { CountryManager countryManager = CountryManager.getInstance(); String country = "United States of America"; assertTrue(countryManager.isValidKey(country)); assertTrue(countryManager.isValidCountry(country, CountryNameSpecification.NAME));  //check that 3 ISO letter code is matched country = "USA"; assertTrue(countryManager.isValidKey(country)); assertTrue(countryManager.isValidCountry(country, CountryNameSpecification.ISO3));  country = "GB"; assertTrue(countryManager.isValidKey(country)); assertTrue(countryManager.isValidCountry(country, CountryNameSpecification.ISO2));  //check that the lowercase version is also matched country = "brazil"; assertTrue(countryManager.isValidKey(country));  //check that friendly name is also matched country = "Vietnam"; assertTrue(countryManager.isValidKey(country));  country = "sierra leone"; assertTrue(countryManager.isValidKey(country));  country = "Foobar"; "<AssertPlaceHolder>"; }
isValidKey(String country) { String key = country.toUpperCase(); for (CountryNameSpecification e : CountryNameSpecification.values()) { if (countryMap.get(getAllCountriesName())[e.ordinal()].getMap().containsKey(key)) { return true; } }  return false; }
[*] target: assertFalse(countryManager.isValidKey(country))
[-] pred: org. junit. Assert. assertFalse ( countryManager. isValidKey( country ) )
************************************
************************************
[+] input: testLookupSuccessful() { VINManager vinManager = new VINManager(); String wmi = "1C3"; assertTrue(vinManager.isValidWMI(wmi));  //check that the lowercase version is also matched wmi = "1c3"; "<AssertPlaceHolder>"; }
isValidWMI(String wmi) { if (wmi.length() != 3) { return false; }  return wmiMap.containsKey(wmi.toUpperCase()); }
[*] target: assertTrue(vinManager.isValidWMI(wmi))
[-] pred: org. junit. Assert. assertTrue ( vinManager. isValidWMI(wmi ) )
************************************
************************************
[+] input: identifiedEntitiesAreTreatedByTypeCorrectly() { MaskingProviderFactory mockedFactory = mock(MaskingProviderFactory.class); MaskingProvider mockedNameMP = mock(MaskingProvider.class); MaskingProvider mockedAddressMP = mock(MaskingProvider.class); when(mockedFactory.get(ArgumentMatchers.same(ProviderType.NAME), any(MaskingConfiguration.class))).thenReturn(mockedNameMP); when(mockedFactory.get(ArgumentMatchers.same(ProviderType.ADDRESS), any(MaskingConfiguration.class))).thenReturn(mockedAddressMP);  String maskingName = "BAR"; when(mockedNameMP.mask(anyString(), eq("NAME"))).thenReturn(maskingName); String maskingAddressValue = "DUMMY ADDRESS"; when(mockedAddressMP.mask(anyString(), eq("ADDRESS"))).thenReturn(maskingAddressValue);  List<IdentifiedEntity> toMask = Arrays.asList( new IdentifiedEntity("foo", 0, 0, Collections.singleton(nameType), Collections.singleton(PartOfSpeechType.UNKNOWN)), new IdentifiedEntity("foo", 0, 0, Collections.singleton(addressType), Collections.singleton(PartOfSpeechType.UNKNOWN)) );  Map<String, DataMaskingTarget> toBeMasked = new HashMap<>(); toBeMasked.put("NAME", new DataMaskingTarget(ProviderType.NAME, "dummy")); toBeMasked.put("ADDRESS", new DataMaskingTarget(ProviderType.ADDRESS, "dummy"));  DataMaskingOptions dataMaskingOptions = new DataMaskingOptions(DataTypeFormat.PLAIN, DataTypeFormat.PLAIN, toBeMasked, false, null, null); MaskIdentifiedEntities ftMask = new MaskIdentifiedEntities(new ConfigurationManager(), dataMaskingOptions, mockedFactory);  List<IdentifiedEntity> maskedEntities = ftMask.maskEntities(toMask);  "<AssertPlaceHolder>"; assertThat(maskedEntities.size(), is(toMask.size()));  verify(mockedNameMP, times(1)).mask(anyString(), eq("NAME")); verify(mockedAddressMP, times(1)).mask(anyString(), eq("ADDRESS")); }
maskEntities(final List<IdentifiedEntity> entities) { Map<String, DataMaskingTarget> toBeMasked = dataMaskingOptions.getToBeMasked();  return entities.parallelStream().map( entity -> { final String type = entity.getType().iterator().next().getSubtype();  String maskedValue = (toBeMasked.containsKey(type)) ? mask(entity.getText(), configurationManager.getFieldConfiguration(type), toBeMasked.get(type).getProviderType(), type) : entity.getText();  return new IdentifiedEntity(maskedValue, entity.getStart(), entity.getEnd(), entity.getType(), entity.getPos()); }).collect(Collectors.toList()); }
[*] target: assertNotNull(maskedEntities)
[-] pred: org. junit. Assert. assertNotNull ( maskedEntities )
************************************
************************************
[+] input: Exception { JSONRecord record = new JSONRecord(mapper.readTree("{"a": [{"b":1},{"b":2}]}"));  Iterable<String> nodes = record.generatePaths("/a/1/b");  "<AssertPlaceHolder>"; assertThat((int) StreamSupport.stream(nodes.spliterator(), false).count(), is(1)); }
generatePaths(String pattern) { List<String> pointers = Arrays.asList(pattern.split("/"));  return generatePaths(node, pointers.subList(1, pointers.size()), ""); }
[*] target: assertNotNull(nodes)
[-] pred: org. junit. Assert. assertNotNull ( nodes )
************************************
************************************
[+] input: Exception { JSONRecord record = new JSONRecord(mapper.readTree("{"a": [{"b":1},{"b":2}]}"));  Iterable<String> nodes = record.generatePaths("/a/*/b");  "<AssertPlaceHolder>"; assertThat((int) StreamSupport.stream(nodes.spliterator(), false).count(), is(2)); }
generatePaths(String pattern) { List<String> pointers = Arrays.asList(pattern.split("/"));  return generatePaths(node, pointers.subList(1, pointers.size()), ""); }
[*] target: assertNotNull(nodes)
[-] pred: org. junit. Assert. assertNotNull ( nodes )
************************************
************************************
[+] input: Exception { JSONRecord record = new JSONRecord(mapper.readTree("[{"b":1},{"b":2}]"));  Iterable<String> nodes = record.generatePaths("/*/b");  "<AssertPlaceHolder>"; assertThat((int) StreamSupport.stream(nodes.spliterator(), false).count(), is(2)); }
generatePaths(String pattern) { List<String> pointers = Arrays.asList(pattern.split("/"));  return generatePaths(node, pointers.subList(1, pointers.size()), ""); }
[*] target: assertNotNull(nodes)
[-] pred: org. junit. Assert. assertNotNull ( nodes )
************************************
************************************
[+] input: Exception { JSONRecord record = new JSONRecord(mapper.readTree("" + "{"a": [{"b":[{"a": 1},{"a": 1}]},{"b":[{"a": 1}]}]}" + ""));  Iterable<String> nodes = record.generatePaths("/a/*/b/*/a");  "<AssertPlaceHolder>"; assertThat((int) StreamSupport.stream(nodes.spliterator(), false).count(), is(3)); }
generatePaths(String pattern) { List<String> pointers = Arrays.asList(pattern.split("/"));  return generatePaths(node, pointers.subList(1, pointers.size()), ""); }
[*] target: assertNotNull(nodes)
[-] pred: org. junit. Assert. assertNotNull ( nodes )
************************************
************************************
[+] input: testMissedFromMasking() { AgeIdentifier identifier = new AgeIdentifier();  String target = "5 years, 6 months, and 11 days";  Age age = identifier.parseAge(target);  "<AssertPlaceHolder>";  assertThat(target.substring(age.getYearPortion().getStart(), age.getYearPortion().getEnd()), is("5")); assertThat(target.substring(age.getMonthPortion().getStart(), age.getMonthPortion().getEnd()), is("6")); assertThat(target.substring(age.getDaysPortion().getStart(), age.getDaysPortion().getEnd()), is("11")); }
parseAge(String identifier) { AgePortion yearPortion = MISSING_AGE_PORTION; AgePortion monthPortion = MISSING_AGE_PORTION; AgePortion weekPortion = MISSING_AGE_PORTION; AgePortion daysPortion = MISSING_AGE_PORTION;  for (Pattern pattern : getPatterns()) { Matcher matcher = pattern.matcher(identifier); if (matcher.matches()) { try { int start = matcher.start("year"); int end = matcher.end("year"); yearPortion = new AgePortion(true, start, end, AgePortionFormat.NUMERICAL); } catch (IllegalArgumentException e) { }  try { int start = matcher.start("month"); int end = matcher.end("month"); monthPortion = new AgePortion(true, start, end, AgePortionFormat.NUMERICAL); } catch (IllegalArgumentException e) { }  try { int start = matcher.start("week"); int end = matcher.end("week"); weekPortion = new AgePortion(true, start, end, AgePortionFormat.NUMERICAL); } catch (IllegalArgumentException e) { }  try { int start = matcher.start("day"); int end = matcher.end("day"); daysPortion = new AgePortion(true, start, end, AgePortionFormat.NUMERICAL); } catch (IllegalArgumentException e) { }  return new Age(yearPortion, monthPortion, weekPortion, daysPortion); } }  return tryWordParse(identifier); }
[*] target: assertNotNull(age)
[-] pred: org. junit. Assert. assertNotNull ( age )
************************************
************************************
[+] input: testInvalid() { Identifier identifier = new IMSIIdentifier();  String imsi = "foobar"; assertFalse(identifier.isOfThisType(imsi));  imsi = "1234455666"; //invalid length assertFalse(identifier.isOfThisType(imsi));  imsi = "1234455666123a5"; //contains letter assertFalse(identifier.isOfThisType(imsi));  imsi = "000000566612345"; //invalid MCC, MNC "<AssertPlaceHolder>"; }
isOfThisType(String data) { return imsiManager.isValidIMSI(data); }
[*] target: assertFalse(identifier.isOfThisType(imsi))
[-] pred: org. junit. Assert. assertFalse ( identifier. isOfThisType(imsi ) )
************************************
************************************
[+] input: testIsOfThisType() { SSNUKIdentifier identifier = new SSNUKIdentifier();  String ssn = "AB123456C"; assertTrue(identifier.isOfThisType(ssn));  //ignores spaces ssn = "AB 12 34 56 C"; assertTrue(identifier.isOfThisType(ssn));  //check for not allowed characters ssn = "DB123456C"; assertFalse(identifier.isOfThisType(ssn)); ssn = "AD123456C"; assertFalse(identifier.isOfThisType(ssn)); ssn = "AO123456C"; assertFalse(identifier.isOfThisType(ssn)); ssn = "BA12A456C"; assertFalse(identifier.isOfThisType(ssn)); ssn = "BA1234567"; assertFalse(identifier.isOfThisType(ssn)); ssn = "BA123456Z"; assertFalse(identifier.isOfThisType(ssn));  //'O' is allowed on the first character ssn = "OA123456C"; "<AssertPlaceHolder>"; }
isOfThisType(String data) { String ssn = data.replace(" ", "").toUpperCase(); if (ssn.length() != 9) { return false; }  char first = ssn.charAt(0); char second = ssn.charAt(1); if (!Character.isAlphabetic(first) || !Character.isAlphabetic(second)) { return false; }  if (first == 'D' || first == 'F' || first == 'I' || first == 'Q' || first == 'U' || first == 'V') { return false; }  if (second == 'D' || second == 'F' || second == 'I' || second == 'Q' || second == 'U' || second == 'V' || second == 'O') { return false; }  for (int i = 2; i < 8; i++) { if (!Character.isDigit(ssn.charAt(i))) { return false; } }  char last = ssn.charAt(8); return last >= 'A' && last <= 'D'; }
[*] target: assertTrue(identifier.isOfThisType(ssn))
[-] pred: org. junit. Assert. assertTrue ( identifier. isOfThisType ( ssn ) )
************************************
************************************
[+] input: testMaskPseudorandom() { MaskingConfiguration maskingConfiguration = new DefaultMaskingConfiguration(); maskingConfiguration.setValue("address.mask.pseudorandom", true);  AddressIdentifier identifier = new AddressIdentifier(); AddressMaskingProvider addressMaskingProvider = new AddressMaskingProvider(maskingConfiguration);  String[] validAddresses = { "200 E Main St, Phoenix AZ 85123, USA", "200 E Main St" };  for(String validAddress: validAddresses) { String randomAddress = addressMaskingProvider.mask(validAddress); assertTrue(identifier.isOfThisType(randomAddress)); assertNotEquals(randomAddress, validAddress);  for (int i = 0; i < 100; i++) { String rnd = addressMaskingProvider.mask(validAddress); "<AssertPlaceHolder>"; } } }
mask(String identifier) { Address randomAddress;  Address address = addressIdentifier.parseAddress(identifier); if (address == null) { address = new Address("", "", "", "", "", ""); randomAddress = new Address(); } else { randomAddress = new Address(address); }  if (address.isPOBox()) { randomAddress.setPoBox(true);  if (this.getPseudorandom) { String poBoxNumber = address.getPoBoxNumber(); randomAddress.setPoBoxNumber(Long.toString(Math.abs(HashUtils.longFromHash(poBoxNumber)) % 10000)); } else { randomAddress.setPoBoxNumber(random.nextInt(10000) + ""); } return randomAddress.toString(); }  if (this.randomizeNumber) { if (this.getPseudorandom) { String number = randomAddress.getNumber(); randomAddress.setNumber(Long.toString(Math.abs(HashUtils.longFromHash(number)) % 300)); } else { randomAddress.setNumber(this.random.nextInt(300) + ""); } }  if (this.randomizeCity) { //psuedorandom is embedded into the provider itself, we have set the configuration accordingly randomAddress.setCityOrState(cityMaskingProvider.mask(address.getCityOrState())); }  if (this.randomizeCountry) { //psuedorandom is embedded into the provider itself, we have set the configuration accordingly randomAddress.setCountry(countryMaskingProvider.mask(address.getCountry())); }  if (this.randomizeName) { if (this.getPseudorandom) { String sname = randomAddress.getName(); randomAddress.setName(streetNameManager.getPseudorandom(sname)); } else { randomAddress.setName(streetNameManager.getRandomKey()); } }  if (this.randomizeRoadType) { RoadTypes[] roadTypes = RoadTypes.values(); int randomPosition;  if (this.getPseudorandom) { randomPosition = (int) (Math.abs(HashUtils.longFromHash(identifier)) % roadTypes.length); } else { randomPosition = random.nextInt(roadTypes.length); }  String randomRoadType = roadTypes[randomPosition].name(); randomAddress.setRoadType(randomRoadType); }  if (this.randomizePostalCode) {  if (this.getPseudorandom) { String postalCode = address.getPostalCode(); randomAddress.setPostalCode(postalCodeManager.getPseudorandom(postalCode)); } else if (this.nearestPostalCode) { String postalCode = address.getPostalCode(); randomAddress.setPostalCode(postalCodeManager.getClosestPostalCode(postalCode, this.nearestPostalCodeK)); } else { randomAddress.setPostalCode(postalCodeManager.getRandomKey()); } }  return randomAddress.toString(); }
[*] target: assertEquals(randomAddress, rnd)
[-] pred: org. junit. Assert. assertEquals ( randomAddress, rnd )
************************************
************************************
[+] input: Exception {  MaskingConfiguration maskingConfiguration = new DefaultMaskingConfiguration(); maskingConfiguration.setValue("city.mask.pseudorandom", true);  MaskingProvider maskingProvider = new CityMaskingProvider(maskingConfiguration);  Collection<ResourceEntry> entryCollection = LocalizationManager.getInstance().getResources(Resource.CITY, Collections.singletonList("gr")); Set<String> greekValues = new HashSet<>();  for(ResourceEntry entry: entryCollection) { InputStream inputStream = entry.createStream(); try (CSVParser reader = Readers.createCSVReaderFromStream(inputStream)) { for (CSVRecord line : reader) { String name = line.get(0); greekValues.add(name.toUpperCase()); } inputStream.close(); } }  String originalCity = "Πάτρα"; String maskedCity = maskingProvider.mask(originalCity);  String firstMask = maskedCity;  for(int i = 0; i < 100; i++) { maskedCity = maskingProvider.mask(originalCity); "<AssertPlaceHolder>"; assertTrue(greekValues.contains(maskedCity.toUpperCase())); }  }
mask(String identifier) {  if (getPseudorandom) { return cityManager.getPseudorandom(identifier); }  if (getClosest) { return cityManager.getClosestCity(identifier, this.closestK); }  City city = cityManager.getKey(identifier); if (city == null) { return cityManager.getRandomKey(); }  return cityManager.getRandomKey(city.getNameCountryCode()); }
[*] target: assertEquals(firstMask, maskedCity)
[-] pred: org. junit. Assert. assertEquals ( firstMask, maskedCity )
************************************
************************************
[+] input: Exception { String greekHospital = "ΠΕΠΑΓΝΗ";  Collection<ResourceEntry> entryCollection = LocalizationManager.getInstance().getResources(Resource.HOSPITAL_NAMES, Collections.singletonList("gr")); Set<String> greekHospitals = new HashSet<>();  for(ResourceEntry entry: entryCollection) { InputStream inputStream = entry.createStream(); try (CSVParser reader = Readers.createCSVReaderFromStream(inputStream)) { for (CSVRecord line : reader) { String name = line.get(0); greekHospitals.add(name.toUpperCase()); } inputStream.close(); } }  MaskingProvider maskingProvider = new HospitalMaskingProvider();  int randomizationOK = 0; for(int i = 0; i < 100; i++) { String maskedHospital = maskingProvider.mask(greekHospital); if (!maskedHospital.equalsIgnoreCase(greekHospital)) { randomizationOK++; }  boolean isMatch = greekHospitals.contains(maskedHospital.toUpperCase());  if (!isMatch) { System.out.println(maskedHospital); }  "<AssertPlaceHolder>"; }  assertTrue(randomizationOK > 0); }
mask(String identifier) { if (!this.preserveCountry) { return hospitalManager.getRandomKey(); }  Hospital hospital = hospitalManager.getKey(identifier); if (hospital == null) { return hospitalManager.getRandomKey(); }  return hospitalManager.getRandomKey(hospital.getNameCountryCode()); }
[*] target: assertTrue(isMatch)
[-] pred: org. junit. Assert. assertTrue ( isMatch )
************************************
************************************
[+] input: testPersistence() {  String email1 = "joedoe1@foo.com"; String email2 = "joedoe2@foo.com";  MaskingProvider emailMaskingProvider = new EmailMaskingProvider(new MaskingProviderFactory(new ConfigurationManager(), Collections.emptyMap()));  DefaultMaskingConfiguration configuration = new DefaultMaskingConfiguration(); configuration.setValue("persistence.file", "/tmp"); configuration.setValue("persistence.namespace", "AAAA");  FileBackedPersistentMaskingProvider provider = new FileBackedPersistentMaskingProvider(emailMaskingProvider, configuration);  String maskedEmail1_once = provider.mask(email1); String maskedEmail1_twice = provider.mask(email1); "<AssertPlaceHolder>";  String maskedEmail2_once = provider.mask(email2); assertNotEquals(maskedEmail2_once, maskedEmail1_once); }
setValue(String identifier, String maskedValue) throws IOException { synchronized (this) { int valueCode = identifier.hashCode(); String oldValue = mappings.putIfAbsent(valueCode, maskedValue); if (!maskedValue.equals(oldValue)) { appendMapping(valueCode, maskedValue); } } }
[*] target: assertEquals(maskedEmail1_once, maskedEmail1_twice)
[-] pred: org. junit. Assert. assertEquals ( maskedEmail1_once, maskedEmail1_twice )
************************************
************************************
[+] input: testReconstructsDictionaryWithValueInserted() { String term = "foo";  ChainRetrieval chainRetrieval = new ChainRetrieval() { @Override public List<DictionaryEntry> retrieveChain() { return Arrays.asList( new DictionaryEntry("A", DictionaryEntryType.INSERT), new DictionaryEntry("B", DictionaryEntryType.INSERT), new DictionaryEntry(CausalOrderingConsistentMaskingProvider.privateHash(term), DictionaryEntryType.VALUE), new DictionaryEntry("C", DictionaryEntryType.INSERT), new DictionaryEntry("D", DictionaryEntryType.INSERT) ); }  @Override public void append(String hashedTerm) throws Exception {  }  @Override public void shutDown() {  } };  List<DictionaryEntry> dictionaryEntries = CausalOrderingConsistentMaskingProvider.reconstructDictionary(chainRetrieval, term);  "<AssertPlaceHolder>"; assertEquals("A", dictionaryEntries.get(0).getValue()); assertEquals("B", dictionaryEntries.get(1).getValue()); }
reconstructDictionary(ChainRetrieval chainRetrieval, String term) { List<DictionaryEntry> entries = new ArrayList<>(); Set<String> entriesToRemove = new HashSet<>();  String hashedTerm = privateHash(term);  List<DictionaryEntry> chainEntries; try { chainEntries = chainRetrieval.retrieveChain(); } catch (IOException e) { throw new RuntimeException("unable to retrieve entries from chain"); }  boolean valueFound = false;  for (DictionaryEntry entry : chainEntries) { if (entry.getType() == DictionaryEntryType.VALUE && entry.getValue().equals(hashedTerm)) { valueFound = true; break; }  if (entry.getType() == DictionaryEntryType.INSERT) { entries.add(entry); } else if (entry.getType() == DictionaryEntryType.DELETE) { entriesToRemove.add(entry.getValue()); } }   if (!valueFound) { try { chainRetrieval.append(hashedTerm); } catch (Exception e) { throw new RuntimeException("unable to append entry to chain"); } }  if (!entriesToRemove.isEmpty()) { int totalEntries = entries.size();  for (int i = (totalEntries - 1); i >= 0; i--) { DictionaryEntry entry = entries.get(i); if (entry.getType() != DictionaryEntryType.INSERT) { continue; }  if (entriesToRemove.contains(entry.getValue())) { entries.remove(i); } } }  return entries;  }
[*] target: assertEquals(2, dictionaryEntries.size())
[-] pred: org. junit. Assert. assertEquals ( 2, dictionaryEntries. size ( ) )
************************************
************************************
[+] input: testReconstructsDictionaryWithValueInsertedWithDelete() { String term = "foo";  ChainRetrieval chainRetrieval = new ChainRetrieval() { @Override public List<DictionaryEntry> retrieveChain() { return Arrays.asList( new DictionaryEntry("A", DictionaryEntryType.INSERT), new DictionaryEntry("B", DictionaryEntryType.INSERT), new DictionaryEntry("B", DictionaryEntryType.DELETE), new DictionaryEntry(CausalOrderingConsistentMaskingProvider.privateHash(term), DictionaryEntryType.VALUE), new DictionaryEntry("C", DictionaryEntryType.INSERT), new DictionaryEntry("D", DictionaryEntryType.INSERT) ); }  @Override public void append(String hashedTerm) throws Exception {  }  @Override public void shutDown() {  } };  List<DictionaryEntry> dictionaryEntries = CausalOrderingConsistentMaskingProvider.reconstructDictionary(chainRetrieval, term);  "<AssertPlaceHolder>"; assertEquals("A", dictionaryEntries.get(0).getValue()); }
reconstructDictionary(ChainRetrieval chainRetrieval, String term) { List<DictionaryEntry> entries = new ArrayList<>(); Set<String> entriesToRemove = new HashSet<>();  String hashedTerm = privateHash(term);  List<DictionaryEntry> chainEntries; try { chainEntries = chainRetrieval.retrieveChain(); } catch (IOException e) { throw new RuntimeException("unable to retrieve entries from chain"); }  boolean valueFound = false;  for (DictionaryEntry entry : chainEntries) { if (entry.getType() == DictionaryEntryType.VALUE && entry.getValue().equals(hashedTerm)) { valueFound = true; break; }  if (entry.getType() == DictionaryEntryType.INSERT) { entries.add(entry); } else if (entry.getType() == DictionaryEntryType.DELETE) { entriesToRemove.add(entry.getValue()); } }   if (!valueFound) { try { chainRetrieval.append(hashedTerm); } catch (Exception e) { throw new RuntimeException("unable to append entry to chain"); } }  if (!entriesToRemove.isEmpty()) { int totalEntries = entries.size();  for (int i = (totalEntries - 1); i >= 0; i--) { DictionaryEntry entry = entries.get(i); if (entry.getType() != DictionaryEntryType.INSERT) { continue; }  if (entriesToRemove.contains(entry.getValue())) { entries.remove(i); } } }  return entries;  }
[*] target: assertEquals(1, dictionaryEntries.size())
[-] pred: org. junit. Assert. assertEquals ( 1, dictionaryEntries. size ( ) )
************************************
************************************
[+] input: testReconstructsDictionaryWithValueInsertedWithDeleteTwoTerms() { String term = "foo"; String term2 = "foo2";  ChainRetrieval chainRetrieval = new ChainRetrieval() { @Override public List<DictionaryEntry> retrieveChain() { return Arrays.asList( new DictionaryEntry("A", DictionaryEntryType.INSERT), new DictionaryEntry("B", DictionaryEntryType.INSERT), new DictionaryEntry("B", DictionaryEntryType.DELETE), new DictionaryEntry(CausalOrderingConsistentMaskingProvider.privateHash(term), DictionaryEntryType.VALUE), new DictionaryEntry("C", DictionaryEntryType.INSERT), new DictionaryEntry("D", DictionaryEntryType.INSERT), new DictionaryEntry(CausalOrderingConsistentMaskingProvider.privateHash(term2), DictionaryEntryType.VALUE) ); }  @Override public void append(String hashedTerm) throws Exception {  }  @Override public void shutDown() {  } };  List<DictionaryEntry> dictionaryEntries = CausalOrderingConsistentMaskingProvider.reconstructDictionary(chainRetrieval, term);  assertEquals(1, dictionaryEntries.size()); assertEquals("A", dictionaryEntries.get(0).getValue());  dictionaryEntries = CausalOrderingConsistentMaskingProvider.reconstructDictionary(chainRetrieval, term2);  "<AssertPlaceHolder>"; assertEquals("A", dictionaryEntries.get(0).getValue()); assertEquals("C", dictionaryEntries.get(1).getValue()); assertEquals("D", dictionaryEntries.get(2).getValue()); }
reconstructDictionary(ChainRetrieval chainRetrieval, String term) { List<DictionaryEntry> entries = new ArrayList<>(); Set<String> entriesToRemove = new HashSet<>();  String hashedTerm = privateHash(term);  List<DictionaryEntry> chainEntries; try { chainEntries = chainRetrieval.retrieveChain(); } catch (IOException e) { throw new RuntimeException("unable to retrieve entries from chain"); }  boolean valueFound = false;  for (DictionaryEntry entry : chainEntries) { if (entry.getType() == DictionaryEntryType.VALUE && entry.getValue().equals(hashedTerm)) { valueFound = true; break; }  if (entry.getType() == DictionaryEntryType.INSERT) { entries.add(entry); } else if (entry.getType() == DictionaryEntryType.DELETE) { entriesToRemove.add(entry.getValue()); } }   if (!valueFound) { try { chainRetrieval.append(hashedTerm); } catch (Exception e) { throw new RuntimeException("unable to append entry to chain"); } }  if (!entriesToRemove.isEmpty()) { int totalEntries = entries.size();  for (int i = (totalEntries - 1); i >= 0; i--) { DictionaryEntry entry = entries.get(i); if (entry.getType() != DictionaryEntryType.INSERT) { continue; }  if (entriesToRemove.contains(entry.getValue())) { entries.remove(i); } } }  return entries;  }
[*] target: assertEquals(3, dictionaryEntries.size())
[-] pred: org. junit. Assert. assertEquals ( 3, dictionaryEntries. size ( ) )
************************************
************************************
[+] input: testFrequencyBasedThresholdNotExceeded() { List<IdentifiedType> identifiedTypeList = new ArrayList<>(); identifiedTypeList.add(new IdentifiedType("EMAIL", 10)); identifiedTypeList.add(new IdentifiedType("ADDRESS", 10));  Map<String, Integer> priorities = new HashMap<>(); priorities.put("EMAIL", 90); priorities.put("ADDRESS", 89);  IdentificationConfiguration identificationConfiguration = new IdentificationConfiguration(50, 90, false, IdentificationStrategy.FREQUENCY_BASED, priorities, Collections.emptyMap());  IdentifiedType bestType = IdentifierUtils.findBestType(identifiedTypeList, 15L, identificationConfiguration);  "<AssertPlaceHolder>"; assertThat(bestType.getCount(), is(-1L)); assertThat(bestType.getTypeName(), is("UNKNOWN")); }
findBestType(Collection<IdentifiedType> identifiedTypes, Long rowsProcessed, IdentificationConfiguration identificationConfiguration) { switch (identificationConfiguration.getIdentificationStrategy()) { case FREQUENCY_BASED: return findBestTypeFrequencyBased(identifiedTypes, rowsProcessed, identificationConfiguration); case PRIORITY_BASED: return findBestTypePriorityBased(identifiedTypes, rowsProcessed, identificationConfiguration); default: throw new RuntimeException("Not implemented yet"); }  }
[*] target: assertNotNull(bestType)
[-] pred: org. junit. Assert. assertNotNull ( bestType )
************************************
************************************
[+] input: testPriorityBasedDoesNotExceedFrequencyThreshold() { List<IdentifiedType> identifiedTypeList = new ArrayList<>(); identifiedTypeList.add(new IdentifiedType("EMAIL", 100)); identifiedTypeList.add(new IdentifiedType("ADDRESS", 100));  Map<String, Integer> priorities = new HashMap<>(); priorities.put("EMAIL", 90);  IdentificationConfiguration identificationConfiguration = new IdentificationConfiguration(50, 50, false, IdentificationStrategy.PRIORITY_BASED, priorities, Collections.emptyMap());  IdentifiedType bestType = IdentifierUtils.findBestType(identifiedTypeList, 1000L, identificationConfiguration);  "<AssertPlaceHolder>"; assertThat(bestType.getCount(), is(-1L)); assertThat(bestType.getTypeName(), is("UNKNOWN")); }
findBestType(Collection<IdentifiedType> identifiedTypes, Long rowsProcessed, IdentificationConfiguration identificationConfiguration) { switch (identificationConfiguration.getIdentificationStrategy()) { case FREQUENCY_BASED: return findBestTypeFrequencyBased(identifiedTypes, rowsProcessed, identificationConfiguration); case PRIORITY_BASED: return findBestTypePriorityBased(identifiedTypes, rowsProcessed, identificationConfiguration); default: throw new RuntimeException("Not implemented yet"); }  }
[*] target: assertNotNull(bestType)
[-] pred: org. junit. Assert. assertNotNull ( bestType )
************************************
************************************
[+] input: testFillCharacterMap() { int[] counters = new int[256]; Arrays.fill(counters, 0);  String input = "aabc@def.com";  int nA = IdentifierUtils.fillCharacterMap(input, counters);  "<AssertPlaceHolder>"; assertEquals(2, counters['a']); assertEquals(1, counters['b']); assertEquals(1, counters['@']); assertEquals(0, counters['w']); }
fillCharacterMap(String input, int[] counters) { int nonASCII = 0;  for (int i = 0; i < input.length(); i++) { char c = input.charAt(i); if (c > 256) { nonASCII++; continue; }  counters[c]++; }  return nonASCII; }
[*] target: assertEquals(0, nA)
[-] pred: org. junit. Assert. assertEquals ( 0, nA )
************************************
************************************
[+] input: Exception { String jsonS = "{"a": 2}"; JsonNode node = MAPPER.readTree(jsonS);  Map<String, List<JsonNode>> traverseMap = JsonUtils.traverseObject(node);   "<AssertPlaceHolder>"; assertEquals(1, traverseMap.get("/a").size()); }
traverseObject(JsonNode node) { return traverseObject(node, ""); }
[*] target: assertEquals(1, traverseMap.size())
[-] pred: org. junit. Assert. assertEquals ( 1, traverseMap. size ( ) )
************************************
************************************
[+] input: getResourcesUsIsEn() { Collection<ResourceEntry> resources = manager.getResources(Resource.COUNTRY, Collections.singleton("us"));  "<AssertPlaceHolder>"; assertThat(resources.size(), is(1));  for (ResourceEntry resourceEntry : resources) assertThat(resourceEntry.getCountryCode(), is("en")); }
getResources(Resource resource, Collection<String> countries) { logger.debug("Requesting {} for {}", resource, Arrays.toString(countries.toArray()));  final List<ResourceEntry> entries = new ArrayList<>(); final Set<String> countriesLoaded = new HashSet<>();  final Map<String, ResourceEntry> knownEntries = registeredResources.get(resource);  if (null == knownEntries) return entries;  switch (resource) { case IMSI: case ATC_CODES: case TACDB: case PUBLIC_SUFFIX_LIST: return Collections.singletonList(knownEntries.get(COMMON)); default: logger.warn("Unexpected value: {}", resource); }  for (String country : countries) { logger.debug("Retrieving country {}", country);  if (!knownEntries.containsKey(country)) { final String mapped = countryCommonMap.get(country);  if (mapped != null) { country = mapped; } else { continue; } }  if (countriesLoaded.contains(country)) { continue; } final ResourceEntry entry = knownEntries.get(country);  if (null == entry) { continue; } entries.add(entry); countriesLoaded.add(country); }  return entries; }
[*] target: assertNotNull(resources)
[-] pred: org. junit. Assert. assertNotNull ( resources )
************************************
************************************
[+] input: getResourcesUkIsEn() { Collection<ResourceEntry> resources = manager.getResources(Resource.COUNTRY, Collections.singleton("uk"));  "<AssertPlaceHolder>"; assertThat(resources.size(), is(1));  for (ResourceEntry resourceEntry : resources) assertThat(resourceEntry.getCountryCode(), is("en")); }
getResources(Resource resource, Collection<String> countries) { logger.debug("Requesting {} for {}", resource, Arrays.toString(countries.toArray()));  final List<ResourceEntry> entries = new ArrayList<>(); final Set<String> countriesLoaded = new HashSet<>();  final Map<String, ResourceEntry> knownEntries = registeredResources.get(resource);  if (null == knownEntries) return entries;  switch (resource) { case IMSI: case ATC_CODES: case TACDB: case PUBLIC_SUFFIX_LIST: return Collections.singletonList(knownEntries.get(COMMON)); default: logger.warn("Unexpected value: {}", resource); }  for (String country : countries) { logger.debug("Retrieving country {}", country);  if (!knownEntries.containsKey(country)) { final String mapped = countryCommonMap.get(country);  if (mapped != null) { country = mapped; } else { continue; } }  if (countriesLoaded.contains(country)) { continue; } final ResourceEntry entry = knownEntries.get(country);  if (null == entry) { continue; } entries.add(entry); countriesLoaded.add(country); }  return entries; }
[*] target: assertNotNull(resources)
[-] pred: org. junit. Assert. assertNotNull ( resources )
************************************
************************************
[+] input: MalformedURLException { URL baseURL = new URL("http://localhost:80/");  URL expectedURL = new URL("http://localhost:80/my/custom/url"); URL actualURL = URLBuilder.fromURL(baseURL).withPath("my").withPath("custom").withPath("url").build(); assertEquals(expectedURL, actualURL);  actualURL = URLBuilder.fromURL(baseURL).withPath("my", "custom", "url").build(); assertEquals(expectedURL, actualURL);  actualURL = URLBuilder.fromURL(baseURL).withPath("my").withPath("custom", "url").build(); assertEquals(expectedURL, actualURL);  baseURL = new URL("http://localhost:80/my/"); actualURL = URLBuilder.fromURL(baseURL).withPath("custom").withPath("url").build(); assertEquals(expectedURL, actualURL);  actualURL = URLBuilder.fromURL(baseURL).withPath("custom", "url").build(); "<AssertPlaceHolder>"; }
build() {  URL extendedURL = baseURL;  extendedURL = extendQuery(extendedURL, queries); extendedURL = extendPath(extendedURL, paths);  log.info("Built URL: " + extendedURL.toString());  return extendedURL; }
[*] target: assertEquals(expectedURL, actualURL)
[-] pred: org. junit. Assert. assertEquals ( expectedURL, actualURL )
************************************
************************************
[+] input: MalformedURLException { URL baseURL = new URL("http://localhost:80/myServlet/");  URL expectedURL = new URL("http://localhost:80/myServlet?myKey=myValue"); URL actualURL = URLBuilder.fromURL(baseURL).withQuery("myKey", "myValue").build(); assertEquals(expectedURL, actualURL);  expectedURL = new URL("http://localhost:80/myServlet?myKey=myValue&myKey2=myValue2"); actualURL = URLBuilder.fromURL(baseURL).withQuery("myKey", "myValue").withQuery("myKey2", "myValue2").build(); assertEquals(expectedURL, actualURL);  baseURL = new URL("http://localhost:80/myServlet?myKey=myValue"); actualURL = URLBuilder.fromURL(baseURL).withQuery("myKey2", "myValue2").build(); assertEquals(expectedURL, actualURL);  expectedURL = new URL("http://localhost:80/myServlet?myKey=myValue"); actualURL = URLBuilder.fromURL(baseURL).withQuery("myKey", "myValue").build(); "<AssertPlaceHolder>"; }
build() {  URL extendedURL = baseURL;  extendedURL = extendQuery(extendedURL, queries); extendedURL = extendPath(extendedURL, paths);  log.info("Built URL: " + extendedURL.toString());  return extendedURL; }
[*] target: assertEquals(expectedURL, actualURL)
[-] pred: org. junit. Assert. assertEquals ( expectedURL, actualURL )
************************************
************************************
[+] input: testSimpleValuePresent_null() { Result<String> value = Result.empty(); assertFalse(value.isValuePresent()); "<AssertPlaceHolder>"; }
isExceptionPresent() { return exception != null; }
[*] target: assertFalse(value.isExceptionPresent())
[-] pred: org. junit. Assert. assertFalse ( value. isExceptionPresent() )
************************************
************************************
[+] input: testExceptionIsPresent() { Result<String> value = Result.of(new IllegalArgumentException("12345")); "<AssertPlaceHolder>"; assertThrows(RuntimeException.class, value::get); }
isExceptionPresent() { return exception != null; }
[*] target: assertTrue(value.isExceptionPresent())
[-] pred: org. junit. Assert. assertTrue ( value. isExceptionPresent() )
************************************
************************************
[+] input: isExceptionPresent() { String test = "test"; Result<String> value = Result.of(test); assertFalse(value.isExceptionPresent());  value = Result.of(new RuntimeException()); "<AssertPlaceHolder>"; }
isExceptionPresent() { return exception != null; }
[*] target: assertTrue(value.isExceptionPresent())
[-] pred: org. junit. Assert. assertTrue ( value. isExceptionPresent() )
************************************
************************************
[+] input: InterruptedException { String key = "test:" + UuidUtils.uuid32(); RedisLock redisLock = factory.create(key, 5000); Assertions.assertTrue(redisLock.tryLock());  Thread.sleep(55); Long ttl1 = bean.getExpire("lock:" + key, TimeUnit.MILLISECONDS); System.out.println("ttl1: " + ttl1); Assertions.assertTrue(ttl1 > 4000 && ttl1 < 5000);  Thread.sleep(1000); Long ttl2 = bean.getExpire("lock:" + key, TimeUnit.MILLISECONDS); System.out.println("ttl2: " + ttl2); Assertions.assertTrue(ttl2 > 3000 && ttl2 < 4000);  Assertions.assertTrue(redisLock.tryLock()); Thread.sleep(50); Long ttl3 = bean.getExpire("lock:" + key, TimeUnit.MILLISECONDS); System.out.println("ttl3: " + ttl3); Assertions.assertTrue(ttl3 > 4000 && ttl3 < 5000);  Assertions.assertTrue(redisLock.isLocked()); Assertions.assertTrue(redisLock.isHeldByCurrentThread());  Thread thread = new Thread(() -> { Assertions.assertTrue(redisLock.isLocked()); Assertions.assertFalse(redisLock.isHeldByCurrentThread()); System.out.println("child thread done."); }); thread.start(); thread.join();  Assertions.assertTrue(redisLock.isLocked()); redisLock.unlock();  Assertions.assertTrue(redisLock.isLocked()); redisLock.unlock();  Assertions.assertFalse(redisLock.isLocked()); Assertions.assertFalse(redisLock.isHeldByCurrentThread()); Assertions."<AssertPlaceHolder>"; }
tryLock() { return acquire(); }
[*] target: assertTrue(redisLock.tryLock())
[-] pred: org. junit. Assert. assertTrue ( redisLock. tryLock ( ) )
************************************
************************************
[+] input: JobException { String taskParam = "taskParam"; when(workerRpcService.splitJob(any())).thenReturn(new SplitJobResult(Collections.singletonList(taskParam)));  SplitJobResult result = workerRpcService.splitJob(new SplitJobParam("group", null, null, null, null)); "<AssertPlaceHolder>"; assertNotNull(result.getTaskParams()); assertEquals(1, result.getTaskParams().size()); assertEquals(taskParam, result.getTaskParams().get(0)); }
splitJob(SplitJobParam param) throws JobException;
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testRemoveFirst() { deque.addLast(1); deque.addLast(2); deque.addLast(3);  assertEquals(Integer.valueOf(1), deque.removeFirst()); assertEquals(Integer.valueOf(2), deque.removeFirst()); assertEquals(Integer.valueOf(3), deque.removeFirst());  "<AssertPlaceHolder>"; }
removeFirst() { if (size == 0) { return null; }  T element = (T) elements[readIndex]; elements[readIndex] = null; readIndex = (readIndex + 1) & mask; size--; return element; }
[*] target: assertNull(deque.removeFirst())
[-] pred: org. junit. Assert. assertNull ( deque. removeFirst() )
************************************
************************************
[+] input: testRemoveLast() { deque.addLast(1); deque.addLast(2); assertEquals(Integer.valueOf(2), deque.removeLast()); assertEquals(Integer.valueOf(1), deque.get(0)); assertEquals(Integer.valueOf(1), deque.removeLast()); assertNull(deque.removeLast()); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(0, deque.size())
[-] pred: org. junit. Assert. assertEquals ( 0, deque. size() )
************************************
************************************
[+] input: testRemoveLast2() { deque.addFirst(1); deque.addFirst(2); assertEquals(Integer.valueOf(1), deque.removeLast()); assertEquals(Integer.valueOf(2), deque.get(0)); assertEquals(Integer.valueOf(2), deque.removeLast()); deque.removeLast(); assertNull(deque.removeLast()); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(0, deque.size())
[-] pred: org. junit. Assert. assertEquals ( 0, deque. size() )
************************************
************************************
[+] input: testForEach() { int[] keys = new int[]{1, 17, 33, 2, 18, 3};  IntObjMap<String> m = setupForEach(keys); int size = m.size(); m.forEach((k, v) -> false); assertEquals(0, m.size());  for (int key : keys) { m = setupForEach(keys); // remove the key from map though forEach m.forEach((k, v) -> k != key); assertEquals(size - 1, m.size()); assertNull(m.get(key)); for (int k : keys) { if (k != key) { assertEquals(String.valueOf(k), m.get(k)); } }  // re-put m.put(key, String.valueOf(key)); for (int k : keys) { assertEquals(String.valueOf(k), m.get(k)); } "<AssertPlaceHolder>"; } }
size() { return size; }
[*] target: assertEquals(size, m.size())
[-] pred: org. junit. Assert. assertEquals ( size, m. size() )
************************************
************************************
[+] input: testForEach() { long[] keys = new long[]{1, 17, 33, 2, 18, 3};  LongObjMap<String> m = setupForEach(keys); int size = m.size(); m.forEach((k, v) -> false); assertEquals(0, m.size());  for (long key : keys) { m = setupForEach(keys); // remove the key from map though forEach m.forEach((k, v) -> k != key); assertEquals(size - 1, m.size()); assertNull(m.get(key)); for (long k : keys) { if (k != key) { assertEquals(String.valueOf(k), m.get(k)); } }  // re-put m.put(key, String.valueOf(key)); for (long k : keys) { assertEquals(String.valueOf(k), m.get(k)); } "<AssertPlaceHolder>"; } }
size() { return size; }
[*] target: assertEquals(size, m.size())
[-] pred: org. junit. Assert. assertEquals ( size, m. size() )
************************************
************************************
[+] input: testRemove() { future.addWaiter(f1); future.addWaiter(f2); future.addWaiter(f3); future.addWaiter(f4); future.removeWaiter(f2);//mid future.removeWaiter(f1);//head future.removeWaiter(f4);//tail future.removeWaiter(f3);//last one Assertions.assertNull(future.popHeadWaiter()); Assertions."<AssertPlaceHolder>"; }
popTailWaiter() { Fiber result = lastWaiter; if (result != null) { if (result == firstWaiter) { firstWaiter = null; lastWaiter = null; } else { lastWaiter = result.previousWaiter; lastWaiter.nextWaiter = null; result.previousWaiter = null; } } return result; }
[*] target: assertNull(future.popTailWaiter())
[-] pred: org. junit. Assert. assertNull ( future. popTailWaiter() )
************************************
************************************
[+] input: testSize() { map.put(0, 100); map.put(1, 200); map.put(2, 300);  assertEquals(3, map.size()); map.remove(); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(2, map.size())
[-] pred: org. junit. Assert. assertEquals ( 2, map. size() )
************************************
************************************
[+] input: getApiKeyRequestUrl_whenRetrieved_thenReturnsUrl() { String loginUrl = this.sut.getApiKeyRequestUrl(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("https://cloud.dqops.com/requestapikey/", loginUrl); }
getApiKeyRequestUrl() { return apiKeyRequestUrl; }
[*] target: assertNotNull(loginUrl)
[-] pred: org. junit. Assert. assertNotNull ( loginUrl )
************************************
************************************
[+] input: prepareText_fromMessageParametersOfOpenedIncident_generatesValidMessage() { ((DefaultTimeZoneProviderStub)defaultTimeZoneProvider).setTimeZone(ZoneId.of("+02:00"));  Instant instant = LocalDateTime .of(2023, 9, 1, 12, 30, 20) .toInstant(ZoneOffset.UTC);  IncidentNotificationMessage notificationMessage = SampleIncidentMessages.createSampleIncidentMessage(instant, IncidentStatus.open);  String message = sut.prepareText(notificationMessage);  "<AssertPlaceHolder>"; assertEquals(""" > New incident detected in <http://localhost:8888/sources/connection/connection_name/schema/schema_here/table/table_name_here/detail | schema_here.table_name_here> table. > \s > First seen: 2023-09-01 14:30:20 (GMT+2)\s > Quality dimension: Reasonableness\s > Check category: volume\s > Highest severity: fatal\s > Total data quality issues: 10\s > Table priority: 2\s > \s > <http://localhost:8888/incidents/connection_name/2023/9/1 | View in DQOps>\s """.replaceAll("\\s+", ""), message.replaceAll("\\s+", "") ); }
prepareText(IncidentNotificationMessage notificationMessage){  String fullTableNameWithLink = formatToLink( prepareUrlToTable(notificationMessage), notificationMessage.getSchema() + "." + notificationMessage.getTable() );  StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(getBlockQuotedLine(prepareHeader(notificationMessage.getStatus(), fullTableNameWithLink ))); stringBuilder.append(getBlockQuotedLine(""));  stringBuilder.append(extractInstantWithFormatting(notificationMessage.getFirstSeen(), IncidentsColumnNames.FIRST_SEEN_COLUMN_NAME)); if(!notificationMessage.getStatus().equals(IncidentStatus.open)){ stringBuilder.append(extractInstantWithFormatting(notificationMessage.getLastSeen(), IncidentsColumnNames.LAST_SEEN_COLUMN_NAME)); } stringBuilder.append(extractStringWithFormatting(notificationMessage.getQualityDimension(), IncidentsColumnNames.QUALITY_DIMENSION_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckCategory(), IncidentsColumnNames.CHECK_CATEGORY_COLUMN_NAME)); stringBuilder.append(String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), readableColumnName(IncidentsColumnNames.HIGHEST_SEVERITY_COLUMN_NAME), RuleSeverityLevel.fromSeverityLevel(notificationMessage.getHighestSeverity()).name())); stringBuilder.append( String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), "Total data quality issues", notificationMessage.getFailedChecksCount())); stringBuilder.append(extractIntWithFormatting(notificationMessage.getTablePriority(), IncidentsColumnNames.TABLE_PRIORITY_COLUMN_NAME));  if (notificationMessage.getIssueUrl() != null && !notificationMessage.getIssueUrl().isEmpty()) { stringBuilder.append( String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), readableColumnName(IncidentsColumnNames.ISSUE_URL_COLUMN_NAME), formatToLink(notificationMessage.getIssueUrl(), "LINK"))); }  stringBuilder.append(extractStringWithFormatting(notificationMessage.getDataGroupName(), IncidentsColumnNames.DATA_GROUP_NAME_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckType(), IncidentsColumnNames.CHECK_TYPE_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckName(), IncidentsColumnNames.CHECK_NAME_COLUMN_NAME));  if (notificationMessage.getMessage() != null) { stringBuilder.append(extractStringWithFormatting(notificationMessage.getMessage(), "Message")); }  stringBuilder.append(getBlockQuotedLine(""));  stringBuilder.append(getBlockQuotedLine(formatToLink( prepareUrlToIncident(notificationMessage), "View in DQOps" )));  return stringBuilder.toString(); }
[*] target: assertNotNull(message)
[-] pred: org. junit. Assert. assertNotNull ( message )
************************************
************************************
[+] input: prepareText_fromMessageParametersOfAcknowledgedIncident_generatesValidMessage() { ((DefaultTimeZoneProviderStub)defaultTimeZoneProvider).setTimeZone(ZoneId.of("+02:00"));  Instant instant = LocalDateTime .of(2023, 9, 1, 12, 30, 20) .toInstant(ZoneOffset.UTC);  IncidentNotificationMessage notificationMessage = SampleIncidentMessages.createSampleIncidentMessage(instant, IncidentStatus.acknowledged);  String message = sut.prepareText(notificationMessage);  "<AssertPlaceHolder>"; assertEquals(""" > The incident in <http://localhost:8888/sources/connection/connection_name/schema/schema_here/table/table_name_here/detail | schema_here.table_name_here> table has been acknowledged.\s > \s > First seen: 2023-09-01 14:30:20 (GMT+2)\s > Last seen: 2023-09-01 14:30:20 (GMT+2)\s > Quality dimension: Reasonableness\s > Check category: volume\s > Highest severity: fatal\s > Total data quality issues: 10\s > Table priority: 2\s > \s > <http://localhost:8888/incidents/connection_name/2023/9/1 | View in DQOps>\s """.replaceAll("\\s+", ""), message.replaceAll("\\s+", "") ); }
prepareText(IncidentNotificationMessage notificationMessage){  String fullTableNameWithLink = formatToLink( prepareUrlToTable(notificationMessage), notificationMessage.getSchema() + "." + notificationMessage.getTable() );  StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(getBlockQuotedLine(prepareHeader(notificationMessage.getStatus(), fullTableNameWithLink ))); stringBuilder.append(getBlockQuotedLine(""));  stringBuilder.append(extractInstantWithFormatting(notificationMessage.getFirstSeen(), IncidentsColumnNames.FIRST_SEEN_COLUMN_NAME)); if(!notificationMessage.getStatus().equals(IncidentStatus.open)){ stringBuilder.append(extractInstantWithFormatting(notificationMessage.getLastSeen(), IncidentsColumnNames.LAST_SEEN_COLUMN_NAME)); } stringBuilder.append(extractStringWithFormatting(notificationMessage.getQualityDimension(), IncidentsColumnNames.QUALITY_DIMENSION_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckCategory(), IncidentsColumnNames.CHECK_CATEGORY_COLUMN_NAME)); stringBuilder.append(String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), readableColumnName(IncidentsColumnNames.HIGHEST_SEVERITY_COLUMN_NAME), RuleSeverityLevel.fromSeverityLevel(notificationMessage.getHighestSeverity()).name())); stringBuilder.append( String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), "Total data quality issues", notificationMessage.getFailedChecksCount())); stringBuilder.append(extractIntWithFormatting(notificationMessage.getTablePriority(), IncidentsColumnNames.TABLE_PRIORITY_COLUMN_NAME));  if (notificationMessage.getIssueUrl() != null && !notificationMessage.getIssueUrl().isEmpty()) { stringBuilder.append( String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), readableColumnName(IncidentsColumnNames.ISSUE_URL_COLUMN_NAME), formatToLink(notificationMessage.getIssueUrl(), "LINK"))); }  stringBuilder.append(extractStringWithFormatting(notificationMessage.getDataGroupName(), IncidentsColumnNames.DATA_GROUP_NAME_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckType(), IncidentsColumnNames.CHECK_TYPE_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckName(), IncidentsColumnNames.CHECK_NAME_COLUMN_NAME));  if (notificationMessage.getMessage() != null) { stringBuilder.append(extractStringWithFormatting(notificationMessage.getMessage(), "Message")); }  stringBuilder.append(getBlockQuotedLine(""));  stringBuilder.append(getBlockQuotedLine(formatToLink( prepareUrlToIncident(notificationMessage), "View in DQOps" )));  return stringBuilder.toString(); }
[*] target: assertNotNull(message)
[-] pred: org. junit. Assert. assertNotNull ( message )
************************************
************************************
[+] input: prepareText_fromMessageParametersWithIssueUrl_generatesValidMessage() { ((DefaultTimeZoneProviderStub)defaultTimeZoneProvider).setTimeZone(ZoneId.of("+02:00"));  Instant instant = LocalDateTime .of(2023, 9, 1, 12, 30, 20) .toInstant(ZoneOffset.UTC);  IncidentNotificationMessage notificationMessage = SampleIncidentMessages.createSampleIncidentMessage(instant, IncidentStatus.acknowledged); notificationMessage.setIssueUrl("https://www.google.com");  String message = sut.prepareText(notificationMessage);  "<AssertPlaceHolder>"; assertEquals(""" > The incident in <http://localhost:8888/sources/connection/connection_name/schema/schema_here/table/table_name_here/detail | schema_here.table_name_here> table has been acknowledged.\s > \s > First seen: 2023-09-01 14:30:20 (GMT+2)\s > Last seen: 2023-09-01 14:30:20 (GMT+2)\s > Quality dimension: Reasonableness\s > Check category: volume\s > Highest severity: fatal\s > Total data quality issues: 10\s > Table priority: 2\s > Issue url: <https://www.google.com | LINK>\s > \s > <http://localhost:8888/incidents/connection_name/2023/9/1 | View in DQOps>\s """.replaceAll("\\s+", ""), message.replaceAll("\\s+", "") ); }
prepareText(IncidentNotificationMessage notificationMessage){  String fullTableNameWithLink = formatToLink( prepareUrlToTable(notificationMessage), notificationMessage.getSchema() + "." + notificationMessage.getTable() );  StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(getBlockQuotedLine(prepareHeader(notificationMessage.getStatus(), fullTableNameWithLink ))); stringBuilder.append(getBlockQuotedLine(""));  stringBuilder.append(extractInstantWithFormatting(notificationMessage.getFirstSeen(), IncidentsColumnNames.FIRST_SEEN_COLUMN_NAME)); if(!notificationMessage.getStatus().equals(IncidentStatus.open)){ stringBuilder.append(extractInstantWithFormatting(notificationMessage.getLastSeen(), IncidentsColumnNames.LAST_SEEN_COLUMN_NAME)); } stringBuilder.append(extractStringWithFormatting(notificationMessage.getQualityDimension(), IncidentsColumnNames.QUALITY_DIMENSION_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckCategory(), IncidentsColumnNames.CHECK_CATEGORY_COLUMN_NAME)); stringBuilder.append(String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), readableColumnName(IncidentsColumnNames.HIGHEST_SEVERITY_COLUMN_NAME), RuleSeverityLevel.fromSeverityLevel(notificationMessage.getHighestSeverity()).name())); stringBuilder.append( String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), "Total data quality issues", notificationMessage.getFailedChecksCount())); stringBuilder.append(extractIntWithFormatting(notificationMessage.getTablePriority(), IncidentsColumnNames.TABLE_PRIORITY_COLUMN_NAME));  if (notificationMessage.getIssueUrl() != null && !notificationMessage.getIssueUrl().isEmpty()) { stringBuilder.append( String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), readableColumnName(IncidentsColumnNames.ISSUE_URL_COLUMN_NAME), formatToLink(notificationMessage.getIssueUrl(), "LINK"))); }  stringBuilder.append(extractStringWithFormatting(notificationMessage.getDataGroupName(), IncidentsColumnNames.DATA_GROUP_NAME_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckType(), IncidentsColumnNames.CHECK_TYPE_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckName(), IncidentsColumnNames.CHECK_NAME_COLUMN_NAME));  if (notificationMessage.getMessage() != null) { stringBuilder.append(extractStringWithFormatting(notificationMessage.getMessage(), "Message")); }  stringBuilder.append(getBlockQuotedLine(""));  stringBuilder.append(getBlockQuotedLine(formatToLink( prepareUrlToIncident(notificationMessage), "View in DQOps" )));  return stringBuilder.toString(); }
[*] target: assertNotNull(message)
[-] pred: org. junit. Assert. assertNotNull ( message )
************************************
************************************
[+] input: prepareText_forTimeZoneWithNegativeOffset_generatesValidMessage() { ((DefaultTimeZoneProviderStub)defaultTimeZoneProvider).setTimeZone(ZoneId.of("-08:00"));  Instant instant = LocalDateTime .of(2023, 9, 1, 12, 30, 20) .toInstant(ZoneOffset.UTC);  IncidentNotificationMessage notificationMessage = SampleIncidentMessages.createSampleIncidentMessage(instant, IncidentStatus.open);  String message = sut.prepareText(notificationMessage);  "<AssertPlaceHolder>"; assertEquals(""" > New incident detected in <http://localhost:8888/sources/connection/connection_name/schema/schema_here/table/table_name_here/detail | schema_here.table_name_here> table. > \s > First seen: 2023-09-01 04:30:20 (GMT-8)\s > Quality dimension: Reasonableness\s > Check category: volume\s > Highest severity: fatal\s > Total data quality issues: 10\s > Table priority: 2\s > \s > <http://localhost:8888/incidents/connection_name/2023/9/1 | View in DQOps>\s """.replaceAll("\\s+", ""), message.replaceAll("\\s+", "") ); }
prepareText(IncidentNotificationMessage notificationMessage){  String fullTableNameWithLink = formatToLink( prepareUrlToTable(notificationMessage), notificationMessage.getSchema() + "." + notificationMessage.getTable() );  StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(getBlockQuotedLine(prepareHeader(notificationMessage.getStatus(), fullTableNameWithLink ))); stringBuilder.append(getBlockQuotedLine(""));  stringBuilder.append(extractInstantWithFormatting(notificationMessage.getFirstSeen(), IncidentsColumnNames.FIRST_SEEN_COLUMN_NAME)); if(!notificationMessage.getStatus().equals(IncidentStatus.open)){ stringBuilder.append(extractInstantWithFormatting(notificationMessage.getLastSeen(), IncidentsColumnNames.LAST_SEEN_COLUMN_NAME)); } stringBuilder.append(extractStringWithFormatting(notificationMessage.getQualityDimension(), IncidentsColumnNames.QUALITY_DIMENSION_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckCategory(), IncidentsColumnNames.CHECK_CATEGORY_COLUMN_NAME)); stringBuilder.append(String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), readableColumnName(IncidentsColumnNames.HIGHEST_SEVERITY_COLUMN_NAME), RuleSeverityLevel.fromSeverityLevel(notificationMessage.getHighestSeverity()).name())); stringBuilder.append( String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), "Total data quality issues", notificationMessage.getFailedChecksCount())); stringBuilder.append(extractIntWithFormatting(notificationMessage.getTablePriority(), IncidentsColumnNames.TABLE_PRIORITY_COLUMN_NAME));  if (notificationMessage.getIssueUrl() != null && !notificationMessage.getIssueUrl().isEmpty()) { stringBuilder.append( String.format(getBlockQuotedLine(KEY_VALUE_FORMAT), readableColumnName(IncidentsColumnNames.ISSUE_URL_COLUMN_NAME), formatToLink(notificationMessage.getIssueUrl(), "LINK"))); }  stringBuilder.append(extractStringWithFormatting(notificationMessage.getDataGroupName(), IncidentsColumnNames.DATA_GROUP_NAME_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckType(), IncidentsColumnNames.CHECK_TYPE_COLUMN_NAME)); stringBuilder.append(extractStringWithFormatting(notificationMessage.getCheckName(), IncidentsColumnNames.CHECK_NAME_COLUMN_NAME));  if (notificationMessage.getMessage() != null) { stringBuilder.append(extractStringWithFormatting(notificationMessage.getMessage(), "Message")); }  stringBuilder.append(getBlockQuotedLine(""));  stringBuilder.append(getBlockQuotedLine(formatToLink( prepareUrlToIncident(notificationMessage), "View in DQOps" )));  return stringBuilder.toString(); }
[*] target: assertNotNull(message)
[-] pred: org. junit. Assert. assertNotNull ( message )
************************************
************************************
[+] input: deleteSelectedErrorSamplesFragment_whenFilterCapturesSpanOfTwoPartitions_thenDeleteCapturedRows() { String connectionName = "connection"; String tableName = "tab"; String id_prefix1 = "1"; String id_prefix2 = "2"; PhysicalTableName physicalTableName = new PhysicalTableName("sch", tableName); UserDomainIdentity userIdentity = UserDomainIdentityObjectMother.createAdminIdentity();  LocalDate month1 = LocalDate.of(2023, 1, 1); LocalDate month2 = LocalDate.of(2023, 2, 1); LocalDateTime startDate1 = month1.atStartOfDay().plusDays(14); LocalDateTime startDate2 = month2.atStartOfDay().plusDays(14);  Table table1 = prepareSimplePartitionTable(tableName, startDate1, id_prefix1); Table table2 = prepareSimplePartitionTable(tableName, startDate2, id_prefix2);  ParquetPartitionId partitionId1 = new ParquetPartitionId( userIdentity.getDataDomainFolder(), this.errorSamplesStorageSettings.getTableType(), connectionName, physicalTableName, month1); ParquetPartitionId partitionId2 = new ParquetPartitionId( userIdentity.getDataDomainFolder(), this.errorSamplesStorageSettings.getTableType(), connectionName, physicalTableName, month2);  this.parquetPartitionStorageService.savePartition( new LoadedMonthlyPartition(partitionId1), new TableDataChanges(table1), this.errorSamplesStorageSettings, userIdentity); this.parquetPartitionStorageService.savePartition( new LoadedMonthlyPartition(partitionId2), new TableDataChanges(table2), this.errorSamplesStorageSettings, userIdentity);  ErrorsSamplesFragmentFilter filter = new ErrorsSamplesFragmentFilter(){{ setTableSearchFilters(new TableSearchFilters(){{ setConnection(connectionName); setFullTableName(physicalTableName.toTableSearchFilter()); }}); setDateStart(startDate1.toLocalDate()); setDateEnd(startDate2.toLocalDate()); }};  this.sut.deleteSelectedErrorSamplesFragment(filter, userIdentity);  LoadedMonthlyPartition partition1AfterDelete = this.parquetPartitionStorageService.loadPartition( partitionId1, this.errorSamplesStorageSettings, null, userIdentity); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(0L, partition1AfterDelete.getLastModified());  LoadedMonthlyPartition partition2AfterDelete = this.parquetPartitionStorageService.loadPartition( partitionId2, this.errorSamplesStorageSettings, null, userIdentity); Assertions.assertNotNull(partition2AfterDelete.getData()); Assertions.assertFalse(partition2AfterDelete.getData().textColumn(ErrorSamplesColumnNames.ID_COLUMN_NAME).contains(id_prefix2 + "id1")); Assertions.assertTrue(partition2AfterDelete.getData().textColumn(ErrorSamplesColumnNames.ID_COLUMN_NAME).contains(id_prefix2 + "id2")); Assertions.assertTrue(partition2AfterDelete.getData().textColumn(ErrorSamplesColumnNames.ID_COLUMN_NAME).contains(id_prefix2 + "id3")); Assertions.assertNotEquals(0L, partition2AfterDelete.getLastModified()); }
deleteSelectedErrorSamplesFragment( ErrorsSamplesFragmentFilter filter, UserDomainIdentity userIdentity) { Map<String, String> simpleConditions = filter.getColumnConditions(); Map<String, Set<String>> conditions = new LinkedHashMap<>(); for (Map.Entry<String, String> kv: simpleConditions.entrySet()) { String columnName = kv.getKey(); String columnValue = kv.getValue(); Set<String> wrappedValue = new LinkedHashSet<>(){{add(columnValue);}}; conditions.put(columnName, wrappedValue); }  if (filter.getColumnNames() != null && !filter.getColumnNames().isEmpty()) { conditions.put(ErrorSamplesColumnNames.COLUMN_NAME_COLUMN_NAME, new LinkedHashSet<>(filter.getColumnNames())); }  DeleteStoredDataResult deleteStoredDataResult = new DeleteStoredDataResult();  FileStorageSettings fileStorageSettings = ErrorSamplesSnapshot.createErrorSamplesStorageSettings(); List<String> connections = this.parquetPartitionMetadataService.listConnections(fileStorageSettings, userIdentity); if (connections == null) { // No connections present. return deleteStoredDataResult; }  List<String> filteredConnections = connections.stream() .filter(filter.getTableSearchFilters().getConnectionNameSearchPattern()::match) .collect(Collectors.toList());  for (String connectionName: filteredConnections) { List<PhysicalTableName> tables = this.parquetPartitionMetadataService.listTablesForConnection( connectionName, fileStorageSettings, userIdentity);  if (tables == null) { // No tables present for this connection. continue; }  Collection<ErrorSamplesSnapshot> errorSamplesSnapshots = tables.stream() .filter(schemaTableName -> { SearchPattern schemaNameSearchPattern = filter.getTableSearchFilters().getSchemaNameSearchPattern(); SearchPattern tableNameSearchPattern = filter.getTableSearchFilters().getTableNameSearchPattern();  return (schemaNameSearchPattern == null || schemaNameSearchPattern.match(schemaTableName.getSchemaName())) && (tableNameSearchPattern == null || tableNameSearchPattern.match(schemaTableName.getTableName())); }) .map(tableName -> this.errorSamplesSnapshotFactory.createSnapshot( filter.getTableSearchFilters().getConnection(), tableName, userIdentity )) .collect(Collectors.toList());  for (ErrorSamplesSnapshot currentSnapshot: errorSamplesSnapshots) { LocalDate startDeletionRange = filter.getDateStart(); LocalDate endDeletionRange = filter.getDateEnd();  currentSnapshot.markSelectedForDeletion(startDeletionRange, endDeletionRange, conditions);  if (currentSnapshot.getLoadedMonthlyPartitions() == null) { continue; }  DeleteStoredDataResult snapshotDeleteStoredDataResult = currentSnapshot.getDeleteResults(); deleteStoredDataResult.concat(snapshotDeleteStoredDataResult);  currentSnapshot.save(); } }  return deleteStoredDataResult; }
[*] target: assertNull(partition1AfterDelete.getData())
[-] pred: org. junit. Assert. assertNull ( partition1AfterDelete. getData ( ) )
************************************
************************************
[+] input: deleteSelectedIncidentsFragment_whenFilterCapturesSpanOfTwoPartitions_thenDeleteCapturedRows() { String connectionName = "connection"; String schemaName = "sch"; String tableName = "tab"; String id_prefix1 = "1"; String id_prefix2 = "2"; PhysicalTableName physicalTableName = new PhysicalTableName("sch", tableName); UserDomainIdentity userIdentity = UserDomainIdentityObjectMother.createAdminIdentity();  LocalDate month1 = LocalDate.of(2023, 1, 1); LocalDate month2 = LocalDate.of(2023, 2, 1); LocalDateTime startDate1 = month1.atStartOfDay().plusDays(14); LocalDateTime startDate2 = month2.atStartOfDay().plusDays(14);  Table table1 = prepareSimplePartitionTable(schemaName, tableName, startDate1, id_prefix1); Table table2 = prepareSimplePartitionTable(schemaName, tableName, startDate2, id_prefix2);  ParquetPartitionId partitionId1 = new ParquetPartitionId( userIdentity.getDataDomainFolder(), this.incidentsStorageSettings.getTableType(), connectionName, null, month1); ParquetPartitionId partitionId2 = new ParquetPartitionId( userIdentity.getDataDomainFolder(), this.incidentsStorageSettings.getTableType(), connectionName, null, month2);  this.parquetPartitionStorageService.savePartition( new LoadedMonthlyPartition(partitionId1), new TableDataChanges(table1), this.incidentsStorageSettings, userIdentity); this.parquetPartitionStorageService.savePartition( new LoadedMonthlyPartition(partitionId2), new TableDataChanges(table2), this.incidentsStorageSettings, userIdentity);  IncidentsFragmentFilter filter = new IncidentsFragmentFilter(){{ setTableSearchFilters(new TableSearchFilters(){{ setConnection(connectionName); setFullTableName(physicalTableName.toTableSearchFilter()); }}); setDateStart(startDate1.toLocalDate()); setDateEnd(startDate2.toLocalDate()); }};  this.sut.deleteSelectedIncidentsFragment(filter, userIdentity);  LoadedMonthlyPartition partition1AfterDelete = this.parquetPartitionStorageService.loadPartition( partitionId1, this.incidentsStorageSettings, null, userIdentity); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(0L, partition1AfterDelete.getLastModified());  LoadedMonthlyPartition partition2AfterDelete = this.parquetPartitionStorageService.loadPartition( partitionId2, this.incidentsStorageSettings, null, userIdentity); Assertions.assertNotNull(partition2AfterDelete.getData()); Assertions.assertFalse(partition2AfterDelete.getData().textColumn(IncidentsColumnNames.ID_COLUMN_NAME).contains(id_prefix2 + "id1")); Assertions.assertTrue(partition2AfterDelete.getData().textColumn(IncidentsColumnNames.ID_COLUMN_NAME).contains(id_prefix2 + "id2")); Assertions.assertTrue(partition2AfterDelete.getData().textColumn(IncidentsColumnNames.ID_COLUMN_NAME).contains(id_prefix2 + "id3")); Assertions.assertNotEquals(0L, partition2AfterDelete.getLastModified()); }
deleteSelectedIncidentsFragment(IncidentsFragmentFilter filter, UserDomainIdentity userIdentity) { Map<String, String> simpleConditions = filter.getColumnConditions(); Map<String, Set<String>> conditions = new LinkedHashMap<>(); for (Map.Entry<String, String> kv: simpleConditions.entrySet()) { String columnName = kv.getKey(); String columnValue = kv.getValue(); Set<String> wrappedValue = new LinkedHashSet<>(){{add(columnValue);}}; conditions.put(columnName, wrappedValue); }  String fullTableName = filter.getTableSearchFilters().getFullTableName(); if(fullTableName != null && fullTableName.contains(".")){ String[] split = fullTableName.split("\\."); String schemaName = split[0]; String tableName = split[1];  conditions.put(IncidentsColumnNames.SCHEMA_NAME_COLUMN_NAME, new LinkedHashSet<>(Set.of(schemaName))); conditions.put(IncidentsColumnNames.TABLE_NAME_COLUMN_NAME, new LinkedHashSet<>(Set.of(tableName))); }   DeleteStoredDataResult deleteStoredDataResult = new DeleteStoredDataResult();  FileStorageSettings fileStorageSettings = IncidentsSnapshot.createIncidentsStorageSettings(); List<String> connections = this.parquetPartitionMetadataService.listConnections(fileStorageSettings, userIdentity); if (connections == null) { // No connections present. return deleteStoredDataResult; }  List<String> filteredConnections = connections.stream() .filter(filter.getTableSearchFilters().getConnectionNameSearchPattern()::match) .collect(Collectors.toList());  for (String connectionName: filteredConnections) { IncidentsSnapshot currentSnapshot = this.incidentsSnapshotFactory.createSnapshot(connectionName, userIdentity);  LocalDate startDeletionRange = filter.getDateStart(); LocalDate endDeletionRange = filter.getDateEnd();  currentSnapshot.markSelectedForDeletion(startDeletionRange, endDeletionRange, conditions);  if (currentSnapshot.getLoadedMonthlyPartitions() == null) { continue; }  DeleteStoredDataResult snapshotDeleteStoredDataResult = currentSnapshot.getDeleteResults(); deleteStoredDataResult.concat(snapshotDeleteStoredDataResult);  currentSnapshot.save(); }  return deleteStoredDataResult; }
[*] target: assertNull(partition1AfterDelete.getData())
[-] pred: org. junit. Assert. assertNull ( partition1AfterDelete. getData ( ) )
************************************
************************************
[+] input: resolveFileFormat_whenAvailableOnTableAndParameters_retunsFormTable() {  TableSpec tableSpec = new TableSpec(new PhysicalTableName("schema_name_example", "table_name_example")); tableSpec.setFileFormat(FileFormatSpecObjectMother.createForCsvFile(SampleCsvFileNames.continuous_days_one_row_per_day));  DuckdbParametersSpec duckdbParametersSpec = DuckdbConnectionSpecObjectMother.createForFiles(DuckdbFilesFormatType.csv).getDuckdb(); duckdbParametersSpec.setCsv(new CsvFileFormatSpec(){{ setAutoDetect(false); }});  FileFormatSpec fileFormatSpec = FileFormatSpecProvider.resolveFileFormat(duckdbParametersSpec, tableSpec);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(1, fileFormatSpec.getFilePaths().size()); Assertions.assertTrue(fileFormatSpec.getCsv().getAutoDetect()); }
resolveFileFormat(DuckdbParametersSpec duckdbParametersSpec, TableSpec tableSpec) { DuckdbFilesFormatType filesType = duckdbParametersSpec.getFilesFormatType(); if (filesType == null) { throw new RuntimeException("The files format is unknown. Please set files format on the connection."); }  FileFormatSpec fileFormat = tableSpec.getFileFormat() == null ? new FileFormatSpec() : tableSpec.getFileFormat().deepClone(); if(fileFormat.getFilePaths().isEmpty()){ FilePathListSpec filePathListSpec = guessFilePaths(duckdbParametersSpec, tableSpec); fileFormat.setFilePaths(filePathListSpec); }  if (fileFormat.isFormatSetForType(filesType)) { return fileFormat; }  FileFormatSpec fileFormatCloned = fileFormat.deepClone(); if (duckdbParametersSpec.isFormatSetForType()) { switch (filesType) { case csv: fileFormatCloned.setCsv(duckdbParametersSpec.getCsv().deepClone()); break; case json: fileFormatCloned.setJson(duckdbParametersSpec.getJson().deepClone()); break; case parquet: fileFormatCloned.setParquet(duckdbParametersSpec.getParquet().deepClone()); break; case iceberg: fileFormatCloned.setIceberg(duckdbParametersSpec.getIceberg().deepClone()); break; } return fileFormatCloned; }  fillDefaultFileFormat(fileFormatCloned, filesType); return fileFormatCloned; }
[*] target: assertNotNull(fileFormatSpec)
[-] pred: org. junit. Assert. assertNotNull ( fileFormatSpec )
************************************
************************************
[+] input: resolveFileFormat_whenNotSetOnTable_guessesFormConnectionParameters() { String schemaName = "schema_name_example"; String tableName = "a/file/path.csv"; String pathPrefix = "prefix_example"; TableSpec tableSpec = new TableSpec(new PhysicalTableName(schemaName, tableName));  DuckdbParametersSpec duckdbParametersSpec = DuckdbConnectionSpecObjectMother.createForFiles(DuckdbFilesFormatType.csv).getDuckdb(); duckdbParametersSpec.setCsv(new CsvFileFormatSpec(){{ setAutoDetect(false); }}); duckdbParametersSpec.getDirectories().put(schemaName, pathPrefix);  FileFormatSpec fileFormatSpec = FileFormatSpecProvider.resolveFileFormat(duckdbParametersSpec, tableSpec);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(1, fileFormatSpec.getFilePaths().size()); Assertions.assertEquals(fileFormatSpec.getFilePaths().get(0), Path.of(pathPrefix,tableName).toString()); Assertions.assertFalse(fileFormatSpec.getCsv().getAutoDetect()); }
resolveFileFormat(DuckdbParametersSpec duckdbParametersSpec, TableSpec tableSpec) { DuckdbFilesFormatType filesType = duckdbParametersSpec.getFilesFormatType(); if (filesType == null) { throw new RuntimeException("The files format is unknown. Please set files format on the connection."); }  FileFormatSpec fileFormat = tableSpec.getFileFormat() == null ? new FileFormatSpec() : tableSpec.getFileFormat().deepClone(); if(fileFormat.getFilePaths().isEmpty()){ FilePathListSpec filePathListSpec = guessFilePaths(duckdbParametersSpec, tableSpec); fileFormat.setFilePaths(filePathListSpec); }  if (fileFormat.isFormatSetForType(filesType)) { return fileFormat; }  FileFormatSpec fileFormatCloned = fileFormat.deepClone(); if (duckdbParametersSpec.isFormatSetForType()) { switch (filesType) { case csv: fileFormatCloned.setCsv(duckdbParametersSpec.getCsv().deepClone()); break; case json: fileFormatCloned.setJson(duckdbParametersSpec.getJson().deepClone()); break; case parquet: fileFormatCloned.setParquet(duckdbParametersSpec.getParquet().deepClone()); break; case iceberg: fileFormatCloned.setIceberg(duckdbParametersSpec.getIceberg().deepClone()); break; } return fileFormatCloned; }  fillDefaultFileFormat(fileFormatCloned, filesType); return fileFormatCloned; }
[*] target: assertNotNull(fileFormatSpec)
[-] pred: org. junit. Assert. assertNotNull ( fileFormatSpec )
************************************
************************************
[+] input: resolveFileFormat_whenOnlyPathsSetOnFileFormat_retunsFormParametersWithPathsFormTable() { String sampleFileName = SampleCsvFileNames.continuous_days_one_row_per_day; TableSpec tableSpec = new TableSpec(new PhysicalTableName("schema_name_example", "table_name_example")); tableSpec.setFileFormat( new FileFormatSpec() {{ setFilePaths(new FilePathListSpec(){{ add(SampleDataFilesProvider.getFile(sampleFileName).toString()); }}); }});  DuckdbParametersSpec duckdbParametersSpec = DuckdbConnectionSpecObjectMother.createForFiles(DuckdbFilesFormatType.csv).getDuckdb(); duckdbParametersSpec.setCsv(new CsvFileFormatSpec(){{ setAutoDetect(false); }});  FileFormatSpec fileFormatSpec = FileFormatSpecProvider.resolveFileFormat(duckdbParametersSpec, tableSpec);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(1, fileFormatSpec.getFilePaths().size()); Assertions.assertFalse(fileFormatSpec.getCsv().getAutoDetect()); }
resolveFileFormat(DuckdbParametersSpec duckdbParametersSpec, TableSpec tableSpec) { DuckdbFilesFormatType filesType = duckdbParametersSpec.getFilesFormatType(); if (filesType == null) { throw new RuntimeException("The files format is unknown. Please set files format on the connection."); }  FileFormatSpec fileFormat = tableSpec.getFileFormat() == null ? new FileFormatSpec() : tableSpec.getFileFormat().deepClone(); if(fileFormat.getFilePaths().isEmpty()){ FilePathListSpec filePathListSpec = guessFilePaths(duckdbParametersSpec, tableSpec); fileFormat.setFilePaths(filePathListSpec); }  if (fileFormat.isFormatSetForType(filesType)) { return fileFormat; }  FileFormatSpec fileFormatCloned = fileFormat.deepClone(); if (duckdbParametersSpec.isFormatSetForType()) { switch (filesType) { case csv: fileFormatCloned.setCsv(duckdbParametersSpec.getCsv().deepClone()); break; case json: fileFormatCloned.setJson(duckdbParametersSpec.getJson().deepClone()); break; case parquet: fileFormatCloned.setParquet(duckdbParametersSpec.getParquet().deepClone()); break; case iceberg: fileFormatCloned.setIceberg(duckdbParametersSpec.getIceberg().deepClone()); break; } return fileFormatCloned; }  fillDefaultFileFormat(fileFormatCloned, filesType); return fileFormatCloned; }
[*] target: assertNotNull(fileFormatSpec)
[-] pred: org. junit. Assert. assertNotNull ( fileFormatSpec )
************************************
************************************
[+] input: testIsServeUnread() { assertFalse(fManager.mustServeReadTips()); fManager.setServeReadTips(true); "<AssertPlaceHolder>"; }
mustServeReadTips() { checkDisposed(); return fServeReadTips; }
[*] target: assertTrue(fManager.mustServeReadTips())
[-] pred: org. junit. Assert. assertTrue ( fManager. mustServeReadTips() )
************************************
************************************
[+] input: testLoad() { TestTipProvider p = (TestTipProvider) new TestTipProvider().setManager(fManager); assertFalse(p.isReady()); p.loadNewTips(new NullProgressMonitor()); "<AssertPlaceHolder>"; }
isReady() { return fReady; }
[*] target: assertTrue(p.isReady())
[-] pred: org. junit. Assert. assertTrue ( p. isReady() )
************************************
************************************
[+] input: testCompareSimpleSame() { IndexSee see1 = createSee(SEE_ECLIPSE); IndexSee see2 = createSee(SEE_ECLIPSE); assertTrue (see1.equals(see2)); assertEquals(0, see1.compareTo(see2)); assertEquals(0, see2.compareTo(see1)); "<AssertPlaceHolder>"; }
hashCode() { int result = getKeyword().hashCode(); IIndexSubpath[] subpaths = getSubpathElements(); for (int i = 0; i < subpaths.length; i++) { result += subpaths[i].getKeyword().hashCode(); } return result; }
[*] target: assertEquals(see1.hashCode(), see2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( see1. hashCode ( ), see2. hashCode() )
************************************
************************************
[+] input: testCompareCompoundSame() { IndexSee see1 = createSee(SEE_ECLIPSE_SDK); IndexSee see2 = createSee(SEE_ECLIPSE_SDK); assertTrue (see1.equals(see2)); assertEquals(0, see1.compareTo(see2)); assertEquals(0, see2.compareTo(see1)); "<AssertPlaceHolder>"; }
hashCode() { int result = getKeyword().hashCode(); IIndexSubpath[] subpaths = getSubpathElements(); for (int i = 0; i < subpaths.length; i++) { result += subpaths[i].getKeyword().hashCode(); } return result; }
[*] target: assertEquals(see1.hashCode(), see2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( see1. hashCode ( ), see2. hashCode ( ) )
************************************
************************************
[+] input: testNullUrl() { HelpData data = new HelpData(null); assertEquals(0, data.getTocOrder().size()); assertEquals(0, data.getHiddenTocs().size()); assertEquals(0, data.getHiddenIndexes().size()); "<AssertPlaceHolder>"; }
isSortOthers() { if (sortMode == null) { loadHelpData(); } return "true".equals(sortMode); //$NON-NLS-1$ }
[*] target: assertTrue(data.isSortOthers())
[-] pred: org. junit. Assert. assertTrue ( data. isSortOthers() )
************************************
************************************
[+] input: testAddScope() { String scopeName = "newScope1"; ScopeSetManager manager = new ScopeSetManager(); ScopeSet newScope = new ScopeSet(scopeName); manager.add(newScope); manager.save(); manager = new ScopeSetManager(); ScopeSet set = manager.findSet(scopeName); "<AssertPlaceHolder>"; assertEquals(scopeName, set.getName()); }
findSet(String name) { return findSet(name, false); }
[*] target: assertNotNull(set)
[-] pred: org. junit. Assert. assertNotNull ( set )
************************************
************************************
[+] input: testAddAndDeleteScope() { String scopeName = "newScope4"; ScopeSetManager manager = new ScopeSetManager(); ScopeSet newScope = new ScopeSet(scopeName); manager.add(newScope); manager.save();  manager = new ScopeSetManager(); ScopeSet set = manager.findSet(scopeName); assertNotNull(set); assertEquals(scopeName, set.getName()); manager.remove(set);  manager = new ScopeSetManager(); set = manager.findSet(scopeName); "<AssertPlaceHolder>"; }
findSet(String name) { return findSet(name, false); }
[*] target: assertNull(set)
[-] pred: org. junit. Assert. assertNull ( set )
************************************
************************************
[+] input: testNoTocs() { TopicFinder finder = new TopicFinder("http:", new IToc[0], new UniversalScope()); assertEquals(-1, finder.getSelectedToc()); "<AssertPlaceHolder>"; }
getTopicPath() { return foundTopicPath; }
[*] target: assertNull(finder.getTopicPath())
[-] pred: org. junit. Assert. assertNull ( finder. getTopicPath() )
************************************
************************************
[+] input: testNoTopic() { TopicFinder finder = new TopicFinder(null, getTocs(), new UniversalScope()); assertEquals(-1, finder.getSelectedToc()); "<AssertPlaceHolder>"; }
getTopicPath() { return foundTopicPath; }
[*] target: assertNull(finder.getTopicPath())
[-] pred: org. junit. Assert. assertNull ( finder. getTopicPath() )
************************************
************************************
[+] input: perform() { Concert concert = new Concert(new MockElvis()); concert.perform();  assertTrue(concert.isLightsOn()); "<AssertPlaceHolder>"; }
isMainStateOpen() { return mainStateOpen; }
[*] target: assertTrue(concert.isMainStateOpen())
[-] pred: org. junit. Assert. assertTrue ( concert. isMainStateOpen() )
************************************
************************************
[+] input: readHex() { byte[] bytes = new byte[32]; new Random().nextBytes(bytes); Bean bean = new Bean(); bean.value = bytes;  String str = JSON.toJSONString(bean); String str1 = JSON.toJSONString(bean, JSONWriter.Feature.OptimizedForAscii); "<AssertPlaceHolder>"; assertEquals( str, new String( JSON.toJSONBytes(bean) ) ); String str2 = JSON.toJSONString(bean, JSONWriter.Feature.PrettyFormat); assertArrayEquals( JSON.parseObject(str).getBytes("value"), JSON.parseObject(str2).getBytes("value") );  JSONWriter jsonWriter = JSONWriter.ofUTF8(); jsonWriter.writeAny(bean); assertEquals(str, new String(jsonWriter.getBytes(StandardCharsets.UTF_8))); assertEquals(str, new String(jsonWriter.getBytes(StandardCharsets.US_ASCII))); assertEquals(str.length(), jsonWriter.size());  Bean bean1 = JSON.parseObject(str, Bean.class); assertArrayEquals(bean.value, bean1.value);  Bean bean2 = JSON.parseObject(str.getBytes(), Bean.class); assertArrayEquals(bean.value, bean2.value);  Bean bean3 = JSON.parseObject(str.toCharArray(), Bean.class); assertArrayEquals(bean.value, bean3.value); }
readHex();  public byte[] readBinary() { if (ch == 'x') { return readHex(); }  if (isString()) { String str = readString(); if (str.isEmpty()) { return null; }  if ((context.features & Feature.Base64StringAsByteArray.mask) != 0) { return Base64.getDecoder().decode(str); }  throw new JSONException(info("not support input " + str)); }  if (nextIfArrayStart()) { int index = 0; byte[] bytes = new byte[64]; while (true) { if (ch == ']') { next(); break; } if (index == bytes.length) { int oldCapacity = bytes.length; int newCapacity = oldCapacity + (oldCapacity >> 1); bytes = Arrays.copyOf(bytes, newCapacity); } bytes[index++] = (byte) readInt32Value(); } nextIfComma(); return Arrays.copyOf(bytes, index); }  throw new JSONException(info("not support read binary")); }
[*] target: assertEquals(str, str1)
[-] pred: org. junit. Assert. assertEquals ( str, str1 )
************************************
************************************
[+] input: next_() { char ch = '®'; String str = "®" + ch; byte[] utf8 = str.getBytes(StandardCharsets.UTF_8); byte[] latin1 = str.getBytes(StandardCharsets.ISO_8859_1); { JSONReader reader = JSONReader.of(str); assertEquals(ch, reader.current()); reader.next(); assertEquals(ch, reader.current()); } { JSONReader reader = JSONReader.of(str.toCharArray()); assertEquals(ch, reader.current()); reader.next(); assertEquals(ch, reader.current()); } { JSONReader reader = JSONReader.of(utf8); assertEquals(ch, reader.current()); reader.next(); assertEquals(ch, reader.current()); } { JSONReader reader = JSONReader.of(latin1, 0, latin1.length, StandardCharsets.ISO_8859_1); assertEquals(ch, reader.current()); reader.next(); "<AssertPlaceHolder>"; } }
current() { return ch; }
[*] target: assertEquals(ch, reader.current())
[-] pred: org. junit. Assert. assertEquals ( ch, reader. current() )
************************************
************************************
[+] input: propertyPreFilter() { JSONWriter jsonWriter = JSONWriter.of(); JSONWriter.Context context = jsonWriter.getContext();  context.setPropertyPreFilter(null); assertNull(context.getPropertyPreFilter());  context.setNameFilter(null); assertNull(context.getNameFilter());  context.setValueFilter(null); assertNull(context.getValueFilter());  context.setPropertyFilter(null); assertNull(context.getPropertyFilter());  context.setContextValueFilter(null); assertNull(context.getContextValueFilter());  context.setContextNameFilter(null); assertNull(context.getContextNameFilter());  context.setAfterFilter(null); assertNull(context.getAfterFilter());  context.setBeforeFilter(null); assertNull(context.getBeforeFilter());  context.setLabelFilter(null); "<AssertPlaceHolder>"; }
getLabelFilter() { return labelFilter; }
[*] target: assertNull(context.getLabelFilter())
[-] pred: org. junit. Assert. assertNull ( context. getLabelFilter() )
************************************
************************************
[+] input: test() { String str = "{"value":true}"; assertEquals( true, JSON.parseObject(str, Bean.class).value.get() );  assertEquals( true, JSON.parseObject(str).to(Bean.class).value.get() );  ObjectReader objectReader = JSONFactory.getDefaultObjectReaderProvider().getObjectReader(Bean.class); FieldReader fieldReader = objectReader.getFieldReader("value"); assertEquals("value", fieldReader.toString()); "<AssertPlaceHolder>"; }
isReadOnly() { return true; }
[*] target: assertTrue(fieldReader.isReadOnly())
[-] pred: org. junit. Assert. assertTrue ( fieldReader. isReadOnly() )
************************************
************************************
[+] input: test() { String str = "{"value":[123]}"; assertEquals( 123, JSON.parseObject(str, Bean.class).value.get(0) );  assertEquals( 123, JSON.parseObject(str).to(Bean.class).value.get(0) );  ObjectReader objectReader = JSONFactory.getDefaultObjectReaderProvider().getObjectReader(Bean.class); FieldReader fieldReader = objectReader.getFieldReader("value"); assertEquals("getValue", fieldReader.toString()); "<AssertPlaceHolder>"; }
isReadOnly() { return true; }
[*] target: assertTrue(fieldReader.isReadOnly())
[-] pred: org. junit. Assert. assertTrue ( fieldReader. isReadOnly() )
************************************
************************************
[+] input: test() { String str = "{"value":123}"; assertEquals( 123, JSON.parseObject(str, Bean.class).value.get() );  assertEquals( 123, JSON.parseObject(str).to(Bean.class).value.get() );  ObjectReader objectReader = JSONFactory.getDefaultObjectReaderProvider().getObjectReader(Bean.class); FieldReader fieldReader = objectReader.getFieldReader("value"); assertEquals("getValue", fieldReader.toString()); "<AssertPlaceHolder>"; }
isReadOnly() { return true; }
[*] target: assertTrue(fieldReader.isReadOnly())
[-] pred: org. junit. Assert. assertTrue ( fieldReader. isReadOnly() )
************************************
************************************
[+] input: test1() { MoneySupport.CLASS_NUMBER_VALUE = null;  String str = "{"currency":"USD","number":200}"; MonetaryAmount amount = JSON.parseObject(str, MonetaryAmount.class); assertEquals("USD", amount.getCurrency().getCurrencyCode());  MoneySupport.CLASS_NUMBER_VALUE = null; MoneySupport.CLASS_CURRENCY_UNIT = null; MoneySupport.CLASS_MONETARY_AMOUNT_FACTORY = null;  Object amount1 = MoneySupport.createMonetaryAmount(amount.getCurrency(), amount.getNumber()); "<AssertPlaceHolder>"; }
createMonetaryAmount(Object currency, Object number) { if (CLASS_NUMBER_VALUE == null) { CLASS_NUMBER_VALUE = TypeUtils.loadClass("javax.money.NumberValue"); }  if (CLASS_CURRENCY_UNIT == null) { CLASS_CURRENCY_UNIT = TypeUtils.loadClass("javax.money.CurrencyUnit"); }  if (CLASS_MONETARY == null) { CLASS_MONETARY = TypeUtils.loadClass("javax.money.Monetary"); }  if (CLASS_MONETARY_AMOUNT == null) { CLASS_MONETARY_AMOUNT = TypeUtils.loadClass("javax.money.MonetaryAmount"); }  if (CLASS_MONETARY_AMOUNT_FACTORY == null) { CLASS_MONETARY_AMOUNT_FACTORY = TypeUtils.loadClass("javax.money.MonetaryAmountFactory"); }  if (FUNC_GET_DEFAULT_AMOUNT_FACTORY == null) { MethodHandles.Lookup lookup = JDKUtils.trustedLookup(CLASS_MONETARY); try { MethodHandle methodHandle = lookup.findStatic( CLASS_MONETARY, "getDefaultAmountFactory", MethodType.methodType(CLASS_MONETARY_AMOUNT_FACTORY) );  CallSite callSite = LambdaMetafactory.metafactory( lookup, "get", METHOD_TYPE_SUPPLIER, METHOD_TYPE_OBJECT, methodHandle, MethodType.methodType(CLASS_MONETARY_AMOUNT_FACTORY) ); MethodHandle target = callSite.getTarget(); FUNC_GET_DEFAULT_AMOUNT_FACTORY = (Supplier<Object>) target.invokeExact(); } catch (Throwable e) { throw new JSONException("method not found : javax.money.Monetary.getDefaultAmountFactory", e); } }  if (FUNC_SET_CURRENCY == null) { MethodHandles.Lookup lookup = JDKUtils.trustedLookup(CLASS_MONETARY_AMOUNT_FACTORY); try { MethodHandle methodHandle = lookup.findVirtual( CLASS_MONETARY_AMOUNT_FACTORY, "setCurrency", MethodType.methodType(CLASS_MONETARY_AMOUNT_FACTORY, CLASS_CURRENCY_UNIT) );  CallSite callSite = LambdaMetafactory.metafactory( lookup, "apply", METHOD_TYPE_BI_FUNCTION, METHOD_TYPE_OBJECT_OBJECT_OBJECT, methodHandle, MethodType.methodType(CLASS_MONETARY_AMOUNT_FACTORY, CLASS_MONETARY_AMOUNT_FACTORY, CLASS_CURRENCY_UNIT) ); MethodHandle target = callSite.getTarget(); FUNC_SET_CURRENCY = (BiFunction<Object, Object, Object>) target.invokeExact(); } catch (Throwable e) { throw new JSONException("method not found : javax.money.NumberValue.numberValue", e); } }  if (FUNC_SET_NUMBER == null) { MethodHandles.Lookup lookup = JDKUtils.trustedLookup(CLASS_MONETARY_AMOUNT_FACTORY); try { MethodHandle methodHandle = lookup.findVirtual( CLASS_MONETARY_AMOUNT_FACTORY, "setNumber", MethodType.methodType(CLASS_MONETARY_AMOUNT_FACTORY, Number.class) );  CallSite callSite = LambdaMetafactory.metafactory( lookup, "apply", METHOD_TYPE_BI_FUNCTION, METHOD_TYPE_OBJECT_OBJECT_OBJECT, methodHandle, MethodType.methodType(CLASS_MONETARY_AMOUNT_FACTORY, CLASS_MONETARY_AMOUNT_FACTORY, Number.class) ); MethodHandle target = callSite.getTarget(); FUNC_SET_NUMBER = (BiFunction<Object, Object, Number>) target.invokeExact(); } catch (Throwable e) { throw new JSONException("method not found : javax.money.NumberValue.numberValue", e); } }  if (FUNC_CREATE == null) { MethodHandles.Lookup lookup = JDKUtils.trustedLookup(CLASS_MONETARY_AMOUNT_FACTORY); try { MethodHandle methodHandle = lookup.findVirtual( CLASS_MONETARY_AMOUNT_FACTORY, "create", MethodType.methodType(CLASS_MONETARY_AMOUNT) );  CallSite callSite = LambdaMetafactory.metafactory( lookup, "apply", METHOD_TYPE_FUNCTION, METHOD_TYPE_OBJECT_OBJECT, methodHandle, MethodType.methodType(CLASS_MONETARY_AMOUNT, CLASS_MONETARY_AMOUNT_FACTORY) ); MethodHandle target = callSite.getTarget(); FUNC_CREATE = (Function<Object, Object>) target.invokeExact(); } catch (Throwable e) { throw new JSONException("method not found : javax.money.NumberValue.numberValue", e); } }  Object factoryObject = FUNC_GET_DEFAULT_AMOUNT_FACTORY.get();  if (currency != null) { FUNC_SET_CURRENCY.apply(factoryObject, currency); }  if (number != null) { FUNC_SET_NUMBER.apply(factoryObject, number); }  return FUNC_CREATE.apply(factoryObject); }
[*] target: assertEquals(amount, amount1)
[-] pred: org. junit. Assert. assertEquals ( amount, amount1 )
************************************
************************************
[+] input: parseArray() { String str = "[123]"; JSONLexer lexer = new JSONScanner(str); DefaultJSONParser parser = new DefaultJSONParser(str, lexer, ParserConfig.global); List list = new ArrayList(); parser.parseArray(Long.class, list); parser.handleResovleTask(list); "<AssertPlaceHolder>"; assertEquals(123L, list.get(0)); }
handleResovleTask(Object value) { reader.handleResolveTasks(value); }
[*] target: assertEquals(1, list.size())
[-] pred: org. junit. Assert. assertEquals ( 1, list. size ( ) )
************************************
************************************
[+] input: test1() { ParserConfig config = new ParserConfig(); try { config.setSafeMode(true); } catch (Exception ignored) { // ignored }  ParserConfig.AutoTypeCheckHandler handler = new ParserConfig.AutoTypeCheckHandler() { @Override public Class<?> handler(String typeName, Class<?> expectClass, int features) { return null; } }; config.addAutoTypeCheckHandler(handler); config.addDeny("aaa"); config.addDenyInternal("aaa"); config.addAccept("aaa");  Properties properties = new Properties(); properties.put(ParserConfig.AUTOTYPE_ACCEPT, "a,b,c"); properties.put(ParserConfig.DENY_PROPERTY, "e,f,g");  ObjectDeserializer deserializer = config.get(Bean.class); assertNotNull(deserializer);  deserializer = config.getDeserializer(Bean.class); assertNotNull(deserializer);  deserializer = config.getDeserializer(Bean.class, Bean.class); "<AssertPlaceHolder>";  Bean bean = deserializer.deserialze(new DefaultJSONParser("{"id":123}"), null, null); assertEquals(123, bean.id); }
getDeserializer(Class<?> clazz, Type type) { if (type == null) { type = clazz; }  ObjectReader objectReader = getProvider().getObjectReader(type); if (objectReader instanceof ObjectDeserializer) { return (ObjectDeserializer) objectReader; } return new ObjectDeserializerWrapper(objectReader); }
[*] target: assertNotNull(deserializer)
[-] pred: org. junit. Assert. assertNotNull ( deserializer )
************************************
************************************
[+] input: testCastToBytes() { byte[] bytes = new byte[1024]; new Random().nextBytes(bytes); String str = Base64.getEncoder().encodeToString(bytes); byte[] bytes1 = TypeUtils.castToBytes(str); assertArrayEquals(bytes, bytes1);  Exception error = null; try { TypeUtils.castToBytes(new Object()); } catch (Exception ex) { error = ex; } "<AssertPlaceHolder>"; }
castToBytes(Object value) { if (value instanceof byte[]) { return (byte[]) value; } if (value instanceof String) { return IOUtils.decodeBase64((String) value); } throw new JSONException("can not cast to byte[], value : " + value); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: givenTwoVideosWithSameChecksumAndLocation_whenCallsEquals_ShouldReturnTrue() { // given final var expectedChecksum = "abc"; final var expectedRawLocation = "/images/ac";  final var img1 = AudioVideoMedia.with(expectedChecksum, "Random", expectedRawLocation);  final var img2 = AudioVideoMedia.with(expectedChecksum, "Simple", expectedRawLocation);  // then Assertions."<AssertPlaceHolder>"; Assertions.assertNotSame(img1, img2); }
with( final String checksum, final String name, final String rawLocation ) { return new AudioVideoMedia(IdUtils.uuid(), checksum, name, rawLocation, "", MediaStatus.PENDING); }
[*] target: assertEquals(img1, img2)
[-] pred: org. junit. Assert. assertEquals ( img1, img2 )
************************************
************************************
[+] input: givenTwoImagesWithSameChecksumAndLocation_whenCallsEquals_ShouldReturnTrue() { // given final var expectedChecksum = "abc"; final var expectedLocation = "/images/ac";  final var img1 = ImageMedia.with(expectedChecksum, "Random", expectedLocation);  final var img2 = ImageMedia.with(expectedChecksum, "Simple", expectedLocation);  // then Assertions."<AssertPlaceHolder>"; Assertions.assertNotSame(img1, img2); }
with(final String checksum, final String name, final String location) { return new ImageMedia(IdUtils.uuid(), checksum, name, location); }
[*] target: assertEquals(img1, img2)
[-] pred: org. junit. Assert. assertEquals ( img1, img2 )
************************************
************************************
[+] input: givenValidVideoId_whenCallsGetResource_shouldReturnIt() { // given final var videoOne = VideoID.unique(); final var expectedType = VideoMediaType.VIDEO; final var expectedResource = resource(expectedType);  storageService().store("videoId-%s/type-%s".formatted(videoOne.getValue(), expectedType), expectedResource); storageService().store("videoId-%s/type-%s".formatted(videoOne.getValue(), VideoMediaType.TRAILER.name()), resource(mediaType())); storageService().store("videoId-%s/type-%s".formatted(videoOne.getValue(), VideoMediaType.BANNER.name()), resource(mediaType()));  Assertions.assertEquals(3, storageService().storage().size());  // when final var actualResult = this.mediaResourceGateway.getResource(videoOne, expectedType).get();  // then Assertions."<AssertPlaceHolder>"; }
getResource(final VideoID anId, final VideoMediaType type) { return this.storageService.get(filepath(anId, type)); }
[*] target: assertEquals(expectedResource, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedResource, actualResult )
************************************
************************************
[+] input: givenAValidVideo_whenCallsFindById_shouldReturnIt() { // given final var expectedTitle = Fixture.title(); final var expectedDescription = Fixture.Videos.description(); final var expectedLaunchYear = Year.of(Fixture.year()); final var expectedDuration = Fixture.duration(); final var expectedOpened = Fixture.bool(); final var expectedPublished = Fixture.bool(); final var expectedRating = Fixture.Videos.rating(); final var expectedCategories = Set.of(aulas.getId()); final var expectedGenres = Set.of(tech.getId()); final var expectedMembers = Set.of(wesley.getId());  final AudioVideoMedia expectedVideo = AudioVideoMedia.with("123", "video", "/media/video");  final AudioVideoMedia expectedTrailer = AudioVideoMedia.with("123", "trailer", "/media/trailer");  final ImageMedia expectedBanner = ImageMedia.with("123", "banner", "/media/banner");  final ImageMedia expectedThumb = ImageMedia.with("123", "thumb", "/media/thumb");  final ImageMedia expectedThumbHalf = ImageMedia.with("123", "thumbHalf", "/media/thumbHalf");  final var aVideo = videoGateway.create( Video.newVideo( expectedTitle, expectedDescription, expectedLaunchYear, expectedDuration, expectedOpened, expectedPublished, expectedRating, expectedCategories, expectedGenres, expectedMembers ) .updateVideoMedia(expectedVideo) .updateTrailerMedia(expectedTrailer) .updateBannerMedia(expectedBanner) .updateThumbnailMedia(expectedThumb) .updateThumbnailHalfMedia(expectedThumbHalf) );  // when final var actualVideo = videoGateway.findById(aVideo.getId()).get();  // then Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(actualVideo.getId());  Assertions.assertEquals(expectedTitle, actualVideo.getTitle()); Assertions.assertEquals(expectedDescription, actualVideo.getDescription()); Assertions.assertEquals(expectedLaunchYear, actualVideo.getLaunchedAt()); Assertions.assertEquals(expectedDuration, actualVideo.getDuration()); Assertions.assertEquals(expectedOpened, actualVideo.getOpened()); Assertions.assertEquals(expectedPublished, actualVideo.getPublished()); Assertions.assertEquals(expectedRating, actualVideo.getRating()); Assertions.assertEquals(expectedCategories, actualVideo.getCategories()); Assertions.assertEquals(expectedGenres, actualVideo.getGenres()); Assertions.assertEquals(expectedMembers, actualVideo.getCastMembers()); Assertions.assertEquals(expectedVideo.name(), actualVideo.getVideo().get().name()); Assertions.assertEquals(expectedTrailer.name(), actualVideo.getTrailer().get().name()); Assertions.assertEquals(expectedBanner.name(), actualVideo.getBanner().get().name()); Assertions.assertEquals(expectedThumb.name(), actualVideo.getThumbnail().get().name()); Assertions.assertEquals(expectedThumbHalf.name(), actualVideo.getThumbnailHalf().get().name()); }
findById(final VideoID anId) { return this.videoRepository.findById(anId.getValue()) .map(VideoJpaEntity::toAggregate); }
[*] target: assertNotNull(actualVideo)
[-] pred: org. junit. Assert. assertNotNull ( actualVideo )
************************************
************************************
[+] input: testIsImmobilized() { final Combatant combatant = new Combatant(); assertFalse(combatant.isImmobilized()); combatant.addBuff(Buff.builder().buffType(STUN).buffTraits(Collections.singletonList(IMMOBILIZE_BUFF.name())).build()); assertTrue(combatant.isImmobilized());  combatant.getBuffs().clear(); assertFalse(combatant.isImmobilized()); combatant.addBuff(Buff.builder().buffType(CHARM).buffTraits(Collections.singletonList(IMMOBILIZE_BUFF.name())).build()); "<AssertPlaceHolder>"; }
isImmobilized() { return anyBuffMatch(BuffUtils::isImmobilizeDebuff); }
[*] target: assertTrue(combatant.isImmobilized())
[-] pred: org. junit. Assert. assertTrue ( combatant. isImmobilized() )
************************************
************************************
[+] input: testPollEnemies() { final Stage stage = new Stage( ImmutableList.of(new Combatant(), new Combatant()), 3, ImmutableList.of() );  assertTrue(stage.hasMoreEnemies()); stage.getNextEnemy(); stage.getNextEnemy(); "<AssertPlaceHolder>"; }
hasMoreEnemies() { return !enemies.isEmpty(); }
[*] target: assertFalse(stage.hasMoreEnemies())
[-] pred: org. junit. Assert. assertFalse ( stage. hasMoreEnemies() )
************************************
************************************
[+] input: Exception { var collector = new RestApiMetricsCollector<JobID, JobAutoScalerContext<JobID>>();  JobVertexID jobVertexID = new JobVertexID(); var flinkMetrics = Map.of( "a.pendingRecords", FlinkMetric.PENDING_RECORDS, "b.pendingRecords", FlinkMetric.PENDING_RECORDS); var metrics = Map.of(jobVertexID, flinkMetrics);  var aggregatedMetricsResponse = List.of( new AggregatedMetric( "a.pendingRecords", Double.NaN, Double.NaN, Double.NaN, 100.), new AggregatedMetric( "b.pendingRecords", Double.NaN, Double.NaN, Double.NaN, 100.), new AggregatedMetric( "c.unrelated", Double.NaN, Double.NaN, Double.NaN, 100.));  var conf = new Configuration(); var restClusterClient = new RestClusterClient<>( conf, "test-cluster", (c, e) -> new StandaloneClientHAServices("localhost")) { @Override public < M extends MessageHeaders<R, P, U>, U extends MessageParameters, R extends RequestBody, P extends ResponseBody> CompletableFuture<P> sendRequest( M messageHeaders, U messageParameters, R request) { if (messageHeaders instanceof AggregatedSubtaskMetricsHeaders) { return (CompletableFuture<P>) CompletableFuture.completedFuture( new AggregatedMetricsResponseBody( aggregatedMetricsResponse)); } return (CompletableFuture<P>) CompletableFuture.completedFuture(EmptyResponseBody.getInstance()); } };  JobID jobID = new JobID(); var context = new JobAutoScalerContext<>( jobID, jobID, JobStatus.RUNNING, conf, new UnregisteredMetricsGroup(), () -> restClusterClient);  var jobVertexIDMapMap = collector.queryAllAggregatedMetrics(context, metrics);  "<AssertPlaceHolder>"; Map<FlinkMetric, AggregatedMetric> vertexMetrics = jobVertexIDMapMap.get(jobVertexID); Assertions.assertNotNull(vertexMetrics); AggregatedMetric pendingRecordsMetric = vertexMetrics.get(FlinkMetric.PENDING_RECORDS); Assertions.assertNotNull(pendingRecordsMetric); assertEquals(pendingRecordsMetric.getSum(), 200); }
queryAllAggregatedMetrics( Context ctx, Map<JobVertexID, Map<String, FlinkMetric>> filteredVertexMetricNames) {  return filteredVertexMetricNames.entrySet().stream() .collect( Collectors.toMap( Map.Entry::getKey, e -> queryAggregatedVertexMetrics(ctx, e.getKey(), e.getValue()))); }
[*] target: assertEquals(1, jobVertexIDMapMap.size())
[-] pred: org. junit. Assert. assertEquals ( 1, jobVertexIDMapMap. size ( ) )
************************************
************************************
[+] input: evaluateShouldOverwriteRestartCountWhenLess() { var observedClusterHealthInfo1 = createClusterHealthInfo(validInstant1, 1, 1); var observedClusterHealthInfo2 = createClusterHealthInfo(validInstant2, 0, 1);  setLastValidClusterHealthInfo(observedClusterHealthInfo1); clusterHealthEvaluator.evaluate(configuration, clusterInfo, observedClusterHealthInfo2); var lastValidClusterHealthInfo = ClusterHealthEvaluator.getLastValidClusterHealthInfo(clusterInfo); "<AssertPlaceHolder>"; assertEquals( observedClusterHealthInfo2.getNumRestarts(), lastValidClusterHealthInfo.getNumRestarts()); assertEquals( observedClusterHealthInfo2.getTimeStamp(), lastValidClusterHealthInfo.getNumRestartsEvaluationTimeStamp()); }
getLastValidClusterHealthInfo(Map<String, String> clusterInfo) { LOG.debug("Getting last valid health check info"); if (clusterInfo.containsKey(CLUSTER_INFO_KEY)) { return ClusterHealthInfo.deserialize(clusterInfo.get(CLUSTER_INFO_KEY)); } else { LOG.debug("No last valid health check info"); return null; } }
[*] target: assertNotNull(lastValidClusterHealthInfo)
[-] pred: org. junit. Assert. assertNotNull ( lastValidClusterHealthInfo )
************************************
************************************
[+] input: evaluateShouldOverwriteRestartCountWhenTimestampIsOutOfWindow() { configuration.set(OPERATOR_CLUSTER_HEALTH_CHECK_RESTARTS_WINDOW, Duration.ofMinutes(1)); var observedClusterHealthInfo1 = createClusterHealthInfo(validInstant1, 0, 1); var observedClusterHealthInfo2 = createClusterHealthInfo(validInstant2, 1, 1);  setLastValidClusterHealthInfo(observedClusterHealthInfo1); clusterHealthEvaluator.evaluate(configuration, clusterInfo, observedClusterHealthInfo2); var lastValidClusterHealthInfo = ClusterHealthEvaluator.getLastValidClusterHealthInfo(clusterInfo); "<AssertPlaceHolder>"; assertEquals( observedClusterHealthInfo2.getNumRestarts(), lastValidClusterHealthInfo.getNumRestarts()); assertEquals( observedClusterHealthInfo2.getTimeStamp(), lastValidClusterHealthInfo.getNumRestartsEvaluationTimeStamp()); }
getLastValidClusterHealthInfo(Map<String, String> clusterInfo) { LOG.debug("Getting last valid health check info"); if (clusterInfo.containsKey(CLUSTER_INFO_KEY)) { return ClusterHealthInfo.deserialize(clusterInfo.get(CLUSTER_INFO_KEY)); } else { LOG.debug("No last valid health check info"); return null; } }
[*] target: assertNotNull(lastValidClusterHealthInfo)
[-] pred: org. junit. Assert. assertNotNull ( lastValidClusterHealthInfo )
************************************
************************************
[+] input: test() { val libs = parse(getJsonObject("lib.json")); "<AssertPlaceHolder>"; OS os = new OS("Windows", OS.Type.WINDOWS, "10", false); Features feat = Features.EMPTY; assertEquals(Rule.Action.ALLOW, libs.get(0).getRule().apply(os, feat)); assertEquals("testpackage:test:testversion", libs.get(0).getName()); assertEquals("testpackage", libs.get(0).getPackage()); assertEquals("test", libs.get(0).getNameAfterPackage()); assertEquals("testversion", libs.get(0).getVersionNumber()); assertEquals("http://_download_url", libs.get(0).getUrl("")); assertFalse(libs.get(0).isNativeLibrary()); }
parse(JsonObject json) { val rule = ruleFactory.parse(json.get("rules")); val extractor = extractorFactory.parse(json.get("extract")); val natives = nativesFactory.parse(json.get("natives")); val result = new ArrayList<Library>(natives.isEmpty() ? 1 : natives.size() + 1); val name = json.get("name").getAsString(); val baseUrl = JsonUtil.getString(json, "url");  val downloads = json.get("downloads"); if (downloads != null && downloads.isJsonObject()) { val artifact = downloads.getAsJsonObject().get("artifact"); if (artifact != null && artifact.isJsonObject()) { JsonObject jo = artifact.getAsJsonObject(); String url = JsonUtil.getString(jo, "url"); String path = JsonUtil.getString(jo, "path"); String sha1 = JsonUtil.getString(jo, "sha1"); Long size = JsonUtil.getLong(jo, "size"); result.add(new LibraryImpl(natives, Extractor.NO_EXTRACTION, name, rule, baseUrl, sha1, size, url, path, false)); }  val classifiers = downloads.getAsJsonObject().get("classifiers"); if (classifiers != null && classifiers.isJsonObject()) { for (Map.Entry<String, JsonElement> e : classifiers.getAsJsonObject().entrySet()) { Map.Entry<String, String> nativeEntry = getNativeEntry(natives, e.getKey()); if (nativeEntry == null || !e.getValue().isJsonObject()) { continue; }  // nativeWithReplace for this library, ${arch} is replaced String nativeName = e.getKey(); // name of the os String os = nativeEntry.getKey(); // native name containing ${arch} to be replaced with 32/64 String nativeWithReplace = nativeEntry.getValue(); Rule osRule = (osIn, f) -> { // check that we have the right os if (os.equalsIgnoreCase(osIn.getType().getName()) // check that we have the right arch version && nativeWithReplace.replace("${arch}", osIn.isArch() ? "64" : "32").equals(nativeName)) { return rule.apply(osIn, f); }  return Rule.Action.DISALLOW; };  Extractor nativeExtractor = extractor; // if there was no extraction rule specified. if (!extractor.isExtracting()) { nativeExtractor = new ExtractorImpl(); }  JsonObject jo = e.getValue().getAsJsonObject(); String url = JsonUtil.getString(jo, "url"); String path = JsonUtil.getString(jo, "path"); String sha1 = JsonUtil.getString(jo, "sha1"); Long size = JsonUtil.getLong(jo, "size"); result.add(new LibraryImpl(natives, nativeExtractor, name, osRule, baseUrl, sha1, size, url, path, true)); } } }  if (result.isEmpty()) { result.add(new LibraryImpl(natives, extractor, name, rule, baseUrl, null, null, null, null, false)); }  return result; }
[*] target: assertEquals(1, libs.size())
[-] pred: org. junit. Assert. assertEquals ( 1, libs. size ( ) )
************************************
************************************
[+] input: testLibWithNatives() { val libs = parse(getJsonObject("lib_natives.json")); "<AssertPlaceHolder>"; assertFalse(libs.get(0).isNativeLibrary()); assertTrue(libs.get(1).isNativeLibrary()); }
parse(JsonObject json) { val rule = ruleFactory.parse(json.get("rules")); val extractor = extractorFactory.parse(json.get("extract")); val natives = nativesFactory.parse(json.get("natives")); val result = new ArrayList<Library>(natives.isEmpty() ? 1 : natives.size() + 1); val name = json.get("name").getAsString(); val baseUrl = JsonUtil.getString(json, "url");  val downloads = json.get("downloads"); if (downloads != null && downloads.isJsonObject()) { val artifact = downloads.getAsJsonObject().get("artifact"); if (artifact != null && artifact.isJsonObject()) { JsonObject jo = artifact.getAsJsonObject(); String url = JsonUtil.getString(jo, "url"); String path = JsonUtil.getString(jo, "path"); String sha1 = JsonUtil.getString(jo, "sha1"); Long size = JsonUtil.getLong(jo, "size"); result.add(new LibraryImpl(natives, Extractor.NO_EXTRACTION, name, rule, baseUrl, sha1, size, url, path, false)); }  val classifiers = downloads.getAsJsonObject().get("classifiers"); if (classifiers != null && classifiers.isJsonObject()) { for (Map.Entry<String, JsonElement> e : classifiers.getAsJsonObject().entrySet()) { Map.Entry<String, String> nativeEntry = getNativeEntry(natives, e.getKey()); if (nativeEntry == null || !e.getValue().isJsonObject()) { continue; }  // nativeWithReplace for this library, ${arch} is replaced String nativeName = e.getKey(); // name of the os String os = nativeEntry.getKey(); // native name containing ${arch} to be replaced with 32/64 String nativeWithReplace = nativeEntry.getValue(); Rule osRule = (osIn, f) -> { // check that we have the right os if (os.equalsIgnoreCase(osIn.getType().getName()) // check that we have the right arch version && nativeWithReplace.replace("${arch}", osIn.isArch() ? "64" : "32").equals(nativeName)) { return rule.apply(osIn, f); }  return Rule.Action.DISALLOW; };  Extractor nativeExtractor = extractor; // if there was no extraction rule specified. if (!extractor.isExtracting()) { nativeExtractor = new ExtractorImpl(); }  JsonObject jo = e.getValue().getAsJsonObject(); String url = JsonUtil.getString(jo, "url"); String path = JsonUtil.getString(jo, "path"); String sha1 = JsonUtil.getString(jo, "sha1"); Long size = JsonUtil.getLong(jo, "size"); result.add(new LibraryImpl(natives, nativeExtractor, name, osRule, baseUrl, sha1, size, url, path, true)); } } }  if (result.isEmpty()) { result.add(new LibraryImpl(natives, extractor, name, rule, baseUrl, null, null, null, null, false)); }  return result; }
[*] target: assertEquals(2, libs.size())
[-] pred: org. junit. Assert. assertEquals ( 2, libs. size ( ) )
************************************
************************************
[+] input: testSerializeWithMetricsData() {  CollectRep.MetricsData metricsData = CollectRep.MetricsData.newBuilder() .setMetrics("someValue") .setApp("linux") .build(); byte[] bytes = serializer.serialize("", metricsData);  "<AssertPlaceHolder>"; assertArrayEquals(metricsData.toByteArray(), bytes); }
serialize(String s, CollectRep.MetricsData metricsData) {  if (metricsData == null) { log.error("metricsData is null"); return null; }  return metricsData.toByteArray(); }
[*] target: assertNotNull(bytes)
[-] pred: org. junit. Assert. assertNotNull ( bytes )
************************************
************************************
[+] input: testAesEncode() { String originalText = "This is a secret message"; String encryptedText = aesEncode(originalText, VALID_KEY); assertNotEquals(originalText, encryptedText);  String decryptedText = aesDecode(encryptedText, VALID_KEY); "<AssertPlaceHolder>"; }
aesDecode(String content, String decryptKey) { try { byte[] byteDecode = getBytes(content, decryptKey); return new String(byteDecode, StandardCharsets.UTF_8); } catch (BadPaddingException e) { if (!ENCODE_RULES.equals(decryptKey)) { log.warn("There has default encode secret encode content, try to decode with default secret key"); return aesDecode(content, ENCODE_RULES); } log.error("aes decode content error: {}, please config right common secret key", e.getMessage()); return content; } catch (NoSuchAlgorithmException e) { log.error("no such algorithm: {}", e.getMessage(), e); } catch (IllegalBlockSizeException e) { log.error("illegal block size: {}", e.getMessage(), e); } catch (NullPointerException e) { log.error("null point exception: {}", e.getMessage(), e); } catch (Exception e) { log.error("aes decode error: {}", e.getMessage(), e); } return content; }
[*] target: assertEquals(originalText, decryptedText)
[-] pred: org. junit. Assert. assertEquals ( originalText, decryptedText )
************************************
************************************
[+] input: testCalInitMap() { int size = 0; int expectedCapacity = (int) Math.ceil(size / 0.75); int actualCapacity = MapCapUtil.calInitMap(size);  assertEquals(expectedCapacity, actualCapacity);  size = 10; expectedCapacity = (int) Math.ceil(size / 0.75); actualCapacity = MapCapUtil.calInitMap(size);  "<AssertPlaceHolder>"; }
calInitMap(int size) { return (int) Math.ceil (size / LOAD_FACTOR); }
[*] target: assertEquals(expectedCapacity, actualCapacity)
[-] pred: org. junit. Assert. assertEquals ( expectedCapacity, actualCapacity )
************************************
************************************
[+] input: toProtobuf() {  Person.Builder builder = Person.newBuilder(); Person person = (Person) ProtoJsonUtil.toProtobuf(sampleJson, builder); assertEquals(samplePerson, person);  String invalidJson = "{ "name": "John Doe", "id": "not-a-number" }"; builder = Person.newBuilder(); person = (Person) ProtoJsonUtil.toProtobuf(invalidJson, builder);  "<AssertPlaceHolder>"; }
toProtobuf(String json, Message.Builder builder) {  if (Objects.isNull(json) || Objects.isNull(builder)) { log.error("json or builder is null"); return null; }  try { PARSER.merge(json, builder); return builder.build(); } catch (Exception e) { log.error(e.getMessage(), e); return null; } }
[*] target: assertNull(person)
[-] pred: org. junit. Assert. assertNull ( person )
************************************
************************************
[+] input: testIsEmpty() {  StrBuffer buffer = new StrBuffer(""); assertTrue(buffer.isEmpty());  buffer = new StrBuffer("  \t  "); buffer.skipBlankTabs(); assertTrue(buffer.isEmpty());  buffer = new StrBuffer("hello"); "<AssertPlaceHolder>"; }
isEmpty() { return left > right; }
[*] target: assertFalse(buffer.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( buffer. isEmpty() )
************************************
************************************
[+] input: IOException {  String input = "metric_name{label1="value1",label2="value2"} 123.45 67890\n"; InputStream inputStream = new ByteArrayInputStream(input.getBytes());  List<Metric> metrics = PrometheusUtil.parseMetrics(inputStream);  "<AssertPlaceHolder>"; assertEquals(1, metrics.size());  Metric metric = metrics.get(0); assertEquals("metric_name", metric.getMetricName()); assertEquals(123.45, metric.getValue()); assertEquals(67890, metric.getTimestamp());  List<Label> labels = metric.getLabelList(); assertEquals(2, labels.size()); assertEquals("label1", labels.get(0).getName()); assertEquals("value1", labels.get(0).getValue()); assertEquals("label2", labels.get(1).getName()); assertEquals("value2", labels.get(1).getValue()); }
parseMetrics(InputStream inputStream) throws IOException { List<Metric> metricList = new ArrayList<>(); int i = parseMetric(inputStream, metricList); while (i == '\n' || i == COMMENT_LINE) { if (i == COMMENT_LINE) { if (skipCommentLine(inputStream) == NORMAL_END) { return metricList; }  } i = parseMetric(inputStream, metricList); } if (i == NORMAL_END) { return metricList; } else { return null; } }
[*] target: assertNotNull(metrics)
[-] pred: org. junit. Assert. assertNotNull ( metrics )
************************************
************************************
[+] input: IOException {  String input = "# This is a comment\nmetric_name{label1="value1"} 123.45 67890\n"; InputStream inputStream = new ByteArrayInputStream(input.getBytes());  List<Metric> metrics = PrometheusUtil.parseMetrics(inputStream);  "<AssertPlaceHolder>"; assertEquals(1, metrics.size());  Metric metric = metrics.get(0); assertEquals("metric_name", metric.getMetricName()); assertEquals(123.45, metric.getValue()); assertEquals(67890, metric.getTimestamp());  List<Label> labels = metric.getLabelList(); assertEquals(1, labels.size()); assertEquals("label1", labels.get(0).getName()); assertEquals("value1", labels.get(0).getValue()); }
parseMetrics(InputStream inputStream) throws IOException { List<Metric> metricList = new ArrayList<>(); int i = parseMetric(inputStream, metricList); while (i == '\n' || i == COMMENT_LINE) { if (i == COMMENT_LINE) { if (skipCommentLine(inputStream) == NORMAL_END) { return metricList; }  } i = parseMetric(inputStream, metricList); } if (i == NORMAL_END) { return metricList; } else { return null; } }
[*] target: assertNotNull(metrics)
[-] pred: org. junit. Assert. assertNotNull ( metrics )
************************************
************************************
[+] input: IOException {  String input = "metric_name{label1="value1"} +Inf 67890\n"; InputStream inputStream = new ByteArrayInputStream(input.getBytes());  List<Metric> metrics = PrometheusUtil.parseMetrics(inputStream);  "<AssertPlaceHolder>"; assertEquals(1, metrics.size());  Metric metric = metrics.get(0); assertEquals("metric_name", metric.getMetricName()); assertEquals(Double.POSITIVE_INFINITY, metric.getValue()); assertEquals(67890, metric.getTimestamp()); }
parseMetrics(InputStream inputStream) throws IOException { List<Metric> metricList = new ArrayList<>(); int i = parseMetric(inputStream, metricList); while (i == '\n' || i == COMMENT_LINE) { if (i == COMMENT_LINE) { if (skipCommentLine(inputStream) == NORMAL_END) { return metricList; }  } i = parseMetric(inputStream, metricList); } if (i == NORMAL_END) { return metricList; } else { return null; } }
[*] target: assertNotNull(metrics)
[-] pred: org. junit. Assert. assertNotNull ( metrics )
************************************
************************************
[+] input: IOException {  String input = "metric_name{label1="value1"} -Inf 67890\n"; InputStream inputStream = new ByteArrayInputStream(input.getBytes());  List<Metric> metrics = PrometheusUtil.parseMetrics(inputStream);  "<AssertPlaceHolder>"; assertEquals(1, metrics.size());  Metric metric = metrics.get(0); assertEquals("metric_name", metric.getMetricName()); assertEquals(Double.NEGATIVE_INFINITY, metric.getValue()); assertEquals(67890, metric.getTimestamp()); }
parseMetrics(InputStream inputStream) throws IOException { List<Metric> metricList = new ArrayList<>(); int i = parseMetric(inputStream, metricList); while (i == '\n' || i == COMMENT_LINE) { if (i == COMMENT_LINE) { if (skipCommentLine(inputStream) == NORMAL_END) { return metricList; }  } i = parseMetric(inputStream, metricList); } if (i == NORMAL_END) { return metricList; } else { return null; } }
[*] target: assertNotNull(metrics)
[-] pred: org. junit. Assert. assertNotNull ( metrics )
************************************
************************************
[+] input: IOException {  String input = "metric_name 123.45 67890\n"; InputStream inputStream = new ByteArrayInputStream(input.getBytes());  List<Metric> metrics = PrometheusUtil.parseMetrics(inputStream);  "<AssertPlaceHolder>"; assertEquals(1, metrics.size());  Metric metric = metrics.get(0); assertEquals("metric_name", metric.getMetricName()); assertEquals(123.45, metric.getValue()); assertEquals(67890, metric.getTimestamp()); assertNull(metric.getLabelList()); }
parseMetrics(InputStream inputStream) throws IOException { List<Metric> metricList = new ArrayList<>(); int i = parseMetric(inputStream, metricList); while (i == '\n' || i == COMMENT_LINE) { if (i == COMMENT_LINE) { if (skipCommentLine(inputStream) == NORMAL_END) { return metricList; }  } i = parseMetric(inputStream, metricList); } if (i == NORMAL_END) { return metricList; } else { return null; } }
[*] target: assertNotNull(metrics)
[-] pred: org. junit. Assert. assertNotNull ( metrics )
************************************
************************************
[+] input: IOException {  String input = "metric_name{label1="value1"} 123.45\n"; InputStream inputStream = new ByteArrayInputStream(input.getBytes());  List<Metric> metrics = PrometheusUtil.parseMetrics(inputStream);  "<AssertPlaceHolder>"; assertEquals(1, metrics.size());  Metric metric = metrics.get(0); assertEquals("metric_name", metric.getMetricName()); assertEquals(123.45, metric.getValue()); assertEquals(null, metric.getTimestamp()); // Assuming 0 for no timestamp  List<Label> labels = metric.getLabelList(); assertEquals(1, labels.size()); assertEquals("label1", labels.get(0).getName()); assertEquals("value1", labels.get(0).getValue()); }
parseMetrics(InputStream inputStream) throws IOException { List<Metric> metricList = new ArrayList<>(); int i = parseMetric(inputStream, metricList); while (i == '\n' || i == COMMENT_LINE) { if (i == COMMENT_LINE) { if (skipCommentLine(inputStream) == NORMAL_END) { return metricList; }  } i = parseMetric(inputStream, metricList); } if (i == NORMAL_END) { return metricList; } else { return null; } }
[*] target: assertNotNull(metrics)
[-] pred: org. junit. Assert. assertNotNull ( metrics )
************************************
************************************
[+] input: IOException {  String input = "metric_name1{label1="value1"} 123.45 67890\nmetric_name2 678.90 12345\n"; InputStream inputStream = new ByteArrayInputStream(input.getBytes());  List<Metric> metrics = PrometheusUtil.parseMetrics(inputStream);  "<AssertPlaceHolder>"; assertEquals(2, metrics.size());  Metric metric1 = metrics.get(0); assertEquals("metric_name1", metric1.getMetricName()); assertEquals(123.45, metric1.getValue()); assertEquals(67890, metric1.getTimestamp());  List<Label> labels1 = metric1.getLabelList(); assertEquals(1, labels1.size()); assertEquals("label1", labels1.get(0).getName()); assertEquals("value1", labels1.get(0).getValue());  Metric metric2 = metrics.get(1); assertEquals("metric_name2", metric2.getMetricName()); assertEquals(678.90, metric2.getValue()); assertEquals(12345, metric2.getTimestamp()); assertNull(metric2.getLabelList()); }
parseMetrics(InputStream inputStream) throws IOException { List<Metric> metricList = new ArrayList<>(); int i = parseMetric(inputStream, metricList); while (i == '\n' || i == COMMENT_LINE) { if (i == COMMENT_LINE) { if (skipCommentLine(inputStream) == NORMAL_END) { return metricList; }  } i = parseMetric(inputStream, metricList); } if (i == NORMAL_END) { return metricList; } else { return null; } }
[*] target: assertNotNull(metrics)
[-] pred: org. junit. Assert. assertNotNull ( metrics )
************************************
************************************
[+] input: IOException {  String input = ""; InputStream inputStream = new ByteArrayInputStream(input.getBytes());  List<Metric> metrics = PrometheusUtil.parseMetrics(inputStream);  "<AssertPlaceHolder>"; assertTrue(metrics.isEmpty()); }
parseMetrics(InputStream inputStream) throws IOException { List<Metric> metricList = new ArrayList<>(); int i = parseMetric(inputStream, metricList); while (i == '\n' || i == COMMENT_LINE) { if (i == COMMENT_LINE) { if (skipCommentLine(inputStream) == NORMAL_END) { return metricList; }  } i = parseMetric(inputStream, metricList); } if (i == NORMAL_END) { return metricList; } else { return null; } }
[*] target: assertNotNull(metrics)
[-] pred: org. junit. Assert. assertNotNull ( metrics )
************************************
************************************
[+] input: findNoticeRulesByEnableTrue() { List<NoticeRule> enabledList = noticeRuleDao.findNoticeRulesByEnableTrue(); "<AssertPlaceHolder>"; assertEquals(1, enabledList.size()); }
findNoticeRulesByEnableTrue();
[*] target: assertNotNull(enabledList)
[-] pred: org. junit. Assert. assertNotNull ( enabledList )
************************************
************************************
[+] input: AuthenticationException {  SurenessAccount account = DefaultAccount.builder("app1") .setPassword(Md5Util.md5(password + salt)) .setSalt(salt) .setOwnRoles(roles) .setDisabledAccount(Boolean.FALSE) .setExcessiveAttempts(Boolean.FALSE) .build(); LoginDto loginDto = LoginDto.builder() .credential(password) .identifier(identifier) .build();  when(accountProvider.loadAccount(identifier)).thenReturn(account);  Map<String, String> response = accountService.authGetToken(loginDto);  "<AssertPlaceHolder>"; assertNotNull(response.get("token")); assertNotNull(response.get("refreshToken")); assertNotNull(response.get("role")); assertEquals(JsonUtil.toJson(roles), response.get("role"));  }
authGetToken(LoginDto loginDto) throws AuthenticationException;
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: AuthenticationException {  String userId = "admin"; String refreshToken = JsonWebTokenUtil.issueJwt(userId, 3600L, Collections.singletonMap("refresh", true));  SurenessAccount account = DefaultAccount.builder("app1") .setPassword(Md5Util.md5(password + salt)) .setSalt(salt) .setOwnRoles(roles) .setDisabledAccount(Boolean.FALSE) .setExcessiveAttempts(Boolean.FALSE) .build(); when(accountProvider.loadAccount(userId)).thenReturn(account);  RefreshTokenResponse response = accountService.refreshToken(refreshToken);  "<AssertPlaceHolder>"; assertNotNull(response.getToken()); assertNotNull(response.getRefreshToken()); }
refreshToken(String refreshToken) throws AuthenticationException;
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testPositiveResolutionByCweId() { Cwe cwe = CweResolver.getInstance().resolve("CWE-79"); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(79, cwe.getCweId()); }
resolve(final String cweString) { final Integer cweId = parseCweString(cweString); if (cweId != null) { final String cweName = CweDictionary.DICTIONARY.get(cweId); if (cweName != null) { final var cwe = new Cwe(); cwe.setCweId(cweId); cwe.setName(cweName); return cwe; } } return null; }
[*] target: assertNotNull(cwe)
[-] pred: org. junit. Assert. assertNotNull ( cwe )
************************************
************************************
[+] input: testPositiveResolutionByCweIdIntegerOnly() { Cwe cwe = CweResolver.getInstance().resolve("79"); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(79, cwe.getCweId()); }
resolve(final String cweString) { final Integer cweId = parseCweString(cweString); if (cweId != null) { final String cweName = CweDictionary.DICTIONARY.get(cweId); if (cweName != null) { final var cwe = new Cwe(); cwe.setCweId(cweId); cwe.setName(cweName); return cwe; } } return null; }
[*] target: assertNotNull(cwe)
[-] pred: org. junit. Assert. assertNotNull ( cwe )
************************************
************************************
[+] input: testEquals() { Tag t1 = new Tag(); t1.setId(111); Tag t2 = new Tag(); t2.setId(222); Tag t3 = new Tag(); t3.setId(111); Assertions.assertFalse(t1.equals(t2)); Assertions."<AssertPlaceHolder>"; }
equals(Object object) { if (object instanceof Tag) { return this.id == ((Tag) object).id; } return false; }
[*] target: assertTrue(t1.equals(t3))
[-] pred: org. junit. Assert. assertTrue ( t1. equals ( t3 ) )
************************************
************************************
[+] input: testVulnerableSoftwareFields() { VulnerableSoftware vs = new VulnerableSoftware(); vs.setPart("a"); vs.setVendor("acme"); vs.setProduct("cool-product"); vs.setVersion("1.1.0"); vs.setUpdate("*"); vs.setEdition("*"); vs.setLanguage("*"); vs.setSwEdition("*"); vs.setTargetSw("*"); vs.setTargetHw("*"); vs.setOther("*"); vs.setVersionEndExcluding("111"); vs.setVersionEndIncluding("222"); vs.setVersionStartExcluding("333"); vs.setVersionStartIncluding("444"); vs.setVulnerable(true); Assertions.assertEquals("a", vs.getPart()); Assertions.assertEquals("acme", vs.getVendor()); Assertions.assertEquals("cool-product", vs.getProduct()); Assertions.assertEquals("1.1.0", vs.getVersion()); Assertions.assertEquals("*", vs.getUpdate()); Assertions.assertEquals("*", vs.getEdition()); Assertions.assertEquals("*", vs.getLanguage()); Assertions.assertEquals("*", vs.getSwEdition()); Assertions.assertEquals("*", vs.getTargetSw()); Assertions.assertEquals("*", vs.getTargetHw()); Assertions.assertEquals("*", vs.getOther()); Assertions.assertEquals("111", vs.getVersionEndExcluding()); Assertions.assertEquals("222", vs.getVersionEndIncluding()); Assertions.assertEquals("333", vs.getVersionStartExcluding()); Assertions.assertEquals("444", vs.getVersionStartIncluding()); Assertions."<AssertPlaceHolder>"; }
isVulnerable() { return vulnerable; }
[*] target: assertTrue(vs.isVulnerable())
[-] pred: org. junit. Assert. assertTrue ( vs. isVulnerable ( ) )
************************************
************************************
[+] input: configProperty() {  entityManager.createNativeQuery(""" INSERT INTO "REPOSITORY" ("ID", "ENABLED", "IDENTIFIER", "INTERNAL", "PASSWORD", "RESOLUTION_ORDER", "TYPE", "URL") VALUES (1, 'true', 'central', 'false', 'null', 2, 'MAVEN', 'https://repo1.maven.org/maven2/'); """).executeUpdate(); entityManager.createNativeQuery(""" INSERT INTO "REPOSITORY" ("ID", "ENABLED", "IDENTIFIER", "INTERNAL", "PASSWORD", "RESOLUTION_ORDER", "TYPE", "URL") VALUES (2, 'true', 'central2', 'false', 'null', 1, 'MAVEN', 'https://repo1.maven.org/maven2/123'); """).executeUpdate(); final List<Repository> config= repository .findEnabledRepositoriesByType(RepositoryType.MAVEN); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(1, config.get(0).getResolutionOrder()); Assertions.assertEquals(2, config.get(1).getResolutionOrder()); }
findEnabledRepositoriesByType(final RepositoryType type) { return find("type = :type AND enabled = :enabled ORDER BY resolutionOrder ASC", Parameters.with("type", type).and("enabled", true)) .withHint(HINT_READ_ONLY, true) .list(); }
[*] target: assertEquals(2, config.size())
[-] pred: org. junit. Assert. assertEquals ( 2, config. size ( ) )
************************************
************************************
[+] input: testInspectEvent_ReturnNull() { PerformanceInspection eventStartInspection = PerformanceInspection.createEventStartInspection("event start"); PerformanceInspectionResult eventStartResult = performanceTestManagementService.inspect(eventStartInspection); Assertions.assertNull(eventStartResult);  PerformanceInspection eventEndInspection = PerformanceInspection.createEventEndInspection("event end"); PerformanceInspectionResult eventEndResult = performanceTestManagementService.inspect(eventEndInspection); Assertions."<AssertPlaceHolder>";  }
inspect(PerformanceInspection performanceInspection) { ITestRun testRun = getTestRun(); return inspect(performanceInspection, testRun); }
[*] target: assertNull(eventEndResult)
[-] pred: org. junit. Assert. assertNull ( eventEndResult )
************************************
************************************
[+] input: Exception { FileInputStream in = new FileInputStream("src/test/resources/directed_acyclic_graph.gexf"); String graphXml = IOUtils.toString(in, StandardCharsets.UTF_8); String path = "0,2,3"; String packageName = "com.microsoft.appmanager"; String deviceType = "android"; String result = T2CJsonGenerator.generateT2CJsonFromGraphXml(graphXml, path, null, packageName, deviceType); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(result.contains("android.widget.Button")); }
generateT2CJsonFromGraphXml(String graphXml, String path, Logger logger, String packageName, String deviceType) throws Exception { if (graphXml == null || graphXml.isEmpty() || path == null || path.isEmpty()) { return null; }  String[] nodes = path.split(","); if (nodes.length < 2) { logger.error("Graph path [" + path + "] is not valid"); return null; }  List<String> elementStrList = new ArrayList<>(); for (int i = 0; i < nodes.length - 1; i++) { String source = nodes[i]; String target = nodes[i + 1]; elementStrList.add(extract(graphXml, source, target)); }  //TODO for other device type return exportT2CJsonForAndroid(elementStrList, packageName); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: attemptTaskIdTest() { String tezTaskAttemptId = "attempt_1677051234358_0091_1_00_000000_0"; TezTaskAttemptID originalTezTaskAttemptID = TezTaskAttemptID.fromString(tezTaskAttemptId); String uniqueIdentifier = String.format("%s_%05d", tezTaskAttemptId, 3); String uniqueIdentifierToAttemptId = RssTezUtils.uniqueIdentifierToAttemptId(uniqueIdentifier); "<AssertPlaceHolder>"; TezTaskAttemptID tezTaskAttemptID = TezTaskAttemptID.fromString(uniqueIdentifierToAttemptId); assertEquals(originalTezTaskAttemptID, tezTaskAttemptID); }
uniqueIdentifierToAttemptId(String uniqueIdentifier) { if (uniqueIdentifier == null) { throw new RssException("uniqueIdentifier should not be null"); } String[] ids = uniqueIdentifier.split("_"); return StringUtils.join(ids, "_", 0, 7); }
[*] target: assertEquals(tezTaskAttemptId, uniqueIdentifierToAttemptId)
[-] pred: org. junit. Assert. assertEquals ( tezTaskAttemptId, uniqueIdentifierToAttemptId )
************************************
************************************
[+] input: Exception { initHadoopSecurityContext();  // write file by proxy user. String fileContent = "hello world"; Path filePath = new Path("/alex/HadoopFilesystemProviderTest-testWriteAndReadBySecuredFilesystem.file"); FileSystem writeFs = HadoopFilesystemProvider.getFilesystem("alex", filePath, kerberizedHadoop.getConf());  boolean ok = writeFs.exists(new org.apache.hadoop.fs.Path("/alex")); "<AssertPlaceHolder>"; assertEquals("alex", writeFs.getFileStatus(new org.apache.hadoop.fs.Path("/alex")).getOwner());  FSDataOutputStream fsDataOutputStream = writeFs.create(filePath); BufferedWriter br = new BufferedWriter(new OutputStreamWriter(fsDataOutputStream, "UTF-8")); br.write(fileContent); br.close();  assertTrue(writeFs.exists(filePath)); assertEquals("alex", writeFs.getFileStatus(filePath).getOwner());  // Read content from HDFS by alex user directly UserGroupInformation readerUGI = UserGroupInformation.loginUserFromKeytabAndReturnUGI( kerberizedHadoop.getAlexPrincipal() + "@" + kerberizedHadoop.getKdc().getRealm(), kerberizedHadoop.getAlexKeytab()); readerUGI.doAs( (PrivilegedExceptionAction<Object>) () -> { FileSystem fs = FileSystem.get(kerberizedHadoop.getConf()); FSDataInputStream inputStream = fs.open(filePath); String fetchedResult = IOUtils.toString(inputStream); assertEquals(fileContent, fetchedResult); return null; }); }
getFilesystem(String user, Path path, Configuration configuration) throws Exception { UserGroupInformation.AuthenticationMethod authenticationMethod = SecurityUtil.getAuthenticationMethod(configuration); boolean needSecurity = authenticationMethod != UserGroupInformation.AuthenticationMethod.SIMPLE;  Callable<FileSystem> callable = () -> FileSystem.get(path.toUri(), configuration);  FileSystem fileSystem; if (needSecurity) { fileSystem = SecurityContextFactory.get().getSecurityContext().runSecured(user, callable); } else { fileSystem = callable.call(); }  if (fileSystem instanceof LocalFileSystem) { if (LOGGER.isDebugEnabled()) { LOGGER.debug("{} is local file system", path); } return ((LocalFileSystem) fileSystem).getRawFileSystem(); }  return fileSystem; }
[*] target: assertTrue(ok)
[-] pred: org. junit. Assert. assertTrue ( ok )
************************************
************************************
[+] input: testParseGroupingKey() { Map<String, String> groupingKey = PrometheusPushGatewayMetricReporter.parseGroupingKey("k1=v1;k2=v2"); "<AssertPlaceHolder>"; assertEquals("v1", groupingKey.get("k1")); assertEquals("v2", groupingKey.get("k2")); }
parseGroupingKey(final String groupingKeyConfig) { Map<String, String> groupingKey = new HashMap<>(); if (!groupingKeyConfig.isEmpty()) { String[] kvs = groupingKeyConfig.split(";"); for (String kv : kvs) { int idx = kv.indexOf("="); if (idx < 0) { LOG.warn("Invalid prometheusPushGateway groupingKey:{}, will be ignored", kv); continue; }  String labelKey = kv.substring(0, idx); String labelValue = kv.substring(idx + 1); if (StringUtils.isEmpty(labelKey) || StringUtils.isEmpty(labelValue)) { LOG.warn( "Invalid groupingKey {labelKey:{}, labelValue:{}} must not be empty", labelKey, labelValue); continue; } groupingKey.put(labelKey, labelValue); }  return groupingKey; }  return groupingKey; }
[*] target: assertNotNull(groupingKey)
[-] pred: org. junit. Assert. assertNotNull ( groupingKey )
************************************
************************************
[+] input: Exception { CoordinatorConf ssc = new CoordinatorConf(); ssc.set( CoordinatorConf.COORDINATOR_SELECT_PARTITION_STRATEGY, AbstractAssignmentStrategy.SelectPartitionStrategyName.ROUND); ssc.setInteger(CoordinatorConf.COORDINATOR_SHUFFLE_NODES_MAX, shuffleNodesMax); try (SimpleClusterManager clusterManager = new SimpleClusterManager(ssc, new Configuration())) { BasicAssignmentStrategy strategy = new BasicAssignmentStrategy(clusterManager, ssc);  for (int i = 0; i < 20; ++i) { clusterManager.add( new ServerNode(String.valueOf(i), "127.0.0." + i, 0, 0, 0, 20 - i, 0, tags)); }  PartitionRangeAssignment pra = strategy.assign(100, 10, 2, tags, -1, -1); SortedMap<PartitionRange, List<ServerNode>> assignments = pra.getAssignments(); "<AssertPlaceHolder>";  for (int i = 0; i < 100; i += 10) { assertTrue(assignments.containsKey(new PartitionRange(i, i + 10))); }  int i = 0; Iterator<List<ServerNode>> ite = assignments.values().iterator(); while (ite.hasNext()) { List<ServerNode> cur = ite.next(); assertEquals(2, cur.size()); assertEquals(String.valueOf(i % shuffleNodesMax), cur.get(0).getId()); i++; assertEquals(String.valueOf(i % shuffleNodesMax), cur.get(1).getId()); i++; } } }
assign( int totalPartitionNum, int partitionNumPerRange, int replica, Set<String> requiredTags, int requiredShuffleServerNumber, int estimateTaskConcurrency) { return assign( totalPartitionNum, partitionNumPerRange, replica, requiredTags, requiredShuffleServerNumber, estimateTaskConcurrency, Sets.newConcurrentHashSet()); }
[*] target: assertEquals(10, assignments.size())
[-] pred: org. junit. Assert. assertEquals ( 10, assignments. size ( ) )
************************************
************************************
[+] input: test() { SortedMap<PartitionRange, List<ServerNode>> sortedMap = new TreeMap<>(); for (int i = 0; i < 9; i = i + 3) { PartitionRange range = new PartitionRange(i, i + 2); List<ServerNode> nodes = Collections.singletonList( new ServerNode( String.valueOf(i), "127.0.0." + i, i / 3, 0, 0, 0, 0, Sets.newHashSet("test"))); sortedMap.put(range, nodes); }  PartitionRangeAssignment partitionRangeAssignment = new PartitionRangeAssignment(sortedMap); List<RssProtos.PartitionRangeAssignment> res = partitionRangeAssignment.convertToGrpcProto(); assertEquals(3, res.size());  for (int i = 0; i < 3; ++i) { RssProtos.PartitionRangeAssignment pra = res.get(i); assertEquals(1, pra.getServerCount()); assertEquals(i, pra.getServer(0).getPort()); assertEquals(3 * i, pra.getStartPartition()); assertEquals(3 * i + 2, pra.getEndPartition()); }  partitionRangeAssignment = new PartitionRangeAssignment(null); res = partitionRangeAssignment.convertToGrpcProto(); "<AssertPlaceHolder>"; }
isEmpty() { return assignments == null || assignments.isEmpty(); }
[*] target: assertTrue(res.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( res. isEmpty() )
************************************
************************************
[+] input: testInitLocalStorageManager() { String[] storagePaths = {"/tmp/rssdata", "/tmp/rssdata2"};  ShuffleServerConf conf = new ShuffleServerConf(); conf.set(ShuffleServerConf.RSS_STORAGE_BASE_PATH, Arrays.asList(storagePaths)); conf.setLong(ShuffleServerConf.DISK_CAPACITY, 1024L); conf.setString( ShuffleServerConf.RSS_STORAGE_TYPE.key(), org.apache.uniffle.storage.util.StorageType.LOCALFILE.name()); LocalStorageManager localStorageManager = new LocalStorageManager(conf);  List<LocalStorage> storages = localStorageManager.getStorages(); "<AssertPlaceHolder>"; assertEquals(storages.size(), storagePaths.length); for (int i = 0; i < storagePaths.length; i++) { assertEquals(storagePaths[i], storages.get(i).getBasePath()); } }
getStorages() { return localStorages; }
[*] target: assertNotNull(storages)
[-] pred: org. junit. Assert. assertNotNull ( storages )
************************************
************************************
[+] input: testGetNextSibling() { Node function = root.getChild(0); Node def = function.getChild(0); Node identifier = function.getChild(1); Assertions.assertNull(root.getNextSibling()); Assertions."<AssertPlaceHolder>"; }
getNextSibling() { return getNextSibling(false); }
[*] target: assertEquals(identifier, def.getNextSibling())
[-] pred: org. junit. Assert. assertEquals ( identifier, def. getNextSibling() )
************************************
************************************
[+] input: testIterator() { Node function = root.getChild(0); Iterator<Node> iterator = function.iterator(); Assertions.assertTrue(iterator.hasNext()); Assertions.assertEquals(function, iterator.next()); for (int i = 0; i < function.getChildCount(); i++) { Assertions.assertTrue(iterator.hasNext()); Assertions.assertEquals(function.getChild(i), iterator.next()); } Assertions.assertTrue(iterator.hasNext()); Iterator<Node> emptyIterator = empty.iterator(); emptyIterator.next(); Assertions."<AssertPlaceHolder>"; Assertions.assertThrows(NoSuchElementException.class, emptyIterator::next); }
hasNext() { return !stack.isEmpty(); }
[*] target: assertFalse(emptyIterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( emptyIterator. hasNext() )
************************************
************************************
[+] input: testExecuteByteRange() { List<Node> comments = body.getChildren().stream() .filter(Node::isNamed) .collect(Collectors.toUnmodifiableList()); @Cleanup QueryCursor cursor = root.walk(query); Assertions.assertFalse(cursor.isExecuted()); for (Node comment: comments) { int lowerByte = comment.getStartByte(); int upperByte = comment.getEndByte(); cursor.setRange(lowerByte, upperByte); Iterator<QueryMatch> iterator = cursor.iterator(); Assertions.assertTrue(cursor.isExecuted()); Assertions.assertTrue(iterator.hasNext()); Assertions.assertNotNull(iterator.next()); Assertions."<AssertPlaceHolder>"; } }
hasNext() { return current != null; }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext() )
************************************
************************************
[+] input: whenObjectAreEquivalent_ThenEqualsReturnsTrue() { GroupId id1 = new GroupId("group@example.com"); GroupId id2 = new GroupId("group@example.com");  assertTrue(id1.equals(id2)); assertEquals(id1.hashCode(), id2.hashCode()); "<AssertPlaceHolder>"; }
compareTo(@NotNull GroupId o) { return this.email.compareTo(o.email); }
[*] target: assertEquals(0, id1.compareTo(id2))
[-] pred: org. junit. Assert. assertEquals ( 0, id1. compareTo ( id2 ) )
************************************
************************************
[+] input: whenObjectAreEquivalentButDifferInCasing_ThenEqualsReturnsTrue() { GroupId id1 = new GroupId("Group@Example.com"); GroupId id2 = new GroupId("group@example.com");  assertTrue(id1.equals(id2)); assertEquals(id1.hashCode(), id2.hashCode()); "<AssertPlaceHolder>"; }
compareTo(@NotNull GroupId o) { return this.email.compareTo(o.email); }
[*] target: assertEquals(0, id1.compareTo(id2))
[-] pred: org. junit. Assert. assertEquals ( 0, id1. compareTo ( id2 ) )
************************************
************************************
[+] input: whenObjectAreSame_ThenEqualsReturnsTrue() { GroupId id1 = new GroupId("group@example.com");  assertTrue(id1.equals(id1)); "<AssertPlaceHolder>"; }
compareTo(@NotNull GroupId o) { return this.email.compareTo(o.email); }
[*] target: assertEquals(0, id1.compareTo(id1))
[-] pred: org. junit. Assert. assertEquals ( 0, id1. compareTo ( id1 ) )
************************************
************************************
[+] input: whenObjectAreEquivalent_ThenEqualsReturnsTrue() { UserId id1 = new UserId("bob@example.com"); UserId id2 = new UserId("bob@example.com");  assertTrue(id1.equals(id2)); assertEquals(id1.hashCode(), id2.hashCode()); "<AssertPlaceHolder>"; }
compareTo(@NotNull UserId o) { return this.email.compareTo(o.email); }
[*] target: assertEquals(0, id1.compareTo(id2))
[-] pred: org. junit. Assert. assertEquals ( 0, id1. compareTo ( id2 ) )
************************************
************************************
[+] input: whenObjectAreEquivalentButDifferInCasing_ThenEqualsReturnsTrue() { UserId id1 = new UserId("Bob@Example.Com"); UserId id2 = new UserId("bob@example.com");  assertTrue(id1.equals(id2)); assertEquals(id1.hashCode(), id2.hashCode()); "<AssertPlaceHolder>"; }
compareTo(@NotNull UserId o) { return this.email.compareTo(o.email); }
[*] target: assertEquals(0, id1.compareTo(id2))
[-] pred: org. junit. Assert. assertEquals ( 0, id1. compareTo ( id2 ) )
************************************
************************************
[+] input: whenObjectAreSame_ThenEqualsReturnsTrue() { UserId id1 = new UserId("bob@example.com");  assertTrue(id1.equals(id1)); "<AssertPlaceHolder>"; }
compareTo(@NotNull UserId o) { return this.email.compareTo(o.email); }
[*] target: assertEquals(0, id1.compareTo(id1))
[-] pred: org. junit. Assert. assertEquals ( 0, id1. compareTo ( id1 ) )
************************************
************************************
[+] input: whenObjectAreEquivalent_ThenEqualsReturnsTrue() { SampleEntitlementId id1 = new SampleEntitlementId("cat", "jit-1"); SampleEntitlementId id2 = new SampleEntitlementId("cat", "jit-1");  assertTrue(id1.equals(id2)); "<AssertPlaceHolder>"; }
hashCode() { return id().hashCode(); }
[*] target: assertEquals(id1.hashCode(), id2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( id1. hashCode ( ), id2. hashCode ( ) )
************************************
************************************
[+] input: whenObjectAreEquivalent_ThenEqualsReturnsTrue() { GroupKey id1 = new GroupKey("group-1"); GroupKey id2 = new GroupKey("group-1");  assertTrue(id1.equals(id2)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(this.id); }
[*] target: assertEquals(id1.hashCode(), id2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( id1. hashCode ( ), id2. hashCode ( ) )
************************************
************************************
[+] input: testGetClassesInPackage() { final ClassTreeHelper classTreeHelper = new ClassTreeHelper();  final FilterableTreeItem<ClassTreeNode> root = buildClassTree();  final List<LoadedClass> classesInPackage = classTreeHelper.getClassesInPackage(root, "org", null);  Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(classesInPackage.stream().allMatch(c -> c.getName().startsWith("org"))); }
getClassesInPackage(FilterableTreeItem<ClassTreeNode> classesTreeRoot, String fullPackageName, ClassLoaderDescriptor packageClassLoader) { return classesTreeRoot.streamVisible() .filter(p -> p.getType() == ClassTreeNode.Type.CLASS) .map(ClassTreeNode::getLoadedClass) .filter(c -> c.getName().startsWith(fullPackageName)) .filter(c -> (packageClassLoader == null) || packageClassLoader.equals(c.getClassLoaderDescriptor())) .collect(Collectors.toList()); }
[*] target: assertEquals(2, classesInPackage.size())
[-] pred: org. junit. Assert. assertEquals ( 2, classesInPackage. size ( ) )
************************************
************************************
[+] input: IOException { final ExportHelper exportHelper = new ExportHelper(clientHandler); final ClassLoaderDescriptor classLoaderDescriptor = ClassLoaderDescriptor.builder().build(); final List<LoadedClass> classesToExport = List.of(new LoadedClass("org.test.MyClass", null, null), new LoadedClass("org.othertest.SomeClass", classLoaderDescriptor, null), new LoadedClass("testing.Export", classLoaderDescriptor, null));  final Map<String, byte[]> classData = classesToExport.stream() .collect(Collectors.toMap(LoadedClass::getName, l -> generateClassBytes()));  Mockito.when(clientHandler.getClassBytes(ArgumentMatchers.eq(JVM), ArgumentMatchers.any())) .thenAnswer(ctx -> classData.get(ctx.getArgument(1, LoadedClass.class).getName()));  final File outputFile = File.createTempFile("export", ".jar"); final AtomicInteger exportCount = new AtomicInteger();  final boolean success = exportHelper.export(JVM, classesToExport, outputFile, exportCount::set);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(classesToExport.size(), exportCount.get());  final JarFile jarFile = new JarFile(outputFile); final List<JarEntry> jarEntries = jarFile.stream() .filter(entry -> entry.getName().endsWith(".class")) .collect(Collectors.toList()); Assertions.assertEquals(jarEntries.size(), classesToExport.size());  for (JarEntry jarEntry : jarEntries) { final byte[] jarClassFile = jarFile.getInputStream(jarEntry).readAllBytes(); final byte[] baseClassFile = classData.get(jarEntry.getName().replace('/', '.').replace(".class", "")); Assertions.assertArrayEquals(baseClassFile, jarClassFile); } }
export(RunningJvm jvm, List<LoadedClass> loadedClasses, File outputJar, Consumer<Integer> currentProgress) { log.debug("Exporting {} files in {} to {}", loadedClasses.size(), jvm, outputJar); try { Files.deleteIfExists(outputJar.toPath()); Files.createFile(outputJar.toPath()); } catch (IOException e) { log.warn("Failed to create initial file for export", e); return false; } final AtomicInteger count = new AtomicInteger(); try (JarOutputStream jarOutputStream = new JarOutputStream(Files.newOutputStream(outputJar.toPath()))) { // Note - parallel stream runs in common fork join pool despite these being io bound tasks loadedClasses.stream() .parallel() .map(loadedClass -> new Pair<>(loadedClass, clientHandler.getClassBytes(jvm, loadedClass))) .forEach(pair -> { log.debug("Exporting: {}", loadedClasses); synchronized (count) { // Possible race condition - count could be incremented before another thread, but the // other thread could run currentProgress first. Therefore, we synchronize. currentProgress.accept(count.incrementAndGet()); } final String name = pair.getKey().getName().replace('.', '/') + ".class"; final byte[] content = pair.getValue(); write(name, content, jarOutputStream); }); log.debug("Jar created: {} with {} classes", outputJar, count.get()); return true; } catch (IOException | UncheckedIOException e) { log.warn("Failed to export", e); return false; } }
[*] target: assertTrue(success)
[-] pred: org. junit. Assert. assertTrue ( success )
************************************
************************************
[+] input: Exception { final PatchHelper patchHelper = new PatchHelper();  final File jarFile = JarTestHelper.buildJar(Startup.class); final AtomicInteger patchedClasses = new AtomicInteger();  Mockito.when(clientHandler.replaceClass(ArgumentMatchers.any(), ArgumentMatchers.any(), ArgumentMatchers.any())) .thenReturn(PatchResult.builder().success(true).build());  final boolean success = patchHelper.patch(jarFile, JVM, clientHandler, null, patchedClasses::set);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(1, patchedClasses.get());  Mockito.verify(clientHandler, Mockito.times(patchedClasses.get())) .replaceClass(ArgumentMatchers.eq(JVM), ArgumentMatchers.any(), ArgumentMatchers.any()); }
patch(File jarFile, RunningJvm runningJvm, ClientHandler clientHandler, ClassLoaderDescriptor classLoaderDescriptor, Consumer<Integer> patchedClasses) { log.debug("Attempting to patch {} with {}", runningJvm, jarFile); final AtomicInteger patchedClassCount = new AtomicInteger(); try (final JarFile jar = new JarFile(jarFile)) { jar.stream().parallel().filter(j -> j.getName().endsWith(".class")).forEach(classFile -> { try { final String name = classFile.getName().replace('/', '.').replace(".class", ""); log.debug("Patching {}", name); final byte[] classContents = jar.getInputStream(classFile).readAllBytes(); // Note - we may not always want to pass in the class loader. It could be in a child classloader. final LoadedClass loadedClass = new LoadedClass(name, classLoaderDescriptor, null); final PatchResult result = clientHandler.replaceClass(runningJvm, loadedClass, classContents); if (!result.isSuccess()) { throw new IllegalStateException( "Failed to replace class on jvm: " + name + " because " + result.getMessage()); } } catch (IOException e) { log.warn("Failed to process {}", classFile.getName()); throw new UncheckedIOException(e); } synchronized (patchedClassCount) { patchedClasses.accept(patchedClassCount.incrementAndGet()); } }); return true; } catch (IOException | UncheckedIOException | IllegalStateException e) { log.warn("Failed to patch {} with {}", runningJvm, jarFile, e); return false; } }
[*] target: assertTrue(success)
[-] pred: org. junit. Assert. assertTrue ( success )
************************************
************************************
[+] input: testGetGitHash() { String gitHash = VersionUtil.getGitHash(); "<AssertPlaceHolder>"; assertNotEquals("unknown", gitHash); assertFalse(gitHash.isEmpty()); }
getGitHash() { return GIT_HASH; }
[*] target: assertNotNull(gitHash)
[-] pred: org. junit. Assert. assertNotNull ( gitHash )
************************************
************************************
[+] input: byDefault() {  final String[] args = { };  Options options = OptionsUtil.parse(Options.class, args);  "<AssertPlaceHolder>"; assertEquals(options.getWindowType(), WindowType.TUMBLING); assertEquals(options.getName(), "foo"); }
parse(final Class<T> optionsClass, final String[] args) {  final T options = create(optionsClass);  JCommander jCommander = JCommander.newBuilder() .addObject(options) .build();  //easiest way to set configuration through docker. //similar to how Confluent does this in their Docker images. OptionsUtil.populateByEnvironment(options);  jCommander.parse(args);  if (options.isHelp()) { jCommander.usage(); return null; }  return options; }
[*] target: assertNotNull(options)
[-] pred: org. junit. Assert. assertNotNull ( options )
************************************
************************************
[+] input: byArguments() {  final String[] args = { "--window-type", "HOPPING", "--name", "bar" };  Options options = OptionsUtil.parse(Options.class, args);  "<AssertPlaceHolder>"; assertEquals(options.getWindowType(), WindowType.HOPPING); assertEquals(options.getName(), "bar"); }
parse(final Class<T> optionsClass, final String[] args) {  final T options = create(optionsClass);  JCommander jCommander = JCommander.newBuilder() .addObject(options) .build();  //easiest way to set configuration through docker. //similar to how Confluent does this in their Docker images. OptionsUtil.populateByEnvironment(options);  jCommander.parse(args);  if (options.isHelp()) { jCommander.usage(); return null; }  return options; }
[*] target: assertNotNull(options)
[-] pred: org. junit. Assert. assertNotNull ( options )
************************************
************************************
[+] input: IllegalAccessException { LocalS3Router localS3Router = new LocalS3Router();  HttpRequestHandler handler1 = mock(HttpRequestHandler.class, "handler1"); localS3Router.route(Route.builder() .method(HttpMethod.GET).path("/a") .paramMatcher(params -> params.containsKey("versioning")) .handler(handler1) .build());  HttpRequestHandler handler2 = mock(HttpRequestHandler.class, "handler2"); localS3Router.route(Route.builder() .method(HttpMethod.GET).path("/a") .paramMatcher(params -> params.containsKey("versioning")) .headerMatcher(headers -> headers.containsKey("x-header")) .handler(handler2) .build());  HttpRequestHandler matchedHandler1 = localS3Router.match(HttpRequest.builder() .method(HttpMethod.GET).path("/a") .params(Map.of("versioning", List.of("true"))) .build()); "<AssertPlaceHolder>";  HttpRequestHandler matchedHandler2 = localS3Router.match(HttpRequest.builder() .method(HttpMethod.GET).path("/a") .params(Map.of("versioning", List.of("true"))) .headers(Map.of("x-header", "value")) .build()); assertSame(handler2, matchedHandler2); }
route(Route rule) { this.rules.putIfAbsent(rule.getMethod(), new HashMap<>()); Map<String, List<Route>> pathRules = this.rules.get(rule.getMethod()); pathRules.putIfAbsent(rule.getPath(), new ArrayList<>()); List<Route> routes = pathRules.get(rule.getPath()); routes.add(rule); return this; }
[*] target: assertSame(handler1, matchedHandler1)
[-] pred: org. junit. Assert. assertSame ( handler1, matchedHandler1 )
************************************
************************************
[+] input: testCreateSingle() { // // Setup Test Data and Interactions // Mockito.when(mockMonitoredServiceRepository.findByTenantIdTypeAndIpInterface( TEST_TENANT_ID, monitorType, testIpInterface)) .thenReturn(Optional.empty()); // // Execute // MonitoredService result = target.createSingle(testIpInterface, monitorType);  // // Verify the Results // "<AssertPlaceHolder>"; assertSame(testMonitoredService1.getTenantId(), result.getTenantId()); assertSame(testMonitoredService1.getMonitorType(), result.getMonitorType()); }
createSingle(IpInterface ipInterface, String monitorType) {  Optional<MonitoredService> monitoredServiceOpt = modelRepo.findByTenantIdTypeAndIpInterface(ipInterface.getTenantId(), monitorType, ipInterface);  if (monitoredServiceOpt.isEmpty()) {  MonitoredService monitoredService = new MonitoredService(); monitoredService.setTenantId(ipInterface.getTenantId()); monitoredService.setIpInterface(ipInterface); monitoredService.setMonitorType(monitorType);  modelRepo.save(monitoredService); return monitoredService; } return monitoredServiceOpt.get(); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testGetByIdAndTenantId() { // Mock data long id = 1L; MonitoringLocation monitoringLocation = new MonitoringLocation(); when(modelRepo.findByIdAndTenantId(id, TENANT_ID)).thenReturn(Optional.of(monitoringLocation)); when(mapper.modelToDTO(any(MonitoringLocation.class))) .thenReturn(MonitoringLocationDTO.newBuilder().build());  // Test Optional<MonitoringLocationDTO> result = monitoringLocationService.getByIdAndTenantId(id, TENANT_ID);  // Assertions "<AssertPlaceHolder>"; assertTrue(result.isPresent()); verify(modelRepo, times(1)).findByIdAndTenantId(id, TENANT_ID); verify(mapper, times(1)).modelToDTO(any(MonitoringLocation.class)); }
getByIdAndTenantId(long id, String tenantId) { return modelRepo.findByIdAndTenantId(id, tenantId).map(mapper::modelToDTO); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: detectSNMP() { SnmpAgentConfig config1 = new SnmpAgentConfig(InetAddressUtils.getInetAddress("127.0.0.1"), SnmpConfiguration.DEFAULTS); SnmpAgentConfig config2 = new SnmpAgentConfig(InetAddressUtils.getInetAddress("192.168.1.1"), SnmpConfiguration.DEFAULTS); List<SnmpAgentConfig> configs = Arrays.asList(config1, config2);  SnmpValue[] snmpValues1 = new SnmpValue[] {new Snmp4JValue(new Integer32(1))}; SnmpValue[] snmpValues2 = new SnmpValue[0];  when(snmpHelper.getAsync(config1, new SnmpObjId[] {SnmpObjId.get(SnmpHelper.SYS_OBJECTID_INSTANCE)})) .thenReturn(CompletableFuture.completedFuture(snmpValues1)); when(snmpHelper.getAsync(config2, new SnmpObjId[] {SnmpObjId.get(SnmpHelper.SYS_OBJECTID_INSTANCE)})) .thenReturn(CompletableFuture.completedFuture(snmpValues2));  List<SnmpAgentConfig> detectedConfigs = snmpConfigDiscovery.getDiscoveredConfig(configs);  "<AssertPlaceHolder>"; assertEquals(config1, detectedConfigs.get(0));  verify(snmpHelper, times(2)).getAsync(any(), any()); }
getDiscoveredConfig(List<SnmpAgentConfig> configs) {  List<SnmpAgentConfig> detectedConfigs = new ArrayList<>(); var futures = configs.stream().map(this::detectConfig).toList(); var allFutures = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])); // Join all the results. CompletableFuture<List<Optional<SnmpAgentConfig>>> results = allFutures.thenApply( agentConfig -> futures.stream().map(CompletableFuture::join).collect(Collectors.toList())); try { var timeout = findMaxTimeout(configs); var validConfigs = results.get(timeout, TimeUnit.MILLISECONDS); detectedConfigs.addAll( validConfigs.stream().flatMap(Optional::stream).toList()); } catch (InterruptedException | ExecutionException | TimeoutException e) { if (LOG.isDebugEnabled()) { LOG.debug("Exception while executing config discovery", e); } else { LOG.error("Exception while executing config discovery {}", e.getMessage()); } }  return detectedConfigs; }
[*] target: assertEquals(1, detectedConfigs.size())
[-] pred: org. junit. Assert. assertEquals ( 1, detectedConfigs. size ( ) )
************************************
************************************
[+] input: givenPrePersistedCategories_whenCallsExistsByIds_shouldReturnIds() { // given final var filmes = Category.newCategory("Filmes", "A categoria mais assistida", true); final var series = Category.newCategory("Séries", "Uma categoria assistida", true); final var documentarios = Category.newCategory("Documentários", "A categoria menos assistida", true);  Assertions.assertEquals(0, categoryRepository.count());  categoryRepository.saveAll(List.of( CategoryJpaEntity.from(filmes), CategoryJpaEntity.from(series), CategoryJpaEntity.from(documentarios) ));  Assertions.assertEquals(3, categoryRepository.count());  final var expectedIds = List.of(filmes.getId(), series.getId());  final var ids = List.of(filmes.getId(), series.getId(), CategoryID.from("123"));  // when final var actualResult = categoryGateway.existsByIds(ids);  Assertions."<AssertPlaceHolder>"; }
existsByIds(final Iterable<CategoryID> categoryIDs) { final var ids = StreamSupport.stream(categoryIDs.spliterator(), false) .map(CategoryID::getValue) .toList(); return this.repository.existsByIds(ids).stream() .map(CategoryID::from) .toList(); }
[*] target: assertEquals(expectedIds, actualResult)
[-] pred: org. junit. Assert. assertEquals ( expectedIds, actualResult )
************************************
************************************
[+] input: IOException { URL codeSourceLocation = null; assertNull(codeSourceLocation);  codeSourceLocation = repository.getCodeSourceLocation(ClassDataRepositoryTest.class); info("codeSourceLocation : " + codeSourceLocation); assertNotNull(codeSourceLocation);  codeSourceLocation = repository.getCodeSourceLocation(Nonnull.class); info("codeSourceLocation : " + codeSourceLocation); "<AssertPlaceHolder>";  }
getCodeSourceLocation(Class<?> type) throws NullPointerException {  URL codeSourceLocation = null; ClassLoader classLoader = type.getClassLoader();  if (classLoader == null) { // Bootstrap ClassLoader or type is primitive or void String path = findClassPath(type); if (isNotBlank(path)) { try { codeSourceLocation = new File(path).toURI().toURL(); } catch (MalformedURLException ignored) { codeSourceLocation = null; } } } else { ProtectionDomain protectionDomain = type.getProtectionDomain(); CodeSource codeSource = protectionDomain == null ? null : protectionDomain.getCodeSource(); codeSourceLocation = codeSource == null ? null : codeSource.getLocation(); } return codeSourceLocation; }
[*] target: assertNotNull(codeSourceLocation)
[-] pred: org. junit. Assert. assertNotNull ( codeSourceLocation )
************************************
************************************
[+] input: testResolvePath() { String path = null; String expectedPath = null; String resolvedPath = null;  resolvedPath = normalizePath(path); assertEquals(expectedPath, resolvedPath);  path = ""; expectedPath = ""; resolvedPath = normalizePath(path); assertEquals(expectedPath, resolvedPath);  path = "/abc/"; expectedPath = "/abc/"; resolvedPath = normalizePath(path); assertEquals(expectedPath, resolvedPath);  path = "//abc///"; expectedPath = "/abc/"; resolvedPath = normalizePath(path); assertEquals(expectedPath, resolvedPath);   path = "//\\abc///"; expectedPath = "/abc/"; resolvedPath = normalizePath(path); "<AssertPlaceHolder>"; }
normalizePath(final String path) {  if (isBlank(path)) { return path; }  String resolvedPath = path.trim();  while (resolvedPath.contains(BACK_SLASH)) { resolvedPath = replace(resolvedPath, BACK_SLASH, SLASH); }  while (resolvedPath.contains(DOUBLE_SLASH)) { resolvedPath = replace(resolvedPath, DOUBLE_SLASH, SLASH); } return resolvedPath; }
[*] target: assertEquals(expectedPath, resolvedPath)
[-] pred: org. junit. Assert. assertEquals ( expectedPath, resolvedPath )
************************************
************************************
[+] input: testResolveQueryParameters() { String url = "https://www.google.com.hk/search?q=java&oq=java&sourceid=chrome&es_sm=122&ie=UTF-8"; Map<String, List<String>> parametersMap = resolveQueryParameters(url); Map<String, List<String>> expectedParametersMap = new LinkedHashMap<>(); expectedParametersMap.put("q", Arrays.asList("java")); expectedParametersMap.put("oq", Arrays.asList("java")); expectedParametersMap.put("sourceid", Arrays.asList("chrome")); expectedParametersMap.put("es_sm", Arrays.asList("122")); expectedParametersMap.put("ie", Arrays.asList("UTF-8"));  assertEquals(expectedParametersMap, parametersMap);  url = "https://www.google.com.hk/search"; parametersMap = resolveQueryParameters(url); expectedParametersMap = emptyMap(); assertEquals(expectedParametersMap, parametersMap);  url = "https://www.google.com.hk/search?"; parametersMap = resolveQueryParameters(url); expectedParametersMap = emptyMap(); "<AssertPlaceHolder>"; }
resolveQueryParameters(String url) { String queryString = substringAfterLast(url, QUERY_STRING); return resolveParameters(queryString, AND_CHAR); }
[*] target: assertEquals(expectedParametersMap, parametersMap)
[-] pred: org. junit. Assert. assertEquals ( expectedParametersMap, parametersMap )
************************************
************************************
[+] input: testResolveMatrixParameters() { String url = "https://www.google.com.hk/search;q=java;oq=java;sourceid=chrome;es_sm=122;ie=UTF-8"; Map<String, List<String>> parametersMap = resolveMatrixParameters(url); Map<String, List<String>> expectedParametersMap = new LinkedHashMap<>(); expectedParametersMap.put("q", Arrays.asList("java")); expectedParametersMap.put("oq", Arrays.asList("java")); expectedParametersMap.put("sourceid", Arrays.asList("chrome")); expectedParametersMap.put("es_sm", Arrays.asList("122")); expectedParametersMap.put("ie", Arrays.asList("UTF-8"));  assertEquals(expectedParametersMap, parametersMap);  url = "https://www.google.com.hk/search"; parametersMap = resolveMatrixParameters(url); expectedParametersMap = emptyMap(); assertEquals(expectedParametersMap, parametersMap);  url = "https://www.google.com.hk/search;"; parametersMap = resolveMatrixParameters(url); expectedParametersMap = emptyMap(); "<AssertPlaceHolder>"; }
resolveMatrixParameters(String url) { int startIndex = url.indexOf(SEMICOLON_CHAR); if (startIndex == -1) { // The matrix separator ";" was not found return emptyMap(); }  int endIndex = url.indexOf(QUERY_STRING_CHAR); if (endIndex == -1) { // The query string separator "?" was not found endIndex = url.indexOf(SHARP_CHAR); } if (endIndex == -1) { // The fragment separator "#" was not found endIndex = url.length(); }  String matrixString = url.substring(startIndex, endIndex);  return resolveParameters(matrixString, SEMICOLON_CHAR); }
[*] target: assertEquals(expectedParametersMap, parametersMap)
[-] pred: org. junit. Assert. assertEquals ( expectedParametersMap, parametersMap )
************************************
************************************
[+] input: testToList() { int[] intArray = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9}; List<Integer> list = ReflectionUtils.toList(intArray); Object expectedList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); assertEquals(expectedList, list);   int[][] intIntArray = new int[][]{{1, 2, 3}, {4, 5, 6,}, {7, 8, 9}}; list = ReflectionUtils.toList(intIntArray); expectedList = Arrays.asList(Arrays.asList(1, 2, 3), Arrays.asList(4, 5, 6), Arrays.asList(7, 8, 9)); "<AssertPlaceHolder>"; }
toList(Object array) throws IllegalArgumentException { int length = Array.getLength(array); List<T> list = new ArrayList<>(length); for (int i = 0; i < length; i++) { Object element = Array.get(array, i); list.add((T) toObject(element)); } return list; }
[*] target: assertEquals(expectedList, list)
[-] pred: org. junit. Assert. assertEquals ( expectedList, list )
************************************
************************************
[+] input: testResolve() { String resourceName = "META-INF/abc/def"; String expectedResourceName = "META-INF/abc/def"; String resolvedResourceName = DEFAULT.resolve(resourceName); assertEquals(expectedResourceName, resolvedResourceName);  resourceName = "///////META-INF//abc\\/def"; resolvedResourceName = DEFAULT.resolve(resourceName); assertEquals(expectedResourceName, resolvedResourceName);  resourceName = "java.lang.String.class";  expectedResourceName = "java/lang/String.class"; resolvedResourceName = CLASS.resolve(resourceName); assertEquals(expectedResourceName, resolvedResourceName);  resourceName = "java.lang"; expectedResourceName = "java/lang/"; resolvedResourceName = PACKAGE.resolve(resourceName); "<AssertPlaceHolder>";  }
resolve(String name) { String normalizedName = supported(name) ? normalize(name) : null; if (normalizedName == null) return normalizedName;  normalizedName = URLUtils.normalizePath(normalizedName);  // 除去开头的"/" while (normalizedName.startsWith("/")) { normalizedName = normalizedName.substring(1); }  return normalizedName; }
[*] target: assertEquals(expectedResourceName, resolvedResourceName)
[-] pred: org. junit. Assert. assertEquals ( expectedResourceName, resolvedResourceName )
************************************
************************************
[+] input: testGetInheritableClassLoaders() { Set<ClassLoader> classLoaders = getInheritableClassLoaders(classLoader); "<AssertPlaceHolder>"; assertTrue(classLoaders.size() > 1); info(classLoaders); }
getInheritableClassLoaders(ClassLoader classLoader) throws NullPointerException { Set<ClassLoader> classLoadersSet = new LinkedHashSet(); classLoadersSet.add(classLoader); ClassLoader parentClassLoader = classLoader.getParent(); while (parentClassLoader != null) { classLoadersSet.add(parentClassLoader); parentClassLoader = parentClassLoader.getParent(); } return unmodifiableSet(classLoadersSet); }
[*] target: assertNotNull(classLoaders)
[-] pred: org. junit. Assert. assertNotNull ( classLoaders )
************************************
************************************
[+] input: testGetBootstrapClassPaths() { Set<String> bootstrapClassPaths = getBootstrapClassPaths(); "<AssertPlaceHolder>"; RuntimeMXBean runtimeMXBean = getRuntimeMXBean(); assertEquals(runtimeMXBean.isBootClassPathSupported(), !bootstrapClassPaths.isEmpty()); info(bootstrapClassPaths); }
getBootstrapClassPaths() { return bootstrapClassPaths; }
[*] target: assertNotNull(bootstrapClassPaths)
[-] pred: org. junit. Assert. assertNotNull ( bootstrapClassPaths )
************************************
************************************
[+] input: testEquals() { WorkspaceMeta w1 = new WorkspaceMeta("/nonexist"); WorkspaceMeta w2 = new WorkspaceMeta("/nonexist"); WorkspaceMeta w3 = new WorkspaceMeta("/nonexist/"); Assertions.assertTrue(w1.equals(w2)); Assertions."<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; WorkspaceMeta that = (WorkspaceMeta) o; return Objects.equals(new File(baseDirPath), new File(that.baseDirPath)); }
[*] target: assertTrue(w1.equals(w3))
[-] pred: org. junit. Assert. assertTrue ( w1. equals ( w3 ) )
************************************
************************************
[+] input: testBasic() {  String expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  category = 'apple'\n" + "  AND price < 500";  XMLMapperBuilder builder = new XMLMapperBuilder(LoadXmlUtil.load("basic-fruits.xml")); Map<String, SqlSource> sqlSourceMap = builder.parse(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sqlSourceMap.containsKey("fruit.testBasic"));  SqlSource sqlSource = sqlSourceMap.get("fruit.testBasic");  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), null));  }
parse() {  Map<String, SqlSource> sqlSourceMap = new HashMap<>();  XNode context = this.parser.evalNode("/mapper");  String namespace = context.getStringAttribute("namespace");  sqlElement(context.evalNodes("/mapper/sql"));  List<XNode> statements = context.evalNodes("select|insert|update|delete");  for (XNode node : statements) {  XMLStatementBuilder statementBuilder = new XMLStatementBuilder(node, sqlFragments); SqlSource sqlSource = statementBuilder.parseStatementNode();  String id = node.getStringAttribute("id"); String methodName = (namespace == null || namespace.length() == 0) ? id : String.format("%s.%s", namespace, id);  sqlSourceMap.put(methodName, sqlSource); }  return sqlSourceMap;  }
[*] target: assertNotNull(sqlSourceMap)
[-] pred: org. junit. Assert. assertNotNull ( sqlSourceMap )
************************************
************************************
[+] input: testBind() {  String expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  name LIKE '%testBind%'";  XMLMapperBuilder builder = new XMLMapperBuilder(LoadXmlUtil.load("bind-fruits.xml")); Map<String, SqlSource> sqlSourceMap = builder.parse(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sqlSourceMap.containsKey("fruit.testBind"));  SqlSource sqlSource = sqlSourceMap.get("fruit.testBind");  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"name": "testBind"}"));  }
parse() {  Map<String, SqlSource> sqlSourceMap = new HashMap<>();  XNode context = this.parser.evalNode("/mapper");  String namespace = context.getStringAttribute("namespace");  sqlElement(context.evalNodes("/mapper/sql"));  List<XNode> statements = context.evalNodes("select|insert|update|delete");  for (XNode node : statements) {  XMLStatementBuilder statementBuilder = new XMLStatementBuilder(node, sqlFragments); SqlSource sqlSource = statementBuilder.parseStatementNode();  String id = node.getStringAttribute("id"); String methodName = (namespace == null || namespace.length() == 0) ? id : String.format("%s.%s", namespace, id);  sqlSourceMap.put(methodName, sqlSource); }  return sqlSourceMap;  }
[*] target: assertNotNull(sqlSourceMap)
[-] pred: org. junit. Assert. assertNotNull ( sqlSourceMap )
************************************
************************************
[+] input: testChoose() {  XMLMapperBuilder builder = new XMLMapperBuilder(LoadXmlUtil.load("choose-fruits.xml")); Map<String, SqlSource> sqlSourceMap = builder.parse(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sqlSourceMap.containsKey("fruit.testChoose"));  SqlSource sqlSource = sqlSourceMap.get("fruit.testChoose");  String expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  name = 'testChoose'";   Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"name": "testChoose"}"));  expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  name = 'testBind'";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"name": "testBind"}"));  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"name": "testBind", "category": "apple"}"));  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"name": "testBind", "category": "banana"}"));  expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  category = 'banana'";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"category": "banana"}"));  expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  category = 'banana'\n" + "  AND price = 10.00";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"category": "banana", "price": 10.00}"));  expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  category = 'apple'"; Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), null)); }
parse() {  Map<String, SqlSource> sqlSourceMap = new HashMap<>();  XNode context = this.parser.evalNode("/mapper");  String namespace = context.getStringAttribute("namespace");  sqlElement(context.evalNodes("/mapper/sql"));  List<XNode> statements = context.evalNodes("select|insert|update|delete");  for (XNode node : statements) {  XMLStatementBuilder statementBuilder = new XMLStatementBuilder(node, sqlFragments); SqlSource sqlSource = statementBuilder.parseStatementNode();  String id = node.getStringAttribute("id"); String methodName = (namespace == null || namespace.length() == 0) ? id : String.format("%s.%s", namespace, id);  sqlSourceMap.put(methodName, sqlSource); }  return sqlSourceMap;  }
[*] target: assertNotNull(sqlSourceMap)
[-] pred: org. junit. Assert. assertNotNull ( sqlSourceMap )
************************************
************************************
[+] input: testAdvancedForeach() { XMLMapperBuilder builder = new XMLMapperBuilder(LoadXmlUtil.load("foreach-advanced-fruits.xml")); Map<String, SqlSource> sqlSourceMap = builder.parse(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sqlSourceMap.containsKey("fruit.testInsertMulti"));  SqlSource sqlSource = sqlSourceMap.get("fruit.testInsertMulti");  String expectedSql = "INSERT INTO\n" + "  fruits (name, category, price)\n" + "VALUES\n" + "  ('Jonathan', 'apple', 10.00)";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"fruits":[{"name": "Jonathan", "price": 10.00, "category": "apple"}]}"));  expectedSql = "INSERT INTO\n" + "  fruits (name, category, price)\n" + "VALUES\n" + "  ('Jonathan', 'apple', 10.00),\n" + "  ('Mcintosh', 'apple', 12.00)";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"fruits":[{"name": "Jonathan", "price": 10.00, "category": "apple"},{"name": "Mcintosh", "price": 12.00, "category": "apple"}]}"));  }
parse() {  Map<String, SqlSource> sqlSourceMap = new HashMap<>();  XNode context = this.parser.evalNode("/mapper");  String namespace = context.getStringAttribute("namespace");  sqlElement(context.evalNodes("/mapper/sql"));  List<XNode> statements = context.evalNodes("select|insert|update|delete");  for (XNode node : statements) {  XMLStatementBuilder statementBuilder = new XMLStatementBuilder(node, sqlFragments); SqlSource sqlSource = statementBuilder.parseStatementNode();  String id = node.getStringAttribute("id"); String methodName = (namespace == null || namespace.length() == 0) ? id : String.format("%s.%s", namespace, id);  sqlSourceMap.put(methodName, sqlSource); }  return sqlSourceMap;  }
[*] target: assertNotNull(sqlSourceMap)
[-] pred: org. junit. Assert. assertNotNull ( sqlSourceMap )
************************************
************************************
[+] input: testBasicForeach() { XMLMapperBuilder builder = new XMLMapperBuilder(LoadXmlUtil.load("foreach-basic-fruits.xml")); Map<String, SqlSource> sqlSourceMap = builder.parse(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sqlSourceMap.containsKey("fruit.testForeach"));  SqlSource sqlSource = sqlSourceMap.get("fruit.testForeach");  String expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  category = 'apple'\n" + "  AND (name = 'Jonathan')";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"apples":["Jonathan", "Mcintosh"]}"));  expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  category = 'apple'\n" + "  AND (\n" + "    name = 'Jonathan'\n" + "    OR name = 'Fuji'\n" + "  )";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"apples":["Jonathan","Mcintosh", "Fuji"]}"));  expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  category = 'apple'\n" + "  AND ()";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"apples":["Mcintosh"]}")); }
parse() {  Map<String, SqlSource> sqlSourceMap = new HashMap<>();  XNode context = this.parser.evalNode("/mapper");  String namespace = context.getStringAttribute("namespace");  sqlElement(context.evalNodes("/mapper/sql"));  List<XNode> statements = context.evalNodes("select|insert|update|delete");  for (XNode node : statements) {  XMLStatementBuilder statementBuilder = new XMLStatementBuilder(node, sqlFragments); SqlSource sqlSource = statementBuilder.parseStatementNode();  String id = node.getStringAttribute("id"); String methodName = (namespace == null || namespace.length() == 0) ? id : String.format("%s.%s", namespace, id);  sqlSourceMap.put(methodName, sqlSource); }  return sqlSourceMap;  }
[*] target: assertNotNull(sqlSourceMap)
[-] pred: org. junit. Assert. assertNotNull ( sqlSourceMap )
************************************
************************************
[+] input: testIf() { XMLMapperBuilder builder = new XMLMapperBuilder(LoadXmlUtil.load("if-fruits.xml")); Map<String, SqlSource> sqlSourceMap = builder.parse(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sqlSourceMap.containsKey("fruit.testIf"));  SqlSource sqlSource = sqlSourceMap.get("fruit.testIf");  String expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  1 = 1\n" + "  AND category = 'apple'\n" + "  AND price = 100.0";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"price": 100.0, "category": "apple"}"));  expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  1 = 1\n" + "  AND category = 'apple'\n" + "  AND price = 500.0\n" + "  AND name = 'Fuji'";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"price": 500.0, "category": "apple"}")); }
parse() {  Map<String, SqlSource> sqlSourceMap = new HashMap<>();  XNode context = this.parser.evalNode("/mapper");  String namespace = context.getStringAttribute("namespace");  sqlElement(context.evalNodes("/mapper/sql"));  List<XNode> statements = context.evalNodes("select|insert|update|delete");  for (XNode node : statements) {  XMLStatementBuilder statementBuilder = new XMLStatementBuilder(node, sqlFragments); SqlSource sqlSource = statementBuilder.parseStatementNode();  String id = node.getStringAttribute("id"); String methodName = (namespace == null || namespace.length() == 0) ? id : String.format("%s.%s", namespace, id);  sqlSourceMap.put(methodName, sqlSource); }  return sqlSourceMap;  }
[*] target: assertNotNull(sqlSourceMap)
[-] pred: org. junit. Assert. assertNotNull ( sqlSourceMap )
************************************
************************************
[+] input: testInclude() { XMLMapperBuilder builder = new XMLMapperBuilder(LoadXmlUtil.load("include-fruits.xml")); Map<String, SqlSource> sqlSourceMap = builder.parse(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sqlSourceMap.containsKey("fruit.testInclude"));  SqlSource sqlSource = sqlSourceMap.get("fruit.testInclude");  String expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  category = 'apple'";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"category": "apple"}")); }
parse() {  Map<String, SqlSource> sqlSourceMap = new HashMap<>();  XNode context = this.parser.evalNode("/mapper");  String namespace = context.getStringAttribute("namespace");  sqlElement(context.evalNodes("/mapper/sql"));  List<XNode> statements = context.evalNodes("select|insert|update|delete");  for (XNode node : statements) {  XMLStatementBuilder statementBuilder = new XMLStatementBuilder(node, sqlFragments); SqlSource sqlSource = statementBuilder.parseStatementNode();  String id = node.getStringAttribute("id"); String methodName = (namespace == null || namespace.length() == 0) ? id : String.format("%s.%s", namespace, id);  sqlSourceMap.put(methodName, sqlSource); }  return sqlSourceMap;  }
[*] target: assertNotNull(sqlSourceMap)
[-] pred: org. junit. Assert. assertNotNull ( sqlSourceMap )
************************************
************************************
[+] input: testParameters() { XMLMapperBuilder builder = new XMLMapperBuilder(LoadXmlUtil.load("parameters-fruits.xml")); Map<String, SqlSource> sqlSourceMap = builder.parse(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sqlSourceMap.containsKey("fruit.testParameters"));  SqlSource sqlSource = sqlSourceMap.get("fruit.testParameters");  String expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  category = 'apple'\n" + "  AND price > 100.00";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"category": "apple", "price": 100.00}"));  }
parse() {  Map<String, SqlSource> sqlSourceMap = new HashMap<>();  XNode context = this.parser.evalNode("/mapper");  String namespace = context.getStringAttribute("namespace");  sqlElement(context.evalNodes("/mapper/sql"));  List<XNode> statements = context.evalNodes("select|insert|update|delete");  for (XNode node : statements) {  XMLStatementBuilder statementBuilder = new XMLStatementBuilder(node, sqlFragments); SqlSource sqlSource = statementBuilder.parseStatementNode();  String id = node.getStringAttribute("id"); String methodName = (namespace == null || namespace.length() == 0) ? id : String.format("%s.%s", namespace, id);  sqlSourceMap.put(methodName, sqlSource); }  return sqlSourceMap;  }
[*] target: assertNotNull(sqlSourceMap)
[-] pred: org. junit. Assert. assertNotNull ( sqlSourceMap )
************************************
************************************
[+] input: testSet() { XMLMapperBuilder builder = new XMLMapperBuilder(LoadXmlUtil.load("set-fruits.xml")); Map<String, SqlSource> sqlSourceMap = builder.parse(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sqlSourceMap.containsKey("fruit.testSet"));  SqlSource sqlSource = sqlSourceMap.get("fruit.testSet");  String expectedSql = "UPDATE\n" + "  fruits\n" + "SET\n" + "  category = 'apple',\n" + "  price = 10.00\n" + "WHERE\n" + "  name = 'Jonathan'";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"name": "Jonathan", "price": 10.00, "category": "apple"}"));  expectedSql = "UPDATE\n" + "  fruits\n" + "SET\n" + "  category = 'apple'\n" + "WHERE\n" + "  name = 'Jonathan'";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"name": "Jonathan", "category": "apple"}"));  expectedSql = "UPDATE\n" + "  fruits\n" + "SET\n" + "  price = 10.00\n" + "WHERE\n" + "  name = 'Jonathan'";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"name": "Jonathan", "price": 10.00}"));  }
parse() {  Map<String, SqlSource> sqlSourceMap = new HashMap<>();  XNode context = this.parser.evalNode("/mapper");  String namespace = context.getStringAttribute("namespace");  sqlElement(context.evalNodes("/mapper/sql"));  List<XNode> statements = context.evalNodes("select|insert|update|delete");  for (XNode node : statements) {  XMLStatementBuilder statementBuilder = new XMLStatementBuilder(node, sqlFragments); SqlSource sqlSource = statementBuilder.parseStatementNode();  String id = node.getStringAttribute("id"); String methodName = (namespace == null || namespace.length() == 0) ? id : String.format("%s.%s", namespace, id);  sqlSourceMap.put(methodName, sqlSource); }  return sqlSourceMap;  }
[*] target: assertNotNull(sqlSourceMap)
[-] pred: org. junit. Assert. assertNotNull ( sqlSourceMap )
************************************
************************************
[+] input: testTrim() { XMLMapperBuilder builder = new XMLMapperBuilder(LoadXmlUtil.load("trim-fruits.xml")); Map<String, SqlSource> sqlSourceMap = builder.parse(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sqlSourceMap.containsKey("fruit.testTrim"));  SqlSource sqlSource = sqlSourceMap.get("fruit.testTrim");  String expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  category = 'apple'\n" + "  OR price = 200";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), null)); }
parse() {  Map<String, SqlSource> sqlSourceMap = new HashMap<>();  XNode context = this.parser.evalNode("/mapper");  String namespace = context.getStringAttribute("namespace");  sqlElement(context.evalNodes("/mapper/sql"));  List<XNode> statements = context.evalNodes("select|insert|update|delete");  for (XNode node : statements) {  XMLStatementBuilder statementBuilder = new XMLStatementBuilder(node, sqlFragments); SqlSource sqlSource = statementBuilder.parseStatementNode();  String id = node.getStringAttribute("id"); String methodName = (namespace == null || namespace.length() == 0) ? id : String.format("%s.%s", namespace, id);  sqlSourceMap.put(methodName, sqlSource); }  return sqlSourceMap;  }
[*] target: assertNotNull(sqlSourceMap)
[-] pred: org. junit. Assert. assertNotNull ( sqlSourceMap )
************************************
************************************
[+] input: testWhere() { XMLMapperBuilder builder = new XMLMapperBuilder(LoadXmlUtil.load("where-fruits.xml")); Map<String, SqlSource> sqlSourceMap = builder.parse(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sqlSourceMap.containsKey("fruit.testWhere"));  SqlSource sqlSource = sqlSourceMap.get("fruit.testWhere");  String expectedSql = "SELECT\n" + "  name,\n" + "  category,\n" + "  price\n" + "FROM\n" + "  fruits\n" + "WHERE\n" + "  category = 'apple'\n" + "  AND price = 10.00";  Assertions.assertEquals(expectedSql, sqlSource.getSql(Collections.emptyList(), "{"price": 10.00}")); }
parse() {  Map<String, SqlSource> sqlSourceMap = new HashMap<>();  XNode context = this.parser.evalNode("/mapper");  String namespace = context.getStringAttribute("namespace");  sqlElement(context.evalNodes("/mapper/sql"));  List<XNode> statements = context.evalNodes("select|insert|update|delete");  for (XNode node : statements) {  XMLStatementBuilder statementBuilder = new XMLStatementBuilder(node, sqlFragments); SqlSource sqlSource = statementBuilder.parseStatementNode();  String id = node.getStringAttribute("id"); String methodName = (namespace == null || namespace.length() == 0) ? id : String.format("%s.%s", namespace, id);  sqlSourceMap.put(methodName, sqlSource); }  return sqlSourceMap;  }
[*] target: assertNotNull(sqlSourceMap)
[-] pred: org. junit. Assert. assertNotNull ( sqlSourceMap )
************************************
************************************
[+] input: shouldFindCreditCardActivityByAmountInterval() {  BigDecimal min = BigDecimal.ONE; BigDecimal max = BigDecimal.valueOf(10000);  List<CrdCreditCardActivity> crdCreditCardActivityList = createDummyCrdCreditCardActivityList();  List<CrdCreditCardActivity> expectedResult = createDummyCrdCreditCardActivityList();  when(crdCreditCardActivityEntityService.findCreditCardActivityByAmountInterval(min,max)).thenReturn(crdCreditCardActivityList);  List<CrdCreditCardActivity> result = crdCreditCardActivityEntityService.findCreditCardActivityByAmountInterval(min,max);  "<AssertPlaceHolder>"; assertNotNull(result); }
findCreditCardActivityByAmountInterval(BigDecimal min, BigDecimal max) {  crdCreditCardActivityValidationService.controlIsParameterMinLargerThanMax(min,max);  List<CrdCreditCardActivity> crdCreditCardActivityList = crdCreditCardActivityEntityService.findCreditCardActivityByAmountInterval(min,max);  List<CrdCreditCardActivityDto> convertToCrdCreditCardDtoList = CrdCreditCardMapper.INSTANCE.convertToCrdCreditCardActivityDtoList(crdCreditCardActivityList);  return convertToCrdCreditCardDtoList; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: shouldGetCardActivityAnalysis() {  List<CrdCreditCardActivityAnalysisDto> crdCreditCardActivityAnalysisDtoList = createDummyCrdCreditCardActivityAnalysisDtoList();  List<CrdCreditCardActivityAnalysisDto> expectedResult = createDummyCrdCreditCardActivityAnalysisDtoList();  when(crdCreditCardActivityEntityService.getCardActivityAnalysis(1L)).thenReturn(crdCreditCardActivityAnalysisDtoList);  List<CrdCreditCardActivityAnalysisDto> result = crdCreditCardActivityEntityService.getCardActivityAnalysis(1L);  "<AssertPlaceHolder>"; assertNotNull(result);  }
getCardActivityAnalysis(Long creditCardId) {  crdCreditCardActivityValidationService.controlIsCreditCardExist(creditCardId);  List<CrdCreditCardActivityAnalysisDto> crdCreditCardActivityAnalysisDtoList = crdCreditCardActivityEntityService.getCardActivityAnalysis(creditCardId);  return crdCreditCardActivityAnalysisDtoList; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: shouldFindAllCustomers() {  List<CusCustomer> cusCustomerList = createDummyCusCustomerList();  List<CusCustomerDto> expectedResult = createDummyCusCustomerDtoList();  when(cusCustomerEntityService.findAllCustomers()).thenReturn(cusCustomerList);  List<CusCustomerDto> result = cusCustomerService.findAllCustomers();  "<AssertPlaceHolder>"; assertNotNull(result); }
findAllCustomers(){  List<CusCustomer> cusCustomerList = cusCustomerEntityService.findAllCustomers();  List<CusCustomerDto> cusCustomerDtoList = CusCustomerMapper.INSTANCE.convertToCusCustomerDtoList(cusCustomerList);  return cusCustomerDtoList; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: shouldFindCustomerById() {  CusCustomer cusCustomer = createDummyCusCustomer(); Long cusCustomerId = cusCustomer.getId(); CusCustomerDto expectedResult = createDummyCusCustomerDto();  when(cusCustomerEntityService.getByIdWithControl(cusCustomerId)).thenReturn(cusCustomer);  CusCustomerDto result = cusCustomerService.findCustomerById(cusCustomerId);  "<AssertPlaceHolder>"; assertNotNull(result); }
findCustomerById(Long id) {  CusCustomer cusCustomer = cusCustomerEntityService.getByIdWithControl(id);  CusCustomerDto cusCustomerDto = CusCustomerMapper.INSTANCE.convertToCusCustomerDto(cusCustomer);  return cusCustomerDto; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: shouldSaveCustomer() {  CusCustomerDto cusCustomerDto = createDummyCusCustomerDto(); CusCustomer cusCustomer = createDummyCusCustomer();  when(cusCustomerEntityService.saveCustomer(any())).thenReturn(cusCustomer);  CusCustomerDto result = cusCustomerService.saveCustomer(any());  "<AssertPlaceHolder>"; assertNotNull(result); }
saveCustomer(CusCustomerSaveDto cusCustomerSaveDto) {  CusCustomer cusCustomer = CusCustomerMapper.INSTANCE.convertToCusCustomer(cusCustomerSaveDto);  String password = passwordEncoder.encode(cusCustomer.getPassword()); cusCustomer.setPassword(password);  cusCustomerValidationService.controlAreFieldsNonNull(cusCustomer); cusCustomerValidationService.controlIsIdentityNoUnique(cusCustomer);  cusCustomer = cusCustomerEntityService.saveCustomer(cusCustomer);  CusCustomerDto cusCustomerDto = CusCustomerMapper.INSTANCE.convertToCusCustomerDto(cusCustomer);  return cusCustomerDto; }
[*] target: assertEquals(cusCustomerDto, result)
[-] pred: org. junit. Assert. assertEquals ( cusCustomerDto, result )
************************************
************************************
[+] input: shouldUpdateCustomer() {  CusCustomerDto cusCustomerDto = createDummyCusCustomerDto(); CusCustomer cusCustomer = createDummyCusCustomer();  when(cusCustomerEntityService.saveCustomer(any())).thenReturn(cusCustomer);  CusCustomerDto result = cusCustomerService.saveCustomer(any());  "<AssertPlaceHolder>"; assertNotNull(result); }
saveCustomer(CusCustomerSaveDto cusCustomerSaveDto) {  CusCustomer cusCustomer = CusCustomerMapper.INSTANCE.convertToCusCustomer(cusCustomerSaveDto);  String password = passwordEncoder.encode(cusCustomer.getPassword()); cusCustomer.setPassword(password);  cusCustomerValidationService.controlAreFieldsNonNull(cusCustomer); cusCustomerValidationService.controlIsIdentityNoUnique(cusCustomer);  cusCustomer = cusCustomerEntityService.saveCustomer(cusCustomer);  CusCustomerDto cusCustomerDto = CusCustomerMapper.INSTANCE.convertToCusCustomerDto(cusCustomer);  return cusCustomerDto; }
[*] target: assertEquals(cusCustomerDto, result)
[-] pred: org. junit. Assert. assertEquals ( cusCustomerDto, result )
************************************
************************************
[+] input: testMultiArray() {  // ======================================== // Build a data object with 2 arrays DataBuilder builder = new DataBuilder(). // addData("name", "John"). // addData("description", "Hello World");  // first array with one object builder.addArray("scripts"); builder.addObject(); builder.addData("language", "javascript"); builder.addData("script", "1+1"); builder.addObject(); builder.addData("language", "java"); builder.addData("script", "1+1");  // second array with one object builder.addArray("links"); builder.addObject(); builder.addData("source", "a-connector"); builder.addData("target", "b-connector");  String json = builder.build(); "<AssertPlaceHolder>"; logger.info(json);  // ======================================== // validate the json structure JsonReader jsonReader = Json.createReader(new StringReader(json)); JsonObject dataObject = jsonReader.readObject(); jsonReader.close(); // each array should contain exactly one object assertNotNull(dataObject); JsonArray array1 = dataObject.getJsonArray("scripts"); assertNotNull(array1); assertEquals(2, array1.size());  JsonArray array2 = dataObject.getJsonArray("links"); assertNotNull(array2); assertEquals(1, array2.size()); }
build() { closeArray(); // write result JsonObject jsonObject = rootBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: testCategorization() {  UISchemaBuilder builder = new UISchemaBuilder(Layout.CATEGORIZATION);  builder.addCategory("Cat-1"). // addLayout(Layout.HORIZONTAL). // addElements(new String[] { "firstName", "lastName", "role" });  String json = builder.build();  "<AssertPlaceHolder>"; // assertTrue(json.contains("#/properties/lastName")); logger.info(json);  }
build() {  // close current controllsBuilder.... if (controlsArrayBuilder != null && layoutContext != null) { layoutContext.add("elements", controlsArrayBuilder.build()); }  if (groupArrayBuilder != null) {  // close current layoutContext.... if (layoutsArrayBuilder != null && layoutContext != null) { this.layoutsArrayBuilder.add(layoutContext.build()); }  // close current gourpContext if (groupContext != null) { groupContext.add("elements", layoutsArrayBuilder.build()); groupArrayBuilder.add(groupContext); }  rootLayoutBuilder.add("elements", groupArrayBuilder.build()); }  // write result JsonObject jsonObject = rootLayoutBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: testCategorizationMixed() {  UISchemaBuilder builder = new UISchemaBuilder(Layout.CATEGORIZATION);  builder.addCategory("Cat-1"). // addLayout(Layout.HORIZONTAL). // addElements(new String[] { "firstName", "lastName", "role" });  builder.addLayout(Layout.VERTICAL). // addElements(new String[] { "age", "city" });  String json = builder.build();  "<AssertPlaceHolder>"; // assertTrue(json.contains("#/properties/lastName")); logger.info(json);  }
build() {  // close current controllsBuilder.... if (controlsArrayBuilder != null && layoutContext != null) { layoutContext.add("elements", controlsArrayBuilder.build()); }  if (groupArrayBuilder != null) {  // close current layoutContext.... if (layoutsArrayBuilder != null && layoutContext != null) { this.layoutsArrayBuilder.add(layoutContext.build()); }  // close current gourpContext if (groupContext != null) { groupContext.add("elements", layoutsArrayBuilder.build()); groupArrayBuilder.add(groupContext); }  rootLayoutBuilder.add("elements", groupArrayBuilder.build()); }  // write result JsonObject jsonObject = rootLayoutBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: testCategorization2SectionsWithoutLayout() {  UISchemaBuilder builder = new UISchemaBuilder(Layout.CATEGORIZATION);  builder.addCategory("Cat-1"). // // missing Layout addElements("color", "rule"). // addCategory("Cat-2"). // addLayout(Layout.HORIZONTAL). // addElements("firstName", "lastName", "role");  String json = builder.build();  "<AssertPlaceHolder>"; logger.info(json); assertTrue(json.contains("VerticalLayout"));  }
build() {  // close current controllsBuilder.... if (controlsArrayBuilder != null && layoutContext != null) { layoutContext.add("elements", controlsArrayBuilder.build()); }  if (groupArrayBuilder != null) {  // close current layoutContext.... if (layoutsArrayBuilder != null && layoutContext != null) { this.layoutsArrayBuilder.add(layoutContext.build()); }  // close current gourpContext if (groupContext != null) { groupContext.add("elements", layoutsArrayBuilder.build()); groupArrayBuilder.add(groupContext); }  rootLayoutBuilder.add("elements", groupArrayBuilder.build()); }  // write result JsonObject jsonObject = rootLayoutBuilder.build(); String result = null; try (Writer writer = new StringWriter()) { Json.createWriter(writer).write(jsonObject); result = writer.toString(); } catch (IOException e) { result = "{}"; e.printStackTrace(); } return result; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: testGetAppByName() { App app = appDAO.getAppByName("xxx-service"); Assertions."<AssertPlaceHolder>";  Assertions.assertEquals(app.getName(), "xxx-service"); }
getAppByName(String appName);
[*] target: assertNotNull(app)
[-] pred: org. junit. Assert. assertNotNull ( app )
************************************
************************************
[+] input: testSave() { String ip = "127.0.0.2"; String akkaAddress = "127.0.0.2:25520"; Server server = new Server(); server.setIp(ip); server.setAkkaAddress(akkaAddress); Long id = serverDAO.save(server);  Assertions."<AssertPlaceHolder>"; Optional<Server> optionalServer = serverRepository.findById(id); Assertions.assertTrue(optionalServer.isPresent());  optionalServer.ifPresent((s) -> { Assertions.assertEquals(s.getIp(), server.getIp()); Assertions.assertEquals(s.getAkkaAddress(), server.getAkkaAddress()); }); }
save(Server server);
[*] target: assertNotNull(id)
[-] pred: org. junit. Assert. assertNotNull ( id )
************************************
************************************
[+] input: testGetByAddress() { Worker worker = workerDAO.getByAddress("127.0.0.1:25300");  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("xxx-service", worker.getAppName()); }
getByAddress(String address);
[*] target: assertNotNull(worker)
[-] pred: org. junit. Assert. assertNotNull ( worker )
************************************
************************************
[+] input: testListOnlineWorkersByAppName() { List<Worker> workers = workerDAO.listOnlineWorkers();  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(workers.size(), 2); }
listOnlineWorkers();
[*] target: assertNotNull(workers)
[-] pred: org. junit. Assert. assertNotNull ( workers )
************************************
************************************
[+] input: testGetProperties() { Properties properties = ConfigLoader.getProperties(); Assertions."<AssertPlaceHolder>";  Assertions.assertEquals(properties.getProperty("openjob.worker.test"), "test"); }
getProperties() { return PROPERTIES; }
[*] target: assertNotNull(properties)
[-] pred: org. junit. Assert. assertNotNull ( properties )
************************************
************************************
[+] input: testClassPathFile() { Properties properties = ConfigUtil.loadProperties("classpath:openjob.properties"); Assertions."<AssertPlaceHolder>";  String value = properties.getProperty("openjob.worker.test", "none"); Assertions.assertEquals(value, "test"); }
loadProperties(String filename) { // Empty filename. if (StringUtils.isBlank(filename)) { return null; }  // Absolute file. if (isAbsoluteFile(filename)) { return loadPropertiesFromAbsoluteFile(filename); }  // Classpath file. if (filename.startsWith(CLASSPATH_PREFIX)) { return loadPropertiesFromClasspathFile(filename); }  // Relative file. return loadPropertiesFromRelativeFile(filename); }
[*] target: assertNotNull(properties)
[-] pred: org. junit. Assert. assertNotNull ( properties )
************************************
************************************
[+] input: testConstruct() { Result result = new Result(); "<AssertPlaceHolder>"; assertEquals(result.getCode(), "000000"); assertEquals(result.getMesg(), "处理成功"); }
isSuccess() { return SUCCESSFUL_CODE.equals(this.code); }
[*] target: assertTrue(result.isSuccess())
[-] pred: org. junit. Assert. assertTrue ( result. isSuccess ( ) )
************************************
************************************
[+] input: testConstructErrorType() { Result result = new Result(SystemErrorType.SYSTEM_BUSY); "<AssertPlaceHolder>"; assertEquals(result.getCode(), SystemErrorType.SYSTEM_BUSY.getCode()); assertEquals(result.getMesg(), SystemErrorType.SYSTEM_BUSY.getMesg()); }
isFail() { return !isSuccess(); }
[*] target: assertTrue(result.isFail())
[-] pred: org. junit. Assert. assertTrue ( result. isFail() )
************************************
************************************
[+] input: testConstructErrorTypeWithData() { Date data = new Date(); Result result = new Result(SystemErrorType.SYSTEM_BUSY, data); "<AssertPlaceHolder>"; assertEquals(result.getCode(), SystemErrorType.SYSTEM_BUSY.getCode()); assertEquals(result.getMesg(), SystemErrorType.SYSTEM_BUSY.getMesg()); assertEquals(result.getData(), data); }
isFail() { return !isSuccess(); }
[*] target: assertTrue(result.isFail())
[-] pred: org. junit. Assert. assertTrue ( result. isFail() )
************************************
************************************
[+] input: testSuccess() { Result success = Result.success(); "<AssertPlaceHolder>"; assertEquals(success.getCode(), "000000"); assertEquals(success.getMesg(), "处理成功"); }
isSuccess() { return SUCCESSFUL_CODE.equals(this.code); }
[*] target: assertTrue(success.isSuccess())
[-] pred: org. junit. Assert. assertTrue ( success. isSuccess ( ) )
************************************
************************************
[+] input: testFailWithBaseException() { Result result = Result.fail(new BaseException()); "<AssertPlaceHolder>"; assertEquals(result.getCode(), SystemErrorType.SYSTEM_ERROR.getCode()); }
isFail() { return !isSuccess(); }
[*] target: assertTrue(result.isFail())
[-] pred: org. junit. Assert. assertTrue ( result. isFail() )
************************************
************************************
[+] input: testFailWithBaseExceptionAndData() { Date data = new Date(); Result result = Result.fail(new BaseException(), data); "<AssertPlaceHolder>"; assertEquals(result.getCode(), SystemErrorType.SYSTEM_ERROR.getCode()); assertEquals(result.getData(), data); }
isFail() { return !isSuccess(); }
[*] target: assertTrue(result.isFail())
[-] pred: org. junit. Assert. assertTrue ( result. isFail() )
************************************
************************************
[+] input: testFailWithErrorTypeAndData() { Date data = new Date(); Result result = Result.fail(SystemErrorType.GATEWAY_ERROR, data); "<AssertPlaceHolder>"; assertEquals(result.getCode(), SystemErrorType.GATEWAY_ERROR.getCode()); assertEquals(result.getData(), data); }
isFail() { return !isSuccess(); }
[*] target: assertTrue(result.isFail())
[-] pred: org. junit. Assert. assertTrue ( result. isFail() )
************************************
************************************
[+] input: testFailWithErrorType() { Result result = Result.fail(SystemErrorType.GATEWAY_ERROR); "<AssertPlaceHolder>"; assertEquals(result.getCode(), SystemErrorType.GATEWAY_ERROR.getCode()); }
isFail() { return !isSuccess(); }
[*] target: assertTrue(result.isFail())
[-] pred: org. junit. Assert. assertTrue ( result. isFail() )
************************************
************************************
[+] input: testOlderDataIndex() { WorkflowDef def = new WorkflowDef(); def.setName("pending_count_correlation_jtest");  WorkflowModel workflow = createTestWorkflow(); workflow.setWorkflowDefinition(def); workflow.setWorkflowId(UUID.randomUUID().toString());  archiveDAO.createOrUpdateWorkflow(workflow); WorkflowModel found = archiveDAO.getWorkflow(workflow.getWorkflowId(), false); "<AssertPlaceHolder>"; assertEquals(workflow.getWorkflowId(), found.getWorkflowId()); }
getWorkflow(String workflowId, boolean includeTasks) { try (Connection connection = super.dataSource.getConnection()) { PreparedStatement statement = connection.prepareStatement(GET_WORKFLOW); statement.setString(1, workflowId); ResultSet rs = statement.executeQuery(); if (rs.next()) { byte[] json = rs.getBytes("json_data"); if (json == null || json.length == 0) { return null; } return objectMapper.readValue(json, WorkflowModel.class); } } catch (Exception e) { log.error("Error reading workflow - " + e.getMessage(), e); throw new RuntimeException(e); } return null; }
[*] target: assertNotNull(found)
[-] pred: org. junit. Assert. assertNotNull ( found )
************************************
************************************
[+] input: testIndexWorkflow() { WorkflowDef def = new WorkflowDef(); def.setName("pending_count_correlation_jtest");  WorkflowModel workflow = createTestWorkflow(); workflow.setWorkflowDefinition(def);  generateWorkflows(workflow, 10); List<String> bycorrelationId = archiveDAO.getWorkflowIdsByCorrelationId( "pending_count_correlation_jtest", "corr001", true, true); assertNotNull(bycorrelationId); assertEquals(10, bycorrelationId.size()); System.out.println("Workflow Ids: " + bycorrelationId);  List<String> bycorrelationId2 = archiveDAO.getWorkflowIdsByCorrelationId( "pending_count_correlation_jtest", "corr001", true, true); System.out.println("Workflow Ids: " + bycorrelationId2); System.out.println("Workflow Ids: " + (bycorrelationId.size() == bycorrelationId2.size()));  workflow.setStatus(WorkflowModel.Status.COMPLETED); workflow.setUpdatedTime(System.currentTimeMillis()); workflow.getTasks().forEach(t -> t.setStatus(TaskModel.Status.COMPLETED)); workflow.setUpdatedTime(System.currentTimeMillis()); archiveDAO.createOrUpdateWorkflow(workflow); WorkflowModel found = archiveDAO.getWorkflow(workflow.getWorkflowId(), false); assertNotNull(found); assertNotNull(workflow.getTasks()); assertFalse(workflow.getTasks().isEmpty());  // Updating it back to running status shouldn't do anything! workflow.setStatus(WorkflowModel.Status.RUNNING); archiveDAO.createOrUpdateWorkflow(workflow); found = archiveDAO.getWorkflow(workflow.getWorkflowId(), false); "<AssertPlaceHolder>"; assertEquals(WorkflowModel.Status.COMPLETED, found.getStatus()); }
getWorkflow(String workflowId, boolean includeTasks) { try (Connection connection = super.dataSource.getConnection()) { PreparedStatement statement = connection.prepareStatement(GET_WORKFLOW); statement.setString(1, workflowId); ResultSet rs = statement.executeQuery(); if (rs.next()) { byte[] json = rs.getBytes("json_data"); if (json == null || json.length == 0) { return null; } return objectMapper.readValue(json, WorkflowModel.class); } } catch (Exception e) { log.error("Error reading workflow - " + e.getMessage(), e); throw new RuntimeException(e); } return null; }
[*] target: assertNotNull(found)
[-] pred: org. junit. Assert. assertNotNull ( found )
************************************
************************************
[+] input: testTopSearches() { _db.addRating("0", Rating.C_PING, null, 0); _db.addRating("1", Rating.C_PING, null, 0); _db.addRating("2", Rating.C_PING, null, 0); _db.addRating("3", Rating.C_PING, null, 0); _db.addRating("4", Rating.C_PING, null, 0); _db.addRating("5", Rating.C_PING, null, 0);  _db.addSearchHit("5", 0); _db.addSearchHit("0", 0); _db.addSearchHit("0", 0); _db.addSearchHit("0", 0);  _db.addSearchHit("1", 1); _db.addSearchHit("2", 2); _db.addSearchHit("3", 3); _db.cleanupSearchHistory(30);  _db.addSearchHit("0", 4); _db.addSearchHit("4", 5); _db.addSearchHit("5", 6);  List<? extends SearchInfo> topSearches = _db.getTopSearches(1, 1);  "<AssertPlaceHolder>";  assertEquals("5", topSearches.get(0).getPhone()); assertEquals(1, topSearches.get(0).getCount()); assertEquals(1, topSearches.get(0).getTotal());  assertEquals("0", topSearches.get(1).getPhone()); assertEquals(1, topSearches.get(1).getCount()); assertEquals(3, topSearches.get(1).getTotal()); }
getTopSearches(int cntLatest, int cntSearches) { try (SqlSession session = openSession()) { SpamReports reports = session.getMapper(SpamReports.class);  int revision = nonNull(reports.getLastRevision()); Set<String> yesterdaySearches = revision > 0 ? reports.getTopSearches(revision) : Collections.emptySet();  Set<String> topNumbers = reports.getLatestSearchesToday(); topNumbers.addAll(yesterdaySearches);  if (topNumbers.isEmpty()) { return Collections.emptyList(); }  List<DBSearchInfo> topSearches = reports.getSearchesTodayAll(topNumbers); Map<String, DBSearchInfo> yesterdayByPhone = reports.getSearchesAtAll(revision, topNumbers).stream().collect(Collectors.toMap(i -> i.getPhone(), i -> i));  for (DBSearchInfo today : topSearches) { DBSearchInfo yesterday = yesterdayByPhone.get(today.getPhone()); if (yesterday == null) { today.setTotal(0); } else { today.setTotal(yesterday.getCount()); } }  topSearches.sort(byDate);  List<SearchInfo> result = new ArrayList<>();  // Latest 3 (most likely from today). int index = Math.min(cntLatest, topSearches.size()); result.addAll(topSearches.subList(0, index));  // Sort the rest by total amount of searches (from today and yesterday). ArrayList<DBSearchInfo> tail = new ArrayList<>(topSearches.subList(index, topSearches.size())); tail.sort((s1, s2) -> -Integer.compare(s1.getCount() + s1.getTotal(), s2.getCount() + s2.getTotal()));  // Top 3 result.addAll(tail.subList(0, Math.min(cntSearches, tail.size())));  // Present all in last search order. result.sort(byDate);  return result; } }
[*] target: assertEquals(2, topSearches.size())
[-] pred: org. junit. Assert. assertEquals ( 2, topSearches. size ( ) )
************************************
************************************
[+] input: liveMirror() { Project project = ProjectBuilder.builder().build(); project.getPlugins().apply("com.gtnewhorizons.retrofuturagradle"); ModUtils modUtils = project.getExtensions().getByType(ModUtils.class); "<AssertPlaceHolder>"; assertNotNull( modUtils.getLiveMirrorURL(10000, "https://example.com", "https://www.iana.org/help/example-domains")); }
apply(Project project) { project.getPluginManager().apply(JavaLibraryPlugin.class);  if (GradleVersion.current().compareTo(GradleVersion.version("7.6")) < 0) { throw new IllegalStateException("Using RetroFuturaGradle requires at least Gradle 7.6."); }  RfgCacheService.register(project.getGradle());  // Register the obfuscation status attribute ObfuscationAttribute.configureProject(project);  // Register the `minecraft {...}` block final MinecraftExtension mcExt = project.getExtensions().create("minecraft", MinecraftExtension.class, project);  final MinecraftTasks mcTasks = new MinecraftTasks(project, mcExt); project.getExtensions().add("minecraftTasks", mcTasks); final MCPTasks mcpTasks = new MCPTasks(project, mcExt, mcTasks); project.getExtensions().add("mcpTasks", mcpTasks); final ModUtils modUtils = new ModUtils(project, mcExt, mcTasks, mcpTasks); project.getExtensions().add("modUtils", modUtils); }
[*] target: assertNotNull(modUtils)
[-] pred: org. junit. Assert. assertNotNull ( modUtils )
************************************
************************************
[+] input: testRemoveUsersByLogin() { var users = new MemoryUsers();  try { users .addRole("role1") .addRole("role2") .addRole("role3") .addUser("login1", new RoleUserAttributes("thepassword")) .addUser("login2", new RoleUserAttributes("thepassword2", new String[]{"role1", "role2"})) .addUser("login3", new RoleUserAttributes("thepassword3", new String[]{"role1", "role2", "role3"})) .addUser("login4", new RoleUserAttributes(174, "thepassword4", new String[]{"role2", "role3"}));  assertEquals(4, users.countUsers()); assertFalse(users.removeUser("login5")); assertEquals(4, users.countUsers()); assertTrue(users.removeUser("login4")); assertEquals(3, users.countUsers()); assertTrue(users.removeUser("login1")); assertEquals(2, users.countUsers()); assertTrue(users.removeUser("login2")); assertEquals(1, users.countUsers()); assertTrue(users.removeUser("login3")); "<AssertPlaceHolder>"; } catch (CredentialsManagerException e) { fail(ExceptionUtils.getExceptionStackTrace(e)); } }
countUsers() { readLock_.lock(); try { return users_.size(); } finally { readLock_.unlock(); } }
[*] target: assertEquals(0, users.countUsers())
[-] pred: org. junit. Assert. assertEquals ( 0, users. countUsers ( ) )
************************************
************************************
[+] input: testRemoveUsersByUserId() { var users = new MemoryUsers();  try { users .addRole("role1") .addRole("role2") .addRole("role3") .addUser("login1", new RoleUserAttributes(1, "thepassword")) .addUser("login2", new RoleUserAttributes(23, "thepassword2", new String[]{"role1", "role2"})) .addUser("login3", new RoleUserAttributes(14, "thepassword3", new String[]{"role1", "role2", "role3"})) .addUser("login4", new RoleUserAttributes(174, "thepassword4", new String[]{"role2", "role3"}));  assertEquals(4, users.countUsers()); assertFalse(users.removeUser(5)); assertEquals(4, users.countUsers()); assertTrue(users.removeUser(174)); assertEquals(3, users.countUsers()); assertTrue(users.removeUser(1)); assertEquals(2, users.countUsers()); assertTrue(users.removeUser(23)); assertEquals(1, users.countUsers()); assertTrue(users.removeUser(14)); "<AssertPlaceHolder>"; } catch (CredentialsManagerException e) { fail(ExceptionUtils.getExceptionStackTrace(e)); } }
countUsers() { readLock_.lock(); try { return users_.size(); } finally { readLock_.unlock(); } }
[*] target: assertEquals(0, users.countUsers())
[-] pred: org. junit. Assert. assertEquals ( 0, users. countUsers ( ) )
************************************
************************************
[+] input: testClearUsers() { var users = new MemoryUsers();  try { users .addRole("role1") .addRole("role2") .addRole("role3") .addUser("login1", new RoleUserAttributes("thepassword")) .addUser("login2", new RoleUserAttributes("thepassword2", new String[]{"role1", "role2"})) .addUser("login3", new RoleUserAttributes("thepassword3", new String[]{"role1", "role2", "role3"})) .addUser("login4", new RoleUserAttributes(174, "thepassword4", new String[]{"role2", "role3"}));  assertEquals(4, users.countUsers()); users.clearUsers(); "<AssertPlaceHolder>"; } catch (CredentialsManagerException e) { fail(ExceptionUtils.getExceptionStackTrace(e)); } }
countUsers() { readLock_.lock(); try { return users_.size(); } finally { readLock_.unlock(); } }
[*] target: assertEquals(0, users.countUsers())
[-] pred: org. junit. Assert. assertEquals ( 0, users. countUsers ( ) )
************************************
************************************
[+] input: testEraseAllSessions() { var sessions = new MemorySessions(); sessions.setSessionDuration(1200000);  try { sessions.startSession(8433, "143.98.32.545", false); assertTrue(sessions.countSessions() > 0); sessions.eraseAllSessions(); "<AssertPlaceHolder>"; } catch (SessionManagerException e) { fail(ExceptionUtils.getExceptionStackTrace(e)); } }
countSessions() { var expiration = System.currentTimeMillis() - getSessionDuration(); return sessions_.reduceToLong(1, (s, session) -> (session.getStart() > expiration ? 1L : 0L), 0, Long::sum); }
[*] target: assertEquals(0, sessions.countSessions())
[-] pred: org. junit. Assert. assertEquals ( 0, sessions. countSessions() )
************************************
************************************
[+] input: testFragment() { var content = new Content(MimeType.APPLICATION_XHTML, "<html></html>"); content.setFragment(true); assertTrue(content.isFragment()); assertSame(content, content.fragment(false)); "<AssertPlaceHolder>"; }
isFragment() { return fragment_; }
[*] target: assertFalse(content.isFragment())
[-] pred: org. junit. Assert. assertFalse ( content. isFragment() )
************************************
************************************
[+] input: testName() { var repository = new ContentRepository(); repository.setName("anotherone"); assertEquals("anotherone", repository.getName()); repository.name("stillonemore"); assertEquals("stillonemore", repository.getName()); repository.setName(null); "<AssertPlaceHolder>"; }
getName() { return name_; }
[*] target: assertNull(repository.getName())
[-] pred: org. junit. Assert. assertNull ( repository. getName() )
************************************
************************************
[+] input: testLoadFromBytesError() { var loader = new ImageIOLoader(); Set<String> errors = new HashSet<>();  var image_bytes = new byte[]{2, 9, 7, 12, 45}; // just random values var image = loader.loadFromBytes(image_bytes, errors);  "<AssertPlaceHolder>"; assertEquals(0, errors.size()); }
loadFromBytes(byte[] data, Set<String> errors) throws ContentManagerException { var input = new ByteArrayInputStream(data); Image image; MimeType mime_type = null;  try { var stream = ImageIO.createImageInputStream(input); if (stream == null) { throw new IIOException("Can't create an ImageInputStream"); }  var iter = ImageIO.getImageReaders(stream); if (!iter.hasNext()) { return null; }  var reader = iter.next();  // detect if any of the reader mimetypes corresponds to a CMF supported one var reader_mime_types = reader.getOriginatingProvider().getMIMETypes(); if (reader_mime_types != null) { for (var reader_mime : reader_mime_types) { mime_type = MimeType.getMimeType(reader_mime); if (mime_type != null) { break; } } }  // create an awt image var param = reader.getDefaultReadParam(); reader.setInput(stream, true, true); try { image = reader.read(0, param); } finally { reader.dispose(); stream.close(); }  if (image == null) { stream.close(); }  // wait until the image is fully loaded ImageWaiter.wait(image); } catch (Throwable e) { if (errors != null) { errors.add(ExceptionUtils.getExceptionStackTrace(e)); }  image = null; }  return new LoadedContent<>(mime_type, image); }
[*] target: assertNull(image)
[-] pred: org. junit. Assert. assertNull ( image )
************************************
************************************
[+] input: testLoadSuccess() { var loader = new SAXLoader(); Set<String> errors = new HashSet<>();  var xhtml = loader.load("<p>some <b>html</b> here</p>", true, errors);  "<AssertPlaceHolder>"; assertEquals(0, errors.size()); }
load(String data, boolean fragment, Set<String> errors) throws ContentManagerException { var complete_page = data;  if (fragment) { var t = TemplateFactory.HTML.get("cmf.container.template"); t.setValue("fragment", data); complete_page = t.getContent(); }  Reader reader = new StringReader(complete_page);  var sax_parse_exception = false; try { var inputsource = new InputSource(reader);  SAXParser parser = null;  try { parser = SAXParserFactory.newInstance().newSAXParser(); } catch (ParserConfigurationException | SAXException e) { throw new XmlErrorException(e); }  try { parser.getXMLReader().setFeature("http://xml.org/sax/features/validation", true); } catch (SAXException e) { throw new XmlErrorException("The parser '" + parser.getClass().getName() + "' doesn't support validation.", e); }  try { parser.parse(inputsource, this); } catch (SAXParseException e) { sax_parse_exception = true; if (errors != null) { errors.add(formatException(fragment, e)); } } catch (SAXException e) { if (e.getException() != null && e.getException() instanceof RuntimeException) { throw (RuntimeException) e.getException(); } else { throw new XmlErrorException(e); } } catch (IOException e) { throw new XmlErrorException(e); }  if (errors != null) { if (errorRedirector_.hasErrors()) { errors.addAll(formatExceptions(fragment, errorRedirector_.getErrors())); } if (errorRedirector_.hasFatalErrors()) { errors.addAll(formatExceptions(fragment, errorRedirector_.getFatalErrors())); } } } catch (RuntimeException e) { if (errors != null) { errors.add(e.getMessage()); } return null; }  if (sax_parse_exception || (errors != null && !errors.isEmpty()) || (errorRedirector_.hasErrors() || errorRedirector_.hasFatalErrors())) { return null; }  return new LoadedContent<>(MimeType.APPLICATION_XHTML, data); }
[*] target: assertNotNull(xhtml)
[-] pred: org. junit. Assert. assertNotNull ( xhtml )
************************************
************************************
[+] input: testLoadUnsupportedType() { var loader = new SAXLoader(); Set<String> errors = new HashSet<>();  var xhtml = loader.load(new Object(), true, errors);  "<AssertPlaceHolder>"; assertEquals(0, errors.size()); }
load(String data, boolean fragment, Set<String> errors) throws ContentManagerException { var complete_page = data;  if (fragment) { var t = TemplateFactory.HTML.get("cmf.container.template"); t.setValue("fragment", data); complete_page = t.getContent(); }  Reader reader = new StringReader(complete_page);  var sax_parse_exception = false; try { var inputsource = new InputSource(reader);  SAXParser parser = null;  try { parser = SAXParserFactory.newInstance().newSAXParser(); } catch (ParserConfigurationException | SAXException e) { throw new XmlErrorException(e); }  try { parser.getXMLReader().setFeature("http://xml.org/sax/features/validation", true); } catch (SAXException e) { throw new XmlErrorException("The parser '" + parser.getClass().getName() + "' doesn't support validation.", e); }  try { parser.parse(inputsource, this); } catch (SAXParseException e) { sax_parse_exception = true; if (errors != null) { errors.add(formatException(fragment, e)); } } catch (SAXException e) { if (e.getException() != null && e.getException() instanceof RuntimeException) { throw (RuntimeException) e.getException(); } else { throw new XmlErrorException(e); } } catch (IOException e) { throw new XmlErrorException(e); }  if (errors != null) { if (errorRedirector_.hasErrors()) { errors.addAll(formatExceptions(fragment, errorRedirector_.getErrors())); } if (errorRedirector_.hasFatalErrors()) { errors.addAll(formatExceptions(fragment, errorRedirector_.getFatalErrors())); } } } catch (RuntimeException e) { if (errors != null) { errors.add(e.getMessage()); } return null; }  if (sax_parse_exception || (errors != null && !errors.isEmpty()) || (errorRedirector_.hasErrors() || errorRedirector_.hasFatalErrors())) { return null; }  return new LoadedContent<>(MimeType.APPLICATION_XHTML, data); }
[*] target: assertNull(xhtml)
[-] pred: org. junit. Assert. assertNull ( xhtml )
************************************
************************************
[+] input: testLoadFromStringSuccessComplete() { var loader = new SAXLoader(); Set<String> errors = new HashSet<>();  var xhtml = loader.loadFromString(""" <?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> <html xmlns="http://www.w3.org/1999/xhtml"><head><title></title></head><body> <p>body</p> </body></html>""", false, errors);  "<AssertPlaceHolder>"; assertEquals(xhtml.originalMimeType(), MimeType.APPLICATION_XHTML); assertEquals(0, errors.size()); }
loadFromString(String data, boolean fragment, Set<String> errors) throws ContentManagerException { return new LoaderDelegate().load(data, fragment, errors); }
[*] target: assertNotNull(xhtml)
[-] pred: org. junit. Assert. assertNotNull ( xhtml )
************************************
************************************
[+] input: testGetTask() { var task_id = -1; Task task = null; TaskManager manager = new MemoryTasks(); try { var cal = Calendar.getInstance(); cal.set(2001, Calendar.NOVEMBER, 24, 0, 0, 0);  task = new Task(); task.setType(TestTasktypes.UPLOAD_GROUPS); task.setPlanned(cal.getTime().getTime()); task.setFrequency(Frequency.MINUTELY); task.setBusy(false); task_id = manager.addTask(task);  task = manager.getTask(task_id); "<AssertPlaceHolder>";  assertEquals(task.getId(), task_id); assertEquals(task.getType(), TestTasktypes.UPLOAD_GROUPS); assertTrue(task.getPlanned() <= cal.getTime().getTime()); assertEquals(task.getFrequency().toString(), "* * * * *"); assertFalse(task.isBusy()); assertSame(task.getTaskManager(), manager); } catch (FrequencyException | TaskManagerException e) { fail(ExceptionUtils.getExceptionStackTrace(e)); } }
getTask(int id) throws TaskManagerException { if (id < 0) throw new IllegalArgumentException("the task id can't be negative.");  synchronized (this) { return taskMapping_.get(id); } }
[*] target: assertNotNull(task)
[-] pred: org. junit. Assert. assertNotNull ( task )
************************************
************************************
[+] input: testUpdateTask() { var task_id = -1; Task task = null; TaskManager manager = new MemoryTasks(); try { var cal = Calendar.getInstance(); cal.set(2001, Calendar.NOVEMBER, 24, 0, 0, 0);  task = new Task(); task.setType(TestTasktypes.UPLOAD_GROUPS); task.setPlanned(cal.getTime().getTime()); task.setFrequency(Frequency.MINUTELY); task.setBusy(false); task_id = manager.addTask(task);  cal.set(2002, Calendar.MARCH, 12, 0, 0, 0); var type = TestTasktypes.SEND_RANKING; var planned = cal.getTime().getTime(); var frequency = new Frequency().atMinute(20).everyHour(3); var busy = true;  task = new Task(); task.setId(task_id); task.setType(type); task.setPlanned(planned); task.setFrequency(frequency); task.setBusy(busy);  assertTrue(manager.updateTask(task));  task = manager.getTask(task_id); "<AssertPlaceHolder>";  assertEquals(task.getId(), task_id); assertEquals(task.getType(), type); assertTrue(task.getPlanned() <= planned); assertEquals(task.getFrequency(), frequency); assertEquals(task.isBusy(), busy); assertSame(task.getTaskManager(), manager); } catch (FrequencyException | TaskManagerException e) { fail(ExceptionUtils.getExceptionStackTrace(e)); } }
getTask(int id) throws TaskManagerException { if (id < 0) throw new IllegalArgumentException("the task id can't be negative.");  synchronized (this) { return taskMapping_.get(id); } }
[*] target: assertNotNull(task)
[-] pred: org. junit. Assert. assertNotNull ( task )
************************************
************************************
[+] input: test_When_Order_Success() { //Mocking Order order = getMockOrder(); when(orderRepository.findById(anyLong())) .thenReturn(Optional.of(order));  when(restTemplate.getForObject( "http://PRODUCT-SERVICE/product/" + order.getProductId(), ProductResponse.class )).thenReturn(getMockProductResponse());  when(restTemplate.getForObject( "http://PAYMENT-SERVICE/payment/order/" + order.getId(), PaymentResponse.class )).thenReturn(getMockPaymentResponse());  //Actual OrderResponse orderResponse = orderService.getOrderDetails(1);  //Verification verify(orderRepository, times(1)).findById(anyLong()); verify(restTemplate, times(1)).getForObject( "http://PRODUCT-SERVICE/product/" + order.getProductId(), ProductResponse.class); verify(restTemplate, times(1)).getForObject( "http://PAYMENT-SERVICE/payment/order/" + order.getId(), PaymentResponse.class);   //Assert "<AssertPlaceHolder>"; assertEquals(order.getId(), orderResponse.getOrderId()); }
getOrderDetails(long orderId) { log.info("Get order details for Order Id : {}", orderId);  Order order = orderRepository.findById(orderId) .orElseThrow(() -> new CustomException("Order not found for the order Id:" + orderId, "NOT_FOUND", 404));  log.info("Invoking Product service to fetch the product for id: {}", order.getProductId()); ProductResponse productResponse = restTemplate.getForObject( "http://PRODUCT-SERVICE/product/" + order.getProductId(), ProductResponse.class );  log.info("Getting payment information form the payment Service"); PaymentResponse paymentResponse = restTemplate.getForObject( "http://PAYMENT-SERVICE/payment/order/" + order.getId(), PaymentResponse.class );  OrderResponse.ProductDetails productDetails = OrderResponse.ProductDetails .builder() .productName(productResponse.getProductName()) .productId(productResponse.getProductId()) .build();  OrderResponse.PaymentDetails paymentDetails = OrderResponse.PaymentDetails .builder() .paymentId(paymentResponse.getPaymentId()) .paymentStatus(paymentResponse.getStatus()) .paymentDate(paymentResponse.getPaymentDate()) .paymentMode(paymentResponse.getPaymentMode()) .build();  OrderResponse orderResponse = OrderResponse.builder() .orderId(order.getId()) .orderStatus(order.getOrderStatus()) .amount(order.getAmount()) .orderDate(order.getOrderDate()) .productDetails(productDetails) .paymentDetails(paymentDetails) .build();  return orderResponse; }
[*] target: assertNotNull(orderResponse)
[-] pred: org. junit. Assert. assertNotNull ( orderResponse )
************************************
************************************
[+] input: testInfo) { var userDetails = userDetailsService.loadUserByUsername(email); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(testInfo.getDisplayName(), userDetails.getUsername()); }
loadUserByUsername(final String usernameOrEmail) { // Ensure that usernameOrEmail is not empty or null. if (StringUtils.isNotBlank(usernameOrEmail)) { var storedUser = UserUtils.isEmail(usernameOrEmail) ? userRepository.findByEmail(usernameOrEmail) : userRepository.findByUsername(usernameOrEmail); if (Objects.isNull(storedUser)) { LOG.warn("No record found for storedUser with usernameOrEmail {}", usernameOrEmail); throw new UsernameNotFoundException( "User with usernameOrEmail " + usernameOrEmail + " not found"); } return UserDetailsBuilder.buildUserDetails(storedUser); } return null; }
[*] target: assertNotNull(userDetails)
[-] pred: org. junit. Assert. assertNotNull ( userDetails )
************************************
************************************
[+] input: testCreateHttpCookie() { var duration = Duration.ofHours(DURATION); var cookie = cookieService.createCookie(TokenType.ACCESS.getName(), jwtToken, duration); Assertions."<AssertPlaceHolder>";  assertCookie(cookie.getName(), cookie.toString(), jwtToken, duration); }
createCookie(String name, String value, Duration duration);
[*] target: assertNotNull(cookie)
[-] pred: org. junit. Assert. assertNotNull ( cookie )
************************************
************************************
[+] input: shouldGenerateSignUpRequestWithRandomCredentialsWhenNoParametersProvided() { SignUpRequest signUpRequest = SignUpUtils.createSignUpRequest();  "<AssertPlaceHolder>"; assertNotNull(signUpRequest.getUsername()); assertTrue(signUpRequest.getPassword().length() >= SignUpUtils.PASSWORD_MIN_LENGTH); assertTrue(signUpRequest.getPassword().length() <= SignUpUtils.PASSWORD_MAX_LENGTH); assertNotNull(signUpRequest.getEmail()); }
createSignUpRequest() { return createSignUpRequest(FAKER.internet().username()); }
[*] target: assertNotNull(signUpRequest)
[-] pred: org. junit. Assert. assertNotNull ( signUpRequest )
************************************
************************************
[+] input: shouldReturnEmptyJwtResponseWithNoUserDetails() { JwtResponseBuilder jwtResponse = JwtResponseBuilder.buildJwtResponse(JWT_TOKEN); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(StringUtils.isBlank(jwtResponse.getAccessToken())); }
buildJwtResponse(final String jwtToken) { return buildJwtResponse(jwtToken, null); }
[*] target: assertNotNull(jwtResponse)
[-] pred: org. junit. Assert. assertNotNull ( jwtResponse )
************************************
************************************
[+] input: shouldReturnJwtResponseWithMatchingToken() { JwtResponseBuilder jwtResponse = JwtResponseBuilder.buildJwtResponse(JWT_TOKEN, userDetailsBuilder); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(JWT_TOKEN, jwtResponse.getAccessToken()); }
buildJwtResponse( String jwToken, UserDetailsBuilder userDetails) {  var localUserDetails = userDetails; if (Objects.isNull(localUserDetails)) { localUserDetails = SecurityUtils.getAuthenticatedUserDetails(); }  if (Objects.nonNull(localUserDetails)) { List<String> roleList = new ArrayList<>(); for (GrantedAuthority authority : localUserDetails.getAuthorities()) { roleList.add(authority.getAuthority()); } return JwtResponseBuilder.builder() .accessToken(jwToken) .email(localUserDetails.getEmail()) .username(localUserDetails.getUsername()) .publicId(localUserDetails.getPublicId()) .type(SecurityConstants.BEARER) .roles(roleList) .build(); } return JwtResponseBuilder.builder().build(); }
[*] target: assertNotNull(jwtResponse)
[-] pred: org. junit. Assert. assertNotNull ( jwtResponse )
************************************
************************************
[+] input: test_When_Order_Success() {  String bearerToken = "eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJVc2VyIiwiaXNzIjoiUk9MRV9VU0VSICIsImlhdCI6MTY3MjQ0NDI2MiwiZXhwIjoxNjcyNDQ0MzgyfQ.8QKm8VKgi8zHAo7YGngB00ng6XrByyofzUkEq_3g4omRA_ODGpwjDYSDNIvpEKXEATt6oMWV9JrMkHz3hI-xOw";  HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.set("Authorization", "Bearer "+ bearerToken);  HttpEntity request = new HttpEntity<>(headers);  //Mocking Order order = getMockOrder(); when(orderRepository.findById(anyLong())) .thenReturn(Optional.of(order));   when(restTemplate.exchange( "http://PRODUCT-SERVICE/product/" + order.getProductId(), HttpMethod.GET, request, ProductResponse.class)).thenReturn(ResponseEntity.ok(getMockProductResponse()));  when(restTemplate.exchange( "http://PAYMENT-SERVICE/payment/order/" + order.getId(), HttpMethod.GET, request, PaymentResponse.class)).thenReturn(ResponseEntity.ok(getMockPaymentResponse()));  //Actual OrderResponse orderResponse = orderService.getOrderDetails(1,"Bearer "+ bearerToken);  //Verification verify(orderRepository, times(1)).findById(anyLong());  verify(restTemplate, times(1)) .exchange("http://PRODUCT-SERVICE/product/" + order.getProductId(), HttpMethod.GET, request, ProductResponse.class);  verify(restTemplate, times(1)) .exchange("http://PAYMENT-SERVICE/payment/order/" + order.getId(), HttpMethod.GET, request, PaymentResponse.class);  //Assert "<AssertPlaceHolder>"; assertEquals(order.getId(), orderResponse.getOrderId()); }
getOrderDetails(long orderId, String bearerToken) {  HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); headers.set("Authorization", bearerToken);  HttpEntity<String> request = new HttpEntity<String>(headers);  log.info("OrderServiceImpl | getOrderDetails | Get order details for Order Id : {}", orderId);  Order order = orderRepository.findById(orderId) .orElseThrow(() -> new CustomException("Order not found for the order Id:" + orderId, "NOT_FOUND", 404));  log.info("OrderServiceImpl | getOrderDetails | Invoking Product service to fetch the product for id: {}", order.getProductId()); /*ProductResponse productResponse = restTemplate.getForObject( "http://PRODUCT-SERVICE/product/" + order.getProductId(), ProductResponse.class );*/  ResponseEntity<ProductResponse> responseProduct = restTemplate.exchange( "http://PRODUCT-SERVICE/product/" + order.getProductId(), HttpMethod.GET, request, ProductResponse.class); ProductResponse productResponse = responseProduct.getBody();   log.info("OrderServiceImpl | getOrderDetails | Getting payment information form the payment Service"); /*PaymentResponse paymentResponse = restTemplate.getForObject( "http://PAYMENT-SERVICE/payment/order/" + order.getId(), PaymentResponse.class );*/  ResponseEntity<PaymentResponse> responsePayment = restTemplate.exchange( "http://PAYMENT-SERVICE/payment/order/" + order.getId(), HttpMethod.GET, request, PaymentResponse.class); PaymentResponse paymentResponse = responsePayment.getBody();  OrderResponse.ProductDetails productDetails = OrderResponse.ProductDetails .builder() .productName(productResponse.getProductName()) .productId(productResponse.getProductId()) .build();  OrderResponse.PaymentDetails paymentDetails = OrderResponse.PaymentDetails .builder() .paymentId(paymentResponse.getPaymentId()) .paymentStatus(paymentResponse.getStatus()) .paymentDate(paymentResponse.getPaymentDate()) .paymentMode(paymentResponse.getPaymentMode()) .build();  OrderResponse orderResponse = OrderResponse.builder() .orderId(order.getId()) .orderStatus(order.getOrderStatus()) .amount(order.getAmount()) .orderDate(order.getOrderDate()) .productDetails(productDetails) .paymentDetails(paymentDetails) .build();  log.info("OrderServiceImpl | getOrderDetails | orderResponse : " + orderResponse.toString());  return orderResponse; }
[*] target: assertNotNull(orderResponse)
[-] pred: org. junit. Assert. assertNotNull ( orderResponse )
************************************
************************************
[+] input: test_When_getPaymentDetailsByOrderId_isSuccess() {  TransactionDetails transactionDetails = getMockTransactionDetails();  when(transactionDetailsRepository.findByOrderId(anyLong())).thenReturn(Optional.of(transactionDetails));  //Actual PaymentResponse paymentResponse = paymentService.getPaymentDetailsByOrderId(1);  //Verification verify(transactionDetailsRepository, times(1)).findByOrderId(anyLong());  //Assert "<AssertPlaceHolder>"; assertEquals(transactionDetails.getId(), paymentResponse.getPaymentId()); }
getPaymentDetailsByOrderId(long orderId) {  log.info("PaymentServiceImpl | getPaymentDetailsByOrderId is called");  log.info("PaymentServiceImpl | getPaymentDetailsByOrderId | Getting payment details for the Order Id: {}", orderId);  TransactionDetails transactionDetails = transactionDetailsRepository.findByOrderId(orderId) .orElseThrow(() -> new PaymentServiceCustomException( "TransactionDetails with given id not found", "TRANSACTION_NOT_FOUND"));  PaymentResponse paymentResponse = PaymentResponse.builder() .paymentId(transactionDetails.getId()) .paymentMode(PaymentMode.valueOf(transactionDetails.getPaymentMode())) .paymentDate(transactionDetails.getPaymentDate()) .orderId(transactionDetails.getOrderId()) .status(transactionDetails.getPaymentStatus()) .amount(transactionDetails.getAmount()) .build();  log.info("PaymentServiceImpl | getPaymentDetailsByOrderId | paymentResponse: {}", paymentResponse.toString());  return paymentResponse; }
[*] target: assertNotNull(paymentResponse)
[-] pred: org. junit. Assert. assertNotNull ( paymentResponse )
************************************
************************************
[+] input: test_When_GetProductById_isSuccess() { Product product = getMockProductDetails(); when(productRepository.findById(product.getProductId())).thenReturn(Optional.of(product));  ProductResponse productResponse = productService.getProductById(1); //Verification verify(productRepository, times(1)).findById(anyLong());  //Assert "<AssertPlaceHolder>"; assertEquals(product.getProductId(), productResponse.getProductId());  }
getProductById(long productId) {  log.info("ProductServiceImpl | getProductById is called"); log.info("ProductServiceImpl | getProductById | Get the product for productId: {}", productId);  Product product = productRepository.findById(productId) .orElseThrow( () -> new ProductServiceCustomException("Product with given Id not found","PRODUCT_NOT_FOUND"));  ProductResponse productResponse = new ProductResponse();  copyProperties(product, productResponse);  log.info("ProductServiceImpl | getProductById | productResponse :" + productResponse.toString());  return productResponse; }
[*] target: assertNotNull(productResponse)
[-] pred: org. junit. Assert. assertNotNull ( productResponse )
************************************
************************************
[+] input: test() { // 判断数据源是否加载 if (Boolean.FALSE.equals(MutilConnectionPool.check("test"))) { // 加载数据源 MutilConnectionPool.init("test", "jdbc:h2:file:./data/demo;AUTO_SERVER=TRUE", "sa", ""); }  User user = new User(); // 判断表是否存在 if (MutilConnectionPool.run("test", conn -> ModelSqlUtils.SQL(user).isTableExists(conn))) { // 删除表 MutilConnectionPool.run("test", conn -> ModelSqlUtils.dropSql(user).dropTable(conn)); } // 创建表 MutilConnectionPool.run("test", conn -> ModelSqlUtils.createSql(user).createTable(conn)); // 插入数据 user.setUserName("112233"); int count = MutilConnectionPool.run("test", conn -> ModelSqlUtils.saveSql(user).executeUpdate(conn)); Assertions.assertEquals(count, 1); // 查询数据 List<User> userList = MutilConnectionPool.run("test", conn -> ModelSqlUtils.selectSql(user).executeQuery(conn)); Assertions.assertEquals(userList.size(), 1); user.setId(userList.get(0).getId()); user.setUserName("332211"); // 更新数据 count = MutilConnectionPool.run("test", conn -> ModelSqlUtils.saveSql(user).executeUpdate(conn)); Assertions.assertEquals(count, 1); // 可以使用 ModelSqlUtils.insertSql(user)强行插入数据 // 可以使用 ModelSqlUtils.updateSql(user)强行更新数据 // 删除数据 count = MutilConnectionPool.run("test", conn -> ModelSqlUtils.deleteSql(user).executeUpdate(conn)); Assertions."<AssertPlaceHolder>"; }
deleteSql(T data) { Class<T> clazz = (Class<T>) data.getClass(); // 获取表信息 TableModel tableModel = EntityUtils.getTable(clazz); SQL<T> sql = new SQL<T>(clazz) { }.delete(); TableModel.ColumnModel keyCol = tableModel.getCols().stream().filter(TableModel.ColumnModel::getKey).findAny().orElseThrow(() -> new ModelSqlException("主键未定义")); sql.addWhereEQ(keyCol.getColumnName(), Objects.requireNonNull(EntityUtils.getValue(keyCol.getField(), data), "主键值不能为空")); return sql; }
[*] target: assertEquals(count, 1)
[-] pred: org. junit. Assert. assertEquals ( count, 1 )
************************************
************************************
[+] input: test() { // 判断数据源是否加载 if (Boolean.FALSE.equals(MutilConnectionPool.check("test"))) { // 加载数据源 MutilConnectionPool.init("test", "jdbc:h2:file:./data/demo;AUTO_SERVER=TRUE", "sa", ""); } SQL<User> userSQL = new SQL<User>() { }; // 判断表是否存在 if (Boolean.TRUE.equals(MutilConnectionPool.run("test", conn -> userSQL.isTableExists(conn)))) { // 删除表 MutilConnectionPool.run("test", conn -> userSQL.drop().dropTable(conn)); } // 创建表 MutilConnectionPool.run("test", conn -> userSQL.create().createTable(conn)); Assertions.assertEquals(true, MutilConnectionPool.check("test")); // 插入数据 int count = MutilConnectionPool.run("test", conn -> userSQL.insert().addSet("user_name", "11111").executeUpdate(conn)); Assertions.assertEquals(count, 1); // 更新数据 count = MutilConnectionPool.run("test", conn -> userSQL.update().addSet("user_name", "22222").addWhereEQ("user_name", "11111").executeUpdate(conn)); Assertions.assertEquals(count, 1); // 查询数据 List<User> userList = MutilConnectionPool.run("test", conn -> userSQL.select().addWhereEQ("user_name", "22222").executeQuery(conn)); Assertions.assertEquals(userList.size(), 1); // 删除数据 count = MutilConnectionPool.run("test", conn -> userSQL.delete().addWhereEQ("user_name", "22222").executeUpdate(conn)); Assertions."<AssertPlaceHolder>"; }
executeUpdate(Connection connection) { // 检查操作类型是否为新增、更新或删除，否则抛出异常 if (statementType != StatementType.INSERT && statementType != StatementType.UPDATE && statementType != StatementType.DELETE) throw new SQLRuntimeException("非新增、更新、删除模式，不能调用executeUpdate方法！");  // 如果数据库类型未设置，则自动识别数据库类型 if (dbType == null) dialect(); // 如果仍未设置数据库类型，则通过连接自动识别 if (dbType == null) dialect(connection);  // 解析SQL语句 parse();  // 执行更新操作，并返回影响的行数 return ExecuteSqlUtils.executeUpdate(connection, this.sqls.get(0), this.params); }
[*] target: assertEquals(count, 1)
[-] pred: org. junit. Assert. assertEquals ( count, 1 )
************************************
************************************
[+] input: nothingTest() { val list = Lists.of(); SerCons.nothing().andThen(list::add).accept("foo"); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("foo", list.get(0)); }
andThen(SerBiCons<? super T, ? super U> after) { Objects.requireNonNull(after); return (l, r) -> { accepting(l, r); after.accepting(l, r); }; }
[*] target: assertEquals(1, list.size())
[-] pred: org. junit. Assert. assertEquals ( 1, list. size ( ) )
************************************
************************************
[+] input: testTypeOfFilter() { Stream.<SerRunn>of( () -> { Opp<String> opp = Opp.of("").typeOfFilter((String str) -> str.trim().isEmpty()); Assertions.assertTrue(opp.isPresent()); }, () -> { Opp<String> opp = Opp.of("").typeOfFilter((String str) -> !str.trim().isEmpty()); Assertions."<AssertPlaceHolder>"; }) .forEach(SerRunn::run); }
isEmpty() { return value == null; }
[*] target: assertTrue(opp.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( opp. isEmpty ( ) )
************************************
************************************
[+] input: testZip() { Stream.<SerRunn>of( () -> { String biMap = Opp.of(1).zip(Opp.of("st"), (l, r) -> l + r).get(); Assertions.assertEquals("1st", biMap); }, () -> { String biMap = Opp.of(1).zip(Opp.<String>empty(), (l, r) -> l + r).get(); Assertions."<AssertPlaceHolder>"; }) .forEach(SerRunn::run); }
get() { return this.value; }
[*] target: assertNull(biMap)
[-] pred: org. junit. Assert. assertNull ( biMap )
************************************
************************************
[+] input: testZipOrSelf() { Stream.<SerRunn>of( () -> { String compose = Opp.ofStr("Vampire").zipOrSelf(Opp.of("Achao"), String::concat).get(); Assertions.assertEquals("VampireAchao", compose); }, () -> { String compose = Opp.ofStr("Vampire").zipOrSelf(Opp.empty(), String::concat).get(); Assertions.assertEquals("Vampire", compose); }, () -> { String compose = Opp.ofStr("").zipOrSelf(Opp.empty(), String::concat).get(); Assertions."<AssertPlaceHolder>"; }) .forEach(SerRunn::run); }
get() { return this.value; }
[*] target: assertNull(compose)
[-] pred: org. junit. Assert. assertNull ( compose )
************************************
************************************
[+] input: NoSuchMethodException { WrappingLookupCommand command = new WrappingLookupCommand(); Context testContext = new ContextBase();  Context wrapped = command.getContext(testContext);  "<AssertPlaceHolder>"; assertSame(testContext, wrapped); }
getContext(Context context) throws ClassNotFoundException, InstantiationException, InvocationTargetException, IllegalAccessException, NoSuchMethodException { if (wrapperClassName == null) { log.debug("No defined wrapper class; " + "returning original context.");  return context; }  log.debug("Looking for wrapper class: {}", wrapperClassName);  Class<?> wrapperClass = ClassUtils.getApplicationClass(wrapperClassName);  log.debug("Instantiating wrapper class");  return (Context) ConstructorUtils.invokeConstructor(wrapperClass, context); }
[*] target: assertNotNull(wrapped)
[-] pred: org. junit. Assert. assertNotNull ( wrapped )
************************************
************************************
[+] input: testAspectRunnable() { CountDownLatch checkRunnableIsCalled = new CountDownLatch(3); // before, runner, after DisposableThreadGroupAspect<DisposableThreadGroupBase> aspect = Mockito.mock(DisposableThreadGroupAspect.class); try (MockedStatic<AspectUtils> aspectUtilsMockedStatic = Mockito.mockStatic(AspectUtils.class)) { aspectUtilsMockedStatic.when(() -> AspectUtils.executeAspect(Mockito.any(), Mockito.any())).thenAnswer(invocationOnMock -> { checkRunnableIsCalled.countDown(); return null; });  Runnable realRunnable = checkRunnableIsCalled::countDown; Runnable aspectRunnable = AspectRunnableUtil.aspectRunnable(aspect, realRunnable); Assertions."<AssertPlaceHolder>"; aspectRunnable.run();  try { // 等待子线程被调用一次，最多等待5秒 Assertions.assertTrue(checkRunnableIsCalled.await(100, TimeUnit.MILLISECONDS), "Runnable is not called"); } catch (InterruptedException ignore) { Thread.currentThread().interrupt(); } }  }
aspectRunnable(DisposableThreadGroupAspect<? extends DisposableThreadGroupBase> aspect, Runnable runnable){ return () -> { try { AspectUtils.executeAspect(DisposableThreadGroupAspect.class, () -> aspect); runnable.run(); } finally { AspectUtils.executeAspect(DisposableThreadGroupAspect.class, aspect::release); } }; }
[*] target: assertNotNull(aspectRunnable)
[-] pred: org. junit. Assert. assertNotNull ( aspectRunnable )
************************************
************************************
[+] input: testTransformFromTapValueTapUpdateRecordEventWithoutAfter() { TapdataEvent tapdataEvent = new TapdataEvent(); when(tapUpdateRecordEvent.getAfter()).thenReturn(null); tapdataEvent.setTapEvent(tapUpdateRecordEvent); HazelcastBaseNode.TapValueTransform actual = hazelcastBaseNode.transformFromTapValue(tapdataEvent); assertNotNull(actual); "<AssertPlaceHolder>"; }
getAfter() { return after; }
[*] target: assertNull(actual.getAfter())
[-] pred: org. junit. Assert. assertNull ( actual. getAfter() )
************************************
************************************
[+] input: testGetTableNameOnlyHaveMessageEntity() { when(tapdataEvent.getMessageEntity()).thenReturn(messageEntity); when(tapdataEvent.getTapEvent()).thenReturn(null); String tableName = hazelcastBaseNode.getTableName(tapdataEvent); verify(tapdataEvent, new Times(1)).getMessageEntity(); "<AssertPlaceHolder>"; assertEquals(TABLE_NAME1, tableName); }
getTableName(TapdataEvent tapdataEvent) { if (null == tapdataEvent) return ""; MessageEntity messageEntity = tapdataEvent.getMessageEntity(); TapEvent tapEvent = tapdataEvent.getTapEvent(); if (null != messageEntity) { return messageEntity.getTableName(); } else { if (tapEvent instanceof TapBaseEvent) { return ((TapBaseEvent) tapEvent).getTableId(); } else { return ""; } } }
[*] target: assertNotNull(tableName)
[-] pred: org. junit. Assert. assertNotNull ( tableName )
************************************
************************************
[+] input: testGetTableNameOnlyHaveTapEvent() { when(tapdataEvent.getMessageEntity()).thenReturn(null); when(tapdataEvent.getTapEvent()).thenReturn(tapInsertRecordEvent); tapdataEvent.setTapEvent(tapInsertRecordEvent); String tableName = hazelcastBaseNode.getTableName(tapdataEvent); verify(tapdataEvent, new Times(1)).getTapEvent(); "<AssertPlaceHolder>"; assertEquals(TABLE_NAME2, tableName); }
getTableName(TapdataEvent tapdataEvent) { if (null == tapdataEvent) return ""; MessageEntity messageEntity = tapdataEvent.getMessageEntity(); TapEvent tapEvent = tapdataEvent.getTapEvent(); if (null != messageEntity) { return messageEntity.getTableName(); } else { if (tapEvent instanceof TapBaseEvent) { return ((TapBaseEvent) tapEvent).getTableId(); } else { return ""; } } }
[*] target: assertNotNull(tableName)
[-] pred: org. junit. Assert. assertNotNull ( tableName )
************************************
************************************
[+] input: testGetTableNameBothHaveMessageEntityAndTapEvent() { when(tapdataEvent.getMessageEntity()).thenReturn(messageEntity); when(tapdataEvent.getTapEvent()).thenReturn(tapInsertRecordEvent); tapdataEvent.setTapEvent(tapInsertRecordEvent); String tableName = hazelcastBaseNode.getTableName(tapdataEvent); verify(tapdataEvent, new Times(1)).getTapEvent(); "<AssertPlaceHolder>"; assertEquals(TABLE_NAME1, tableName); }
getTableName(TapdataEvent tapdataEvent) { if (null == tapdataEvent) return ""; MessageEntity messageEntity = tapdataEvent.getMessageEntity(); TapEvent tapEvent = tapdataEvent.getTapEvent(); if (null != messageEntity) { return messageEntity.getTableName(); } else { if (tapEvent instanceof TapBaseEvent) { return ((TapBaseEvent) tapEvent).getTableId(); } else { return ""; } } }
[*] target: assertNotNull(tableName)
[-] pred: org. junit. Assert. assertNotNull ( tableName )
************************************
************************************
[+] input: testGetTableNameWithNullTapdataEvent() { String tableName = hazelcastBaseNode.getTableName(null); "<AssertPlaceHolder>"; assertEquals("", tableName); }
getTableName(TapdataEvent tapdataEvent) { if (null == tapdataEvent) return ""; MessageEntity messageEntity = tapdataEvent.getMessageEntity(); TapEvent tapEvent = tapdataEvent.getTapEvent(); if (null != messageEntity) { return messageEntity.getTableName(); } else { if (tapEvent instanceof TapBaseEvent) { return ((TapBaseEvent) tapEvent).getTableId(); } else { return ""; } } }
[*] target: assertNotNull(tableName)
[-] pred: org. junit. Assert. assertNotNull ( tableName )
************************************
************************************
[+] input: testGetTableNameNotTapBaseEvent() { when(tapdataEvent.getMessageEntity()).thenReturn(null); when(tapdataEvent.getTapEvent()).thenReturn(heartbeatEvent); String tableName = hazelcastBaseNode.getTableName(tapdataEvent); "<AssertPlaceHolder>"; assertEquals("", tableName); }
getTableName(TapdataEvent tapdataEvent) { if (null == tapdataEvent) return ""; MessageEntity messageEntity = tapdataEvent.getMessageEntity(); TapEvent tapEvent = tapdataEvent.getTapEvent(); if (null != messageEntity) { return messageEntity.getTableName(); } else { if (tapEvent instanceof TapBaseEvent) { return ((TapBaseEvent) tapEvent).getTableId(); } else { return ""; } } }
[*] target: assertNotNull(tableName)
[-] pred: org. junit. Assert. assertNotNull ( tableName )
************************************
************************************
[+] input: testInitSettingService() { ReflectionTestUtils.setField(hazelcastBaseNode, "clientMongoOperator", mockClientMongoOperator); SettingService actual = hazelcastBaseNode.initSettingService(); "<AssertPlaceHolder>"; assertEquals(mockClientMongoOperator, ReflectionTestUtils.getField(actual, "clientMongoOperator")); }
initSettingService() { if (null == clientMongoOperator) { throw new TapCodeException(TaskProcessorExCode_11.INIT_SETTING_SERVICE_FAILED_CLIENT_MONGO_OPERATOR_IS_NULL); } return new SettingService(clientMongoOperator); }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: testGetOutboxAndCheckNullable() { Outbox mockOutbox = mock(Outbox.class); ReflectionTestUtils.setField(hazelcastBaseNode, "outbox", mockOutbox); Outbox actual = hazelcastBaseNode.getOutboxAndCheckNullable(); "<AssertPlaceHolder>"; assertEquals(mockOutbox, actual); }
getOutboxAndCheckNullable() { Outbox outbox = getOutbox(); if (null == outbox) { throw new TapCodeException(TaskProcessorExCode_11.OUTBOX_IS_NULL_WHEN_OFFER, "Get outbox failed, outbox is null"); } return outbox; }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: testTableIUDAndRename() {  // create table TapCreateTableEvent createTable = new TapCreateTableEvent(); createTable.setTableId(tableName); String currentTableName = instance.getTgtTableNameFromTapEvent(createTable); Assertions.assertEquals(expected, currentTableName);  // rename table TapRenameTableEvent tableEvent = new TapRenameTableEvent(); tableEvent.setTableId(tableName); tableEvent.setNameChanges(Collections.singletonList(new ValueChange<>(tableName, expected))); currentTableName = instance.getTgtTableNameFromTapEvent(tableEvent); Assertions.assertEquals(expected, currentTableName);  // drop table TapDropTableEvent dropTable = new TapDropTableEvent(); dropTable.setTableId(tableName); currentTableName = instance.getTgtTableNameFromTapEvent(dropTable); Assertions.assertEquals(expected, currentTableName);  // second stop table test tableName not in cache currentTableName = instance.getTgtTableNameFromTapEvent(dropTable); Assertions."<AssertPlaceHolder>"; }
getTgtTableNameFromTapEvent(TapEvent tapEvent) { String tableId = TapEventUtil.getTableId(tapEvent); TableRenameProcessNode tableRenameProcessNode = (TableRenameProcessNode) getNode(); if (tapEvent instanceof TapRenameTableEvent) { String newTableId = tableRenameProcessNode.convertTableName(tableNameMappingMap, tableId, true); innerTableCacheMap.put(tableId, newTableId); return newTableId; } else if (tapEvent instanceof TapDropTableEvent) { String newTableId = innerTableCacheMap.remove(tableId); if (null == newTableId) { newTableId = tableRenameProcessNode.convertTableName(tableNameMappingMap, tableId, false); } return newTableId; } else { return innerTableCacheMap.computeIfAbsent(tableId, id -> tableRenameProcessNode.convertTableName(tableNameMappingMap, tableId, false)); } }
[*] target: assertEquals(expected, currentTableName)
[-] pred: org. junit. Assert. assertEquals ( expected, currentTableName )
************************************
************************************
[+] input: testStartTaskOperation() { TaskDto taskDto = new TaskDto(); taskDto.setId(ObjectId.get()); taskDto.setName("test-task"); TaskOperation taskOperation = StartTaskOperation.create().taskDto(taskDto); AtomicBoolean isCallStartTask = new AtomicBoolean(false); TapdataTaskScheduler instance = new TapdataTaskScheduler() { @Override protected void startTask(TaskDto taskDto) { isCallStartTask.set(true); } };  Runnable handleTaskOperationRunnable = instance.getHandleTaskOperationRunnable(taskOperation); "<AssertPlaceHolder>"; handleTaskOperationRunnable.run(); assertTrue(isCallStartTask.get()); }
getHandleTaskOperationRunnable(TaskOperation taskOperation) { return () -> { String taskId; try { if (taskOperation instanceof StartTaskOperation) { StartTaskOperation startTaskOperation = (StartTaskOperation) taskOperation; Thread.currentThread().setName(String.format("Start-Task-Operation-Handler-%s[%s]", startTaskOperation.getTaskDto().getName(), startTaskOperation.getTaskDto().getId())); taskId = startTaskOperation.getTaskDto().getId().toHexString(); TaskDto taskDto = startTaskOperation.getTaskDto(); if (!taskLock.tryRun(taskId, ()-> startTask(taskDto), 1L, TimeUnit.SECONDS)) { logger.warn("Start task {} failed because of task lock, will ignored", taskDto.getName()); } } else if (taskOperation instanceof StopTaskOperation) { StopTaskOperation stopTaskOperation = (StopTaskOperation) taskOperation; Thread.currentThread().setName(String.format("Stop-Task-Operation-Handler-%s", stopTaskOperation.getTaskId())); taskId = stopTaskOperation.getTaskId(); if (!taskLock.tryRun(taskId, () -> stopTask(taskId), 1L, TimeUnit.SECONDS)) { logger.warn("Stop task {} failed because of task lock, will retry later", taskId); } } logger.info("Handled task operation: {}", taskOperation); } catch (Exception e) { if (TmUnavailableException.isInstance(e)) { logger.warn("Handle task operation failed because TM unavailable: {}", e.getMessage()); } else { logger.error("Handle task operation error", e); } } }; }
[*] target: assertNotNull(handleTaskOperationRunnable)
[-] pred: org. junit. Assert. assertNotNull ( handleTaskOperationRunnable )
************************************
************************************
[+] input: getLogConfTest() { AgentLogConfigurationWatcher agentLogConfigurationWatcher = new AgentLogConfigurationWatcher(); try(MockedStatic<ObsLoggerFactory> obsLoggerFactoryMockedStatic = mockStatic(ObsLoggerFactory.class); MockedStatic<BeanUtil> beanUtilMockedStatic = mockStatic(BeanUtil.class)){ ObsLoggerFactory obsLoggerFactory = mock(ObsLoggerFactory.class); when(ObsLoggerFactory.getInstance()).thenReturn(obsLoggerFactory); SettingService settingService = mock(SettingService.class); when(BeanUtil.getBean(SettingService.class)).thenReturn(settingService); when(settingService.getString("scriptEngineHttpAppender", "false")).thenReturn("false"); when(settingService.getString("logLevel","info")).thenReturn("info"); LogConfiguration logConfiguration = LogConfiguration.builder().logSaveTime(180).logSaveSize(10).logSaveCount(10).build(); when(obsLoggerFactory.getLogConfiguration("agent")).thenReturn(logConfiguration); LogConfiguration logConf = agentLogConfigurationWatcher.getLogConfig(); "<AssertPlaceHolder>"; assertEquals("info",logConf.getLogLevel()); assertEquals("false",logConf.getScriptEngineHttpAppender()); assertEquals(180,logConf.getLogSaveTime()); assertEquals(10,logConf.getLogSaveSize()); assertEquals(10,logConf.getLogSaveCount()); } }
getLogConfig() { SettingService settingService = BeanUtil.getBean(SettingService.class); LogConfiguration logConfiguration = ObsLoggerFactory.getInstance().getLogConfiguration(AGENT); String scriptEngineHttpApender = settingService.getString("scriptEngineHttpAppender", "false"); String logLevel = settingService.getString("logLevel","info"); logConfiguration.setLogLevel(logLevel); logConfiguration.setScriptEngineHttpAppender(scriptEngineHttpApender); return logConfiguration; }
[*] target: assertEquals(logConfiguration,logConf)
[-] pred: org. junit. Assert. assertEquals ( logConfiguration, logConf )
************************************
************************************
[+] input: testGlobalStateMap() { ExternalStorageDto externalStorageDto = new ExternalStorageDto(); externalStorageDto.setId(new ObjectId()); externalStorageDto.setType(ExternalStorageType.mongodb.getMode()); externalStorageDto.setUri("mongodb://localhost:27017/test"); externalStorageDto.setTtlDay(3); PersistenceStorage persistenceStorage = spy(PersistenceStorage.getInstance()); IMap iMap = mock(IMap.class); when(iMap.isEmpty()).thenReturn(false); doReturn(persistenceStorage).when(persistenceStorage).initMapStoreConfig(anyString(), any(Config.class), anyString()); doReturn(iMap).when(mockHazelcastInstance).getMap(anyString()); try ( MockedStatic<ExternalStorageUtil> externalStorageUtilMockedStatic = mockStatic(ExternalStorageUtil.class); MockedStatic<PersistenceStorage> persistenceStorageMockedStatic = mockStatic(PersistenceStorage.class) ) { persistenceStorageMockedStatic.when(PersistenceStorage::getInstance).thenReturn(persistenceStorage); externalStorageUtilMockedStatic.when(ExternalStorageUtil::getTapdataOrDefaultExternalStorage).thenReturn(externalStorageDto); externalStorageUtilMockedStatic.when(() -> ExternalStorageUtil.initHZMapStorage(eq(externalStorageDto), anyString(), anyString(), any(Config.class))).thenAnswer(invocationOnMock -> null); PdkStateMap pdkStateMap = PdkStateMap.globalStateMap(mockHazelcastInstance); "<AssertPlaceHolder>"; Object actualConstructIMap = ReflectionTestUtils.getField(pdkStateMap, "constructIMap"); assertNotNull(actualConstructIMap); assertInstanceOf(DocumentIMap.class, actualConstructIMap); assertNotNull(((DocumentIMap) actualConstructIMap).getiMap()); assertEquals(iMap, ((DocumentIMap) actualConstructIMap).getiMap()); assertEquals(0, externalStorageDto.getTtlDay()); } }
globalStateMap(HazelcastInstance hazelcastInstance) { if (globalStateMap == null) { synchronized (GLOBAL_STATE_MAP_LOCK) { if (globalStateMap == null) { synchronized (GLOBAL_STATE_MAP_LOCK) { globalStateMap = new PdkStateMap(hazelcastInstance, GLOBAL_MAP_NAME); } } } } return globalStateMap; }
[*] target: assertNotNull(pdkStateMap)
[-] pred: org. junit. Assert. assertNotNull ( pdkStateMap )
************************************
************************************
[+] input: testNormal() { milestoneAspectTask.taskMilestone("code", consumer); MilestoneEntity code = milestones.get("code"); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("code", code.getCode()); Assertions.assertEquals(MilestoneStatus.FINISH, code.getStatus()); verify(consumer).accept(any(MilestoneEntity.class)); }
taskMilestone(String code, Consumer<MilestoneEntity> consumer) { MilestoneEntity entity = milestones.get(code); if (null == entity) { synchronized (milestones) { entity = milestones.computeIfAbsent(code, s -> new MilestoneEntity(code, MilestoneStatus.WAITING)); } } if (null != consumer) { consumer.accept(entity); } }
[*] target: assertNotNull(code)
[-] pred: org. junit. Assert. assertNotNull ( code )
************************************
************************************
[+] input: testMilestoneEntityIsNull() { milestones.put("code", null); milestoneAspectTask.taskMilestone("code", consumer); MilestoneEntity code = milestones.get("code"); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("code", code.getCode()); Assertions.assertEquals(MilestoneStatus.WAITING, code.getStatus()); verify(consumer).accept(any(MilestoneEntity.class)); }
taskMilestone(String code, Consumer<MilestoneEntity> consumer) { MilestoneEntity entity = milestones.get(code); if (null == entity) { synchronized (milestones) { entity = milestones.computeIfAbsent(code, s -> new MilestoneEntity(code, MilestoneStatus.WAITING)); } } if (null != consumer) { consumer.accept(entity); } }
[*] target: assertNotNull(code)
[-] pred: org. junit. Assert. assertNotNull ( code )
************************************
************************************
[+] input: testTaskNullEndTime() { task.setStatus(MilestoneStatus.FINISH); node.setStatus(MilestoneStatus.FINISH); task.setEnd(null); String taskSyncStatus = milestoneAspectTask.getTaskSyncStatus(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(MilestoneAspectTask.KPI_DATA_NODE_INIT, taskSyncStatus); }
getTaskSyncStatus() { Collection<MilestoneEntity> values = new ArrayList<>(milestones.values()); List<MilestoneEntity> sorted = values.stream() .filter(m -> Objects.nonNull(m) && !MilestoneStatus.WAITING.equals(m.getStatus())) .sorted((m1, m2) -> { MilestoneStatus s1 = m1.getStatus(); MilestoneStatus s2 = m2.getStatus(); if (KPI_CDC.equals(m1.getCode())) return -1; if (KPI_CDC.equals(m2.getCode())) return 1; if (MilestoneStatus.RUNNING.equals(s1)) return -1; if (MilestoneStatus.RUNNING.equals(s2)) return 1; Long e1 = m1.getEnd(); Long e2 = m2.getEnd(); if (null == e1) e1 = 0L; if (null == e2) e2 = 0L; return e2.intValue() - e1.intValue(); }).collect(Collectors.toList()); if (sorted.isEmpty()) return KPI_TASK; return sorted.get(0).getCode(); }
[*] target: assertNotNull(taskSyncStatus)
[-] pred: org. junit. Assert. assertNotNull ( taskSyncStatus )
************************************
************************************
[+] input: testCountTapDataEvent() { List<TapdataEvent> events = new ArrayList<>(); TapdataEvent e = new TapdataEvent(); e.setTapEvent(tapEvent); events.add(e); HandlerUtil.EventTypeRecorder recorder = HandlerUtil.countTapdataEvent(events); Assertions.assertNotNull(recorder); Assertions.assertTrue(recorder.getMemorySize() > 0); Assertions.assertEquals(1, recorder.getUpdateTotal()); Assertions.assertEquals(0, recorder.getInsertTotal()); Assertions.assertEquals(0, recorder.getDdlTotal()); Assertions."<AssertPlaceHolder>"; }
getTotal() { return ddlTotal + insertTotal + updateTotal + deleteTotal + othersTotal; }
[*] target: assertEquals(1, recorder.getTotal())
[-] pred: org. junit. Assert. assertEquals ( 1, recorder. getTotal() )
************************************
************************************
[+] input: testCountTapDataEventOfTapDataHeartbeatEvent() { List<TapdataEvent> events = new ArrayList<>(); TapdataHeartbeatEvent event = new TapdataHeartbeatEvent(); Long time = System.currentTimeMillis() - 5; event.setSourceTime(time); events.add(event); HandlerUtil.EventTypeRecorder recorder = HandlerUtil.countTapdataEvent(events); Assertions.assertNotNull(recorder); Assertions.assertEquals(0, recorder.getMemorySize()); Assertions.assertEquals(0, recorder.getUpdateTotal()); Assertions.assertEquals(0, recorder.getInsertTotal()); Assertions.assertEquals(0, recorder.getDdlTotal()); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(recorder.getReplicateLagTotal() > 4); }
getTotal() { return ddlTotal + insertTotal + updateTotal + deleteTotal + othersTotal; }
[*] target: assertEquals(0, recorder.getTotal())
[-] pred: org. junit. Assert. assertEquals ( 0, recorder. getTotal() )
************************************
************************************
[+] input: testCountTapDataEventOfNotTapDataHeartbeatEvent() { List<TapdataEvent> events = new ArrayList<>(); TapdataShareLogEvent event = new TapdataShareLogEvent(); Long time = System.currentTimeMillis() - 5; event.setSourceTime(time); events.add(event); HandlerUtil.EventTypeRecorder recorder = HandlerUtil.countTapdataEvent(events); Assertions.assertNotNull(recorder); Assertions.assertEquals(0, recorder.getMemorySize()); Assertions.assertEquals(0, recorder.getUpdateTotal()); Assertions.assertEquals(0, recorder.getInsertTotal()); Assertions.assertEquals(0, recorder.getDdlTotal()); Assertions."<AssertPlaceHolder>"; Assertions.assertNull(recorder.getReplicateLagTotal()); }
getTotal() { return ddlTotal + insertTotal + updateTotal + deleteTotal + othersTotal; }
[*] target: assertEquals(0, recorder.getTotal())
[-] pred: org. junit. Assert. assertEquals ( 0, recorder. getTotal() )
************************************
************************************
[+] input: testCountTapEvent1() { List<TapEvent> events = new ArrayList<>(); HandlerUtil.EventTypeRecorder recorder = HandlerUtil.countTapEvent(events); Assertions.assertNotNull(recorder); Assertions.assertEquals(0, recorder.getMemorySize()); Assertions.assertEquals(0, recorder.getUpdateTotal()); Assertions.assertEquals(0, recorder.getInsertTotal()); Assertions.assertEquals(0, recorder.getDdlTotal()); Assertions."<AssertPlaceHolder>"; }
getTotal() { return ddlTotal + insertTotal + updateTotal + deleteTotal + othersTotal; }
[*] target: assertEquals(0, recorder.getTotal())
[-] pred: org. junit. Assert. assertEquals ( 0, recorder. getTotal() )
************************************
************************************
[+] input: testCountTapEvent2() { List<TapdataEvent> events = new ArrayList<>(); TapdataHeartbeatEvent event = new TapdataHeartbeatEvent(); event.setSourceTime(System.currentTimeMillis()); events.add(event); HandlerUtil.EventTypeRecorder recorder = HandlerUtil.countTapdataEvent(events); Assertions.assertNotNull(recorder); Assertions.assertEquals(0, recorder.getMemorySize()); Assertions.assertEquals(0, recorder.getUpdateTotal()); Assertions.assertEquals(0, recorder.getInsertTotal()); Assertions.assertEquals(0, recorder.getDdlTotal()); Assertions."<AssertPlaceHolder>"; }
getTotal() { return ddlTotal + insertTotal + updateTotal + deleteTotal + othersTotal; }
[*] target: assertEquals(0, recorder.getTotal())
[-] pred: org. junit. Assert. assertEquals ( 0, recorder. getTotal() )
************************************
************************************
[+] input: testLoopByConfigNormal() { try (MockedStatic<TapSimplify> mockedStatic = mockStatic(TapSimplify.class)) { mockedStatic.when(() -> TapSimplify.toJson(any(Object.class))).thenReturn("mokc json"); boolean byConfig = utils.loopByConfig(configFile, log, "mock", "python-jar-path"); mockedStatic.verify(() -> TapSimplify.toJson(any(Map.class)), times(1)); Assertions."<AssertPlaceHolder>"; } finally { assertVerify(1, 1, 1, 1); } }
loopByConfig(File config, Log logger, final String loopPath, final String pythonJarPath) { //按照配置文件来编译第三方Python包 Map<String, Object> configMap = getPythonConfig(config); Object sitePackages = configMap.get(PYTHON_THREAD_SITE_PACKAGES_PATH); if (sitePackages instanceof Collection) { Collection<String> packages = (Collection<String>) sitePackages; if (!packages.isEmpty()) { logger.info("Configuration files will be used for package compilation： {}", toJson(configMap)); List<File> path = new ArrayList<>(); for (Object name : packages) { if (null == name) continue; path.add(new File(concat(loopPath, String.valueOf(name)))); } if (!path.isEmpty()) { loopFiles(path, logger, pythonJarPath); return true; } } } return false; }
[*] target: assertTrue(byConfig)
[-] pred: org. junit. Assert. assertTrue ( byConfig )
************************************
************************************
[+] input: testLoopByConfigConfigValueNotCollection() { try (MockedStatic<TapSimplify> mockedStatic = mockStatic(TapSimplify.class)) { mockedStatic.when(() -> TapSimplify.toJson(any(Object.class))).thenReturn("mokc json"); when(configMap.get(PythonUtils.PYTHON_THREAD_SITE_PACKAGES_PATH)).thenReturn("string values"); boolean byConfig = utils.loopByConfig(configFile, log, "mock", "python-jar-path"); mockedStatic.verify(() -> TapSimplify.toJson(any(Map.class)), times(0)); Assertions."<AssertPlaceHolder>"; } finally { assertVerify(1, 1, 0, 0); } }
loopByConfig(File config, Log logger, final String loopPath, final String pythonJarPath) { //按照配置文件来编译第三方Python包 Map<String, Object> configMap = getPythonConfig(config); Object sitePackages = configMap.get(PYTHON_THREAD_SITE_PACKAGES_PATH); if (sitePackages instanceof Collection) { Collection<String> packages = (Collection<String>) sitePackages; if (!packages.isEmpty()) { logger.info("Configuration files will be used for package compilation： {}", toJson(configMap)); List<File> path = new ArrayList<>(); for (Object name : packages) { if (null == name) continue; path.add(new File(concat(loopPath, String.valueOf(name)))); } if (!path.isEmpty()) { loopFiles(path, logger, pythonJarPath); return true; } } } return false; }
[*] target: assertFalse(byConfig)
[-] pred: org. junit. Assert. assertFalse ( byConfig )
************************************
************************************
[+] input: testLoopByConfigConfigValueIsEmptyCollection() { try (MockedStatic<TapSimplify> mockedStatic = mockStatic(TapSimplify.class)) { mockedStatic.when(() -> TapSimplify.toJson(any(Object.class))).thenReturn("mokc json"); packages = new ArrayList<>(); when(configMap.get(PythonUtils.PYTHON_THREAD_SITE_PACKAGES_PATH)).thenReturn(packages); boolean byConfig = utils.loopByConfig(configFile, log, "mock", "python-jar-path"); mockedStatic.verify(() -> TapSimplify.toJson(any(Map.class)), times(0)); Assertions."<AssertPlaceHolder>"; } finally { assertVerify(1, 1, 0, 0); } }
loopByConfig(File config, Log logger, final String loopPath, final String pythonJarPath) { //按照配置文件来编译第三方Python包 Map<String, Object> configMap = getPythonConfig(config); Object sitePackages = configMap.get(PYTHON_THREAD_SITE_PACKAGES_PATH); if (sitePackages instanceof Collection) { Collection<String> packages = (Collection<String>) sitePackages; if (!packages.isEmpty()) { logger.info("Configuration files will be used for package compilation： {}", toJson(configMap)); List<File> path = new ArrayList<>(); for (Object name : packages) { if (null == name) continue; path.add(new File(concat(loopPath, String.valueOf(name)))); } if (!path.isEmpty()) { loopFiles(path, logger, pythonJarPath); return true; } } } return false; }
[*] target: assertFalse(byConfig)
[-] pred: org. junit. Assert. assertFalse ( byConfig )
************************************
************************************
[+] input: testLoopByConfigConfigValueIsCollectionButAllElementNotString() { try (MockedStatic<TapSimplify> mockedStatic = mockStatic(TapSimplify.class)) { mockedStatic.when(() -> TapSimplify.toJson(any(Object.class))).thenReturn("mokc json"); when(utils.getPythonConfig(any(File.class))).thenReturn(configMap); packages = new ArrayList<>(); packages.add("mock"); packages.add(100); when(configMap.get(PythonUtils.PYTHON_THREAD_SITE_PACKAGES_PATH)).thenReturn(packages); boolean byConfig = utils.loopByConfig(configFile, log, "mock", "python-jar-path"); mockedStatic.verify(() -> TapSimplify.toJson(any(Map.class)), times(1)); Assertions."<AssertPlaceHolder>"; } finally { assertVerify(1, 1, 1, 1); } }
loopByConfig(File config, Log logger, final String loopPath, final String pythonJarPath) { //按照配置文件来编译第三方Python包 Map<String, Object> configMap = getPythonConfig(config); Object sitePackages = configMap.get(PYTHON_THREAD_SITE_PACKAGES_PATH); if (sitePackages instanceof Collection) { Collection<String> packages = (Collection<String>) sitePackages; if (!packages.isEmpty()) { logger.info("Configuration files will be used for package compilation： {}", toJson(configMap)); List<File> path = new ArrayList<>(); for (Object name : packages) { if (null == name) continue; path.add(new File(concat(loopPath, String.valueOf(name)))); } if (!path.isEmpty()) { loopFiles(path, logger, pythonJarPath); return true; } } } return false; }
[*] target: assertTrue(byConfig)
[-] pred: org. junit. Assert. assertTrue ( byConfig )
************************************
************************************
[+] input: testLoopByConfigConfigValueIsCollectionButElementsContainsNullString() { try (MockedStatic<TapSimplify> mockedStatic = mockStatic(TapSimplify.class)) { mockedStatic.when(() -> TapSimplify.toJson(any(Object.class))).thenReturn("mokc json"); packages = new ArrayList<>(); packages.add("mock"); packages.add(null); when(configMap.get(PythonUtils.PYTHON_THREAD_SITE_PACKAGES_PATH)).thenReturn(packages); boolean byConfig = utils.loopByConfig(configFile, log, "mock", "python-jar-path"); mockedStatic.verify(() -> TapSimplify.toJson(any(Object.class)), times(1)); Assertions."<AssertPlaceHolder>"; } finally { assertVerify(1, 1, 1,  1); } }
loopByConfig(File config, Log logger, final String loopPath, final String pythonJarPath) { //按照配置文件来编译第三方Python包 Map<String, Object> configMap = getPythonConfig(config); Object sitePackages = configMap.get(PYTHON_THREAD_SITE_PACKAGES_PATH); if (sitePackages instanceof Collection) { Collection<String> packages = (Collection<String>) sitePackages; if (!packages.isEmpty()) { logger.info("Configuration files will be used for package compilation： {}", toJson(configMap)); List<File> path = new ArrayList<>(); for (Object name : packages) { if (null == name) continue; path.add(new File(concat(loopPath, String.valueOf(name)))); } if (!path.isEmpty()) { loopFiles(path, logger, pythonJarPath); return true; } } } return false; }
[*] target: assertTrue(byConfig)
[-] pred: org. junit. Assert. assertTrue ( byConfig )
************************************
************************************
[+] input: testLoopByConfigConfigValueIsCollectionButAllElementsAreNullString() { try (MockedStatic<TapSimplify> mockedStatic = mockStatic(TapSimplify.class)) { mockedStatic.when(() -> TapSimplify.toJson(any(Object.class))).thenReturn("mokc json"); packages = new ArrayList<>(); packages.add(null); when(configMap.get(PythonUtils.PYTHON_THREAD_SITE_PACKAGES_PATH)).thenReturn(packages); boolean byConfig = utils.loopByConfig(configFile, log, "mock", "python-jar-path"); mockedStatic.verify(() -> TapSimplify.toJson(any(Object.class)), times(1)); Assertions."<AssertPlaceHolder>"; } finally { assertVerify(1, 1, 0, 1); } }
loopByConfig(File config, Log logger, final String loopPath, final String pythonJarPath) { //按照配置文件来编译第三方Python包 Map<String, Object> configMap = getPythonConfig(config); Object sitePackages = configMap.get(PYTHON_THREAD_SITE_PACKAGES_PATH); if (sitePackages instanceof Collection) { Collection<String> packages = (Collection<String>) sitePackages; if (!packages.isEmpty()) { logger.info("Configuration files will be used for package compilation： {}", toJson(configMap)); List<File> path = new ArrayList<>(); for (Object name : packages) { if (null == name) continue; path.add(new File(concat(loopPath, String.valueOf(name)))); } if (!path.isEmpty()) { loopFiles(path, logger, pythonJarPath); return true; } } } return false; }
[*] target: assertFalse(byConfig)
[-] pred: org. junit. Assert. assertFalse ( byConfig )
************************************
************************************
[+] input: testGetLibPathNormal() { when(utils.getLibPath(jarName, ato)).thenCallRealMethod(); classLoader = mock(URLClassLoader.class); when(utils.getCurrentThreadContextClassLoader()).thenReturn(classLoader); when(((URLClassLoader)classLoader).getURLs()).thenReturn(urls); InputStream libPath = utils.getLibPath(jarName, ato); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(stream, libPath); Assertions.assertEquals(mockPath, ato.get()); verify((URLClassLoader)classLoader, times(1)).getURLs(); assertVerify(1, 1, 1); }
getLibPath(String jarName, AtomicReference<String> ato) throws IOException { InputStream pyJarPath = null; ClassLoader classLoader = getCurrentThreadContextClassLoader(); if (classLoader instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) classLoader).getURLs(); for (URL url : urls) { String jarPath = url.getPath(); if (jarPath.contains(jarName)) { pyJarPath = url.openStream(); ato.set(jarPath); break; } } } return pyJarPath; }
[*] target: assertNotNull(libPath)
[-] pred: org. junit. Assert. assertNotNull ( libPath )
************************************
************************************
[+] input: testGetLibPathNotURLClassLoader() { when(utils.getLibPath(jarName, ato)).thenCallRealMethod(); classLoader = mock(AbstractClassLoader.class); when(utils.getCurrentThreadContextClassLoader()).thenReturn(classLoader); InputStream libPath = utils.getLibPath(jarName, ato); Assertions."<AssertPlaceHolder>"; Assertions.assertNotEquals(mockPath, ato.get()); assertVerify(1, 0, 0); }
getLibPath(String jarName, AtomicReference<String> ato) throws IOException { InputStream pyJarPath = null; ClassLoader classLoader = getCurrentThreadContextClassLoader(); if (classLoader instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) classLoader).getURLs(); for (URL url : urls) { String jarPath = url.getPath(); if (jarPath.contains(jarName)) { pyJarPath = url.openStream(); ato.set(jarPath); break; } } } return pyJarPath; }
[*] target: assertNull(libPath)
[-] pred: org. junit. Assert. assertNull ( libPath )
************************************
************************************
[+] input: testGetLibPathIsURLClassLoaderButURLsIsEmpty() { when(utils.getLibPath(jarName, ato)).thenCallRealMethod(); classLoader = mock(URLClassLoader.class); when(utils.getCurrentThreadContextClassLoader()).thenReturn(classLoader); when(((URLClassLoader)classLoader).getURLs()).thenReturn(new URL[]{}); InputStream libPath = utils.getLibPath(jarName, ato); Assertions."<AssertPlaceHolder>"; Assertions.assertNotEquals(mockPath, ato.get()); assertVerify(1, 0, 0); }
getLibPath(String jarName, AtomicReference<String> ato) throws IOException { InputStream pyJarPath = null; ClassLoader classLoader = getCurrentThreadContextClassLoader(); if (classLoader instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) classLoader).getURLs(); for (URL url : urls) { String jarPath = url.getPath(); if (jarPath.contains(jarName)) { pyJarPath = url.openStream(); ato.set(jarPath); break; } } } return pyJarPath; }
[*] target: assertNull(libPath)
[-] pred: org. junit. Assert. assertNull ( libPath )
************************************
************************************
[+] input: testGetLibPathIsURLClassLoaderAndURLsNotEmptyButJarPathNotContainsJarName() { when(utils.getLibPath(jarName, ato)).thenCallRealMethod(); classLoader = mock(URLClassLoader.class); when(utils.getCurrentThreadContextClassLoader()).thenReturn(classLoader); when(((URLClassLoader)classLoader).getURLs()).thenReturn(urls); when(url.getPath()).thenReturn("any-path"); InputStream libPath = utils.getLibPath(jarName, ato); Assertions."<AssertPlaceHolder>"; Assertions.assertNotEquals(mockPath, ato.get()); assertVerify(1, 1, 0); }
getLibPath(String jarName, AtomicReference<String> ato) throws IOException { InputStream pyJarPath = null; ClassLoader classLoader = getCurrentThreadContextClassLoader(); if (classLoader instanceof URLClassLoader) { URL[] urls = ((URLClassLoader) classLoader).getURLs(); for (URL url : urls) { String jarPath = url.getPath(); if (jarPath.contains(jarName)) { pyJarPath = url.openStream(); ato.set(jarPath); break; } } } return pyJarPath; }
[*] target: assertNull(libPath)
[-] pred: org. junit. Assert. assertNull ( libPath )
************************************
************************************
[+] input: testChangeConnectionAndNullFilter() { String filters = null;  DataSourceEntity dataSourceEntity = mock(DataSourceEntity.class); when(dataSourceRepository.findAndModify(any(Query.class), any(Update.class), eq(userDetail))).thenReturn(dataSourceEntity);  UpdateResult updateResult = mock(UpdateResult.class); doAnswer(invocation -> { Document doc = invocation.<Query>getArgument(0).getQueryObject(); assertEquals(connId, doc.getString("source._id")); assertEquals("{"$ne": true}", doc.get("is_deleted", Document.class).toJson()); assertEquals(MetaType.table, doc.get("meta_type")); assertEquals(SourceTypeEnum.SOURCE, doc.get("sourceType")); assertEquals(fromSchemaVersion, doc.getString("source." + DataSourceConnectionDto.FIELD_SCHEMA_VERSION));  doc = invocation.<Update>getArgument(1).getUpdateObject().get("$set", Document.class); assertEquals(toSchemaVersion, doc.getString("source." + DataSourceConnectionDto.FIELD_SCHEMA_VERSION)); assertEquals(lastUpdate, doc.getLong(DataSourceConnectionDto.FIELD_LAST_UPDATE)); return updateResult; }).when(metadataInstancesService).updateMany(any(Query.class), any(Update.class));  long count = dataSourceService.updatePartialSchema(connId, loadFieldsStatus, lastUpdate, fromSchemaVersion, toSchemaVersion, filters, userDetail); "<AssertPlaceHolder>"; }
updatePartialSchema(String id, String loadFieldsStatus, Long lastUpdate, String fromSchemaVersion, String toSchemaVersion, String filters, UserDetail user) { long result = 0; // 更新连接加载状态 DataSourceEntity entity = repository.findAndModify( Query.query(Criteria.where("_id").is(id) .and(DataSourceConnectionDto.FIELD_SCHEMA_VERSION).is(fromSchemaVersion)) , Update.update(DataSourceConnectionDto.FIELD_SCHEMA_VERSION, toSchemaVersion) .set(DataSourceConnectionDto.FIELD_LAST_UPDATE, lastUpdate) .set(DataSourceConnectionDto.FIELD_LOAD_FIELDS_STATUS, loadFieldsStatus) , user);  // 更新连接对应模型的版本（部分更新，需要将没更新的模型版本进行设置） if (null != entity) { result = 1; Criteria where = Criteria.where("source._id").is(id) .and("is_deleted").ne(true) .and("meta_type").is(MetaType.table) .and("sourceType").is(SourceTypeEnum.SOURCE) .and("source." + DataSourceConnectionDto.FIELD_SCHEMA_VERSION).is(fromSchemaVersion); if(null != filters) { where = where.and("name").nin(Arrays.asList(filters.split(","))); } UpdateResult updateResult = metadataInstancesService.updateMany(Query.query(where) , Update.update("source." + DataSourceConnectionDto.FIELD_SCHEMA_VERSION, toSchemaVersion) .set(DataSourceConnectionDto.FIELD_LAST_UPDATE, lastUpdate) ); result += updateResult.getModifiedCount(); }  // 返回数量大于 0，才需要进行模型加载 return result; }
[*] target: assertEquals(1, count)
[-] pred: org. junit. Assert. assertEquals ( 1, count )
************************************
************************************
[+] input: testNormal() { when(scheduleUtil.criteria(anyString())).thenCallRealMethod(); Criteria mockId = scheduleUtil.criteria("mockId"); Assertions."<AssertPlaceHolder>"; Document criteriaObject = mockId.getCriteriaObject(); Assertions.assertNotNull(criteriaObject); Assertions.assertEquals(5, criteriaObject.size()); Assertions.assertTrue(criteriaObject.containsKey("is_deleted")); Assertions.assertTrue(criteriaObject.containsKey("source._id")); Assertions.assertTrue(criteriaObject.containsKey("sourceType")); Assertions.assertTrue(criteriaObject.containsKey("meta_type")); Assertions.assertTrue(criteriaObject.containsKey("taskId")); }
criteria(String dataSourceId) { return Criteria.where("is_deleted").ne(true) .and("source._id").is(dataSourceId) .and("sourceType").is(SourceTypeEnum.SOURCE.name()) .and("meta_type").ne("database") .and("taskId").exists(false); }
[*] target: assertNotNull(mockId)
[-] pred: org. junit. Assert. assertNotNull ( mockId )
************************************
************************************
[+] input: testInspectChartNormal() { Map<String, Integer> actual = taskService.inspectChart(user); Assertions."<AssertPlaceHolder>"; assertEquals(list.size(), actual.get("total")); assertEquals(1, actual.get("error")); assertEquals(1, actual.get("running")); assertEquals(1, actual.get("done")); assertEquals(1, actual.get("waiting")); assertEquals(1, actual.get("scheduling")); assertEquals(1, actual.get("stopping")); }
inspectChart(UserDetail user) { int error = 0; int running = 0; int done = 0; int waiting = 0; int scheduling = 0; int stopping = 0; int total = 0; List<InspectDto> inspectDtoList = inspectTaskList(new Filter(), user); if (CollectionUtils.isNotEmpty(inspectDtoList)) { total = inspectDtoList.size(); for (InspectDto taskDto : inspectDtoList) { String status = String.valueOf(taskDto.getStatus()).toLowerCase(); if (ERROR.getValue().equals(status)) { error++; } else if(RUNNING.getValue().equals(status)) { running++; } else if (DONE.getValue().equals(status)) { done++; } else if (WAITING.getValue().equals(status)) { waiting++; }else if (SCHEDULING.getValue().equals(status)) { scheduling++; }else if (STOPPING.getValue().equals(status)) { stopping++; } } }  Map<String, Integer> chart5 = new HashMap<>(); chart5.put(TOTAL, total); chart5.put("error", error); chart5.put("running", running); chart5.put("done", done); chart5.put("waiting", waiting); chart5.put("scheduling", scheduling); chart5.put("stopping", stopping); return chart5; }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: testEmpty() { list.clear(); Map<String, Integer> actual = taskService.inspectChart(user); Assertions."<AssertPlaceHolder>"; assertEquals(list.size(), actual.get("total")); assertEquals(0, actual.get("error")); assertEquals(0, actual.get("running")); assertEquals(0, actual.get("done")); assertEquals(0, actual.get("waiting")); assertEquals(0, actual.get("scheduling")); assertEquals(0, actual.get("stopping")); }
inspectChart(UserDetail user) { int error = 0; int running = 0; int done = 0; int waiting = 0; int scheduling = 0; int stopping = 0; int total = 0; List<InspectDto> inspectDtoList = inspectTaskList(new Filter(), user); if (CollectionUtils.isNotEmpty(inspectDtoList)) { total = inspectDtoList.size(); for (InspectDto taskDto : inspectDtoList) { String status = String.valueOf(taskDto.getStatus()).toLowerCase(); if (ERROR.getValue().equals(status)) { error++; } else if(RUNNING.getValue().equals(status)) { running++; } else if (DONE.getValue().equals(status)) { done++; } else if (WAITING.getValue().equals(status)) { waiting++; }else if (SCHEDULING.getValue().equals(status)) { scheduling++; }else if (STOPPING.getValue().equals(status)) { stopping++; } } }  Map<String, Integer> chart5 = new HashMap<>(); chart5.put(TOTAL, total); chart5.put("error", error); chart5.put("running", running); chart5.put("done", done); chart5.put("waiting", waiting); chart5.put("scheduling", scheduling); chart5.put("stopping", stopping); return chart5; }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: test1() { List<DataSourceConnectionDto> dataSourceConnectionList=new ArrayList<>(); DataSourceConnectionDto dataSourceConnectionDto=new DataSourceConnectionDto(); dataSourceConnectionDto.setId(MongoUtils.toObjectId("665eb04d9e541e4fee4f87c5")); dataSourceConnectionDto.setHeartbeatEnable(true); dataSourceConnectionList.add(dataSourceConnectionDto);  Map<String, LogCollecotrConnConfig> logCollectorConnConfigs =new HashMap<>(); doCallRealMethod().when(taskService).addHeartBeatTable2LogCollector(dataSourceConnectionList,logCollectorConnConfigs,tableNames); boolean updateConfig = taskService.addHeartBeatTable2LogCollector(dataSourceConnectionList, logCollectorConnConfigs, tableNames); "<AssertPlaceHolder>"; assertEquals(2,tableNames.size()); }
addHeartBeatTable2LogCollector(List<DataSourceConnectionDto> allDataSourceConnection, Map<String, LogCollecotrConnConfig> logCollectorConnConfigs, Set<String> tableNameSet) { boolean updateConfig = false; int beforeTableNamesSize = tableNameSet.size(); for (DataSourceConnectionDto dataSourceConnectionDto : allDataSourceConnection) { if (Boolean.TRUE.equals(dataSourceConnectionDto.getHeartbeatEnable())) { if (MapUtils.isNotEmpty(logCollectorConnConfigs) && null != logCollectorConnConfigs.get(dataSourceConnectionDto.getId().toHexString())) { LogCollecotrConnConfig logCollecotrConnConfig = logCollectorConnConfigs.get(dataSourceConnectionDto.getId().toHexString()); List<String> tableNames = logCollecotrConnConfig.getTableNames(); if (tableNames.stream().noneMatch(ConnHeartbeatUtils.TABLE_NAME::equals)) { logCollecotrConnConfig.getTableNames().add(ConnHeartbeatUtils.TABLE_NAME); updateConfig = true; } } tableNameSet.add(ConnHeartbeatUtils.TABLE_NAME); } } return updateConfig || beforeTableNamesSize < tableNameSet.size(); }
[*] target: assertEquals(true,updateConfig)
[-] pred: org. junit. Assert. assertEquals ( true, updateConfig )
************************************
************************************
[+] input: test2() { List<DataSourceConnectionDto> dataSourceConnectionList=new ArrayList<>(); DataSourceConnectionDto dataSourceConnectionDto=new DataSourceConnectionDto(); dataSourceConnectionDto.setId(MongoUtils.toObjectId("665eb04d9e541e4fee4f87c5")); dataSourceConnectionDto.setHeartbeatEnable(false); dataSourceConnectionList.add(dataSourceConnectionDto);  Map<String, LogCollecotrConnConfig> logCollectorConnConfigs =new HashMap<>(); doCallRealMethod().when(taskService).addHeartBeatTable2LogCollector(dataSourceConnectionList,logCollectorConnConfigs,tableNames); boolean updateConfig = taskService.addHeartBeatTable2LogCollector(dataSourceConnectionList, logCollectorConnConfigs, tableNames);  "<AssertPlaceHolder>"; assertEquals(1,tableNames.size()); }
addHeartBeatTable2LogCollector(List<DataSourceConnectionDto> allDataSourceConnection, Map<String, LogCollecotrConnConfig> logCollectorConnConfigs, Set<String> tableNameSet) { boolean updateConfig = false; int beforeTableNamesSize = tableNameSet.size(); for (DataSourceConnectionDto dataSourceConnectionDto : allDataSourceConnection) { if (Boolean.TRUE.equals(dataSourceConnectionDto.getHeartbeatEnable())) { if (MapUtils.isNotEmpty(logCollectorConnConfigs) && null != logCollectorConnConfigs.get(dataSourceConnectionDto.getId().toHexString())) { LogCollecotrConnConfig logCollecotrConnConfig = logCollectorConnConfigs.get(dataSourceConnectionDto.getId().toHexString()); List<String> tableNames = logCollecotrConnConfig.getTableNames(); if (tableNames.stream().noneMatch(ConnHeartbeatUtils.TABLE_NAME::equals)) { logCollecotrConnConfig.getTableNames().add(ConnHeartbeatUtils.TABLE_NAME); updateConfig = true; } } tableNameSet.add(ConnHeartbeatUtils.TABLE_NAME); } } return updateConfig || beforeTableNamesSize < tableNameSet.size(); }
[*] target: assertEquals(false,updateConfig)
[-] pred: org. junit. Assert. assertEquals ( false, updateConfig )
************************************
************************************
[+] input: test3() { String connectionId="665eb04d9e541e4fee4f87c5"; List<DataSourceConnectionDto> dataSourceConnectionList=new ArrayList<>(); DataSourceConnectionDto dataSourceConnectionDto=new DataSourceConnectionDto(); dataSourceConnectionDto.setId(MongoUtils.toObjectId(connectionId)); dataSourceConnectionDto.setHeartbeatEnable(true); dataSourceConnectionList.add(dataSourceConnectionDto);  Map<String, LogCollecotrConnConfig> logCollectorConnConfigs =new HashMap<>();  List<String> tableNamesList=new ArrayList<>(); tableNamesList.add("testTable"); LogCollecotrConnConfig logCollecotrConnConfig=new LogCollecotrConnConfig(connectionId, tableNamesList); logCollectorConnConfigs.put(connectionId, logCollecotrConnConfig);  doCallRealMethod().when(taskService).addHeartBeatTable2LogCollector(dataSourceConnectionList,logCollectorConnConfigs,tableNames); boolean updateConfig = taskService.addHeartBeatTable2LogCollector(dataSourceConnectionList, logCollectorConnConfigs, tableNames); "<AssertPlaceHolder>"; assertEquals(2,tableNames.size()); assertEquals(2,logCollecotrConnConfig.getTableNames().size()); }
addHeartBeatTable2LogCollector(List<DataSourceConnectionDto> allDataSourceConnection, Map<String, LogCollecotrConnConfig> logCollectorConnConfigs, Set<String> tableNameSet) { boolean updateConfig = false; int beforeTableNamesSize = tableNameSet.size(); for (DataSourceConnectionDto dataSourceConnectionDto : allDataSourceConnection) { if (Boolean.TRUE.equals(dataSourceConnectionDto.getHeartbeatEnable())) { if (MapUtils.isNotEmpty(logCollectorConnConfigs) && null != logCollectorConnConfigs.get(dataSourceConnectionDto.getId().toHexString())) { LogCollecotrConnConfig logCollecotrConnConfig = logCollectorConnConfigs.get(dataSourceConnectionDto.getId().toHexString()); List<String> tableNames = logCollecotrConnConfig.getTableNames(); if (tableNames.stream().noneMatch(ConnHeartbeatUtils.TABLE_NAME::equals)) { logCollecotrConnConfig.getTableNames().add(ConnHeartbeatUtils.TABLE_NAME); updateConfig = true; } } tableNameSet.add(ConnHeartbeatUtils.TABLE_NAME); } } return updateConfig || beforeTableNamesSize < tableNameSet.size(); }
[*] target: assertEquals(true,updateConfig)
[-] pred: org. junit. Assert. assertEquals ( true, updateConfig )
************************************
************************************
[+] input: testNormal() { TablePathInfo tablePathInfo = parseRelMig13OrMore.getTablePathInfo(contentMapping); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals("table", tablePathInfo.getTable()); Assertions.assertEquals("schema", tablePathInfo.getSchema()); Assertions.assertEquals("database", tablePathInfo.getDatabase()); verify(parseRelMig13OrMore).getFromMap(contentMapping, KeyWords.TABLE); verify(parseRelMig13OrMore).getFromMap(parseRelMig13OrMore.project, KeyWords.CONTENT); verify(parseRelMig13OrMore).getFromMap(content, KeyWords.TABLES); verify(parseRelMig13OrMore).getFromMap(tables, "tableId"); verify(parseRelMig13OrMore).getFromMap(tablePath, KeyWords.PATH); verify(tableInfo).get(KeyWords.DATABASE); verify(tableInfo).get(KeyWords.SCHEMA); verify(tableInfo).get(KeyWords.TABLE); verify(parseRelMig13OrMore, times(4)).parseMap(any()); }
getTablePathInfo(Map<String, Object> contentMapping) { String tableId = String.valueOf(getFromMap(contentMapping, KeyWords.TABLE)); Map<String, Object> content = parseMap(getFromMap(project, KeyWords.CONTENT)); Map<String, Object> tables = parseMap(getFromMap(content, KeyWords.TABLES)); Map<String, Object> tablePath = parseMap(getFromMap(tables, tableId)); Map<String, Object> tableInfo = parseMap(getFromMap(tablePath, KeyWords.PATH)); return new TablePathInfo(String.valueOf(tableInfo.get(KeyWords.DATABASE)), String.valueOf(tableInfo.get(KeyWords.SCHEMA)), String.valueOf(tableInfo.get(KeyWords.TABLE))); }
[*] target: assertNotNull(tablePathInfo)
[-] pred: org. junit. Assert. assertNotNull ( tablePathInfo )
************************************
************************************
[+] input: Exception { when(multipartFile.getBytes()).thenReturn("{"version":"1.2.0"}".getBytes()); try(MockedStatic<ParseRelMig> prm = Mockito.mockStatic(ParseRelMig.class)) { prm.when(() -> ParseRelMig.redirect(param)).thenCallRealMethod(); ParseRelMig redirect = ParseRelMig.redirect(param); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(ParseBaseVersionRelMigImpl.class.getName(), redirect.getClass().getName()); } }
redirect(ParseParam param) { try { MultipartFile multipartFile = param.getMultipartFile(); String relMig = new String(multipartFile.getBytes()); param.setRelMigStr(relMig); Map<String, Object> relMigInfo = (Map<String, Object>) new ObjectMapper().readValue(param.getRelMigStr(), Map.class); param.setRelMigInfo(relMigInfo); String version = String.valueOf(relMigInfo.get(KeyWords.VERSION)); Class<? extends ParseRelMig> instance = ParseRelMigFileVersionMapping.getInstance(version); Constructor<? extends ParseRelMig> declaredConstructor = instance.getDeclaredConstructor(ParseParam.class); return declaredConstructor.newInstance(param); } catch (Exception e) { throw new BizException("relMig.parse.failed", e.getMessage()); } }
[*] target: assertNotNull(redirect)
[-] pred: org. junit. Assert. assertNotNull ( redirect )
************************************
************************************
[+] input: Exception { when(multipartFile.getBytes()).thenReturn("{"version":"1.3.0"}".getBytes()); try(MockedStatic<ParseRelMig> prm = Mockito.mockStatic(ParseRelMig.class)) { prm.when(() -> ParseRelMig.redirect(param)).thenCallRealMethod(); ParseRelMig redirect = ParseRelMig.redirect(param); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(ParseRelMig13OrMoreImpl.class.getName(), redirect.getClass().getName()); } }
redirect(ParseParam param) { try { MultipartFile multipartFile = param.getMultipartFile(); String relMig = new String(multipartFile.getBytes()); param.setRelMigStr(relMig); Map<String, Object> relMigInfo = (Map<String, Object>) new ObjectMapper().readValue(param.getRelMigStr(), Map.class); param.setRelMigInfo(relMigInfo); String version = String.valueOf(relMigInfo.get(KeyWords.VERSION)); Class<? extends ParseRelMig> instance = ParseRelMigFileVersionMapping.getInstance(version); Constructor<? extends ParseRelMig> declaredConstructor = instance.getDeclaredConstructor(ParseParam.class); return declaredConstructor.newInstance(param); } catch (Exception e) { throw new BizException("relMig.parse.failed", e.getMessage()); } }
[*] target: assertNotNull(redirect)
[-] pred: org. junit. Assert. assertNotNull ( redirect )
************************************
************************************
[+] input: testEmpty() { when(webHookController.success(null)).thenReturn(mock(ResponseMessage.class)); List mock = mock(List.class); when(mock.isEmpty()).thenReturn(true); when(webHookService.close(any(String[].class), any(UserDetail.class))).thenReturn(mock); when(webHookController.closeOneWebHookByHookId("id")).thenCallRealMethod(); ResponseMessage<WebHookInfoVo> hook = webHookController.closeOneWebHookByHookId("id"); Assertions."<AssertPlaceHolder>"; Assertions.assertNull(hook.getData()); verify(webHookController).success(null); verify(webHookService).close(any(String[].class), any(UserDetail.class)); }
closeOneWebHookByHookId(@PathVariable(value = "id") String hookId) { List<WebHookInfoVo> closed = webHookService.close(new String[]{hookId}, getLoginUser()); if (closed.isEmpty()) { return success(null); } return success(closed.get(0)); }
[*] target: assertNotNull(hook)
[-] pred: org. junit. Assert. assertNotNull ( hook )
************************************
************************************
[+] input: testTrue() { InspectDto inspectDto = new InspectDto(); inspectDto.setInspectMethod(InspectMethod.FIELD.getValue()); inspectDto.setStatus(InspectStatusEnum.DONE.getValue()); inspectDto.setResult("failed"); inspectDto.setFlowId("test-flow-id");  List<String> errors = AutoRecoveryUtils.checkCanRecovery(inspectDto); Assertions.assertTrue(errors.isEmpty());  inspectDto.setInspectMethod(InspectMethod.JOINTFIELD.getValue()); errors = AutoRecoveryUtils.checkCanRecovery(inspectDto); Assertions."<AssertPlaceHolder>"; }
checkCanRecovery(InspectDto inspectDto) { List<String> errorCodes = new ArrayList<>(); if (!( InspectMethod.FIELD.getValue().equals(inspectDto.getInspectMethod()) || InspectMethod.JOINTFIELD.getValue().equals(inspectDto.getInspectMethod()) )) { errorCodes.add("Inspect.Recovery.NotFieldMethod"); } if (!InspectStatusEnum.DONE.getValue().equals(inspectDto.getStatus())) { errorCodes.add("Inspect.Recovery.StatusNotDone"); } if (!InspectResultEnum.FAILED.getValue().equals(inspectDto.getResult())) { errorCodes.add("Inspect.Recovery.ResultNotFound"); } if (null == inspectDto.getFlowId() || inspectDto.getFlowId().isEmpty()) { errorCodes.add("Inspect.Recovery.IsNotWithTask"); } return errorCodes; }
[*] target: assertTrue(errors.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( errors. isEmpty ( ) )
************************************
************************************
[+] input: testLocalDateTime() { LocalDateTime now = LocalDateTime.now(); long l = now.toInstant(ZoneOffset.UTC).toEpochMilli(); TapInsertRecordEvent insertRecordEvent = TapInsertRecordEvent.create().init() .after(new Document("id",1).append("ts", now)); Long aLong = CdcDelay.parseTs(insertRecordEvent); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(l, aLong); }
parseTs(@NonNull TapRecordEvent recordEvent) { Object ts = null; if (recordEvent instanceof TapInsertRecordEvent) { Map<String, Object> after = ((TapInsertRecordEvent) recordEvent).getAfter(); if (null != after) { ts = after.get("ts"); } } else if (recordEvent instanceof TapUpdateRecordEvent) { Map<String, Object> after = ((TapUpdateRecordEvent) recordEvent).getAfter(); if (null != after) { ts = after.get("ts"); } } else { return recordEvent.getReferenceTime(); } if (ts instanceof Date) { return ((Date) ts).getTime(); } else if (ts instanceof Instant) { return ((Instant) ts).toEpochMilli(); } else if (ts instanceof Long) { return (Long) ts; } else if (ts instanceof LocalDateTime) { return ((LocalDateTime) ts).toInstant((ZoneOffset.UTC)).toEpochMilli(); } else if (ts instanceof String) { try { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); sdf.setTimeZone(UTC_TIME_ZONE); Date date = sdf.parse(ts.toString()); return date.getTime(); } catch (ParseException e) { logger.warn("Parse string to date failed: {}, error: {}", ts, e.getMessage()); } } else { logger.warn("Calc '{}' delay failed: unknown type: {}", ts, null == ts ? "null" : ts.getClass().getName()); } return recordEvent.getReferenceTime(); }
[*] target: assertNotNull(aLong)
[-] pred: org. junit. Assert. assertNotNull ( aLong )
************************************
************************************
[+] input: testDate() { Date now = new Date(); TapInsertRecordEvent insertRecordEvent = TapInsertRecordEvent.create().init() .after(new Document("id",1).append("ts", now)); Long aLong = CdcDelay.parseTs(insertRecordEvent); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(now.getTime(), aLong); }
parseTs(@NonNull TapRecordEvent recordEvent) { Object ts = null; if (recordEvent instanceof TapInsertRecordEvent) { Map<String, Object> after = ((TapInsertRecordEvent) recordEvent).getAfter(); if (null != after) { ts = after.get("ts"); } } else if (recordEvent instanceof TapUpdateRecordEvent) { Map<String, Object> after = ((TapUpdateRecordEvent) recordEvent).getAfter(); if (null != after) { ts = after.get("ts"); } } else { return recordEvent.getReferenceTime(); } if (ts instanceof Date) { return ((Date) ts).getTime(); } else if (ts instanceof Instant) { return ((Instant) ts).toEpochMilli(); } else if (ts instanceof Long) { return (Long) ts; } else if (ts instanceof LocalDateTime) { return ((LocalDateTime) ts).toInstant((ZoneOffset.UTC)).toEpochMilli(); } else if (ts instanceof String) { try { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); sdf.setTimeZone(UTC_TIME_ZONE); Date date = sdf.parse(ts.toString()); return date.getTime(); } catch (ParseException e) { logger.warn("Parse string to date failed: {}, error: {}", ts, e.getMessage()); } } else { logger.warn("Calc '{}' delay failed: unknown type: {}", ts, null == ts ? "null" : ts.getClass().getName()); } return recordEvent.getReferenceTime(); }
[*] target: assertNotNull(aLong)
[-] pred: org. junit. Assert. assertNotNull ( aLong )
************************************
************************************
[+] input: testInstant() { Instant now = new Date().toInstant(); TapInsertRecordEvent insertRecordEvent = TapInsertRecordEvent.create().init() .after(new Document("id",1).append("ts", now)); Long aLong = CdcDelay.parseTs(insertRecordEvent); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(now.toEpochMilli(), aLong); }
parseTs(@NonNull TapRecordEvent recordEvent) { Object ts = null; if (recordEvent instanceof TapInsertRecordEvent) { Map<String, Object> after = ((TapInsertRecordEvent) recordEvent).getAfter(); if (null != after) { ts = after.get("ts"); } } else if (recordEvent instanceof TapUpdateRecordEvent) { Map<String, Object> after = ((TapUpdateRecordEvent) recordEvent).getAfter(); if (null != after) { ts = after.get("ts"); } } else { return recordEvent.getReferenceTime(); } if (ts instanceof Date) { return ((Date) ts).getTime(); } else if (ts instanceof Instant) { return ((Instant) ts).toEpochMilli(); } else if (ts instanceof Long) { return (Long) ts; } else if (ts instanceof LocalDateTime) { return ((LocalDateTime) ts).toInstant((ZoneOffset.UTC)).toEpochMilli(); } else if (ts instanceof String) { try { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); sdf.setTimeZone(UTC_TIME_ZONE); Date date = sdf.parse(ts.toString()); return date.getTime(); } catch (ParseException e) { logger.warn("Parse string to date failed: {}, error: {}", ts, e.getMessage()); } } else { logger.warn("Calc '{}' delay failed: unknown type: {}", ts, null == ts ? "null" : ts.getClass().getName()); } return recordEvent.getReferenceTime(); }
[*] target: assertNotNull(aLong)
[-] pred: org. junit. Assert. assertNotNull ( aLong )
************************************
************************************
[+] input: testLong() { Date now = new Date(); TapInsertRecordEvent insertRecordEvent = TapInsertRecordEvent.create().init() .after(new Document("id",1).append("ts", now.getTime())); Long aLong = CdcDelay.parseTs(insertRecordEvent); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(now.getTime(), aLong); }
parseTs(@NonNull TapRecordEvent recordEvent) { Object ts = null; if (recordEvent instanceof TapInsertRecordEvent) { Map<String, Object> after = ((TapInsertRecordEvent) recordEvent).getAfter(); if (null != after) { ts = after.get("ts"); } } else if (recordEvent instanceof TapUpdateRecordEvent) { Map<String, Object> after = ((TapUpdateRecordEvent) recordEvent).getAfter(); if (null != after) { ts = after.get("ts"); } } else { return recordEvent.getReferenceTime(); } if (ts instanceof Date) { return ((Date) ts).getTime(); } else if (ts instanceof Instant) { return ((Instant) ts).toEpochMilli(); } else if (ts instanceof Long) { return (Long) ts; } else if (ts instanceof LocalDateTime) { return ((LocalDateTime) ts).toInstant((ZoneOffset.UTC)).toEpochMilli(); } else if (ts instanceof String) { try { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); sdf.setTimeZone(UTC_TIME_ZONE); Date date = sdf.parse(ts.toString()); return date.getTime(); } catch (ParseException e) { logger.warn("Parse string to date failed: {}, error: {}", ts, e.getMessage()); } } else { logger.warn("Calc '{}' delay failed: unknown type: {}", ts, null == ts ? "null" : ts.getClass().getName()); } return recordEvent.getReferenceTime(); }
[*] target: assertNotNull(aLong)
[-] pred: org. junit. Assert. assertNotNull ( aLong )
************************************
************************************
[+] input: testString() { TapInsertRecordEvent insertRecordEvent = TapInsertRecordEvent.create().init() .after(new Document("id",1).append("ts", "2024-07-25 10:50:46.001")).referenceTime(0L); Long aLong = CdcDelay.parseTs(insertRecordEvent); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(0L, aLong); }
parseTs(@NonNull TapRecordEvent recordEvent) { Object ts = null; if (recordEvent instanceof TapInsertRecordEvent) { Map<String, Object> after = ((TapInsertRecordEvent) recordEvent).getAfter(); if (null != after) { ts = after.get("ts"); } } else if (recordEvent instanceof TapUpdateRecordEvent) { Map<String, Object> after = ((TapUpdateRecordEvent) recordEvent).getAfter(); if (null != after) { ts = after.get("ts"); } } else { return recordEvent.getReferenceTime(); } if (ts instanceof Date) { return ((Date) ts).getTime(); } else if (ts instanceof Instant) { return ((Instant) ts).toEpochMilli(); } else if (ts instanceof Long) { return (Long) ts; } else if (ts instanceof LocalDateTime) { return ((LocalDateTime) ts).toInstant((ZoneOffset.UTC)).toEpochMilli(); } else if (ts instanceof String) { try { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); sdf.setTimeZone(UTC_TIME_ZONE); Date date = sdf.parse(ts.toString()); return date.getTime(); } catch (ParseException e) { logger.warn("Parse string to date failed: {}, error: {}", ts, e.getMessage()); } } else { logger.warn("Calc '{}' delay failed: unknown type: {}", ts, null == ts ? "null" : ts.getClass().getName()); } return recordEvent.getReferenceTime(); }
[*] target: assertNotNull(aLong)
[-] pred: org. junit. Assert. assertNotNull ( aLong )
************************************
************************************
[+] input: testMergeSchema() { // init config Map<String, String> expectedMap = new HashMap<>();  DAG.Options options = new DAG.Options(); options.setIncludes(new ArrayList<>()); options.getIncludes().add("TEST");  // test empty schemas List<List<Schema>> inputSchemas = new ArrayList<>(); List<Schema> outputSchemas = instance.mergeSchema(inputSchemas, null, options); Assertions.assertTrue(outputSchemas.isEmpty());  // test rules inputSchemas.add(Arrays.asList( initSchema(expectedMap, "TEST", expectedTableName("TEST")), // prefix + suffix + upperCase initSchema(expectedMap, "TestBefore", expectedTableName("TestAfter")), // keywords initSchema(expectedMap, customOrigin, customCurrent) // custom table name ));  outputSchemas = instance.mergeSchema(inputSchemas, null, options); Assertions."<AssertPlaceHolder>"; for (Schema schema : outputSchemas) { Assertions.assertNotNull(schema);  String expectedName = expectedMap.get(schema.getAncestorsName()); Assertions.assertNotNull(expectedName); Assertions.assertEquals(expectedName, schema.getName()); Assertions.assertEquals(expectedName, schema.getOriginalName()); } }
mergeSchema(List<List<Schema>> inputSchemas, List<Schema> schemas, DAG.Options options) { if (CollectionUtils.isEmpty(inputSchemas)) { return Lists.newArrayList(); }  // 'schemas' is null because node not exists physical model List<Schema> outputSchemas = SchemaUtils.cloneSchema(inputSchemas.get(0));  outputSchemas.forEach(schema -> { Map<String, TableRenameTableInfo> originaledMap = originalMap(); String ancestorsName = schema.getAncestorsName(); String currentTableName = convertTableName(originaledMap, ancestorsName, false); schema.setName(currentTableName); schema.setOriginalName(currentTableName); Optional.ofNullable(options.getIncludes()).ifPresent(includes -> { for (int i = 0; i < includes.size(); i++) { if (ancestorsName.equals(includes.get(i))) { includes.set(i, currentTableName); } } }); });  return outputSchemas; }
[*] target: assertNotNull(outputSchemas)
[-] pred: org. junit. Assert. assertNotNull ( outputSchemas )
************************************
************************************
[+] input: Exception { final String json; try (Reader reader = new InputStreamReader(Objects.requireNonNull(TestDataBuilder.class .getResourceAsStream("/securityReport.json")))) { json = new BufferedReader(reader).lines().collect(Collectors.joining()); } catch (IOException e) { e.printStackTrace(); return; }  var mapper = new ObjectMapper(); var report = mapper.readValue(json, Report.class);  // Assertions to verify the parsed object assertNotNull(report); assertEquals("azure", report.getModuleNamespace()); assertEquals("foo", report.getModuleName()); assertEquals("1.0.0", report.getModuleVersion()); assertEquals("azurerm", report.getProvider());  var securityReport = report.getSecurityReport(); assertNotNull(securityReport); assertEquals(1, securityReport.get("main.tf").size()); SecurityFinding finding = securityReport.get("main.tf").get(0); assertEquals("AVD-AZU-0014", finding.getId());  TerraformDocumentation documentation = report.getDocumentation(); "<AssertPlaceHolder>"; assertEquals(1, documentation.getProviders().size()); assertEquals("azurerm", documentation.getProviders().get(0).getName()); assertEquals(1, documentation.getResources().size()); assertEquals("mykey", documentation.getResources().get(0).getName()); }
getDocumentation() { return documentation; }
[*] target: assertNotNull(documentation)
[-] pred: org. junit. Assert. assertNotNull ( documentation )
************************************
************************************
[+] input: test2() { //when this.registerPage.fillOutForm();  //then String expected = "Welcome to your account. Here you can manage all of your personal information and orders."; String actual = this.registerPage.getWelcomeMessage(); Assertions."<AssertPlaceHolder>";  String actualUrl = this.registerPage.getCurrentUrl(); Assertions.assertFalse(this.URL.equals(actualUrl)); }
getWelcomeMessage() { super.waitVisibilityOfElementLocated(welcomeMessageLocator); return super.getText(welcomeMessageLocator); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: failOnUnknownPropertiesMapperTest() { Asset asset = new Asset(); asset.setId(new AssetId(UUID.randomUUID())); asset.setName("Test"); asset.setType("type"); String serializedAsset = JacksonUtil.toString(asset); JsonNode jsonNode = JacksonUtil.toJsonNode(serializedAsset); // case: add new field to serialized Asset string and check for backward compatibility with original Asset object Assertions.assertNotNull(jsonNode); ((ObjectNode) jsonNode).put("test", (String) null); serializedAsset = JacksonUtil.toString(jsonNode); // deserialize with FAIL_ON_UNKNOWN_PROPERTIES = false Asset result = JacksonUtil.fromString(serializedAsset, Asset.class, true); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(asset.getId(), result.getId()); Assertions.assertEquals(asset.getName(), result.getName()); Assertions.assertEquals(asset.getType(), result.getType()); }
fromString(String string, Class<T> clazz, boolean ignoreUnknownFields) { try { return string != null ? IGNORE_UNKNOWN_PROPERTIES_JSON_MAPPER.readValue(string, clazz) : null; } catch (IOException e) { throw new IllegalArgumentException("The given string value cannot be transformed to Json object: " + string, e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: test_2_plus_2_body() { var node = initNode(TbRuleNodeMathFunctionType.ADD, new TbMathResult(TbMathArgumentType.MESSAGE_BODY, "result", 2, false, false, null), new TbMathArgument(TbMathArgumentType.MESSAGE_BODY, "a"), new TbMathArgument(TbMathArgumentType.MESSAGE_BODY, "b") );  TbMsg msg = TbMsg.newMsg(TbMsgType.POST_TELEMETRY_REQUEST, originator, TbMsgMetaData.EMPTY, JacksonUtil.newObjectNode().put("a", 2).put("b", 2).toString());  node.onMsg(ctx, msg);  ArgumentCaptor<TbMsg> msgCaptor = ArgumentCaptor.forClass(TbMsg.class); verify(ctx, timeout(TIMEOUT)).tellSuccess(msgCaptor.capture());  TbMsg resultMsg = msgCaptor.getValue(); "<AssertPlaceHolder>"; assertNotNull(resultMsg.getData()); var resultJson = JacksonUtil.toJsonNode(resultMsg.getData()); assertTrue(resultJson.has("result")); assertEquals(4, resultJson.get("result").asInt()); }
onMsg(TbContext ctx, TbMsg msg) { locks.computeIfAbsent(msg.getOriginator(), SemaphoreWithTbMsgQueue::new) .addToQueueAndTryProcess(msg, ctx, this::processMsgAsync); }
[*] target: assertNotNull(resultMsg)
[-] pred: org. junit. Assert. assertNotNull ( resultMsg )
************************************
************************************
[+] input: test_2_plus_2_meta() { var node = initNode(TbRuleNodeMathFunctionType.ADD, new TbMathResult(TbMathArgumentType.MESSAGE_METADATA, "result", 0, false, false, null), new TbMathArgument(TbMathArgumentType.MESSAGE_BODY, "a"), new TbMathArgument(TbMathArgumentType.MESSAGE_BODY, "b") );  TbMsg msg = TbMsg.newMsg(TbMsgType.POST_TELEMETRY_REQUEST, originator, TbMsgMetaData.EMPTY, JacksonUtil.newObjectNode().put("a", 2).put("b", 2).toString());  node.onMsg(ctx, msg);  ArgumentCaptor<TbMsg> msgCaptor = ArgumentCaptor.forClass(TbMsg.class); verify(ctx, timeout(TIMEOUT)).tellSuccess(msgCaptor.capture());  TbMsg resultMsg = msgCaptor.getValue(); "<AssertPlaceHolder>"; assertNotNull(resultMsg.getData()); assertNotNull(resultMsg.getMetaData()); var result = resultMsg.getMetaData().getValue("result"); assertNotNull(result); assertEquals("4", result); }
onMsg(TbContext ctx, TbMsg msg) { locks.computeIfAbsent(msg.getOriginator(), SemaphoreWithTbMsgQueue::new) .addToQueueAndTryProcess(msg, ctx, this::processMsgAsync); }
[*] target: assertNotNull(resultMsg)
[-] pred: org. junit. Assert. assertNotNull ( resultMsg )
************************************
************************************
[+] input: test_2_plus_2_attr_and_ts() { var node = initNode(TbRuleNodeMathFunctionType.ADD, new TbMathResult(TbMathArgumentType.MESSAGE_BODY, "result", 2, false, false, null), new TbMathArgument(TbMathArgumentType.ATTRIBUTE, "a"), new TbMathArgument(TbMathArgumentType.TIME_SERIES, "b") );  TbMsg msg = TbMsg.newMsg(TbMsgType.POST_TELEMETRY_REQUEST, originator, TbMsgMetaData.EMPTY, JacksonUtil.newObjectNode().toString());  when(attributesService.find(tenantId, originator, AttributeScope.SERVER_SCOPE, "a")) .thenReturn(Futures.immediateFuture(Optional.of(new BaseAttributeKvEntry(System.currentTimeMillis(), new DoubleDataEntry("a", 2.0)))));  when(tsService.findLatest(tenantId, originator, "b")) .thenReturn(Futures.immediateFuture(Optional.of(new BasicTsKvEntry(System.currentTimeMillis(), new LongDataEntry("b", 2L)))));  node.onMsg(ctx, msg);  ArgumentCaptor<TbMsg> msgCaptor = ArgumentCaptor.forClass(TbMsg.class); verify(ctx, timeout(TIMEOUT)).tellSuccess(msgCaptor.capture());  TbMsg resultMsg = msgCaptor.getValue(); "<AssertPlaceHolder>"; assertNotNull(resultMsg.getData()); var resultJson = JacksonUtil.toJsonNode(resultMsg.getData()); assertTrue(resultJson.has("result")); assertEquals(4, resultJson.get("result").asInt()); }
onMsg(TbContext ctx, TbMsg msg) { locks.computeIfAbsent(msg.getOriginator(), SemaphoreWithTbMsgQueue::new) .addToQueueAndTryProcess(msg, ctx, this::processMsgAsync); }
[*] target: assertNotNull(resultMsg)
[-] pred: org. junit. Assert. assertNotNull ( resultMsg )
************************************
************************************
[+] input: test_sqrt_5_body() { var node = initNode(TbRuleNodeMathFunctionType.SQRT, new TbMathResult(TbMathArgumentType.MESSAGE_BODY, "result", 3, false, false, null), new TbMathArgument(TbMathArgumentType.MESSAGE_BODY, "a") );  TbMsg msg = TbMsg.newMsg(TbMsgType.POST_TELEMETRY_REQUEST, originator, TbMsgMetaData.EMPTY, JacksonUtil.newObjectNode().put("a", 5).toString());  node.onMsg(ctx, msg);  ArgumentCaptor<TbMsg> msgCaptor = ArgumentCaptor.forClass(TbMsg.class); verify(ctx, timeout(TIMEOUT)).tellSuccess(msgCaptor.capture());  TbMsg resultMsg = msgCaptor.getValue(); "<AssertPlaceHolder>"; assertNotNull(resultMsg.getData()); var resultJson = JacksonUtil.toJsonNode(resultMsg.getData()); assertTrue(resultJson.has("result")); assertEquals(2.236, resultJson.get("result").asDouble(), 0.0); }
onMsg(TbContext ctx, TbMsg msg) { locks.computeIfAbsent(msg.getOriginator(), SemaphoreWithTbMsgQueue::new) .addToQueueAndTryProcess(msg, ctx, this::processMsgAsync); }
[*] target: assertNotNull(resultMsg)
[-] pred: org. junit. Assert. assertNotNull ( resultMsg )
************************************
************************************
[+] input: test_sqrt_5_meta() { var node = initNode(TbRuleNodeMathFunctionType.SQRT, new TbMathResult(TbMathArgumentType.MESSAGE_METADATA, "result", 3, false, false, null), new TbMathArgument(TbMathArgumentType.MESSAGE_BODY, "a") );  TbMsg msg = TbMsg.newMsg(TbMsgType.POST_TELEMETRY_REQUEST, originator, TbMsgMetaData.EMPTY, JacksonUtil.newObjectNode().put("a", 5).toString());  node.onMsg(ctx, msg);  ArgumentCaptor<TbMsg> msgCaptor = ArgumentCaptor.forClass(TbMsg.class); verify(ctx, timeout(TIMEOUT)).tellSuccess(msgCaptor.capture());  TbMsg resultMsg = msgCaptor.getValue(); "<AssertPlaceHolder>"; assertNotNull(resultMsg.getData()); var result = resultMsg.getMetaData().getValue("result"); assertNotNull(result); assertEquals("2.236", result); }
onMsg(TbContext ctx, TbMsg msg) { locks.computeIfAbsent(msg.getOriginator(), SemaphoreWithTbMsgQueue::new) .addToQueueAndTryProcess(msg, ctx, this::processMsgAsync); }
[*] target: assertNotNull(resultMsg)
[-] pred: org. junit. Assert. assertNotNull ( resultMsg )
************************************
************************************
[+] input: test_sqrt_5_to_attribute_and_metadata() { var node = initNode(TbRuleNodeMathFunctionType.SQRT, new TbMathResult(TbMathArgumentType.ATTRIBUTE, "result", 3, false, true, DataConstants.SERVER_SCOPE), new TbMathArgument(TbMathArgumentType.MESSAGE_BODY, "a") );  TbMsg msg = TbMsg.newMsg(TbMsgType.POST_TELEMETRY_REQUEST, originator, TbMsgMetaData.EMPTY, JacksonUtil.newObjectNode().put("a", 5).toString());  when(telemetryService.saveAttrAndNotify(any(), any(), any(AttributeScope.class), anyString(), anyDouble())) .thenReturn(Futures.immediateFuture(null));  node.onMsg(ctx, msg);  ArgumentCaptor<TbMsg> msgCaptor = ArgumentCaptor.forClass(TbMsg.class); verify(ctx, timeout(TIMEOUT)).tellSuccess(msgCaptor.capture()); verify(telemetryService, times(1)).saveAttrAndNotify(any(), any(), any(AttributeScope.class), anyString(), anyDouble());  TbMsg resultMsg = msgCaptor.getValue(); "<AssertPlaceHolder>"; assertNotNull(resultMsg.getData()); var result = resultMsg.getMetaData().getValue("result"); assertNotNull(result); assertEquals("2.236", result); }
onMsg(TbContext ctx, TbMsg msg) { locks.computeIfAbsent(msg.getOriginator(), SemaphoreWithTbMsgQueue::new) .addToQueueAndTryProcess(msg, ctx, this::processMsgAsync); }
[*] target: assertNotNull(resultMsg)
[-] pred: org. junit. Assert. assertNotNull ( resultMsg )
************************************
************************************
[+] input: test_sqrt_5_to_timeseries_and_data() { var node = initNode(TbRuleNodeMathFunctionType.SQRT, new TbMathResult(TbMathArgumentType.TIME_SERIES, "result", 3, true, false, DataConstants.SERVER_SCOPE), new TbMathArgument(TbMathArgumentType.MESSAGE_BODY, "a") );  TbMsg msg = TbMsg.newMsg(TbMsgType.POST_TELEMETRY_REQUEST, originator, TbMsgMetaData.EMPTY, JacksonUtil.newObjectNode().put("a", 5).toString()); when(telemetryService.saveAndNotify(any(), any(), any(TsKvEntry.class))) .thenReturn(Futures.immediateFuture(null));  node.onMsg(ctx, msg);  ArgumentCaptor<TbMsg> msgCaptor = ArgumentCaptor.forClass(TbMsg.class); verify(ctx, timeout(TIMEOUT)).tellSuccess(msgCaptor.capture()); verify(telemetryService, times(1)).saveAndNotify(any(), any(), any(TsKvEntry.class));  TbMsg resultMsg = msgCaptor.getValue(); "<AssertPlaceHolder>"; assertNotNull(resultMsg.getData()); var resultJson = JacksonUtil.toJsonNode(resultMsg.getData()); assertTrue(resultJson.has("result")); assertEquals(2.236, resultJson.get("result").asDouble(), 0.0); }
onMsg(TbContext ctx, TbMsg msg) { locks.computeIfAbsent(msg.getOriginator(), SemaphoreWithTbMsgQueue::new) .addToQueueAndTryProcess(msg, ctx, this::processMsgAsync); }
[*] target: assertNotNull(resultMsg)
[-] pred: org. junit. Assert. assertNotNull ( resultMsg )
************************************
************************************
[+] input: test_sqrt_5_to_timeseries_and_metadata_and_data() { var node = initNode(TbRuleNodeMathFunctionType.SQRT, new TbMathResult(TbMathArgumentType.TIME_SERIES, "result", 3, true, true, DataConstants.SERVER_SCOPE), new TbMathArgument(TbMathArgumentType.MESSAGE_BODY, "a") );  TbMsg msg = TbMsg.newMsg(TbMsgType.POST_TELEMETRY_REQUEST, originator, TbMsgMetaData.EMPTY, JacksonUtil.newObjectNode().put("a", 5).toString()); when(telemetryService.saveAndNotify(any(), any(), any(TsKvEntry.class))) .thenReturn(Futures.immediateFuture(null));  node.onMsg(ctx, msg);  ArgumentCaptor<TbMsg> msgCaptor = ArgumentCaptor.forClass(TbMsg.class); verify(ctx, timeout(TIMEOUT)).tellSuccess(msgCaptor.capture()); verify(telemetryService, times(1)).saveAndNotify(any(), any(), any(TsKvEntry.class));  TbMsg resultMsg = msgCaptor.getValue(); "<AssertPlaceHolder>"; assertNotNull(resultMsg.getData()); var resultMetadata = resultMsg.getMetaData().getValue("result"); var resultData = JacksonUtil.toJsonNode(resultMsg.getData());  assertTrue(resultData.has("result")); assertEquals(2.236, resultData.get("result").asDouble(), 0.0);  assertNotNull(resultMetadata); assertEquals("2.236", resultMetadata); }
onMsg(TbContext ctx, TbMsg msg) { locks.computeIfAbsent(msg.getOriginator(), SemaphoreWithTbMsgQueue::new) .addToQueueAndTryProcess(msg, ctx, this::processMsgAsync); }
[*] target: assertNotNull(resultMsg)
[-] pred: org. junit. Assert. assertNotNull ( resultMsg )
************************************
************************************
[+] input: test_sqrt_5_default_value() { TbMathArgument tbMathArgument = new TbMathArgument(TbMathArgumentType.MESSAGE_BODY, "TestKey"); tbMathArgument.setDefaultValue(5.0); var node = initNode(TbRuleNodeMathFunctionType.SQRT, new TbMathResult(TbMathArgumentType.MESSAGE_METADATA, "result", 3, false, false, null), tbMathArgument ); TbMsg msg = TbMsg.newMsg(TbMsgType.POST_TELEMETRY_REQUEST, originator, TbMsgMetaData.EMPTY, JacksonUtil.newObjectNode().put("a", 10).toString());  node.onMsg(ctx, msg); ArgumentCaptor<TbMsg> msgCaptor = ArgumentCaptor.forClass(TbMsg.class); verify(ctx, timeout(TIMEOUT)).tellSuccess(msgCaptor.capture());  TbMsg resultMsg = msgCaptor.getValue(); "<AssertPlaceHolder>"; assertNotNull(resultMsg.getData()); var result = resultMsg.getMetaData().getValue("result"); assertNotNull(result); assertEquals("2.236", result); }
onMsg(TbContext ctx, TbMsg msg) { locks.computeIfAbsent(msg.getOriginator(), SemaphoreWithTbMsgQueue::new) .addToQueueAndTryProcess(msg, ctx, this::processMsgAsync); }
[*] target: assertNotNull(resultMsg)
[-] pred: org. junit. Assert. assertNotNull ( resultMsg )
************************************
************************************
[+] input: testAssignment() {  String source = "a = 2 + 5"; List<Token> tokens = LexicalParser.parse(source);  "<AssertPlaceHolder>";  int count = 0; assertEquals(TokenType.Variable, tokens.get(count).getType()); assertEquals("a", tokens.get(count).getValue()); assertEquals(1, tokens.get(count).getRowNumber());  assertEquals(TokenType.Operator, tokens.get(++count).getType()); assertEquals("=", tokens.get(count).getValue()); assertEquals(1, tokens.get(count).getRowNumber());  assertEquals(TokenType.Numeric, tokens.get(++count).getType()); assertEquals("2", tokens.get(count).getValue()); assertEquals(1, tokens.get(count).getRowNumber());  assertEquals(TokenType.Operator, tokens.get(++count).getType()); assertEquals("+", tokens.get(count).getValue()); assertEquals(1, tokens.get(count).getRowNumber());  assertEquals(TokenType.Numeric, tokens.get(++count).getType()); assertEquals("5", tokens.get(count).getValue()); assertEquals(1, tokens.get(count).getRowNumber()); }
parse(String sourceCode) { LexicalParser parser = new LexicalParser(sourceCode); parser.parse(); return parser.tokens; }
[*] target: assertEquals(5, tokens.size())
[-] pred: org. junit. Assert. assertEquals ( 5, tokens. size ( ) )
************************************
************************************
[+] input: testComment() { List<Token> tokens = List.of( Token.builder().type(TokenType.Comment).value("# a = 5").build(), Token.builder().type(TokenType.LineBreak).value("\n").build(), Token.builder().type(TokenType.Variable).value("a").build(), Token.builder().type(TokenType.Operator).value("=").build(), Token.builder().type(TokenType.Numeric).value("5").build(), Token.builder().type(TokenType.Comment).value("# a is equal to 5").build() ); DefinitionContext.pushScope(DefinitionContext.newScope()); MemoryContext.pushScope(MemoryContext.newScope()); CompositeStatement statement = new CompositeStatement(null, "testComment"); StatementParser.parse(tokens, statement);  List<Statement> statements = statement.getStatements2Execute(); "<AssertPlaceHolder>";  assertEquals(ExpressionStatement.class, statements.get(0).getClass()); ExpressionStatement expressionStatement = (ExpressionStatement) statements.get(0);  assertEquals(expressionStatement.getExpression().getClass(), AssignmentOperator.class); AssignmentOperator assignStatement = (AssignmentOperator) expressionStatement.getExpression();  assertTrue(assignStatement.getLeft() instanceof VariableExpression); VariableExpression variableExpression = (VariableExpression) assignStatement.getLeft(); assertEquals("a", variableExpression.getName()); assertEquals(NumericValue.class, assignStatement.getRight().getClass()); NumericValue numericValue = (NumericValue) assignStatement.getRight();  assertEquals(5, numericValue.getValue());  DefinitionContext.endScope(); MemoryContext.endScope(); }
parse(List<Token> tokens, CompositeStatement compositeStatement) { StatementParser parser = new StatementParser(new TokensStack(tokens), new Scanner(System.in), compositeStatement); while (parser.hasNextStatement()) { parser.parseExpression(); } }
[*] target: assertEquals(1, statements.size())
[-] pred: org. junit. Assert. assertEquals ( 1, statements. size ( ) )
************************************
************************************
[+] input: shouldAddOpenListener() { component.onDrawerOpen(event -> { });  List<EventListener<AppLayoutDrawerOpenEvent>> listeners = component.getEventListeners(AppLayoutDrawerOpenEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<AppLayoutDrawerOpenEvent>); }
onDrawerOpen( EventListener<AppLayoutDrawerOpenEvent> listener) { return addDrawerOpenListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddCloseListener() { component.onDrawerClose(event -> { });  List<EventListener<AppLayoutDrawerCloseEvent>> listeners = component.getEventListeners(AppLayoutDrawerCloseEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<AppLayoutDrawerCloseEvent>); }
onDrawerClose( EventListener<AppLayoutDrawerCloseEvent> listener) { return addDrawerCloseListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddOpenListener() { component.onOpen(event -> { });  List<EventListener<DialogOpenEvent>> listeners = component.getEventListeners(DialogOpenEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<DialogOpenEvent>); }
onOpen(EventListener<DialogOpenEvent> listener) { return addOpenListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddCloseListener() { component.onClose(event -> { });  List<EventListener<DialogCloseEvent>> listeners = component.getEventListeners(DialogCloseEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<DialogCloseEvent>); }
onClose(EventListener<DialogCloseEvent> listener) { return addCloseListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddOpenListener() { component.onOpen(event -> { });  List<EventListener<DrawerOpenEvent>> listeners = component.getEventListeners(DrawerOpenEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<DrawerOpenEvent>); }
onOpen(EventListener<DrawerOpenEvent> listener) { return addOpenListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddOpenListener() { component.onSelect(event -> { });  List<EventListener<GoogleChartSelectedEvent>> listeners = component.getEventListeners(GoogleChartSelectedEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<GoogleChartSelectedEvent>); }
onSelect( EventListener<GoogleChartSelectedEvent> listener) { return addSelectedListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldConstructWithHrefText() { String href = "https://example.com"; String text = "Example Link";  Anchor anchor = new Anchor(href, text); assertNotNull(anchor); "<AssertPlaceHolder>"; assertEquals(text, anchor.getText()); }
getHref() { return get(hrefProp); }
[*] target: assertEquals(href, anchor.getHref())
[-] pred: org. junit. Assert. assertEquals ( href, anchor. getHref() )
************************************
************************************
[+] input: shouldConstructWithHrefAndComponents() { Div firstMock = new Div(); Div secondMock = new Div();  String href = "https://example.com";  Anchor anchor = new Anchor(href, firstMock, secondMock); assertNotNull(anchor); "<AssertPlaceHolder>"; assertEquals(2, anchor.getComponents().size()); }
getHref() { return get(hrefProp); }
[*] target: assertEquals(href, anchor.getHref())
[-] pred: org. junit. Assert. assertEquals ( href, anchor. getHref() )
************************************
************************************
[+] input: shouldAddCancelListener() { component.onCancel(event -> { });  List<EventListener<LoginCancelEvent>> listeners = component.getEventListeners(LoginCancelEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<LoginCancelEvent>); }
onCancel(EventListener<LoginCancelEvent> listener) { return addCancelListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddResizeListener() { component.onResize(event -> { });  List<EventListener<SplitterResizeEvent>> listeners = component.getEventListeners(SplitterResizeEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<SplitterResizeEvent>); }
onResize( EventListener<SplitterResizeEvent> listener) { return addResizeListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddRowClickListener() { table.onItemClick(event -> { });  List<EventListener<TableItemClickEvent>> listeners = table.getEventListeners(TableItemClickEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<TableItemClickEvent>); }
onItemClick( EventListener<TableItemClickEvent<T>> listener) { return addItemClickListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddRowDoubleClickListener() { table.onItemDoubleClick(event -> { });  List<EventListener<TableItemDoubleClickEvent>> listeners = table.getEventListeners(TableItemDoubleClickEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<TableItemDoubleClickEvent>); }
onItemDoubleClick( EventListener<TableItemDoubleClickEvent<T>> listener) { return addItemDoubleClickListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddRowSelectListener() { table.onItemSelect(event -> { });  List<EventListener<TableItemSelectEvent>> listeners = table.getEventListeners(TableItemSelectEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<TableItemSelectEvent>); }
onItemSelect( EventListener<TableItemSelectEvent<T>> listener) { return addItemSelectListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddRowDeselectListener() { table.onItemDeselect(event -> { });  List<EventListener<TableItemDeselectEvent>> listeners = table.getEventListeners(TableItemDeselectEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<TableItemDeselectEvent>); }
onItemDeselect( EventListener<TableItemDeselectEvent<T>> listener) { return addItemDeselectListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddSelectionChangeListener() { table.onItemSelectionChange(event -> { });  List<EventListener<TableItemSelectionChange>> listeners = table.getEventListeners(TableItemSelectionChange.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<TableItemSelectionChange>); }
onItemSelectionChange( EventListener<TableItemSelectionChange<T>> listener) { return addItemSelectionChangeListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddDataListener() { component.onData(event -> { });  List<EventListener<TerminalDataEvent>> listeners = component.getEventListeners(TerminalDataEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<TerminalDataEvent>); }
onData(EventListener<TerminalDataEvent> listener) { return addDataListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldAddKeyListener() { component.onKey(event -> { });  List<EventListener<TerminalKeyEvent>> listeners = component.getEventListeners(TerminalKeyEvent.class);  "<AssertPlaceHolder>"; assertTrue(listeners.get(0) instanceof EventListener<TerminalKeyEvent>); }
onKey(EventListener<TerminalKeyEvent> listener) { return addKeyListener(listener); }
[*] target: assertEquals(1, listeners.size())
[-] pred: org. junit. Assert. assertEquals ( 1, listeners. size ( ) )
************************************
************************************
[+] input: shouldSelectItems() { component.select("item1"); component.select("item2");  List<Integer> indices = component.getSelectedIndices();  "<AssertPlaceHolder>"; assertEquals(0, indices.get(0)); assertEquals(1, indices.get(1)); }
getSelectedIndices();  /** * Returns whether the given item is selected. * * @param item the item to check * @return {@code true}
[*] target: assertEquals(2, indices.size())
[-] pred: org. junit. Assert. assertEquals ( 2, indices. size ( ) )
************************************
************************************
[+] input: shouldSelectKeys() { component.selectKey("item2", "item3");  List<Integer> indices = component.getSelectedIndices();  "<AssertPlaceHolder>"; assertEquals(1, indices.get(0)); assertEquals(2, indices.get(1)); }
getSelectedIndices();  /** * Returns whether the given item is selected. * * @param item the item to check * @return {@code true}
[*] target: assertEquals(2, indices.size())
[-] pred: org. junit. Assert. assertEquals ( 2, indices. size ( ) )
************************************
************************************
[+] input: shouldReturnSelectedKeys() { component.select("item2"); component.select("item3");  List<Object> keys = component.getSelectedKeys();  "<AssertPlaceHolder>"; assertEquals("item2", keys.get(0)); assertEquals("item3", keys.get(1)); }
getSelectedKeys();  /** * Returns the list of selected indices. * * @return the list of selected indices */ List<Integer> getSelectedIndices();  /** * Returns whether the given item is selected. * * @param item the item to check * @return {@code true}
[*] target: assertEquals(2, keys.size())
[-] pred: org. junit. Assert. assertEquals ( 2, keys. size ( ) )
************************************
************************************
[+] input: BBjException { String script = "console.log('script')"; PendingResult<Object> operation = page.executeJsAsync(script);  "<AssertPlaceHolder>"; assertFalse(operation.isDone());  AtomicReference<String> resultRef = new AtomicReference<>(); operation.complete("Executed: " + script); operation.thenAccept(result -> resultRef.set((String) result));  assertEquals("Executed: " + script, resultRef.get()); assertTrue(operation.isDone());  verify(webManager).executeAsyncScript(script, true, true); }
executeJsAsync(String js) { try { if (executeJsAsyncHandler == null) { executeJsAsyncHandler = new PageExecuteJsAsyncHandler(getEnvironment()); executeJsAsyncHandler.register(); }  PendingResult<Object> result = new PendingResult<>(); int index = getWebManager().executeAsyncScript(js, true, true); executeJsAsyncHandler.getPendingResults().put(index, result);  return result; } catch (BBjException e) { throw new WebforjRuntimeException("Failed to execute async script.", e); } }
[*] target: assertNotNull(operation)
[-] pred: org. junit. Assert. assertNotNull ( operation )
************************************
************************************
[+] input: IllegalAccessException { ReflectionUtils.nullifyControl(component);  component.setInvalid(true); "<AssertPlaceHolder>";  assertTrue(component.getProperty("invalid", Boolean.class)); }
isInvalid() { return getProperty("invalid", Boolean.class); }
[*] target: assertTrue(component.isInvalid())
[-] pred: org. junit. Assert. assertTrue ( component. isInvalid() )
************************************
************************************
[+] input: IllegalAccessException { ReflectionUtils.nullifyControl(component);  component.setAutoClientValidateOnLoad(true); "<AssertPlaceHolder>";  assertTrue(component.getProperty("autoValidateOnLoad", Boolean.class)); }
isAutoClientValidateOnLoad() { return this.autoValidateOnLoad; }
[*] target: assertTrue(component.isAutoClientValidateOnLoad())
[-] pred: org. junit. Assert. assertTrue ( component. isAutoClientValidateOnLoad ( ) )
************************************
************************************
[+] input: IllegalAccessException { ReflectionUtils.nullifyControl(component);  component.setAutoClientValidate(true); "<AssertPlaceHolder>";  assertTrue(component.getProperty("autoValidate", Boolean.class)); }
isAutoClientValidate() { return this.autoValidate; }
[*] target: assertTrue(component.isAutoClientValidate())
[-] pred: org. junit. Assert. assertTrue ( component. isAutoClientValidate() )
************************************
************************************
[+] input: shouldCreateFieldWithLabelValueAndListener() { EventListener<ValueChangeEvent<LocalDateTime>> listener = event -> { }; LocalDateTime dateTime = LocalDateTime.of(2020, 1, 1, 10, 0); component = new DateTimeField("label", dateTime, listener); assertEquals("label", component.getLabel()); "<AssertPlaceHolder>"; assertEquals(Expanse.MEDIUM, component.getExpanse()); assertEquals(1, component.getEventListeners(ValueChangeEvent.class).size()); }
getValue() { String text = getText(); return text == null || text.isEmpty() ? null : LocalDateTime.parse(text).truncatedTo(ChronoUnit.SECONDS); }
[*] target: assertEquals(dateTime, component.getValue())
[-] pred: org. junit. Assert. assertEquals ( dateTime, component. getValue ( ) )
************************************
************************************
[+] input: shouldCreateFieldWithValue() { LocalDateTime dateTime = LocalDateTime.of(2020, 1, 1, 10, 0); component = new DateTimeField(dateTime); "<AssertPlaceHolder>"; assertEquals(Expanse.MEDIUM, component.getExpanse()); }
getValue() { String text = getText(); return text == null || text.isEmpty() ? null : LocalDateTime.parse(text).truncatedTo(ChronoUnit.SECONDS); }
[*] target: assertEquals(dateTime, component.getValue())
[-] pred: org. junit. Assert. assertEquals ( dateTime, component. getValue ( ) )
************************************
************************************
[+] input: shouldCreateFieldWithLabelAndValue() { LocalDateTime dateTime = LocalDateTime.of(2020, 1, 1, 10, 0); component = new DateTimeField("label", dateTime); assertEquals("label", component.getLabel()); "<AssertPlaceHolder>"; assertEquals(Expanse.MEDIUM, component.getExpanse()); }
getValue() { String text = getText(); return text == null || text.isEmpty() ? null : LocalDateTime.parse(text).truncatedTo(ChronoUnit.SECONDS); }
[*] target: assertEquals(dateTime, component.getValue())
[-] pred: org. junit. Assert. assertEquals ( dateTime, component. getValue ( ) )
************************************
************************************
[+] input: shouldCreateFieldWithLabelValueAndPlaceholder() { LocalDate value = LocalDate.of(2020, 10, 1); component = new MaskedDateFieldSpinner("label", value, "placeholder"); assertEquals("label", component.getLabel()); "<AssertPlaceHolder>"; assertEquals("placeholder", component.getPlaceholder()); assertEquals(Expanse.MEDIUM, component.getExpanse()); }
getValue() { return value; }
[*] target: assertEquals(value, component.getValue())
[-] pred: org. junit. Assert. assertEquals ( value, component. getValue() )
************************************
************************************
[+] input: shouldCreateFieldWithLabelAndValue() { LocalDate value = LocalDate.of(2020, 10, 1); component = new MaskedDateFieldSpinner("label", value); assertEquals("label", component.getLabel()); "<AssertPlaceHolder>"; assertEquals(Expanse.MEDIUM, component.getExpanse()); }
getValue() { return value; }
[*] target: assertEquals(value, component.getValue())
[-] pred: org. junit. Assert. assertEquals ( value, component. getValue() )
************************************
************************************
[+] input: shouldCreateFieldWithLabelValueAndPlaceholder() { LocalTime value = LocalTime.of(12, 30); component = new MaskedTimeFieldSpinner("label", value, "placeholder"); assertEquals("label", component.getLabel()); "<AssertPlaceHolder>"; assertEquals("placeholder", component.getPlaceholder()); assertEquals(Expanse.MEDIUM, component.getExpanse()); }
getValue() { return value; }
[*] target: assertEquals(value, component.getValue())
[-] pred: org. junit. Assert. assertEquals ( value, component. getValue() )
************************************
************************************
[+] input: shouldCreateFieldWithLabelValueAndListener() { LocalTime value = LocalTime.of(12, 30); EventListener<ValueChangeEvent<LocalTime>> listener = event -> { }; component = new MaskedTimeFieldSpinner("label", value, listener); assertEquals("label", component.getLabel()); "<AssertPlaceHolder>"; assertEquals(Expanse.MEDIUM, component.getExpanse()); assertEquals(1, component.getEventListeners(ValueChangeEvent.class).size()); }
getValue() { return value; }
[*] target: assertEquals(value, component.getValue())
[-] pred: org. junit. Assert. assertEquals ( value, component. getValue() )
************************************
************************************
[+] input: shouldCreateFieldWithLabelAndValue() { LocalTime value = LocalTime.of(12, 30); component = new MaskedTimeFieldSpinner("label", value); assertEquals("label", component.getLabel()); "<AssertPlaceHolder>"; assertEquals(Expanse.MEDIUM, component.getExpanse()); }
getValue() { return value; }
[*] target: assertEquals(value, component.getValue())
[-] pred: org. junit. Assert. assertEquals ( value, component. getValue() )
************************************
************************************
[+] input: BBjException { when(control.getAllParagraphs()) .thenReturn(new BBjVector(List.of("paragraph 1", "paragraph 2")));  List<String> paragraphs = component.getParagraphs();  "<AssertPlaceHolder>"; assertEquals("paragraph 1", paragraphs.get(0)); assertEquals("paragraph 2", paragraphs.get(1)); }
getParagraphs() { BBjCEdit field = inferField();  if (field != null) { try { List<String> ret = new ArrayList<>(); field.getAllParagraphs().stream().forEach(p -> ret.add(String.valueOf(p))); return ret; } catch (BBjException e) { throw new WebforjRuntimeException(e); } }  return paragraphs; }
[*] target: assertEquals(2, paragraphs.size())
[-] pred: org. junit. Assert. assertEquals ( 2, paragraphs. size ( ) )
************************************
************************************
[+] input: shouldFireChangeEvent() { NavigatorChangeEvent[] changeEvent = new NavigatorChangeEvent[1]; NavigatorMoveNextEvent nextEvent = new NavigatorMoveNextEvent(component, Map.of("current", 2, "startIndex", 0, "endIndex", 10));  component.onChange(e -> changeEvent[0] = e); component.handleChangeEvent(nextEvent);  "<AssertPlaceHolder>"; assertEquals(NavigatorChangeEvent.Direction.NEXT, changeEvent[0].getDirection()); assertEquals(2, changeEvent[0].getCurrent()); assertEquals(0, changeEvent[0].getStartIndex()); assertEquals(10, changeEvent[0].getEndIndex()); }
handleChangeEvent(NavigatorMoveEvent event) { int current = event.getCurrent(); NavigatorChangeEvent.Direction direction = null;  if (event instanceof NavigatorMoveFirstEvent) { direction = NavigatorChangeEvent.Direction.FIRST; } else if (event instanceof NavigatorMoveLastEvent) { direction = NavigatorChangeEvent.Direction.LAST; } else if (event instanceof NavigatorMoveNextEvent) { direction = NavigatorChangeEvent.Direction.NEXT; } else if (event instanceof NavigatorMovePreviousEvent) { direction = NavigatorChangeEvent.Direction.PREVIOUS; }  paginator.setCurrent(current);  NavigatorChangeEvent navigatorChangeEvent = new NavigatorChangeEvent(this, direction, current, event.getStartIndex(), event.getEndIndex());  getEventDispatcher().dispatchEvent(navigatorChangeEvent); }
[*] target: assertNotNull(changeEvent[0])
[-] pred: org. junit. Assert. assertNotNull ( changeEvent[0] )
************************************
************************************
[+] input: shouldConstructWithTitleInitialPathFiltersAndRestricted() { component = new FileChooserDialog("Title", "/path", Arrays.asList(mockFilter1, mockFilter2), true); assertEquals("Title", component.getTitle()); assertEquals("/path", component.getInitialPath()); assertEquals(Arrays.asList(mockFilter1, mockFilter2), component.getFilters()); "<AssertPlaceHolder>"; }
isRestricted() { return restricted; }
[*] target: assertTrue(component.isRestricted())
[-] pred: org. junit. Assert. assertTrue ( component. isRestricted() )
************************************
************************************
[+] input: shouldConstructWithTitleInitialPathAndRestricted() { component = new FileChooserDialog("Title", "/path", true); assertEquals("Title", component.getTitle()); assertEquals("/path", component.getInitialPath()); "<AssertPlaceHolder>"; }
isRestricted() { return restricted; }
[*] target: assertTrue(component.isRestricted())
[-] pred: org. junit. Assert. assertTrue ( component. isRestricted() )
************************************
************************************
[+] input: shouldSetAndGetCustomFilters() { component = new FileChooserDialog(); component.setCustomFilters(true); "<AssertPlaceHolder>";  assertEquals("true", component.getAttributes().get("custom-filters")); }
isCustomFilters() { return customFilters; }
[*] target: assertTrue(component.isCustomFilters())
[-] pred: org. junit. Assert. assertTrue ( component. isCustomFilters() )
************************************
************************************
[+] input: shouldSetAndGetCacheCustomFilters() { component = new FileChooserDialog(); component.setCacheCustomFilters(true); "<AssertPlaceHolder>";  assertEquals("true", component.getAttributes().get("cache-custom-filters")); }
isCacheCustomFilters() { return cacheCustomFilters; }
[*] target: assertTrue(component.isCacheCustomFilters())
[-] pred: org. junit. Assert. assertTrue ( component. isCacheCustomFilters() )
************************************
************************************
[+] input: shouldCreateRadioButtonWithNoParameters() { RadioButton radioButton = RadioButton.Switch();  assertEquals("", radioButton.getText()); "<AssertPlaceHolder>"; }
isChecked() { // this method should return false if radio button // belongs to a group and there is a button already checked  RadioButtonGroup theGroup = getButtonGroup(); if (Boolean.FALSE.equals(this.isAttached()) && theGroup != null) { List<RadioButton> checkedButtons = theGroup.getButtons().stream().filter(RadioButton::getChecked).toList();  if (checkedButtons.size() > 1) { return checkedButtons.get(checkedButtons.size() - 1) == this; } }  return super.isChecked(); }
[*] target: assertFalse(radioButton.isChecked())
[-] pred: org. junit. Assert. assertFalse ( radioButton. isChecked ( ) )
************************************
************************************
[+] input: shouldSetGetMaxLength() { int expectedMaxLength = 256; assertSame(component.setMaxLength(expectedMaxLength), component); "<AssertPlaceHolder>"; }
getMaxLength() { Component component = ComponentUtil.getBoundComponent(this);  if (component instanceof HasMaxLength) { return ((HasMaxLength<?>) component).getMaxLength(); }  throw new UnsupportedOperationException("The component does not support max length"); }
[*] target: assertEquals(expectedMaxLength, component.getMaxLength())
[-] pred: org. junit. Assert. assertEquals ( expectedMaxLength, component. getMaxLength() )
************************************
************************************
[+] input: shouldSetGetMinLength() { int expectedMaxLength = 10; assertSame(component, component.setMinLength(expectedMaxLength)); "<AssertPlaceHolder>"; }
getMinLength() { Component component = ComponentUtil.getBoundComponent(this);  if (component instanceof HasMinLength) { return ((HasMinLength<?>) component).getMinLength(); }  throw new UnsupportedOperationException("The component does not support the min length"); }
[*] target: assertEquals(expectedMaxLength, component.getMinLength())
[-] pred: org. junit. Assert. assertEquals ( expectedMaxLength, component. getMinLength() )
************************************
************************************
[+] input: shouldSetGetMin() { Double expectedMin = 1.99; assertSame(component.setMin(expectedMin), component); "<AssertPlaceHolder>"; }
getMin() { Component component = ComponentUtil.getBoundComponent(this);  if (component instanceof HasMin) { return ((HasMin<?, V>) component).getMin(); }  throw new UnsupportedOperationException("The component does not support min"); }
[*] target: assertEquals(expectedMin, component.getMin())
[-] pred: org. junit. Assert. assertEquals ( expectedMin, component. getMin() )
************************************
************************************
[+] input: shouldSetGetValue() { Double expectedValue = 1.99; assertSame(component, component.setValue(expectedValue)); "<AssertPlaceHolder>"; }
getValue() { Component component = ComponentUtil.getBoundComponent(this);  if (component instanceof HasValue) { return ((HasValue<?, V>) component).getValue(); }  throw new UnsupportedOperationException("The component does not support the value property"); }
[*] target: assertEquals(expectedValue, component.getValue())
[-] pred: org. junit. Assert. assertEquals ( expectedValue, component. getValue ( ) )
************************************
************************************
[+] input: testConstructor() { String message = "This is the message"; String body = "This is the body"; int code = 403; String expectToString = "com.amazon.spapi.documents.exception.HttpResponseException: " + "This is the message {code=403, body=This is the body}";  HttpResponseException exception = new HttpResponseException(message, body, code);  assertEquals(message, exception.getMessage()); assertEquals(body, exception.getBody()); assertEquals(code, exception.getCode()); "<AssertPlaceHolder>"; }
toString() { return super.toString() + " {code=" + getCode() + ", body=" + getBody() + '}'; }
[*] target: assertEquals(expectToString, exception.toString())
[-] pred: org. junit. Assert. assertEquals ( expectToString, exception. toString ( ) )
************************************
************************************
[+] input: testConstructorNullBody() { String message = "This is the message"; String body = null; int code = 403; String expectToString = "com.amazon.spapi.documents.exception.HttpResponseException: " + "This is the message {code=403, body=null}";  HttpResponseException exception = new HttpResponseException(message, body, code);  assertEquals(message, exception.getMessage()); assertEquals(body, exception.getBody()); assertEquals(code, exception.getCode()); "<AssertPlaceHolder>"; }
toString() { return super.toString() + " {code=" + getCode() + ", body=" + getBody() + '}'; }
[*] target: assertEquals(expectToString, exception.toString())
[-] pred: org. junit. Assert. assertEquals ( expectToString, exception. toString ( ) )
************************************
************************************
[+] input: testConstructorCause() { String message = "This is the message"; Throwable cause = new RuntimeException(); String body = "This is the body"; int code = 403;  HttpResponseException exception = new HttpResponseException(message, cause, body, code);  assertEquals(message, exception.getMessage()); assertSame(cause, exception.getCause()); assertEquals(body, exception.getBody()); "<AssertPlaceHolder>"; }
getCode() { return code; }
[*] target: assertEquals(code, exception.getCode())
[-] pred: org. junit. Assert. assertEquals ( code, exception. getCode() )
************************************
************************************
[+] input: Exception { String clientId = "22334455"; String clientSecret = "998877665544"; String cloudApiBaseUrl = "https://xray.cloud.getxray.app/api/v2"; String authenticationPayload = "{ "client_id": "" + clientId +"", "client_secret": "" + clientSecret +"" }"; String expectedToken = "00000000000000000000000000111111111111111111111111222222222222222222222223333333333333";  Log log = Mockito.mock(Log.class); OkHttpClient client = Mockito.mock(OkHttpClient.class); Builder responseBuilder = new Response.Builder(); responseBuilder.protocol(okhttp3.Protocol.HTTP_1_1); responseBuilder.request(new Request.Builder().url(cloudApiBaseUrl + "/authenticate").build()); responseBuilder.code(200); responseBuilder.message("OK"); responseBuilder.header("Content-Type", "application/json"); responseBuilder.body(okhttp3.ResponseBody.create("""+expectedToken+""", okhttp3.MediaType.parse("application/json"))); Response response = responseBuilder.build();  final Call remoteCall = Mockito.mock(Call.class); when(remoteCall.execute()).thenReturn(response); when(client.newCall(any())).thenReturn(remoteCall);  // OkHttpClient client2 = mockHttpClient("""+expectedToken+"""); String authToken = CommonCloud.authenticateXrayAPIKeyCredentials(log, true, client, clientId, clientSecret, cloudApiBaseUrl); "<AssertPlaceHolder>";  ArgumentCaptor<Request> req = ArgumentCaptor.forClass(Request.class); verify(client).newCall(req.capture()); assertEquals(cloudApiBaseUrl + "/authenticate", req.getValue().url().toString()); assertEquals("POST", req.getValue().method()); assertEquals("application/json; charset=utf-8", req.getValue().body().contentType().toString()); final Buffer buffer = new Buffer(); req.getValue().body().writeTo(buffer); assertEquals(authenticationPayload,  buffer.readUtf8()); }
authenticateXrayAPIKeyCredentials(Log logger,boolean verbose, OkHttpClient client, String clientId, String clientSecret, String cloudApiBaseUrl) throws IOException { String authenticationPayload = "{ "client_id": "" + clientId +"", "client_secret": "" + clientSecret +"" }"; RequestBody body = RequestBody.create(authenticationPayload, MEDIA_TYPE_JSON); String xrayCloudAuthenticateUrl = cloudApiBaseUrl + "/authenticate"; Request request = new Request.Builder().url(xrayCloudAuthenticateUrl).post(body).build(); CommonUtils.logRequest(logger, request, verbose); try (Response response = client.newCall(request).execute()) { CommonUtils.logResponse(logger, response, false); String responseBody = response.body().string(); if (response.isSuccessful()) { return responseBody.replace(""", ""); } else { throw new IOException("failed to authenticate " + response); } } }
[*] target: assertEquals(expectedToken, authToken)
[-] pred: org. junit. Assert. assertEquals ( expectedToken, authToken )
************************************
************************************
[+] input: getCountry_ExistInDatabase_Success() { generateTestData(); CountryVm countryVm = countryService.findById(country1.getId()); "<AssertPlaceHolder>"; assertEquals("country-1", countryVm.name()); }
findById(final Long id) { final Country country = countryRepository .findById(id) .orElseThrow( () -> new NotFoundException(Constants.ErrorCode.COUNTRY_NOT_FOUND, id)); return countryMapper.toCountryViewModelFromCountry(country); }
[*] target: assertNotNull(countryVm)
[-] pred: org. junit. Assert. assertNotNull ( countryVm )
************************************
************************************
[+] input: createCountry_ValidData_Success() { CountryPostVm countryPostVm = CountryPostVm.builder() .name("country") .build(); Country country = countryService.create(countryPostVm); "<AssertPlaceHolder>"; assertEquals("country", country.getName()); }
create(final CountryPostVm countryPostVm) { if (countryRepository.existsByName(countryPostVm.name())) { throw new DuplicatedException(Constants.ErrorCode.NAME_ALREADY_EXITED, countryPostVm.name()); } return countryRepository.save(countryMapper.toCountryFromCountryPostViewModel(countryPostVm)); }
[*] target: assertNotNull(country)
[-] pred: org. junit. Assert. assertNotNull ( country )
************************************
************************************
[+] input: getCountries_Pagination_Success() { generateTestData(); int pageNo = 1; int pageSize = 2; CountryListGetVm countryListGetVm = countryService.getPageableCountries(pageNo, pageSize); "<AssertPlaceHolder>"; assertEquals(countryListGetVm.pageNo(), pageNo); assertEquals(countryListGetVm.pageSize(), pageSize); assertTrue(countryListGetVm.isLast()); assertEquals(2, countryListGetVm.totalElements()); assertEquals(1, countryListGetVm.totalPages()); }
getPageableCountries(final int pageNo, final int pageSize) { final Pageable pageable = PageRequest.of(pageNo, pageSize); final Page<Country> countryPage = countryRepository.findAll(pageable); final List<Country> countryList = countryPage.getContent();  final List<CountryVm> countryVms = countryList.stream() .map(CountryVm::fromModel) .toList();  return new CountryListGetVm( countryVms, countryPage.getNumber(), countryPage.getSize(), (int) countryPage.getTotalElements(), countryPage.getTotalPages(), countryPage.isLast() ); }
[*] target: assertNotNull(countryListGetVm)
[-] pred: org. junit. Assert. assertNotNull ( countryListGetVm )
************************************
************************************
[+] input: getAllStateOrProvinceByCountryId_Success() { generateTestData(); List<StateOrProvinceVm> stateOrProvinceVms = stateOrProvinceService.getAllByCountryId(country.getId()); "<AssertPlaceHolder>"; assertEquals(2, stateOrProvinceVms.size()); }
getAllByCountryId(Long countryId) { return stateOrProvinceRepository.findAllByCountryIdOrderByNameAsc(countryId).stream() .map(stateOrProvinceMapper::toStateOrProvinceViewModelFromStateOrProvince) .toList(); }
[*] target: assertNotNull(stateOrProvinceVms)
[-] pred: org. junit. Assert. assertNotNull ( stateOrProvinceVms )
************************************
************************************
[+] input: getStateOrProvincePagination_Success() { generateTestData(); int pageNo = 0; int pageSize = 2; StateOrProvinceListGetVm stateOrProvinceListGetVm = stateOrProvinceService.getPageableStateOrProvinces(pageNo, pageSize, country.getId()); "<AssertPlaceHolder>"; assertEquals(stateOrProvinceListGetVm.pageNo(), pageNo); assertEquals(stateOrProvinceListGetVm.pageSize(), pageSize); assertEquals(2, stateOrProvinceListGetVm.stateOrProvinceContent().size()); }
getPageableStateOrProvinces(int pageNo, int pageSize, Long countryId) { final Pageable pageable = PageRequest.of(pageNo, pageSize); final Page<StateOrProvince> stateOrProvincePage = stateOrProvinceRepository.getPageableStateOrProvincesByCountry( countryId, pageable); final List<StateOrProvince> stateOrProvinceList = stateOrProvincePage.getContent();  final List<StateOrProvinceVm> stateOrProvinceVms = stateOrProvinceList.stream() .map(StateOrProvinceVm::fromModel) .toList();  return new StateOrProvinceListGetVm( stateOrProvinceVms, stateOrProvincePage.getNumber(), stateOrProvincePage.getSize(), (int) stateOrProvincePage.getTotalElements(), stateOrProvincePage.getTotalPages(), stateOrProvincePage.isLast() ); }
[*] target: assertNotNull(stateOrProvinceListGetVm)
[-] pred: org. junit. Assert. assertNotNull ( stateOrProvinceListGetVm )
************************************
************************************
[+] input: testCreateOrder_RemoteServiceThrowsException_RollbackOrder() { doThrow(new RuntimeException()).when(productService).subtractProductStockQuantity(any(OrderVm.class)); try { orderService.createOrder(orderPostVm); } catch (Exception e) {  } List<Order> orders = orderRepository.findAll(); "<AssertPlaceHolder>"; List<OrderItem> orderItems = orderItemRepository.findAll(); assertEquals(0, orderItems.size()); }
createOrder(OrderPostVm orderPostVm) {  OrderAddressPostVm billingAddressPostVm = orderPostVm.billingAddressPostVm(); OrderAddress billOrderAddress = OrderAddress.builder() .phone(billingAddressPostVm.phone()) .contactName(billingAddressPostVm.contactName()) .addressLine1(billingAddressPostVm.addressLine1()) .addressLine2(billingAddressPostVm.addressLine2()) .city(billingAddressPostVm.city()) .zipCode(billingAddressPostVm.zipCode()) .districtId(billingAddressPostVm.districtId()) .districtName(billingAddressPostVm.districtName()) .stateOrProvinceId(billingAddressPostVm.stateOrProvinceId()) .stateOrProvinceName(billingAddressPostVm.stateOrProvinceName()) .countryId(billingAddressPostVm.countryId()) .countryName(billingAddressPostVm.countryName()) .build();  OrderAddressPostVm shipOrderAddressPostVm = orderPostVm.shippingAddressPostVm(); OrderAddress shippOrderAddress = OrderAddress.builder() .phone(shipOrderAddressPostVm.phone()) .contactName(shipOrderAddressPostVm.contactName()) .addressLine1(shipOrderAddressPostVm.addressLine1()) .addressLine2(shipOrderAddressPostVm.addressLine2()) .city(shipOrderAddressPostVm.city()) .zipCode(shipOrderAddressPostVm.zipCode()) .districtId(shipOrderAddressPostVm.districtId()) .districtName(shipOrderAddressPostVm.districtName()) .stateOrProvinceId(shipOrderAddressPostVm.stateOrProvinceId()) .stateOrProvinceName(shipOrderAddressPostVm.stateOrProvinceName()) .countryId(shipOrderAddressPostVm.countryId()) .countryName(shipOrderAddressPostVm.countryName()) .build();  Order order = Order.builder() .email(orderPostVm.email()) .note(orderPostVm.note()) .tax(orderPostVm.tax()) .discount(orderPostVm.discount()) .numberItem(orderPostVm.numberItem()) .totalPrice(orderPostVm.totalPrice()) .couponCode(orderPostVm.couponCode()) .orderStatus(OrderStatus.PENDING) .deliveryFee(orderPostVm.deliveryFee()) .deliveryMethod(orderPostVm.deliveryMethod()) .deliveryStatus(DeliveryStatus.PREPARING) .paymentStatus(orderPostVm.paymentStatus()) .shippingAddressId(shippOrderAddress) .billingAddressId(billOrderAddress) .checkoutId(orderPostVm.checkoutId()) .build(); orderRepository.save(order);   Set<OrderItem> orderItems = orderPostVm.orderItemPostVms().stream() .map(item -> OrderItem.builder() .productId(item.productId()) .productName(item.productName()) .quantity(item.quantity()) .productPrice(item.productPrice()) .note(item.note()) .orderId(order) .build()) .collect(Collectors.toSet()); orderItemRepository.saveAll(orderItems);  //setOrderItems so that we able to return order with orderItems order.setOrderItems(orderItems); OrderVm orderVm = OrderVm.fromModel(order); productService.subtractProductStockQuantity(orderVm); cartService.deleteCartItem(orderVm); acceptOrder(orderVm.id()); return orderVm; }
[*] target: assertEquals(0, orders.size())
[-] pred: org. junit. Assert. assertEquals ( 0, orders. size ( ) )
************************************
************************************
[+] input: getCategoryById_Success() { when(mediaService.getMedia(category.getImageId())).thenReturn(noFileMediaVm); CategoryGetDetailVm categoryGetDetailVm = categoryService.getCategoryById(category.getId()); "<AssertPlaceHolder>"; assertEquals("name", categoryGetDetailVm.name()); }
getCategoryById(Long id) { Category category = categoryRepository .findById(id) .orElseThrow(() -> new NotFoundException(Constants.ErrorCode.CATEGORY_NOT_FOUND, id)); ImageVm categoryImage = null; if (category.getImageId() != null) { categoryImage = new ImageVm(category.getImageId(), mediaService.getMedia(category.getImageId()).url()); } Category parentCategory = category.getParent(); Long parentId = 0L; if (parentCategory != null) { parentId = parentCategory.getId(); } return new CategoryGetDetailVm( category.getId(), category.getName(), category.getSlug(), category.getDescription(), parentId, category.getMetaKeyword(), category.getMetaDescription(), category.getDisplayOrder(), category.getIsPublished(), categoryImage ); }
[*] target: assertNotNull(categoryGetDetailVm)
[-] pred: org. junit. Assert. assertNotNull ( categoryGetDetailVm )
************************************
************************************
[+] input: input1() { WorkbookParameter workbookParameter = WorkbookParameter .builder() .build();  Assertions.assertNull(workbookParameter.getInputFileName()); Assertions.assertNull(workbookParameter.getInputFilePath()); Assertions.assertNull(workbookParameter.getInputFile()); Assertions.assertNull(workbookParameter.getInputStream());  Assertions."<AssertPlaceHolder>"; }
isXssf() { return xssf == null || xssf; }
[*] target: assertTrue(workbookParameter.isXssf())
[-] pred: org. junit. Assert. assertTrue ( workbookParameter. isXssf() )
************************************
************************************
[+] input: output1() { WorkbookParameter workbookParameter = WorkbookParameter .builder() .build();  Assertions.assertNull(workbookParameter.getOutputFileName()); Assertions.assertNull(workbookParameter.getOutputFilePath()); Assertions.assertNull(workbookParameter.getOutputFile()); Assertions.assertNull(workbookParameter.getOutputStream());  Assertions."<AssertPlaceHolder>";  }
isXssf() { return xssf == null || xssf; }
[*] target: assertTrue(workbookParameter.isXssf())
[-] pred: org. junit. Assert. assertTrue ( workbookParameter. isXssf() )
************************************
************************************
[+] input: empty() { CellResultSet cellResultSet = CellResultSet.none(); Assertions."<AssertPlaceHolder>"; Assertions.assertThrows(ExcelException.class, cellResultSet::getFirstCellResult); Assertions.assertThrows(ExcelException.class, cellResultSet::getExcelType); Assertions.assertTrue(cellResultSet.getCellResultListList().isEmpty()); }
isNone() { if (cellResultListList == null || cellResultListList.isEmpty()) { return true; } for (List<CellResult> cellResultList : cellResultListList) { if (cellResultList != null && !cellResultList.isEmpty()) { return false; } } return true; }
[*] target: assertTrue(cellResultSet.isNone())
[-] pred: org. junit. Assert. assertTrue ( cellResultSet. isNone() )
************************************
************************************
[+] input: findForClassTestField() { ExcelAnnotationParse excelAnnotationParse = new ExcelAnnotationParse(new Configuration()); excelAnnotationParse.setConfigCacheEnabled(false);  ExcelClassConfig excelClassConfig = excelAnnotationParse.findForClass(Demo7.class); List<ExcelFieldConfig> excelFieldConfigList = excelClassConfig.getItemList();  Assertions."<AssertPlaceHolder>"; ExcelFieldConfig excelFieldConfig = excelFieldConfigList.get(0); Assertions.assertEquals(excelFieldConfig.getTitle(), "name-title"); Assertions.assertEquals(excelFieldConfig.getExcelType(), ExcelType.STRING); Assertions.assertEquals(excelFieldConfig.getCellHandler().length, 1); Assertions.assertEquals(excelFieldConfig.getCellHandler()[0], DateStringHandler.class); Assertions.assertEquals(excelFieldConfig.getColspan(), 2); Assertions.assertEquals(excelFieldConfig.getColspan(), 2); Assertions.assertEquals(excelFieldConfig.getHeadFormat(), "@@"); Assertions.assertEquals(excelFieldConfig.getJavaFormat(), "yyyy"); Assertions.assertEquals(excelFieldConfig.getExcelFormat(), "mm");   }
findForClass(Class<?> clazz) { if (configCacheEnabled) { // synchronized (type) removed see issue #461 return excelClassConfigMap.computeIfAbsent(clazz, this::parseForClass); } else { return this.parseForClass(clazz); } }
[*] target: assertEquals(excelFieldConfigList.size(), 3)
[-] pred: org. junit. Assert. assertEquals ( excelFieldConfigList. size ( ), 3 )
************************************
************************************

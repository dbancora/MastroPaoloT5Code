[+] input: testRangeMergeOnly() {  AckRangeSet set = new AckRangeSet(); set.add(0, 1); set.add(1, 101); set.add(101, 201); set.add(201, 301); set.add(301, 401); set.add(201, 301); set.add(501, 601);  List<AckRange> rangesList = convertToOrderedList(set.getRanges()); "<AssertPlaceHolder>"; assertRangeEquals(0, 401, rangesList.get(0)); assertRangeEquals(501, 601, rangesList.get(1));  }
getRanges() { return ranges; }
[*] target: assertEquals(2, rangesList.size())
[-] pred: org. junit. Assert. assertEquals ( 2, rangesList. size ( ) )
************************************
************************************
[+] input: testRangeMergeAbove() {  AckRangeSet set = new AckRangeSet(); set.add(0, 1); set.add(1, 101); set.add(201, 301); set.add(101, 201); set.add(401, 501);  List<AckRange> rangesList = convertToOrderedList(set.getRanges()); "<AssertPlaceHolder>"; assertRangeEquals(0, 301, rangesList.get(0)); assertRangeEquals(401, 501, rangesList.get(1));  }
getRanges() { return ranges; }
[*] target: assertEquals(2, rangesList.size())
[-] pred: org. junit. Assert. assertEquals ( 2, rangesList. size ( ) )
************************************
************************************
[+] input: Exception { CollectorFormatter minF = new CollectorFormatter("{7}", (Formatter) null, (Comparator<LogRecord>) null);  tickMilli(); //Make sure the max not equal to the start time.  final String min = minF.getTail((Handler) null); NumberFormat.getIntegerInstance().parse(min); tickMilli();  //Next min is not old min. String next = minF.getTail((Handler) null); assertFalse(min + ' ' + next, min.equals(next));  //All mins start at the init time. CollectorFormatter initF = new CollectorFormatter("{10}", (Formatter) null, (Comparator<LogRecord>) null);  next = initF.getTail((Handler) null); "<AssertPlaceHolder>"; }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }
[*] target: assertEquals(min, next)
[-] pred: org. junit. Assert. assertEquals ( min, next )
************************************
************************************
[+] input: Exception { final String p = CollectorFormatter.class.getName(); Properties props = new Properties(); final String expect = CollectorFormatterTest.class.getName(); props.put(p.concat(".format"), expect); LogManager manager = LogManager.getLogManager(); try { read(manager, props); CollectorFormatter cf = new CollectorFormatter(); LogRecord first = new LogRecord(Level.SEVERE, Level.SEVERE.getName()); assertEquals("", cf.format(first)); String result = cf.getTail((Handler) null); "<AssertPlaceHolder>"; } finally { manager.reset(); } }
getTail(final Handler h) { super.getTail(h);  //Be forward compatible with super.getHead. return formatRecord(h, true); }
[*] target: assertEquals(expect, result)
[-] pred: org. junit. Assert. assertEquals ( expect, result )
************************************
************************************
[+] input: Exception { LogRecord record = new LogRecord(Level.SEVERE, ""); try { long expected = 10L; if (Thread.currentThread().getId() == expected) { ++expected; } setLongThreadID(record, expected); assertNotEquals(expected, Thread.currentThread().getId());  CompactFormatter cf = new CompactFormatter("%10$d"); String output = cf.format(record); String expect = Long.toString(expected); assertEquals(expect, output);  setLongThreadID(record, -1L); output = cf.format(record); expect = Long.toString(-1L); assertEquals(expect, output);  //Test that downcast works right. Number id = cf.formatThreadID(record); assertEquals(-1, id.intValue()); assertEquals(expect, Long.toString(id.longValue()));  setLongThreadID(record, Long.MAX_VALUE >>> 1L); output = cf.format(record); expect = Long.toString(Long.MAX_VALUE >>> 1L); "<AssertPlaceHolder>";  int tid = getIntThreadID(record); assertTrue(String.valueOf(tid), tid < 0); } catch (NoSuchMethodException JDK8245302) { try { Method m = LogRecord.class.getMethod("getLongThreadID"); fail(m.toString()); } catch (NoSuchMethodException expect) { assertNull(LogManagerProperties.getLongThreadID(record)); } } }
format(final LogRecord record) { //LogRecord is mutable so define local vars. Locale l = getLocale(record); String msg = formatMessage(record); String thrown = formatThrown(record); String err = formatError(record); Object[] params = { formatZonedDateTime(record), formatSource(record), formatLoggerName(record), formatLevel(record), msg, thrown, new Alternate(msg, thrown), new Alternate(thrown, msg), record.getSequenceNumber(), formatThreadID(record), err, new Alternate(msg, err), new Alternate(err, msg), formatBackTrace(record), record.getResourceBundleName(), record.getMessage()};  if (l == null) { //BUG ID 6282094 return String.format(fmt, params); } else { return String.format(l, fmt, params); } }
[*] target: assertEquals(expect, output)
[-] pred: org. junit. Assert. assertEquals ( expect, output )
************************************
************************************
[+] input: Exception { String prefix = LogManagerPropertiesTest.class.getName(); Properties parent = new Properties(); LogManagerProperties mp = new LogManagerProperties(parent, prefix); String key = "key"; Object value = TimeUnit.MILLISECONDS; assertNull(mp.put(key, value)); Object newValue = TimeUnit.NANOSECONDS; assertEquals(value, mp.put(key, newValue)); "<AssertPlaceHolder>"; }
get(final Object key) { Object value; if (key instanceof String) { value = getProperty((String) key); } else { value = null; }  //Search for non-string value. if (value == null) { value = defaults.get(key); if (value == null && !defaults.containsKey(key)) { value = super.get(key); } } return value; }
[*] target: assertEquals(newValue, mp.get(key))
[-] pred: org. junit. Assert. assertEquals ( newValue, mp. get( key ) )
************************************
************************************
[+] input: testEquals() { MailHandler h = new MailHandler(); assertFalse(h.equals((Object) null)); assertNotEquals(h, new MailHandler()); "<AssertPlaceHolder>"; }
equals(Object o) { if (o instanceof TailNameFormatter) { return name.equals(((TailNameFormatter) o).name); } return false; }
[*] target: assertTrue(h.equals(h))
[-] pred: org. junit. Assert. assertTrue ( h. equals(h ) )
************************************
************************************
[+] input: testLevelAfterClose() { MailHandler instance = new MailHandler(createInitProperties("")); InternalErrorManager em = new InternalErrorManager(); instance.setErrorManager(em);  instance.setLevel(Level.WARNING); instance.setFormatter(new LevelCheckingFormatter(Level.OFF)); instance.publish(new CloseLogRecord(Level.SEVERE, "", instance)); assertEquals(Level.OFF, instance.getLevel());  instance.close(); boolean failed = false; for (Exception exception : em.exceptions) { Throwable t = exception; if (t instanceof MessagingException) { if (!isConnectOrTimeout(t)) { dump(t); failed = true; } } else { dump(t); failed = true; } } "<AssertPlaceHolder>"; assertFalse(em.exceptions.isEmpty()); }
close() { checkAccess(); try { Message msg = null; synchronized (this) { try { msg = writeLogRecords(ErrorManager.CLOSE_FAILURE); } finally {  //Change level after formatting. this.logLevel = Level.OFF; this.disabledLevel = null; //free reference /** * The sign bit of the capacity is set to ensure that * records that have passed isLoggable, but have yet to be * added to the internal buffer, are immediately pushed as * an email. */ if (this.capacity > 0) { this.capacity = -this.capacity; }  //Only need room for one record after closed //Ensure not inside a push. if (size == 0 && data.length != 1) { initLogRecords(1); } } }  if (msg != null) { send(msg, false, ErrorManager.CLOSE_FAILURE); } } catch (final LinkageError JDK8152515) { reportLinkageError(JDK8152515, ErrorManager.CLOSE_FAILURE); } catch (final ServiceConfigurationError sce) { reportConfigurationError(sce, ErrorManager.CLOSE_FAILURE); } }
[*] target: assertFalse(failed)
[-] pred: org. junit. Assert. assertFalse ( failed )
************************************
************************************
[+] input: Exception { Properties props = new Properties(); MailHandler instance = new MailHandler(); InternalErrorManager em = new InternalErrorManager(); instance.setErrorManager(em);  assertNotNull(instance.getMailProperties()); assertEquals(Properties.class, instance.getMailProperties().getClass());   instance.setMailProperties((Properties) null); assertTrue(instance.getMailProperties().isEmpty());  instance.setMailProperties(props); Properties stored = instance.getMailProperties();  assertNotNull(stored); assertNotSame(props, stored); assertEquals(props.getClass(), stored.getClass());  assertEquals(true, em.exceptions.isEmpty()); instance.close();  instance = createHandlerWithRecords(); props = instance.getMailProperties(); em = new InternalErrorManager(); instance.setErrorManager(em);  props.setProperty("mail.from", "localhost@localdomain"); props.setProperty("mail.to", "localhost@localdomain"); instance.setMailProperties(props); instance.flush(); boolean failed = false; for (Exception exception : em.exceptions) { final Throwable t = exception; if (!isConnectOrTimeout(t)) { dump(t); failed = true; } } assertFalse(failed); assertFalse(em.exceptions.isEmpty());  props.setProperty("mail.from", "localhost@localdomain"); props.setProperty("mail.to", "::1@@"); instance.setMailProperties(props);  em = new InternalErrorManager(); instance.setErrorManager(em);  instance.publish(new LogRecord(Level.SEVERE, "test")); instance.close(); failed = false; for (Exception exception : em.exceptions) { final Throwable t = exception; if (t instanceof AddressException || isConnectOrTimeout(t)) { continue; } dump(t); failed = true; } "<AssertPlaceHolder>"; assertFalse(em.exceptions.isEmpty()); }
close() { checkAccess(); try { Message msg = null; synchronized (this) { try { msg = writeLogRecords(ErrorManager.CLOSE_FAILURE); } finally {  //Change level after formatting. this.logLevel = Level.OFF; this.disabledLevel = null; //free reference /** * The sign bit of the capacity is set to ensure that * records that have passed isLoggable, but have yet to be * added to the internal buffer, are immediately pushed as * an email. */ if (this.capacity > 0) { this.capacity = -this.capacity; }  //Only need room for one record after closed //Ensure not inside a push. if (size == 0 && data.length != 1) { initLogRecords(1); } } }  if (msg != null) { send(msg, false, ErrorManager.CLOSE_FAILURE); } } catch (final LinkageError JDK8152515) { reportLinkageError(JDK8152515, ErrorManager.CLOSE_FAILURE); } catch (final ServiceConfigurationError sce) { reportConfigurationError(sce, ErrorManager.CLOSE_FAILURE); } }
[*] target: assertFalse(failed)
[-] pred: org. junit. Assert. assertFalse ( failed )
************************************
************************************
[+] input: Exception { Properties props = createInitProperties(""); props.put("mail.from", ".invalid@@address."); props.remove("mail.to"); props.remove("mail.cc"); props.remove("mail.bcc");  //Ensure from can not be computed. assertNull(InternetAddress.getLocalAddress(Session.getInstance(props))); MailHandler instance = createHandlerWithRecords(); instance.setErrorManager(new InternalErrorManager()); instance.setMailProperties(props); instance.close(); InternalErrorManager em = internalErrorManagerFrom(instance); boolean failed = false; for (Exception exception : em.exceptions) { if (exception instanceof MessagingException) { if (exception instanceof AddressException || exception.getCause() instanceof AddressException) { continue; }  if (exception.getMessage().contains("From")) { continue; }  if (exception.getMessage().contains("No recipient addresses")) { continue; } } dump(exception); failed = true; } "<AssertPlaceHolder>"; assertFalse(em.exceptions.isEmpty()); }
close() { checkAccess(); try { Message msg = null; synchronized (this) { try { msg = writeLogRecords(ErrorManager.CLOSE_FAILURE); } finally {  //Change level after formatting. this.logLevel = Level.OFF; this.disabledLevel = null; //free reference /** * The sign bit of the capacity is set to ensure that * records that have passed isLoggable, but have yet to be * added to the internal buffer, are immediately pushed as * an email. */ if (this.capacity > 0) { this.capacity = -this.capacity; }  //Only need room for one record after closed //Ensure not inside a push. if (size == 0 && data.length != 1) { initLogRecords(1); } } }  if (msg != null) { send(msg, false, ErrorManager.CLOSE_FAILURE); } } catch (final LinkageError JDK8152515) { reportLinkageError(JDK8152515, ErrorManager.CLOSE_FAILURE); } catch (final ServiceConfigurationError sce) { reportConfigurationError(sce, ErrorManager.CLOSE_FAILURE); } }
[*] target: assertFalse(failed)
[-] pred: org. junit. Assert. assertFalse ( failed )
************************************
************************************
[+] input: testHashCode() { final SeverityComparator a = new SeverityComparator(); final SeverityComparator b = new SeverityComparator(); assertNotSame(a, b);  assertTrue(a.equals(b)); assertTrue(b.equals(a));  "<AssertPlaceHolder>"; }
hashCode() { return 31 * getClass().hashCode(); }
[*] target: assertEquals(a.hashCode(), b.hashCode())
[-] pred: org. junit. Assert. assertEquals ( a. hashCode(), b. hashCode() )
************************************
************************************
[+] input: Exception { final SeverityComparator a = new SeverityComparator(); final SeverityComparator b = serialClone(a);  assertTrue(a.equals(b)); assertTrue(b.equals(a));  "<AssertPlaceHolder>"; }
hashCode() { return 31 * getClass().hashCode(); }
[*] target: assertEquals(a.hashCode(), b.hashCode())
[-] pred: org. junit. Assert. assertEquals ( a. hashCode ( ), b. hashCode ( ) )
************************************
************************************
[+] input: IOException { HttpURLConnection connection = Mockito.mock(HttpURLConnection.class); when(connection.getInputStream()).thenReturn(null); when(connection.getOutputStream()).thenReturn(new ByteArrayOutputStream()); when(connection.getResponseCode()).thenReturn(200); try (ResponseInputStream response = HttpClientDefault.request(connection, new byte[0])) { "<AssertPlaceHolder>"; assertEquals(-1, response.read()); assertTrue(response.headers().isEmpty()); } }
request(HttpURLConnection connection, byte[] requestBody) { int responseCode; Map<String, List<String>> responseHeaders; InputStream is; try { if (requestBody != null) { OutputStream out = connection.getOutputStream(); out.write(requestBody); out.flush(); } responseHeaders = connection.getHeaderFields(); responseCode = connection.getResponseCode(); if (isOk(responseCode)) { is = connection.getInputStream(); } else { is = connection.getErrorStream(); } if (is == null) { is = Util.emptyInputStream(); } } catch (IOException e) { try { connection.disconnect(); } catch (Throwable e2) { // ignore } throw new UncheckedIOException(e); } return new ResponseInputStream(connection, responseCode, responseHeaders, is); }
[*] target: assertEquals(200, response.statusCode())
[-] pred: org. junit. Assert. assertEquals ( 200, response. statusCode ( ) )
************************************
************************************
[+] input: Exception { Properties properties = new Properties(); properties.put(DataSourceFactory.JDBC_DATABASE_NAME, "db"); properties.put("currentSchema", "schema"); DataSource dataSource = dataSourceFactory.createDataSource(properties); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dataSource instanceof SimpleDataSource); SimpleDataSource simpleDataSource = (SimpleDataSource) dataSource; Assert.assertEquals("db", simpleDataSource.getDatabaseName()); Assert.assertEquals("schema", simpleDataSource.getCurrentSchema()); }
createDataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); if (props.containsKey(JDBC_INITIAL_POOL_SIZE) || props.containsKey(JDBC_MIN_POOL_SIZE) || props.containsKey(JDBC_MAX_POOL_SIZE) || props.containsKey(JDBC_MAX_IDLE_TIME) || props.containsKey(JDBC_MAX_STATEMENTS)) { return createPoolingDataSource(props); } else { return createSimpleDataSource(props); } }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: Exception { Properties properties = new Properties(); properties.put(DataSourceFactory.JDBC_DATABASE_NAME, "db"); properties.put(DataSourceFactory.JDBC_INITIAL_POOL_SIZE, "5"); properties.put(DataSourceFactory.JDBC_MAX_POOL_SIZE, "10"); DataSource dataSource = dataSourceFactory.createDataSource(properties); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dataSource instanceof PoolingDataSource); PoolingDataSource poolingDataSource = (PoolingDataSource) dataSource; Assert.assertEquals("db", poolingDataSource.getDatabaseName()); Assert.assertEquals(5, poolingDataSource.getInitialConnections()); Assert.assertEquals(10, poolingDataSource.getMaxConnections()); }
createDataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); if (props.containsKey(JDBC_INITIAL_POOL_SIZE) || props.containsKey(JDBC_MIN_POOL_SIZE) || props.containsKey(JDBC_MAX_POOL_SIZE) || props.containsKey(JDBC_MAX_IDLE_TIME) || props.containsKey(JDBC_MAX_STATEMENTS)) { return createPoolingDataSource(props); } else { return createSimpleDataSource(props); } }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: Exception { Properties properties = new Properties(); properties.put(DataSourceFactory.JDBC_DATABASE_NAME, "db"); ConnectionPoolDataSource dataSource = dataSourceFactory.createConnectionPoolDataSource(properties); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dataSource instanceof ConnectionPool); ConnectionPool connectionPoolDataSource = (ConnectionPool) dataSource; Assert.assertEquals("db", connectionPoolDataSource.getDatabaseName()); }
createConnectionPoolDataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); ConnectionPool dataSource = new ConnectionPool(); configureBaseDataSource(dataSource, props); return dataSource; }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: Exception { Properties properties = new Properties(); properties.put(DataSourceFactory.JDBC_DATABASE_NAME, "db"); XADataSource dataSource = dataSourceFactory.createXADataSource(properties); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dataSource instanceof PGXADataSource); PGXADataSource xaDataSource = (PGXADataSource) dataSource; Assert.assertEquals("db", xaDataSource.getDatabaseName()); }
createXADataSource(Properties props) throws SQLException { props = new SingleUseProperties(props); PGXADataSource dataSource = new PGXADataSource(); configureBaseDataSource(dataSource, props); return dataSource; }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: testUpdateActionsFromPaths_basic() { Set<UpdateAction> expectedActions = EnumSet.of(UpdateAction.CLIENT, UpdateAction.FUNCTIONS); List<Path> changedPaths = List.of( Path.of("client/web/src/App.js"), Path.of("functions/onboarding-app-stack-listener/pom.xml")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(changedPaths); "<AssertPlaceHolder>"; actualActions.forEach(action -> { if (action == UpdateAction.FUNCTIONS) { assertEquals(1, action.getTargets().size()); assertEquals(1, UpdateAction.FUNCTIONS.getTargets().size()); assertTrue(action.getTargets().contains("onboarding-app-stack-listener")); } }); }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: testUpdateActionsFromPaths_layersFirst() { Set<UpdateAction> expectedActions = EnumSet.of(UpdateAction.LAYERS, UpdateAction.CLIENT, UpdateAction.FUNCTIONS); List<Path> changedPaths = List.of( Path.of("client/web/src/App.js"), Path.of("functions/onboarding-app-stack-listener/pom.xml"), Path.of("layers/apigw-helper/pom.xml")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(changedPaths); "<AssertPlaceHolder>"; // the first item in the set iterator should always be LAYERS // (meaning we update layers first) regardless of changedPath ordering assertTrue(actualActions.iterator().next().name().equals("LAYERS")); }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: testUpdateActionsFromPaths_customResourcesPath() { Set<UpdateAction> expectedActions = EnumSet.of(UpdateAction.CUSTOM_RESOURCES, UpdateAction.RESOURCES); List<Path> changedPaths = List.of( Path.of("resources/saas-boost.yaml"), Path.of("resources/custom-resources/app-services-macro/pom.xml")); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(changedPaths); "<AssertPlaceHolder>"; actualActions.forEach(action -> { if (action == UpdateAction.RESOURCES) { assertEquals(1, action.getTargets().size()); assertTrue(action.getTargets().contains("saas-boost.yaml")); } if (action == UpdateAction.CUSTOM_RESOURCES) { assertEquals(1, action.getTargets().size()); assertTrue(action.getTargets().contains("app-services-macro")); } }); }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: testUpdateActionsFromPaths_newPath() { Path newResource = Path.of("resources/saas-boost-newtemplate.yaml"); createFile(newResource); Set<UpdateAction> expectedActions = EnumSet.of(UpdateAction.RESOURCES); Collection<UpdateAction> actualActions = updateWorkflow.getUpdateActionsFromPaths(List.of(newResource)); "<AssertPlaceHolder>"; actualActions.forEach(action -> { if (action == UpdateAction.RESOURCES) { assertEquals(1, action.getTargets().size()); assertTrue(action.getTargets().contains("saas-boost-newtemplate.yaml")); } }); }
getUpdateActionsFromPaths(List<Path> changedPaths) { Set<UpdateAction> actions = EnumSet.noneOf(UpdateAction.class);  /* * Take for example the following list of changed paths: *   client/web/src/App.js *   functions/core-stack-listener/src/... *   services/onboarding-service/src/... *   services/tenant-service/src/... *   services/tenant-service/src/... *   resources/saas-boost.yaml *   resources/saas-boost-svc-tenant.yaml *   resources/custom-resources/app-services-ecr-macro/src/... * * The intention of this algorithm is to pull out the high level SaaS Boost components from the Path, as * represented by the UpdateAction Enum. e.g. CLIENT, FUNCTIONS, SERVICES, CUSTOM_RESOURCES, RESOURCES for * the above example, following these steps *   - for each path *     - traverse through each path component, up to a maximum depth of 2 (optimization, since no component *       pathname is at a depth deeper than two) *       - if we find the resources/ path component and the next component is custom-resources, continue *       - otherwise match the path component against an UpdateAction. if we find a valid one, add it to our *         list taking into account not only the UpdateAction itself (e.g. FUNCTIONS) but also the "target" *         of the UpdateAction (e.g. FUNCTIONS -> core-stack-listener) * * So the expected set of UpdateActions resulting from the above example is: *   CLIENT *   FUNCTIONS -> core-stack-listener *   SERVICES -> onboarding-service, tenant-service *   RESOURCES -> saas-boost.yaml, saas-boost-svc-tenant.yaml *   CUSTOM_RESOURCES -> app-services-ecr-macro */ for (Path changedPath : changedPaths) { LOGGER.debug("processing {}", changedPath); Path absolutePath = Path.of(workingDir.toString(), changedPath.toString()); if (!absolutePath.toFile().exists()) { LOGGER.debug("Skipping {} since it doesn't exist", changedPath); continue; } final int maximumTraversalDepth = 2; for (int i = 0; i < Math.min(changedPath.getNameCount(), maximumTraversalDepth); i++) { UpdateAction pathAction = UpdateAction.fromDirectoryName(changedPath.getName(i).toString()); if (pathAction != null) { // edge case: if this is a resources/custom-resources/.. path, we might be pinging on resources/ //            when we should on custom-resources. so skip if it is LOGGER.debug("found action {} from path {}", pathAction, changedPath); if ((i + 1) == changedPath.getNameCount()) { // "this" name at `i` resolved to an UpdateAction, but there is no valid target // represented by the next value in the name. this is an invalid changed path: // a directory itself isn't changed, the files underneath is changed LOGGER.error("Skipping {}, since it's an invalid changed path: expecting a file", changedPath); break; } String target = changedPath.getName(i + 1).toString(); if (pathAction == UpdateAction.RESOURCES && UpdateAction.fromDirectoryName(target) == UpdateAction.CUSTOM_RESOURCES) { LOGGER.debug("Skipping RESOURCES for CUSTOM_RESOURCES in {}", changedPath); continue; } // now add targets if necessary switch (pathAction) { case RESOURCES: { if (target.endsWith(".yaml")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else if (target.endsWith("keycloak/Dockerfile")) { LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); pathAction.addTarget(target); } else { LOGGER.debug("Skipping adding {} to UpdateAction {}", target, pathAction); } break; } case CLIENT: case CUSTOM_RESOURCES: case FUNCTIONS: case LAYERS: case METERING_BILLING: case SERVICES: { // each of the above actions use update.sh to update. the target here needs to be // a directory, because the update workflow looks underneath the target for the update // script. therefore editing something like layers/ parent pom or metering-billing // parent pom is not something worth updating LOGGER.debug("Adding new target {} to UpdateAction {}", target, pathAction); // absolute against workingDir, rather than against running dir Path targetPath = Path.of(workingDir.toString(), changedPath.subpath(0, i + 2).toString()); if (targetPath.toFile().isDirectory()) { // a non-yaml file (e.g. pom.xml) is not an acceptable target, // since there will be no update path underneath it pathAction.addTarget(target); } break; } default: { // do nothing } } if (pathAction.getTargets().size() > 0 && !actions.contains(pathAction)) { LOGGER.debug("Adding new action {} from path {}", pathAction, changedPath); actions.add(pathAction); } break; } } }  return actions; }
[*] target: assertEquals(expectedActions, actualActions)
[-] pred: org. junit. Assert. assertEquals ( expectedActions, actualActions )
************************************
************************************
[+] input: testResourceName() { String serviceName = "foo"; String expected = "foo"; String actual = ApplicationServicesMacro.ecrResourceName(serviceName); assertEquals(expected, actual);  serviceName = "Foo"; expected = "Foo"; actual = ApplicationServicesMacro.ecrResourceName(serviceName); assertEquals(expected, actual);  serviceName = "Foo Bar"; expected = "FooBar"; actual = ApplicationServicesMacro.ecrResourceName(serviceName); assertEquals(expected, actual);  serviceName = "Foo_Bar"; expected = "FooBar"; actual = ApplicationServicesMacro.ecrResourceName(serviceName); assertEquals(expected, actual);  serviceName = "Foo-Bar"; expected = "FooBar"; actual = ApplicationServicesMacro.ecrResourceName(serviceName); "<AssertPlaceHolder>"; }
ecrResourceName(String serviceName) { if (Utils.isBlank(serviceName)) { throw new IllegalArgumentException("service name cannot be blank"); } return cloudFormationResourceName(serviceName); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception {  Set<UserId> all_users = new HashSet<UserId>(); Set<UserId> worker_users = new TreeSet<UserId>(); Integer last_num_users = null; for (var w : this.workers) { AuctionMarkWorker worker = (AuctionMarkWorker) w; assertNotNull(w);  // Get the uninitialized profile AuctionMarkProfile profile = worker.getProfile(); "<AssertPlaceHolder>"; assertTrue(profile.users_per_itemCount.isEmpty());  // Then try to initialize it profile.loadProfile(worker); assertFalse(profile.users_per_itemCount.isEmpty()); int num_users = profile.users_per_itemCount.getSampleCount(); if (last_num_users != null) assertEquals(last_num_users.intValue(), num_users); else { System.err.println("Number of Users: " + num_users); }  worker_users.clear(); for (int i = 0; i < num_users; i++) { UserId user_id = profile.getRandomSellerId(worker.getId()); assertNotNull(user_id); assertFalse( worker.getId() + " -> " + user_id.toString() + " / " + user_id.encode(), all_users.contains(user_id)); worker_users.add(user_id); } // FOR assertFalse(worker_users.isEmpty()); all_users.addAll(worker_users); last_num_users = num_users; } // FOR }
getProfile() { return (this.profile); }
[*] target: assertNotNull(profile)
[-] pred: org. junit. Assert. assertNotNull ( profile )
************************************
************************************
[+] input: Exception { // Test by reading the country table. Table countryTable = this.benchmark.getCatalog().getTable(SEATSConstants.TABLENAME_COUNTRY); String countryFilePath = SEATSBenchmark.getTableDataFilePath(this.benchmark.getDataDir(), countryTable); "<AssertPlaceHolder>"; InputStream countryFile = this.getClass().getResourceAsStream(countryFilePath); assertNotNull(countryFile); }
getDataDir() { return "/benchmarks/" + getBenchmarkName(); }
[*] target: assertNotNull(countryFilePath)
[-] pred: org. junit. Assert. assertNotNull ( countryFilePath )
************************************
************************************
[+] input: testCalculateReturnDate() { for (int return_day : this.return_days) { Timestamp return_flight_date = ReturnFlight.calculateReturnDate(this.flight_date, return_day); "<AssertPlaceHolder>"; assertTrue(this.flight_date.getTime() < return_flight_date.getTime()); } // FOR }
calculateReturnDate(Timestamp flight_date, int return_days) {  // Round this to the start of the day Calendar cal = Calendar.getInstance(); cal.setTimeInMillis( flight_date.getTime() + (return_days * SEATSConstants.MILLISECONDS_PER_DAY));  int year = cal.get(Calendar.YEAR); int month = cal.get(Calendar.MONTH); int day = cal.get(Calendar.DAY_OF_MONTH);  cal.clear(); cal.set(year, month, day); return (new Timestamp(cal.getTime().getTime())); }
[*] target: assertNotNull(return_flight_date)
[-] pred: org. junit. Assert. assertNotNull ( return_flight_date )
************************************
************************************
[+] input: Exception { // Obtained by prepending the rsa-1024 certificate to the PKCS#7 SignedData certificates set // of v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-2048.apk META-INF/CERT.RSA. The certs // (in the order of appearance in the file) are thus: rsa-1024, rsa-2048. The package's // signing cert is rsa-2048. ApkVerifier.Result result = verify("v1-only-pkcs7-cert-bag-first-cert-not-used.apk"); assertVerified(result); List<X509Certificate> signingCerts = result.getSignerCertificates(); "<AssertPlaceHolder>"; assertEquals( "fb5dbd3c669af9fc236c6991e6387b7f11ff0590997f22d0f5c74ff40e04fca8", HexEncoding.encode(sha256(signingCerts.get(0).getEncoded()))); }
getSignerCertificates() { return mSignerCerts; }
[*] target: assertEquals(1, signingCerts.size())
[-] pred: org. junit. Assert. assertEquals ( 1, signingCerts. size ( ) )
************************************
************************************
[+] input: testSaveCell() { long currentTimeStamp = System.currentTimeMillis(); String content = "select 1 as a as output;"; CellInfo cellInfo = new CellInfo(); cellInfo.setNotebookId(Integer.valueOf(defaultMockNotebookId)); cellInfo.setContent(content); cellInfo.setUpdateTime(new Timestamp(currentTimeStamp)); nbService.save(cellInfo); CellInfo savedCellInfo = nbService.getCellInfo(cellInfo.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(Integer.valueOf(defaultMockNotebookId), savedCellInfo.getNotebookId()); Assert.assertEquals(content, savedCellInfo.getContent()); }
getCellInfo(Integer cellId) { return cellInfoRepository.findById(cellId).orElse(null); }
[*] target: assertNotNull(savedCellInfo)
[-] pred: org. junit. Assert. assertNotNull ( savedCellInfo )
************************************
************************************
[+] input: testSaveNotebook() { String newName = "new name"; long currentTimeStamp = System.currentTimeMillis(); NotebookInfo nbInfo = nbService.findById(Integer.valueOf(defaultMockNotebookId)); nbInfo.setName(newName); nbInfo.setUpdateTime(new Timestamp(currentTimeStamp)); nbService.save(nbInfo); NotebookInfo newNotebookInfo = nbService.findById(Integer.valueOf(defaultMockNotebookId)); Assert."<AssertPlaceHolder>"; Assert.assertEquals(newName, newNotebookInfo.getName()); Assert.assertEquals(currentTimeStamp, newNotebookInfo.getUpdateTime().getTime()); }
findById(Integer id) { return notebookRepository.findById(id).orElse(null); }
[*] target: assertNotNull(newNotebookInfo)
[-] pred: org. junit. Assert. assertNotNull ( newNotebookInfo )
************************************
************************************
[+] input: InvalidSPDXAnalysisException { File resultDirectory = Files.createTempDirectory("cdxTest").toFile(); try { String resultFilePath = resultDirectory + File.separator + "resultSpdx.json"; CycloneToSpdx.cycloneDxToSpdx(VALID_BOM_PATH.toString(), resultFilePath); MultiFormatStore store = new MultiFormatStore(new InMemSpdxStore(), Format.JSON_PRETTY, Verbose.COMPACT); String documentUri; try (InputStream is = new FileInputStream(new File(resultFilePath))) { documentUri = store.deSerialize(is, false); } SpdxDocument spdxDoc = new SpdxDocument(store, documentUri, null, false); List<String> verify = spdxDoc.verify(); "<AssertPlaceHolder>"; List<String> expectedDocAttributionPatterns = new ArrayList<>(); assertTrue(spdxDoc.getDocumentUri().contains("3e671687-395b-41f5-a30f-a58921a69b79")); assertTrue(spdxDoc.getDocumentUri().endsWith("_1")); String created = spdxDoc.getCreationInfo().getCreated(); assertTrue(created.startsWith("2020-04-13T20:20:39")); Collection<String> creators = spdxDoc.getCreationInfo().getCreators(); boolean foundTool = false; boolean foundPerson = false; boolean foundOrganization = false; for (String creator:creators) { if (creator.contains("Awesome Tool")) { assertFalse(foundTool); foundTool = true; assertTrue(creator.startsWith("Tool:")); assertTrue(creator.contains("9.1.2")); // Too checksums expectedDocAttributionPatterns.add("25ed8e31b995bb927966616df2a42b979a2717f0"); expectedDocAttributionPatterns.add("a74f733635a19aefb1f73e5947cef59cd7440c6952ef0f03d09d974274cbd6df"); } if (creator.contains("Samantha Wright")) { assertFalse(foundPerson); foundPerson = true; assertTrue(creator.startsWith("Person:")); assertTrue(creator.contains("(samantha.wright@example.com)")); expectedDocAttributionPatterns.add("800-555-1212"); } if (creator.contains("Acme, Inc.")) { assertFalse(foundOrganization); foundOrganization = true; assertTrue(creator.startsWith("Organization: ")); expectedDocAttributionPatterns.add("https://example.com"); expectedDocAttributionPatterns.add("Acme Distribution"); expectedDocAttributionPatterns.add("distribution@example.com"); } } assertTrue(foundTool); assertTrue(foundPerson); assertTrue(foundOrganization); expectedDocAttributionPatterns.add("Acme, Inc."); expectedDocAttributionPatterns.add("Acme Professional Services"); expectedDocAttributionPatterns.add("professional.services@example.com"); assertEquals(1, spdxDoc.getDocumentDescribes().size()); SpdxElement described = spdxDoc.getDocumentDescribes().toArray(new SpdxElement[1])[0]; assertEquals("Acme Application", described.getName().get()); assertTrue(spdxDoc.getName().get().contains("Acme Application")); assertAnnotationsContains(spdxDoc.getAnnotations(), expectedDocAttributionPatterns);  // check on all the packages final List<String> foundComponentNames = new ArrayList<>(); SpdxModelFactory.getElements(spdxDoc.getModelStore(), spdxDoc.getDocumentUri(), spdxDoc.getCopyManager(), SpdxPackage.class).forEach(element -> { try { SpdxPackage pkg = (SpdxPackage)element; foundComponentNames.add(pkg.getName().get()); if ("Acme Application".equals(pkg.getName().get())) { List<String> expectedAnnotations = new ArrayList<>(); expectedAnnotations.add("application".toUpperCase());	// type assertEquals("Person: Acme Super Heros", pkg.getOriginator().get()); /** TODO: Uncomment this out once the SWID external refs are implemented assertEquals("9.1.1", pkg.getVersionInfo().get()); ExternalRef[] externalRefs = pkg.getExternalRefs().toArray(new ExternalRef[pkg.getExternalRefs().size()]); assertEquals(1, externalRefs.length); assertEquals(ListedReferenceTypes.getListedReferenceTypes().getListedReferenceTypeByName("swid"), externalRefs[0].getReferenceType()); assertEquals(ReferenceCategory.SECURITY, externalRefs[0].getReferenceCategory()); assertTrue(externalRefs[0].getReferenceLocator().contains("swidgen-242eb18a-503e-ca37-393b-cf156ef09691_9.1.1")); **/ expectedAnnotations.add("PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiID8"); // part of the SWID content assertAnnotationsContains(pkg.getAnnotations(), expectedAnnotations); } else if ("com.acme:tomcat-catalina".equals(pkg.getName().get())) { List<String> expectedAnnotations = new ArrayList<>(); expectedAnnotations.add("library".toUpperCase());	// type assertTrue(pkg.getOriginator().get().contains("Acme Inc")); assertEquals("9.0.14", pkg.getVersionInfo().get()); if (pkg.getId().contains("npm")) { // There are 3 in the BOM test file with the same name - one has more details assertEquals("e6b1000b94e835ffd37f4c6dcbdad43f4b48a02a", pkg.getSha1()); boolean foundSha1 = false; boolean foundSha512 = false; boolean foundSha256 = false; boolean foundMd5 = false; for (Checksum checksum:pkg.getChecksums()) { if (ChecksumAlgorithm.SHA1.equals(checksum.getAlgorithm())) { assertFalse(foundSha1); foundSha1 = true; assertEquals("e6b1000b94e835ffd37f4c6dcbdad43f4b48a02a", checksum.getValue()); } else if (ChecksumAlgorithm.SHA256.equals(checksum.getAlgorithm())) { assertFalse(foundSha256); foundSha256 = true; assertEquals("f498a8ff2dd007e29c2074f5e4b01a9a01775c3ff3aeaf6906ea503bc5791b7b", checksum.getValue()); } else if (ChecksumAlgorithm.SHA512.equals(checksum.getAlgorithm())) { assertFalse(foundSha512); foundSha512 = true; assertEquals("e8f33e424f3f4ed6db76a482fde1a5298970e442c531729119e37991884bdffab4f9426b7ee11fccd074eeda0634d71697d6f88a460dce0ac8d627a29f7d1282", checksum.getValue()); } else if (ChecksumAlgorithm.MD5.equals(checksum.getAlgorithm())) { assertFalse(foundMd5); foundMd5 = true; assertEquals("3942447fac867ae5cdb3229b658f4d48", checksum.getValue()); } else { fail("Unexpected checksum algorithm"); } } assertTrue(foundSha512); assertTrue(foundSha256); assertTrue(foundSha1); assertTrue(foundMd5); assertEquals("Apache-2.0", pkg.getLicenseDeclared().toString()); ExternalRef[] externalRefs = pkg.getExternalRefs().toArray(new ExternalRef[pkg.getExternalRefs().size()]); assertEquals(1, externalRefs.length); assertEquals(ListedReferenceTypes.getListedReferenceTypes().getListedReferenceTypeByName("purl"), externalRefs[0].getReferenceType()); assertEquals(ReferenceCategory.PACKAGE_MANAGER, externalRefs[0].getReferenceCategory()); assertEquals("pkg:npm/acme/component@1.0.0", externalRefs[0].getReferenceLocator()); Relationship[] relationships = pkg.getRelationships().toArray(new Relationship[pkg.getRelationships().size()]); assertEquals(3, relationships.length); int numAcestors = 0; int numDependencies = 0; for (Relationship relationship:relationships) { SpdxPackage relatedPackage = (SpdxPackage)relationship.getRelatedSpdxElement().get(); assertEquals("com.acme:tomcat-catalina", relatedPackage.getName().get());  assertEquals("9.0.14", relatedPackage.getVersionInfo().get()); if (RelationshipType.ANCESTOR_OF.equals(relationship.getRelationshipType())) { numAcestors++; } else if (RelationshipType.DEPENDS_ON.equals(relationship.getRelationshipType())) { numDependencies++; } else { fail("Unexpected relationship type: "+relationship.getRelationshipType()); } } assertEquals(2, numAcestors); assertEquals(1, numDependencies); expectedAnnotations.add("123"); // commit expectedAnnotations.add("2018-11-13T"); // commit } assertAnnotationsContains(pkg.getAnnotations(), expectedAnnotations); } else if ("org.example:mylibrary".equals(pkg.getName().get())) { List<String> expectedAnnotations = new ArrayList<>(); assertTrue(pkg.getSupplier().get().contains("Example, Inc.")); assertTrue(pkg.getSupplier().get().contains("support@example.com")); expectedAnnotations.add("800-555-1212"); expectedAnnotations.add("Example Support APAC"); expectedAnnotations.add("support@apac.example.com"); assertEquals("Person: Example Super Heros", pkg.getOriginator().get()); expectedAnnotations.add("https://example.com"); expectedAnnotations.add("https://example.net"); assertEquals("1.0.0", pkg.getVersionInfo().get()); assertAnnotationsContains(pkg.getAnnotations(), expectedAnnotations); } else { fail("Unexpected package "+pkg.getName().get()); } } catch (Exception ex) { fail("Exception occurred while processing packages: "+ex.getMessage()); } }); assertEquals(5, foundComponentNames.size()); assertTrue(foundComponentNames.contains("Acme Application")); assertTrue(foundComponentNames.contains("com.acme:tomcat-catalina")); assertTrue(foundComponentNames.contains("org.example:mylibrary")); } finally { deleteDirOrFile(resultDirectory); } }
cycloneDxToSpdx(String cycloneDxFilePath, String spdxFilePath) throws CycloneConversionException { File outFile = new File(spdxFilePath); if (outFile.exists()) { throw new CycloneConversionException("File "+spdxFilePath+" already exists."); } try { if (!outFile.createNewFile()) { throw new CycloneConversionException("Could not create output file "+spdxFilePath); } } catch (IOException e) { throw new CycloneConversionException("I/O Error creating output file "+spdxFilePath, e); } ISerializableModelStore modelStore = null; try { modelStore = fileTypeToStore(fileToFileType(outFile)); } catch (InvalidSPDXAnalysisException e) { throw new CycloneConversionException("Unable to create SPDX model store: "+e.getMessage(), e); } catch (org.spdx.cdx2spdx.InvalidFileNameException e) { throw new CycloneConversionException("Cyclone DX Parsing Exception: "+e.getMessage(), e); } File inFile = new File(cycloneDxFilePath); if (!inFile.exists()) { throw new CycloneConversionException("File "+cycloneDxFilePath+" does not exist."); } Bom cycloneBom = null; try { Parser cycloneParser = BomParserFactory.createParser(inFile); cycloneBom = cycloneParser.parse(inFile); } catch (ParseException e) { throw new CycloneConversionException("Error creating Cyclone parser:"+e.getMessage()); } CycloneSpdxConverter converter = new CycloneSpdxConverter(cycloneBom, modelStore); converter.convert(); try (FileOutputStream output = new FileOutputStream(outFile)) { modelStore.serialize(converter.getDocumentUri(), output); return converter.getWarnings(); } catch (FileNotFoundException e) { throw new CycloneConversionException("Output file "+spdxFilePath+" not found.", e); } catch (IOException e) { throw new CycloneConversionException("I/O error writing output file:"+e.getMessage(), e); } catch (InvalidSPDXAnalysisException e) { throw new CycloneConversionException("SPDX error creating output file:"+e.getMessage(), e); } }
[*] target: assertEquals(0, verify.size())
[-] pred: org. junit. Assert. assertEquals ( 0, verify. size ( ) )
************************************
************************************
[+] input: testUpdateEventOffset() { List<Map<String, Object>> rows = offset.queryEventOffset().join(); rows.forEach(map -> { Long id = (Long) map.get("id"); Long offset_id = (Long) map.get("event_offset_id"); String dataSourceName = (String) map.get("data_source_name"); boolean status = offset.updateEventOffset(dataSourceName, offset_id + 1, id).join(); Assert.assertTrue(status); boolean status2 = offset.updateEventOffset(dataSourceName, offset_id, id).join(); Assert."<AssertPlaceHolder>"; });  }
updateEventOffset(String dataSourceName, long offsetId, long id) { try { DataSource dataSource = dataSourceNameMap.get(dataSourceName); QueryRunner queryRunner = new QueryRunner(dataSource); queryRunner.update(UPDATE_EVENT_OFFSET, offsetId, id); return CompletableFuture.completedFuture(true); } catch (Throwable e) { CompletableFuture<Boolean> future = new CompletableFuture<>(); future.completeExceptionally(e); return future; } }
[*] target: assertTrue(status2)
[-] pred: org. junit. Assert. assertTrue ( status2 )
************************************
************************************
[+] input: verifyEmailTokenSuccessFull() { ChangeEmailRequest changeEmailRequest = getDummyChangeEmailRequest(); User user = getDummyUser(); String expectedMessage = UserMessage.EMAIL_CHANGE_SUCCESSFUL; ChangeEmailForm changeEmailForm = getDummyChangeEmailForm(); changeEmailForm.setNew_email(changeEmailForm.getNew_email()); changeEmailForm.setOld_email("user@email.com"); Mockito.when(changeEmailRepository.findByEmailToken(Mockito.anyString())) .thenReturn(changeEmailRequest); Mockito.doReturn(user).when(userRepository).save(Mockito.any(User.class)); Mockito.doReturn(user).when(userService).getUserFromToken(Mockito.any()); CRAPIResponse crapiAPIResponse = userService.verifyEmailToken(getMockHttpRequest(), changeEmailForm); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(HttpStatus.OK.value(), crapiAPIResponse.getStatus()); }*/
verifyEmailToken( HttpServletRequest request, ChangeEmailForm changeEmailForm) { ChangeEmailRequest changeEmailRequest; User user; changeEmailRequest = changeEmailRepository.findByEmailToken(changeEmailForm.getToken()); user = getUserFromToken(request); if (changeEmailRequest != null) { if (user.getEmail().equalsIgnoreCase(changeEmailRequest.getOldEmail())) { if (changeEmailRequest.getNewEmail().equalsIgnoreCase(changeEmailForm.getNew_email())) { user.setEmail(changeEmailRequest.getNewEmail()); user.setJwtToken(""); userRepository.save(user); return new CRAPIResponse(UserMessage.EMAIL_CHANGE_SUCCESSFUL, 200); } else { return new CRAPIResponse(UserMessage.NEW_MAIL_DOES_NOT_BELONG, 500); } } else { return new CRAPIResponse(UserMessage.OLD_MAIL_DOES_NOT_BELONG, 500); } } return new CRAPIResponse(UserMessage.INVALID_EMAIL_TOKEN, 500); }
[*] target: assertEquals(expectedMessage, crapiAPIResponse.getMessage())
[-] pred: org. junit. Assert. assertEquals ( expectedMessage, crapiAPIResponse. getMessage ( ) )
************************************
************************************
[+] input: getVehicleLocationSuccessWithUserDetailsNotNull() { VehicleDetails vehicleDetails = getDummyVehicleDetails(); UserDetails userDetails = getDummyUserDetails(); Mockito.when(vehicleDetailsRepository.findByUuid(vehicleDetails.getUuid())) .thenReturn(vehicleDetails); Mockito.when(userDetailsRepository.findByUser_id(Mockito.anyLong())).thenReturn(userDetails); VehicleLocationResponse vehicleLocationResponse = vehicleService.getVehicleLocation(vehicleDetails.getUuid()); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(userDetails.getName(), vehicleLocationResponse.getFullName()); Assertions.assertEquals(userDetails.getUser().getEmail(), vehicleLocationResponse.getEmail()); }
getVehicleLocation(UUID carId) { VehicleDetails vehicleDetails = null; VehicleLocationResponse vehicleLocationForm = null; UserDetails userDetails = null; Random random = new Random(); try { vehicleDetails = vehicleDetailsRepository.findByUuid(carId); if (vehicleDetails != null) { // vehicleDetails = vehicleDetailsRepository.findByVehicleLocation_id(carId); // vehicleDetails.setVehicleLocation(getVehicleLocationList().get(random.nextInt(getVehicleLocationList().size()))); if (vehicleDetails.getOwner() != null) { userDetails = userDetailsRepository.findByUser_id(vehicleDetails.getOwner().getId()); vehicleLocationForm = new VehicleLocationResponse( carId, (userDetails != null ? userDetails.getName() : null), (userDetails != null ? userDetails.getUser().getEmail() : null), vehicleDetails.getVehicleLocation()); return vehicleLocationForm; } } } catch (Exception exception) { log.error("Fail to get vehicle location-> Message: {}", exception); } return null; }
[*] target: assertNotNull(vehicleLocationResponse)
[-] pred: org. junit. Assert. assertNotNull ( vehicleLocationResponse )
************************************
************************************
[+] input: UnsupportedEncodingException { SnappyRpcCompressor compressor = new SnappyRpcCompressor(); String s = "xxxxasdasdasd0as8d0asdkmasldjalsd"; byte[] bs = compressor.compress(s.getBytes("utf-8")); Assert.assertNotNull(s);  String s1 = new String(compressor.deCompress(bs), "utf-8"); Assert."<AssertPlaceHolder>"; }
deCompress(byte[] src) { return uncompress(src, 0, src.length); }
[*] target: assertEquals(s, s1)
[-] pred: org. junit. Assert. assertEquals ( s, s1 )
************************************
************************************
[+] input: InterruptedException { ScheduledService scheduledService = new ScheduledService("ttt", 12345, new Runnable() { @Override public void run() { count.incrementAndGet(); } }, 0, 100, TimeUnit.MILLISECONDS); scheduledService.start(); Assert.assertFalse(scheduledService.isStarted());  scheduledService = new ScheduledService("ttt", ScheduledService.MODE_FIXEDRATE, new Runnable() { @Override public void run() { count.incrementAndGet(); } }, 0, 100, TimeUnit.MILLISECONDS); scheduledService.start(); Assert.assertTrue(scheduledService.isStarted()); scheduledService.start(); Assert.assertTrue(scheduledService.isStarted()); Thread.sleep(300); Assert.assertTrue(count.get() > 0);  ScheduledService.reset(); Assert.assertTrue(scheduledService.isStarted()); Assert.assertFalse(ScheduledService.isResetting());  scheduledService.shutdown(); Assert.assertFalse(scheduledService.isStarted()); scheduledService.stop(); Assert."<AssertPlaceHolder>"; }
isStarted() { return started; }
[*] target: assertFalse(scheduledService.isStarted())
[-] pred: org. junit. Assert. assertFalse ( scheduledService. isStarted() )
************************************
************************************
[+] input: testEquals() { ServerConfig config1 = new ServerConfig(); Assert.assertTrue(config1.equals(config1)); Assert.assertFalse(config1.equals(null)); Assert.assertFalse(config1.equals(""));  ServerConfig config2 = new ServerConfig(); Assert.assertTrue(config1.equals(config2));  config1.setHost("127.0.0.1"); Assert.assertFalse(config1.equals(config2)); config2.setHost("127.0.0.2"); Assert.assertFalse(config1.equals(config2)); config2.setHost("127.0.0.1"); Assert.assertTrue(config1.equals(config2));  config1.setPort(1234); Assert.assertFalse(config1.equals(config2)); config2.setPort(1235); Assert.assertFalse(config1.equals(config2)); config2.setPort(1234); Assert.assertTrue(config1.equals(config2));  config1.setProtocol("xxx"); Assert.assertFalse(config1.equals(config2)); config2.setProtocol("yyy"); Assert.assertFalse(config1.equals(config2)); config2.setProtocol("xxx"); Assert."<AssertPlaceHolder>"; }
equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } ServerConfig other = (ServerConfig) obj; if (host == null) { if (other.host != null) { return false; } } else if (!host.equals(other.host)) { return false; } if (port != other.port) { return false; } if (protocol == null) { if (other.protocol != null) { return false; } } else if (!protocol.equals(other.protocol)) { return false; } return true; }
[*] target: assertTrue(config1.equals(config2))
[-] pred: org. junit. Assert. assertTrue ( config1. equals ( config2 ) )
************************************
************************************
[+] input: testAll() {  ClientTransportConfig config = new ClientTransportConfig(); config.setProviderInfo(ProviderHelper.toProviderInfo("127.0.0.1")); config.setContainer("xxx"); config.setChannelListeners(Collections.<ChannelListener> singletonList(new ChannelListener() { @Override public void onConnected(AbstractChannel channel) {  }  @Override public void onDisconnected(AbstractChannel channel) {  } })); config.setConnectionNum(22); config.setConnectTimeout(3333); config.setConsumerConfig(new ConsumerConfig()); config.setDisconnectTimeout(4444); config.setInvokeTimeout(5555); config.setPayload(666666); config.setUseEpoll(true);  Assert.assertNotNull(config.getConsumerConfig()); Assert.assertNotNull(config.getProviderInfo()); Assert.assertNotNull(config.getChannelListeners()); Assert.assertEquals("xxx", config.getContainer()); Assert.assertEquals(22, config.getConnectionNum()); Assert.assertEquals(3333, config.getConnectTimeout()); Assert.assertEquals(4444, config.getDisconnectTimeout()); Assert.assertEquals(5555, config.getInvokeTimeout()); Assert.assertEquals(666666, config.getPayload()); Assert."<AssertPlaceHolder>"; }
isUseEpoll() { return useEpoll; }
[*] target: assertTrue(config.isUseEpoll())
[-] pred: org. junit. Assert. assertTrue ( config. isUseEpoll() )
************************************
************************************
[+] input: Exception { ServerTransportConfig config = new ServerTransportConfig(); config.setHost("0.0.0.0"); config.setPort(22222); config.setBossThreads(1); config.setIoThreads(8); config.setBizMaxThreads(200); config.setBizPoolQueues(50); config.setDaemon(false); config.setContainer("test"); ServerTransport server = ServerTransportFactory.getServerTransport(config); Assert.assertNotNull(server);  boolean error = false; try { config.setContainer("testasdasd"); ServerTransportFactory.getServerTransport(config); } catch (Exception e) { error = true; } Assert."<AssertPlaceHolder>"; }
getServerTransport(ServerTransportConfig serverConfig) { ServerTransport serverTransport = ExtensionLoaderFactory.getExtensionLoader(ServerTransport.class) .getExtension(serverConfig.getContainer(), new Class[] { ServerTransportConfig.class }, new Object[] { serverConfig }); if (serverTransport != null) { String key = Integer.toString(serverConfig.getPort()); SERVER_TRANSPORT_MAP.put(key, serverTransport); } return serverTransport; }
[*] target: assertTrue(error)
[-] pred: org. junit. Assert. assertTrue ( error )
************************************
************************************
[+] input: testDeserializeWithComment() {  String s = "{" + ""a": null, // 111\n" + "        "b":1, /*2   // asdsad / das */\n" + "        "c":1, /*2   // asdsad \n \r / das */\n" + "        "d":9999999999" + "}"; LOGGER.info(s); Map json = (Map) JSONSerializer.deserialize(s); Assert."<AssertPlaceHolder>"; Assert.assertEquals(json.get("a"), null); Assert.assertEquals(json.get("b"), 1); Assert.assertEquals(json.get("c"), 1); Assert.assertEquals(json.get("d"), 9999999999l); }
deserialize(String json) throws ParseException { // 去掉注释 return new JSONSerializer(json).nextValue(); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: Exception { List<String> s1 = Arrays.asList("111", "222", "333"); List<String> s2 = Arrays.asList("111", "333", "444", "555", "666");  ListDifference difference = new ListDifference(s1, s2); Assert.assertFalse(difference.areEqual());  List<String> add = difference.getOnlyOnRight(); List<String> removed = difference.getOnlyOnLeft(); List<String> same = difference.getOnBoth();  Assert.assertEquals(add.size(), 3); Assert.assertEquals(removed.size(), 1); Assert.assertEquals(same.size(), 2);  Assert.assertEquals(add.get(0), "444"); Assert.assertEquals(removed.get(0), "222");  s1 = Arrays.asList("111", "222", "333"); s2 = Arrays.asList("111", "333", "222");  difference = new ListDifference(s1, s2); Assert.assertTrue(difference.areEqual());  add = difference.getOnlyOnRight(); removed = difference.getOnlyOnLeft(); same = difference.getOnBoth();  Assert.assertEquals(add.size(), 0); Assert.assertEquals(removed.size(), 0); Assert.assertEquals(same.size(), 3);  s1 = new ArrayList<String>(); s2 = Arrays.asList(); difference = new ListDifference(s1, s2); Assert.assertTrue(difference.areEqual());  s1 = null; s2 = Arrays.asList(); difference = new ListDifference(s1, s2); Assert.assertTrue(difference.areEqual());  s1 = Collections.emptyList(); s2 = null; difference = new ListDifference(s1, s2); Assert."<AssertPlaceHolder>"; }
areEqual() { return onlyOnLeft.isEmpty() && onlyOnRight.isEmpty(); }
[*] target: assertTrue(difference.areEqual())
[-] pred: org. junit. Assert. assertTrue ( difference. areEqual ( ) )
************************************
************************************
[+] input: Exception { SofaRpcException exception = new SofaRpcException(RpcErrorType.SERVER_BUSY, "111"); String string = ExceptionUtils.toString(exception); Assert."<AssertPlaceHolder>"; Pattern pattern = Pattern.compile("at"); Matcher matcher = pattern.matcher(string); int count = 0; while (matcher.find()) { count++; } Assert.assertTrue(count > 1); }
toString(Throwable e) { StackTraceElement[] traces = e.getStackTrace(); StringBuilder sb = new StringBuilder(1024); sb.append(e.toString()).append("\n"); if (traces != null) { for (StackTraceElement trace : traces) { sb.append("\tat ").append(trace).append("\n"); } } return sb.toString(); }
[*] target: assertNotNull(string)
[-] pred: org. junit. Assert. assertNotNull ( string )
************************************
************************************
[+] input: Exception { SofaRpcException exception = new SofaRpcException(RpcErrorType.SERVER_BUSY, "111"); String string = ExceptionUtils.toShortString(exception, 1); Assert."<AssertPlaceHolder>"; Pattern pattern = Pattern.compile("at"); Matcher matcher = pattern.matcher(string); int count = 0; while (matcher.find()) { count++; } Assert.assertTrue(count == 1); }
toShortString(Throwable e, int stackLevel) { StackTraceElement[] traces = e.getStackTrace(); StringBuilder sb = new StringBuilder(1024); sb.append(e.toString()).append("\t"); if (traces != null) { for (int i = 0; i < traces.length; i++) { if (i < stackLevel) { sb.append("\tat ").append(traces[i]).append("\t"); } else { break; } } } return sb.toString(); }
[*] target: assertNotNull(string)
[-] pred: org. junit. Assert. assertNotNull ( string )
************************************
************************************
[+] input: InterruptedException { ProviderConfig<?> providerConfig = providerConfig("consul-test-1", 12200); registry.register(providerConfig);  ConsumerConfig<?> consumerConfig = consumerConfig("consul-test-1"); MockProviderInfoListener listener = new MockProviderInfoListener(); consumerConfig.setProviderInfoListener(listener);  assertUntil(() -> { List<ProviderGroup> providerGroups = registry.subscribe(consumerConfig); Assert.assertEquals(1, providerGroups.size()); Assert.assertEquals(1, providerGroups.get(0).size()); }, 10, TimeUnit.SECONDS);  CountDownLatch latch = new CountDownLatch(1); listener.setCountDownLatch(latch);  providerConfig = providerConfig("consul-test-1", 12201, 12202); registry.register(providerConfig);  boolean ok = latch.await(10, TimeUnit.SECONDS); Assert.assertTrue(ok);  assertUntil(() -> { Map<String, ProviderInfo> providers = listener.getData(); Assert.assertEquals(3, providers.size()); }, 10, TimeUnit.SECONDS);  latch = new CountDownLatch(1); listener.setCountDownLatch(latch);  registry.unRegister(providerConfig);  ok = latch.await(10, TimeUnit.SECONDS); Assert."<AssertPlaceHolder>";  assertUntil(() -> { Map<String, ProviderInfo> providers = listener.getData(); Assert.assertEquals(1, providers.size()); }, 10, TimeUnit.SECONDS); }
unRegister(ProviderConfig config) { String appName = config.getAppName();  if (!registryConfig.isRegister()) { // 注册中心不注册 if (LOGGER.isInfoEnabled(appName)) { LOGGER.infoWithApp(appName, LogCodes.getLog(LogCodes.INFO_REGISTRY_IGNORE)); } return; } // 反注册服务端节点 if (!config.isRegister()) { return; } try { List<String> ids = buildServiceIds(config); if (CommonUtils.isNotEmpty(ids)) { ids.forEach(this::deregisterConsulService); if (LOGGER.isInfoEnabled(appName)) { LOGGER.infoWithApp(appName, LogCodes.getLog(LogCodes.INFO_ROUTE_REGISTRY_UNPUB, config.getInterfaceId(), ids.size())); } } } catch (Exception e) { if (!RpcRunningState.isShuttingDown()) { if ( e instanceof SofaRpcRuntimeException){ throw e; }else{ throw new SofaRpcRuntimeException(LogCodes.getLog(LogCodes.ERROR_UNREG_PROVIDER ,EXT_NAME), e); }} } }
[*] target: assertTrue(ok)
[-] pred: org. junit. Assert. assertTrue ( ok )
************************************
************************************
[+] input: testLoadFile() { ServerConfig serverConfig = new ServerConfig() .setProtocol("bolt") .setHost("0.0.0.0") .setPort(12200);  ProviderConfig<?> provider = new ProviderConfig(); provider.setInterfaceId("com.alipay.xxx.TestService") .setUniqueId("unique123Id") .setRegister(true) .setRegistry(registryConfig) .setServer(serverConfig);  registry.register(provider); registry.destroy();  // registry 关闭，但是 provider 信息保存到本地 Assert.assertTrue(new File(file).exists());  // 创建一个新的 localRegistry，会立即加载到缓存 RegistryConfig newRegistryConfig = new RegistryConfig() .setProtocol("local") //.setParameter("registry.local.scan.period", "1000") .setSubscribe(true) .setFile(file) .setRegister(true);  LocalRegistry newRegistry = (LocalRegistry) RegistryFactory.getRegistry(newRegistryConfig);  newRegistry.init(); Assert.assertFalse(newRegistry.memoryCache.isEmpty());  // consumer 订阅时应该能立刻读到数据 ConsumerConfig<?> consumer = new ConsumerConfig(); consumer.setInterfaceId("com.alipay.xxx.TestService") .setUniqueId("unique123Id") .setRegistry(registryConfig) .setSubscribe(true);  List<ProviderGroup> subscribe = newRegistry.subscribe(consumer); Assert."<AssertPlaceHolder>"; Assert.assertFalse(subscribe.get(0).getProviderInfos().isEmpty()); }
subscribe(ConsumerConfig config) { String key = LocalRegistryHelper.buildListDataId(config, config.getProtocol()); List<ConsumerConfig> listeners = notifyListeners.get(key); if (listeners == null) { listeners = new ArrayList<ConsumerConfig>(); notifyListeners.put(key, listeners); } listeners.add(config); // 返回已经加载到内存的列表（可能不是最新的) ProviderGroup group = memoryCache.get(key); if (group == null) { group = new ProviderGroup(); memoryCache.put(key, group); }  if (EventBus.isEnable(ConsumerSubEvent.class)) { ConsumerSubEvent event = new ConsumerSubEvent(config); EventBus.post(event); }  return Collections.singletonList(group); }
[*] target: assertFalse(subscribe.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( subscribe. isEmpty ( ) )
************************************
************************************
[+] input: testAllocPartPersist() { diskSpaceManager = getDiskSpaceManager(); diskSpaceManager.allocPart(); diskSpaceManager.close(); diskSpaceManager = getDiskSpaceManager(); int partNum = diskSpaceManager.allocPart(); diskSpaceManager.close();  "<AssertPlaceHolder>"; assertTrue(managerRoot.resolve("1").toFile().exists()); assertEquals(DiskSpaceManager.PAGE_SIZE, managerRoot.resolve("0").toFile().length()); }
close();  /** * Allocates a new partition. * * @return partition number of new partition */ int allocPart();  /** * Allocates a new partition with a specific partition number. * * @param partNum partition number of new partition * @return partition number of new partition */ int allocPart(int partNum);  /** * Releases a partition from use.  * @param partNum partition number to be released */ void freePart(int partNum);  /** * Allocates a new page. * @param partNum partition to allocate new page under * @return virtual page number of new page */ long allocPage(int partNum);  /** * Allocates a new page with a specific page number. * @param pageNum page number of new page * @return virtual page number of new page */ long allocPage(long pageNum);  /** * Frees a page. The page cannot be used after this call. * @param page virtual page number of page to be released */ void freePage(long page);  /** * Reads a page. * * @param page number of page to be read * @param buf byte buffer whose contents will be filled with page data */ void readPage(long page, byte[] buf);  /** * Writes to a page. * * @param page number of page to be read * @param buf byte buffer that contains the new page data */ void writePage(long page, byte[] buf);  /** * Checks if a page is allocated * * @param page number of page to check * @return true if the page is allocated, false otherwise */ boolean pageAllocated(long page);  /** * Gets partition number from virtual page number * @param page virtual page number * @return partition number */ static int getPartNum(long page) { return (int) (page / 10000000000L); }
[*] target: assertEquals(1, partNum)
[-] pred: org. junit. Assert. assertEquals ( 1, partNum )
************************************
************************************
[+] input: testReload() { int partNum = diskSpaceManager.allocPart(1);  byte[] expected = new byte[] { (byte) 0xDE, (byte) 0xAD, (byte) 0xBE, (byte) 0xEF }; byte[] actual = new byte[4];  BufferFrame frame1 = bufferManager.fetchNewPageFrame(partNum); frame1.writeBytes((short) 67, (short) 4, expected); frame1.unpin();  // force a eviction bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin();  assertFalse(frame1.isValid());  // reload page frame1 = bufferManager.fetchPageFrame(frame1.getPageNum()); frame1.readBytes((short) 67, (short) 4, actual); frame1.unpin();  "<AssertPlaceHolder>"; }
unpin() { super.unpin(); this.frameLock.unlock(); }
[*] target: assertArrayEquals(expected, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expected, actual )
************************************
************************************
[+] input: testRequestValidFrame() { int partNum = diskSpaceManager.allocPart(1);  byte[] expected = new byte[] { (byte) 0xDE, (byte) 0xAD, (byte) 0xBE, (byte) 0xEF }; byte[] actual = new byte[4];  BufferFrame frame1 = bufferManager.fetchNewPageFrame(partNum); frame1.writeBytes((short) 67, (short) 4, expected); frame1.unpin();  assertSame(frame1, frame1.requestValidFrame()); frame1.unpin();  // force a eviction bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin(); bufferManager.fetchNewPageFrame(partNum).unpin();  assertFalse(frame1.isValid());  BufferFrame frame2 = frame1.requestValidFrame(); assertNotSame(frame1, frame2); frame2.readBytes((short) 67, (short) 4, actual); frame2.unpin();  "<AssertPlaceHolder>"; }
unpin() { super.unpin(); this.frameLock.unlock(); }
[*] target: assertArrayEquals(expected, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expected, actual )
************************************
************************************
[+] input: testFreePart() { int partNum1 = diskSpaceManager.allocPart(1); int partNum2 = diskSpaceManager.allocPart(2);  BufferFrame frame1 = bufferManager.fetchNewPageFrame(partNum1); BufferFrame frame2 = bufferManager.fetchNewPageFrame(partNum2); BufferFrame frame3 = bufferManager.fetchNewPageFrame(partNum1); BufferFrame frame4 = bufferManager.fetchNewPageFrame(partNum2); BufferFrame frame5 = bufferManager.fetchNewPageFrame(partNum2);  frame1.unpin(); frame2.unpin(); frame3.unpin(); frame4.unpin(); frame5.unpin();  bufferManager.freePart(partNum1);  try { diskSpaceManager.readPage(frame1.getPageNum(), new byte[DiskSpaceManager.PAGE_SIZE]); fail(); } catch (Exception e) { /* do nothing */ } try { diskSpaceManager.readPage(frame3.getPageNum(), new byte[DiskSpaceManager.PAGE_SIZE]); fail(); } catch (Exception e) { /* do nothing */ } try { diskSpaceManager.allocPage(partNum1); fail(); } catch (Exception e) { /* do nothing */ }  BufferFrame frame6  = bufferManager.fetchNewPageFrame(partNum2); BufferFrame frame7  = bufferManager.fetchNewPageFrame(partNum2); frame6.unpin(); frame7.unpin(); assertFalse(frame1.isValid()); assertTrue(frame2.isValid()); assertFalse(frame3.isValid()); assertTrue(frame4.isValid()); assertTrue(frame5.isValid()); assertTrue(frame6.isValid()); "<AssertPlaceHolder>"; }
isValid() { return this.index >= 0; }
[*] target: assertTrue(frame7.isValid())
[-] pred: org. junit. Assert. assertTrue ( frame7. isValid() )
************************************
************************************
[+] input: testMultiPageScan() { for (int i = 0; i < 10000; ++i) { logManager.appendToLog(new MasterLogRecord(i)); }  Iterator<LogRecord> iter = logManager.scanFrom(90000); for (int i = 9 * (DiskSpaceManager.PAGE_SIZE / 9); i < 10000; ++i) { assertEquals(new MasterLogRecord(i), iter.next()); } "<AssertPlaceHolder>"; }
hasNext() { return nextIter != null; }
[*] target: assertFalse(iter.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iter. hasNext() )
************************************
************************************
[+] input: testRewriteMasterRecord() { for (int i = 0; i < 1000; ++i) { logManager.appendToLog(new MasterLogRecord(i)); } logManager.rewriteMasterRecord(new MasterLogRecord(77)); logManager.rewriteMasterRecord(new MasterLogRecord(999)); logManager.rewriteMasterRecord(new MasterLogRecord(-1));  Iterator<LogRecord> iter = logManager.iterator(); assertEquals(new MasterLogRecord(-1), iter.next()); for (int i = 1; i < 1000; ++i) { assertEquals(new MasterLogRecord(i), iter.next()); } "<AssertPlaceHolder>"; }
hasNext() { return nextIter != null; }
[*] target: assertFalse(iter.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iter. hasNext() )
************************************
************************************
[+] input: shouldReturnTheSameBuilderWithoutSettingFieldIfNullPassed() { Descriptors.FieldDescriptor fieldDescriptor = TestBookingLogMessage.getDescriptor().findFieldByName("order_number"); MessageHandler messageHandler = new MessageHandler(fieldDescriptor); DynamicMessage.Builder builder = DynamicMessage.newBuilder(fieldDescriptor.getContainingType());  DynamicMessage.Builder outputBuilder = messageHandler.transformToProtoBuilder(builder, null); "<AssertPlaceHolder>"; assertEquals("", outputBuilder.getField(fieldDescriptor)); }
transformToProtoBuilder(Builder builder, Object field) { if (!canHandle() || field == null) { return builder; }  Builder elementBuilder = DynamicMessage.newBuilder(fieldDescriptor.getMessageType()); List<FieldDescriptor> nestedFieldDescriptors = fieldDescriptor.getMessageType().getFields(); Row rowElement = (Row) field;  for (FieldDescriptor nestedFieldDescriptor : nestedFieldDescriptors) { int index = nestedFieldDescriptor.getIndex(); if (index < rowElement.getArity()) { TypeHandler typeHandler = TypeHandlerFactory.getTypeHandler(nestedFieldDescriptor); if (rowElement.getField(index) != null) { typeHandler.transformToProtoBuilder(elementBuilder, rowElement.getField(index)); } } }  return builder.setField(fieldDescriptor, elementBuilder.build()); }
[*] target: assertEquals(builder, outputBuilder)
[-] pred: org. junit. Assert. assertEquals ( builder, outputBuilder )
************************************
************************************
[+] input: shouldReturnParentPostProcessor() { when(configuration.getString(Constants.FLINK_SQL_QUERY_KEY, Constants.FLINK_SQL_QUERY_DEFAULT)).thenReturn("test-sql"); when(configuration.getBoolean(Constants.PROCESSOR_POSTPROCESSOR_ENABLE_KEY, Constants.PROCESSOR_POSTPROCESSOR_ENABLE_DEFAULT)).thenReturn(true);  List<PostProcessor> postProcessors = PostProcessorFactory.getPostProcessors(daggerContext, stencilClientOrchestrator, columnNames, metricsTelemetryExporter);  "<AssertPlaceHolder>"; assertEquals(ParentPostProcessor.class, postProcessors.get(0).getClass()); }
getPostProcessors(DaggerContext daggerContext, StencilClientOrchestrator stencilClientOrchestrator, String[] columnNames, MetricsTelemetryExporter metricsTelemetryExporter) { List<PostProcessor> postProcessors = new ArrayList<>();  if (Arrays.stream(columnNames).anyMatch(s -> Pattern.compile(".*\\blongbow.*key\\b.*").matcher(s).find())) { postProcessors.add(getLongBowProcessor(columnNames, daggerContext.getConfiguration(), metricsTelemetryExporter, stencilClientOrchestrator)); } if (daggerContext.getConfiguration().getBoolean(Constants.PROCESSOR_POSTPROCESSOR_ENABLE_KEY, Constants.PROCESSOR_POSTPROCESSOR_ENABLE_DEFAULT)) { postProcessors.add(new ParentPostProcessor(daggerContext, stencilClientOrchestrator, metricsTelemetryExporter)); } if (daggerContext.getConfiguration().getBoolean(Constants.METRIC_TELEMETRY_ENABLE_KEY, Constants.METRIC_TELEMETRY_ENABLE_VALUE_DEFAULT)) { postProcessors.add(new TelemetryProcessor(metricsTelemetryExporter)); } return postProcessors; }
[*] target: assertEquals(1, postProcessors.size())
[-] pred: org. junit. Assert. assertEquals ( 1, postProcessors. size ( ) )
************************************
************************************
[+] input: shouldReturnNullIfPythonFilesConfigIsNotGiven() { String pythonJsonConfig = "{"PYTHON_FN_EXECUTION_ARROW_BATCH_SIZE": "10000", "PYTHON_FN_EXECUTION_BUNDLE_SIZE": "100000", "PYTHON_FN_EXECUTION_BUNDLE_TIME": "1000"}";  when(configuration.getString(Constants.PYTHON_UDF_CONFIG, "")).thenReturn(pythonJsonConfig); PythonUdfConfig pythonUdfConfig = PythonUdfConfig.parse(configuration);  Assert.assertNull(pythonUdfConfig.getPythonFiles()); Assert."<AssertPlaceHolder>"; Assert.assertNull(pythonUdfConfig.getPythonRequirements()); }
getPythonArchives() { if (pythonArchives != null) { return pythonArchives.replaceAll("\\s+", ""); } return null; }
[*] target: assertNull(pythonUdfConfig.getPythonArchives())
[-] pred: org. junit. Assert. assertNull ( pythonUdfConfig. getPythonArchives ( ) )
************************************
************************************
[+] input: testGetResourceToFile() { // 测试getResourceToFile方法是否能正确地将资源文件复制到指定的文件路径  //获取临时文件路径 String tempDirectoryPath = org.apache.commons.io.FileUtils.getTempDirectoryPath();  String resourceName = "iast.properties.example"; // 假设存在名为test_resource.txt的资源文件 String fileName = tempDirectoryPath + "test.example"; // 替换为实际的目标文件路径  boolean result; try { result = FileUtils.getResourceToFile(resourceName, fileName); } catch (IOException e) { throw new RuntimeException(e); }  Assert."<AssertPlaceHolder>"; // 验证复制操作是否成功  // 验证目标文件是否存在 java.io.File targetFile = new java.io.File(fileName); Assert.assertTrue(targetFile.exists());  // 清理测试产生的文件 targetFile.delete(); }
getResourceToFile(String resourceName, String fileName) throws IOException { File targetFile = new File(fileName);  if (!targetFile.exists()) { if (!targetFile.getParentFile().exists()) { if (!targetFile.getParentFile().mkdirs()) { DongTaiLog.error(ErrorCode.AGENT_GET_RESOURCE_TO_FILE_FAILED, resourceName, fileName, "mkdirs"); } } if (!targetFile.createNewFile()) { DongTaiLog.error(ErrorCode.AGENT_GET_RESOURCE_TO_FILE_FAILED, resourceName, fileName, "createNewFile"); } }  try { InputStream is = FileUtils.class.getClassLoader().getResourceAsStream(resourceName); if (is == null) { return false; } FileOutputStream fos = new FileOutputStream(targetFile); int length = 0; byte[] data = new byte[1024]; while ((length = is.read(data)) != -1) { fos.write(data, 0, length); } data = null; is.close(); fos.close(); return true; } catch (Throwable e) { DongTaiLog.error(ErrorCode.AGENT_GET_RESOURCE_TO_FILE_FAILED, resourceName, fileName, "write", e); return false; } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testConvert() { // 创建 MethodConvertor 实例 MethodConvertor methodConvertor = new MethodConvertor(manager, reflectionMethod);  // 调用 convert 方法 Operation convertedOperation = methodConvertor.convert();  // 进行断言，验证转换后的 Operation 对象是否符合预期 Assert.assertNotNull(convertedOperation); //判断类型是否正确 Assert.assertEquals(DataType.String().getType(),convertedOperation.getParameters().get(0).getSchema().getType()); Assert.assertEquals(DataType.String().getType(),convertedOperation.getParameters().get(1).getSchema().getType());  MethodConvertor methodConvertor1 = new MethodConvertor(manager, reflectionReturnMethod); Operation convert = methodConvertor1.convert(); Assert."<AssertPlaceHolder>"; //判断有返回值的情况下是否正确 Assert.assertEquals(DataType.Array(DataType.String()) .getType(),convert.getResponses().get(Response.CODE_OK).getContent().get(MediaType.APPLICATION_JSON) .getSchema().getType());   }
convert() { Operation o = new Operation();  try { o.mergeParameters(this.parseParameters()); } catch (Throwable e) { DongTaiLog.debug("MethodConvertor.convert parseParameters exception", e); }  try { o.setResponses(this.parseResponse()); } catch (Throwable e) { DongTaiLog.debug("MethodConvertor.convert parseResponse exception", e); }  // 设置这两个字段 o.setOperationId(UUID.randomUUID().toString()); // 把类名设置为标签 o.setTags(Collections.singletonList(reflectionMethod.getDeclaringClass().getName()));  return o; }
[*] target: assertNotNull(convert)
[-] pred: org. junit. Assert. assertNotNull ( convert )
************************************
************************************
[+] input: convert() { Schema c = convertor.convert(Enumnumnum.class); Assert."<AssertPlaceHolder>"; Assert.assertEquals("string", c.getType()); Assert.assertArrayEquals(c.getEnums(), new String[]{"A", "B", "C"}); }
convert(Class clazz) {  if (clazz == null) { return null; }  // Open API里枚举类型是被看做一个有限取值的string Schema schema = manager.database.find(clazz); if (schema != null) { return schema; }  // 处理枚举值 Object[] enumConstants = clazz.getEnumConstants(); String[] enums = new String[enumConstants.length]; for (int i = 0; i < enumConstants.length; i++) { enums[i] = enumConstants[i].toString(); }  Schema s = new Schema(DataType.String()); s.setEnums(enums);  // 枚举不会有dfs，所以不需要触发转换完成的回调  return s; }
[*] target: assertNotNull(c)
[-] pred: org. junit. Assert. assertNotNull ( c )
************************************
************************************
[+] input: IOException { final File file = File.createTempFile(FastBufferedReaderTest.class.getSimpleName(), "tmp"); file.deleteOnExit();  byte[] a = { '0', '\n', '1', '\n' }; BinIO.storeBytes(a, file); it.unimi.dsi.big.io.FileLinesByteArrayCollection flbac = new it.unimi.dsi.big.io.FileLinesByteArrayCollection(file.toString()); it.unimi.dsi.big.io.FileLinesByteArrayCollection.FileLinesIterator iterator = flbac.iterator(); assertArrayEquals(new byte[] { '0' }, iterator.next()); assertArrayEquals(new byte[] { '1' }, iterator.next()); assertFalse(iterator.hasNext()); assertEquals(2, flbac.size64());  a = new byte[] { '0', '\n', '1' }; BinIO.storeBytes(a, file); flbac = new it.unimi.dsi.big.io.FileLinesByteArrayCollection(file.toString()); assertEquals(2, flbac.size64()); iterator = flbac.iterator(); assertArrayEquals(new byte[] { '0' }, iterator.next()); assertTrue(iterator.hasNext()); assertArrayEquals(new byte[] { '1' }, iterator.next()); assertFalse(iterator.hasNext()); assertFalse(iterator.hasNext()); iterator.close();  a = new byte[1000000]; Arrays.fill(a, (byte)'A'); BinIO.storeBytes(a, file); flbac = new it.unimi.dsi.big.io.FileLinesByteArrayCollection(file.toString()); assertEquals(1, flbac.size64()); iterator = flbac.iterator(); assertArrayEquals(a, iterator.next()); "<AssertPlaceHolder>";  file.delete(); }
hasNext() { if (ready) return true; if (fbis == null) return false; ready = false; try { read = 0; int len; while((len = fbis.readLine(buffer, read, buffer.length - read, terminators)) == buffer.length - read) { ready = true; read += len; buffer = ByteArrays.grow(buffer, buffer.length + 1); } if (len != -1) { ready = true; read += len; } if (len == -1) close(); } catch (final IOException e) { throw new RuntimeException(e); }  return ready; }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext ( ) )
************************************
************************************
[+] input: test() { final SummaryStats summaryStats = new SummaryStats(); summaryStats.add(0); assertEquals(0, summaryStats.sum(), 0); assertEquals(0, summaryStats.mean(), 0); assertEquals(0, summaryStats.variance(), 0); assertEquals(0, summaryStats.min(), 0); assertEquals(0, summaryStats.max(), 0); assertEquals(1, summaryStats.size64());  summaryStats.add(1); assertEquals(1, summaryStats.sum(), 0); assertEquals(.5, summaryStats.mean(), 0); assertEquals(.25, summaryStats.variance(), 0); assertEquals(0, summaryStats.min(), 0); assertEquals(1, summaryStats.max(), 0); "<AssertPlaceHolder>"; }
size64() { return size; }
[*] target: assertEquals(2, summaryStats.size64())
[-] pred: org. junit. Assert. assertEquals ( 2, summaryStats. size64() )
************************************
************************************
[+] input: testParse() { GalleryDetailUrlParser.Result result = GalleryDetailUrlParser.parse(url, strict); if (isNull) { "<AssertPlaceHolder>"; } else { assertEquals(gid, result.gid); assertEquals(token, result.token); } }
parse(String url, boolean strict) { if (url == null) { return null; }  Pattern pattern = strict ? URL_STRICT_PATTERN : URL_PATTERN; Matcher m = pattern.matcher(url); if (m.find()) { Result result = new Result(); result.gid = NumberUtils.parseLongSafely(m.group(1), -1L); result.token = m.group(2); if (result.gid < 0) { return null; } return result; } else { return null; } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testParse() { GalleryPageUrlParser.Result result = GalleryPageUrlParser.parse(url, strict); if (isNull) { "<AssertPlaceHolder>"; } else { assertEquals(gid, result.gid); assertEquals(pToken, result.pToken); assertEquals(page, result.page); } }
parse(String url, boolean strict) { if (url == null) { return null; }  Pattern pattern = strict ? URL_STRICT_PATTERN : URL_PATTERN; Matcher m = pattern.matcher(url); if (m.find()) { Result result = new Result(); result.gid = NumberUtils.parseLongSafely(m.group(2), -1L); result.pToken = m.group(1); result.page = NumberUtils.parseIntSafely(m.group(3), 0) - 1; if (result.gid < 0 || result.page < 0) { return null; } return result; } else { return null; } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: Exception { String name = "test_disable_auto_commit"; FastKV kv1 = new FastKV.Builder(TestHelper.DIR, name).blocking().build(); kv1.clear();  Assert.assertEquals(false, kv1.contains("time")); long newTime = System.currentTimeMillis() ^ System.nanoTime();  kv1.disableAutoCommit(); kv1.putLong("time", newTime); kv1.putString("str", "hello"); kv1.putInt("int", 100);  FastKV kv2 = new FastKV(TestHelper.DIR, name, null, null, FastKV.SYNC_BLOCKING); Assert.assertNotEquals(100, kv2.getInt("int"));  boolean result = kv1.commit(); Assert."<AssertPlaceHolder>";  FastKV kv3 = new FastKV(TestHelper.DIR, name, null, null, FastKV.SYNC_BLOCKING); Assert.assertEquals(100, kv3.getInt("int"));  File aFile = new File(TestHelper.DIR, name + ".kvc"); RandomAccessFile accessFile = new RandomAccessFile(aFile, "r"); ByteBuffer buffer = ByteBuffer.allocate(26); buffer.order(ByteOrder.LITTLE_ENDIAN); accessFile.read(buffer.array(), 0, 26); long t = buffer.getLong(18); Assert.assertEquals(newTime, t);  kv1.putBoolean("bool", false); kv1.putBoolean("bool", true);  FastKV kv4 = new FastKV(TestHelper.DIR, name, null, null, FastKV.SYNC_BLOCKING); Assert.assertEquals(newTime, kv4.getLong("time")); Assert.assertEquals(true, kv4.getBoolean("bool")); }
commit() { if (closed) return false; autoCommit = true; return commitToCFile(); }
[*] target: assertEquals(true, result)
[-] pred: org. junit. Assert. assertEquals ( true, result )
************************************
************************************
[+] input: URISyntaxException { BatchRequestCreator batchRequestCreator = new BatchRequestCreator(firehoseInstrumentation, uriBuilder, headerBuilder, HttpSinkRequestMethodType.PUT, jsonBody, httpSinkConfig); List<HttpEntityEnclosingRequestBase> requests = batchRequestCreator.create(messages, requestEntityBuilder);  "<AssertPlaceHolder>"; assertEquals(HttpSinkRequestMethodType.PUT.toString(), requests.get(0).getMethod()); verify(firehoseInstrumentation, times(1)).logDebug("\nRequest URL: {}\nRequest headers: {}\nRequest content: {}\nRequest method: {}", uriBuilder.build(), headerBuilder.build(), jsonBody.serialize(messages), HttpSinkRequestMethodType.PUT); }
create(List<Message> messages, RequestEntityBuilder requestEntityBuilder) throws URISyntaxException { URI uri = uriBuilder.build(); HttpEntityEnclosingRequestBase request = HttpRequestMethodFactory .create(uri, method);  Map<String, String> headerMap = headerBuilder.build(); headerMap.forEach(request::addHeader); String messagesString = jsonBody.serialize(messages).toString();  if (!(method == HttpSinkRequestMethodType.DELETE && !httpSinkConfig.getSinkHttpDeleteBodyEnable())) { request.setEntity(requestEntityBuilder.buildHttpEntity(messagesString)); firehoseInstrumentation.logDebug("\nRequest URL: {}\nRequest headers: {}\nRequest content: {}\nRequest method: {}", uri, headerMap, jsonBody.serialize(messages), method); } else { firehoseInstrumentation.logDebug("\nRequest URL: {}\nRequest headers: {}\nRequest content: no body\nRequest method: {}", uri, headerMap, method); } return Collections.singletonList(request); }
[*] target: assertEquals(1, requests.size())
[-] pred: org. junit. Assert. assertEquals ( 1, requests. size ( ) )
************************************
************************************
[+] input: URISyntaxException { BatchRequestCreator batchRequestCreator = new BatchRequestCreator(firehoseInstrumentation, uriBuilder, headerBuilder, HttpSinkRequestMethodType.POST, jsonBody, httpSinkConfig); List<HttpEntityEnclosingRequestBase> requests = batchRequestCreator.create(messages, requestEntityBuilder);  "<AssertPlaceHolder>"; assertEquals(HttpSinkRequestMethodType.POST.toString(), requests.get(0).getMethod()); verify(firehoseInstrumentation, times(1)).logDebug("\nRequest URL: {}\nRequest headers: {}\nRequest content: {}\nRequest method: {}", uriBuilder.build(), headerBuilder.build(), jsonBody.serialize(messages), HttpSinkRequestMethodType.POST); }
create(List<Message> messages, RequestEntityBuilder requestEntityBuilder) throws URISyntaxException { URI uri = uriBuilder.build(); HttpEntityEnclosingRequestBase request = HttpRequestMethodFactory .create(uri, method);  Map<String, String> headerMap = headerBuilder.build(); headerMap.forEach(request::addHeader); String messagesString = jsonBody.serialize(messages).toString();  if (!(method == HttpSinkRequestMethodType.DELETE && !httpSinkConfig.getSinkHttpDeleteBodyEnable())) { request.setEntity(requestEntityBuilder.buildHttpEntity(messagesString)); firehoseInstrumentation.logDebug("\nRequest URL: {}\nRequest headers: {}\nRequest content: {}\nRequest method: {}", uri, headerMap, jsonBody.serialize(messages), method); } else { firehoseInstrumentation.logDebug("\nRequest URL: {}\nRequest headers: {}\nRequest content: no body\nRequest method: {}", uri, headerMap, method); } return Collections.singletonList(request); }
[*] target: assertEquals(1, requests.size())
[-] pred: org. junit. Assert. assertEquals ( 1, requests. size ( ) )
************************************
************************************
[+] input: URISyntaxException { BatchRequestCreator batchRequestCreator = new BatchRequestCreator(firehoseInstrumentation, uriBuilder, headerBuilder, HttpSinkRequestMethodType.PATCH, jsonBody, httpSinkConfig); List<HttpEntityEnclosingRequestBase> requests = batchRequestCreator.create(messages, requestEntityBuilder);  "<AssertPlaceHolder>"; assertEquals(HttpSinkRequestMethodType.PATCH.toString(), requests.get(0).getMethod()); verify(firehoseInstrumentation, times(1)).logDebug("\nRequest URL: {}\nRequest headers: {}\nRequest content: {}\nRequest method: {}", uriBuilder.build(), headerBuilder.build(), jsonBody.serialize(messages), HttpSinkRequestMethodType.PATCH); }
create(List<Message> messages, RequestEntityBuilder requestEntityBuilder) throws URISyntaxException { URI uri = uriBuilder.build(); HttpEntityEnclosingRequestBase request = HttpRequestMethodFactory .create(uri, method);  Map<String, String> headerMap = headerBuilder.build(); headerMap.forEach(request::addHeader); String messagesString = jsonBody.serialize(messages).toString();  if (!(method == HttpSinkRequestMethodType.DELETE && !httpSinkConfig.getSinkHttpDeleteBodyEnable())) { request.setEntity(requestEntityBuilder.buildHttpEntity(messagesString)); firehoseInstrumentation.logDebug("\nRequest URL: {}\nRequest headers: {}\nRequest content: {}\nRequest method: {}", uri, headerMap, jsonBody.serialize(messages), method); } else { firehoseInstrumentation.logDebug("\nRequest URL: {}\nRequest headers: {}\nRequest content: no body\nRequest method: {}", uri, headerMap, method); } return Collections.singletonList(request); }
[*] target: assertEquals(1, requests.size())
[-] pred: org. junit. Assert. assertEquals ( 1, requests. size ( ) )
************************************
************************************
[+] input: IllegalAccessException { BulkWriteError writeError1 = new BulkWriteError(400, "Duplicate Key Error", new BsonDocument(), 0); BulkWriteError writeError2 = new BulkWriteError(11000, "Duplicate Key Error", new BsonDocument(), 1); List<BulkWriteError> writeErrors = Arrays.asList(writeError1, writeError2);  MongoSink mongoSink = new MongoSink(firehoseInstrumentation, SinkType.MONGODB.name(), mongoRequestHandler, mongoSinkClient); Field messagesField = MongoSink.class.getDeclaredField("messages"); messagesField.setAccessible(true); messagesField.set(mongoSink, this.messages);  when(mongoSinkClient.processRequest(any())).thenReturn(writeErrors); List<Message> failedMessages = mongoSink.execute(); "<AssertPlaceHolder>"; assertEquals(this.messages.get(0), failedMessages.get(0)); assertEquals(this.messages.get(1), failedMessages.get(1)); }
execute() { List<BulkWriteError> writeErrors = mongoSinkClient.processRequest(requests); return writeErrors.stream() .map(writeError -> messages.get(writeError.getIndex())) .collect(Collectors.toList()); }
[*] target: assertEquals(2, failedMessages.size())
[-] pred: org. junit. Assert. assertEquals ( 2, failedMessages. size ( ) )
************************************
************************************
[+] input: testLabeledPointWithWeightGenerator() { String featuresCol = "features"; String labelCol = "label"; String weightCol = "weight";  LabeledPointWithWeightGenerator generator = new LabeledPointWithWeightGenerator() .setFeatureArity(10) .setLabelArity(10) .setColNames(new String[] {featuresCol, labelCol, weightCol}) .setNumValues(100);  int count = 0; for (CloseableIterator<Row> it = generator.getData(tEnv)[0].execute().collect(); it.hasNext(); ) { Row row = it.next(); count++; DenseVector features = (DenseVector) row.getField(featuresCol); "<AssertPlaceHolder>"; for (double value : features.values) { assertTrue(value >= 0); assertTrue(value <= generator.getFeatureArity() - 1); }  double label = (double) row.getField(labelCol); assertTrue(label >= 0); assertTrue(label <= generator.getLabelArity() - 1);  double weight = (double) row.getField(weightCol); assertTrue(weight >= 0); assertTrue(weight < 1); } assertEquals(generator.getNumValues(), count); }
getData(StreamTableEnvironment tEnv);
[*] target: assertNotNull(features)
[-] pred: org. junit. Assert. assertNotNull ( features )
************************************
************************************
[+] input: testIsEmpty() { QuantileSummary summary = new QuantileSummary(0.01); assertTrue(summary.isEmpty());  summary = summary.insert(1); assertFalse(summary.isEmpty());  summary = summary.compress(); assertFalse(summary.isEmpty());  summary = summary.merge(new QuantileSummary(0.01)); "<AssertPlaceHolder>"; }
isEmpty() { return headBuffer.isEmpty() && sampled.isEmpty(); }
[*] target: assertFalse(summary.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( summary. isEmpty() )
************************************
************************************
[+] input: Exception { VectorSlicer vectorSlicer = new VectorSlicer().setInputCol("vec").setOutputCol("sliceVec").setIndices(0, 2, 1);  Table output = vectorSlicer.transform(inputDataTable)[0]; DataStream<Row> dataStream = tEnv.toDataStream(output); List<Row> results = IteratorUtils.toList(dataStream.executeAndCollect()); "<AssertPlaceHolder>"; for (Row result : results) { if (result.getField(0) == (Object) 0) { assertEquals( Vectors.dense(2.1, 2.3, 3.1), result.getField(vectorSlicer.getOutputCol()));  } else if (result.getField(0) == (Object) 1) { assertEquals( Vectors.dense(2.3, 1.3, 4.1), result.getField(vectorSlicer.getOutputCol())); } else { throw new RuntimeException("Result id value is error, it must be 0 or 1."); } } }
transform(Table... inputs) { Preconditions.checkArgument(inputs.length == 1); StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment(); RowTypeInfo inputTypeInfo = TableUtils.getRowTypeInfo(inputs[0].getResolvedSchema()); RowTypeInfo outputTypeInfo = new RowTypeInfo( ArrayUtils.addAll(inputTypeInfo.getFieldTypes(), VectorTypeInfo.INSTANCE), ArrayUtils.addAll(inputTypeInfo.getFieldNames(), getOutputCol())); DataStream<Row> output = tEnv.toDataStream(inputs[0]) .map(new VectorSliceFunction(getIndices(), getInputCol()), outputTypeInfo); Table outputTable = tEnv.fromDataStream(output); return new Table[] {outputTable}; }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size ( ) )
************************************
************************************
[+] input: testConcatAndSplitByteArrays() { byte[] first = new byte[] {1, 2, 3, 4}; byte[] second = new byte[] {1, 2, 3};  byte[] concat = CommonUtils.concatByteArrays(first, second); assertEquals(15, concat.length);  List<byte[]> split = CommonUtils.splitByteArrays(concat); "<AssertPlaceHolder>"; assertArrayEquals(first, split.get(0)); assertArrayEquals(second, split.get(1)); }
splitByteArrays(byte[] concatArray) { List<byte[]> arrays = new ArrayList<>(); ByteBuffer buffer = ByteBuffer.wrap(concatArray); while (buffer.hasRemaining()) { int length = buffer.getInt(); byte[] array = new byte[length]; buffer.get(array); arrays.add(array); }  return arrays; }
[*] target: assertEquals(2, split.size())
[-] pred: org. junit. Assert. assertEquals ( 2, split. size ( ) )
************************************
************************************
[+] input: Exception { // ZooKeeper does not like whitespace in the quorum connect String. String actual, expected; Configuration conf = new Configuration();  { expected = "localhost:2891";  setQuorum(conf, expected); actual = ZooKeeperUtils.getZooKeeperEnsemble(conf); assertEquals(expected, actual);  setQuorum(conf, " localhost:2891 "); // with leading and trailing whitespace actual = ZooKeeperUtils.getZooKeeperEnsemble(conf); assertEquals(expected, actual);  setQuorum(conf, "localhost :2891"); // whitespace after port actual = ZooKeeperUtils.getZooKeeperEnsemble(conf); assertEquals(expected, actual); }  { expected = "localhost:2891,localhost:2891";  setQuorum(conf, "localhost:2891,localhost:2891"); actual = ZooKeeperUtils.getZooKeeperEnsemble(conf); assertEquals(expected, actual);  setQuorum(conf, "localhost:2891, localhost:2891"); actual = ZooKeeperUtils.getZooKeeperEnsemble(conf); assertEquals(expected, actual);  setQuorum(conf, "localhost :2891, localhost:2891"); actual = ZooKeeperUtils.getZooKeeperEnsemble(conf); assertEquals(expected, actual);  setQuorum(conf, " localhost:2891, localhost:2891 "); actual = ZooKeeperUtils.getZooKeeperEnsemble(conf); "<AssertPlaceHolder>"; } }
getZooKeeperEnsemble(Configuration conf) { String zkQuorum = conf.getString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM); if (zkQuorum == null || StringUtils.isBlank(zkQuorum)) { throw new ConfigurationException("No ZooKeeper quorum specified in config."); } // Remove all whitespace return zkQuorum.replaceAll("\\s+", ""); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testRpcConnectionClose() { final String testRpcConnectionEndpointAddress = "<TestRpcConnectionEndpointAddress>"; final UUID leaderId = UUID.randomUUID(); final String connectionID = "Test RPC Connection ID";  TestRegistrationGateway testGateway = new TestRegistrationGateway( new RetryingRegistrationTest.TestRegistrationSuccess(connectionID));  try { rpcService.registerGateway(testRpcConnectionEndpointAddress, testGateway);  TestRpcConnection connection = new TestRpcConnection( testRpcConnectionEndpointAddress, leaderId, rpcService.getExecutor(), rpcService); connection.start(); // close the connection connection.close();  // validate connection is closed assertEquals(testRpcConnectionEndpointAddress, connection.getTargetAddress()); assertEquals(leaderId, connection.getTargetLeaderId()); "<AssertPlaceHolder>"; } finally { testGateway.stop(); } }
isClosed() { return closed; }
[*] target: assertTrue(connection.isClosed())
[-] pred: org. junit. Assert. assertTrue ( connection. isClosed() )
************************************
************************************
[+] input: Exception { File base = TEMP_FOLDER.newFolder(); String basePath = base.getAbsolutePath() + "/";  LocalShuffleMetaStore metaStore = new LocalShuffleMetaStore(Collections.singleton(basePath));  DataPartitionMeta meta = randomMeta(basePath); metaStore.onPartitionCreated(meta);  List<DataPartitionStatus> current = metaStore.listDataPartitions(); "<AssertPlaceHolder>"; assertEquals( new DataPartitionStatus( meta.getJobID(), new DataPartitionCoordinate(meta.getDataSetID(), meta.getDataPartitionID()), false), current.get(0));  File[] metaFiles = listMetaFiles(basePath); assertNotNull(metaFiles); assertEquals(1, metaFiles.length); }
listDataPartitions() { List<DataPartitionStatus> dataPartitionStatuses = new ArrayList<>();  synchronized (dataPartitions) { dataPartitions.forEach( ((coordinate, dataPartitionWorkerStatus) -> { dataPartitionStatuses.add( new DataPartitionStatus( dataPartitionWorkerStatus.getMeta().getJobID(), new DataPartitionCoordinate( dataPartitionWorkerStatus.getMeta().getDataSetID(), dataPartitionWorkerStatus .getMeta() .getDataPartitionID()), dataPartitionWorkerStatus.isReleasing())); })); }  return dataPartitionStatuses; }
[*] target: assertEquals(1, current.size())
[-] pred: org. junit. Assert. assertEquals ( 1, current. size ( ) )
************************************
************************************
[+] input: Throwable { LocalMapPartitionFile partitionFile = createPartitionFile(); StorageTestUtils.writeLocalMapPartitionFile( partitionFile, 0, StorageTestUtils.NUM_REDUCE_PARTITIONS, 0, false, dataChecksumEnabled);  int buffersRead = readData(partitionFile, 1); "<AssertPlaceHolder>"; assertNull(partitionFile.getIndexReadingChannel()); assertNull(partitionFile.getDataReadingChannel()); }
readData(BufferQueue buffers, BufferRecycler recycler) throws Exception { CommonUtils.checkArgument(buffers != null, "Must be not null."); CommonUtils.checkArgument(recycler != null, "Must be not null.");  CommonUtils.checkState(isOpened, "Partition reader is not opened.");  boolean hasReaming = fileReader.hasRemaining(); boolean continueReading = hasReaming; long numBytes = 0; int numDataBuffers = 0;  while (continueReading) { ByteBuffer buffer = buffers.poll(); if (buffer == null) { break; }  try { continueReading = fileReader.readBuffer(buffer); } catch (Throwable throwable) { BufferUtils.recycleBuffer(buffer, recycler); throw throwable; }  hasReaming = fileReader.hasRemaining(); numBytes += buffer.remaining(); addBuffer(new Buffer(buffer, recycler, buffer.remaining()), hasReaming); ++numDataBuffers; }  if (numDataBuffers > 0) { notifyBacklog(numDataBuffers); }  if (!hasReaming) { closeReader(); }  if (numBytes > 0) { readingThroughputBytes.mark(numBytes); } return hasReaming; }
[*] target: assertEquals(0, buffersRead)
[-] pred: org. junit. Assert. assertEquals ( 0, buffersRead )
************************************
************************************
[+] input: Exception { LocalMapPartitionFile partitionFile1 = createPartitionFile(); partitionFile1.onError(new Exception("Test exception.")); partitionFile1.onError(new Exception("Test exception.")); partitionFile1.onError(new Exception("Test exception.")); partitionFile1.onError(new Exception("Test exception.")); assertTrue(partitionFile1.isConsumable());  partitionFile1.onError(new FileCorruptedException()); assertFalse(partitionFile1.isConsumable());  LocalMapPartitionFile partitionFile2 = createPartitionFile(); partitionFile2.onError(new ClosedChannelException()); partitionFile2.onError(new ClosedChannelException()); partitionFile2.onError(new ClosedChannelException()); partitionFile2.onError(new ClosedChannelException()); assertTrue(partitionFile2.isConsumable());  assertTrue(partitionFile2.isConsumable()); partitionFile2.onError(new IOException("Test exception."));  assertTrue(partitionFile2.isConsumable()); partitionFile2.onError(new IOException("Test exception."));  assertTrue(partitionFile2.isConsumable()); partitionFile2.onError(new IOException("Test exception."));  assertTrue(partitionFile2.isConsumable()); partitionFile2.onError(new IOException("Test exception.")); "<AssertPlaceHolder>"; }
isConsumable() { return isConsumable && Files.isReadable(fileMeta.getDataFilePath()) && Files.isReadable(fileMeta.getIndexFilePath()); }
[*] target: assertFalse(partitionFile2.isConsumable())
[-] pred: org. junit. Assert. assertFalse ( partitionFile2. isConsumable ( ) )
************************************
************************************
[+] input: rangeQueryPolygonTest() { TreeIndex<Polygon> polygonTreeIndex = new STRTreeIndex<>(); polygonTreeIndex.insert(polygons);  List<Polygon> r1 = polygonTreeIndex.query(new Envelope(14, 20, 9, 12)); assertEquals(1, r1.size());  List<Polygon> r2 = polygonTreeIndex.query(new Envelope(5, 10, 0, 10)); "<AssertPlaceHolder>"; }
size() { return rTree.size(); }
[*] target: assertEquals(2, r2.size())
[-] pred: org. junit. Assert. assertEquals ( 2, r2. size ( ) )
************************************
************************************
[+] input: should_ReturnValidationError_When_NullAsEndpointNameGiven() { String validationResult = checker.check(null);  "<AssertPlaceHolder>"; assertTrue(validationResult.contains("blank")); }
check(String endpointName) { if (endpointName == null || endpointName.isEmpty()) { return "Endpoint name cannot be blank"; } if (ECMA_SCRIPT_RESERVED_WORDS.contains(endpointName)) { return "Endpoint name cannot be equal to JavaScript reserved words"; } if (WHITESPACE_PATTERN.matcher(endpointName).find()) { return "Endpoint name cannot contain any whitespaces"; } return null; }
[*] target: assertNotNull(validationResult)
[-] pred: org. junit. Assert. assertNotNull ( validationResult )
************************************
************************************
[+] input: should_ReturnValidationError_When_EmptyAsEndpointNameGiven() { String validationResult = checker.check("");  "<AssertPlaceHolder>"; assertTrue(validationResult.contains("blank")); }
check(String endpointName) { if (endpointName == null || endpointName.isEmpty()) { return "Endpoint name cannot be blank"; } if (ECMA_SCRIPT_RESERVED_WORDS.contains(endpointName)) { return "Endpoint name cannot be equal to JavaScript reserved words"; } if (WHITESPACE_PATTERN.matcher(endpointName).find()) { return "Endpoint name cannot contain any whitespaces"; } return null; }
[*] target: assertNotNull(validationResult)
[-] pred: org. junit. Assert. assertNotNull ( validationResult )
************************************
************************************
[+] input: should_ReturnError_When_GivenNullValue_ForStringType() { String error = explicitNullableTypeChecker.checkValueForType(null, String.class, false);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(error.contains("null")); Assert.assertTrue(error.contains("String")); }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: should_ReturnError_When_GivenNullValue_ForDateType() { String error = explicitNullableTypeChecker.checkValueForType(null, Date.class, false);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(error.contains("null")); Assert.assertTrue(error.contains("Date")); }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: should_ReturnError_When_GivenNullValue_ForDateTimeType() { String error = explicitNullableTypeChecker.checkValueForType(null, LocalDateTime.class, false);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(error.contains("null")); Assert.assertTrue(error.contains("LocalDateTime")); }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: should_ReturnError_When_GivenNullValue_ForLcalTimeType() { String error = explicitNullableTypeChecker.checkValueForType(null, LocalTime.class, false);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(error.contains("null")); Assert.assertTrue(error.contains("LocalTime")); }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: should_ReturnError_When_GivenNullValue_ForMapType() { String error = explicitNullableTypeChecker.checkValueForType(null, Map.class, false);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(error.contains("null")); Assert.assertTrue(error.contains("Map")); }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: should_ReturnError_When_GivenNullValue_ForObjectType() { String error = explicitNullableTypeChecker.checkValueForType(null, Object.class, false);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(error.contains("null")); Assert.assertTrue(error.contains("Object")); }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: should_ReturnError_When_GivenNullValue_ForOptionalType() { String error = explicitNullableTypeChecker.checkValueForType(null, Optional.class, false);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(error.contains("null")); Assert.assertTrue(error.contains("Optional.empty")); }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: should_ReturnError_When_GivenNullValue_ForCollectionType() { String error = explicitNullableTypeChecker.checkValueForType(null, stringListType, false);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(error.contains("null")); Assert.assertTrue(error.contains("List")); Assert.assertTrue(error.contains("String")); }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: should_ReturnError_When_GivenNull_BeanProperty() { // Property 'title' is null Bean bean = new Bean();  String error = explicitNullableTypeChecker.checkValueForType(bean, Bean.class, false);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(error.contains("null")); Assert.assertTrue(error.contains("Bean")); }
checkValueForType(Object value, Type expectedType, boolean requiredByContext) { return new ExplicitNullableTypeCheckerHelper(requiredByContext) .checkValueForType(value, expectedType); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: constraintOptional() { createCueFile("#Person: {\n" + "    <caret>name!: string\n" + "    age?:  int\n" + "}");  var field = findTypedElement(CueLabelExpr.class); assertTrue(field.isRequiredFieldConstraint()); "<AssertPlaceHolder>"; }
isOptionalFieldConstraint() { return CuePsiImplUtil.isOptionalFieldConstraint(this); }
[*] target: assertFalse(field.isOptionalFieldConstraint())
[-] pred: org. junit. Assert. assertFalse ( field. isOptionalFieldConstraint ( ) )
************************************
************************************
[+] input: useSettingsFromConfigTemplate() { GinkgoRunConfiguration configTemplate = (GinkgoRunConfiguration) new GinkgoConfigurationType().createTemplateConfiguration(getProject()); configTemplate.getOptions().setGinkgoAdditionalOptions("additional options"); configTemplate.getOptions().setGoToolOptions("build tool options"); configTemplate.getOptions().setWorkingDir("custom directory");  GoFile file = (GoFile) myFixture.configureByFile("marker_ginkgo.go"); PsiElement specElement = getSpecElement(file, "Describe"); ConfigurationContext context = new ConfigurationContext(specElement); boolean result = ginkgoRunConfigurationProducer.setupConfigurationFromContext(configTemplate, context, new Ref<>(specElement));  "<AssertPlaceHolder>"; assertEquals("additional options", configTemplate.getOptions().getGinkgoAdditionalOptions()); assertEquals("build tool options", configTemplate.getOptions().getGoToolOptions()); assertEquals("custom directory", configTemplate.getOptions().getWorkingDir()); }
setupConfigurationFromContext(@NotNull GinkgoRunConfiguration configuration, @NotNull ConfigurationContext context, @NotNull Ref<PsiElement> sourceElement) { if (context.getPsiLocation() == null || context.getPsiLocation().getParent() == null) { return false; }  if (!(context.getPsiLocation().getParent().getParent() instanceof GoCallExpr)) { return false; }  List<String> specNames = getSpecNames(context); GinkgoRunConfigurationOptions options = configuration.getOptions();  GinkgoRunConfigurationOptions ginkgoRunConfigurationOptions = new GinkgoRunConfigurationOptions(); ginkgoRunConfigurationOptions.setGinkgoExecutable(options.getGinkgoExecutable()); ginkgoRunConfigurationOptions.setWorkingDir(configWorkingDirectory(context, options)); ginkgoRunConfigurationOptions.setEnvData(options.getEnvData()); ginkgoRunConfigurationOptions.setGinkgoAdditionalOptions(options.getGinkgoAdditionalOptions()); ginkgoRunConfigurationOptions.setGinkgoScope(GinkgoScope.FOCUS); ginkgoRunConfigurationOptions.setTestNames(specNames); ginkgoRunConfigurationOptions.setFocusTestExpression(String.join(" ", specNames)); ginkgoRunConfigurationOptions.setGoToolOptions(options.getGoToolOptions()); GoFile file = (GoFile) context.getPsiLocation().getContainingFile(); ginkgoRunConfigurationOptions.setPackageName(file.getPackageName());  configuration.setOptions(ginkgoRunConfigurationOptions); configuration.setGeneratedName(); return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: getStructureViewBuilder_ginkgo() { GoFile file = (GoFile) myFixture.configureByFile("marker_test.go"); StructureViewBuilder structureViewBuilder = ginkgoStructureViewFactory.getStructureViewBuilder(file); "<AssertPlaceHolder>"; StructureView structureView = structureViewBuilder.createStructureView(null, file.getProject()); assertTrue(structureView.getTreeModel() instanceof GinkgoStructureViewModel); }
getStructureViewBuilder(@NotNull PsiFile psiFile) { GinkgoSettings settings = GinkgoSettings.getInstance(); if (isGinkgoTestFile(psiFile) && settings.isGinkgoStructViewEnabled()) { return new TreeBasedStructureViewBuilder() { public @NotNull StructureViewModel createStructureViewModel(@Nullable Editor editor) { return new GinkgoStructureViewModel(psiFile); } }; }  //we should fall back to GoStructViewFactory return new GoStructureViewFactory().getStructureViewBuilder(psiFile); }
[*] target: assertNotNull(structureViewBuilder)
[-] pred: org. junit. Assert. assertNotNull ( structureViewBuilder )
************************************
************************************
[+] input: getStructureViewBuilder_go() { GoFile file = (GoFile) myFixture.configureByFile("go_file.go"); StructureViewBuilder structureViewBuilder = ginkgoStructureViewFactory.getStructureViewBuilder(file); "<AssertPlaceHolder>"; StructureView structureView = structureViewBuilder.createStructureView(null, file.getProject()); assertTrue(structureView.getTreeModel() instanceof GoStructureViewFactory.Model); }
getStructureViewBuilder(@NotNull PsiFile psiFile) { GinkgoSettings settings = GinkgoSettings.getInstance(); if (isGinkgoTestFile(psiFile) && settings.isGinkgoStructViewEnabled()) { return new TreeBasedStructureViewBuilder() { public @NotNull StructureViewModel createStructureViewModel(@Nullable Editor editor) { return new GinkgoStructureViewModel(psiFile); } }; }  //we should fall back to GoStructViewFactory return new GoStructureViewFactory().getStructureViewBuilder(psiFile); }
[*] target: assertNotNull(structureViewBuilder)
[-] pred: org. junit. Assert. assertNotNull ( structureViewBuilder )
************************************
************************************
[+] input: toByteArray() { ByteArraySerializer serializer = ByteArraySerializer.newInstance(); byte[] expect = new byte[]{(byte) 0x01, // 0, 25689 (byte) 0x00, (byte) 0x00, (byte) 0x64, (byte) 0x59, // 523975585 (byte) 0x1F, (byte) 0x3B, (byte) 0x3B, (byte) 0xA1, (byte) 0x1F, (byte) 0x3B, (byte) 0x3B, (byte) 0xA1, // 33.16f, -15.62f (byte) 0x42, (byte) 0x04, (byte) 0xA3, (byte) 0xD7, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, // 156665.35455556 (byte) 0x41, (byte) 0x03, (byte) 0x1F, (byte) 0xCA, (byte) 0xD6, (byte) 0x21, (byte) 0x39, (byte) 0xB7, // -56516.66664 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, // 23A (byte) 0x32, (byte) 0x33, (byte) 0x41};  ByteArrayBean bean = serializer.toObject(ByteArrayBean.class, expect); byte[] actual = serializer.toByteArray(bean); assertArrayEquals(expect, actual);  expect = new byte[]{(byte) 0x81, // 0, 25689 (byte) 0x00, (byte) 0x00, (byte) 0x64, (byte) 0x59, // 523975585 (byte) 0x1F, (byte) 0x3B, (byte) 0x3B, (byte) 0xA1, (byte) 0x1F, (byte) 0x3B, (byte) 0x3B, (byte) 0xA1, // 33.16f, -15.62f (byte) 0x42, (byte) 0x04, (byte) 0xA3, (byte) 0xD7, (byte) 0xC1, (byte) 0x79, (byte) 0xEB, (byte) 0x85, // 156665.35455556 (byte) 0x41, (byte) 0x03, (byte) 0x1F, (byte) 0xCA, (byte) 0xD6, (byte) 0x21, (byte) 0x39, (byte) 0xB7, // -56516.66664 (byte) 0xC0, (byte) 0xEB, (byte) 0x98, (byte) 0x95, (byte) 0x55, (byte) 0x1D, (byte) 0x68, (byte) 0xC7, // 23A (byte) 0x32, (byte) 0x33, (byte) 0x41};  ByteArrayListBean listBean = serializer.toObject(ByteArrayListBean.class, expect); actual = serializer.toByteArray(listBean); "<AssertPlaceHolder>"; }
toByteArray(final T targetBean) { try { // 组装数据，同时计算最大的字节长度 int buffSize = 0; List<ByteArrayParseData> parseDataList = new ArrayList<>(); for (final Field field : targetBean.getClass().getDeclaredFields()) { final ByteArrayVariable variable = field.getAnnotation(ByteArrayVariable.class); if (variable == null) { continue; } ByteArrayParameter parameter = new ByteArrayParameter(variable.byteOffset(), variable.bitOffset(), variable.count(), variable.type(), variable.littleEndian(), variable.format()); this.checkByteArrayVariable(parameter); parseDataList.add(new ByteArrayParseData(variable, field)); int maxPos = variable.byteOffset() + variable.count() * variable.type().getByteLength(); if (maxPos > buffSize) { buffSize = maxPos; } } if (buffSize == 0 || parseDataList.isEmpty()) { return new byte[0]; } // 填充字节数组的内容 ByteWriteBuff buff = ByteWriteBuff.newInstance(buffSize); for (ByteArrayParseData item : parseDataList) { item.getField().setAccessible(true); Object data = item.getField().get(targetBean); if (data == null) { continue; } if (item.getVariable().count() == 1) { this.fillOneData(item.getVariable(), data, buff, 0); } else { this.fillListData(item.getVariable(), data, buff); } } return buff.getData(); } catch (Exception e) { throw new ByteArrayParseException("parsing to object error, cause:" + e.getMessage(), e); } }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x01, (byte) 0x00, (byte) 0x13, (byte) 0x00, (byte) 0x13}; MbReadCoilRequest mb = new MbReadCoilRequest(); mb.setFunctionCode(EMbFunctionCode.READ_COIL); mb.setAddress(19); mb.setQuantity(19); assertEquals(5, mb.byteArrayLength()); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x02, (byte) 0x00, (byte) 0xC4, (byte) 0x00, (byte) 0x16}; MbReadDiscreteInputRequest mb = new MbReadDiscreteInputRequest(); mb.setFunctionCode(EMbFunctionCode.READ_DISCRETE_INPUT); mb.setAddress(196); mb.setQuantity(22); assertEquals(5, mb.byteArrayLength()); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x03, (byte) 0x00, (byte) 0x6B, (byte) 0x00, (byte) 0x03}; MbReadHoldRegisterRequest mb = new MbReadHoldRegisterRequest(); mb.setFunctionCode(EMbFunctionCode.READ_HOLD_REGISTER); mb.setAddress(107); mb.setQuantity(3); assertEquals(5, mb.byteArrayLength()); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x04, (byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x01}; MbReadInputRegisterRequest mb = new MbReadInputRegisterRequest(); mb.setFunctionCode(EMbFunctionCode.READ_INPUT_REGISTER); mb.setAddress(8); mb.setQuantity(1); assertEquals(5, mb.byteArrayLength()); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.quantity) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x05, (byte) 0x00, (byte) 0xAC, (byte) 0xFF, (byte) 0x00}; MbWriteSingleCoilRequest mb = new MbWriteSingleCoilRequest(); mb.setFunctionCode(EMbFunctionCode.WRITE_SINGLE_COIL); mb.setAddress(172); mb.setValue(true); assertEquals(5, mb.byteArrayLength()); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putBytes(this.value ? ON : OFF) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x05, (byte) 0x00, (byte) 0xAC, (byte) 0xFF, (byte) 0x00}; MbWriteSingleCoilResponse mb = new MbWriteSingleCoilResponse(); mb.setFunctionCode(EMbFunctionCode.WRITE_SINGLE_COIL); mb.setAddress(172); mb.setValue(new byte[]{(byte) 0xFF, (byte) 0x00}); assertEquals(5, mb.byteArrayLength()); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putBytes(this.value) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x06, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x03}; MbWriteSingleRegisterRequest mb = new MbWriteSingleRegisterRequest(); mb.setFunctionCode(EMbFunctionCode.WRITE_SINGLE_REGISTER); mb.setAddress(1); mb.setValue(3); assertEquals(5, mb.byteArrayLength()); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putShort(this.value) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: toByteArray() { byte[] actual = new byte[]{(byte) 0x06, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x03}; MbWriteSingleRegisterResponse mb = new MbWriteSingleRegisterResponse(); mb.setFunctionCode(EMbFunctionCode.WRITE_SINGLE_REGISTER); mb.setAddress(1); mb.setValue(new byte[]{(byte) 0x00, (byte) 0x03}); assertEquals(5, mb.byteArrayLength()); "<AssertPlaceHolder>"; }
toByteArray() { return ByteWriteBuff.newInstance(this.byteArrayLength()) .putByte(this.functionCode.getCode()) .putShort(this.address) .putBytes(this.value) .getData(); }
[*] target: assertArrayEquals(actual, mb.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( actual, mb. toByteArray ( ) )
************************************
************************************
[+] input: createResponse6() { UsernamePasswordCredential credential = new UsernamePasswordCredential("admin", "kilox1234"); DigestAuthenticator authenticator = new DigestAuthenticator(credential); authenticator.addServerInfoByString("Digest realm="IP Camera(G5366)", nonce="2beea68cde935c964af4993f5535d15b", stale="FALSE""); authenticator.addClientInfo("rtsp://192.168.3.142:554/h264/ch1/main/av_stream", ERtspMethod.DESCRIBE.getCode()); String expect = "Digest username="admin", realm="IP Camera(G5366)", nonce="2beea68cde935c964af4993f5535d15b", uri="rtsp://192.168.3.142:554/h264/ch1/main/av_stream", response="e89e52ddba1f60572564db63c35612b2""; String actual = authenticator.createResponse(); assertEquals(expect, actual);  authenticator.setUri("rtsp://192.168.3.142:554/h264/ch1/main/av_stream/"); authenticator.setMethod(ERtspMethod.SETUP.getCode()); expect = "Digest username="admin", realm="IP Camera(G5366)", nonce="2beea68cde935c964af4993f5535d15b", uri="rtsp://192.168.3.142:554/h264/ch1/main/av_stream/", response="593dd32ac8986b39643c69ad41861d18""; actual = authenticator.createResponse(); assertEquals(expect, actual);  //        authenticator.setUri("rtsp://192.168.3.142:554/h264/ch1/main/av_stream/"); authenticator.setMethod(ERtspMethod.PLAY.getCode()); expect = "Digest username="admin", realm="IP Camera(G5366)", nonce="2beea68cde935c964af4993f5535d15b", uri="rtsp://192.168.3.142:554/h264/ch1/main/av_stream/", response="e7d858ae3f5d1c30bcfdfa1f022ff42e""; actual = authenticator.createResponse(); "<AssertPlaceHolder>"; }
createResponse() { if (this.realm == null || this.realm.equals("")) { throw new AuthenticationException("realm is empty"); } if (this.nonce == null || this.nonce.equals("")) { throw new AuthenticationException("nonce is empty"); } if (this.uri == null || this.uri.equals("")) { throw new AuthenticationException("uri is empty"); } if (this.method == null || this.method.equals("")) { throw new AuthenticationException("method is empty"); } StringBuilder sb = new StringBuilder(); sb.append(DIGEST_NAME).append(" ") .append("username="").append(this.credential.getUsername()).append("", ") .append("realm="").append(this.realm).append("", ") .append("nonce="").append(this.nonce).append("", ") .append("uri="").append(this.uri).append("", "); if (this.qop == null || this.qop.equals("")) { sb.append("response="").append(this.calculateResponseString()).append("""); } else { sb.append("response="").append(this.calculateResponseString()).append("", ") .append("qop=").append(this.qop).append(", ") .append("nc=").append(String.format("%08X", this.nc)).append(", ") .append("cnonce="").append(this.cnonce).append("""); } return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: rtspDescribeRequestTest() { String expect = "DESCRIBE rtsp://10.3.8.202:554 RTSP/1.0\r\n" + "CSeq: 0\r\n" + "User-Agent: IOT-COMMUNICATION\r\n" + "Accept: application/sdp\r\n" + "\r\n"; URI uri = URI.create("rtsp://10.3.8.202:554"); RtspDescribeRequest request = new RtspDescribeRequest(uri, Collections.singletonList(ERtspAcceptContent.SDP)); request.setCSeq(0); String actual = request.toObjectString(); assertEquals(expect, actual);  expect = "DESCRIBE rtsp://10.3.8.202:554 RTSP/1.0\r\n" + "CSeq: 1\r\n" + "Authorization: Digest username="admin", realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", uri="rtsp://10.3.8.202:554", response="56d55b92e8b41aa6cc1a68a5c2e2de15"\r\n" + "User-Agent: IOT-COMMUNICATION\r\n" + "Accept: application/sdp\r\n" + "\r\n"; request = new RtspDescribeRequest(uri, Collections.singletonList(ERtspAcceptContent.SDP), this.authenticator); request.setCSeq(1); actual = request.toObjectString(); "<AssertPlaceHolder>"; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: rtspSetParameterRequestTest() {  String expect = "SET_PARAMETER rtsp://10.3.8.202:554/ RTSP/1.0\r\n" + "CSeq: 0\r\n" + "Authorization: Digest username="admin", realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", uri="rtsp://10.3.8.202:554", response="56d55b92e8b41aa6cc1a68a5c2e2de15"\r\n" + "User-Agent: IOT-COMMUNICATION\r\n" + "Session: 1273222592\r\n" + "\r\n"; URI uri = URI.create("rtsp://10.3.8.202:554/"); RtspSetParameterRequest request = new RtspSetParameterRequest(uri, "1273222592", this.authenticator); request.setCSeq(0); String actual = request.toObjectString(); assertEquals(expect, actual);  expect = "SET_PARAMETER rtsp://10.3.8.202:554/ RTSP/1.0\r\n" + "CSeq: 1\r\n" + "Authorization: Digest username="admin", realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", uri="rtsp://10.3.8.202:554", response="56d55b92e8b41aa6cc1a68a5c2e2de15"\r\n" + "User-Agent: IOT-COMMUNICATION\r\n" + "Session: 1273222592\r\n" + "Content-Type: text/parameters\r\n" + "Content-Length: 20\r\n" + "\r\n" + "barparam: barstuff\r\n";  uri = URI.create("rtsp://10.3.8.202:554/"); request = new RtspSetParameterRequest(uri, "1273222592", this.authenticator); request.setCSeq(1); request.addParameter("barparam", "barstuff"); actual = request.toObjectString(); "<AssertPlaceHolder>"; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: rtspGetParameterRequestTest() {  String expect = "GET_PARAMETER rtsp://10.3.8.202:554/ RTSP/1.0\r\n" + "CSeq: 0\r\n" + "Authorization: Digest username="admin", realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", uri="rtsp://10.3.8.202:554", response="56d55b92e8b41aa6cc1a68a5c2e2de15"\r\n" + "User-Agent: IOT-COMMUNICATION\r\n" + "Session: 1273222592\r\n" + "\r\n"; URI uri = URI.create("rtsp://10.3.8.202:554/"); RtspGetParameterRequest request = new RtspGetParameterRequest(uri, "1273222592", this.authenticator); request.setCSeq(0); String actual = request.toObjectString(); assertEquals(expect, actual);  expect = "GET_PARAMETER rtsp://10.3.8.202:554/ RTSP/1.0\r\n" + "CSeq: 1\r\n" + "Authorization: Digest username="admin", realm="IP Camera(10789)", nonce="6b9a455aec675b8db81a9ceb802e4eb8", uri="rtsp://10.3.8.202:554", response="56d55b92e8b41aa6cc1a68a5c2e2de15"\r\n" + "User-Agent: IOT-COMMUNICATION\r\n" + "Session: 1273222592\r\n" + "Content-Type: text/parameters\r\n" + "Content-Length: 26\r\n" + "\r\n" + "packets_received\r\n" + "jitter\r\n"; uri = URI.create("rtsp://10.3.8.202:554/"); request = new RtspGetParameterRequest(uri, "1273222592", this.authenticator); request.setCSeq(1); request.addParameter("packets_received"); request.addParameter("jitter"); actual = request.toObjectString(); "<AssertPlaceHolder>"; }
toObjectString() { StringBuilder sb = new StringBuilder(); this.addRequestLine(sb); this.addGeneralHeader(sb); this.addCommonRequestHeader(sb); this.addRequestHeader(sb); this.addEntityHeader(sb); sb.append(CRLF); this.addMessageBody(sb); return sb.toString(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: extractFrom() { String src = "RTP/AVP;unicast;client_port=60802-60803;server_port=8216-8217;ssrc=4f92ef4b;mode="play""; RtspClientPortTransport transport = (RtspClientPortTransport)RtspTransport.fromString(src); assertEquals("RTP/AVP", transport.getProtocol()); assertEquals("unicast", transport.getCastMode()); assertEquals(60802, transport.getRtpClientPort().intValue()); assertEquals(60803, transport.getRtcpClientPort().intValue()); assertEquals(8216, transport.getRtpServerPort().intValue()); assertEquals(8217, transport.getRtcpServerPort().intValue()); assertEquals("4f92ef4b", transport.getSsrc()); assertEquals("play", transport.getMode()); "<AssertPlaceHolder>"; }
toString() { if (this.protocol == null || this.protocol.equals("")) { throw new RtspCommException("protocol of RtspTransport is null or empty"); } if (this.castMode == null || this.castMode.equals("")) { throw new RtspCommException("castMode of RtspTransport is null or empty"); } List<String> res = new ArrayList<>(); res.add(this.protocol); res.add(this.castMode);  if (this.ssrc != null && !this.ssrc.equals("")) { res.add(String.format("ssrc=%s", this.ssrc)); } if (this.mode != null && !this.mode.equals("")) { res.add(String.format("mode="%s"", this.mode)); } return String.join(";", res); }
[*] target: assertEquals(src, transport.toString())
[-] pred: org. junit. Assert. assertEquals ( src, transport. toString ( ) )
************************************
************************************
[+] input: rtspInterleavedTransportTest() { String src = "RTP/AVP/TCP;unicast;interleaved=0-1;ssrc=1fc17e75;mode="play""; RtspInterleavedTransport transport = (RtspInterleavedTransport)RtspTransport.fromString(src); assertEquals("RTP/AVP/TCP", transport.getProtocol()); assertEquals("unicast", transport.getCastMode()); assertEquals(0, transport.getInterleaved1().intValue()); assertEquals(1, transport.getInterleaved2().intValue()); assertEquals("1fc17e75", transport.getSsrc()); assertEquals("play", transport.getMode()); "<AssertPlaceHolder>"; }
toString() { if (this.protocol == null || this.protocol.equals("")) { throw new RtspCommException("protocol of RtspTransport is null or empty"); } if (this.castMode == null || this.castMode.equals("")) { throw new RtspCommException("castMode of RtspTransport is null or empty"); } List<String> res = new ArrayList<>(); res.add(this.protocol); res.add(this.castMode);  if (this.ssrc != null && !this.ssrc.equals("")) { res.add(String.format("ssrc=%s", this.ssrc)); } if (this.mode != null && !this.mode.equals("")) { res.add(String.format("mode="%s"", this.mode)); } return String.join(";", res); }
[*] target: assertEquals(src, transport.toString())
[-] pred: org. junit. Assert. assertEquals ( src, transport. toString ( ) )
************************************
************************************
[+] input: getValue() { boolean b = BooleanUtil.getValue((byte) 0x80, 7); assertTrue(b); b = BooleanUtil.getValue((byte) 0x80, 6); "<AssertPlaceHolder>"; }
getValue(byte data, int bit) { if (bit > 7 || bit < 0) { throw new IndexOutOfBoundsException("0 <= bit <= 7"); } return (((data & 0xFF) & (1 << bit)) != 0); }
[*] target: assertFalse(b)
[-] pred: org. junit. Assert. assertFalse ( b )
************************************
************************************
[+] input: crc16ToByteArray() { byte[] data = new byte[]{(byte) 0x01, (byte) 0x03, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A}; byte[] expect = new byte[]{ (byte) 0xC5,(byte) 0xCD}; byte[] actual = CRCUtil.crc16ToByteArray(data); assertArrayEquals(expect, actual); data = new byte[]{(byte) 0x01, (byte) 0x03, (byte) 0x14, (byte) 0x00, (byte) 0x12, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00}; expect = new byte[]{(byte) 0x1E, (byte) 0x1C}; actual = CRCUtil.crc16ToByteArray(data); "<AssertPlaceHolder>"; }
crc16ToByteArray(byte[] data) { byte high = (byte) 0xFF; byte low = (byte) 0xFF; for (byte datum : data) { int index = (high ^ datum) & 0xFF; high = (byte) (low ^ HIGH_BYTES[index]); low = LOW_BYTES[index]; } return new byte[]{high, low}; }
[*] target: assertArrayEquals(expect, actual)
[-] pred: org. junit. Assert. assertArrayEquals ( expect, actual )
************************************
************************************
[+] input: toHexString() { String expected = "1A 6B DE 8C"; byte[] data = new byte[]{(byte) 0x1A, (byte) 0x6B, (byte) 0xDE, (byte) 0x8C}; String actual = HexUtil.toHexString(data); assertEquals(expected, actual);  expected = "A1 49 AB DF"; data = new byte[]{(byte) 0xA1, (byte) 0x49, (byte) 0xAB, (byte) 0xDF}; actual = HexUtil.toHexString(data); assertEquals(expected, actual);  expected = "A1|49|AB|DF"; data = new byte[]{(byte) 0xA1, (byte) 0x49, (byte) 0xAB, (byte) 0xDF}; actual = HexUtil.toHexString(data,"|"); assertEquals(expected, actual);  expected = "A1-49-AB-DF"; data = new byte[]{(byte) 0xA1, (byte) 0x49, (byte) 0xAB, (byte) 0xDF}; actual = HexUtil.toHexString(data,"-"); assertEquals(expected, actual);  expected = "A1@49@AB@DF"; data = new byte[]{(byte) 0xA1, (byte) 0x49, (byte) 0xAB, (byte) 0xDF}; actual = HexUtil.toHexString(data,"@"); "<AssertPlaceHolder>"; }
toHexString(byte[] src, String splitStr) { return toHexString(src, splitStr, true); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generateAuthorizationCodeResponse() { String url = idsAuthorizationProvider.generateAuthorizationCodeResponse(userInfo, idsRequestParam, clientDetail); System.out.println(url); Assert."<AssertPlaceHolder>"; String params = url.substring(idsRequestParam.getRedirectUri().length() + 1); Map<String, String> obj = ObjectUtils.parseStringToMap(params); Assert.assertEquals(2, obj.size()); Assert.assertTrue(obj.containsKey("code")); Assert.assertTrue(obj.containsKey("state")); }
generateAuthorizationCodeResponse(UserInfo userInfo, IdsRequestParam param, ClientDetail clientDetail) { String authorizationCode = oauth2Service.createAuthorizationCode(param, userInfo, OauthUtil.getCodeExpiresIn(clientDetail.getCodeExpiresIn())); String params = "?code=" + authorizationCode; if (StringUtil.isNotEmpty(param.getState())) { params = params + "&state=" + param.getState(); } return param.getRedirectUri() + params; }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
************************************
[+] input: generateImplicitGrantResponse() { String url = idsAuthorizationProvider.generateImplicitGrantResponse(userInfo, idsRequestParam, clientDetail, issuer); System.out.println(url); Assert."<AssertPlaceHolder>"; String params = url.substring(idsRequestParam.getRedirectUri().length() + 1); Map<String, String> obj = ObjectUtils.parseStringToMap(params); Assert.assertEquals(6, obj.size()); Assert.assertTrue(obj.containsKey("access_token")); Assert.assertTrue(obj.containsKey("scope")); Assert.assertTrue(obj.containsKey("id_token")); Assert.assertTrue(obj.containsKey("state")); Assert.assertTrue(obj.containsKey("token_type")); Assert.assertTrue(obj.containsKey("expires_in")); }
generateImplicitGrantResponse(UserInfo userInfo, IdsRequestParam param, ClientDetail clientDetail, String issuer) { AccessToken accessToken = TokenUtil.createAccessToken(userInfo, clientDetail, param.getGrantType(), param.getScope(), param.getNonce(), issuer); Map<String, String> tokenResponse = new HashMap<>(9); // https://tools.ietf.org/html/rfc6749#section-4.2.2 // The authorization server MUST NOT issue a refresh token. tokenResponse.put(IdsConsts.ACCESS_TOKEN, accessToken.getAccessToken()); tokenResponse.put(IdsConsts.EXPIRES_IN, String.valueOf(OauthUtil.getAccessTokenExpiresIn(clientDetail.getAccessTokenExpiresIn()))); tokenResponse.put(IdsConsts.TOKEN_TYPE, IdsConsts.TOKEN_TYPE_BEARER); tokenResponse.put(IdsConsts.SCOPE, param.getScope()); if (OauthUtil.isOidcProtocol(param.getScope())) { tokenResponse.put(IdsConsts.ID_TOKEN, TokenUtil.createIdToken(clientDetail, userInfo, param.getNonce(), issuer)); } if (StringUtil.isNotEmpty(param.getState())) { tokenResponse.put(IdsConsts.STATE, param.getState()); } String params = ObjectUtils.parseMapToString(tokenResponse, false); return param.getRedirectUri() + "?" + params; }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
************************************
[+] input: generateCodeIdTokenAuthorizationResponse() { String url = idsAuthorizationProvider.generateCodeIdTokenAuthorizationResponse(userInfo, idsRequestParam, clientDetail, issuer); System.out.println(url); Assert."<AssertPlaceHolder>"; String params = url.substring(idsRequestParam.getRedirectUri().length() + 1); Map<String, String> obj = ObjectUtils.parseStringToMap(params); Assert.assertEquals(3, obj.size()); Assert.assertTrue(obj.containsKey("code")); Assert.assertTrue(obj.containsKey("id_token")); Assert.assertTrue(obj.containsKey("state")); }
generateCodeIdTokenAuthorizationResponse(UserInfo userInfo, IdsRequestParam param, ClientDetail clientDetail, String issuer) { String params = "&id_token=" + TokenUtil.createIdToken(clientDetail, userInfo, param.getNonce(), issuer); return this.generateAuthorizationCodeResponse(userInfo, param, clientDetail) + params; }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
************************************
[+] input: generateIdTokenAuthorizationResponse() { String url = idsAuthorizationProvider.generateIdTokenAuthorizationResponse(userInfo, idsRequestParam, clientDetail, issuer); System.out.println(url); Assert."<AssertPlaceHolder>"; String params = url.substring(idsRequestParam.getRedirectUri().length() + 1); Map<String, String> obj = ObjectUtils.parseStringToMap(params); Assert.assertEquals(1, obj.size()); Assert.assertTrue(obj.containsKey("id_token")); }
generateIdTokenAuthorizationResponse(UserInfo userInfo, IdsRequestParam param, ClientDetail clientDetail, String issuer) { String params = "?id_token=" + TokenUtil.createIdToken(clientDetail, userInfo, param, issuer); return param.getRedirectUri() + params; }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
************************************
[+] input: generateIdTokenTokenAuthorizationResponse() { String url = idsAuthorizationProvider.generateIdTokenTokenAuthorizationResponse(userInfo, idsRequestParam, clientDetail, issuer); System.out.println(url); Assert."<AssertPlaceHolder>"; String params = url.substring(idsRequestParam.getRedirectUri().length() + 1); Map<String, String> obj = ObjectUtils.parseStringToMap(params); Assert.assertEquals(2, obj.size()); Assert.assertTrue(obj.containsKey("access_token")); Assert.assertTrue(obj.containsKey("id_token")); }
generateIdTokenTokenAuthorizationResponse(UserInfo userInfo, IdsRequestParam param, ClientDetail clientDetail, String issuer) { AccessToken accessToken = TokenUtil.createAccessToken(userInfo, clientDetail, param.getGrantType(), param.getScope(), param.getNonce(), issuer); String params = "?access_token=" + accessToken.getAccessToken() + "&id_token=" + TokenUtil.createIdToken(clientDetail, userInfo, param.getNonce(), issuer); return param.getRedirectUri() + params; }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
************************************
[+] input: generateCodeTokenAuthorizationResponse() { String url = idsAuthorizationProvider.generateCodeTokenAuthorizationResponse(userInfo, idsRequestParam, clientDetail, issuer); System.out.println(url); Assert."<AssertPlaceHolder>"; String params = url.substring(idsRequestParam.getRedirectUri().length() + 1); Map<String, String> obj = ObjectUtils.parseStringToMap(params); Assert.assertEquals(3, obj.size()); Assert.assertTrue(obj.containsKey("access_token")); Assert.assertTrue(obj.containsKey("code")); Assert.assertTrue(obj.containsKey("state")); }
generateCodeTokenAuthorizationResponse(UserInfo userInfo, IdsRequestParam param, ClientDetail clientDetail, String issuer) { AccessToken accessToken = TokenUtil.createAccessToken(userInfo, clientDetail, param.getGrantType(), param.getScope(), param.getNonce(), issuer); String params = "&access_token=" + accessToken.getAccessToken(); return this.generateAuthorizationCodeResponse(userInfo, param, clientDetail) + params; }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
************************************
[+] input: generateCodeIdTokenTokenAuthorizationResponse() { String url = idsAuthorizationProvider.generateCodeIdTokenTokenAuthorizationResponse(userInfo, idsRequestParam, clientDetail, issuer); System.out.println(url); Assert."<AssertPlaceHolder>"; String params = url.substring(idsRequestParam.getRedirectUri().length() + 1); Map<String, String> obj = ObjectUtils.parseStringToMap(params); Assert.assertEquals(4, obj.size()); Assert.assertTrue(obj.containsKey("code")); Assert.assertTrue(obj.containsKey("state")); Assert.assertTrue(obj.containsKey("access_token")); Assert.assertTrue(obj.containsKey("id_token")); }
generateCodeIdTokenTokenAuthorizationResponse(UserInfo userInfo, IdsRequestParam param, ClientDetail clientDetail, String issuer) { String params = "&id_token=" + TokenUtil.createIdToken(clientDetail, userInfo, param.getNonce(), issuer); return this.generateCodeTokenAuthorizationResponse(userInfo, param, clientDetail, issuer) + params; }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
************************************
[+] input: generateNoneAuthorizationResponse() { String url = idsAuthorizationProvider.generateNoneAuthorizationResponse(idsRequestParam); System.out.println(url); Assert."<AssertPlaceHolder>"; String params = url.substring(idsRequestParam.getRedirectUri().length() + 1); Map<String, String> obj = ObjectUtils.parseStringToMap(params); Assert.assertEquals(1, obj.size()); Assert.assertTrue(obj.containsKey("state")); }
generateNoneAuthorizationResponse(IdsRequestParam param) { String params = ""; if (!StringUtil.isEmpty(param.getState())) { params = "?state=" + param.getState(); } return param.getRedirectUri() + params; }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
************************************
[+] input: getCacheCodeVerifier() { JapCache japCache = new JapLocalCache(); JapAuthentication.setContext(new JapContext().setCache(japCache)); JapAuthentication.getContext().getCache().set("clientId", "111", 111111); String res = PkceHelper.getCacheCodeVerifier("clientId"); Assert."<AssertPlaceHolder>"; Assert.assertEquals("111", res); }
getCacheCodeVerifier(String clientId) { return (String) JapAuthentication.getContext().getCache().get(clientId); }
[*] target: assertNotNull(res)
[-] pred: org. junit. Assert. assertNotNull ( res )
************************************
************************************
[+] input: test4() { try (GetSetMethodHandler getSetMethodHandler = new GetSetMethodHandler(configureWrapper)) { BaseWriteDbData4GetSetMethod getSetMethod1 = getSetMethodHandler.queryGetSetMethodByClassMethod(true, FRADtoA.class.getName(), "getLongA1"); Assert.assertNotNull(getSetMethod1); printObjectContent(getSetMethod1, "queryGetSetMethodByMethodName-get");  BaseWriteDbData4GetSetMethod getSetMethod2 = getSetMethodHandler.queryGetSetMethodByFieldName(true, FRADtoA.class.getName(), "strA1"); Assert."<AssertPlaceHolder>"; printObjectContent(getSetMethod2, "queryGetSetMethodByFieldName-get"); } }
queryGetSetMethodByFieldName(boolean queryGetMethod, String className, String fieldName) { List<BaseWriteDbData4GetSetMethod> list = queryGetSetMethodListByFieldName(queryGetMethod, className, fieldName); if (JavaCGUtil.isCollectionEmpty(list)) { return null; } if (list.size() > 1) { logger.error("类的字段存在多个{}方法 {} {}", (queryGetMethod ? JavaCGConstants.METHOD_PREFIX_GET : JavaCGConstants.METHOD_PREFIX_SET), className, fieldName); } return list.get(0); }
[*] target: assertNotNull(getSetMethod2)
[-] pred: org. junit. Assert. assertNotNull ( getSetMethod2 )
************************************
************************************
[+] input: test5() { try (GetSetMethodHandler getSetMethodHandler = new GetSetMethodHandler(configureWrapper)) { BaseWriteDbData4GetSetMethod getSetMethod1 = getSetMethodHandler.queryGetSetMethodByClassMethod(false, FRADtoA.class.getName(), "setStrA1"); Assert.assertNotNull(getSetMethod1); printObjectContent(getSetMethod1, "queryGetSetMethodByMethodName-set");  BaseWriteDbData4GetSetMethod getSetMethod2 = getSetMethodHandler.queryGetSetMethodByFieldName(false, FRADtoA.class.getName(), "intA1"); Assert."<AssertPlaceHolder>"; printObjectContent(getSetMethod2, "queryGetSetMethodByFieldName-set"); } }
queryGetSetMethodByFieldName(boolean queryGetMethod, String className, String fieldName) { List<BaseWriteDbData4GetSetMethod> list = queryGetSetMethodListByFieldName(queryGetMethod, className, fieldName); if (JavaCGUtil.isCollectionEmpty(list)) { return null; } if (list.size() > 1) { logger.error("类的字段存在多个{}方法 {} {}", (queryGetMethod ? JavaCGConstants.METHOD_PREFIX_GET : JavaCGConstants.METHOD_PREFIX_SET), className, fieldName); } return list.get(0); }
[*] target: assertNotNull(getSetMethod2)
[-] pred: org. junit. Assert. assertNotNull ( getSetMethod2 )
************************************
************************************
[+] input: test6() { try (GetSetMethodHandler getSetMethodHandler = new GetSetMethodHandler(configureWrapper)) { BaseWriteDbData4GetSetMethod getSetMethod1 = getSetMethodHandler.queryGetSetMethodByFieldNameSuper(true, FRCDtoC.class.getName(), "iField1"); Assert.assertNotNull(getSetMethod1); printObjectContent(getSetMethod1, "querySuperGetSetMethodByFieldName-get");  BaseWriteDbData4GetSetMethod getSetMethod2 = getSetMethodHandler.queryGetSetMethodByFieldNameSuper(false, FRCDtoC.class.getName(), "iField1"); Assert."<AssertPlaceHolder>"; printObjectContent(getSetMethod2, "querySuperGetSetMethodByFieldName-set"); } }
queryGetSetMethodByFieldNameSuper(boolean queryGetMethod, String className, String fieldName) { String currentClassName = className; while (true) { BaseWriteDbData4GetSetMethod getSetMethod = queryGetSetMethodByFieldName(queryGetMethod, currentClassName, fieldName); if (getSetMethod != null) { // 检查获取到的get/set方法中的类名，若与指定的类名不同则进行修改 checkClassName(className, getSetMethod); return getSetMethod; } // 当前类未查询到对应的get/set方法，再查询父类的 String superClassName = extendsImplHandler.querySuperClassNameByFull(currentClassName); if (superClassName == null) { return null; } currentClassName = superClassName; } }
[*] target: assertNotNull(getSetMethod2)
[-] pred: org. junit. Assert. assertNotNull ( getSetMethod2 )
************************************
************************************
[+] input: pushNPop() { CustomLinkedList<Integer> linkedList = new CustomLinkedList<>(); assertTrue(linkedList.isEmpty()); linkedList.push(2); linkedList.push(3); linkedList.push(36); linkedList.push(39);  assertThat(linkedList.pop(), is(39)); assertThat(linkedList.pop(), is(36)); assertThat(linkedList.pop(), is(3)); assertFalse(linkedList.isEmpty()); assertThat(linkedList.pop(), is(2)); "<AssertPlaceHolder>"; }
isEmpty() { return size == 0; }
[*] target: assertTrue(linkedList.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( linkedList. isEmpty() )
************************************
************************************
[+] input: pushNPopNRemove() { CustomLinkedList<Integer> linkedList = new CustomLinkedList<>(); linkedList.push(2); linkedList.push(3); linkedList.push(36);    // 36 3 2 assertThat(linkedList.remove(1), is(3));   // 36 2 linkedList.push(39); linkedList.push(43); linkedList.push(45);    // 45 43 39 36 2 assertThat(linkedList.remove(2), is(39));   // 45 43 36 2  assertThat(linkedList.pop(), is(45)); assertThat(linkedList.pop(), is(43)); assertThat(linkedList.pop(), is(36)); assertThat(linkedList.pop(), is(2)); "<AssertPlaceHolder>"; }
isEmpty() { return size == 0; }
[*] target: assertTrue(linkedList.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( linkedList. isEmpty() )
************************************
************************************
[+] input: InvalidMessageException { TimebasedProposalGenerator proposalGenerator = new TimebasedProposalGenerator(); Proposal proposal = proposalGenerator.nextProposal(); Value value = new Protocol.StringValue("test1"); Value svalue = new Protocol.StringValue("test2"); Promise prom = protocol.new Promise(proposal, value, svalue,new Ranking(100, 101), 1, LogEntryType.LOG_VERSION, JEVersion.CURRENT_VERSION); assertEquals(101, prom.getSuggestionRanking().minor);  final String wireFormatNew = prom.wireFormat();  int tieBreaker = wireFormatNew.lastIndexOf(TextProtocol.SEPARATOR); final String wireFormatOld = wireFormatNew.substring(0, tieBreaker);  /* Simulate new node reading old Promise format. */ Promise prom2 = (Promise)protocol.parse(wireFormatOld);  assertEquals(Ranking.UNINITIALIZED.major, prom2.getSuggestionRanking().minor);  TestProtocol.OldPromise oldProm = protocol.new OldPromise(proposal, value, svalue, 100, 1, LogEntryType.LOG_VERSION, JEVersion.CURRENT_VERSION);  /* Simulate old node reading old and new promise formats. */ protocol.replacePromise();  assertEquals(oldProm.wireFormat(), wireFormatOld); TestProtocol.OldPromise oldProm1 = (TestProtocol.OldPromise)protocol.parse(wireFormatOld); TestProtocol.OldPromise oldProm2 = (TestProtocol.OldPromise)protocol.parse(wireFormatNew);  /* verify they check out equal. */ "<AssertPlaceHolder>"; }
parse(String wireFormat); }  /** * A String based value implementation used as the "default" Value */ public static class StringValue extends StringFormatable implements Value {  StringValue() { super(null); }  public StringValue(String s) { super(s); }  @Override public String toString() { return "Value:" + s; }  public String getString() { return s; } }
[*] target: assertEquals(oldProm1, oldProm2)
[-] pred: org. junit. Assert. assertEquals ( oldProm1, oldProm2 )
************************************
************************************
[+] input: testIsNotSet() { AtomicLongComponent comp = new AtomicLongComponent(); assertTrue(comp.isNotSet()); comp.set(3); assertFalse(comp.isNotSet()); comp.clear(); "<AssertPlaceHolder>"; }
isNotSet() { return val.get() == 0; }
[*] target: assertTrue(comp.isNotSet())
[-] pred: org. junit. Assert. assertTrue ( comp. isNotSet() )
************************************
************************************
[+] input: testClear() { ILogger logger = NetworkTaskLog.getLogger(TestRegistry.getContext(), getNetworkTask()); assertNotNull(logger); NetworkTaskLog.clear(); ILogger logger2 = NetworkTaskLog.getLogger(TestRegistry.getContext(), getNetworkTask()); "<AssertPlaceHolder>"; assertNotSame(logger, logger2); }
getLogger(Context context, NetworkTask task) { String key = LogUtil.getLogFileKey(context, task); ILogger logger = loggers.get(key); if (logger == null) { initialize(context, task); logger = loggers.get(key); } return logger; }
[*] target: assertNotNull(logger2)
[-] pred: org. junit. Assert. assertNotNull ( logger2 )
************************************
************************************
[+] input: testPreferenceValues() { PreferenceManager preferenceManager = new PreferenceManager(TestRegistry.getContext()); preferenceManager.setPreferencePingCount(123); preferenceManager.setPreferencePingPackageSize(456); preferenceManager.setPreferenceConnectCount(789); AccessTypeData data = new AccessTypeData(TestRegistry.getContext()); assertEquals(-1, data.getId()); assertEquals(-1, data.getNetworkTaskId()); assertEquals(123, data.getPingCount()); assertEquals(456, data.getPingPackageSize()); assertEquals(789, data.getConnectCount()); preferenceManager.removeAllPreferences(); data = new AccessTypeData(TestRegistry.getContext()); assertEquals(-1, data.getId()); assertEquals(-1, data.getNetworkTaskId()); assertEquals(3, data.getPingCount()); assertEquals(56, data.getPingPackageSize()); "<AssertPlaceHolder>"; }
getConnectCount() { return connectCount; }
[*] target: assertEquals(1, data.getConnectCount())
[-] pred: org. junit. Assert. assertEquals ( 1, data. getConnectCount() )
************************************
************************************
[+] input: testTechnicallyIsEqual() { AccessTypeData data1 = new AccessTypeData(); AccessTypeData data2 = new AccessTypeData(); assertTrue(data1.isTechnicallyEqual(data2)); data1.setId(0); assertTrue(data1.isTechnicallyEqual(data2)); data2.setId(0); assertTrue(data1.isTechnicallyEqual(data2)); data1.setNetworkTaskId(22); assertFalse(data1.isTechnicallyEqual(data2)); data2.setNetworkTaskId(22); assertTrue(data1.isTechnicallyEqual(data2)); data1.setPingCount(123); assertFalse(data1.isTechnicallyEqual(data2)); data2.setPingCount(123); assertTrue(data1.isTechnicallyEqual(data2)); data1.setPingPackageSize(456); assertFalse(data1.isTechnicallyEqual(data2)); data2.setPingPackageSize(456); assertTrue(data1.isTechnicallyEqual(data2)); data1.setConnectCount(789); assertFalse(data1.isTechnicallyEqual(data2)); data2.setConnectCount(789); "<AssertPlaceHolder>"; }
isTechnicallyEqual(AccessTypeData other) { if (other == null || getClass() != other.getClass()) { return false; } if (networktaskid != other.networktaskid) { return false; } if (pingCount != other.pingCount) { return false; } if (pingPackageSize != other.pingPackageSize) { return false; } return Objects.equals(connectCount, other.connectCount); }
[*] target: assertTrue(data1.isTechnicallyEqual(data2))
[-] pred: org. junit. Assert. assertTrue ( data1. isTechnicallyEqual ( data2 ) )
************************************
************************************
[+] input: testInvalidMap() { Map<String, Object> map = new HashMap<>(); map.put("id", "xyz"); map.put("index", "index"); map.put("schedulerid", "abc"); map.put("instances", "abc"); map.put("address", null); map.put("port", "port"); map.put("accessType", -1); map.put("interval", "interval"); map.put("onlyWifi", "fal"); map.put("notification", "tru"); map.put("running", "tru"); map.put("lastScheduled", "xyz"); map.put("failureCount", "zyx"); NetworkTask task = new NetworkTask(map); assertEquals(-1, task.getId()); assertEquals(-1, task.getIndex()); assertEquals(-1, task.getSchedulerId()); assertEquals(0, task.getInstances()); assertNull(task.getAddress()); assertEquals(0, task.getPort()); assertNull(task.getAccessType()); assertEquals(0, task.getInterval()); assertFalse(task.isOnlyWifi()); assertFalse(task.isNotification()); assertFalse(task.isRunning()); assertEquals(-1, task.getLastScheduled()); "<AssertPlaceHolder>"; }
getFailureCount() { return failureCount; }
[*] target: assertEquals(0, task.getFailureCount())
[-] pred: org. junit. Assert. assertEquals ( 0, task. getFailureCount() )
************************************
************************************
[+] input: testEmptyMap() { Map<String, ?> map = new HashMap<>(); SchedulerId schedulerId = new SchedulerId(map); assertEquals(-1, schedulerId.getId()); assertEquals(-1, schedulerId.getSchedulerId()); assertEquals(-1, schedulerId.getTimestamp()); "<AssertPlaceHolder>"; }
isValid() { return valid; }
[*] target: assertFalse(schedulerId.isValid())
[-] pred: org. junit. Assert. assertFalse ( schedulerId. isValid() )
************************************
************************************
[+] input: testInvalidMap() { Map<String, Object> map = new HashMap<>(); map.put("id", "id"); map.put("schedulerid", "schedulerid"); map.put("valid", "valid"); map.put("timestamp", "timestamp"); SchedulerId schedulerId = new SchedulerId(map); assertEquals(-1, schedulerId.getId()); assertEquals(-1, schedulerId.getSchedulerId()); assertEquals(-1, schedulerId.getTimestamp()); "<AssertPlaceHolder>"; }
isValid() { return valid; }
[*] target: assertFalse(schedulerId.isValid())
[-] pred: org. junit. Assert. assertFalse ( schedulerId. isValid() )
************************************
************************************
[+] input: testMapStringValues() { Map<String, Object> map = new HashMap<>(); map.put("id", "1"); map.put("schedulerid", "2"); map.put("valid", "true"); map.put("timestamp", "3"); SchedulerId schedulerId = new SchedulerId(map); assertEquals(1, schedulerId.getId()); assertEquals(2, schedulerId.getSchedulerId()); assertEquals(3, schedulerId.getTimestamp()); "<AssertPlaceHolder>"; }
isValid() { return valid; }
[*] target: assertTrue(schedulerId.isValid())
[-] pred: org. junit. Assert. assertTrue ( schedulerId. isValid() )
************************************
************************************
[+] input: testToBundleDefaultValues() { Time time = new Time(); assertEquals(0, time.getHour()); assertEquals(0, time.getMinute()); PersistableBundle persistableBundle = time.toPersistableBundle(); assertNotNull(persistableBundle); time = new Time(persistableBundle); assertEquals(0, time.getHour()); assertEquals(0, time.getMinute()); Bundle bundle = time.toBundle(); assertNotNull(bundle); time = new Time(bundle); assertEquals(0, time.getHour()); assertEquals(0, time.getMinute()); Map<String, ?> map = time.toMap(); assertNotNull(map); time = new Time(map); assertEquals(0, time.getHour()); "<AssertPlaceHolder>"; }
getMinute() { return minute; }
[*] target: assertEquals(0, time.getMinute())
[-] pred: org. junit. Assert. assertEquals ( 0, time. getMinute() )
************************************
************************************
[+] input: testEmptyMap() { Map<String, ?> map = new HashMap<>(); Time time = new Time(map); assertEquals(0, time.getHour()); "<AssertPlaceHolder>"; }
getMinute() { return minute; }
[*] target: assertEquals(0, time.getMinute())
[-] pred: org. junit. Assert. assertEquals ( 0, time. getMinute() )
************************************
************************************
[+] input: testInvalidMap() { Map<String, Object> map = new HashMap<>(); map.put("hour", "hour"); map.put("minute", "minute"); Time time = new Time(map); assertEquals(0, time.getHour()); "<AssertPlaceHolder>"; }
getMinute() { return minute; }
[*] target: assertEquals(0, time.getMinute())
[-] pred: org. junit. Assert. assertEquals ( 0, time. getMinute() )
************************************
************************************
[+] input: testGetSetRemovePreferenceSuspensionEnabled() { assertTrue(preferenceManager.getPreferenceSuspensionEnabled()); preferenceManager.setPreferenceSuspensionEnabled(false); assertFalse(preferenceManager.getPreferenceSuspensionEnabled()); preferenceManager.removeAllPreferences(); assertTrue(preferenceManager.getPreferenceSuspensionEnabled()); preferenceManager.setPreferenceSuspensionEnabled(false); preferenceManager.removePreferenceSuspensionEnabled(); "<AssertPlaceHolder>"; }
getPreferenceSuspensionEnabled() { Log.d(PreferenceManager.class.getName(), "getPreferenceSuspensionEnabled"); return getPreferenceBoolean(getResources().getString(R.string.suspension_enabled_key), getResources().getBoolean(R.bool.suspension_enabled_default)); }
[*] target: assertTrue(preferenceManager.getPreferenceSuspensionEnabled())
[-] pred: org. junit. Assert. assertTrue ( preferenceManager. getPreferenceSuspensionEnabled ( ) )
************************************
************************************
[+] input: testGetSetRemovePreferenceFileDumpEnabled() { assertFalse(preferenceManager.getPreferenceFileDumpEnabled()); preferenceManager.setPreferenceFileDumpEnabled(true); assertTrue(preferenceManager.getPreferenceFileDumpEnabled()); preferenceManager.removeAllPreferences(); assertFalse(preferenceManager.getPreferenceFileDumpEnabled()); preferenceManager.setPreferenceFileDumpEnabled(true); preferenceManager.removePreferenceFileDumpEnabled(); "<AssertPlaceHolder>"; }
getPreferenceFileDumpEnabled() { Log.d(PreferenceManager.class.getName(), "getPreferenceFileDumpEnabled"); return getPreferenceBoolean(getResources().getString(R.string.file_dump_enabled_key), getResources().getBoolean(R.bool.file_dump_enabled_default)); }
[*] target: assertFalse(preferenceManager.getPreferenceFileDumpEnabled())
[-] pred: org. junit. Assert. assertFalse ( preferenceManager. getPreferenceFileDumpEnabled ( ) )
************************************
************************************
[+] input: testInvalidInput() { parser.parse("xyz"); assertFalse(parser.isValidInput()); parser.parse(getInvalidTestIP4Ping1()); "<AssertPlaceHolder>"; }
isValidInput() { return validInput; }
[*] target: assertFalse(parser.isValidInput())
[-] pred: org. junit. Assert. assertFalse ( parser. isValidInput() )
************************************
************************************
[+] input: testSynchronizeIntervalsAdd() { activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); SuspensionIntervalsDialog intervalsDialog = openSuspensionIntervalsDialog(); onView(isRoot()).perform(waitFor(500)); IntervalHandler handler = new IntervalHandler(getGlobalSettingsActivity(), intervalsDialog); intervalsDialog.getAdapter().addItem(getInterval1()); intervalsDialog.getAdapter().addItem(getInterval2()); intervalsDialog.getAdapter().addItem(getInterval3()); "<AssertPlaceHolder>"; List<Interval> intervals = getIntervalDAO().readAllIntervals(); assertEquals(2, intervals.size()); assertTrue(intervals.get(0).isEqual(getInterval1())); assertTrue(intervals.get(1).isEqual(getInterval2())); }
synchronizeIntervals() { Log.d(IntervalHandler.class.getName(), "synchronizeIntervals"); boolean didChanges = false; try { List<Interval> newIntervals = intervalDialog.getAdapter().getAllItems(); List<Interval> dbIntervals = new ArrayList<>(globalSettingsActivity.getTimeBasedSuspensionScheduler().getIntervals()); for (Interval interval : newIntervals) { Log.d(IntervalHandler.class.getName(), "Processing interval " + interval); if (interval.getId() < 0) { insertInterval(interval); didChanges = true; } else { Interval dbInterval = findById(interval.getId(), dbIntervals); Log.d(IntervalHandler.class.getName(), "Found dbInterval = " + dbInterval); if (dbInterval != null) { if (!interval.isEqual(dbInterval)) { updateInterval(interval); didChanges = true; } dbIntervals.remove(dbInterval); } else { Log.e(IntervalHandler.class.getName(), "No interval with id " + interval.getId() + " found"); } } } for (Interval interval : dbIntervals) { deleteInterval(interval); didChanges = true; } } catch (Exception exc) { Log.e(IntervalHandler.class.getName(), "Error synchronizing intervals.", exc); showErrorDialog(getResources().getString(R.string.text_dialog_general_error_synchronize_intervals)); } return didChanges; }
[*] target: assertTrue(handler.synchronizeIntervals())
[-] pred: org. junit. Assert. assertTrue ( handler. synchronizeIntervals ( ) )
************************************
************************************
[+] input: testSynchronizeIntervalsUpdated() { Interval interval1 = getIntervalDAO().insertInterval(getInterval1()); Interval interval2 = getIntervalDAO().insertInterval(getInterval2()); activityScenario = launchSettingsInputActivity(GlobalSettingsActivity.class); injectTimeBasedSuspensionScheduler(); SuspensionIntervalsDialog intervalsDialog = openSuspensionIntervalsDialog(); onView(isRoot()).perform(waitFor(500)); IntervalHandler handler = new IntervalHandler(getGlobalSettingsActivity(), intervalsDialog); intervalsDialog.getAdapter().removeItems(); Time start1 = new Time(); start1.setHour(5); start1.setMinute(5); Time end1 = new Time(); end1.setHour(6); end1.setMinute(6); interval1.setStart(start1); interval1.setEnd(end1); Time start2 = new Time(); start2.setHour(9); start2.setMinute(9); Time end2 = new Time(); end2.setHour(10); end2.setMinute(10); interval2.setStart(start2); interval2.setEnd(end2); intervalsDialog.getAdapter().addItem(interval1); intervalsDialog.getAdapter().addItem(interval2); "<AssertPlaceHolder>"; List<Interval> intervals = getIntervalDAO().readAllIntervals(); assertEquals(2, intervals.size()); assertFalse(intervals.get(0).isEqual(getInterval1())); assertFalse(intervals.get(1).isEqual(getInterval2())); assertTrue(intervals.get(0).isEqual(interval1)); assertTrue(intervals.get(1).isEqual(interval2)); }
synchronizeIntervals() { Log.d(IntervalHandler.class.getName(), "synchronizeIntervals"); boolean didChanges = false; try { List<Interval> newIntervals = intervalDialog.getAdapter().getAllItems(); List<Interval> dbIntervals = new ArrayList<>(globalSettingsActivity.getTimeBasedSuspensionScheduler().getIntervals()); for (Interval interval : newIntervals) { Log.d(IntervalHandler.class.getName(), "Processing interval " + interval); if (interval.getId() < 0) { insertInterval(interval); didChanges = true; } else { Interval dbInterval = findById(interval.getId(), dbIntervals); Log.d(IntervalHandler.class.getName(), "Found dbInterval = " + dbInterval); if (dbInterval != null) { if (!interval.isEqual(dbInterval)) { updateInterval(interval); didChanges = true; } dbIntervals.remove(dbInterval); } else { Log.e(IntervalHandler.class.getName(), "No interval with id " + interval.getId() + " found"); } } } for (Interval interval : dbIntervals) { deleteInterval(interval); didChanges = true; } } catch (Exception exc) { Log.e(IntervalHandler.class.getName(), "Error synchronizing intervals.", exc); showErrorDialog(getResources().getString(R.string.text_dialog_general_error_synchronize_intervals)); } return didChanges; }
[*] target: assertTrue(handler.synchronizeIntervals())
[-] pred: org. junit. Assert. assertTrue ( handler. synchronizeIntervals ( ) )
************************************
************************************
[+] input: Exception { PropertyGroup pg = new PropertyGroup(obj); String value = pg.getStringProperty("level1|level2|scalars|stringProp"); "<AssertPlaceHolder>"; assertEquals("stringValue", value); }
getStringProperty(String propertyName) throws Exception { return getStringProperty(propertyName, null); }
[*] target: assertNotNull(value)
[-] pred: org. junit. Assert. assertNotNull ( value )
************************************
************************************
[+] input: Exception { PropertyGroup pg = new PropertyGroup(obj); Object[] array = pg.getArrayProperty("level1|level2|arrays|string-array"); "<AssertPlaceHolder>"; assertEquals(2, array.length); assertEquals("one", array[0]); assertEquals("two", array[1]); }
getArrayProperty(String propertyName) throws Exception { Object[] result = null; JsonValue jsonValue = getJsonValue(propertyName); if (jsonValue != null) { if (jsonValue instanceof JsonArray) { result = convertJsonArray((JsonArray) jsonValue); } else { throw new IllegalArgumentException("Property '" + propertyName + "' must be an array"); } } return result; }
[*] target: assertNotNull(array)
[-] pred: org. junit. Assert. assertNotNull ( array )
************************************
************************************
[+] input: testSegmentIoExample1() {  // SOURCE: https://github.com/segmentio/ksuid // // REPRESENTATION: // String: 0ujtsYcgvSTl8PAuAdqWYSMnLOv // Raw: 0669F7EFB5A1CD34B5F99D1154FB6853345C9735 // // COMPONENTS: // // Time: 2017-10-09 21:00:47 -0700 PDT // Timestamp: 107608047 // Payload: B5A1CD34B5F99D1154FB6853345C9735 //  String string = "0ujtsYcgvSTl8PAuAdqWYSMnLOv"; String raw = "0669F7EFB5A1CD34B5F99D1154FB6853345C9735"; Instant instant = Instant.parse("2017-10-10T04:00:47Z"); // UTC long timestamp = 107608047; // KSUID time String payload = "B5A1CD34B5F99D1154FB6853345C9735";  // instantiate a KSUID from bytes byte[] bytes = new BigInteger(raw, 16).toByteArray(); Ksuid ksuid = Ksuid.from(bytes);  // String: 0ujtsYcgvSTl8PAuAdqWYSMnLOv assertEquals(string, ksuid.toString());  // Raw: 0669F7EFB5A1CD34B5F99D1154FB6853345C9735 String raw2 = new BigInteger(1, ksuid.toBytes()).toString(16).toUpperCase(); assertEquals(raw.replaceAll("^0+", ""), raw2);  // Time: 2017-10-09 21:00:47 -0700 PDT assertEquals(instant, ksuid.getInstant());  // Timestamp: 107608047 assertEquals(Ksuid.toUnixTime(timestamp), ksuid.getTime());  // Payload: B5A1CD34B5F99D1154FB6853345C9735 String payload2 = new BigInteger(1, ksuid.getPayload()).toString(16).toUpperCase(); "<AssertPlaceHolder>"; }
getPayload() { final byte[] copy = new byte[PAYLOAD_BYTES]; System.arraycopy(this.payload, 0, copy, 0, PAYLOAD_BYTES); return copy; }
[*] target: assertEquals(payload, payload2)
[-] pred: org. junit. Assert. assertEquals ( payload, payload2 )
************************************
************************************
[+] input: testHealthyAndDead() { System.setProperty(DashboardConfig.CONFIG_UNHEALTHY_MACHINE_MILLIS, "60000"); System.setProperty(DashboardConfig.CONFIG_AUTO_REMOVE_MACHINE_MILLIS, "600000"); DashboardConfig.clearCache(); MachineInfo machineInfo = new MachineInfo(); machineInfo.setHeartbeatVersion(1); machineInfo.setLastHeartbeat(System.currentTimeMillis() - 10000); assertTrue(machineInfo.isHealthy()); assertFalse(machineInfo.isDead());  machineInfo.setLastHeartbeat(System.currentTimeMillis() - 100000); assertFalse(machineInfo.isHealthy()); assertFalse(machineInfo.isDead());  machineInfo.setLastHeartbeat(System.currentTimeMillis() - 1000000); assertFalse(machineInfo.isHealthy()); "<AssertPlaceHolder>"; }
isDead() { if (DashboardConfig.getAutoRemoveMachineMillis() > 0) { long delta = System.currentTimeMillis() - lastHeartbeat; return delta > DashboardConfig.getAutoRemoveMachineMillis(); } return false; }
[*] target: assertTrue(machineInfo.isDead())
[-] pred: org. junit. Assert. assertTrue ( machineInfo. isDead() )
************************************
************************************
[+] input: InterruptedException { DbTable table = DataBase.getInstance().getDbTableByName("t_person"); ExecutorService threadPool = Executors.newCachedThreadPool(); int threadNum = 2; ArrayList<Future<Page>> futureResult = new ArrayList<>(); HeapPageID heapPageID = new HeapPageID(table.getTableId(), 0);  Transaction transaction = new Transaction(Lock.LockType.SLock); Future<Page> pageFuture = threadPool.submit(() -> { Connection.passingTransaction(transaction); return DataBase.getBufferPool().getPage(heapPageID); }); futureResult.add(pageFuture);  transaction.setLockType(Lock.LockType.XLock); Future<Page> pageFuture2 = threadPool.submit(() -> { Connection.passingTransaction(transaction); return DataBase.getBufferPool().getPage(heapPageID); }); futureResult.add(pageFuture2);  Thread.sleep(100); // 锁应升级为x锁,新的事务获取应获取不到 Transaction transaction3 = new Transaction(Lock.LockType.SLock); Future<Page> pageFuture3 = threadPool.submit(() -> { Connection.passingTransaction(transaction3); return DataBase.getBufferPool().getPage(heapPageID); }); futureResult.add(pageFuture3);  // 1获取锁成功 Page page = futureResult.get(0).get(); "<AssertPlaceHolder>";  // 2获取锁成功 Page page2 = futureResult.get(1).get(); assertNotNull(page2);  // 线程3获取锁失败 try { futureResult.get(2).get(1, TimeUnit.SECONDS); fail("expected timeout"); } catch (Exception ignored) { }   // 终止所有线程 threadPool.shutdownNow(); }
setLockType(LockType lockType) { this.lockType = lockType; }
[*] target: assertNotNull(page)
[-] pred: org. junit. Assert. assertNotNull ( page )
************************************
************************************
[+] input: InterruptedException { DbTable table = DataBase.getInstance().getDbTableByName("t_person"); ExecutorService threadPool = Executors.newCachedThreadPool(); int threadNum = 2; ArrayList<Future<Page>> futureResult = new ArrayList<>(); HeapPageID heapPageID = new HeapPageID(table.getTableId(), 0);  Transaction transaction = new Transaction(Lock.LockType.XLock); Future<Page> pageFuture = threadPool.submit(() -> { Connection.passingTransaction(transaction); return DataBase.getBufferPool().getPage(heapPageID); }); futureResult.add(pageFuture);   Thread.sleep(100); transaction.setLockType(Lock.LockType.SLock); Future<Page> pageFuture2 = threadPool.submit(() -> { Connection.passingTransaction(transaction); return DataBase.getBufferPool().getPage(heapPageID); }); futureResult.add(pageFuture2);  Thread.sleep(100); // 锁应保持为x锁,新的事务获取应获取不到锁 Transaction transaction3 = new Transaction(Lock.LockType.SLock); Future<Page> pageFuture3 = threadPool.submit(() -> { Connection.passingTransaction(transaction3); return DataBase.getBufferPool().getPage(heapPageID); }); futureResult.add(pageFuture3);  // 1获取锁成功 Page page = futureResult.get(0).get(); "<AssertPlaceHolder>";  // 2获取锁成功 Page page2 = futureResult.get(1).get(); assertNotNull(page2);  // 线程3获取锁失败 try { futureResult.get(2).get(1, TimeUnit.SECONDS); fail("expected timeout"); } catch (Exception ignored) { }  // 终止所有线程 threadPool.shutdownNow(); }
setLockType(LockType lockType) { this.lockType = lockType; }
[*] target: assertNotNull(page)
[-] pred: org. junit. Assert. assertNotNull ( page )
************************************
************************************
[+] input: testToString() { Field f = new Field("aliases", "string[]", true, false); assertEquals("Field [name=aliases, type=string[], isArray=true, required=false]", f.toString()); "<AssertPlaceHolder>"; }
isArray() { return isArray; }
[*] target: assertTrue(f.isArray())
[-] pred: org. junit. Assert. assertTrue ( f. isArray() )
************************************
************************************
[+] input: ExecutionException { String openhufuRoot = System.getenv("OPENHUFU_ROOT"); Path libDir = Paths.get(openhufuRoot, "lib"); Map<ProtocolType, ProtocolFactory> factories = LibraryLoader.loadProtocolLibrary(libDir.toString()); ProtocolFactory factory = factories.get(ProtocolType.ABY); ProtocolExecutor aby0 = factory.create( OwnerInfo.newBuilder().setEndpoint("127.0.0.1:7766").setId(0).build(), ProtocolType.ABY); "<AssertPlaceHolder>"; ProtocolExecutor aby1 = factory.create( OwnerInfo.newBuilder().setEndpoint("127.0.0.1:7766").setId(1).build(), ProtocolType.ABY); assertNotNull(aby1); ExecutorService service = Executors.newFixedThreadPool(2); final int A = 40; final int B = 30; final boolean expect = A > B; Future<Boolean> r0 = service.submit(new Callable<Boolean>() { @Override public Boolean call() throws Exception { LOG.info("0 call"); List<byte[]> res = (List<byte[]>) aby0.run(0, ImmutableList.of(0), ImmutableList.of(OpenHuFuCodec.encodeInt(A)), OperatorType.GT, ColumnType.INT, "127.0.0.1", 7766, false); return OpenHuFuCodec.decodeBoolean(res.get(0)); } }); Future<Boolean> r1 = service.submit(new Callable<Boolean>() { @Override public Boolean call() throws Exception { LOG.info("1 call"); List<byte[]> res = (List<byte[]>) aby1.run(0, ImmutableList.of(1), ImmutableList.of(OpenHuFuCodec.encodeInt(B)), OperatorType.GT, ColumnType.INT, "127.0.0.1", 7766, false); return OpenHuFuCodec.decodeBoolean(res.get(0)); } }); assertEquals(expect, r0.get()); assertEquals(expect, r1.get()); }
loadProtocolLibrary(String libDir) { LOG.info("Load library from {}", libDir); File libJars[]= new File(libDir).listFiles(new FileFilter() { @Override public boolean accept(File file) { return file.getName().endsWith(".jar"); } }); List<URL> libURLs = new ArrayList<>(); for (File libJar : libJars) { try { libURLs.add(libJar.toURI().toURL()); LOG.info("Add JAR {}", libJar.getAbsolutePath()); } catch (Exception e) { LOG.error("Add JAR {} error", libJar.getAbsolutePath(), e); } } ClassLoader libClassLoader = new URLClassLoader(libURLs.toArray(new URL[0]), ProtocolFactory.class.getClassLoader()); ServiceLoader<ProtocolFactory> libs = ServiceLoader.load(ProtocolFactory.class, libClassLoader); ImmutableMap.Builder<ProtocolType, ProtocolFactory> builder = ImmutableMap.builder(); for (ProtocolFactory lib : libs) { LOG.info("Load library of protocol {}", lib.getType()); builder.put(lib.getType(), lib); } try { return builder.build(); } catch (IllegalArgumentException e) { LOG.error("Duplicate protocol type found: {}", e.getMessage()); return ImmutableMap.of(); } }
[*] target: assertNotNull(aby0)
[-] pred: org. junit. Assert. assertNotNull ( aby0 )
************************************
************************************
[+] input: testWriteDate() { JdkValueWriter jdkValueWriter = new JdkValueWriter(); Date date = new Date(1420114230123l); Generator generator = Mockito.mock(Generator.class); ArgumentCaptor<String> argument = ArgumentCaptor.forClass(String.class); jdkValueWriter.doWrite(date, generator, ""); Mockito.verify(generator).writeString(argument.capture()); String expected = date.toInstant().atZone(ZoneId.systemDefault()).toOffsetDateTime().toString(); String actual = argument.getValue(); "<AssertPlaceHolder>"; OffsetDateTime parsedDate = DateTimeFormatter.ISO_OFFSET_DATE_TIME.parse(actual, OffsetDateTime::from); assertEquals(123000000, parsedDate.getNano()); //Nothing beyond milliseconds }
doWrite(Object value, Generator generator, String parentField) { if (value == null) { generator.writeNull(); } else if (value instanceof String) { generator.writeString((String) value); } else if (value instanceof Integer) { generator.writeNumber(((Integer) value).intValue()); } else if (value instanceof Long) { generator.writeNumber(((Long) value).longValue()); } else if (value instanceof Float) { generator.writeNumber(((Float) value).floatValue()); } else if (value instanceof Double) { generator.writeNumber(((Double) value).doubleValue()); } else if (value instanceof Short) { generator.writeNumber(((Short) value).shortValue()); } else if (value instanceof Byte) { generator.writeNumber(((Byte) value).byteValue()); } // Big Decimal/Integer else if (value instanceof Number) { // check double vs long Number n = ((Number) value); double d = n.doubleValue(); if (Math.floor(d) == d) { generator.writeNumber(n.longValue()); } else { generator.writeNumber(d); } } else if (value instanceof Boolean) { generator.writeBoolean(((Boolean) value).booleanValue()); } else if (value instanceof byte[]) { generator.writeBinary((byte[]) value); } else if (value.getClass().isArray()) { generator.writeBeginArray(); for (Object o : ObjectUtils.toObjectArray(value)) { Result result = doWrite(o, generator, parentField); if (!result.isSuccesful()) { return result; } } generator.writeEndArray(); } else if (value instanceof Map) { generator.writeBeginObject(); for (Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) { String fieldName = entry.getKey().toString(); // filter out fields if (shouldKeep(parentField, fieldName)) { generator.writeFieldName(fieldName); Result result = doWrite(entry.getValue(), generator, fieldName); if (!result.isSuccesful()) { return result; } } } generator.writeEndObject(); } else if (value instanceof Iterable) { generator.writeBeginArray(); for (Object o : (Iterable<?>) value) { Result result = doWrite(o, generator, parentField); if (!result.isSuccesful()) { return result; } } generator.writeEndArray(); } else if (value instanceof Timestamp) { Timestamp timestamp = (Timestamp) value; long epochSeconds = timestamp.getTime() / 1000; // Getting rid of millisconds because they're captured in timestamp.getNanos() Instant instant = Instant.ofEpochSecond(epochSeconds, timestamp.getNanos()); OffsetDateTime offsetDateTime = OffsetDateTime.ofInstant(instant, ZoneId.systemDefault()); generator.writeString(DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(offsetDateTime)); } else if (value instanceof Date) { Calendar cal = Calendar.getInstance(); cal.setTime((Date) value); generator.writeString(DatatypeConverter.printDateTime(cal)); } else if (value instanceof Calendar) { generator.writeString(DatatypeConverter.printDateTime((Calendar) value)); } else { if (writeUnknownTypes) { return handleUnknown(value, generator); } return Result.FAILED(value); } return Result.SUCCESFUL(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testWriteDateWithNanos() { JdkValueWriter jdkValueWriter = new JdkValueWriter(); Timestamp timestamp = new Timestamp(1420114230123l); timestamp.setNanos(123456789); Generator generator = Mockito.mock(Generator.class); ArgumentCaptor<String> argument = ArgumentCaptor.forClass(String.class); jdkValueWriter.doWrite(timestamp, generator, ""); Mockito.verify(generator).writeString(argument.capture()); String expected = timestamp.toInstant().atZone(ZoneId.systemDefault()).toOffsetDateTime().toString(); String actual = argument.getValue(); "<AssertPlaceHolder>"; OffsetDateTime parsedDate = DateTimeFormatter.ISO_OFFSET_DATE_TIME.parse(actual, OffsetDateTime::from); assertEquals(123456789, parsedDate.getNano()); }
doWrite(Object value, Generator generator, String parentField) { if (value == null) { generator.writeNull(); } else if (value instanceof String) { generator.writeString((String) value); } else if (value instanceof Integer) { generator.writeNumber(((Integer) value).intValue()); } else if (value instanceof Long) { generator.writeNumber(((Long) value).longValue()); } else if (value instanceof Float) { generator.writeNumber(((Float) value).floatValue()); } else if (value instanceof Double) { generator.writeNumber(((Double) value).doubleValue()); } else if (value instanceof Short) { generator.writeNumber(((Short) value).shortValue()); } else if (value instanceof Byte) { generator.writeNumber(((Byte) value).byteValue()); } // Big Decimal/Integer else if (value instanceof Number) { // check double vs long Number n = ((Number) value); double d = n.doubleValue(); if (Math.floor(d) == d) { generator.writeNumber(n.longValue()); } else { generator.writeNumber(d); } } else if (value instanceof Boolean) { generator.writeBoolean(((Boolean) value).booleanValue()); } else if (value instanceof byte[]) { generator.writeBinary((byte[]) value); } else if (value.getClass().isArray()) { generator.writeBeginArray(); for (Object o : ObjectUtils.toObjectArray(value)) { Result result = doWrite(o, generator, parentField); if (!result.isSuccesful()) { return result; } } generator.writeEndArray(); } else if (value instanceof Map) { generator.writeBeginObject(); for (Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) { String fieldName = entry.getKey().toString(); // filter out fields if (shouldKeep(parentField, fieldName)) { generator.writeFieldName(fieldName); Result result = doWrite(entry.getValue(), generator, fieldName); if (!result.isSuccesful()) { return result; } } } generator.writeEndObject(); } else if (value instanceof Iterable) { generator.writeBeginArray(); for (Object o : (Iterable<?>) value) { Result result = doWrite(o, generator, parentField); if (!result.isSuccesful()) { return result; } } generator.writeEndArray(); } else if (value instanceof Timestamp) { Timestamp timestamp = (Timestamp) value; long epochSeconds = timestamp.getTime() / 1000; // Getting rid of millisconds because they're captured in timestamp.getNanos() Instant instant = Instant.ofEpochSecond(epochSeconds, timestamp.getNanos()); OffsetDateTime offsetDateTime = OffsetDateTime.ofInstant(instant, ZoneId.systemDefault()); generator.writeString(DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(offsetDateTime)); } else if (value instanceof Date) { Calendar cal = Calendar.getInstance(); cal.setTime((Date) value); generator.writeString(DatatypeConverter.printDateTime(cal)); } else if (value instanceof Calendar) { generator.writeString(DatatypeConverter.printDateTime((Calendar) value)); } else { if (writeUnknownTypes) { return handleUnknown(value, generator); } return Result.FAILED(value); } return Result.SUCCESFUL(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { InputStream inputStream = IOUtils.open("org/opensearch/hadoop/util/textdata.txt"); "<AssertPlaceHolder>";  BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); assertEquals("Hello World. This is used by IOUtilsTest.", reader.readLine()); }
open(String location) { return open(location, null); }
[*] target: assertNotNull(inputStream)
[-] pred: org. junit. Assert. assertNotNull ( inputStream )
************************************
************************************
[+] input: Exception { File tempFile = File.createTempFile("textdata", "txt"); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile))); writer.write("Hello World. This is used by IOUtilsTest."); writer.close();  InputStream inputStream = IOUtils.open(tempFile.toURI().toURL().toString()); "<AssertPlaceHolder>";  BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); assertEquals("Hello World. This is used by IOUtilsTest.", reader.readLine()); }
open(String location) { return open(location, null); }
[*] target: assertNotNull(inputStream)
[-] pred: org. junit. Assert. assertNotNull ( inputStream )
************************************
************************************
[+] input: canDeserializeSourceAsString() { String json = "{"query":{"match_all":{}},"_source":"_id","size":1}";  SearchRequest searchRequest = fromJson(json, SearchRequest._DESERIALIZER);  SourceConfig _source = searchRequest.source(); assertNotNull(_source); assertTrue(_source.isFilter());  SourceFilter filter = _source.filter(); assertNotNull(filter);  List<String> includes = filter.includes(); "<AssertPlaceHolder>"; assertEquals("_id", includes.get(0));  assertTrue(filter.excludes().isEmpty()); }
size() { return this.size; }
[*] target: assertEquals(1, includes.size())
[-] pred: org. junit. Assert. assertEquals ( 1, includes. size ( ) )
************************************
************************************
[+] input: canDeserializeSourceAsArray() { String json = "{"query":{"match_all":{}},"_source":["_id"],"size":1}";  SearchRequest searchRequest = fromJson(json, SearchRequest._DESERIALIZER);  SourceConfig _source = searchRequest.source(); assertNotNull(_source); assertTrue(_source.isFilter());  SourceFilter filter = _source.filter(); assertNotNull(filter);  List<String> includes = filter.includes(); "<AssertPlaceHolder>"; assertEquals("_id", includes.get(0));  assertTrue(filter.excludes().isEmpty()); }
size() { return this.size; }
[*] target: assertEquals(1, includes.size())
[-] pred: org. junit. Assert. assertEquals ( 1, includes. size ( ) )
************************************
************************************
[+] input: canDeserializeSourceAsObject() { String json = "{"query":{"match_all":{}},"_source":{"includes":["_id"]},"size":1}";  SearchRequest searchRequest = fromJson(json, SearchRequest._DESERIALIZER);  SourceConfig _source = searchRequest.source(); assertNotNull(_source); assertTrue(_source.isFilter());  SourceFilter filter = _source.filter(); assertNotNull(filter);  List<String> includes = filter.includes(); "<AssertPlaceHolder>"; assertEquals("_id", includes.get(0));  assertTrue(filter.excludes().isEmpty()); }
size() { return this.size; }
[*] target: assertEquals(1, includes.size())
[-] pred: org. junit. Assert. assertEquals ( 1, includes. size ( ) )
************************************
************************************
[+] input: testDisableAutoDetectClient() { OptionsMetadata options = new OptionsMetadata(new String[] {"-p p", "-i i"}); assertTrue(options.shouldAutoDetectClient());  options = new OptionsMetadata(new String[] {"-p p", "-i i", "-disable_auto_detect_client"}); "<AssertPlaceHolder>"; }
shouldAutoDetectClient() { return !this.disableAutoDetectClient; }
[*] target: assertFalse(options.shouldAutoDetectClient())
[-] pred: org. junit. Assert. assertFalse ( options. shouldAutoDetectClient() )
************************************
************************************
[+] input: testDeprecatedBinaryFormat() { PrintStream originalOut = System.out; try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); System.setOut(new PrintStream(outputStream)); OptionsMetadata options = new OptionsMetadata(new String[] {"-p p", "-i i", "-b"}); "<AssertPlaceHolder>";  assertEquals( "Forcing the server to return results using the binary format is a violation " + "of the PostgreSQL wire-protocol. Using this option can cause unexpected errors.\nIt is " + "recommended not to use the -b option." + System.lineSeparator(), outputStream.toString()); } finally { System.setOut(originalOut); } }
isBinaryFormat() { return this.binaryFormat; }
[*] target: assertTrue(options.isBinaryFormat())
[-] pred: org. junit. Assert. assertTrue ( options. isBinaryFormat() )
************************************
************************************
[+] input: testDisablePgCatalogReplacements() { OptionsMetadata options = new OptionsMetadata(new String[] {"-p p", "-i i"}); assertTrue(options.replacePgCatalogTables());  options = new OptionsMetadata(new String[] {"-p p", "-i i", "-disable_pg_catalog_replacements"}); "<AssertPlaceHolder>"; }
replacePgCatalogTables() { return !this.disablePgCatalogReplacements; }
[*] target: assertFalse(options.replacePgCatalogTables())
[-] pred: org. junit. Assert. assertFalse ( options. replacePgCatalogTables ( ) )
************************************
************************************
[+] input: IOException { PipedOutputStream pipedOutputStream = new PipedOutputStream(); BinaryCopyParser parser = new BinaryCopyParser(new PipedInputStream(pipedOutputStream, 256));  DataOutputStream data = new DataOutputStream(pipedOutputStream); data.write(COPY_BINARY_HEADER); data.writeInt(0); data.writeInt(0);  // Write a tuple. data.writeShort(2); data.writeInt(10); data.write(new byte[10]); data.writeInt(4); data.writeInt(100); // Then write the trailer. data.writeShort(-1);  Iterator<CopyRecord> iterator = parser.iterator(); assertTrue(iterator.hasNext()); iterator.next(); "<AssertPlaceHolder>"; }
hasNext() { try { // The hasNext status is UNKNOWN if a call to next() has been executed since the last time // hasNext() was called, or if this is the first time hasNext() is called. if (hasNext == HasNext.UNKNOWN) { // The first value in a row is the number of fields in that row. The value will be -1 for // the last tuple (this is the file trailer). The value should be the same for all other // rows. short fieldCount = dataInputStream.readShort(); if (fieldCount == -1) { logger.log(Level.FINE, "End of copy file: -1"); hasNext = HasNext.NO; } else if (fieldCount > -1) { if (firstRowFieldCount == -1) { firstRowFieldCount = fieldCount; currentRow = new BinaryField[fieldCount]; } else if (firstRowFieldCount != fieldCount) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, String.format( "Invalid field count encountered: %d, expected %d", fieldCount, firstRowFieldCount)); } hasNext = HasNext.YES; } else { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, String.format("Invalid field count encountered: %d", fieldCount)); } } return hasNext == HasNext.YES; } catch (EOFException eofException) { // The protocol specifies that the stream should contain a -1 as the trailer in the file, // but it seems that some clients do not include this. logger.log(Level.FINE, "EOF in BinaryCopyParser"); hasNext = HasNext.NO; return false; } catch (IOException ioException) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.INTERNAL, ioException.getMessage(), ioException); } }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext() )
************************************
************************************
[+] input: IOException { PipedOutputStream pipedOutputStream = new PipedOutputStream(); BinaryCopyParser parser = new BinaryCopyParser(new PipedInputStream(pipedOutputStream, 256));  DataOutputStream data = new DataOutputStream(pipedOutputStream); data.write(COPY_BINARY_HEADER); data.writeInt(0); data.writeInt(0);  // Write the trailer indicator to indicate that there are no more rows. data.writeShort(-1);  Iterator<CopyRecord> iterator = parser.iterator(); "<AssertPlaceHolder>"; assertThrows(NoSuchElementException.class, iterator::next); }
hasNext() { try { // The hasNext status is UNKNOWN if a call to next() has been executed since the last time // hasNext() was called, or if this is the first time hasNext() is called. if (hasNext == HasNext.UNKNOWN) { // The first value in a row is the number of fields in that row. The value will be -1 for // the last tuple (this is the file trailer). The value should be the same for all other // rows. short fieldCount = dataInputStream.readShort(); if (fieldCount == -1) { logger.log(Level.FINE, "End of copy file: -1"); hasNext = HasNext.NO; } else if (fieldCount > -1) { if (firstRowFieldCount == -1) { firstRowFieldCount = fieldCount; currentRow = new BinaryField[fieldCount]; } else if (firstRowFieldCount != fieldCount) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, String.format( "Invalid field count encountered: %d, expected %d", fieldCount, firstRowFieldCount)); } hasNext = HasNext.YES; } else { throw SpannerExceptionFactory.newSpannerException( ErrorCode.FAILED_PRECONDITION, String.format("Invalid field count encountered: %d", fieldCount)); } } return hasNext == HasNext.YES; } catch (EOFException eofException) { // The protocol specifies that the stream should contain a -1 as the trailer in the file, // but it seems that some clients do not include this. logger.log(Level.FINE, "EOF in BinaryCopyParser"); hasNext = HasNext.NO; return false; } catch (IOException ioException) { throw SpannerExceptionFactory.newSpannerException( ErrorCode.INTERNAL, ioException.getMessage(), ioException); } }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext ( ) )
************************************
************************************
[+] input: IOException { CSVFormat format = CSVFormat.POSTGRESQL_TEXT;  PipedOutputStream payload = new PipedOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(payload, StandardCharsets.UTF_8);  PipedInputStream inputStream = new PipedInputStream(payload); Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);  CSVParser parser = CSVParser.parse(reader, format); // Pass in 2 complete and one incomplete record. It should be possible to parse the two first // records without problems. String records = "1\tOne\n2\tTwo\n3\t"; writer.write(records); writer.flush();  // Get an iterator for the parser and get the first two records. Iterator<CSVRecord> iterator = parser.iterator(); assertTrue(iterator.hasNext()); CSVRecord record = iterator.next(); assertEquals("1", record.get(0)); assertEquals("One", record.get(1));  assertTrue(iterator.hasNext()); record = iterator.next(); assertEquals("2", record.get(0)); assertEquals("Two", record.get(1));  // Calling iterator.hasNext() or iterator.next() would now block, as there is not enough data // to build another record. // Add the missing pieces for the last record and parse that as well. writer.write("Three\n"); writer.close();  "<AssertPlaceHolder>"; record = iterator.next(); assertEquals("3", record.get(0)); assertEquals("Three", record.get(1));  // There are no more records as the writer has been closed. assertFalse(iterator.hasNext()); }
close() throws IOException { this.payload.close(); this.closedLatch.countDown(); this.dataReceivedLatch.countDown(); }
[*] target: assertTrue(iterator.hasNext())
[-] pred: org. junit. Assert. assertTrue ( iterator. hasNext ( ) )
************************************
************************************
[+] input: listFilesTest() { List<CdcFile> files = fileSystem.listAllFiles(); List<String> actual = new ArrayList<>(); for (CdcFile file : files) { actual.add(file.getName()); } List<String> expect = new ArrayList<>(); int n = 15; for (int i = 1; i < n; i++) { expect.add(binlogFilePrefix + String.format("%06d", i)); } boolean expectTrue = ListUtils.isEqualList(expect, actual); Assert.assertTrue(expectTrue); files = fileSystem.listAllFiles(); actual.clear(); for (CdcFile file : files) { actual.add(file.getName()); } expectTrue = ListUtils.isEqualList(expect, actual); Assert."<AssertPlaceHolder>"; }
listAllFiles() { Map<String, CdcFile> fileMap = getLocalFileMap(); if (remoteFileSystem != null) { List<CdcFile> remoteFiles = listRemoteFiles(); for (CdcFile f : remoteFiles) { if (fileMap.containsKey(f.getName())) { fileMap.get(f.getName()).setRecord(f.getRecord()); } else { fileMap.putIfAbsent(f.getName(), f); } } } ArrayList<CdcFile> res = new ArrayList<>(fileMap.values()); res.sort(CdcFile::compareTo); return res; }
[*] target: assertTrue(expectTrue)
[-] pred: org. junit. Assert. assertTrue ( expectTrue )
************************************
************************************
[+] input: IOException { String fileName = "size-test.txt"; String content = "size_test"; long expect = -1; long actual = fileSystem.size(fileName); Assert.assertEquals(expect, actual); File f = fileSystem.newFile(fileName); f.createNewFile(); FileOutputStream fos = new FileOutputStream(f); fos.write(content.getBytes()); expect = content.length(); actual = fileSystem.size(fileName); Assert."<AssertPlaceHolder>"; }
size(String fileName) { if (exist(fileName)) { return newFile(fileName).length(); } return -1; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: IOException { String fileName = "get-channel-test.txt"; BinlogFileReadChannel channel = fileSystem.getReadChannel(fileName); Assert.assertNull(channel); String content = "Darkness travels towards light, " + "but blindness towards death."; File f = fileSystem.newFile(fileName); f.createNewFile(); FileOutputStream fos = new FileOutputStream(f); fos.write(content.getBytes()); channel = fileSystem.getReadChannel(fileName); byte[] data = new byte[1024]; ByteBuffer buffer = ByteBuffer.wrap(data); channel.read(buffer); buffer.flip(); String actual = new String(buffer.array(), 0, buffer.limit()); Assert."<AssertPlaceHolder>"; }
getReadChannel(String fileName) throws IOException { if (exist(fileName)) { FileInputStream is = new FileInputStream(getFullName(fileName)); return new BinlogFileReadChannel(is.getChannel(), is); } return null; }
[*] target: assertEquals(content, actual)
[-] pred: org. junit. Assert. assertEquals ( content, actual )
************************************
************************************
[+] input: getNextBinlogFileNameTest() { // 单流测试 String groupName = GROUP_NAME_GLOBAL; String streamName = STREAM_NAME_GLOBAL; String fileName = getFirstBinlogFileName(groupName, streamName); int randomSeq = new Random().nextInt(BINLOG_FILE_NAME_MAX_SEQUENCE); for (int i = 1; i < randomSeq; i++) { fileName = getNextBinlogFileName(fileName); } String expectedFileName = getBinlogFileNameBySequence(groupName, streamName, randomSeq); assertEquals(expectedFileName, fileName); // 多流测试 groupName = "group1"; streamName = "stream1"; fileName = getFirstBinlogFileName(groupName, streamName); for (int i = 1; i < randomSeq; i++) { fileName = getNextBinlogFileName(fileName); } expectedFileName = getBinlogFileNameBySequence(groupName, streamName, randomSeq); "<AssertPlaceHolder>"; }
getBinlogFileNameBySequence(String groupName, String streamName, int seq) { if (seq <= 0 || BINLOG_FILE_NAME_MAX_SEQUENCE < seq) { throw new PolardbxException("invalid binlog file name sequence " + seq); } String prefix = getBinlogFilePrefix(groupName, streamName); String suffix = String.format(BINLOG_FILE_NAME_SUFFIX_FORMAT, seq); return prefix + BINLOG_FILE_NAME_SEPARATOR + suffix; }
[*] target: assertEquals(expectedFileName, fileName)
[-] pred: org. junit. Assert. assertEquals ( expectedFileName, fileName )
************************************
************************************
[+] input: getConfigNameTest() { String configName = "binlogx_stream_group_name"; String expect = "binlogx.stream.group.name"; String actual = ConfigNameMap.getOldConfigName(configName); Assert.assertEquals(expect, actual);  configName = "not_exist_config"; expect = ""; actual = ConfigNameMap.getOldConfigName(configName); Assert."<AssertPlaceHolder>"; }
getOldConfigName(String newConfigName) { return StringUtils.defaultIfBlank(CONFIG_MAP.get(newConfigName), ""); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: IOException { // 测试从某个指定的位置读取一次 long fileSize = localChannel.size(); ByteBuffer buffer1 = ByteBuffer.allocate(1024); ByteBuffer buffer2 = ByteBuffer.allocate(1024); int readLen1; int readLen2; CRC32 localCrc = new CRC32(); CRC32 ossCrc = new CRC32();  // 随机测试100次 for (int i = 0; i < 100; i++) { long pos = (long) (Math.random() * fileSize); readLen1 = localChannel.read(buffer1, pos); readLen2 = binlogFileReadChannel.read(buffer2, pos); Assert."<AssertPlaceHolder>"; buffer1.flip(); buffer2.flip(); localCrc.update(buffer1.array(), 0, buffer1.limit()); ossCrc.update(buffer2.array(), 0, buffer2.limit()); Assert.assertEquals(localCrc.getValue(), ossCrc.getValue()); } }
read(ByteBuffer dst, long position) throws IOException { try { return (int) parse(readWithPos.invoke(channel, dst, position)); } catch (Exception e) { log.error("read from binlog file error", e); throw new IOException("Read from file channel error!"); } }
[*] target: assertEquals(readLen1, readLen2)
[-] pred: org. junit. Assert. assertEquals ( readLen1, readLen2 )
************************************
************************************
[+] input: Exception { TimeInterval actual = AsyncTaskUtils.parseTimeInterval("00:00-00:05"); TimeInterval expected = new TimeInterval( LocalTime.of(0, 0, 0), LocalTime.of(0, 5, 0) ); "<AssertPlaceHolder>"; assertEquals(300, actual.getDuration()); }
parseTimeInterval(String str) throws ParseException { String[] splits = str.split("-"); if (splits.length != 2) { throw new ParseException("Bad Input: " + str, 0); } LocalTime start = LocalTime.parse(splits[0].trim()); LocalTime end = LocalTime.parse(splits[1].trim()); return new TimeInterval(start, end); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { TimeInterval actual = AsyncTaskUtils.parseTimeInterval("00:00 -00:30 "); TimeInterval expected = new TimeInterval( LocalTime.of(0, 0, 0), LocalTime.of(0, 30, 0) ); "<AssertPlaceHolder>"; assertEquals(1800, actual.getDuration()); }
parseTimeInterval(String str) throws ParseException { String[] splits = str.split("-"); if (splits.length != 2) { throw new ParseException("Bad Input: " + str, 0); } LocalTime start = LocalTime.parse(splits[0].trim()); LocalTime end = LocalTime.parse(splits[1].trim()); return new TimeInterval(start, end); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { TimeInterval actual = AsyncTaskUtils.parseTimeInterval("02:30 - 04:30"); TimeInterval expected = new TimeInterval( LocalTime.of(2, 30, 0), LocalTime.of(4, 30, 0) ); "<AssertPlaceHolder>"; assertEquals(7200, actual.getDuration()); }
parseTimeInterval(String str) throws ParseException { String[] splits = str.split("-"); if (splits.length != 2) { throw new ParseException("Bad Input: " + str, 0); } LocalTime start = LocalTime.parse(splits[0].trim()); LocalTime end = LocalTime.parse(splits[1].trim()); return new TimeInterval(start, end); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { TimeInterval actual = AsyncTaskUtils.parseTimeInterval("22:30-04:30"); TimeInterval expected = new TimeInterval( LocalTime.of(22, 30, 0), LocalTime.of(4, 30, 0) ); "<AssertPlaceHolder>"; assertEquals(3600 * 6, actual.getDuration()); }
parseTimeInterval(String str) throws ParseException { String[] splits = str.split("-"); if (splits.length != 2) { throw new ParseException("Bad Input: " + str, 0); } LocalTime start = LocalTime.parse(splits[0].trim()); LocalTime end = LocalTime.parse(splits[1].trim()); return new TimeInterval(start, end); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { TimeInterval actual = AsyncTaskUtils.parseTimeInterval("00:00-00:00"); TimeInterval expected = new TimeInterval( LocalTime.of(0, 0, 0), LocalTime.of(0, 0, 0) ); "<AssertPlaceHolder>"; assertEquals(3600 * 24, actual.getDuration()); }
parseTimeInterval(String str) throws ParseException { String[] splits = str.split("-"); if (splits.length != 2) { throw new ParseException("Bad Input: " + str, 0); } LocalTime start = LocalTime.parse(splits[0].trim()); LocalTime end = LocalTime.parse(splits[1].trim()); return new TimeInterval(start, end); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { TimeInterval actual = AsyncTaskUtils.parseTimeInterval("22:30:20-04:30:40"); TimeInterval expected = new TimeInterval( LocalTime.of(22, 30, 20), LocalTime.of(4, 30, 40) ); "<AssertPlaceHolder>"; assertEquals(3600 * 6 + 20, actual.getDuration()); }
parseTimeInterval(String str) throws ParseException { String[] splits = str.split("-"); if (splits.length != 2) { throw new ParseException("Bad Input: " + str, 0); } LocalTime start = LocalTime.parse(splits[0].trim()); LocalTime end = LocalTime.parse(splits[1].trim()); return new TimeInterval(start, end); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ExecutionException { ExecInfo execInfo = new ExecInfo(); execInfo.setTimestamp(1636537498974L); execInfo.setSchema(SCHEMA); execInfo.setSqlType(SQL_TYPE); execInfo.setSampleSql(SQL_SAMPLE); execInfo.setPrevTemplateText(PREV_SAMPLE_SQL); execInfo.setTemplateText(SQL_TEMPLATE_TEXT); execInfo.setSampleTraceId(SAMPLE_TRACE_ID); execInfo.setWorkloadType(WORKLOAD_TYPE); execInfo.setExecuteMode(EXECUTE_MODE); execInfo.setTemplateHash(TEMPLATE_HASH); execInfo.setPrevTemplateHash(PREV_TEMPLATE_HASH); execInfo.setPlanHash(PLAN_HASH); execInfo.setErrorCount(0); execInfo.setAffectedRows(1); execInfo.setTransTime(2); execInfo.setResponseTime(3); execInfo.setPhysicalTime(4); execInfo.setPhysicalExecCount(5); execInfo.setParseTime(1); execInfo.setExecPlanCpuTime(1); execInfo.setPhyFetchRows(1); statementSummaryManager.getConfig().setStmtSummaryPercent(0); for (int i = 0; i < 1000; ++i) { statementSummaryManager.summaryStmt(execInfo); } execInfo.setSlow(true); statementSummaryManager.summaryStmt(execInfo); Iterator<StatementSummaryByDigestEntry> iterator = statementSummaryManager.getCurrentStmtSummaries(1636537498974L); Assert."<AssertPlaceHolder>"; long queryCount = iterator.next().getValue().getCount(); Assert.assertTrue(queryCount == 1); }
getCurrentStmtSummaries(long nowBeginTime) { return getStmtSummaries(nowBeginTime, (e1, e2) -> { return (int) (e1.longValue() - e2.longValue()); }); }
[*] target: assertTrue(iterator.hasNext())
[-] pred: org. junit. Assert. assertTrue ( iterator. hasNext ( ) )
************************************
************************************
[+] input: ExecutionException { ExecInfo execInfo = new ExecInfo(); execInfo.setTimestamp(1636537498974L); execInfo.setSchema(SCHEMA); execInfo.setSqlType(SQL_TYPE); execInfo.setSampleSql(SQL_SAMPLE); execInfo.setPrevTemplateText(PREV_SAMPLE_SQL); execInfo.setTemplateText(SQL_TEMPLATE_TEXT); execInfo.setSampleTraceId(SAMPLE_TRACE_ID); execInfo.setWorkloadType(WORKLOAD_TYPE); execInfo.setExecuteMode(EXECUTE_MODE); execInfo.setTemplateHash(TEMPLATE_HASH); execInfo.setPrevTemplateHash(PREV_TEMPLATE_HASH); execInfo.setPlanHash(PLAN_HASH); execInfo.setErrorCount(0); execInfo.setAffectedRows(1); execInfo.setTransTime(2); execInfo.setResponseTime(3); execInfo.setPhysicalTime(4); execInfo.setPhysicalExecCount(5); execInfo.setParseTime(1); execInfo.setExecPlanCpuTime(1); execInfo.setPhyFetchRows(1); statementSummaryManager.getConfig().setStmtSummaryPercent(1); for (int i = 0; i < 10000; ++i) { statementSummaryManager.summaryStmt(execInfo); } Iterator<StatementSummaryByDigestEntry> iterator = statementSummaryManager.getCurrentStmtSummaries(1636537498974L); Assert."<AssertPlaceHolder>"; long queryCount = iterator.next().getValue().getCount(); Assert.assertTrue(queryCount > 50L && queryCount < 150L); }
getCurrentStmtSummaries(long nowBeginTime) { return getStmtSummaries(nowBeginTime, (e1, e2) -> { return (int) (e1.longValue() - e2.longValue()); }); }
[*] target: assertTrue(iterator.hasNext())
[-] pred: org. junit. Assert. assertTrue ( iterator. hasNext ( ) )
************************************
************************************
[+] input: testRandomTime() { Calendar calendar = new GregorianCalendar(); IntStream.range(0, 1 << 20) // we have 1/3 prob to get random invalid timestamp .mapToObj(i -> R.nextInt() % 3 == 0 ? generateRandomDatetime() : generateStandardDatetime()) .forEach( bs -> { Timestamp t1 = MySQLTimeTypeUtil.bytesToDatetime(bs, Types.TIMESTAMP, calendar, false, true); Timestamp t2 = MySQLTimeTypeUtil.bytesToDatetime(bs, Types.TIMESTAMP, calendar, true, true); boolean eq = t1.toString().equals(t2.toString()); String errorMessage = "original = " + new String(bs) + ", t1 = " + t1.toString() + ", t2 = " + t2.toString(); if (!(t1 instanceof OriginalTimestamp)) { // If timestamp is not modified, they are equal to each other. Assert."<AssertPlaceHolder>"; } else { // If timestamp is modified, they are not equal to each other. Assert.assertTrue(errorMessage, !eq); } // anyway, we must ensure the consistency of timestamp and original bytes Assert.assertTrue( t1.getClass().getSimpleName() + ", actual = " + t1.toString() + ", original = " + new String( bs), Arrays.equals(t1.toString().getBytes(), bs)); } ); }
bytesToDatetime(byte[] timestampAsBytes, int sqlType, Calendar calendar, boolean allowModification, boolean allowInvalidity) {  MysqlDateTime mysqlDateTime = StringTimeParser.parseString(timestampAsBytes, sqlType); if (mysqlDateTime == null) { return null; } if (!allowModification) { return createOriginalTimestamp(mysqlDateTime); } else { int year = (int) mysqlDateTime.getYear(); int month = (int) mysqlDateTime.getMonth(); int day = (int) mysqlDateTime.getDay(); int hour = (int) mysqlDateTime.getHour(); int minute = (int) mysqlDateTime.getMinute(); int second = (int) mysqlDateTime.getSecond(); int secondPart = (int) mysqlDateTime.getSecondPart(); return createJavaTimestamp(calendar, year, month, day, hour, minute, second, secondPart); } }
[*] target: assertTrue(errorMessage, eq)
[-] pred: org. junit. Assert. assertTrue ( errorMessage, eq )
************************************
************************************
[+] input: testSingle() { String original = "0000-00-00 01:01:01"; Calendar calendar = new GregorianCalendar(); byte[] bs = original.getBytes(); Timestamp t1 = MySQLTimeTypeUtil.bytesToDatetime(bs, Types.TIMESTAMP, calendar, false, true); Timestamp t2 = MySQLTimeTypeUtil.bytesToDatetime(bs, Types.TIMESTAMP, calendar, true, true); boolean eq = t1.toString().equals(t2.toString()); if (!(t1 instanceof OriginalTimestamp)) { // If timestamp is not modified, they are equal to each other. Assert."<AssertPlaceHolder>"; } else { // If timestamp is modified, they are not equal to each other. Assert.assertTrue(!eq); } // anyway, we must ensure the consistency of timestamp and original bytes Assert.assertTrue( t1.getClass().getSimpleName() + ", actual = " + t1.toString() + ", original = " + new String(bs), Arrays.equals(t1.toString().getBytes(), bs)); System.out.println(t2.toString()); }
bytesToDatetime(byte[] timestampAsBytes, int sqlType, Calendar calendar, boolean allowModification, boolean allowInvalidity) {  MysqlDateTime mysqlDateTime = StringTimeParser.parseString(timestampAsBytes, sqlType); if (mysqlDateTime == null) { return null; } if (!allowModification) { return createOriginalTimestamp(mysqlDateTime); } else { int year = (int) mysqlDateTime.getYear(); int month = (int) mysqlDateTime.getMonth(); int day = (int) mysqlDateTime.getDay(); int hour = (int) mysqlDateTime.getHour(); int minute = (int) mysqlDateTime.getMinute(); int second = (int) mysqlDateTime.getSecond(); int secondPart = (int) mysqlDateTime.getSecondPart(); return createJavaTimestamp(calendar, year, month, day, hour, minute, second, secondPart); } }
[*] target: assertTrue(eq)
[-] pred: org. junit. Assert. assertTrue ( eq )
************************************
************************************
[+] input: testGetMdl() { /** * ddl */ final ExecutorService ddlPool = Executors.newFixedThreadPool(1); ddlPool.submit(() -> { while (true) { // connect to DRDS final FrontConnection frontConn = new FrontConnection(g.nextId());  final MdlContext context = mdlManager.addContext(frontConn.getId()); frontConn.setMdlContext(context);  final Long trxId = 9527L; // get lock final MdlTicket ticket = context.acquireLock(writeRequest(trxId, tableName));  // update schema version tableSchemaMap.put(tableName, tableSchemaMap.get(tableName) + 1);  try { TimeUnit.MILLISECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }  // release lock context.releaseLock(trxId, ticket);  // close connection mdlManager.removeContext(context);  if (Thread.interrupted()) { break; } } });  /** * dml */ final ExecutorService dmlPool = Executors.newFixedThreadPool(10);  final List<Future> dmlFutures = new ArrayList<>(); IntStream.range(0, 10).forEach(index -> {  final Future<?> future = dmlPool.submit(() -> { final Random r = new Random(LocalDateTime.now().getNano());  int connCount = 0; while (connCount++ < CONN_COUNT) { // connect to DRDS final FrontConnection frontConn = new FrontConnection(g.nextId());  final MdlContext context = mdlManager.addContext(frontConn.getId()); frontConn.setMdlContext(context);  int trxCount = 0; while (trxCount++ < TRX_COUNT) { final int stmtCountInTrx = Math.abs(r.nextInt()) % 10 + 1;  final Long trxId = 9527L + trxIdGenerator.getAndIncrement();  // begin transaction MdlTicket ticket = null; for (int i = 0; i < stmtCountInTrx; i++) { final MdlTicket newTicket = context.acquireLock(readRequest(trxId, tableName));  // grant ticket once for a table in a transaction if (null != ticket) { Assert."<AssertPlaceHolder>"; }  ticket = newTicket;  // get schema version final Long schemaVersion1 = tableSchemaMap.get(tableName);  // execute query try { TimeUnit.MILLISECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }  // check schema version final Long schemaVersion2 = tableSchemaMap.get(tableName);  final long versionChange = schemaVersion2 - schemaVersion1; Assert.assertTrue(versionChange >= 0 && versionChange <= 1); }  // commit context.releaseLock(trxId, ticket);  Assert.assertFalse(ticket.isValidate()); }  // close connection final MdlContext mdlContext = mdlManager.removeContext(context); } });  dmlFutures.add(future); });  dmlFutures.forEach(future -> { try { future.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } });  ddlPool.shutdown();  System.out.println(JSON.toJSONString(tableSchemaMap)); }
acquireLock(@NotNull final MdlRequest request, @NotNull final MdlContext context) { final boolean readLock = MdlManager.isReadLock(request.getType());  if (readLock) { return readLock(request, context); } else { return writeLock(request, context); } }
[*] target: assertEquals(ticket, newTicket)
[-] pred: org. junit. Assert. assertEquals ( ticket, newTicket )
************************************
************************************
[+] input: IOException { // [stripe 0] // Stripe: offset: 3 data: 6333874 rows: 240000 tail: 111 index: 4025 final int stripeId = 0; final int columnId = 2; final int[] rowGroupIds = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22};  final long rowsInStripe = orcTail.getStripes().get(stripeId).getNumberOfRows(); int groupsInStripe = (int) ((rowsInStripe + indexStride - 1) / indexStride);  BlockCacheManager<Block> blockCacheManager = prepareCache(stripeId, new int[] {columnId}, rowGroupIds);  CacheReader<Block> cacheReader = new CacheReaderImpl(stripeId, columnId, groupsInStripe);  if (!cacheReader.isInitialized()) { // Check the block-cache-manager what row-group of this column have been cached. Map<Integer, SeekableIterator<Block>> caches = blockCacheManager.getCachedRowGroups( FILE_PATH, stripeId, columnId, fromRowGroupIds(stripeId, rowGroupIds) ); cacheReader.initialize(caches); }  // Check cached row group bitmap. boolean[] bitmap = cacheReader.cachedRowGroupBitmap(); Assert.assertTrue( Arrays.equals(fromRowGroupIds(stripeId, rowGroupIds), bitmap));  // collect block locations in this group. List<BlockLocation> locationList = new ArrayList<>(); for (int groupId : rowGroupIds) { final int rowCountInGroup = getRowCount(orcTail.getStripes().get(stripeId), groupId); for (int startPosition = 0; startPosition < rowCountInGroup; startPosition += DEFAULT_CHUNK_LIMIT) { int positionCount = Math.min(DEFAULT_CHUNK_LIMIT, rowCountInGroup - startPosition); locationList.add(new BlockLocation(groupId, startPosition, positionCount)); } }  // Check block existence for (BlockLocation location : locationList) { Block cached = cacheReader.getCache(location.rowGroupId, location.startPosition); Assert."<AssertPlaceHolder>"; Assert.assertEquals(location.positionCount, cached.getPositionCount()); } }
getCache(int groupId, int position);
[*] target: assertNotNull(cached)
[-] pred: org. junit. Assert. assertNotNull ( cached )
************************************
************************************
[+] input: SQLException {  final String mockReleaseDate = "20240412"; final String mockEngineVersion = "5.4.19";  Connection mockConnection = mock(Connection.class); mockMetaDbUtil.when(MetaDbUtil::getConnection).thenAnswer(i -> mockConnection); Statement statement = mock(Statement.class); Mockito.when(mockConnection.createStatement()).thenReturn(statement); ResultSet resultSet = mock(ResultSet.class); Mockito.when(statement.executeQuery(Mockito.anyString())).thenReturn(resultSet); Mockito.when(resultSet.next()).thenReturn(true); Mockito.when(resultSet.getString(1)).thenReturn(mockEngineVersion); Mockito.when(resultSet.getString(2)).thenReturn(mockReleaseDate);  String gmsPolardbVersion = null; try { gmsPolardbVersion = MetaDbUtil.getGmsPolardbVersion(); } catch (Exception e) { Assert.fail(e.getMessage()); } Assert."<AssertPlaceHolder>"; Assert.assertEquals(String.format("%s-%s", mockEngineVersion, mockReleaseDate), gmsPolardbVersion); }
getGmsPolardbVersion() throws Exception { String sql = POLARDB_VERSION_SQL; String dnPolardbxVersion = null; String dnReleaseDate = null; try (Connection metaDbConn = MetaDbUtil.getConnection(); Statement stmt = metaDbConn.createStatement(); ResultSet rs = stmt.executeQuery(sql)) { if (rs.next()) { dnPolardbxVersion = rs.getString(1); dnReleaseDate = rs.getString(2); } return String.format("%s-%s", dnPolardbxVersion, dnReleaseDate); } }
[*] target: assertNotNull(gmsPolardbVersion)
[-] pred: org. junit. Assert. assertNotNull ( gmsPolardbVersion )
************************************
************************************
[+] input: testAllocateRevocableMemory() { MemoryPool root = new MemoryPool("root", maxLimit, MemoryType.OTHER); long allocatedSize = 0; for (int i = 0; i < allocateCount; i++) { allocatedSize += testAllocateMemory(root, true); Assert.assertEquals(allocatedSize, root.getMemoryUsage()); } root.destroy(); Assert.assertEquals(0L, root.getMemoryUsage()); Assert.assertEquals(allocatedSize, root.getMaxMemoryUsage()); Assert."<AssertPlaceHolder>"; }
isDestoryed() { return destroyed.get(); }
[*] target: assertTrue(root.isDestoryed())
[-] pred: org. junit. Assert. assertTrue ( root. isDestoryed() )
************************************
************************************
[+] input: testAllocateReservedMemory() { MemoryPool root = new MemoryPool("root", maxLimit, MemoryType.OTHER); long allocatedSize = 0; for (int i = 0; i < allocateCount; i++) { allocatedSize += testAllocateMemory(root, true); Assert.assertEquals(allocatedSize, root.getMemoryUsage()); } root.destroy(); Assert.assertEquals(0L, root.getMemoryUsage()); Assert.assertEquals(allocatedSize, root.getMaxMemoryUsage()); Assert."<AssertPlaceHolder>"; }
isDestoryed() { return destroyed.get(); }
[*] target: assertTrue(root.isDestoryed())
[-] pred: org. junit. Assert. assertTrue ( root. isDestoryed() )
************************************
************************************
[+] input: testAllocateAllMemory() { MemoryPool root = new MemoryPool("root", maxLimit, MemoryType.OTHER); long allocatedSize = 0; for (int i = 0; i < allocateCount; i++) { allocatedSize += testAllocateMemory(root, false); allocatedSize += testAllocateMemory(root, true); Assert.assertEquals(allocatedSize, root.getMemoryUsage()); } root.destroy(); Assert.assertEquals(0L, root.getMemoryUsage()); Assert.assertEquals(allocatedSize, root.getMaxMemoryUsage()); Assert."<AssertPlaceHolder>"; }
isDestoryed() { return destroyed.get(); }
[*] target: assertTrue(root.isDestoryed())
[-] pred: org. junit. Assert. assertTrue ( root. isDestoryed() )
************************************
************************************
[+] input: testAllocateAndReleaseMemory() { MemoryPool root = new MemoryPool("root", maxLimit, MemoryType.OTHER); long allocatedSize = 0; long maxAllocatedSize = 0L; for (int i = 0; i < allocateCount; i++) { allocatedSize += testAllocateMemory(root, false); allocatedSize += testAllocateMemory(root, true); maxAllocatedSize = Math.max(maxAllocatedSize, allocatedSize); allocatedSize -= testReleaseMemory(root, false); allocatedSize -= testReleaseMemory(root, true); Assert.assertEquals(allocatedSize, root.getMemoryUsage()); } Assert.assertEquals(allocatedSize, root.getMemoryUsage()); root.destroy(); Assert.assertEquals(0L, root.getMemoryUsage()); Assert.assertEquals(maxAllocatedSize, root.getMaxMemoryUsage()); Assert."<AssertPlaceHolder>"; }
isDestoryed() { return destroyed.get(); }
[*] target: assertTrue(root.isDestoryed())
[-] pred: org. junit. Assert. assertTrue ( root. isDestoryed() )
************************************
************************************
[+] input: getUserShouldReturnUser() { User user = dataService.getUser(); "<AssertPlaceHolder>"; assertEquals("Joe", user.firstName); }
getUser() { return appData.user; }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: testDatabaseAnnotation() { annotationMapper.parseClassAnnotations(ClassWithDatabase.class.getAnnotations(), context); DefaultDBSystem db = (DefaultDBSystem) context.get("db"); "<AssertPlaceHolder>"; assertEquals("hsqlmem", db.getEnvironment()); }
parseClassAnnotations(Annotation[] annotations, BeneratorContext context) { for (Annotation annotation : annotations) { if (annotation instanceof Database) { parseDatabase((Database) annotation, context); } else if (annotation instanceof Bean) { parseBean((Bean) annotation, context); } } }
[*] target: assertNotNull(db)
[-] pred: org. junit. Assert. assertNotNull ( db )
************************************
************************************
[+] input: testComponentTypes() { List<Entity> list = CollectionUtil.toList(new Entity("childType", provider)); Entity[] array = new Entity[] { new Entity("childType", provider) }; Entity parent = new Entity(parentType, "list", list, "array", array); Entity result = converter.convert(parent); "<AssertPlaceHolder>"; // check list conversion Entity[] convertedList = (Entity[]) result.get("list"); Entity[] expectedList = ArrayUtil.toArray(new Entity("childType", provider)); assertArrayEquals(expectedList, convertedList); // check array conversion Entity[] convertedArray = (Entity[]) result.get("list"); Entity[] expectedArray = new Entity[] { new Entity("childType", provider) }; assertArrayEquals(expectedArray, convertedArray); }
convert(Entity entity) throws ConversionException { return convert(entity, type); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testMTSettings() { assertFalse(converter.isParallelizable()); "<AssertPlaceHolder>"; }
isThreadSafe() { return true; }
[*] target: assertTrue(converter.isThreadSafe())
[-] pred: org. junit. Assert. assertTrue ( converter. isThreadSafe() )
************************************
************************************
[+] input: testPart_entity() { Entity alice = new Entity("person", dp); alice.set("cars", createCar("Audi")); context.setCurrentProduct(new ProductWrapper<>(alice)); modifier.execute(context); Entity car = (Entity) alice.get("cars"); "<AssertPlaceHolder>"; assertEquals("BMW", car.get("maker")); }
execute(BeneratorContext context) { ProductWrapper<?> wrapper = context.getCurrentProduct(); if (wrapper != null) { Object part = ((Entity) wrapper.unwrap()).getComponent(partName); // Init part and add into currentProduct if (part == null) { part = new Entity((ComplexTypeDescriptor) null, null); ((Entity)context.getCurrentProduct().unwrap()).setComponent(partName, part); } applyToPart(part, context); // Convert part (this.converter consist context itself) if (converter != null) { converter.convert(part); } } return true; }
[*] target: assertNotNull(car)
[-] pred: org. junit. Assert. assertNotNull ( car )
************************************
************************************
[+] input: test_3_4() { logger.info("testDefault"); LoggingConsumer consumer = new LoggingConsumer(2, 3); assertFalse(consumer.shouldLog()); consume(1, consumer); assertFalse(consumer.shouldLog()); consume(2, consumer); assertTrue(consumer.shouldLog()); consume(3, consumer); assertTrue(consumer.shouldLog()); consume(4, consumer); assertTrue(consumer.shouldLog()); consume(5, consumer); assertFalse(consumer.shouldLog()); consume(6, consumer); "<AssertPlaceHolder>"; consume(7, consumer); }
shouldLog() { return cursor >= offset && (maxLogs == UNLIMITED || cursor < offset + maxLogs); }
[*] target: assertFalse(consumer.shouldLog())
[-] pred: org. junit. Assert. assertFalse ( consumer. shouldLog() )
************************************
************************************
[+] input: testNormal() { Generator<Long> feed = new IncrementGenerator(1, 1, N); NonNullGenerator<Long> generator = WrapperFactory.asNonNullGenerator( ExpandGeneratorProxy.uniqueProxy(feed, CACHE_SIZE, BUCKET_SIZE)); generator.init(context); UniqueLongValidator validator = new UniqueLongValidator(N); for (int i = 0; i < N; i++) { Long product = generator.generate(); "<AssertPlaceHolder>"; assertTrue("Not unique: " + product, validator.valid(product)); assertTrue(product <= N); assertTrue(product >= 1); } assertUnavailable(generator); }
init(GeneratorContext context) { super.init(context); createBuckets(); }
[*] target: assertNotNull(product)
[-] pred: org. junit. Assert. assertNotNull ( product )
************************************
************************************
[+] input: testFindEnvironments_global() { Map<String, Environment> environments = EnvironmentUtil.findEnvironments(); System.out.println(environments); Environment localEnv = environments.get("local"); "<AssertPlaceHolder>"; assertNotNull(localEnv.getSystem("h2")); }
findEnvironments() { return findEnvironments("."); }
[*] target: assertNotNull(localEnv)
[-] pred: org. junit. Assert. assertNotNull ( localEnv )
************************************
************************************
[+] input: test() { SeedWordGenerator generator = new SeedWordGenerator(); generator.init(context); //generator.printState(); for (int i = 0; i < 10; i++) { String word = generator.generate(); "<AssertPlaceHolder>"; logger.debug(word); assertNotNull(word); assertTrue(word.length() > 0); } assertAvailable(generator); }
generate() { assertInitialized(); return toString(generateFromNotNullSource()); }
[*] target: assertNotNull(word)
[-] pred: org. junit. Assert. assertNotNull ( word )
************************************
************************************
[+] input: testIsRunning() { LatencyCounter counter = new LatencyCounter("test"); counter.start(); assertNotEquals(counter.getStartTime(), 0L); assertTrue(counter.isRunning()); counter.stop(); "<AssertPlaceHolder>"; }
isRunning() { return running; }
[*] target: assertFalse(counter.isRunning())
[-] pred: org. junit. Assert. assertFalse ( counter. isRunning() )
************************************
************************************
[+] input: testDefaultGeneration() { CountryGenerator generator = new CountryGenerator(); generator.init(context); for (int i = 0; i < 100; i++) { Country country = generator.generate(); "<AssertPlaceHolder>"; assertNotNull(Country.getInstance(country.getIsoCode())); } }
generate() { return GeneratorUtil.generateNonNull(this); }
[*] target: assertNotNull(country)
[-] pred: org. junit. Assert. assertNotNull ( country )
************************************
************************************
[+] input: testConstructor2() { Street actualStreet = new Street( new City(new State(), "Name", "Addition", new String[] {"foo", "foo", "foo"}, "Area Code"), "Name", 3); assertEquals("Name", actualStreet.getName()); "<AssertPlaceHolder>"; }
getMaxHouseNumber() { return maxHouseNumber; }
[*] target: assertEquals(3, actualStreet.getMaxHouseNumber())
[-] pred: org. junit. Assert. assertEquals ( 3, actualStreet. getMaxHouseNumber() )
************************************
************************************
[+] input: testGenerateNotNullWithCustomAttributes() { ProductWrapper<FamilyContainer> w = new ProductWrapper<>(); FamilyGenerator g = new FamilyGenerator(); //config general g.setDataset("DE"); g.setLocale(new Locale("de_DE")); int customFirstParentMinAgeYears = 30; int customFirstParentMaxAgeYears = 50; g.setFirstParentMinAgeYears(customFirstParentMinAgeYears); g.setFirstParentMaxAgeYears(customFirstParentMaxAgeYears); //config peerRelation int customMinDiffAgeInPeerRelation = 0; int customMaxDiffAgeInPeerRelation = 3; g.setMinDiffAgeInPeerRelation(customMinDiffAgeInPeerRelation); g.setMaxDiffAgeInPeerRelation(customMaxDiffAgeInPeerRelation); //config higherRelation int customMinDiffAgeInHigherRelation = 30; int customMaxDiffAgeInHigherRelation = 40; g.setMinDiffAgeInHigherRelation(customMinDiffAgeInHigherRelation); g.setMaxDiffAgeInHigherRelation(customMaxDiffAgeInHigherRelation); //config lowerRelation int customMaxBiologicalChildrenNumber = 5; int customMaxChildrenAdoptedNumber = 1; g.setMaxBiologicalChildrenNumber(customMaxBiologicalChildrenNumber); g.setMaxChildrenAdoptedNumber(customMaxChildrenAdoptedNumber); //init context g.init(context); for (int i = 0; i < 1000; i++) { w = g.generate(w); FamilyContainer c = w.unwrap();  //get familyPerson FamilyPerson father = c.getFamilyPersonList().stream() .filter(familyPerson -> familyPerson.getFamilyRole().equals(FamilyRole.FATHER)) .findFirst() .orElse(null); "<AssertPlaceHolder>"; int fatherAge = father.getAge(); String fatherFamilyName = father.getFamilyName(); FamilyPerson mother = c.getFamilyPersonList().stream() .filter(familyPerson -> familyPerson.getFamilyRole().equals(FamilyRole.MOTHER)) .findFirst() .orElse(null); assertNotNull(mother); int motherAge = mother.getAge(); String motherFamilyName = mother.getFamilyName(); FamilyPerson grandParentOfFather = c.getGrandparents().stream() .filter(grandparent -> grandparent.getRelations().containsKey(father)) .findFirst() .orElse(null); assertNotNull(grandParentOfFather); int grandParent1Age = grandParentOfFather.getAge(); String grandParent1FamilyName = grandParentOfFather.getFamilyName(); List<FamilyPerson> children = c.getChildren(); assertNotNull(children); int childrenCount = children.size();  //check general attributes assertTrue(c.getFamilyPersonList().get(0).getAge() >= customFirstParentMinAgeYears && c.getFamilyPersonList().get(0).getAge() <= customFirstParentMaxAgeYears);  //check peer constraint assertEquals(fatherFamilyName, motherFamilyName); assertTrue(c.getFamilyPersonList().get(1).getAge() >= c.getFamilyPersonList().get(0).getAge() + customMinDiffAgeInPeerRelation && c.getFamilyPersonList().get(1).getAge() <= c.getFamilyPersonList().get(0).getAge() + customMaxDiffAgeInPeerRelation);  //check higher constraint assertEquals(fatherFamilyName, grandParent1FamilyName); assertTrue(grandParent1Age >= fatherAge + customMinDiffAgeInHigherRelation && grandParent1Age <= fatherAge + customMaxDiffAgeInHigherRelation);  //check lower constraint assertTrue(childrenCount <= customMaxBiologicalChildrenNumber + customMaxChildrenAdoptedNumber); for (FamilyPerson child : children) { assertEquals(fatherFamilyName, child.getFamilyName()); assertTrue(child.getAge() >= 1 && child.getAge() <= (Math.min(fatherAge, motherAge)) - 18); } } }
generate(ProductWrapper<FamilyContainer> wrapper) { return wrapper.wrap(generate()); }
[*] target: assertNotNull(father)
[-] pred: org. junit. Assert. assertNotNull ( father )
************************************
************************************
[+] input: testEqualsIgnoringDescriptor_false() { Entity alice = createAlice(); assertFalse(alice.equalsIgnoringDescriptor(null)); assertFalse(alice.equalsIgnoringDescriptor(new Entity("person", dp))); assertFalse(alice.equalsIgnoringDescriptor(createBob())); Entity otherAlice = new Entity(alice); otherAlice.set("age", 56); "<AssertPlaceHolder>"; }
equalsIgnoringDescriptor(Entity that) { if (this == that) { return true; } if (that == null) { return false; } if (this.getComponents().size() != that.getComponents().size()) { return false; } for (Map.Entry<String, Object> entry : this.getComponents().entrySet()) { Object thisValue = entry.getValue(); Object thatValue = that.getComponent(entry.getKey()); if (!equalIgnoringDescriptor(thisValue, thatValue)) return false; } return true; }
[*] target: assertFalse(alice.equalsIgnoringDescriptor(otherAlice))
[-] pred: org. junit. Assert. assertFalse ( alice. equalsIgnoringDescriptor( otherAlice ) )
************************************
************************************
[+] input: Exception { List<Entity> entities = AllSheetsXLSEntityIterator.parseAll(IMPORT_XLS, null, false); "<AssertPlaceHolder>"; assertProduct(PROD1, entities.get(0)); assertProduct(PROD2, entities.get(1)); assertPerson(PERSON1, entities.get(2)); }
parseAll(String uri, Converter<String, ?> preprocessor, boolean formatted) throws IOException { List<Entity> list = new ArrayList<>(); AllSheetsXLSEntityIterator iterator = new AllSheetsXLSEntityIterator(uri, preprocessor, null, formatted); iterator.setContext(new DefaultBeneratorContext()); DataContainer<Entity> container = new DataContainer<>(); while ((container = iterator.next(container)) != null) { list.add(container.getData()); } return list; }
[*] target: assertEquals(3, entities.size())
[-] pred: org. junit. Assert. assertEquals ( 3, entities. size ( ) )
************************************
************************************
[+] input: testConstructor() { DOMTree actualDomTree = new DOMTree(); assertNull(actualDomTree.getDataModel()); assertNull(actualDomTree.getInputUri()); assertTrue(actualDomTree.isNamespaceAware()); assertNull(actualDomTree.getId()); assertEquals(0, actualDomTree.getTypeDescriptors().length); "<AssertPlaceHolder>"; }
getOutputUri() { return outputUri; }
[*] target: assertNull(actualDomTree.getOutputUri())
[-] pred: org. junit. Assert. assertNull ( actualDomTree. getOutputUri() )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.examineBrokerClusterInfo()).thenReturn(MockObjectUtil.createClusterInfo()); } ClusterInfo clusterInfo = mqAdminExtImpl.examineBrokerClusterInfo(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(clusterInfo.getBrokerAddrTable().size(), 1); Assert.assertEquals(clusterInfo.getClusterAddrTable().size(), 1); }
examineBrokerClusterInfo() throws InterruptedException, MQBrokerException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException { return MQAdminInstance.threadLocalMQAdminExt().examineBrokerClusterInfo(); }
[*] target: assertNotNull(clusterInfo)
[-] pred: org. junit. Assert. assertNotNull ( clusterInfo )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.examineTopicRouteInfo(anyString())).thenReturn(MockObjectUtil.createTopicRouteData()); } TopicRouteData topicRouteData = mqAdminExtImpl.examineTopicRouteInfo("topic_test"); Assert."<AssertPlaceHolder>"; }
examineTopicRouteInfo(String topic) throws RemotingException, MQClientException, InterruptedException { return MQAdminInstance.threadLocalMQAdminExt().examineTopicRouteInfo(topic); }
[*] target: assertNotNull(topicRouteData)
[-] pred: org. junit. Assert. assertNotNull ( topicRouteData )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.examineConsumerConnectionInfo(anyString())).thenReturn(new ConsumerConnection()); } ConsumerConnection consumerConnection = mqAdminExtImpl.examineConsumerConnectionInfo("group_test"); Assert."<AssertPlaceHolder>"; }
examineConsumerConnectionInfo(String consumerGroup) throws RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException, InterruptedException, MQBrokerException, RemotingException, MQClientException { return MQAdminInstance.threadLocalMQAdminExt().examineConsumerConnectionInfo(consumerGroup); }
[*] target: assertNotNull(consumerConnection)
[-] pred: org. junit. Assert. assertNotNull ( consumerConnection )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.examineProducerConnectionInfo(anyString(), anyString())).thenReturn(new ProducerConnection()); } ProducerConnection producerConnection = mqAdminExtImpl.examineProducerConnectionInfo("group_test", "topic_test"); Assert."<AssertPlaceHolder>"; }
examineProducerConnectionInfo(String producerGroup, String topic) throws RemotingException, MQClientException, InterruptedException, MQBrokerException { return MQAdminInstance.threadLocalMQAdminExt().examineProducerConnectionInfo(producerGroup, topic); }
[*] target: assertNotNull(producerConnection)
[-] pred: org. junit. Assert. assertNotNull ( producerConnection )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.queryTopicConsumeByWho(anyString())).thenReturn(new GroupList()); } GroupList groupList = mqAdminExtImpl.queryTopicConsumeByWho("topic_test"); Assert."<AssertPlaceHolder>"; }
queryTopicConsumeByWho(String topic) throws RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException, InterruptedException, MQBrokerException, RemotingException, MQClientException { return MQAdminInstance.threadLocalMQAdminExt().queryTopicConsumeByWho(topic); }
[*] target: assertNotNull(groupList)
[-] pred: org. junit. Assert. assertNotNull ( groupList )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.getConsumerRunningInfo(anyString(), anyString(), anyBoolean())).thenReturn(new ConsumerRunningInfo()); } ConsumerRunningInfo consumerRunningInfo = mqAdminExtImpl.getConsumerRunningInfo("group_test", "", true); Assert."<AssertPlaceHolder>"; }
getConsumerRunningInfo(String consumerGroup, String clientId, boolean jstack) throws RemotingException, MQClientException, InterruptedException { return MQAdminInstance.threadLocalMQAdminExt().getConsumerRunningInfo(consumerGroup, clientId, jstack); }
[*] target: assertNotNull(consumerRunningInfo)
[-] pred: org. junit. Assert. assertNotNull ( consumerRunningInfo )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.viewMessage(anyString())).thenReturn(new MessageExt()); } MessageExt messageExt = mqAdminExtImpl.viewMessage("7F000001ACC018B4AAC2116AF6500000"); Assert."<AssertPlaceHolder>"; }
viewMessage(String msgId) throws RemotingException, MQBrokerException, InterruptedException, MQClientException { return MQAdminInstance.threadLocalMQAdminExt().viewMessage(msgId); }
[*] target: assertNotNull(messageExt)
[-] pred: org. junit. Assert. assertNotNull ( messageExt )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.queryMessage(anyString(), anyString(), anyInt(), anyLong(), anyLong())).thenReturn(mock(QueryResult.class)); } QueryResult result = mqAdminExtImpl.queryMessage("topic_test", "key", 32, 1627804565000L, System.currentTimeMillis()); Assert."<AssertPlaceHolder>"; }
queryMessage(String topic, String key, int maxNum, long begin, long end) throws MQClientException, InterruptedException { return MQAdminInstance.threadLocalMQAdminExt().queryMessage(topic, key, maxNum, begin, end); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.queryConsumeTimeSpan(anyString(), anyString())).thenReturn(new ArrayList<QueueTimeSpan>()); } List<QueueTimeSpan> timeSpans = mqAdminExtImpl.queryConsumeTimeSpan("topic_test", "group_test"); Assert."<AssertPlaceHolder>"; }
queryConsumeTimeSpan(String topic, String group) throws InterruptedException, MQBrokerException, RemotingException, MQClientException { return MQAdminInstance.threadLocalMQAdminExt().queryConsumeTimeSpan(topic, group); }
[*] target: assertNotNull(timeSpans)
[-] pred: org. junit. Assert. assertNotNull ( timeSpans )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.getBrokerConfig(anyString())).thenReturn(new Properties()); } Properties brokerConfig = mqAdminExtImpl.getBrokerConfig(brokerAddr); Assert."<AssertPlaceHolder>"; }
getBrokerConfig( String brokerAddr) throws RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException, UnsupportedEncodingException, InterruptedException, MQBrokerException { return MQAdminInstance.threadLocalMQAdminExt().getBrokerConfig(brokerAddr); }
[*] target: assertNotNull(brokerConfig)
[-] pred: org. junit. Assert. assertNotNull ( brokerConfig )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.fetchTopicsByCLuster(anyString())).thenReturn(new TopicList()); } TopicList topicList = mqAdminExtImpl.fetchTopicsByCLuster("DefaultCluster"); Assert."<AssertPlaceHolder>"; }
fetchTopicsByCLuster( String clusterName) throws RemotingException, MQClientException, InterruptedException { return MQAdminInstance.threadLocalMQAdminExt().fetchTopicsByCLuster(clusterName); }
[*] target: assertNotNull(topicList)
[-] pred: org. junit. Assert. assertNotNull ( topicList )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.viewBrokerStatsData(anyString(), anyString(), anyString())).thenReturn(new BrokerStatsData()); } BrokerStatsData brokerStatsData = mqAdminExtImpl.viewBrokerStatsData(brokerAddr, BrokerStatsManager.TOPIC_PUT_NUMS, "topic_test"); Assert."<AssertPlaceHolder>"; }
viewBrokerStatsData(String brokerAddr, String statsName, String statsKey) throws RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException, MQClientException, InterruptedException { return MQAdminInstance.threadLocalMQAdminExt().viewBrokerStatsData(brokerAddr, statsName, statsKey); }
[*] target: assertNotNull(brokerStatsData)
[-] pred: org. junit. Assert. assertNotNull ( brokerStatsData )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.getClusterList(anyString())).thenReturn(new HashSet<>()); } Set<String> clusterList = mqAdminExtImpl.getClusterList("topic_test"); Assert."<AssertPlaceHolder>"; }
getClusterList( String topic) throws RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException, MQClientException, InterruptedException { return MQAdminInstance.threadLocalMQAdminExt().getClusterList(topic); }
[*] target: assertNotNull(clusterList)
[-] pred: org. junit. Assert. assertNotNull ( clusterList )
************************************
************************************
[+] input: Exception { assertNotNull(mqAdminExtImpl); { when(defaultMQAdminExt.getAllSubscriptionGroup(anyString(), anyLong())).thenReturn(new SubscriptionGroupWrapper()); } SubscriptionGroupWrapper wrapper = mqAdminExtImpl.getAllSubscriptionGroup(brokerAddr, 5000L); Assert."<AssertPlaceHolder>"; }
getAllSubscriptionGroup(String brokerAddr, long timeoutMillis) throws InterruptedException, RemotingTimeoutException, RemotingSendRequestException, RemotingConnectException, MQBrokerException { return MQAdminInstance.threadLocalMQAdminExt().getAllSubscriptionGroup(brokerAddr, timeoutMillis); }
[*] target: assertNotNull(wrapper)
[-] pred: org. junit. Assert. assertNotNull ( wrapper )
************************************
************************************
[+] input: Exception { AtomicInteger num = new AtomicInteger(0); CollectExecutorConfig config = new CollectExecutorConfig(); config.setCoreSize(10); config.setMaxSize(10); config.setQueueSize(500); config.setKeepAliveTime(3000); ExecutorService collectExecutor = config.collectExecutor(config); Assert."<AssertPlaceHolder>"; CountDownLatch countDownLatch = new CountDownLatch(COUNT); for (int i = 0; i < COUNT; i++) { collectExecutor.submit(() -> { num.getAndIncrement(); countDownLatch.countDown(); }); } countDownLatch.await(); System.out.println(collectExecutor.isTerminated()); Assert.assertEquals(COUNT, num.get()); }
collectExecutor(CollectExecutorConfig collectExecutorConfig) { ExecutorService collectExecutor = new ThreadPoolExecutor( collectExecutorConfig.getCoreSize(), collectExecutorConfig.getMaxSize(), collectExecutorConfig.getKeepAliveTime(), TimeUnit.MILLISECONDS, new LinkedBlockingDeque<>(collectExecutorConfig.getQueueSize()), new ThreadFactory() { private final AtomicLong threadIndex = new AtomicLong(0);  @Override public Thread newThread(Runnable r) { return new Thread(r, "collectTopicThread_" + this.threadIndex.incrementAndGet()); } }, new ThreadPoolExecutor.DiscardOldestPolicy() ); return collectExecutor; }
[*] target: assertNotNull(collectExecutor)
[-] pred: org. junit. Assert. assertNotNull ( collectExecutor )
************************************
************************************
[+] input: testMatch() { boolean b = MatcherUtil.match("/topic/*.query", "/topic/route.query"); boolean b1 = MatcherUtil.match("/**/**.do", "/consumer/route.do"); boolean b2 = MatcherUtil.match("/*", "/topic/qqq/route.do"); Assert."<AssertPlaceHolder>"; Assert.assertTrue(b1); Assert.assertFalse(b2); }
match(String accessUrl, String reqPath) { String regPath = getRegPath(accessUrl); return Pattern.compile(regPath).matcher(reqPath).matches(); }
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
************************************
************************************
[+] input: TableNotExistException { List<CatalogPartitionSpec> catalogPartitionSpecs = rocketMQCatalog.listPartitions(new ObjectPath("default", "test")); "<AssertPlaceHolder>"; assertEquals( new ArrayList<CatalogPartitionSpec>() { { add( new CatalogPartitionSpec( new HashMap<String, String>(1) { { put("__queue_id__", String.valueOf(0)); } })); add( new CatalogPartitionSpec( new HashMap<String, String>(1) { { put("__queue_id__", String.valueOf(1)); } })); } }, catalogPartitionSpecs); }
listPartitions( ObjectPath tablePath, CatalogPartitionSpec partitionSpec) throws TableNotExistException, TableNotPartitionedException, CatalogException { return listPartitions(tablePath); }
[*] target: assertEquals(2, catalogPartitionSpecs.size())
[-] pred: org. junit. Assert. assertEquals ( 2, catalogPartitionSpecs. size ( ) )
************************************
************************************
[+] input: broadcastAllocateStrategyTest() { AllocateStrategy allocateStrategy = new BroadcastAllocateStrategy(); Collection<RocketMQSourceSplit> mqAll = new ArrayList<>(); for (int i = 0; i < NUM_SPLITS; i++) { mqAll.add( new RocketMQSourceSplit( PREFIX_TOPIC + (i + 1), BROKER_NAME, i, 0, SPLIT_SIZE[i])); } int parallelism = 3; Map<Integer, Set<RocketMQSourceSplit>> result = allocateStrategy.allocate(mqAll, parallelism); "<AssertPlaceHolder>"; for (int i = 0; i < parallelism; i++) { Set<RocketMQSourceSplit> splits = result.get(i); assertEquals(NUM_SPLITS, splits.size());  for (int j = 0; j < NUM_SPLITS; j++) { assertTrue( splits.contains( new RocketMQSourceSplit( PREFIX_TOPIC + (i + 1), BROKER_NAME, i, 0, SPLIT_SIZE[i]))); } } }
allocate( final Collection<RocketMQSourceSplit> mqAll, final int parallelism) { Map<Integer, Set<RocketMQSourceSplit>> result = new HashMap<>(parallelism); for (int i = 0; i < parallelism; i++) { result.computeIfAbsent(i, k -> new HashSet<>()).addAll(mqAll); } return result; }
[*] target: assertEquals(parallelism, result.size())
[-] pred: org. junit. Assert. assertEquals ( parallelism, result. size ( ) )
************************************
************************************
[+] input: SQLException { String jsonString = TABLE_METADATA.getResponse(); Response response = new Response.Builder().code(HttpStatus.SC_OK). request(buildRequest()).protocol(Protocol.HTTP_1_1). message("Successful"). body(ResponseBody.create(jsonString, MediaType.parse("application/json"))).build(); doReturn(response).when(queryExecutor).getMetadata(); ResultSet resultSet = queryServiceMetadata.getColumns("", "", "ContactPointEmail__dlm", ""); while(resultSet.next()) { String columnName = resultSet.getString("COLUMN_NAME"); Assert."<AssertPlaceHolder>"; if (booleanColumns.contains(columnName)) { Assert.assertEquals(resultSet.getInt("DATA_TYPE"), Types.BOOLEAN); Assert.assertEquals(resultSet.getString("SQL_DATA_TYPE"), JavaType.BOOLEAN.getName()); } else { Assert.assertEquals(resultSet.getInt("DATA_TYPE"), Types.VARCHAR); Assert.assertEquals(resultSet.getString("SQL_DATA_TYPE"), JavaType.STRING.getName()); } } Assert.assertEquals(resultSet.getMetaData().getColumnCount(), 24); }
getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException { MetadataResponse metadataResponse = getMetadataResponse(); return createColumnResultSet(metadataResponse, tableNamePattern); }
[*] target: assertNotNull(columnName)
[-] pred: org. junit. Assert. assertNotNull ( columnName )
************************************
************************************
[+] input: testEmpty() { ClientRunContext runContext = ClientRunContexts.empty(); assertNull(runContext.getSubject()); assertNull(runContext.getSession()); "<AssertPlaceHolder>"; assertNull(runContext.getLocale()); assertEquals(TransactionScope.REQUIRED, runContext.getTransactionScope()); }
getUserAgent() { return m_userAgent; }
[*] target: assertNull(runContext.getUserAgent())
[-] pred: org. junit. Assert. assertNull ( runContext. getUserAgent() )
************************************
************************************
[+] input: testIconCellSetErrorStatus() { final String testIconId = ""; Cell c = new Cell(); c.setIconId(testIconId); c.addErrorStatus(new Status("error", IStatus.ERROR)); c.addErrorStatus(new Status("error2", IStatus.ERROR)); c.clearErrorStatus(); c.addErrorStatus(new Status("error3", IStatus.ERROR)); c.clearErrorStatus(); assertNull(c.getErrorStatus()); "<AssertPlaceHolder>"; }
getIconId() { return m_cellSpecialization.getIconId(); }
[*] target: assertEquals(testIconId, c.getIconId())
[-] pred: org. junit. Assert. assertEquals ( testIconId, c. getIconId ( ) )
************************************
************************************
[+] input: testFormEventResetComplete() { final Boolean[] called = {false}; final AbstractForm form = new TestForm(false); form.addFormListener(e -> { if (e.getType() == FormEvent.TYPE_RESET_COMPLETE) { called[0] = true; } }); form.start(); assertFalse(called[0]); form.doReset(); "<AssertPlaceHolder>"; }
doReset() { setFormLoading(true); // reset values Consumer<IFormField> v = field -> { if (field instanceof IResettableFormField) { IResettableFormField f = (IResettableFormField) field; f.resetValue(); } }; try { visit(v, IFormField.class); // init again reinit(); // load again loadStateInternal(); } catch (RuntimeException | PlatformError e) { throw BEANS.get(PlatformExceptionTranslator.class).translate(e) .withContextInfo("form", getClass().getName()); } fireFormResetComplete(); }
[*] target: assertTrue(called[0])
[-] pred: org. junit. Assert. assertTrue ( called[0] )
************************************
************************************
[+] input: testEnsureDeclaredNodes() { EntityFixtureDo testObj = BEANS.get(EntityFixtureDo.class); assertFalse(testObj.id().exists()); assertFalse(testObj.otherEntitiesList().exists()); assertFalse(testObj.otherEntities().exists()); assertFalse(testObj.otherEntitiesMap().exists());  EntityFixtureDo testObjEnsuredNodes = m_helper.ensureDeclaredNodes(testObj); "<AssertPlaceHolder>"; assertTrue(testObjEnsuredNodes.id().exists()); assertTrue(testObjEnsuredNodes.otherEntitiesList().exists()); assertTrue(testObjEnsuredNodes.otherEntities().exists()); assertTrue(testObjEnsuredNodes.otherEntitiesMap().exists()); }
ensureDeclaredNodes(E entity) { if (entity == null) { return null; } m_dataObjectInventory.get().getAttributesDescription(entity.getClass()) .values() .forEach(desc -> ensureNodeValue(entity, desc.getName(), desc.getType().getRawType(), null, false)); return entity; }
[*] target: assertEquals(testObj, testObjEnsuredNodes)
[-] pred: org. junit. Assert. assertEquals ( testObj, testObjEnsuredNodes )
************************************
************************************
[+] input: testExtendAllDoNodeTypesAllExisting() { final IDoEntity target = BEANS.get(DoEntityBuilder.class) .put("stringAttribute", "t") .putList("stringList", Arrays.asList("x", "y", "z")).build(); target.putSet("stringSet", CollectionUtility.hashSet("a", "b", "c")); target.putCollection("stringCollection", Arrays.asList("u", "v", "w"));  final IDoEntity template = BEANS.get(DoEntityBuilder.class) .put("stringAttribute", "t2") .putList("stringList", Arrays.asList("x2", "y2", "z2")).build(); template.putSet("stringSet", CollectionUtility.hashSet("a2", "b2", "c2")); template.putCollection("stringCollection", Arrays.asList("u2", "v2", "w2"));  final IDoEntity targetExtended = m_helper.extend(target, template); "<AssertPlaceHolder>"; assertEquals(target, targetExtended); assertNotEquals(template, targetExtended); }
extends IDoEntity> E extend(E target, IDoEntity template) { return ensureNodeValues(target, template, false); }
[*] target: assertSame(target, targetExtended)
[-] pred: org. junit. Assert. assertSame ( target, targetExtended )
************************************
************************************
[+] input: testApplyValues() { final IDoEntity target = BEANS.get(DoEntityBuilder.class) .put("stringAttribute", "s") .putList("stringList", Arrays.asList("a", "b", "c")) .build();  final IDoEntity template = BEANS.get(DoEntityBuilder.class) .put("nullAttribute", null) .put("stringAttribute", "t") .put("otherAttribute", "t") .putList("nullList", (List<?>) null) .putList("stringList", Arrays.asList("x", "y", "z")) .putList("otherList", Arrays.asList("x", "y", "z")) .build();  final IDoEntity targetExtended = m_helper.applyValues(target, template); "<AssertPlaceHolder>";  // check JSON content final IDoEntity expected = BEANS.get(DoEntityBuilder.class) .put("stringAttribute", "t") .putList("stringList", Arrays.asList("x", "y", "z")) .put("nullAttribute", null) .put("otherAttribute", "t") .putList("nullList", (List<?>) null) .putList("otherList", Arrays.asList("x", "y", "z")) .build();  assertEquals(expected, target); assertEquals(expected, targetExtended); }
applyValues(E target, IDoEntity template) { return ensureNodeValues(target, template, true); }
[*] target: assertSame(target, targetExtended)
[-] pred: org. junit. Assert. assertSame ( target, targetExtended )
************************************
************************************
[+] input: testApplyValuesAllDoNodeTypesAllExisting() { final IDoEntity target = BEANS.get(DoEntityBuilder.class) .put("stringAttribute", "t") .putList("stringList", Arrays.asList("x", "y", "z")).build(); target.putSet("stringSet", CollectionUtility.hashSet("a", "b", "c")); target.putCollection("stringCollection", Arrays.asList("u", "v", "w"));  final IDoEntity template = BEANS.get(DoEntityBuilder.class) .put("stringAttribute", "t2") .putList("stringList", Arrays.asList("x2", "y2", "z2")).build(); template.putSet("stringSet", CollectionUtility.hashSet("a2", "b2", "c2")); template.putCollection("stringCollection", Arrays.asList("u2", "v2", "w2"));  final IDoEntity targetExtended = m_helper.applyValues(target, template); "<AssertPlaceHolder>"; assertEquals(template, targetExtended); }
applyValues(E target, IDoEntity template) { return ensureNodeValues(target, template, true); }
[*] target: assertSame(target, targetExtended)
[-] pred: org. junit. Assert. assertSame ( target, targetExtended )
************************************
************************************
[+] input: testEqualsHashCodeFixtureEntity() { EntityFixtureDo entity1 = BEANS.get(EntityFixtureDo.class) .withId("foo") .withOtherEntities(BEANS.get(OtherEntityFixtureDo.class).withId("other1"), BEANS.get(OtherEntityFixtureDo.class).withId("other2")); EntityFixtureDo entity2 = BEANS.get(EntityFixtureDo.class) .withId("foo") .withOtherEntities(BEANS.get(OtherEntityFixtureDo.class).withId("other1"), BEANS.get(OtherEntityFixtureDo.class).withId("other2"));  assertEquals(entity1, entity2); "<AssertPlaceHolder>";  entity2.getOtherEntities().get(0).withId("bar"); assertNotEquals(entity1, entity2); }
hashCode() { int result = m_attributes.hashCode(); Collection<? extends IDoEntityContribution> contributions = hasContributions() ? m_contributions : null; // handle null and empty contributions the same way (lazy init of m_contributions) result = 31 * result + CollectionUtility.hashCodeCollection(contributions); // element order is not relevant return result; }
[*] target: assertEquals(entity1.hashCode(), entity2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( entity1. hashCode ( ), entity2. hashCode() )
************************************
************************************
[+] input: testLast() { assertEquals("baz", m_testDoList.last()); m_testDoList.remove("baz"); assertEquals("bar", m_testDoList.last()); m_testDoList.clear(); "<AssertPlaceHolder>"; }
last() { return size() == 0 ? null : get(get().size() - 1); }
[*] target: assertNull(m_testDoList.last())
[-] pred: org. junit. Assert. assertNull ( m_testDoList. last() )
************************************
************************************
[+] input: testAttributeName() { FixtureDoNode node = new FixtureDoNode(); assertNull(node.getAttributeName()); node.setAttributeName("nodeAttributeName"); assertEquals("nodeAttributeName", node.getAttributeName()); node.setAttributeName(null); "<AssertPlaceHolder>"; }
getAttributeName() { return m_attributeName; }
[*] target: assertNull(node.getAttributeName())
[-] pred: org. junit. Assert. assertNull ( node. getAttributeName() )
************************************
************************************
[+] input: testCompositeIdByComponent() { FixtureCompositeId_CardinalityOne id = BEANS.get(IdFactory.class).createInternal(FixtureCompositeId_CardinalityOne.class, "abc"); List<? extends IId> idComponents = id.unwrap(); "<AssertPlaceHolder>"; assertEquals("abc", idComponents.get(0).unwrap()); }
createInternal(Class<ID> idClass, Object... values) { try { Method createMethod = lookupCreateMethod(idClass); return idClass.cast(createMethod.invoke(null, values)); } catch (Exception e) { throw BEANS.get(PlatformExceptionTranslator.class).translate(e) .withContextInfo("idClass", idClass.getName()) .withContextInfo("values", Arrays.toString(values)); } }
[*] target: assertEquals(1, idComponents.size())
[-] pred: org. junit. Assert. assertEquals ( 1, idComponents. size ( ) )
************************************
************************************
[+] input: testGetMessageDefaultConstructorWithStatus() { ProcessingStatus status = new ProcessingStatus("title", "body", IStatus.ERROR); ProcessingException processingException = new ProcessingException().withStatus(status); "<AssertPlaceHolder>"; assertEquals("title: body [severity=ERROR]", processingException.getMessage()); assertEquals("title: body", processingException.getDisplayMessage()); }
getStatus() { return m_status; }
[*] target: assertEquals(status, processingException.getStatus())
[-] pred: org. junit. Assert. assertEquals ( status, processingException. getStatus() )
************************************
************************************
[+] input: testGetMessageStatusConstructor() { ProcessingStatus status = new ProcessingStatus("title", "body", IStatus.ERROR); ProcessingException processingException = new ProcessingException(status); "<AssertPlaceHolder>"; assertEquals("title: body [severity=ERROR]", processingException.getMessage()); assertEquals("title: body", processingException.getDisplayMessage()); }
getStatus() { return m_status; }
[*] target: assertEquals(status, processingException.getStatus())
[-] pred: org. junit. Assert. assertEquals ( status, processingException. getStatus() )
************************************
************************************
[+] input: testGetMessageDefaultConstructor() { VetoException vetoException = new VetoException(); "<AssertPlaceHolder>"; assertEquals("undefined [severity=ERROR]", vetoException.getMessage()); assertEquals("undefined", vetoException.getDisplayMessage()); }
getHtmlMessage() { return m_htmlMessage; }
[*] target: assertNull(vetoException.getHtmlMessage())
[-] pred: org. junit. Assert. assertNull ( vetoException. getHtmlMessage() )
************************************
************************************
[+] input: testGetMessageMessageConstructor() { VetoException vetoException = new VetoException("message"); "<AssertPlaceHolder>"; assertEquals("message [severity=ERROR]", vetoException.getMessage()); assertEquals("message", vetoException.getDisplayMessage()); }
getHtmlMessage() { return m_htmlMessage; }
[*] target: assertNull(vetoException.getHtmlMessage())
[-] pred: org. junit. Assert. assertNull ( vetoException. getHtmlMessage() )
************************************
************************************
[+] input: testGetMessageStatusConstructor() { VetoException vetoException = new VetoException(m_processingStatus); "<AssertPlaceHolder>"; assertEquals("title: body [severity=ERROR]", vetoException.getMessage()); assertEquals(PROCESSING_STATUS_MESSAGE, vetoException.getDisplayMessage()); }
getHtmlMessage() { return m_htmlMessage; }
[*] target: assertNull(vetoException.getHtmlMessage())
[-] pred: org. junit. Assert. assertNull ( vetoException. getHtmlMessage() )
************************************
************************************
[+] input: testScanFolder() { URL scoutXml = getClass().getResource("/" + JandexInventoryBuilder.SCOUT_XML_PATH); JandexInventoryBuilder builder = new JandexInventoryBuilder(RebuildStrategy.ALWAYS); Index index = builder.scanModule(builder.findIndexUri(scoutXml)); "<AssertPlaceHolder>"; ClassInfo c = index.getClassByName(DotName.createSimple(FixtureJandexInventoryObject.class.getName())); assertNotNull(c); assertEquals(FixtureJandexInventoryObject.class.getSimpleName(), c.simpleName()); }
findIndexUri(URL scoutXmlUrl) { String s = scoutXmlUrl.toExternalForm(); try { return new URI(s.substring(0, s.length() - SCOUT_XML_PATH.length()) + JANDEX_INDEX_PATH); } catch (URISyntaxException ex) { throw new PlatformException("Cannot find index URI from '{}'", s, ex); } }
[*] target: assertNotNull(index)
[-] pred: org. junit. Assert. assertNotNull ( index )
************************************
************************************
[+] input: IOException { JandexInventoryBuilder builder = new JandexInventoryBuilder(RebuildStrategy.ALWAYS); Index index1 = builder.scanModule(builder.findIndexUri(getClass().getResource("test repository/META-INF/scout.xml"))); Index index2 = builder.scanModule(builder.findIndexUri(new URL("jar:" + getClass().getResource("test repository/test.jar_").toExternalForm() + "!/META-INF/scout.xml"))); "<AssertPlaceHolder>"; assertNotNull(index2); }
findIndexUri(URL scoutXmlUrl) { String s = scoutXmlUrl.toExternalForm(); try { return new URI(s.substring(0, s.length() - SCOUT_XML_PATH.length()) + JANDEX_INDEX_PATH); } catch (URISyntaxException ex) { throw new PlatformException("Cannot find index URI from '{}'", s, ex); } }
[*] target: assertNotNull(index1)
[-] pred: org. junit. Assert. assertNotNull ( index1 )
************************************
************************************
[+] input: testCopy() { JobInput input = Jobs.newInput().withRunContext(RunContexts.empty()); input.withName("name");  JobInput copy = input.copy();  assertNotSame(input.getRunContext(), copy.getRunContext()); "<AssertPlaceHolder>"; }
getName() { return m_name; }
[*] target: assertEquals(input.getName(), copy.getName())
[-] pred: org. junit. Assert. assertEquals ( input. getName(), copy. getName() )
************************************
************************************
[+] input: test() { IFuture<Void> future1 = Jobs.schedule(mock(IRunnable.class), Jobs.newInput().withName("job_A_job")); IFuture<Void> future2 = Jobs.schedule(mock(IRunnable.class), Jobs.newInput().withName("job_B_job")); IFuture<Void> future3 = Jobs.schedule(mock(IRunnable.class), Jobs.newInput().withName("job_C_job"));  Predicate<IFuture<?>> filter = new JobNameRegexFutureFilter(Pattern.compile(".*[AB].*")); assertTrue(filter.test(future1)); assertTrue(filter.test(future2)); "<AssertPlaceHolder>";  // cleanup Jobs.getJobManager().awaitDone(Jobs.newFutureFilterBuilder() .andMatchFuture(future1, future2, future3) .toFilter(), 10, TimeUnit.SECONDS); }
test(final IFuture<?> future) { if (future.getJobInput().getName() == null) { return false; } return m_regex.matcher(future.getJobInput().getName()).matches(); }
[*] target: assertFalse(filter.test(future3))
[-] pred: org. junit. Assert. assertFalse ( filter. test ( future3 ) )
************************************
************************************
[+] input: testGetJulRootLogger() { java.util.logging.Logger julLogger = m_loggerSupport.getJulLogger(Logger.ROOT_LOGGER_NAME); "<AssertPlaceHolder>"; assertEquals("", julLogger.getName()); }
getJulLogger(String name) { if (name.equalsIgnoreCase(Logger.ROOT_LOGGER_NAME)) { name = ""; } return java.util.logging.Logger.getLogger(name); }
[*] target: assertNotNull(julLogger)
[-] pred: org. junit. Assert. assertNotNull ( julLogger )
************************************
************************************
[+] input: testGetListenersEmptyNotNull() { final BasicPropertySupport propertySupport = new BasicPropertySupport(null); assertTrue(propertySupport.getPropertyChangeListeners().isEmpty()); "<AssertPlaceHolder>"; }
getSpecificPropertyChangeListeners() { Map<String, List<PropertyChangeListener>> listeners = new HashMap<>(); synchronized (m_listenerLock) { if (m_childListeners != null) { for (Entry<String, List<Object>> entry : m_childListeners.entrySet()) { final String propertyName = entry.getKey(); final List propertySpecificListeners = entry.getValue(); if (propertySpecificListeners != null) { for (Object o : propertySpecificListeners) { if (o instanceof WeakReference) { o = ((Reference) o).get(); } if (o != null) { List<PropertyChangeListener> children = listeners.computeIfAbsent(propertyName, k -> new ArrayList<>()); children.add((PropertyChangeListener) o); } } } } } } return listeners; }
[*] target: assertTrue(propertySupport.getSpecificPropertyChangeListeners().isEmpty())
[-] pred: org. junit. Assert. assertTrue ( propertySupport. getSpecificPropertyChangeListeners ( ). isEmpty ( ) )
************************************
************************************
[+] input: testHashPassword() { final byte[] salt = SecurityUtility.createRandomBytes(); final byte[] salt2 = SecurityUtility.createRandomBytes();  // test hash byte[] hash1 = SecurityUtility.hashPassword(PASSWORD, salt); byte[] hash2 = SecurityUtility.hashPassword(PASSWORD, salt2); byte[] hash3 = SecurityUtility.hashPassword(PASSWORD, salt); byte[] hash4 = SecurityUtility.hashPassword("other".toCharArray(), salt);  // ensure hashing was executed Assert.assertFalse(Arrays.equals(String.valueOf(PASSWORD).getBytes(ENCODING), hash1));  // ensure different salts matter Assert.assertFalse(Arrays.equals(hash1, hash2));  // ensure same input -> same output Assert.assertArrayEquals(hash1, hash3);  // ensure different input -> different output Assert.assertFalse(Arrays.equals(hash4, hash1));  // test invalid values boolean ok = false; try { SecurityUtility.hashPassword(null, salt); } catch (AssertionException e) { ok = true; } Assert.assertTrue(ok);  ok = false; try { SecurityUtility.hashPassword(PASSWORD, null); } catch (AssertionException e) { ok = true; } Assert.assertTrue(ok); ok = false; try { SecurityUtility.hashPassword("".toCharArray(), salt); } catch (AssertionException e) { ok = true; } Assert.assertTrue(ok); ok = false; try { SecurityUtility.hashPassword(PASSWORD, new byte[]{}); } catch (AssertionException e) { ok = true; } Assert."<AssertPlaceHolder>"; }
hashPassword(char[] password, byte[] salt) { return SECURITY_PROVIDER.get().createPasswordHash(password, salt); }
[*] target: assertTrue(ok)
[-] pred: org. junit. Assert. assertTrue ( ok )
************************************
************************************
[+] input: testMultiStatusSeverity() { MultiStatus multiStatus = new MultiStatus(); multiStatus.add(m_warningStatus); multiStatus.add(m_infoStatus); assertTrue(multiStatus.getSeverity() == IStatus.WARNING); "<AssertPlaceHolder>"; }
isMultiStatus() { return true; }
[*] target: assertTrue(multiStatus.isMultiStatus())
[-] pred: org. junit. Assert. assertTrue ( multiStatus. isMultiStatus() )
************************************
************************************
[+] input: testEquals() { MultiStatus multiStatus = new MultiStatus(); multiStatus.add(m_warningStatus); multiStatus.add(m_infoStatus); MultiStatus multiStatus2 = new MultiStatus(); multiStatus2.add(m_infoStatus); multiStatus2.add(m_warningStatus); "<AssertPlaceHolder>"; assertEquals(new MultiStatus(), new MultiStatus()); assertNotEquals(multiStatus, m_warningStatus); assertNotEquals(multiStatus, new Status("aaa")); assertNotEquals(multiStatus, new MultiStatus()); }
add(IStatus status) { m_children.add(Assertions.assertNotNull(status)); }
[*] target: assertEquals(multiStatus, multiStatus2)
[-] pred: org. junit. Assert. assertEquals ( multiStatus, multiStatus2 )
************************************
************************************
[+] input: testMandatoryWithExistingTransactionAndError() { final RuntimeException exception = new RuntimeException("Expected JUnit exception"); ITransaction callingTransaction = mock(ITransaction.class);  final Holder<ITransaction> actualTransaction = new Holder<>();  CallableChain<Object> chain = new CallableChain<>(); chain.add(new TransactionProcessor<>() .withCallerTransaction(callingTransaction) .withTransactionScope(TransactionScope.MANDATORY)); try { chain.call(() -> { actualTransaction.setValue(ITransaction.CURRENT.get()); throw exception; }); fail(); } catch (Exception e) { "<AssertPlaceHolder>";  assertSame(callingTransaction, actualTransaction.getValue()); verifyNoInteractions(m_transaction); verify(callingTransaction, never()).commitPhase1(); verify(callingTransaction, never()).commitPhase2(); verify(callingTransaction, never()).rollback(); verify(callingTransaction, never()).release(); verify(callingTransaction, times(1)).addFailure(any(Exception.class)); } }
withTransactionScope(final TransactionScope transactionScope) { m_transactionScope = Assertions.assertNotNull(transactionScope, "transactionScope must not be null"); return this; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: Exception { final RuntimeException exception = new RuntimeException("Expected JUnit exception");  final Holder<ITransaction> actualTransaction = new Holder<>();  CallableChain<Object> chain = new CallableChain<>(); chain.add(new TransactionProcessor<>() .withCallerTransaction(null) .withTransactionScope(TransactionScope.REQUIRES_NEW)); try { chain.call(() -> { actualTransaction.setValue(ITransaction.CURRENT.get()); throw exception; }); fail(); } catch (RuntimeException e) { "<AssertPlaceHolder>"; assertSame(m_transaction, actualTransaction.getValue());  verify(m_transaction, times(1)).release();  InOrder inOrder = Mockito.inOrder(m_transaction); inOrder.verify(m_transaction, never()).commitPhase1(); inOrder.verify(m_transaction, never()).commitPhase2(); inOrder.verify(m_transaction, times(1)).rollback(); inOrder.verify(m_transaction, times(1)).release(); } }
withTransactionScope(final TransactionScope transactionScope) { m_transactionScope = Assertions.assertNotNull(transactionScope, "transactionScope must not be null"); return this; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: Exception { final RuntimeException exception = new RuntimeException("Expected JUnit exception");  m_transaction.registerMember(new TestTransactionMember(exception));  final Holder<ITransaction> actualTransaction = new Holder<>();  CallableChain<Object> chain = new CallableChain<>(); chain.add(new TransactionProcessor<>() .withCallerTransaction(null) .withTransactionScope(TransactionScope.REQUIRES_NEW)); try { chain.call(() -> { actualTransaction.setValue(ITransaction.CURRENT.get()); return "result"; }); fail(); } catch (RuntimeException e) { "<AssertPlaceHolder>"; assertSame(m_transaction, actualTransaction.getValue());  verify(m_transaction, times(1)).release();  InOrder inOrder = Mockito.inOrder(m_transaction); inOrder.verify(m_transaction, times(1)).commitPhase1(); inOrder.verify(m_transaction, never()).commitPhase2(); inOrder.verify(m_transaction, times(1)).rollback(); inOrder.verify(m_transaction, times(1)).release(); } }
withTransactionScope(final TransactionScope transactionScope) { m_transactionScope = Assertions.assertNotNull(transactionScope, "transactionScope must not be null"); return this; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: Exception { final RuntimeException exception = new RuntimeException("Expected JUnit exception");  final Holder<ITransaction> actualTransaction = new Holder<>();  CallableChain<Object> chain = new CallableChain<>(); chain.add(new TransactionProcessor<>() .withCallerTransaction(null) .withTransactionScope(TransactionScope.REQUIRES_NEW)); try { chain.call(() -> { actualTransaction.setValue(ITransaction.CURRENT.get()); throw exception; }); fail(); } catch (RuntimeException e) { "<AssertPlaceHolder>"; assertSame(m_transaction, actualTransaction.getValue());  verify(m_transaction, times(1)).release();  InOrder inOrder = Mockito.inOrder(m_transaction);  inOrder.verify(m_transaction, never()).commitPhase1(); inOrder.verify(m_transaction, never()).commitPhase2(); inOrder.verify(m_transaction, times(1)).rollback(); inOrder.verify(m_transaction, times(1)).release(); } }
withTransactionScope(final TransactionScope transactionScope) { m_transactionScope = Assertions.assertNotNull(transactionScope, "transactionScope must not be null"); return this; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: Exception { final RuntimeException exception = new RuntimeException("Expected JUnit exception");  ITransactionMember m = new TestTransactionMember(exception);  m_transaction.registerMember(m);  final Holder<ITransaction> actualTransaction = new Holder<>(); CallableChain<Object> chain = new CallableChain<>(); chain.add(new TransactionProcessor<>() .withCallerTransaction(null) .withTransactionScope(TransactionScope.REQUIRES_NEW)); try { chain.call(() -> { actualTransaction.setValue(ITransaction.CURRENT.get()); return "result"; }); fail(); } catch (RuntimeException e) { "<AssertPlaceHolder>"; assertSame(m_transaction, actualTransaction.getValue());  verify(m_transaction, times(1)).release();  InOrder inOrder = Mockito.inOrder(m_transaction);  inOrder.verify(m_transaction, times(1)).commitPhase1(); inOrder.verify(m_transaction, never()).commitPhase2(); inOrder.verify(m_transaction, times(1)).rollback(); inOrder.verify(m_transaction, times(1)).release(); } finally { m_transaction.unregisterMember(m); } }
withTransactionScope(final TransactionScope transactionScope) { m_transactionScope = Assertions.assertNotNull(transactionScope, "transactionScope must not be null"); return this; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: Exception { ITransaction callingTransaction = mock(ITransaction.class);  final RuntimeException exception = new RuntimeException("Expected JUnit exception");  final Holder<ITransaction> actualTransaction = new Holder<>();  CallableChain<Object> chain = new CallableChain<>(); chain.add(new TransactionProcessor<>() .withCallerTransaction(callingTransaction) .withTransactionScope(TransactionScope.REQUIRED)); try { chain.call(() -> { actualTransaction.setValue(ITransaction.CURRENT.get()); throw exception; }); fail(); } catch (RuntimeException e) { "<AssertPlaceHolder>"; assertSame(callingTransaction, actualTransaction.getValue());  verifyNoInteractions(m_transaction);  verify(callingTransaction, never()).commitPhase1(); verify(callingTransaction, never()).commitPhase2(); verify(callingTransaction, never()).rollback(); verify(callingTransaction, times(1)).addFailure(any(Throwable.class)); } }
withTransactionScope(final TransactionScope transactionScope) { m_transactionScope = Assertions.assertNotNull(transactionScope, "transactionScope must not be null"); return this; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: testInstance() { String s = "test"; String res = Assertions.assertInstance(s, String.class); "<AssertPlaceHolder>"; }
assertEquals(final T value1, final Object value2) { return assertEquals(value1, value2, "expected value1 to be equals with value2 [value1={}, value2={}]", value1, value2); }
[*] target: assertEquals(s, res)
[-] pred: org. junit. Assert. assertEquals ( s, res )
************************************
************************************
[+] input: testType() { String s = "test"; String res = Assertions.assertType(s, String.class); "<AssertPlaceHolder>"; }
assertEquals(final T value1, final Object value2) { return assertEquals(value1, value2, "expected value1 to be equals with value2 [value1={}, value2={}]", value1, value2); }
[*] target: assertEquals(s, res)
[-] pred: org. junit. Assert. assertEquals ( s, res )
************************************
************************************
[+] input: testAsIterator() { Enumeration<String> enumeration = enumeration(Arrays.asList("foo", "bar", "baz")); Iterator<String> iter = asIterator(enumeration); assertTrue(iter.hasNext()); assertEquals("foo", iter.next()); assertEquals("bar", iter.next()); assertEquals("baz", iter.next()); "<AssertPlaceHolder>"; }
hasNext() { return enumeration.hasMoreElements(); }
[*] target: assertFalse(iter.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iter. hasNext() )
************************************
************************************
[+] input: XMLStreamException { XMLInputFactory factory = XmlUtility.newXMLInputFactory(); Assert."<AssertPlaceHolder>";  XMLEventReader reader = factory.createXMLEventReader(new ByteArrayInputStream(SIMPLE_XML.getBytes(StandardCharsets.UTF_8))); StringBuilder b = new StringBuilder(); while (reader.hasNext()) { XMLEvent event = reader.nextEvent(); b.append(event.getEventType()); } assertEquals("711228", b.toString()); }
newXMLInputFactory() { XMLInputFactory factory = XMLInputFactory.newInstance(); try { factory.setProperty(XMLInputFactory.SUPPORT_DTD, false); } catch (IllegalArgumentException e) { LOG.debug("Attribute '{}' is not supported in the current XMLInputFactory: {}", XMLInputFactory.SUPPORT_DTD, factory.getClass().getName(), e); } try { factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false); } catch (IllegalArgumentException e) { LOG.debug("Attribute '{}' is not supported in the current XMLInputFactory: {}", XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, factory.getClass().getName(), e); } return factory; }
[*] target: assertNotNull(factory)
[-] pred: org. junit. Assert. assertNotNull ( factory )
************************************
************************************
[+] input: TransformerException { Transformer transformer = XmlUtility.newTransformer(); Assert."<AssertPlaceHolder>";  StreamSource s = new StreamSource(new ByteArrayInputStream(SIMPLE_XML.getBytes(StandardCharsets.UTF_8))); ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamResult r = new StreamResult(out); transformer.transform(s, r); assertEquals(SIMPLE_XML, new String(out.toByteArray(), StandardCharsets.UTF_8)); }
newTransformer() throws TransformerConfigurationException { TransformerFactory tf = TransformerFactory.newInstance(); try { tf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true); } catch (TransformerConfigurationException e) { LOG.debug("Feature '{}' is not supported in the current TransformerFactory: {}", XMLConstants.FEATURE_SECURE_PROCESSING, tf.getClass().getName(), e); } try { tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, ""); } catch (IllegalArgumentException e) { // some factories (e.g. xalan) throw this exception if they do not support this attribute LOG.debug("Attribute '{}' is not supported in the current TransformerFactory: {}", XMLConstants.ACCESS_EXTERNAL_DTD, tf.getClass().getName(), e); } try { // some factories (e.g. xalan) throw this exception if they do not support this attribute tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, ""); } catch (IllegalArgumentException e) { LOG.debug("Attribute '{}' is not supported in the current TransformerFactory: {}", XMLConstants.ACCESS_EXTERNAL_DTD, tf.getClass().getName(), e); } return tf.newTransformer(); }
[*] target: assertNotNull(transformer)
[-] pred: org. junit. Assert. assertNotNull ( transformer )
************************************
************************************
[+] input: testClear() { assertTrue(c.isEmpty()); c.clear(); assertTrue(c.isEmpty()); assertTrue(c.addOrdered(m_ordered10)); assertTrue(c.addOrdered(m_ordered20)); assertTrue(c.addOrdered(m_ordered30)); assertFalse(c.isEmpty()); c.clear(); assertTrue(c.isEmpty()); c.clear(); "<AssertPlaceHolder>"; }
isEmpty() { return m_orderedObjects.isEmpty(); }
[*] target: assertTrue(c.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( c. isEmpty() )
************************************
************************************
[+] input: testWithExceptionInRemove() { GroupedSynchronizer<String, String> lck = new GroupedSynchronizer<>(); RuntimeException expectedException = new RuntimeException(); String key = "key"; lck.runInGroupLock(key, () -> { }, Function.identity());  assertEquals(1, lck.size()); assertNull(lck.remove("nonExisting")); assertEquals(0, lck.numLockedRootLocks());  try { lck.remove("key", obj -> { assertEquals(1, lck.numLockedRootLocks()); throw expectedException; }); } catch (RuntimeException e) { assertSame(expectedException, e); }  // lock is available again: assertEquals(0, lck.numLockedRootLocks()); "<AssertPlaceHolder>"; // remove is done (event there was an exception) }
size() { return m_locks.size(); }
[*] target: assertEquals(0, lck.size())
[-] pred: org. junit. Assert. assertEquals ( 0, lck. size() )
************************************
************************************
[+] input: testAddDays() { TimeZone.setDefault(TimeZone.getTimeZone("GMT+1")); assertEquals("Test only works without day Daylight Saving Time", 0, TimeZone.getDefault().getDSTSavings());  for (int sec = 0; sec < SECONDS_IN_DAY; sec++) { double d = sec / SECONDS_IN_DAY; Calendar cal = getCalendar(1, 0);  String result = stringOf(DateUtility.addDays(cal.getTime(), d));  cal.set(Calendar.SECOND, sec);  String expected = stringOf(cal.getTime()); "<AssertPlaceHolder>"; } }
addDays(Date d, double count) { if (d == null) { return null; } int sign = 1; if (count < 0) { count = -count; sign = -1; } double roundingFactor = (sign > 0) ? 0.000004 : 0.0000017; int sec = (int) ((count + roundingFactor) * 3600 * 24); Calendar cal = Calendar.getInstance(); cal.setTime(d); cal.add(Calendar.DATE, sign * (sec / 3600 / 24)); cal.add(Calendar.HOUR_OF_DAY, sign * ((sec / 3600) % 24)); cal.add(Calendar.MINUTE, sign * ((sec / 60) % 60)); cal.add(Calendar.SECOND, sign * ((sec) % 60)); return cal.getTime(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testSubtractDays() { TimeZone.setDefault(TimeZone.getTimeZone("GMT+1")); assertEquals("Test only works without day Daylight Saving Time", 0, TimeZone.getDefault().getDSTSavings());  for (int sec = 0; sec < SECONDS_IN_DAY; sec++) { double d = -sec / SECONDS_IN_DAY; Calendar cal = getCalendar(1, 0);  String result = stringOf(DateUtility.addDays(cal.getTime(), d));  cal.set(Calendar.SECOND, -sec);  String expected = stringOf(cal.getTime()); "<AssertPlaceHolder>"; } }
addDays(Date d, double count) { if (d == null) { return null; } int sign = 1; if (count < 0) { count = -count; sign = -1; } double roundingFactor = (sign > 0) ? 0.000004 : 0.0000017; int sec = (int) ((count + roundingFactor) * 3600 * 24); Calendar cal = Calendar.getInstance(); cal.setTime(d); cal.add(Calendar.DATE, sign * (sec / 3600 / 24)); cal.add(Calendar.HOUR_OF_DAY, sign * ((sec / 3600) % 24)); cal.add(Calendar.MINUTE, sign * ((sec / 60) % 60)); cal.add(Calendar.SECOND, sign * ((sec) % 60)); return cal.getTime(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testAddMilliseconds() { TimeZone.setDefault(TimeZone.getTimeZone("GMT+1")); assertEquals("Test only works without day Daylight Saving Time", 0, TimeZone.getDefault().getDSTSavings());  for (int i = 0; i < SECONDS_IN_DAY; i++) { Calendar cal = Calendar.getInstance(); cal.set(Calendar.DATE, 1); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); String result = stringOf(DateUtility.addMilliseconds(cal.getTime(), i)); cal.set(Calendar.MILLISECOND, i); String expected = stringOf(cal.getTime()); "<AssertPlaceHolder>"; } }
addMilliseconds(Date d, int milliseconds) { return addTime(d, Calendar.MILLISECOND, milliseconds); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testAddSeconds() { TimeZone.setDefault(TimeZone.getTimeZone("GMT+1")); assertEquals("Test only works without day Daylight Saving Time", 0, TimeZone.getDefault().getDSTSavings());  Calendar cal = Calendar.getInstance(); for (int i = 0; i < SECONDS_IN_DAY; i++) { cal.set(Calendar.DATE, 1); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); String result = stringOf(DateUtility.addSeconds(cal.getTime(), i)); cal.set(Calendar.SECOND, i); String expected = stringOf(cal.getTime()); "<AssertPlaceHolder>"; } }
addSeconds(Date d, int seconds) { return addTime(d, Calendar.SECOND, seconds); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testRemoveOnFire() { final FastListenerList<EventListener> listenerList = new FastListenerList<>(); EventListener[] a = new EventListener[5]; for (int i = 0; i < a.length; i++) { a[i] = new FixtureEventListenerThatRemovesOnFire() { @Override public void handle(Object event) { listenerList.remove(this); } }; listenerList.add(a[i], true); } Assert.assertEquals(5, listenerList.indexes().size()); Assert.assertEquals(expectedList(4, 3, 2, 1, 0), iteratorDump(a, listenerList));  for (EventListener listener : listenerList.list()) { ((FixtureEventListenerThatRemovesOnFire) listener).handle(null); }  Assert.assertEquals(0, listenerList.indexes().size()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(expectedList(), iteratorDump(a, listenerList)); }
isEmpty() { synchronized (lockObject()) { return super.isEmpty(); } }
[*] target: assertTrue(listenerList.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( listenerList. isEmpty() )
************************************
************************************
[+] input: Exception { IScoutTestParameter testParameter = new ParameterizedTestClassParameter("p");  Object createdTestInstance = ParameterizedTestRunnerExtension.createTest(m_testClass, testParameter); "<AssertPlaceHolder>"; assertEquals(SampleParameterizedTestClass.class, createdTestInstance.getClass()); assertEquals(testParameter, ((SampleParameterizedTestClass) createdTestInstance).getTestParameter()); }
createTest(TestClass testClass, IScoutTestParameter testParameter) throws Exception { try { return testClass.getOnlyConstructor().newInstance(testParameter); } catch (Exception ex) { String parameterName = (testParameter != null ? testParameter.getName() : null); throw new Exception("Constructor can not be invoked with the parameter '" + parameterName + "')", ex); } }
[*] target: assertNotNull(createdTestInstance)
[-] pred: org. junit. Assert. assertNotNull ( createdTestInstance )
************************************
************************************
[+] input: testAcquireAndRelease() { OptimisticLock l = new OptimisticLock(); l.acquire(); l.release(); assertFalse(l.isAcquired()); "<AssertPlaceHolder>"; }
isReleased() { return !isAcquired(); }
[*] target: assertTrue(l.isReleased())
[-] pred: org. junit. Assert. assertTrue ( l. isReleased() )
************************************
************************************
[+] input: testMultipleAcquires() { OptimisticLock l = new OptimisticLock(); l.acquire(); l.acquire(); l.release(); assertTrue(l.isAcquired()); "<AssertPlaceHolder>"; }
isReleased() { return !isAcquired(); }
[*] target: assertFalse(l.isReleased())
[-] pred: org. junit. Assert. assertFalse ( l. isReleased() )
************************************
************************************
[+] input: testNullUrlConfig() { HttpServiceTunnel tunnel = new HttpServiceTunnel(); assertNull(tunnel.getServerUrl()); "<AssertPlaceHolder>"; }
isActive() { return m_active; }
[*] target: assertFalse(tunnel.isActive())
[-] pred: org. junit. Assert. assertFalse ( tunnel. isActive() )
************************************
************************************
[+] input: testValidUrlConfig() { when(mockUrl.getValue()).thenReturn("http://localhost"); HttpServiceTunnel tunnel = new HttpServiceTunnel(); assertNotNull(tunnel.getServerUrl()); "<AssertPlaceHolder>"; }
isActive() { return m_active; }
[*] target: assertTrue(tunnel.isActive())
[-] pred: org. junit. Assert. assertTrue ( tunnel. isActive() )
************************************
************************************
[+] input: testLogout() { UiSession uiSession = (UiSession) JsonTestUtility.createAndInitializeUiSession();  uiSession.getClientSession().stop();  assertTrue(uiSession.isDisposed()); "<AssertPlaceHolder>"; JsonTestUtility.endRequest(uiSession); }
currentJsonResponse() { return m_currentJsonResponse; }
[*] target: assertNull(uiSession.currentJsonResponse())
[-] pred: org. junit. Assert. assertNull ( uiSession. currentJsonResponse() )
************************************
************************************
[+] input: testIsAttached() { AbstractJsonAdapter<?> adapter = newAdapter(new Object()); adapter.init(); assertTrue(adapter.isInitialized());  adapter.dispose(); "<AssertPlaceHolder>"; }
isDisposed() { return m_disposed; }
[*] target: assertTrue(adapter.isDisposed())
[-] pred: org. junit. Assert. assertTrue ( adapter. isDisposed() )
************************************
************************************
[+] input: testGetFieldPropertyAnnotation() { PropertyUtils propertyUtils = new PropertyUtils(); propertyUtils.setBeanAccess(BeanAccess.FIELD);  Property name = propertyUtils.getProperty(TestBean.class, "name");  TestAnnotation annotation = name.getAnnotation(TestAnnotation.class); "<AssertPlaceHolder>"; assertEquals("field", annotation.value()); }
getAnnotation(Class<A> annotationType);  @Override public int hashCode() { return getName().hashCode() + getType().hashCode(); }
[*] target: assertNotNull(annotation)
[-] pred: org. junit. Assert. assertNotNull ( annotation )
************************************
************************************
[+] input: testGetMethodPropertyAnnotationSetterOnly() { PropertyUtils propertyUtils = new PropertyUtils(); propertyUtils.setBeanAccess(BeanAccess.PROPERTY);  Property property = propertyUtils.getProperty(TestBean.class, "lastName"); TestAnnotation annotation = property.getAnnotation(TestAnnotation.class); "<AssertPlaceHolder>"; assertEquals("setter", annotation.value()); }
getAnnotation(Class<A> annotationType);  @Override public int hashCode() { return getName().hashCode() + getType().hashCode(); }
[*] target: assertNotNull(annotation)
[-] pred: org. junit. Assert. assertNotNull ( annotation )
************************************
************************************
[+] input: rowShouldEqualToOtherRowWithSimilarFloat() { Row row1 = new Row(); Row row2 = new Row(); row1.add(1.000001); row2.add(1.000002); "<AssertPlaceHolder>"; assertEquals(row2, row1); }
add(Object value) { values.add(roundFloatNum(value)); }
[*] target: assertEquals(row1, row2)
[-] pred: org. junit. Assert. assertEquals ( row1, row2 )
************************************
************************************
[+] input: getMappingForExistingField() { IndexMappings indexMappings = LocalClusterState.state().getFieldMappings(new String[] {INDEX_NAME}); Assert."<AssertPlaceHolder>";  FieldMappings fieldMappings = indexMappings.mapping(INDEX_NAME); Assert.assertNotNull(fieldMappings);  Assert.assertEquals("text", fieldMappings.mapping("address").get("type")); Assert.assertEquals("integer", fieldMappings.mapping("age").get("type")); Assert.assertEquals("keyword", fieldMappings.mapping("city").get("type")); Assert.assertEquals("text", fieldMappings.mapping("employer").get("type"));  Assert.assertEquals("text", fieldMappings.mapping("manager.name").get("type")); Assert.assertEquals("keyword", fieldMappings.mapping("manager.address").get("type")); }
getFieldMappings(String[] indices) { Objects.requireNonNull(client, "Client is null");  try {  Map<String, MappingMetadata> mappingMetadata = client .admin() .indices() .prepareGetMappings(indices) .setLocal(true) .setIndicesOptions(IndicesOptions.strictExpandOpen()) .execute() .actionGet(0, TimeUnit.NANOSECONDS) .mappings();  IndexMappings mappings = new IndexMappings(mappingMetadata);  LOG.debug("Found mappings: {}", mappings); return mappings; } catch (IndexNotFoundException e) { throw e; } catch (Exception e) { throw new IllegalStateException( "Failed to read mapping in cluster state for indices=" + Arrays.toString(indices), e); } }
[*] target: assertNotNull(indexMappings)
[-] pred: org. junit. Assert. assertNotNull ( indexMappings )
************************************
************************************
[+] input: clearEmptyPaths_EmptyPathSize1_ShouldReturnTrueAndMapShouldBeEmpty() { Map<String, Object> map = new HashMap<>(); map.put("a", new HashMap<String, Object>()); boolean result = Util.clearEmptyPaths(map); Assert."<AssertPlaceHolder>"; Assert.assertEquals(0, map.size()); }
clearEmptyPaths(Map<String, Object> map) { if (map.size() == 0) { return true; } Set<String> keysToDelete = new HashSet<>(); for (Map.Entry<String, Object> entry : map.entrySet()) { Object value = entry.getValue(); if (Map.class.isAssignableFrom(value.getClass())) { if (clearEmptyPaths((Map<String, Object>) value)) { keysToDelete.add(entry.getKey()); } } } if (keysToDelete.size() != 0) { if (map.size() == keysToDelete.size()) { map.clear(); return true; } for (String key : keysToDelete) { // TODO: seems like a bug, either fix, or just get rid of for loop and remove the first key map.remove(key); return false; } } return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: clearEmptyPaths_EmptyPathSize2_ShouldReturnTrueAndMapShouldBeEmpty() { Map<String, Object> map = new HashMap<>(); Map<String, Object> innerMap = new HashMap<>(); innerMap.put("b", new HashMap<String, Object>()); map.put("a", innerMap); boolean result = Util.clearEmptyPaths(map); Assert."<AssertPlaceHolder>"; Assert.assertEquals(0, map.size()); }
clearEmptyPaths(Map<String, Object> map) { if (map.size() == 0) { return true; } Set<String> keysToDelete = new HashSet<>(); for (Map.Entry<String, Object> entry : map.entrySet()) { Object value = entry.getValue(); if (Map.class.isAssignableFrom(value.getClass())) { if (clearEmptyPaths((Map<String, Object>) value)) { keysToDelete.add(entry.getKey()); } } } if (keysToDelete.size() != 0) { if (map.size() == keysToDelete.size()) { map.clear(); return true; } for (String key : keysToDelete) { // TODO: seems like a bug, either fix, or just get rid of for loop and remove the first key map.remove(key); return false; } } return false; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { StarRocksTable oldTable = catalog.getTable(DB_NAME, tableName).orElse(null); assertNotNull(oldTable); List<String> dropColumns = Arrays.asList("c2", "c3"); catalog.alterDropColumns(DB_NAME, tableName, dropColumns, 60); StarRocksTable newTable = catalog.getTable(DB_NAME, tableName).orElse(null); "<AssertPlaceHolder>";  List<StarRocksColumn> expectedColumns = oldTable.getColumns().stream() .filter(column -> !dropColumns.contains(column.getColumnName())) .collect(Collectors.toList()); assertEquals(expectedColumns, newTable.getColumns()); }
getTable(String databaseName, String tableName) throws StarRocksCatalogException { Preconditions.checkArgument( !StringUtils.isNullOrWhitespaceOnly(databaseName), "database name cannot be null or empty."); Preconditions.checkArgument( !StringUtils.isNullOrWhitespaceOnly(tableName), "table name cannot be null or empty.");  final String tableSchemaQuery = "SELECT `COLUMN_NAME`, `DATA_TYPE`, `ORDINAL_POSITION`, `COLUMN_SIZE`, `DECIMAL_DIGITS`, " + "`IS_NULLABLE`, `COLUMN_KEY`, `COLUMN_COMMENT` FROM `information_schema`.`COLUMNS` " + "WHERE `TABLE_SCHEMA`=? AND `TABLE_NAME`=?;";  StarRocksTable.TableType tableType = StarRocksTable.TableType.UNKNOWN; List<StarRocksColumn> columns = new ArrayList<>(); List<String> tableKeys = new ArrayList<>(); try (Connection connection = getConnection()) { try (PreparedStatement statement = connection.prepareStatement(tableSchemaQuery)) { statement.setObject(1, databaseName); statement.setObject(2, tableName); try (ResultSet resultSet = statement.executeQuery()) { while (resultSet.next()) { String name = resultSet.getString("COLUMN_NAME"); String type = resultSet.getString("DATA_TYPE"); Integer size = resultSet.getInt("COLUMN_SIZE"); if (resultSet.wasNull()) { size = null; } // mysql does not have boolean type, and starrocks `information_schema`.`COLUMNS` will return // a "tinyint" data type for both StarRocks BOOLEAN and TINYINT type, Distinguish them by // column size, and the size of BOOLEAN is null if ("tinyint".equalsIgnoreCase(type) && size == null) { type = "boolean"; } int position = resultSet.getInt("ORDINAL_POSITION"); Integer scale = resultSet.getInt("DECIMAL_DIGITS"); if (resultSet.wasNull()) { scale = null; } String isNullable = resultSet.getString("IS_NULLABLE"); String comment = resultSet.getString("COLUMN_COMMENT"); StarRocksColumn column = new StarRocksColumn.Builder() .setColumnName(name) .setOrdinalPosition(position - 1) .setDataType(type) .setColumnSize(size) .setDecimalDigits(scale) .setNullable( isNullable == null || !isNullable.equalsIgnoreCase("NO")) .setColumnComment(comment) .build(); columns.add(column);  // Only primary key table has value in this field. and the value is "PRI" String columnKey = resultSet.getString("COLUMN_KEY"); if (!StringUtils.isNullOrWhitespaceOnly(columnKey)) { if (columnKey.equalsIgnoreCase("PRI") && tableType == StarRocksTable.TableType.UNKNOWN) { tableType = StarRocksTable.TableType.PRIMARY_KEY; } tableKeys.add(column.getColumnName()); } } } } } catch (Exception e) { throw new StarRocksCatalogException( String.format("Failed to get table %s.%s", databaseName, tableName), e); }  StarRocksTable starRocksTable = null; if (!columns.isEmpty()) { starRocksTable = new StarRocksTable.Builder() .setDatabaseName(databaseName) .setTableName(tableName) .setTableType(tableType) .setColumns(columns) .setTableKeys(tableKeys) .build(); } return Optional.ofNullable(starRocksTable); }
[*] target: assertNotNull(newTable)
[-] pred: org. junit. Assert. assertNotNull ( newTable )
************************************
************************************
[+] input: IOException { // sample app config String configFile = "./test/data/sample/tkltest_ui_config.toml"; TomlParseResult parsedConfig = Toml.parse(Paths.get(configFile)); String appUrl = parsedConfig.getString("general.app_url"); String testDir = parsedConfig.getString("general.test_directory"); TomlTable generateOptions = parsedConfig.getTable("generate");  // call method for creating crawljax config CrawljaxConfiguration crawljaxConfig = CrawljaxRunner.createCrawljaxConfiguration(appUrl, testDir, generateOptions);  // assert on created config Assert."<AssertPlaceHolder>"; Assert.assertEquals(appUrl, crawljaxConfig.getUrl().toString()); Assert.assertTrue(crawljaxConfig.getOutputDir().toString().endsWith( testDir+File.separator+"localhost"+File.separator+"crawl0")); Assert.assertEquals(0, crawljaxConfig.getMaximumStates()); Assert.assertEquals(2, crawljaxConfig.getCrawlRules().getMaxRepeatExploredActions()); Assert.assertEquals(2, crawljaxConfig.getMaximumDepth()); CrawlRules crawlRules = crawljaxConfig.getCrawlRules(); Assert.assertEquals(9, crawlRules.getPreCrawlConfig().getIncludedElements().size()); Assert.assertEquals(6, crawlRules.getPreCrawlConfig().getExcludedElements().size()); Assert.assertEquals(500, crawlRules.getWaitAfterEvent()); Assert.assertEquals(500, crawlRules.getWaitAfterReloadUrl());  // pre-crawl plugin assertions ImmutableList<Plugin> plugins = crawljaxConfig.getPlugins(); Assert.assertEquals(4, plugins.size()); Assert.assertTrue(plugins.stream().anyMatch(plugin -> plugin instanceof TackleTestOnUrlFirstLoadPlugin)); TackleTestOnUrlFirstLoadPlugin precrawlPlugin = (TackleTestOnUrlFirstLoadPlugin) plugins .stream() .filter(plugin -> plugin instanceof TackleTestOnUrlFirstLoadPlugin) .findFirst() .get(); // assert on submit_totp action TomlTable[] precrawlActions = precrawlPlugin.getPreCrawlActions(); Assert.assertEquals(6, precrawlActions.length); Set<String> expKeySet = Stream .of("action_type", "max_attempts", "optional", "totp_secret_env_var", "enter", "click") .collect(Collectors.toSet()); Assert.assertEquals(expKeySet, precrawlActions[5].keySet()); Assert.assertEquals("submit_totp", precrawlActions[5].getString("action_type")); Assert.assertEquals("TKLTESTUI_TOTP_SECRET", precrawlActions[5].getString("totp_secret_env_var")); Assert.assertEquals(true, precrawlActions[5].getBoolean("optional")); Assert.assertEquals(2, precrawlActions[5].getLong("max_attempts").intValue()); }
createCrawljaxConfiguration(String appUrl, String testDir, TomlTable generateOptions) throws IOException { CrawljaxConfiguration.CrawljaxConfigurationBuilder builder = CrawljaxConfiguration.builderFor(appUrl);  // set browser builder.setBrowserConfig(createBrowserConfiguration( generateOptions.getString("browser"), getIntTypeOption(generateOptions, "browser_pixel_density") ));  // set max runtime long timeLimit = getLongTypeOption(generateOptions, "time_limit"); builder.setMaximumRunTime(timeLimit, TimeUnit.MINUTES);  // set max states int maxStates = getIntTypeOption(generateOptions, "max_states"); if (maxStates == 0) { builder.setUnlimitedStates(); } else { builder.setMaximumStates(maxStates); }  // set max explore action int maxExploreAction = getIntTypeOption(generateOptions, "max_explore_action"); if (maxExploreAction > 1) { builder.crawlRules().skipExploredActions(false, maxExploreAction); }  // set max depth int maxDepth = getIntTypeOption(generateOptions, "max_depth"); if (maxDepth == 0) { builder.setUnlimitedCrawlDepth(); } else { builder.setMaximumDepth(maxDepth); }  // set click rules builder.crawlRules().clickOnce(Boolean.TRUE.equals( generateOptions.getBoolean("click_once"))); builder.crawlRules().clickElementsInRandomOrder(Boolean.TRUE.equals( generateOptions.getBoolean("click_randomly")));  // set wait times builder.crawlRules().waitAfterEvent(getLongTypeOption(generateOptions, "wait_after_event"), TimeUnit.MILLISECONDS); builder.crawlRules().waitAfterReloadUrl(getLongTypeOption(generateOptions, "wait_after_reload"), TimeUnit.MILLISECONDS);  // crawl hidden anchors builder.crawlRules().crawlHiddenAnchors(Boolean.TRUE.equals( generateOptions.getBoolean("crawl_hidden_anchors")));  // click default elements if (getBooleanTypeOption(generateOptions," click_default_elements")) { builder.crawlRules().clickDefaultElements(); }  // handle include_iframes option: if specified use RTED state abstraction function; otherwise // use fragment-based state abstraction if (getBooleanTypeOption(generateOptions, "include_iframes")) { double rtedSimilarityThreshold = getDoubleTypeOption(generateOptions, "rted_similarity_threshold"); builder.setStateVertexFactory(new RTEDStateVertexFactory(rtedSimilarityThreshold)); builder.crawlRules().crawlFrames(true); } else { builder.setStateVertexFactory(new FragGenStateVertexFactory(0, builder, true)); builder.crawlRules().crawlFrames(false); }  // form fill mode CrawlRules.FormFillMode formFillMode = getFormFillMode(generateOptions.getString("form_fill_mode")); builder.crawlRules().setFormFillMode(formFillMode);  // form fill order CrawlRules.FormFillOrder formFillOrder = getFormFillOrder(generateOptions.getString("form_fill_order")); builder.crawlRules().setFormFillOrder(formFillOrder);  // set click and don't-click rules String clickablesSpecFile = generateOptions.getString("clickables_spec_file"); if (clickablesSpecFile != null && !clickablesSpecFile.isEmpty()) { updateClickablesConfiguration(Toml.parse(Paths.get(clickablesSpecFile)), builder); }  // set form input specification String formDataSpecFile = generateOptions.getString("form_data_spec_file"); if (formDataSpecFile != null && !formDataSpecFile.isEmpty()) { InputSpecification inputSpec = getFormInputSpecification(formDataSpecFile); builder.crawlRules().setInputSpec(inputSpec); }  // process pre-crawl actions via onUrlFirstLoad plugin String precrawlActionsSpecFile = generateOptions.getString("precrawl_actions_spec_file"); if (precrawlActionsSpecFile != null && !precrawlActionsSpecFile.isEmpty()) { processPreCrawlActions(Toml.parse(Paths.get(precrawlActionsSpecFile)), builder); }  // add crawl-overview and test-generator plugins builder.addPlugin(new CrawlOverview()); builder.addPlugin(new TestSuiteGenerator(createTestConfiguration("none"))); //        builder.addPlugin(new TestSuiteGenerator( //            createTestConfiguration(generateOptions.getString("add_state_diff_assertions"))));  // set output directory builder.setOutputDirectory(new File(testDir));  return builder.build(); }
[*] target: assertNotNull(crawljaxConfig)
[-] pred: org. junit. Assert. assertNotNull ( crawljaxConfig )
************************************
************************************
[+] input: testWithRealActivities() { testWorkflowRule.getWorker().registerActivitiesImplementations(new ContentLengthActivityImpl()); testWorkflowRule.getTestEnvironment().start();  ContentLengthWorkflow workflow = testWorkflowRule .getWorkflowClient() .newWorkflowStub( ContentLengthWorkflow.class, WorkflowOptions.newBuilder().setTaskQueue(testWorkflowRule.getTaskQueue()).build());  ContentLengthInfo info = workflow.execute();  "<AssertPlaceHolder>"; assertNotNull(info.getWebsiteMap()); assertEquals(1, info.getWebsiteMap().size());  }
execute();
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: testWithMockedActivities() { ContentLengthActivity activities = mock(ContentLengthActivity.class, withSettings().withoutAnnotations());  ContentLengthInfo testInfo = new ContentLengthInfo(); testInfo.add("testsite", 100);  when(activities.count(anyString())).thenReturn(testInfo); testWorkflowRule.getWorker().registerActivitiesImplementations(activities); testWorkflowRule.getTestEnvironment().start();  ContentLengthWorkflow workflow = testWorkflowRule .getWorkflowClient() .newWorkflowStub( ContentLengthWorkflow.class, WorkflowOptions.newBuilder().setTaskQueue(testWorkflowRule.getTaskQueue()).build());  ContentLengthInfo info = workflow.execute(); "<AssertPlaceHolder>"; assertNotNull(info.getWebsiteMap()); assertEquals(1, info.getWebsiteMap().size());  assertEquals(100, (int) info.getWebsiteMap().get("testsite"));  }
execute();
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: InterruptedException { int dataBlockSize = 677; int dataBlocks = 100; int bufferSize = 2 * 1024; //noinspection ConstantConditions assert bufferSize > dataBlockSize;  CommunicationPipe p = new CommunicationPipe(bufferSize); InputStream in = p.getInputStream(); OutputStream out = p.getOutputStream();  byte[] sourceBytes = new byte[dataBlockSize]; new Random().nextBytes(sourceBytes);  CountDownLatch completed = new CountDownLatch(2); new Thread(() -> { for (int i = 0; i < dataBlocks; i++) { try { out.write(sourceBytes); } catch (Exception e) { e.printStackTrace(); return; } completed.countDown(); } }).start();  new Thread(() -> { byte[] readBytes = new byte[dataBlockSize]; try { while (in.available() > dataBlockSize) { int read = in.read(readBytes); Assert."<AssertPlaceHolder>"; Assert.assertArrayEquals(sourceBytes, readBytes); } }catch (Exception e) { e.printStackTrace(); return; } completed.countDown();  }).start();  completed.await(); }
getOutputStream() { return outputStream; }
[*] target: assertEquals(dataBlockSize, read)
[-] pred: org. junit. Assert. assertEquals ( dataBlockSize, read )
************************************
************************************
[+] input: SQLException { Query.Field[] fields = TestResult.makeTestFields("c1|c2", "varbinary|decimal"); VtResultSet resultSet = TestResult.makeTestResult(fields, "a|1", "g|2", "a|1", "c|4", "c|3"); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(resultSet));  OrderByParamsGen4 orderByParamsGen4 = new OrderByParamsGen4(1, false, -1, null); MemorySortGen4Engine ms = new MemorySortGen4Engine(Lists.newArrayList(orderByParamsGen4), fp);  VtResultSet result = (VtResultSet) ms.execute(VtContext.background(), new NoopVCursor(), null, false).getVtRowList();  VtResultSet wantResult = TestResult.makeTestResult(fields, "a|1", "a|1", "g|2", "c|3", "c|4"); Assert.assertEquals(wantResult, result);  fp.rewind(); EvalEngine.BindVariable pv = new EvalEngine.BindVariable("__upper_limit"); ms.setUpperLimit(pv);  Map<String, BindVariable> bindVariableMap = new HashMap<>(); bindVariableMap.put("__upper_limit", SqlTypes.int64BindVariable(3L)); result = (VtResultSet) ms.execute(VtContext.background(), new NoopVCursor(), bindVariableMap, false).getVtRowList(); wantResult = TestResult.makeTestResult(fields, "a|1", "a|1", "g|2"); Assert."<AssertPlaceHolder>"; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { int count = this.fetchCount(bindVariableMap);  IExecute.ExecuteMultiShardResponse response = this.input.execute(ctx, vcursor, bindVariableMap, wantFields);  VtResultSet resultSet = (VtResultSet) response.getVtRowList(); return getExecuteMultiShardResponse(count, resultSet); }
[*] target: assertEquals(wantResult, result)
[-] pred: org. junit. Assert. assertEquals ( wantResult, result )
************************************
************************************
[+] input: SQLException { Query.Field[] fields = TestResult.makeTestFields("c1|c2", "varbinary|decimal"); VtResultSet resultSet = TestResult.makeTestResult(fields, "a|1", "b|2", "b|1", "c|4", "c|3"); FakePrimitive fp = new FakePrimitive(Lists.newArrayList(resultSet));  OrderByParamsGen4 orderByParams1 = new OrderByParamsGen4(1, false, -1, null); OrderByParamsGen4 orderByParams2 = new OrderByParamsGen4(0, true, -1, null); MemorySortGen4Engine ms = new MemorySortGen4Engine(Lists.newArrayList(orderByParams1, orderByParams2), fp);  VtResultSet result = (VtResultSet) ms.execute(VtContext.background(), new NoopVCursor(), null, false).getVtRowList(); VtResultSet wantResult = TestResult.makeTestResult(fields, "b|1", "a|1", "b|2", "c|3", "c|4"); Assert.assertEquals(wantResult, result);  fp.rewind(); EvalEngine.BindVariable pv = new EvalEngine.BindVariable("__upper_limit"); ms.setUpperLimit(pv); Map<String, BindVariable> bindVariableMap = new HashMap<>(); bindVariableMap.put("__upper_limit", SqlTypes.int64BindVariable(3L)); result = (VtResultSet) ms.execute(VtContext.background(), new NoopVCursor(), bindVariableMap, false).getVtRowList(); wantResult = TestResult.makeTestResult(fields, "b|1", "a|1", "b|2"); Assert."<AssertPlaceHolder>"; }
execute(IContext ctx, Vcursor vcursor, Map<String, BindVariable> bindVariableMap, boolean wantFields) throws SQLException { int count = this.fetchCount(bindVariableMap);  IExecute.ExecuteMultiShardResponse response = this.input.execute(ctx, vcursor, bindVariableMap, wantFields);  VtResultSet resultSet = (VtResultSet) response.getVtRowList(); return getExecuteMultiShardResponse(count, resultSet); }
[*] target: assertEquals(wantResult, result)
[-] pred: org. junit. Assert. assertEquals ( wantResult, result )
************************************
************************************
[+] input: IOException { final String basename = File.createTempFile(getClass().getSimpleName(), "test").toString(); final ImmutableGraph g = new ArrayListMutableGraph(new ErdosRenyiGraph(1000, .01, 0, false)).immutableView(); EFGraph.store(g, 1000, basename, 3, 1024, ByteOrder.nativeOrder(), null); final EFGraph efGraph = (EFGraph)ImmutableGraph.load(basename); assertEquals(g, efGraph);  for(int i = 0; i < 1000; i++) { for(int j = 0; j < 1000; j++) { LazyIntSkippableIterator sa = efGraph.successors(i); final int x = sa.skipTo(j); sa = efGraph.successors(i); for(;;) { final int y = sa.nextInt(); if (y >= j) { "<AssertPlaceHolder>"; break; } else if (y == -1) { if (x != LazyIntSkippableIterator.END_OF_LIST) fail(); break; } } } } new File(basename).delete(); new File(basename + EFGraph.GRAPH_EXTENSION).delete(); new File(basename + EFGraph.OFFSETS_EXTENSION).delete(); new File(basename + EFGraph.PROPERTIES_EXTENSION).delete();  }
nextInt() { if (currentIndex >= outdegree) { last = END_OF_LIST; return -1; } return last = (int)(getNextUpperBits() << l | lowerBits.extract()); }
[*] target: assertEquals(y, x)
[-] pred: org. junit. Assert. assertEquals ( y, x )
************************************
************************************
[+] input: testPath() { final DynamicDAG<Integer> dag = new DynamicDAG<>(3.0 / 2.0); final int n = 25; boolean ok;  final int[] nodeOrder = IntArrays.shuffle(Util.identity(n), new XoRoShiRo128PlusRandom(0)); @SuppressWarnings("unchecked") final DOLNode<DAGNode<Integer>>[] x = new DOLNode[n]; for (int i = 0; i < n; i++) { x[nodeOrder[i]] = dag.addNode(nodeOrder[i]); Assert.assertTrue(dag.dynamicOrderedList.assertList()); } final int[] arcOrder = IntArrays.shuffle(Util.identity(n), new XoRoShiRo128PlusRandom(0)); for (int i = 0; i < n; i++) if (arcOrder[i] < n - 1) { ok = dag.addArc(x[arcOrder[i]], x[arcOrder[i] + 1]); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dag.dynamicOrderedList.assertList()); } // Now test for order for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) Assert.assertEquals(Integer.compare(i, j), DynamicOrderedList.compare(x[i], x[j]));  }
addArc(final DOLNode<DAGNode<K>> source, final DOLNode<DAGNode<K>> target) { final DOLNode<DAGNode<K>> lastInserted = visitForwardAndMove(target, source, source); if (lastInserted == null) return false; addSuccessor(source, target); return true; }
[*] target: assertTrue(ok)
[-] pred: org. junit. Assert. assertTrue ( ok )
************************************
************************************
[+] input: FileNotFoundException { IatClient iatClient = new IatClient.Builder() .signature("123456", apiKey, apiSecret) .build(); File file = new File(resourcePath + filePath); iatClient.send(file, new AbstractIatWebSocketListener() { @Override public void onSuccess(WebSocket webSocket, IatResponse iatResponse) { Assert."<AssertPlaceHolder>"; Assert.assertNotNull(iatResponse.getMessage());  Assert.assertNotEquals(iatResponse.getCode(), 101); Assert.assertEquals(iatResponse.getCode(), 10313); iatClient.closeWebsocket(); }  @Override public void onFail(WebSocket webSocket, Throwable t, Response response) { } }); try { Thread.sleep(5000); } catch (InterruptedException e) { System.out.println(e.getMessage()); } }
build() { return new IatClient(this); }
[*] target: assertNotNull(iatResponse)
[-] pred: org. junit. Assert. assertNotNull ( iatResponse )
************************************
************************************
[+] input: Exception { CookieJar cookieJar = new DefaultCookieJar(); List<Cookie> cookies = Lists.of( new Cookie("test.com", "/", "test", "value", 0, false, false), new Cookie("test.com", "/test/", "test", "value1", 0, false, false), new Cookie("test.com", "/test/", "test1", "value1", 0, false, false), new Cookie("test1.com", "/", "test2", "value2", 0, false, false) ); cookieJar.storeCookies(cookies);  URL url = new URL("http://www.test.com/test/"); List<Cookie> matched = cookieJar.getCookies(url); "<AssertPlaceHolder>"; assertEquals(Sets.of( new Cookie("test.com", "/test/", "test", "value1", 0, false, false), new Cookie("test.com", "/test/", "test1", "value1", 0, false, false) ), new HashSet<>(matched.subList(0, 2))); assertEquals(new Cookie("test.com", "/", "test", "value", 0, false, false), matched.get(2)); }
getCookies(URL url) { long now = System.currentTimeMillis(); List<Cookie> matched = new ArrayList<>(); for (Cookie cookie : cookieMap.values()) { if (!Cookies.match(cookie, url.getProtocol(), url.getHost().toLowerCase(), url.getPath())) { continue; } if (cookie.expired(now)) { continue; } matched.add(cookie); } // we did not sort using create time here matched.sort((cookie1, cookie2) -> cookie2.path().length() - cookie1.path().length()); return matched; }
[*] target: assertEquals(3, matched.size())
[-] pred: org. junit. Assert. assertEquals ( 3, matched. size ( ) )
************************************
************************************
[+] input: testGetEntryMetaInPendingEntries() { FileEntrySequence sequence = new FileEntrySequence(entriesFile, entryIndexFile, 1); sequence.append(new NoOpEntry(1, 1)); EntryMeta meta = sequence.getEntryMeta(1); Assert."<AssertPlaceHolder>"; Assert.assertEquals(Entry.KIND_NO_OP, meta.getKind()); Assert.assertEquals(1, meta.getIndex()); Assert.assertEquals(1, meta.getTerm()); }
getEntryMeta(int index) { if (!isEntryPresent(index)) { return null; } if (entryIndexFile.isEmpty()) { return pendingEntries.get(index - doGetFirstLogIndex()).getMeta(); } return entryIndexFile.get(index).toEntryMeta(); }
[*] target: assertNotNull(meta)
[-] pred: org. junit. Assert. assertNotNull ( meta )
************************************
************************************
[+] input: IOException { appendEntryToFile(new NoOpEntry(1, 1)); FileEntrySequence sequence = new FileEntrySequence(entriesFile, entryIndexFile, 1); EntryMeta meta = sequence.getEntryMeta(1); Assert."<AssertPlaceHolder>"; Assert.assertEquals(Entry.KIND_NO_OP, meta.getKind()); Assert.assertEquals(1, meta.getIndex()); Assert.assertEquals(1, meta.getTerm()); }
getEntryMeta(int index) { if (!isEntryPresent(index)) { return null; } if (entryIndexFile.isEmpty()) { return pendingEntries.get(index - doGetFirstLogIndex()).getMeta(); } return entryIndexFile.get(index).toEntryMeta(); }
[*] target: assertNotNull(meta)
[-] pred: org. junit. Assert. assertNotNull ( meta )
************************************
************************************
[+] input: IOException { EntryIndexFile file = new EntryIndexFile(makeEntryIndexFileContent(3, 4)); EntryIndexItem item = file.get(3); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, item.getKind()); Assert.assertEquals(3, item.getTerm()); }
get(int entryIndex) { checkEmpty(); if (entryIndex < minEntryIndex || entryIndex > maxEntryIndex) { throw new IllegalArgumentException("index < min or index > max"); } return entryIndexMap.get(entryIndex); }
[*] target: assertNotNull(item)
[-] pred: org. junit. Assert. assertNotNull ( item )
************************************
************************************
[+] input: valid() { String secretId = "a-secret-id-1"; String secretKey = "a-secret-key-1";  Credentials credentials = new Credentials(secretId, secretKey);  assertEquals(secretId, credentials.getSecretId()); assertEquals(secretId, credentials.secretId());  assertEquals(secretKey, credentials.getSecretKey()); "<AssertPlaceHolder>"; }
secretKey() { return secretKey; }
[*] target: assertEquals(secretKey, credentials.secretKey())
[-] pred: org. junit. Assert. assertEquals ( secretKey, credentials. secretKey() )
************************************
************************************
[+] input: testEmptyConstructor() { EndpointConfigEntry entry = new EndpointConfigEntry(); assertNull(entry.productCode()); assertNull(entry.regionCode()); "<AssertPlaceHolder>"; }
domains() { return domains; }
[*] target: assertNull(entry.domains())
[-] pred: org. junit. Assert. assertNull ( entry. domains() )
************************************
************************************
[+] input: testUrlWithPredefinedQueryParamAndEmptyPathParam() { String expectedUrl = "http://x.y.z/api/v1/getName?token=abc&id=123";  // path parameter 为空map HttpRequest request = new HttpRequest() .protocol(ProtocolEnum.HTTP) .domain("x.y.z") .uriPattern("/api/v1/getName?token=abc") .pathParameters(Collections.emptyMap()) .queryParameter("id", "123"); assertEquals(expectedUrl, request.assembleUrl());  // path parameter 为 null request.pathParameters(null); "<AssertPlaceHolder>"; }
assembleUrl() { Map<String, String> mapQueries = ObjectUtils.defaultIfNull(queryParameters, Collections.emptyMap()); StringBuilder urlBuilder = new StringBuilder(); urlBuilder.append(protocol.toString()); urlBuilder.append("://").append(domain); if (null != this.uriPattern) { urlBuilder.append(populatePathParams(uriPattern, pathParameters)); } if (-1 == urlBuilder.indexOf("?")) { urlBuilder.append("?"); } else if (!urlBuilder.toString().endsWith("?")) { urlBuilder.append("&"); }  if (!mapQueries.isEmpty()) { urlBuilder.append(UrlUtils.encode(mapQueries)); }  String url = urlBuilder.toString();  if (url.endsWith("?") || url.endsWith("&")) { url = url.substring(0, url.length() - 1); } return url; }
[*] target: assertEquals(expectedUrl, request.assembleUrl())
[-] pred: org. junit. Assert. assertEquals ( expectedUrl, request. assembleUrl ( ) )
************************************
************************************

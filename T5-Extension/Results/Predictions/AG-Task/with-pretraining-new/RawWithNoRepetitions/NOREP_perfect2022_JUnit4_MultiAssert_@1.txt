[+] input: Exception { Namespace scope = st.createExternalLibrary("TestScope", SourceType.USER_DEFINED); "<AssertPlaceHolder>"; assertEquals("TestScope", scope.getName()); assertTrue(scope.getBody().isEmpty()); assertTrue(scope instanceof Library); assertEquals(globalScope, scope.getParentNamespace());  Symbol symbol = scope.getSymbol(); assertEquals(scope.getName(), symbol.getName()); assertEquals(globalScope, symbol.getParentNamespace()); }
createExternalLibrary(String name, SourceType source) throws DuplicateNameException, InvalidInputException { SymbolDB s = createLibrarySymbol(name, null, source); return new LibraryDB(s, namespaceMgr); }
[*] target: assertNotNull(scope)
[-] pred: org. junit. Assert. assertNotNull ( scope )
************************************
************************************
[+] input: ClassNotFoundException { String cvc4_path = System.getenv("cvc4_path"); if (cvc4_path != null) { Properties.CVC4_PATH = cvc4_path; } Assume.assumeTrue(Properties.CVC4_PATH!=null); Properties.DSE_SOLVER = Properties.SolverType.CVC4_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: testFormatMaintainingLineSeparators() { FormattingPreferences prefs = new FormattingPreferences() { @Override public boolean wrapLongTags() { return true; }  @Override public int getMaximumLineWidth() { return 40; }  @Override public boolean alignElementCloseChar() { return false; }  @Override public boolean useSpacesInsteadOfTabs() { return true; }  @Override public int getTabWidth() { return 6; } }; String lineSep = System.getProperty("line.separator"); //$NON-NLS-1$ String xmlDoc = "<project default="go"><target name="go" description="Demonstrate the wrapping of long tags."><echo>hi</echo></target>" //$NON-NLS-1$ + lineSep + lineSep + "</project>"; //$NON-NLS-1$ String formattedDoc = XmlFormatter.format(xmlDoc, prefs); String expected = "<project default="go">" + lineSep + "      <target name="go"" + lineSep //$NON-NLS-1$ //$NON-NLS-2$ + "              description="Demonstrate the wrapping of long tags.">" + lineSep //$NON-NLS-1$ + "            <echo>hi</echo>" + lineSep + "      </target>" + lineSep + lineSep + "</project>"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ "<AssertPlaceHolder>"; }
format(String text, FormattingPreferences prefs) {  return format(text, prefs, -1); }
[*] target: assertEquals(expected, formattedDoc)
[-] pred: org. junit. Assert. assertEquals ( expected, formattedDoc )
************************************
************************************
[+] input: URISyntaxException { File jarFile = createJar(); JdkCheckCompatibleRequest request = new JdkCheckCompatibleRequest(); request.setFromVersion(8); request.setToVersion(11); request.setReportLocale(Locale.CHINA); request.setExternalToolHome(System.getProperty("user.home") + "/emt4j-external"); List<ToCheckTarget> toCheckTargetList = new ArrayList<>(); ToCheckTarget toCheckTarget = new ToCheckTarget(); toCheckTarget.setTargetType(CheckTargetTypeEnum.JAR); toCheckTarget.setTargetIdentifier(jarFile.getCanonicalPath()); toCheckTargetList.add(toCheckTarget); request.setToCheckTargetList(toCheckTargetList);  JdkCheckCompatibleResult result = JdkCompatibleCheckFacade.check(request); "<AssertPlaceHolder>"; assertFalse(result.getResultDetailList().isEmpty());  jarFile.delete(); }
check(JdkCheckCompatibleRequest request) throws IOException, InterruptedException, ClassNotFoundException, URISyntaxException { checkParam(request); CheckConfig checkConfig = getCheckConfig(request); MemoryHolderOutputConsumer outputConsumer = new MemoryHolderOutputConsumer(); AnalysisExecutor analysisExecutor = new AnalysisExecutor(checkConfig); analysisExecutor.setAnalysisOutputConsumer(outputConsumer); for (ToCheckTarget checkTarget : request.getToCheckTargetList()) { analysisExecutor.add(convert(checkTarget)); } Progress progress = new Progress(0, 1, "JDK Compatible API Check"); analysisExecutor.execute(Collections.singletonList(Feature.DEFAULT), progress);  ReportConfig reportConfig = new ReportConfig(); reportConfig.setOutputFormat("api"); reportConfig.setLocale(request.getReportLocale()); reportConfig.setTargetJdkHome(request.getTargetJdkHome()); reportConfig.setVerbose(request.isVerbose()); reportConfig.setExternalToolRoot(request.getExternalToolHome()); ReportExecutor reportExecutor = new ReportExecutor(reportConfig); reportExecutor.execute(outputConsumer.getInputProvider(), progress, request.isDisableExternalTool());  JdkCheckCompatibleResult result = new JdkCheckCompatibleResult(); result.setResultDetailList(((ApiRender) reportExecutor.getRender()).getResultDetailList()); return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: replaceNothing3() { // given String nativeSql = "insert into ?.? (ts, temperature, humidity) using ?.? tags(?,?) values(now, ?, ?)";  // when String actual = Utils.getNativeSql(nativeSql, null);  // then Assert."<AssertPlaceHolder>";  }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(nativeSql, actual)
[-] pred: org. junit. Assert. assertEquals ( nativeSql, actual )
************************************
************************************
[+] input: testExtractDefaultValueNULL() { List<String> columnSpecs = Collections.singletonList("default"); String actualDefault = schemaManager.extractDefaultValue(DorisType.STRING, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertNull(actualDefault)
[-] pred: org. junit. Assert. assertNull ( actualDefault )
************************************
************************************
[+] input: Exception { Dictionary<String, Object> dict = getConfiguration("test2").getProperties(); assertFalse(dict.isEmpty()); assertNotNull(dict.remove(Constants.SERVICE_PID)); "<AssertPlaceHolder>"; }
isEmpty() { return configurationProperties.isEmpty(); }
[*] target: assertTrue(dict.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( dict. isEmpty ( ) )
************************************
************************************
[+] input: testSignature() { String timestamp = "1576478257344"; String pathWithQuery = "/configs/100004458/default/application?ip=10.0.0.1"; String secret = "df23df3f59884980844ff3dada30fa97";  String actualSignature = Signature.signature(timestamp, pathWithQuery, secret);  String expectedSignature = "EoKyziXvKqzHgwx+ijDJwgVTDgE="; "<AssertPlaceHolder>"; }
signature(String timestamp, String pathWithQuery, String secret) { String stringToSign = timestamp + DELIMITER + pathWithQuery; return HmacSha1Utils.signString(stringToSign, secret); }
[*] target: assertEquals(expectedSignature, actualSignature)
[-] pred: org. junit. Assert. assertEquals ( expectedSignature, actualSignature )
************************************
************************************
[+] input: cancelTicket() { // init List<Ticket> tickets = new ArrayList<>(); Flight testFlight = new Flight(1, "Flight-XYZ", 50, 300, new Date(), new Date(), tickets, null, null);  Ticket ticket1 = new Ticket(2, null, testFlight); Ticket ticket2 = new Ticket(3, null, testFlight); tickets.add(ticket1); tickets.add(ticket2);  testFlight.getTickets().remove(1); Flight updatedTestFlight = testFlight;   // when - stubbing Mockito.when(ticketService.getTicket(any())).thenReturn(ticket1); Mockito.when(flightService.getFlight(any())).thenReturn(testFlight); Mockito.when(flightService.updateFlight(any())).thenReturn(updatedTestFlight); Mockito.when(ticketService.deleteTicket(any())).thenReturn(true);  // then test boolean actualCancelStatus = airportCompanyService.cancelTicket(2);  // validate Assert."<AssertPlaceHolder>";  }
cancelTicket(Integer ticketId);
[*] target: assertTrue(actualCancelStatus)
[-] pred: org. junit. Assert. assertTrue ( actualCancelStatus )
************************************
************************************
[+] input: ) { Vector actualResult = new Vector( 3 ); actualResult.apply( operand -> 10 );  Vector expectedResult = new Vector( 10d, 10d, 10d );  "<AssertPlaceHolder>"; }
apply(DoubleUnaryOperator function) { for (int i = 0; i < data.length; i++) { data[i] = function.applyAsDouble(data[i]); } return this; }
[*] target: assertEquals( expectedResult, actualResult )
[-] pred: org. junit. Assert. assertEquals ( expectedResult, actualResult )
************************************
************************************
[+] input: testFindApiUsageStateByTenantId() { ApiUsageState apiUsageState = apiUsageStateService.findTenantApiUsageState(tenantId); Assert."<AssertPlaceHolder>"; }
findTenantApiUsageState(TenantId tenantId);
[*] target: assertNotNull(apiUsageState)
[-] pred: org. junit. Assert. assertNotNull ( apiUsageState )
************************************
************************************
[+] input: success_search_test_2() { String pattern = "Magic"; String text = "hello it's me Magic. Do you know what Magic is in this repo"; String exceptedOutput = "Found pattern at index 14\n" + "Found pattern at index 38\n"; String actual = CaptureOutput.captureStandardOutput(() -> Question1.search(pattern, text)); "<AssertPlaceHolder>"; }
search(String pattern, String txt) { int M = pattern.length(); int N = txt.length();  // create lps[] that will hold the longest // prefix suffix values for pattern int lps[] = new int[M]; int j = 0; // index for pat[]  // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pattern, M, lps);  int i = 0; // index for txt[] boolean notFound = true; while ((N - i) >= (M - j)) { if (pattern.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == M) { System.out.println("Found pattern " + "at index " + (i - j)); notFound = false; j = lps[j - 1]; }  // mismatch after j matches else if (i < N && pattern.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j - 1]; else i = i + 1; } } if (notFound){ System.out.println("No Pattern Found"); } }
[*] target: assertEquals(exceptedOutput, actual)
[-] pred: org. junit. Assert. assertEquals ( exceptedOutput, actual )
************************************
************************************
[+] input: Exception { addBlock("block2", 0x2000, 100);  ProgramModule root = treeManager.createRootModule("MyRoot"); "<AssertPlaceHolder>";  Group[] children = root.getChildren(); assertEquals(2, children.length); assertTrue(children[1] instanceof ProgramFragment); ProgramFragment frag = (ProgramFragment) children[1]; assertEquals(2, frag.getNumAddressRanges()); Iterator<AddressRange> it = frag.iterator(); assertEquals(new AddressRangeImpl(getAddr(0x1000), getAddr(0x1063)), it.next()); assertEquals(new AddressRangeImpl(getAddr(0x2000), getAddr(0x2063)), it.next()); }
createRootModule(String treeName) throws DuplicateNameException {  lock.acquire(); try { if (treeMap.containsKey(treeName)) { throw new DuplicateNameException( "Root module named " + treeName + " already exists"); } DBRecord record = adapter.createRecord(treeName); ModuleManager m = new ModuleManager(this, record, program, true); treeMap.put(treeName, m); addMemoryBlocks(m); if (openMode != DBConstants.CREATE) { program.programTreeAdded(record.getKey(), ChangeManager.DOCR_TREE_CREATED, null, treeName); } return m.getRootModule(); } catch (IOException e) { errHandler.dbError(e);  } finally { lock.release(); } return null; }
[*] target: assertNotNull(root)
[-] pred: org. junit. Assert. assertNotNull ( root )
************************************
************************************
[+] input: testDeleteDeviceProfile() { DeviceProfile deviceProfile = this.createDeviceProfile(tenantId, "Device Profile"); DeviceProfile savedDeviceProfile = deviceProfileService.saveDeviceProfile(deviceProfile); deviceProfileService.deleteDeviceProfile(tenantId, savedDeviceProfile.getId()); DeviceProfile foundDeviceProfile = deviceProfileService.findDeviceProfileById(tenantId, savedDeviceProfile.getId()); Assert."<AssertPlaceHolder>"; }
findDeviceProfileById(TenantId tenantId, DeviceProfileId deviceProfileId);
[*] target: assertNull(foundDeviceProfile)
[-] pred: org. junit. Assert. assertNull ( foundDeviceProfile )
************************************
************************************
[+] input: testFindDefaultDeviceProfile() { DeviceProfile foundDefaultDeviceProfile = deviceProfileService.findDefaultDeviceProfile(tenantId); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(foundDefaultDeviceProfile.getId()); Assert.assertNotNull(foundDefaultDeviceProfile.getName()); }
findDefaultDeviceProfile(TenantId tenantId);
[*] target: assertNotNull(foundDefaultDeviceProfile)
[-] pred: org. junit. Assert. assertNotNull ( foundDefaultDeviceProfile )
************************************
************************************
[+] input: substituteParametersInSqlString_BooleanType() {  String sql = "Select * from Table Where check = :check AND mark = :mark"; String sqlToUse = "Select * from Table Where check = true AND mark = false";  ctx.addBooleanParameter("check", true); ctx.addBooleanParameter("mark", false);  String sqlToUseResult = queryLog.substituteParametersInSqlString(sql, ctx); "<AssertPlaceHolder>"; }
substituteParametersInSqlString(String sql, SqlParameterSource paramSource) {  ParsedSql parsedSql = NamedParameterUtils.parseSqlStatement(sql); List<SqlParameter> declaredParams = NamedParameterUtils.buildSqlParameterList(parsedSql, paramSource);  if (declaredParams.isEmpty()) { return sql; }  for (SqlParameter parSQL: declaredParams) { String paramName = parSQL.getName(); if (!paramSource.hasValue(paramName)) { continue; }  Object value = paramSource.getValue(paramName); if (value instanceof SqlParameterValue) { value = ((SqlParameterValue)value).getValue(); }  if (!(value instanceof Iterable)) {  String ValueForSQLQuery = getValueForSQLQuery(value); sql = sql.replace(":" + paramName, ValueForSQLQuery); continue; }  //Iterable int count = 0; String valueArrayStr = "";  for (Object valueTemp: (Iterable)value) {  if (count > 0) { valueArrayStr+=", "; }  String valueForSQLQuery = getValueForSQLQuery(valueTemp); valueArrayStr += valueForSQLQuery; ++count; }  sql = sql.replace(":" + paramName, valueArrayStr);  }  return sql; }
[*] target: assertEquals(sqlToUse, sqlToUseResult)
[-] pred: org. junit. Assert. assertEquals ( sqlToUse, sqlToUseResult )
************************************
************************************
[+] input: testDeleteBookmark() { DBTraceBookmark bm; try (UndoableTransaction tid = b.startTransaction()) { bm = b.addBookmark(0, 0, "Test Type", "Cat1", "Test comment"); } long id = bm.getId();  try (UndoableTransaction tid = b.startTransaction()) { bm.delete(); } DBTraceBookmark found = manager.getBookmark(id); "<AssertPlaceHolder>"; }
getBookmark(long id) { try (LockHold hold = LockHold.lock(lock.readLock())) { DBTraceSpaceKey spaceKey = unpackSpaceKey(id, baseLanguage, threadManager); if (spaceKey == null) { return null; } DBTraceBookmarkSpace space = get(spaceKey, false); if (space == null) { return null; } long bookmarkKey = spaceKey.getAddressSpace().isRegisterSpace() ? unpackRegKey(id) : unpackMemKey(id); return space.bookmarkMapSpace.getDataByKey(bookmarkKey); } }
[*] target: assertNull(found)
[-] pred: org. junit. Assert. assertNull ( found )
************************************
************************************
[+] input: testGetSensorsInfo() { SensorsDomain sensorsDomain = SensorsUtils.getSensorsInfo(); "<AssertPlaceHolder>"; log.info(sensorsDomain.toJsonString()); }
getSensorsInfo() { try { HardwareAbstractionLayer hardwareAbstractionLayer = SYSTEM_INFO.getHardware(); Sensors sensors = hardwareAbstractionLayer.getSensors(); double cpuTemperature = NumberUtil.round(sensors.getCpuTemperature(), 2).doubleValue(); double cpuVoltage = NumberUtil.round(sensors.getCpuVoltage(), 2).doubleValue(); int[] fanSpeeds = sensors.getFanSpeeds(); SensorsDomain sensorDomain = new SensorsDomain(); sensorDomain.setCpuTemperature(cpuTemperature != 0 ? cpuTemperature + "℃" : "未知"); sensorDomain.setCpuVoltage(cpuVoltage != 0 ? cpuVoltage + "V" : "未知"); List<SensorsDomain.FanSpeedDomain> fanSpeedDomains = Lists.newArrayList(); for (int fanSpeed : fanSpeeds) { SensorsDomain.FanSpeedDomain fanSpeedDomain = new SensorsDomain.FanSpeedDomain(); fanSpeedDomain.setFanSpeed(fanSpeed != 0 ? fanSpeed + "rpm" : "未知"); fanSpeedDomains.add(fanSpeedDomain); sensorDomain.setFanSpeedDomainList(fanSpeedDomains); } return sensorDomain; } catch (Throwable e) { log.error(e.getMessage(), e); return null; } }
[*] target: assertNotNull(sensorsDomain)
[-] pred: org. junit. Assert. assertNotNull ( sensorsDomain )
************************************
************************************
[+] input: Exception { Assume.assumeFalse(TinkFips.useOnlyFips());  JsonObject json = WycheproofTestUtil.readJson( "../wycheproof/testvectors/chacha20_poly1305_test.json"); int errors = 0; JsonArray testGroups = json.getAsJsonArray("testGroups"); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); JsonArray tests = group.getAsJsonArray("tests"); for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); String tcId = String.format( "testcase %d (%s)", testcase.get("tcId").getAsInt(), testcase.get("comment").getAsString()); byte[] iv = Hex.decode(testcase.get("iv").getAsString()); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] msg = Hex.decode(testcase.get("msg").getAsString()); byte[] aad = Hex.decode(testcase.get("aad").getAsString()); byte[] ct = Hex.decode(testcase.get("ct").getAsString()); byte[] tag = Hex.decode(testcase.get("tag").getAsString()); byte[] ciphertext = Bytes.concat(iv, ct, tag); // Result is one of "valid", "invalid", "acceptable". // "valid" are test vectors with matching plaintext, ciphertext and tag. // "invalid" are test vectors with invalid parameters or invalid ciphertext and tag. // "acceptable" are test vectors with weak parameters or legacy formats. String result = testcase.get("result").getAsString(); try { Aead aead = createInstance(key); byte[] decrypted = aead.decrypt(ciphertext, aad); boolean eq = TestUtil.arrayEquals(decrypted, msg); if (result.equals("invalid")) { System.out.printf( "FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n", tcId, Hex.encode(msg), Hex.encode(decrypted)); errors++; } else { if (!eq) { System.out.printf( "FAIL %s: incorrect decryption, result: %s, expected: %s%n", tcId, Hex.encode(decrypted), Hex.encode(msg)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("FAIL %s: cannot decrypt, exception %s%n", tcId, ex); errors++; } } } } "<AssertPlaceHolder>"; }
decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException { if (outputPrefix.length == 0) { return rawDecrypt(ciphertext, associatedData); } if (!isPrefix(outputPrefix, ciphertext)) { throw new GeneralSecurityException("Decryption failed (OutputPrefix mismatch)."); } byte[] copiedCiphertext = Arrays.copyOfRange(ciphertext, outputPrefix.length, ciphertext.length); return rawDecrypt(copiedCiphertext, associatedData); }
[*] target: assertEquals(0, errors)
[-] pred: org. junit. Assert. assertEquals ( 0, errors )
************************************
************************************
[+] input: isAvailable_channelScreen_never() { mController.onResume( new NotificationBackend.AppRow(), mock(NotificationChannel.class), null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } // only visible on app screen if (mChannel != null || hasValidGroup()) { return false; }  return mBackend.getDeletedChannelCount(mAppRow.pkg, mAppRow.uid) > 0; }
[*] target: assertFalse(mController.isAvailable())
[-] pred: org. junit. Assert. assertFalse ( mController. isAvailable() )
************************************
************************************
[+] input: Exception { Memory memory = program.getMemory(); MemoryBlock block = memory.createInitializedBlock(".test", getAddr(5), 0x20, (byte) 0xa, TaskMonitorAdapter.DUMMY_MONITOR, false);  AddressSet set = new AddressSet(); set.addRange(getAddr(0), getAddr(0x10)); set.addRange(getAddr(0x20), getAddr(0x25)); set.addRange(getAddr(0x26), getAddr(0x30)); AddressSetPropertyMap pm = program.createAddressSetPropertyMap("MyMap"); pm.add(set); // remove the block memory.removeBlock(block, TaskMonitorAdapter.DUMMY_MONITOR);  // [0,4], [25,30] should still exist // [5,24] should have been removed AddressSet s = new AddressSet(); s.addRange(getAddr(0), getAddr(0x4)); s.addRange(getAddr(0x25), getAddr(0x30)); AddressSet pmSet = pm.getAddressSet(); "<AssertPlaceHolder>"; }
getAddressSet();
[*] target: assertEquals(s, pmSet)
[-] pred: org. junit. Assert. assertEquals ( s, pmSet )
************************************
************************************
[+] input: testGetNewAddressSpace() { AddressSpace space = trans13.getNewAddressSpace("ram"); "<AssertPlaceHolder>"; assertEquals("ram", space.getName()); }
getNewAddressSpace(String oldSpaceName) { if (!isValid) { throw new IllegalStateException("Translator has not been validated"); } if (spaceNameMap.isEmpty()) { return super.getNewAddressSpace(oldSpaceName); } String newName = spaceNameMap.get(oldSpaceName); if (newName != null) { return getNewLanguage().getAddressFactory().getAddressSpace(newName); } return null; }
[*] target: assertNotNull(space)
[-] pred: org. junit. Assert. assertNotNull ( space )
************************************
************************************
[+] input: substituteParametersInSqlString_StringListType() {  List<String> ids = List.of("ID_1'", "ID_2", "ID_3", "ID_4");  String sql = "Select * from Table Where id IN (:ids)"; String sqlToUse = "Select * from Table Where id IN ('ID_1''', 'ID_2', 'ID_3', 'ID_4')";  ctx.addStringListParameter("ids", ids);  String sqlToUseResult = queryLog.substituteParametersInSqlString(sql, ctx); "<AssertPlaceHolder>"; }
substituteParametersInSqlString(String sql, SqlParameterSource paramSource) {  ParsedSql parsedSql = NamedParameterUtils.parseSqlStatement(sql); List<SqlParameter> declaredParams = NamedParameterUtils.buildSqlParameterList(parsedSql, paramSource);  if (declaredParams.isEmpty()) { return sql; }  for (SqlParameter parSQL: declaredParams) { String paramName = parSQL.getName(); if (!paramSource.hasValue(paramName)) { continue; }  Object value = paramSource.getValue(paramName); if (value instanceof SqlParameterValue) { value = ((SqlParameterValue)value).getValue(); }  if (!(value instanceof Iterable)) {  String ValueForSQLQuery = getValueForSQLQuery(value); sql = sql.replace(":" + paramName, ValueForSQLQuery); continue; }  //Iterable int count = 0; String valueArrayStr = "";  for (Object valueTemp: (Iterable)value) {  if (count > 0) { valueArrayStr+=", "; }  String valueForSQLQuery = getValueForSQLQuery(valueTemp); valueArrayStr += valueForSQLQuery; ++count; }  sql = sql.replace(":" + paramName, valueArrayStr);  }  return sql; }
[*] target: assertEquals(sqlToUse, sqlToUseResult)
[-] pred: org. junit. Assert. assertEquals ( sqlToUse, sqlToUseResult )
************************************
************************************
[+] input: Exception { createLabel(addr(100), "primary"); createLabel(addr(100), "fred"); createLabel(addr(100), "joe"); Namespace scope = st.createNameSpace(null, "MyNamespace", SourceType.USER_DEFINED); createLabel(addr(200), "fred", scope); Symbol s = st.getSymbol("fred", addr(200), scope); "<AssertPlaceHolder>"; assertTrue(!s.isGlobal()); assertTrue(s.getSource() == SourceType.USER_DEFINED); }
getSymbol(String name, Address address, Namespace namespace) { if (namespace == null) { namespace = program.getGlobalNamespace(); }  if (isDeletedNamespace(namespace)) { return null; } checkValidNamespaceArgument(namespace);  long namespaceId = namespace.getID();  lock.acquire(); try { DBRecord record = adapter.getSymbolRecord(address, name, namespaceId); if (record != null) { return getSymbol(record); } } catch (IOException e) { program.dbError(e); } finally { lock.release(); }  // check for default external symbol if (namespace.isExternal() && SymbolUtilities.isPossibleDefaultExternalName(name)) { return searchNamespaceForSymbol(namespace, name, address); }  // also check for possible default parameter or local variable symbol if (namespace instanceof Function && SymbolUtilities.isPossibleDefaultLocalOrParamName(name)) { return searchNamespaceForSymbol(namespace, name, address); }  // check if name is a default name Symbol symbol = getSymbolForDynamicName(name); if (symbol != null && address.equals(symbol.getAddress()) && namespace.equals(symbol.getParentNamespace())) { return symbol; } return null; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: whenResolve_insideSubmodelElementList_success() { String submodelId = "http://example.org/submodel"; String submodelElementIdShort = "foo"; String submodelElementListIdShort = "list"; SubmodelElement expected = new DefaultProperty.Builder() .idShort(submodelElementIdShort) .value("bar") .build(); SubmodelElementList list = new DefaultSubmodelElementList.Builder() .idShort(submodelElementListIdShort) .value(expected) .build(); Environment environment = new DefaultEnvironment.Builder() .submodels(new DefaultSubmodel.Builder() .id(submodelId) .submodelElements(list) .build()) .build(); Reference reference = new DefaultReference.Builder() .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL) .value(submodelId) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT_LIST) .value(submodelElementListIdShort) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT) .value("0") .build()) .build(); Referable actual = AasUtils.resolve(reference, environment); Assert."<AssertPlaceHolder>"; }
resolve(Reference reference, Environment env) { return resolve(reference, env, Referable.class); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testAsSet_VarArgs_Null() {  Set<String> set = CollectionUtils.asSet((String) null); assertNotNull(set); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(set.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( set. isEmpty() )
************************************
************************************
[+] input: testGetAllWorkflowDefsLatestVersions() { WorkflowDef def = new WorkflowDef(); def.setName("test1"); def.setVersion(1); def.setDescription("description"); def.setCreatedBy("unit_test"); def.setCreateTime(1L); def.setOwnerApp("ownerApp"); def.setUpdatedBy("unit_test2"); def.setUpdateTime(2L); metadataDAO.createWorkflowDef(def);  def.setName("test2"); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def);  def.setName("test3"); def.setVersion(1); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def); def.setVersion(3); metadataDAO.createWorkflowDef(def);  // Placed the values in a map because they might not be stored in order of defName. // To test, needed to confirm that the versions are correct for the definitions. Map<String, WorkflowDef> allMap = metadataDAO.getAllWorkflowDefsLatestVersions().stream() .collect(Collectors.toMap(WorkflowDef::getName, Function.identity()));  "<AssertPlaceHolder>"; assertEquals(3, allMap.size()); assertEquals(1, allMap.get("test1").getVersion()); assertEquals(2, allMap.get("test2").getVersion()); assertEquals(3, allMap.get("test3").getVersion()); }
getAllWorkflowDefsLatestVersions() { final String GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY = "SELECT json_data FROM meta_workflow_def wd WHERE wd.version = (SELECT MAX(version) FROM meta_workflow_def wd2 WHERE wd2.name = wd.name)"; return queryWithTransaction( GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY, q -> q.executeAndFetch(WorkflowDef.class)); }
[*] target: assertNotNull(allMap)
[-] pred: org. junit. Assert. assertNotNull ( allMap )
************************************
************************************
[+] input: oneMemberProtobuf() { StructValue value = StructValue.of("a", PrimitiveValue.newUint32(1)); StructType type = value.getType();  ValueProtos.Value valuePb = value.toPb(); Assert.assertEquals(ValueProtos.Value.newBuilder() .addItems(ProtoValue.fromUint32(1)) .build(), valuePb);  Value<?> valueX = ProtoValue.fromPb(type, valuePb); Assert."<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) { return true; }  if (o == null || getClass() != o.getClass()) { return false; }  StructValue that = (StructValue) o; return Arrays.equals(members, that.members); }
[*] target: assertTrue(value.equals(valueX))
[-] pred: org. junit. Assert. assertTrue ( value. equals ( valueX ) )
************************************
************************************
[+] input: getTransitionShouldReturnNullWhenMappingDoesNotExistAndThisStateHasOneTransition() { state.addTransition((byte) 'a', new ByteState());  ByteTransition transition = state.getTransition((byte) 'b');  "<AssertPlaceHolder>"; }
getTransition(byte utf8byte) { // Saving the value to avoid reading an updated value Object transitionStore = this.transitionStore; if (transitionStore == null) { return null; } else if (transitionStore instanceof SingleByteTransitionEntry) { SingleByteTransitionEntry entry = (SingleByteTransitionEntry) transitionStore; return utf8byte == entry.utf8byte ? entry.transition : null; } ByteMap map = (ByteMap) transitionStore; return map.getTransition(utf8byte); }
[*] target: assertNull(transition)
[-] pred: org. junit. Assert. assertNull ( transition )
************************************
************************************
[+] input: Exception { byte[] bytes = new byte[64]; bytes[0] = 15; Node nearNode = new Node(bytes, "127.0.0.19", null, 18888, 18888); bytes[0] = 70; Node farNode = new Node(bytes, "127.0.0.20", null, 18888, 18888); nodeTable.addNode(nearNode); nodeTable.addNode(farNode); for (int i = 0; i < KademliaOptions.BUCKET_SIZE - 1; i++) { //To control totally 17 nodes, however closest's capacity is 16 nodeTable.addNode(new Node(ids.get(i), ips[i], null, 18888, 18888)); TimeUnit.MILLISECONDS.sleep(10); } Assert.assertTrue(nodeTable.getBucketsCount() > 1); //3 buckets, nearnode's distance is 252, far's is 255, others' are 253 List<Node> closest = nodeTable.getClosestNodes(homeNode.getId()); Assert."<AssertPlaceHolder>"; //the farest node should be excluded }
contains(Node n) { return nodes.containsKey(n.getHostKey()); }
[*] target: assertTrue(closest.contains(nearNode))
[-] pred: org. junit. Assert. assertTrue ( closest. contains ( nearNode ) )
************************************
************************************
[+] input: testConstructorParentAndVarargsArray() { CategoryPath parent = new CategoryPath("/apple/peaches"); CategoryPath c = new CategoryPath(parent, new String[] { "pumpkin", "pie" }); assertEquals("pie", c.getName()); c = c.getParent(); assertEquals("pumpkin", c.getName()); c = c.getParent(); assertEquals("peaches", c.getName()); c = c.getParent(); assertEquals("apple", c.getName()); c = c.getParent(); assertEquals("", c.getName()); "<AssertPlaceHolder>"; }
isRoot() { // parent can only be null for ROOT return parent == null; }
[*] target: assertTrue(c.isRoot())
[-] pred: org. junit. Assert. assertTrue ( c. isRoot() )
************************************
************************************
[+] input: Exception { refMgr.addMemoryReference(addr(512), addr(256), RefType.FLOW, SourceType.USER_DEFINED, 2); refMgr.addMemoryReference(addr(512), addr(1024), RefType.FLOW, SourceType.USER_DEFINED, 1); refMgr.removeReference(addr(512), addr(256), 1); Reference ref = refMgr.getReference(addr(512), addr(256), 2); "<AssertPlaceHolder>"; }
getReference(Address fromAddr, Address toAddr, int opIndex);
[*] target: assertNotNull(ref)
[-] pred: org. junit. Assert. assertNotNull ( ref )
************************************
************************************
[+] input: testImplicit() { DijkstraShortestPathsAlgorithm<Integer, CollatzEdge> dijkstra = new DijkstraShortestPathsAlgorithm<>(new CollatzGraph(), 10d, GEdgeWeightMetric.unitMetric()); Collection<Deque<CollatzEdge>> opt = dijkstra.computeOptimalPaths(1, 10); Collection<Deque<CollatzEdge>> exp = makeCollatzPaths(1, // new CollatzOp[] { CollatzOp.INV_DIV2, CollatzOp.INV_DIV2, CollatzOp.SQR, CollatzOp.INV_MUL3_ADD1, CollatzOp.INV_DIV2 }, // new CollatzOp[] { CollatzOp.INV_DIV2, CollatzOp.SQR, CollatzOp.SQR, CollatzOp.INV_MUL3_ADD1, CollatzOp.INV_DIV2 }); "<AssertPlaceHolder>"; }
computeOptimalPaths(V src, V dst) { return sources.get(src).computeOptimalPathsTo(dst); }
[*] target: assertEquals(exp, opt)
[-] pred: org. junit. Assert. assertEquals ( exp, opt )
************************************
************************************
[+] input: testCountOccurrencesOfCharacter() { int count = countOccurrences("AxBxCxDxxX", 'x'); "<AssertPlaceHolder>"; }
countOccurrences(String string, char occur) { int count = 0; int length = string.length(); for (int i = 0; i < length; ++i) { if (string.charAt(i) == occur) { ++count; } } return count; }
[*] target: assertEquals(5, count)
[-] pred: org. junit. Assert. assertEquals ( 5, count )
************************************
************************************
[+] input: testMostNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 3);  TestSuiteChromosome exepcted_individual = population.get(12); TestSuiteChromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testGetOperatingSystemInfo() { OperatingSystem operatingSystem = OperatingSystemUtils.getOperatingSystemInfo(); "<AssertPlaceHolder>"; log.info("操作系统信息：" + operatingSystem.toString()); }
getOperatingSystemInfo() { return SYSTEM_INFO.getOperatingSystem(); }
[*] target: assertNotNull(operatingSystem)
[-] pred: org. junit. Assert. assertNotNull ( operatingSystem )
************************************
************************************
[+] input: isAvailable_NOTIFICATION_BUBBLESisOn_neverSentMsg_shouldReturnFalse() { Settings.Global.putInt(mContext.getContentResolver(), NOTIFICATION_BUBBLES, SYSTEM_WIDE_ON); mController.onResume(mAppRow, null, null, null, null, null); when(mBackend.hasSentValidMsg(anyString(), anyInt())).thenReturn(false);  "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mAppRow == null) { return false; } if (mChannel != null) { if (!isGloballyEnabled()) { return false; } if (isDefaultChannel()) { return true; } else { return mAppRow != null; } } return isGloballyEnabled() && mBackend.hasSentValidMsg(mAppRow.pkg, mAppRow.uid); }
[*] target: assertFalse(mController.isAvailable())
[-] pred: org. junit. Assert. assertFalse ( mController. isAvailable() )
************************************
************************************
[+] input: testExecutionException() { KafkaProducerManager manager = new KafkaProducerManager( Duration.ofMillis(150), Duration.ofMillis(500), 10, Duration.ofMillis(120000)); KafkaPublishTask.Input input = getInput(); Producer producer = manager.getProducer(input); "<AssertPlaceHolder>"; }
getProducer(KafkaPublishTask.Input input) { Properties configProperties = getProducerProperties(input); return getFromCache(configProperties, () -> new KafkaProducer(configProperties)); }
[*] target: assertNotNull(producer)
[-] pred: org. junit. Assert. assertNotNull ( producer )
************************************
************************************
[+] input: processTableFieldsOfNullEventData() { Map<String, Object> eventData = null; final String key1 = "field_char"; Set<String> fields = new HashSet<>(); fields.add(key1); eventData = FilterUtil.processTableFields(eventData, fields); Assert."<AssertPlaceHolder>";  }
processTableFields(Map<String, Object> data, Set<String> fieldNames) { if (null == fieldNames || fieldNames.isEmpty()) return data; if (null == data) return null; data.entrySet().removeIf(entry -> !fieldNames.contains(entry.getKey())); return data; }
[*] target: assertNull(eventData)
[-] pred: org. junit. Assert. assertNull ( eventData )
************************************
************************************
[+] input: Exception {  panel.setAddToTop(true); File temp = createTempFileForTest(); Preferences.setProperty(Preferences.LAST_IMPORT_DIRECTORY, temp.getParent()); panel.setFileChooserProperties("Select Source Files", Preferences.LAST_IMPORT_DIRECTORY, GhidraFileChooserMode.FILES_AND_DIRECTORIES, true, new ExtensionFileFilter(new String[] { "h" }, "C Header Files"));  JButton button = findButtonByIcon(panel, ResourceManager.loadImage("images/Plus.png")); "<AssertPlaceHolder>"; pressButton(button, false);  waitForPostedSwingRunnables(); selectFromFileChooser();  assertEquals(6, table.getRowCount());  String filename = (String) table.getModel().getValueAt(0, 0); assertTrue(filename.endsWith("fred.h"));  }
setAddToTop(boolean addToTop) { this.addToTop = addToTop; }
[*] target: assertNotNull(button)
[-] pred: org. junit. Assert. assertNotNull ( button )
************************************
************************************
[+] input: testExtractCommentValue() { String expectComment = ""; List<String> columnSpecs = Arrays.asList("default", "'100'", "COMMENT", "''"); String actualComment = schemaManager.extractComment(columnSpecs); Assert."<AssertPlaceHolder>"; }
extractComment(List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } return extractAdjacentString(columnSpecs, COMMENT); }
[*] target: assertEquals(expectComment, actualComment)
[-] pred: org. junit. Assert. assertEquals ( expectComment, actualComment )
************************************
************************************
[+] input: testIgnoreOtherClasses() { final ClassFileSaveTransformer classFileSaveTransformer = new ClassFileSaveTransformer(Integer.class.getName()); final byte[] classBytes = new byte[10];  classFileSaveTransformer.transform(String.class.getClassLoader(), String.class.getName(), String.class, null, classBytes);  final byte[] bytes = classFileSaveTransformer.getBytes();  Assert."<AssertPlaceHolder>"; }
transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) { if (className.replace('/', '.').equals(this.className)) { bytes = classfileBuffer; } return null; }
[*] target: assertNull(bytes)
[-] pred: org. junit. Assert. assertNull ( bytes )
************************************
************************************
[+] input: whenResolve_withProperty_success() { String submodelId = "http://example.org/submodel"; String submodelElementIdShort = "foo"; SubmodelElement expected = new DefaultProperty.Builder() .idShort(submodelElementIdShort) .value("bar") .build(); Environment environment = new DefaultEnvironment.Builder() .submodels(new DefaultSubmodel.Builder() .id(submodelId) .submodelElements(expected) .build()) .build(); Reference reference = new DefaultReference.Builder() .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL) .value(submodelId) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT) .value(submodelElementIdShort) .build()) .build(); Referable actual = AasUtils.resolve(reference, environment); Assert."<AssertPlaceHolder>"; }
resolve(Reference reference, Environment env) { return resolve(reference, env, Referable.class); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testIterator2() { for (int i = 0; i < 10000; i++) { ps.putObject(i, new Integer(i)); } LongIterator it = ps.getPropertyIterator(); int i = 0; while (it.hasNext()) { long l = it.next(); "<AssertPlaceHolder>"; i++; } assertEquals(i, 10000); }
putObject(long index, Object value) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.addObject(getPageOffset(index), value); numProperties += page.getSize() - n; }
[*] target: assertEquals(i, l)
[-] pred: org. junit. Assert. assertEquals ( i, l )
************************************
************************************
[+] input: Exception {  String mangled = "_ZNSt14__array_traitsIN12LayerDetails15RandomProviderTIZNKS0_9LayerBase10initRandomEllEUlRljE_EELm4EE6_S_refERA4_KS5_m";  String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals( "undefined std::__array_traits<LayerDetails::RandomProviderT<LayerDetails::LayerBase::initRandom(long,long)const::{lambda(long&,unsigned_int)#1}>,4ul>::_S_ref(LayerDetails::LayerBase::initRandom(long,long) const::{lambda(long&, unsigned int)#1} const &[],unsigned long)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception { Structure s = new StructureDataType("foo", 1); assertFalse(s.isNotYetDefined()); assertFalse(s.isZeroLength()); assertEquals(1, s.getNumComponents()); assertEquals(0, s.getNumDefinedComponents()); Structure s2 = (Structure) dataMgr.resolve(s, null); assertFalse(s2.isNotYetDefined()); assertFalse(s2.isZeroLength()); assertEquals(1, s2.getNumComponents()); "<AssertPlaceHolder>"; }
getNumDefinedComponents() { lock.acquire(); try { return components.size(); } finally { lock.release(); } }
[*] target: assertEquals(0, s2.getNumDefinedComponents())
[-] pred: org. junit. Assert. assertEquals ( 0, s2. getNumDefinedComponents ( ) )
************************************
************************************
[+] input: testIterator2() { for (int i = 0; i < 10000; i++) { ps.putObject(i, new SaveableInt(i)); } LongIterator it = ps.getPropertyIterator(); int i = 0; while (it.hasNext()) { long l = it.next(); "<AssertPlaceHolder>"; i++; } assertEquals(i, 10000); }
putObject(long index, Saveable value) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.addSaveableObject(getPageOffset(index), value); numProperties += page.getSize() - n; }
[*] target: assertEquals(i, l)
[-] pred: org. junit. Assert. assertEquals ( i, l )
************************************
************************************
[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setDouble(5, 3.14444); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred: org. junit. Assert. assertEquals ( 1, ret )
************************************
************************************
[+] input: testSplitWithMaxAtMaxWithSpacesAtEnd() { // The word is long enough to force a hard split on the first 'n' characters.  The // space at the end allows the remaining 'word' to be kept intact. List<String> lines = HtmlLineSplitter.split("abc        ", 3); "<AssertPlaceHolder>"; assertEquals("abc", lines.get(0)); }
split(String text, int maxLineLength) { return split(text, maxLineLength, false); }
[*] target: assertEquals(1, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 1, lines. size ( ) )
************************************
************************************
[+] input: testFindUserCredentials() { User user = userService.findUserByEmail(SYSTEM_TENANT_ID,"sysadmin@thingsboard.org"); Assert.assertNotNull(user); UserCredentials userCredentials = userService.findUserCredentialsByUserId(SYSTEM_TENANT_ID, user.getId()); Assert."<AssertPlaceHolder>"; }
findUserCredentialsByUserId(TenantId tenantId, UserId userId);
[*] target: assertNotNull(userCredentials)
[-] pred: org. junit. Assert. assertNotNull ( userCredentials )
************************************
************************************
[+] input: testNorthNorthNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 10);  TestSuiteChromosome exepcted_individual = population.get(2); TestSuiteChromosome returned_individual = neighbors.get(8);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testDeleteFrom() { AddressSet set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  AddressSet origSet = new AddressSet(set); set.deleteToMax(space2.getAddress(0x50)); assertEquals(origSet, set);  set.deleteToMax(addr(0x15));  AddressSet expectedSet = set(0x10, 0x14); assertEquals(expectedSet, set);  set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  set.deleteToMax(space2.getAddress(0x15));  expectedSet = set(0x10, 0x20, 0x30, 0x40); expectedSet.add(space2.getAddress(0x10), space2.getAddress(0x14)); assertEquals(expectedSet, set);  set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  set.deleteToMax(addr(0x0)); assertTrue(set.isEmpty());  set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  set.deleteToMax(addr(0x10)); assertTrue(set.isEmpty());  // make sure handles empty set set = new AddressSet(); set.deleteToMax(addr(0x30)); "<AssertPlaceHolder>"; }
isEmpty() { return rbTree.isEmpty(); }
[*] target: assertTrue(set.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( set. isEmpty ( ) )
************************************
************************************
[+] input: Exception { ProgramBuilder builder = build64BitX86NonVS(); ProgramDB program = builder.getProgram(); boolean result = PEUtil.isVisualStudioOrClangPe(program); "<AssertPlaceHolder>"; }
isVisualStudioOrClangPe(Program program) { return program.getExecutableFormat().equals(PeLoader.PE_NAME) && (program.getCompiler().equals(CompilerEnum.VisualStudio.toString()) || program.getCompiler().equals(CompilerEnum.Clang.toString())); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testTokenizeString() { String s = "Lorem, ipsum. dolor, sit amet"; String reg = "[,\\.]"; String del = " "; brandInfrastructure.setTokenizationParameters(del,reg); List<String> expected = List.of("Lorem","ipsum","dolor","sit","amet"); List<String> actual = brandInfrastructure.tokenizeString(s); "<AssertPlaceHolder>"; }
tokenizeString(String inString) { inString = inString.replaceAll(tokenizationParameters.ignoreRegex, ""); List<String> tokens = List.of(inString.split(tokenizationParameters.delimiterRegex)); return tokens.stream().filter(tokenString -> !tokenString.isEmpty()).toList(); }
[*] target: assertEquals(expected,actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: span_combinesOverlappingInterval() { // Arrange ZonedInterval earliestInterval = new ZonedInterval(SEVEN_DAYS_AGO, THREE_DAYS_AGO); ZonedInterval latestInterval = new ZonedInterval(FIVE_DAYS_AGO, ONE_DAY_AGO); ZonedInterval expectedInterval = new ZonedInterval(SEVEN_DAYS_AGO, ONE_DAY_AGO);  // Act ZonedInterval resultingInterval = earliestInterval.span(latestInterval);  // Assert "<AssertPlaceHolder>"; }
span(@Nonnull ZonedInterval interval) { ZonedDateTime startTime = ObjectUtils.min(interval.getStart(), this.getStart()); ZonedDateTime endTime = ObjectUtils.max(interval.getEndExclusive(), this.getEndExclusive()); return new ZonedInterval(startTime, endTime); }
[*] target: assertEquals(expectedInterval, resultingInterval)
[-] pred: org. junit. Assert. assertEquals ( expectedInterval, resultingInterval )
************************************
************************************
[+] input: Exception { SimpleLineReader reader = new SimpleLineReader(new Document("aha\noho\r\n\r\n\n")); assertEquals("aha\n", reader.readLine()); assertEquals("oho\r\n", reader.readLine()); assertEquals("\r\n", reader.readLine()); assertEquals("\n", reader.readLine()); "<AssertPlaceHolder>"; }
readLine() { int nLines= fInput.getNumberOfLines(); if (fCurrLine >= nLines) { return null; }  try { IRegion region= fInput.getLineInformation(fCurrLine++); String content= fInput.get(region.getOffset(), region.getLength());  int start= region.getOffset();  boolean continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$  while (continuesOnNext && fCurrLine < nLines) { region= fInput.getLineInformation(fCurrLine++); content= fInput.get(region.getOffset(), region.getLength()); continuesOnNext= content.endsWith("\") && !isCommentOrWhiteSpace(content); //$NON-NLS-1$ } int end; if (fCurrLine < nLines) { end= fInput.getLineOffset(fCurrLine); // beginning of next } else { end= fInput.getLength(); if (end == start) { return null; // nd of file, empty line -> null } } return fInput.get(start, end - start); } catch (BadLocationException e) { // should not happen JavaManipulationPlugin.log(e); } return null; }
[*] target: assertNull(reader.readLine())
[-] pred: org. junit. Assert. assertNull ( reader. readLine() )
************************************
************************************
[+] input: testGetColor_StateInactive_ReturnInactiveColor() { final int color = mTileColorPicker.getColor(Tile.STATE_INACTIVE); final int expectedColor = mTintColorStateList.getColorForState( TileColorPicker.INACTIVE_STATE_SET, DEFAULT_COLOR);  "<AssertPlaceHolder>"; }
getColor(int state) { final int defaultColor = 0;  switch (state) { case Tile.STATE_UNAVAILABLE: return mColorStateList.getColorForState(DISABLE_STATE_SET, defaultColor); case Tile.STATE_INACTIVE: return mColorStateList.getColorForState(INACTIVE_STATE_SET, defaultColor); case Tile.STATE_ACTIVE: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); default: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); } }
[*] target: assertEquals(expectedColor, color)
[-] pred: org. junit. Assert. assertEquals ( expectedColor, color )
************************************
************************************
[+] input: testBuild() { DorisBatchSink.Builder<String> builder = DorisBatchSink.builder(); DorisOptions.Builder dorisBuilder = DorisOptions.builder(); dorisBuilder .setFenodes("127.0.0.1:8030") .setTableIdentifier("db.tbl") .setUsername("root") .setPassword(""); DorisExecutionOptions.Builder executionBuilder = DorisExecutionOptions.builder(); DorisBatchSink<String> build = builder.setDorisExecutionOptions(executionBuilder.build()) .setSerializer(new SimpleStringSerializer()) .setDorisOptions(dorisBuilder.build()) .build();  DorisReadOptions expected = DorisReadOptions.builder().build(); DorisReadOptions actual = build.getDorisReadOptions(); Assert."<AssertPlaceHolder>"; }
getDorisReadOptions() { return dorisReadOptions; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testRandomUint64() { UniformRandomGenerator generator = UniformRandomGeneratorFactory.defaultFactory().create(prngType); TLongSet values = new TLongHashSet(); int count = 100; for (int i = 0; i < count; i++) { values.add(generator.nextLong()); } Assert."<AssertPlaceHolder>"; }
nextLong();  /** * Generates randomness into the destination. * * @param destination the destination. */ void generate(long[] destination);  /** * Generates randomness with the assigned length into the destination. * * @param byteCount   the randomness length in byte. * @param destination the destination. * @param startIndex  the start index in the destination. */ void generate(int byteCount, long[] destination, int startIndex);  /** * Returns the next pseudorandom, Gaussian ("normally") distributed * {@code double}
[*] target: assertEquals(count, values.size())
[-] pred: org. junit. Assert. assertEquals ( count, values. size ( ) )
************************************
************************************
[+] input: whenResolve_withElementWithinSubmodelElementList_success() { String submodelId = "http://example.org/submodel"; String submodelElementIdShort = "foo"; SubmodelElement expected = new DefaultProperty.Builder() .value("bar") .build(); Environment environment = new DefaultEnvironment.Builder() .submodels(new DefaultSubmodel.Builder() .id(submodelId) .submodelElements(new DefaultSubmodelElementList.Builder() .idShort(submodelElementIdShort) .value(expected) .build()) .build()) .build(); Reference reference = new DefaultReference.Builder() .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL) .value(submodelId) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT) .value(submodelElementIdShort) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT) .value("0") .build()) .build(); Referable actual = AasUtils.resolve(reference, environment); Assert."<AssertPlaceHolder>"; }
resolve(Reference reference, Environment env) { return resolve(reference, env, Referable.class); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testAddBubble() { mBubbleController.updateBubble(mRow.getEntry()); "<AssertPlaceHolder>";  assertFalse(mSysUiStateBubblesExpanded); }
hasBubbles() { if (mStackView == null) { return false; } return mBubbleData.hasBubbles(); }
[*] target: assertTrue(mBubbleController.hasBubbles())
[-] pred: org. junit. Assert. assertTrue ( mBubbleController. hasBubbles() )
************************************
************************************
[+] input: testGetIP() { //notice: please check that you only have one externalIP String ip1 = null, ip2 = null, ip3 = null; try { Method method = NetUtil.class.getDeclaredMethod("getExternalIp", String.class); method.setAccessible(true); ip1 = (String) method.invoke(NetUtil.class, Constant.ipV4Urls.get(0)); ip2 = (String) method.invoke(NetUtil.class, Constant.ipV4Urls.get(1)); ip3 = (String) method.invoke(NetUtil.class, Constant.ipV4Urls.get(2)); } catch (Exception e) { Assert.fail(); } String ip4 = NetUtil.getExternalIpV4(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(ip2, ip4); Assert.assertEquals(ip3, ip4); }
getExternalIpV4() { long t1 = System.currentTimeMillis(); String ipV4 = getIp(Constant.ipV4Urls); log.debug("GetExternalIpV4 cost {} ms", System.currentTimeMillis() - t1); return ipV4; }
[*] target: assertEquals(ip1, ip4)
[-] pred: org. junit. Assert. assertEquals ( ip1, ip4 )
************************************
************************************
[+] input: Exception { doReturn(true).when(mIDumpstateDevice).getVerboseLoggingEnabled();  mController.onPreferenceChange(mPreference, true /* new value */);  final boolean enabled = mController.getVerboseLoggingEnabled(); "<AssertPlaceHolder>"; }
getVerboseLoggingEnabled() { IDumpstateDevice service = getDumpstateDeviceService();  if (service == null || mDumpstateHalVersion < DUMPSTATE_HAL_VERSION_1_1) { if (DBG) Log.d(TAG, "getVerboseLoggingEnabled not supported."); return false; }  try { android.hardware.dumpstate.V1_1.IDumpstateDevice service11 = (android.hardware.dumpstate.V1_1.IDumpstateDevice) service; if (service11 != null) { return service11.getVerboseLoggingEnabled(); } } catch (RemoteException | RuntimeException e) { if (DBG) Log.e(TAG, "getVerboseLoggingEnabled fail: " + e); } return false; }
[*] target: assertTrue(enabled)
[-] pred: org. junit. Assert. assertTrue ( enabled )
************************************
************************************
[+] input: Exception { selectRow(2);  JButton downButton = findButtonByIcon(pathManager.getComponent(), ResourceManager.loadImage("images/down.png")); "<AssertPlaceHolder>"; pressButton(downButton, true); waitForSwing();  int row = table.getSelectedRow(); assertEquals(3, row); assertEquals(new Path("c:\\path_three"), table.getModel().getValueAt(row, 1));  pressButton(downButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(0, row); assertEquals(new Path("c:\\path_three"), table.getModel().getValueAt(row, 1));  pressButton(downButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(1, row); assertEquals(new Path("c:\\path_three"), table.getModel().getValueAt(row, 1));  pressButton(downButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(2, row); assertEquals(new Path("c:\\path_three"), table.getModel().getValueAt(row, 1)); }
getComponent() { return panel; }
[*] target: assertNotNull(downButton)
[-] pred: org. junit. Assert. assertNotNull ( downButton )
************************************
************************************
[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setInt(2, 10086); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred: org. junit. Assert. assertEquals ( 1, ret )
************************************
************************************
[+] input: testTrimStart() { AddressSet set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  AddressSetView trimSet = AddressSetView.trimStart(set, addr(0x15));  AddressSet expectedSet = set(0x16, 0x20, 0x30, 0x40); expectedSet.add(space2.getAddress(0x10), space2.getAddress(0x20)); expectedSet.add(space2.getAddress(0x30), space2.getAddress(0x40)); assertEquals(expectedSet, trimSet);  trimSet = AddressSetView.trimStart(set, space2.getAddress(0x15));  expectedSet = new AddressSet(space2.getAddress(0x16), space2.getAddress(0x20)); expectedSet.add(space2.getAddress(0x30), space2.getAddress(0x40)); "<AssertPlaceHolder>"; }
add(Address start, Address end) { checkValidRange(start, end);  if (lastNode != null && !lastNode.isDisposed()) { Address value = lastNode.getValue(); if (contains(lastNode, start) || value.isSuccessor(start)) { if (end.compareTo(value) > 0) { updateRangeEndAddress(lastNode, end); consumeFollowOnNodes(lastNode); } return; } }  if (rbTree.isEmpty()) { lastNode = createRangeNode(start, end); return; }  if (start.compareTo(rbTree.getLast().getKey()) > 0) { RedBlackEntry<Address, Address> last = rbTree.getLast(); Address value = last.getValue(); if (contains(last, start) || value.isSuccessor(start)) { if (end.compareTo(value) > 0) { updateRangeEndAddress(last, end); } } else { lastNode = createRangeNode(start, end); } return; }  lastNode = rbTree.getEntryLessThanEqual(start); if (lastNode == null) { lastNode = createRangeNode(start, end); consumeFollowOnNodes(lastNode); return; }  Address nodeEnd = lastNode.getValue(); if (nodeEnd.compareTo(start) >= 0 || nodeEnd.isSuccessor(start)) { if (end.compareTo(nodeEnd) > 0) { updateRangeEndAddress(lastNode, end); consumeFollowOnNodes(lastNode); } return; }  lastNode = createRangeNode(start, end); consumeFollowOnNodes(lastNode);  }
[*] target: assertEquals(expectedSet, trimSet)
[-] pred: org. junit. Assert. assertEquals ( expectedSet, trimSet )
************************************
************************************
[+] input: Exception { AddressSet as1 = new AddressSet(); as1.addRange(addr("0x1001100"), addr("0x1001120")); as1.addRange(addr("0x1001150"), addr("0x1001180")); as1.addRange(addr("0x1001200"), addr("0x1001210")); as1.addRange(addr("0x1001260"), addr("0x1001280")); AddressSet as2 = new AddressSet(); as2.addRange(addr("0x1001090"), addr("0x1001130")); as2.addRange(addr("0x1001170"), addr("0x1001190")); as2.addRange(addr("0x1001230"), addr("0x1001240")); as2.addRange(addr("0x1001250"), addr("0x1001270")); AddressSet as3 = new AddressSet(); as3.addRange(addr("0x1001132"), addr("0x1001132")); as3.addRange(addr("0x1001175"), addr("0x1001175")); as3.addRange(addr("0x1001205"), addr("0x1001235"));  AddressSet multiSet = new AddressSet(); multiSet.addRange(addr("0x1001090"), addr("0x1001130")); multiSet.addRange(addr("0x1001132"), addr("0x1001132")); multiSet.addRange(addr("0x1001150"), addr("0x1001190")); multiSet.addRange(addr("0x1001200"), addr("0x1001240")); multiSet.addRange(addr("0x1001250"), addr("0x1001280")); AddressIterator ai; MultiAddressIterator iter;  // Forward tests boolean forward = true; ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as1.getAddresses(forward), as2.getAddresses(forward), as3.getAddresses(forward) }); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); assertEquals(expectedAddress, actualAddress); }  ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as1.getAddresses(forward), as3.getAddresses(forward), as2.getAddresses(forward) }); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); assertEquals(expectedAddress, actualAddress); }  ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as2.getAddresses(forward), as3.getAddresses(forward), as1.getAddresses(forward) }); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); assertEquals(expectedAddress, actualAddress); }  ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as2.getAddresses(forward), as1.getAddresses(forward), as3.getAddresses(forward) }); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); assertEquals(expectedAddress, actualAddress); }  ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as3.getAddresses(forward), as2.getAddresses(forward), as1.getAddresses(forward) }); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); assertEquals(expectedAddress, actualAddress); }  ai = multiSet.getAddresses(forward); iter = new MultiAddressIterator(new AddressIterator[] { as3.getAddresses(forward), as1.getAddresses(forward), as2.getAddresses(forward) }); while (iter.hasNext()) { assertTrue(ai.hasNext()); Address expectedAddress = ai.next(); Address actualAddress = iter.next(); "<AssertPlaceHolder>"; } }
next() { // Get a next value from each iterator for (int i = 0; i < iters.length; i++) { if (addrs[i] == null) { if (((iters[i] != null) && (iters[i].hasNext()))) { addrs[i] = iters[i].next(); } } }  // Find next address. Address addrNext = null; boolean next[] = new boolean[iters.length]; for (int i = 0; i < iters.length; i++) { if (addrs[i] == null) { continue; } if (addrNext == null) { addrNext = addrs[i]; next[i] = true; } else { int result = addrNext.compareTo(addrs[i]); if (result == 0) { next[i] = true; } else if ((forward && (result > 0)) || (!forward && (result < 0))) { addrNext = addrs[i]; for (int n = 0; n < i; n++) { next[n] = false; } next[i] = true; } } }  // Return next address or null if none. for (int i = 0; i < iters.length; i++) { if (next[i]) { addrs[i] = null; } } return addrNext; }
[*] target: assertEquals(expectedAddress, actualAddress)
[-] pred: org. junit. Assert. assertEquals ( expectedAddress, actualAddress )
************************************
************************************
[+] input: givenAgentConfig_whenToAgentArgsThenParseArgs_parsedArgsEqualsInitialConfig() { final AgentConfiguration agentConfiguration = AgentConfiguration.builder() .identifier("id") .logLevel(1) .port(5000) .hostName("1.1.1.1") .logFilePath("log-file-path") .build(); final String args = agentConfiguration.toAgentArgs(); final AgentConfiguration parsedAgentConfigured = AgentConfiguration.parseAgentArgs(args); Assert."<AssertPlaceHolder>"; }
parseAgentArgs(String agentArgs) { final Properties properties = new Properties(); try { properties.load(new StringReader(agentArgs)); } catch (IOException e) { // Should never happen throw new IllegalStateException(e); } return AgentConfiguration.builder() .port(Integer.parseInt(properties.getProperty(PORT_KEY))) .hostName(properties.getProperty(HOST_NAME_KEY)) .identifier(properties.getProperty(IDENTIFIER_KEY)) .logLevel(Integer.parseInt(properties.getProperty(LOG_LEVEL_KEY))) .logFilePath(properties.getProperty(LOG_FILE_PATH_KEY)) .build(); }
[*] target: assertEquals(agentConfiguration, parsedAgentConfigured)
[-] pred: org. junit. Assert. assertEquals ( agentConfiguration, parsedAgentConfigured )
************************************
************************************
[+] input: testSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.compactNine(population, 5);  TestSuiteChromosome exepcted_individual = population.get(10); TestSuiteChromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
compactNine(List<T> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: addNewFlight() { // expected data init AirportCompany airport_x = new AirportCompany(1, "Airport X", new ArrayList<>()); // new ArrayList<>(); Flight expectedFlight = new Flight(1, "Flight-XYZ", 50, 300, new Date(), new Date(), null, null, airport_x); AirportCompany updatedAirport_X = new AirportCompany(1, "Airport X", Arrays.asList(expectedFlight));  // stub - when when(airportCompanyRepository.findById(any())).thenReturn(Optional.of(airport_x)); when(flightService.getFlight(any())).thenReturn(expectedFlight); when(airportCompanyRepository.save(airport_x)).thenReturn(updatedAirport_X);  // then boolean actualStatus = airportCompanyService.addNewFlight(1, 1);  Assert."<AssertPlaceHolder>"; }
addNewFlight(Integer airportCompanyId, Integer flightId);
[*] target: assertTrue(actualStatus)
[-] pred: org. junit. Assert. assertTrue ( actualStatus )
************************************
************************************
[+] input: testFindUserById() { User user = userService.findUserByEmail(SYSTEM_TENANT_ID, "sysadmin@thingsboard.org"); Assert.assertNotNull(user); User foundUser = userService.findUserById(SYSTEM_TENANT_ID, user.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(user, foundUser); }
findUserById(TenantId tenantId, UserId userId);
[*] target: assertNotNull(foundUser)
[-] pred: org. junit. Assert. assertNotNull ( foundUser )
************************************
************************************
[+] input: multiValuesNoSeparator() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,?,?)(?,?,?,?)(?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 100, 3.14, "abc", 4, 200, 3.1415, "xyz", 5, 300, 3.141592, "uvw", 6).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (100,3.14,'abc',4)(200,3.1415,'xyz',5)(300,3.141592,'uvw',6)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testExtractCommentValueNull() { List<String> columnSpecs = Arrays.asList("default", null, "CommenT", null); String actualComment = schemaManager.extractComment(columnSpecs); Assert."<AssertPlaceHolder>"; }
extractComment(List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } return extractAdjacentString(columnSpecs, COMMENT); }
[*] target: assertNull(actualComment)
[-] pred: org. junit. Assert. assertNull ( actualComment )
************************************
************************************
[+] input: testMaxRegisterAddress() { AddressSpace regSpace = p.getAddressFactory().getRegisterSpace(); Address a = regSpace.getAddress(-1); long key = addrMap.getKey(a, false); assertEquals(0x300000000000ffffl, key); Address b = addrMap.decodeAddress(key); "<AssertPlaceHolder>"; assertEquals(regSpace.getAddress(0xffffL), b);  }
decodeAddress(long value) { return decodeAddress(value, true); }
[*] target: assertEquals(a, b)
[-] pred: org. junit. Assert. assertEquals ( a, b )
************************************
************************************
[+] input: Exception {  SmartUtLocalAddress addr = new SmartUtLocalAddress("127.42.42.42",42); NetworkHandling.sendDataOnTcp(addr,null);  MockServerSocket sut = new MockServerSocket(addr.getPort(), 1, MockInetAddress.getByName(addr.getHost())); Socket socket = sut.accept(); //should not block, should not timeout Assert."<AssertPlaceHolder>"; }
sendDataOnTcp(SmartUtLocalAddress sutServer, byte[] data){ if(sutServer==null){ return false; }  NativeTcp connection = VirtualNetwork.getInstance().registerIncomingTcpConnection( DEFAULT_REMOTE_ADDRESS, VirtualNetwork.getInstance().getNewRemoteEphemeralPort(), sutServer.getHost(), sutServer.getPort());  /* * At this point in time the SUT has not opened a connection yet (if it did, * it would had thrown an IOException). * But we can already put the message on the buffer */  if(data != null){ for(byte b : data){ connection.writeToSUT(b); } } //TODO close connection? or should rather be in another helper function?  return true; }
[*] target: assertNotNull(socket)
[-] pred: org. junit. Assert. assertNotNull ( socket )
************************************
************************************
[+] input: testIterator2() { for (int i = 0; i < 10000; i++) { ps.putInt(i, i); } LongIterator it = ps.getPropertyIterator(); int i = 0; while (it.hasNext()) { long l = it.next(); "<AssertPlaceHolder>"; i++; } assertEquals(i, 10000); }
putInt(long index, int value) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.addInt(getPageOffset(index), value); numProperties += page.getSize() - n; }
[*] target: assertEquals(i, l)
[-] pred: org. junit. Assert. assertEquals ( i, l )
************************************
************************************
[+] input: testFindAssetInfoByTenantIdAndAssetProfileId() { Customer customer = new Customer(); customer.setTitle("Customer X"); customer.setTenantId(tenantId); Customer savedCustomer = customerService.saveCustomer(customer);  Asset asset = new Asset(); asset.setTenantId(tenantId); asset.setName("default"); asset.setLabel("label"); asset.setCustomerId(savedCustomer.getId()); Asset savedAsset = assetService.saveAsset(asset);  PageLink pageLinkWithLabel = new PageLink(100, 0, "label"); List<AssetInfo> assetInfosWithLabel = assetService .findAssetInfosByTenantIdAndAssetProfileId(tenantId, savedAsset.getAssetProfileId(), pageLinkWithLabel).getData();  Assert.assertFalse(assetInfosWithLabel.isEmpty()); Assert.assertTrue( assetInfosWithLabel.stream() .anyMatch( d -> d.getId().equals(savedAsset.getId()) && d.getTenantId().equals(tenantId) && d.getAssetProfileId().equals(savedAsset.getAssetProfileId()) && d.getLabel().equals(savedAsset.getLabel()) ) );  PageLink pageLinkWithCustomer = new PageLink(100, 0, savedCustomer.getTitle()); List<AssetInfo> assetInfosWithCustomer = assetService .findAssetInfosByTenantIdAndAssetProfileId(tenantId, savedAsset.getAssetProfileId(), pageLinkWithCustomer).getData();  Assert."<AssertPlaceHolder>"; Assert.assertTrue( assetInfosWithCustomer.stream() .anyMatch( d -> d.getId().equals(savedAsset.getId()) && d.getTenantId().equals(tenantId) && d.getAssetProfileId().equals(savedAsset.getAssetProfileId()) && d.getCustomerId().equals(savedCustomer.getId()) && d.getCustomerTitle().equals(savedCustomer.getTitle()) ) ); }
findAssetInfosByTenantIdAndAssetProfileId(TenantId tenantId, AssetProfileId assetProfileId, PageLink pageLink);
[*] target: assertFalse(assetInfosWithCustomer.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( assetInfosWithCustomer. isEmpty ( ) )
************************************
************************************
[+] input: testFindDefaultDeviceProfileInfo() { DeviceProfileInfo foundDefaultDeviceProfileInfo = deviceProfileService.findDefaultDeviceProfileInfo(tenantId); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(foundDefaultDeviceProfileInfo.getId()); Assert.assertNotNull(foundDefaultDeviceProfileInfo.getName()); Assert.assertNotNull(foundDefaultDeviceProfileInfo.getType()); }
findDefaultDeviceProfileInfo(TenantId tenantId);
[*] target: assertNotNull(foundDefaultDeviceProfileInfo)
[-] pred: org. junit. Assert. assertNotNull ( foundDefaultDeviceProfileInfo )
************************************
************************************
[+] input: testShouldNotPutInCacheRolledbackAssetProfile() { AssetProfile assetProfile = new AssetProfile(); assetProfile.setName(StringUtils.randomAlphabetic(10)); assetProfile.setTenantId(tenantId);  Asset asset = new Asset(); asset.setName("My asset" + StringUtils.randomAlphabetic(15)); asset.setType(assetProfile.getName()); asset.setTenantId(tenantId);  DefaultTransactionDefinition def = new DefaultTransactionDefinition(); TransactionStatus status = platformTransactionManager.getTransaction(def); try { assetProfileService.saveAssetProfile(assetProfile); assetService.saveAsset(asset); } finally { platformTransactionManager.rollback(status); } AssetProfile assetProfileByName = assetProfileService.findAssetProfileByName(tenantId, assetProfile.getName()); Assert."<AssertPlaceHolder>"; }
saveAsset(Asset asset);
[*] target: assertNull(assetProfileByName)
[-] pred: org. junit. Assert. assertNull ( assetProfileByName )
************************************
************************************
[+] input: Exception {  File temp = createTempFileForTest();  Preferences.setProperty(Preferences.LAST_IMPORT_DIRECTORY, temp.getParent()); pathManager.setFileChooserProperties("Select Source Files", Preferences.LAST_IMPORT_DIRECTORY, GhidraFileChooserMode.FILES_AND_DIRECTORIES, true, new ExtensionFileFilter(new String[] { "h" }, "C Header Files"));  JButton button = findButtonByIcon(pathManager.getComponent(), ResourceManager.loadImage("images/Plus.png")); "<AssertPlaceHolder>"; pressButton(button, false);  waitForSwing(); GhidraFileChooser fileChooser = waitForDialogComponent(GhidraFileChooser.class); assertNotNull(fileChooser);  assertEquals(temp.getParentFile().getName(), fileChooser.getCurrentDirectory().getName()); assertTrue(fileChooser.isMultiSelectionEnabled());  File f = new File("c:\\temp\\myInclude.h"); assertTrue(fileChooser.accept(f)); f = new File("c:\\temp\\myFile.c"); assertTrue(!fileChooser.accept(f));  pressButtonByText(fileChooser, "Cancel", true); }
getComponent() { return panel; }
[*] target: assertNotNull(button)
[-] pred: org. junit. Assert. assertNotNull ( button )
************************************
************************************
[+] input: testGetLastCodeColorAfterFormat() { String input = BUKKIT_COLOR_CODE_PREFIX + "o" + BUKKIT_COLOR_CODE_PREFIX + "cHello"; String expectedResult = BUKKIT_COLOR_CODE_PREFIX + "c";  String result = Format.getLastCode(input);  "<AssertPlaceHolder>"; }
getLastCode(String s) { String ts = ""; char[] ch = s.toCharArray(); for (int a = 0; a < s.length() - 1; a++) { if (String.valueOf(ch[a + 1]).matches("[lkomnLKOMN]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts += String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (String.valueOf(ch[a + 1]).matches("[0123456789abcdefrABCDEFR]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (ch[a + 1] == 'x' && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { if (ch.length > a + 13) { if (String.valueOf(ch[a + 3]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 5]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 7]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 9]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 11]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 13]).matches("[0123456789abcdefABCDEF]") && ch[a + 2] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 4] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 6] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 8] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 10] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 12] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1] + ch[a + 2] + ch[a + 3] + ch[a + 4] + ch[a + 5] + ch[a + 6] + ch[a + 7] + ch[a + 8] + ch[a + 9] + ch[a + 10] + ch[a + 11] + ch[a + 12] + ch[a + 13]; a += 13; } } } } return ts; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testHandle() { final Map<String, String> event = new HashMap<>(); event.put("fileId", "656d7741e7cf041007e6fb8a"); event.put("packageName", "packageName"); GridFSBucket gridFSBucket = mock(GridFSBucket.class); when(mockClientMongoOperator.getGridFSBucket()).thenReturn(gridFSBucket); WebSocketEventResult webSocketEventResult = loadJarLibEventHandlerUnderTest.handle(event); Assert."<AssertPlaceHolder>"; }
handle(Map event) { WebSocketEventResult result; LoadJarLibRequest req = JSONUtil.map2POJO(event, LoadJarLibRequest.class); ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); String fileId = req.getFileId(); String packageName = req.getPackageName(); if (StringUtils.isEmpty(fileId) || StringUtils.isEmpty(packageName)) { return WebSocketEventResult.handleFailed(WebSocketEventResult.Type.LOAD_JAR_LIB_RESULT, "illegal argument"); } //定义类加载器 final Path filePath = Paths.get(System.getenv("TAPDATA_WORK_DIR"), "lib", fileId); URL url ; try { url = filePath.toUri().toURL(); }catch (Exception e){ throw new TapCodeException(WebSocketHandlerExCode_32.PATH_TO_URL_FAILED,String.format("FileId: %s,FilePath: %s",fileId,filePath),e); } try (URLClassLoader classLoader = new URLClassLoader(new URL[]{url});){ synchronized (filePath){ if (Files.notExists(filePath)) { GridFSBucket gridFSBucket = clientMongoOperator.getGridFSBucket(); try (GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(new ObjectId(fileId))) { if (Files.notExists(filePath.getParent())) { Files.createDirectories(filePath.getParent()); } Files.createFile(filePath); Files.copy(gridFSDownloadStream, filePath, StandardCopyOption.REPLACE_EXISTING); } } } Thread.currentThread().setContextClassLoader(classLoader); Set<Class<?>> classSet = ClassUtil.scanPackage(packageName); List<LoadJarLibResponse> resList = getMethodList(classSet);  if (CollectionUtils.isEmpty(resList)) { throw new IllegalArgumentException("Can't find a suitable result from the jar"); } result = WebSocketEventResult.handleSuccess(WebSocketEventResult.Type.LOAD_JAR_LIB_RESULT, resList); } catch (Exception e) { logger.error("load jar class error", e); result = WebSocketEventResult.handleFailed(WebSocketEventResult.Type.LOAD_JAR_LIB_RESULT, e.getMessage()); } finally { Thread.currentThread().setContextClassLoader(contextClassLoader); } return result; }
[*] target: assertNotNull(webSocketEventResult)
[-] pred: org. junit. Assert. assertNotNull ( webSocketEventResult )
************************************
************************************
[+] input: hasNoTransitionsShouldReturnTrueWhenThisStateHasNoTransitions() { boolean hasNoTransitions = state.hasNoTransitions(); "<AssertPlaceHolder>"; }
hasNoTransitions() { return transitionStore == null; }
[*] target: assertTrue(hasNoTransitions)
[-] pred: org. junit. Assert. assertTrue ( hasNoTransitions )
************************************
************************************
[+] input: noDoubleUpdateOnOpNoted() { mController.setBGHandler(mMockHandler);  mController.onOpNoted(AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, AppOpsManager.MODE_ALLOWED); mController.onOpNoted(AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, AppOpsManager.MODE_ALLOWED);  // Only one post to notify subscribers verify(mMockHandler, times(1)).post(any());  List<AppOpItem> list = mController.getActiveAppOps(); "<AssertPlaceHolder>"; }
getActiveAppOps();
[*] target: assertEquals(1, list.size())
[-] pred: org. junit. Assert. assertEquals ( 1, list. size ( ) )
************************************
************************************
[+] input: testMostNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 0);  TestSuiteChromosome exepcted_individual = population.get(15); TestSuiteChromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: IOException { // given String path = Objects.requireNonNull( ClassLoader.getSystemClassLoader().getResource("input/sequence.pdf") ).getPath(); File file = new File(path);  // when FilePdfSource source = new FilePdfSource(file); PDDocument document = source.doLoad();  // then Assert."<AssertPlaceHolder>"; // The PDF file has only 3 pages. Assert.assertEquals(3, document.getNumberOfPages()); }
doLoad() throws IOException { return PDDocument.load(source); }
[*] target: assertNotNull(document)
[-] pred: org. junit. Assert. assertNotNull ( document )
************************************
************************************
[+] input: testFilterRelationshipsBothExcludeAndInclude() { db.executeTransactionally("CREATE (u:User {name:'Joe',gender:'male'})-[:KNOWS]->(u), (u)-[:LOVES]->(u)"); final Map<String, String> conf = map("includeRels", "LOVES", "excludeRels", "LOVES");  final Object result = TestUtil.singleResultFirstColumn( db, "CALL apoc.nodes.group(['User'], ['gender'], null, $conf) yield relationship return relationship", map("conf", conf)); "<AssertPlaceHolder>"; }
group( @Name("labels") List<String> labelNames, @Name("groupByProperties") List<String> groupByProperties, @Name(value = "aggregations", defaultValue = "[{`*`:"count"}
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testDecryptHandler() { Pair<String, String> pair = EncryptionHandler.decryptHandler("test-dataId", "12345678", "content"); Assert."<AssertPlaceHolder>"; }
decryptHandler(String dataId, String secretKey, String content) { if (!checkCipher(dataId)) { return Pair.with("", content); } String algorithmName = parseAlgorithmName(dataId); Optional<EncryptionPluginService> optional = EncryptionPluginManager.instance() .findEncryptionService(algorithmName); if (!optional.isPresent()) { LOGGER.warn("[EncryptionHandler] [decryptHandler] No encryption program with the corresponding name found"); return Pair.with("", content); } EncryptionPluginService encryptionPluginService = optional.get(); String decryptSecretKey = encryptionPluginService.decryptSecretKey(secretKey); String decryptContent = encryptionPluginService.decrypt(decryptSecretKey, content); return Pair.with(decryptSecretKey, decryptContent); }
[*] target: assertNotNull(pair)
[-] pred: org. junit. Assert. assertNotNull ( pair )
************************************
************************************
[+] input: countTest() { long size = 42; Iterator<TripleString> it = LargeFakeDataSetStreamSupplier.createSupplierWithMaxTriples(size, 34) .createTripleStringStream(); int count = 0; while (it.hasNext()) { it.next(); count++; } "<AssertPlaceHolder>"; }
next() { if (!hasNext()) { return null; } Statement next = this.next; this.next = null; return next; }
[*] target: assertEquals(size, count)
[-] pred: org. junit. Assert. assertEquals ( size, count )
************************************
************************************
[+] input: testTrimEnd() { AddressSet set = set(0x10, 0x20, 0x30, 0x40); set.add(space2.getAddress(0x10), space2.getAddress(0x20)); set.add(space2.getAddress(0x30), space2.getAddress(0x40));  AddressSetView trimSet = AddressSetView.trimEnd(set, addr(0x15));  AddressSet expectedSet = set(0x10, 0x14); assertEquals(expectedSet, trimSet);  trimSet = AddressSetView.trimEnd(set, space2.getAddress(0x15));  expectedSet = set(0x10, 0x20, 0x30, 0x40); expectedSet.add(space2.getAddress(0x10), space2.getAddress(0x14)); "<AssertPlaceHolder>"; }
add(Address start, Address end) { checkValidRange(start, end);  if (lastNode != null && !lastNode.isDisposed()) { Address value = lastNode.getValue(); if (contains(lastNode, start) || value.isSuccessor(start)) { if (end.compareTo(value) > 0) { updateRangeEndAddress(lastNode, end); consumeFollowOnNodes(lastNode); } return; } }  if (rbTree.isEmpty()) { lastNode = createRangeNode(start, end); return; }  if (start.compareTo(rbTree.getLast().getKey()) > 0) { RedBlackEntry<Address, Address> last = rbTree.getLast(); Address value = last.getValue(); if (contains(last, start) || value.isSuccessor(start)) { if (end.compareTo(value) > 0) { updateRangeEndAddress(last, end); } } else { lastNode = createRangeNode(start, end); } return; }  lastNode = rbTree.getEntryLessThanEqual(start); if (lastNode == null) { lastNode = createRangeNode(start, end); consumeFollowOnNodes(lastNode); return; }  Address nodeEnd = lastNode.getValue(); if (nodeEnd.compareTo(start) >= 0 || nodeEnd.isSuccessor(start)) { if (end.compareTo(nodeEnd) > 0) { updateRangeEndAddress(lastNode, end); consumeFollowOnNodes(lastNode); } return; }  lastNode = createRangeNode(start, end); consumeFollowOnNodes(lastNode);  }
[*] target: assertEquals(expectedSet, trimSet)
[-] pred: org. junit. Assert. assertEquals ( expectedSet, trimSet )
************************************
************************************
[+] input: testIsAvailable_notIfNoChannelDesc() { NotificationBackend.AppRow appRow = new NotificationBackend.AppRow(); NotificationChannel channel = mock(NotificationChannel.class); when(channel.getImportance()).thenReturn(IMPORTANCE_LOW); mController.onResume(appRow, channel, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mChannel == null && !hasValidGroup()) { return false; } if (mChannel != null && !TextUtils.isEmpty(mChannel.getDescription())) { return true; } if (hasValidGroup() && !TextUtils.isEmpty(mChannelGroup.getDescription())) { return true; } return false; }
[*] target: assertFalse(mController.isAvailable())
[-] pred: org. junit. Assert. assertFalse ( mController. isAvailable() )
************************************
************************************
[+] input: shouldFilterMediaNotificationWhenEnabled() { // GIVEN that the media feature is enabled when(mMediaFeatureFlag.getEnabled()).thenReturn(true); NotificationFilter filter = new NotificationFilter(mStatusBarStateController, mMediaFeatureFlag); // WHEN the media filter is asked about a media entry final boolean shouldFilter = filter.shouldFilterOut(mMediaEntry); // THEN it should be filtered "<AssertPlaceHolder>"; }
shouldFilterOut(NotificationEntry entry) { final StatusBarNotification sbn = entry.getSbn(); if (!(getEnvironment().isDeviceProvisioned() || showNotificationEvenIfUnprovisioned(sbn))) { return true; }  if (!getEnvironment().isNotificationForCurrentProfiles(sbn)) { return true; }  if (getUserManager().isLockscreenPublicMode(sbn.getUserId()) && (sbn.getNotification().visibility == Notification.VISIBILITY_SECRET || getUserManager().shouldHideNotifications(sbn.getUserId()) || getUserManager().shouldHideNotifications(sbn.getKey()))) { return true; }  if (mStatusBarStateController.isDozing() && entry.shouldSuppressAmbient()) { return true; }  if (!mStatusBarStateController.isDozing() && entry.shouldSuppressNotificationList()) { return true; }  if (entry.getRanking().isSuspended()) { return true; }  if (getFsc().isDisclosureNotification(sbn) && !getFsc().isDisclosureNeededForUser(sbn.getUserId())) { // this is a foreground-service disclosure for a user that does not need to show one return true; } if (getFsc().isSystemAlertNotification(sbn)) { final String[] apps = sbn.getNotification().extras.getStringArray( Notification.EXTRA_FOREGROUND_APPS); if (apps != null && apps.length >= 1) { if (!getFsc().isSystemAlertWarningNeeded(sbn.getUserId(), apps[0])) { return true; } } }  if (mIsMediaFlagEnabled && isMediaNotification(sbn)) { return true; } return false; }
[*] target: assertTrue(shouldFilter)
[-] pred: org. junit. Assert. assertTrue ( shouldFilter )
************************************
************************************
[+] input: Exception { Gson gson = new Gson(); String jsonObject = "{"count":"123","hits":{"total":1000,"max_score":null,"hits":[{"_index":"bank","_type":"_doc","_id":"0","sort":[0],"_score":null,"_source":{"account_number":0,"balance":16623,"firstname":"Bradshaw","lastname":"qwe","age":29,"gender":"F","address":"2133","employer":"12","email":"bradshawqwe@123.com","city":"Hobucken","state":"CO"}}]},"aggregations":{"avg-values-per-day":{"buckets":[{"key_as_string":"ID","Avg-CPU-Utilization":{"value":12},"Avg-NetworkIn":{"value":12},"Avg-NetworkOut":{"value":12},"Avg-DiskReadinBytes":{"value":12},"Avg-DiskWriteinBytes":{"value":12}}]}}}"; Map<String, Object> json = (Map<String, Object>) gson.fromJson(jsonObject, Object.class); Map<String, Object> mustFilter = Maps.newHashMap(); mustFilter.put("test", json); mustFilter.put("range", json); Object response = CommonUtils.buildQueryForExistingIssues(mustFilter); "<AssertPlaceHolder>"; }
buildQueryForExistingIssues(Map<String, Object> filter) { Map<String, Object> queryFilters = Maps.newHashMap(); Map<String, Object> boolFilters = Maps.newHashMap(); List<Map<String, Object>> should = getFilter(filter); boolFilters.put(MUST, should); should = Lists.newArrayList(); Map<String, Object> term = Maps.newHashMap(); Map<String, Object> termDetails = Maps.newHashMap(); termDetails.put("issueStatus.keyword", "closed"); term.put("term", termDetails); should.add(term); boolFilters.put(MUST_NOT, should); should = Lists.newArrayList(); term = Maps.newHashMap(); termDetails = Maps.newHashMap(); termDetails.put("type.keyword", "issue"); term.put("term", termDetails); should.add(term); boolFilters.put(SHOULD, should); term = Maps.newHashMap(); termDetails = Maps.newHashMap(); termDetails.put("type.keyword", "recommendation"); term.put("term", termDetails); should.add(term); boolFilters.put(SHOULD, should); queryFilters.put(BOOL, boolFilters); return queryFilters; }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testAsSet_Collection_FromNull() {  Collection<String> c = null; Set<String> set = CollectionUtils.asSet(c); assertNotNull(set); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(set.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( set. isEmpty ( ) )
************************************
************************************
[+] input: IOException { Proto proto = ProtocolSelector.getProto(null, null, null); "<AssertPlaceHolder>"; }
getProto( ServerConnection connection, AndroidUtils utils, StatusNotifier notifier) throws ProtocolException { if (connection == null) { return null; } byte[] proto_v = {PROTO_MAX}; if (connection.send(proto_v)) { return null; } if (connection.receive(proto_v)) { return null; } int selectedProto = PROTO_MAX; if (proto_v[0] == ProtocolSelector.PROTOCOL_OBSOLETE) { throw new ProtocolException("Obsolete client"); } else if (proto_v[0] == ProtocolSelector.PROTOCOL_UNKNOWN) { byte[] serverProto = new byte[1]; if (connection.receive(serverProto)) { return null; } byte serverMaxProto = serverProto[0]; if (serverMaxProto < PROTO_MIN) { serverProto[0] = 0; connection.send(serverProto); throw new ProtocolException("Obsolete server"); } if (acceptProto(connection, serverMaxProto)) { return null; } selectedProto = serverMaxProto; } else if (proto_v[0] != ProtocolSelector.PROTOCOL_SUPPORTED) { return null; } switch (selectedProto) { case 1: return new Proto_v1(connection, utils, notifier); case 2: return new Proto_v2(connection, utils, notifier); case 3: return new Proto_v3(connection, utils, notifier); default: throw new ProtocolException("Unknown protocol"); } }
[*] target: assertNull(proto)
[-] pred: org. junit. Assert. assertNull ( proto )
************************************
************************************
[+] input: multiValues() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,?,?),(?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 100, 3.14, "abc", 4, 200, 3.1415, "xyz", 5).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (100,3.14,'abc',4),(200,3.1415,'xyz',5)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testTryHttpConnection() { backendUtilMockedStatic.when(() -> BackendUtil.tryHttpConnection(any())).thenReturn(true); boolean flag = BackendUtil.tryHttpConnection("127.0.0.1:8040"); Assert."<AssertPlaceHolder>"; }
tryHttpConnection(String host) { try { LOG.debug("try to connect host {}", host); host = "http://" + host; URL url = new URL(host); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(60000); connection.setReadTimeout(60000); int responseCode = connection.getResponseCode(); String responseMessage = connection.getResponseMessage(); connection.disconnect(); if (200 == responseCode) { return true; } LOG.warn( "Failed to connect host {}, responseCode={}, msg={}", host, responseCode, responseMessage); return false; } catch (Exception ex) { LOG.warn("Failed to connect to host:{}", host, ex); return false; } }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: testEastEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 10);  TestSuiteChromosome exepcted_individual = population.get(8); TestSuiteChromosome returned_individual = neighbors.get(10);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: Throwable { DebuggerRegisterMapper rm = getRegisterMapperBase(); Register lRAX = getSLEIGH_X86_64_LANGUAGE().getRegister("RAX"); TestTargetRegister tRAX = Objects.requireNonNull(mb.testProcess1.regs.getCachedElements().get("RAX"));  Register lReg = waitForValue(() -> rm.targetToTrace(tRAX)); "<AssertPlaceHolder>"; }
targetToTrace(TargetRegister tReg) { Register lReg = languageRegs.get(normalizeName(tReg.getIndex())); if (lReg == null) { return null; } Register lbReg = lReg.getBaseRegister(); TreeSet<Register> subs = present.get(lbReg); if (subs == null) { return null; } if (lReg != subs.last()) { return null; } return lbReg; }
[*] target: assertEquals(lRAX, lReg)
[-] pred: org. junit. Assert. assertEquals ( lRAX, lReg )
************************************
************************************
[+] input: testTokenizeBrand() { Brand brand = new Brand(0,"Lorem","Lorem, ipsum. dolor, sit amet","ipsum","Lorem", new ArrayList<String>()); Set<String> expected = new HashSet<>(List.of("Lorem", "ipsum", "dolor", "sit", "amet")); String reg = "[,\\.]"; String del = " "; brandInfrastructure.setTokenizationParameters(del,reg); Set<String> actual = brandInfrastructure.tokenizeBrand(brand); "<AssertPlaceHolder>"; }
tokenizeBrand(Brand brand) { Set<String> tokens = new HashSet<>(); // run tokenizeString on all fields of the brand tokens.addAll(tokenizeString(brand.getName())); tokens.addAll(tokenizeString(brand.getDescription())); tokens.addAll(tokenizeString(brand.getFounded())); tokens.addAll(tokenizeString(brand.getHeadquarters())); for (String product : brand.getProducts()) { tokens.addAll(tokenizeString(product)); } return tokens; }
[*] target: assertEquals(expected,actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: ClassNotFoundException { Properties.DSE_SOLVER = Properties.SolverType.SMARTUT_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: Exception { List<Long> tablets1 = new ArrayList<>(); tablets1.add(1L); tablets1.add(2L); List<Long> tablets2 = new ArrayList<>(); tablets2.add(3L); tablets2.add(4L); Map<String, List<Long>> beToTablets = new HashMap<>(); beToTablets.put("be1", tablets1); beToTablets.put("be2", tablets2);  Settings settings = new PropertiesSettings(); String opaquedQueryPlan = "query_plan"; String cluster = "c"; String database = "d"; String table = "t";  Set<Long> be1Tablet1 = new HashSet<>(); be1Tablet1.add(1L); PartitionDefinition pd1 = new PartitionDefinition( database, table, settings, "be1", be1Tablet1, opaquedQueryPlan);  Set<Long> be1Tablet2 = new HashSet<>(); be1Tablet2.add(2L); PartitionDefinition pd2 = new PartitionDefinition( database, table, settings, "be1", be1Tablet2, opaquedQueryPlan);  Set<Long> be2Tablet1 = new HashSet<>(); be2Tablet1.add(3L); PartitionDefinition pd3 = new PartitionDefinition( database, table, settings, "be2", be2Tablet1, opaquedQueryPlan);  Set<Long> be2Tablet2 = new HashSet<>(); be2Tablet2.add(4L); PartitionDefinition pd4 = new PartitionDefinition( database, table, settings, "be2", be2Tablet2, opaquedQueryPlan);   List<PartitionDefinition> expected = new ArrayList<>(); expected.add(pd1); expected.add(pd2); expected.add(pd3); expected.add(pd4); Collections.sort(expected);  List<PartitionDefinition> actual = RestService.tabletsMapToPartition( settings, beToTablets, opaquedQueryPlan, database, table, logger); Collections.sort(actual);  Assert."<AssertPlaceHolder>"; }
tabletsMapToPartition(Settings cfg, Map<String, List<Long>> be2Tablets, String opaquedQueryPlan, String database, String table, Logger logger) throws IllegalArgumentException { int tabletsSize = tabletCountLimitForOnePartition(cfg, logger); List<PartitionDefinition> partitions = new ArrayList<>(); for (Map.Entry<String, List<Long>> beInfo : be2Tablets.entrySet()) { logger.debug("Generate partition with beInfo: '{}'.", beInfo); HashSet<Long> tabletSet = new HashSet<>(beInfo.getValue()); beInfo.getValue().clear(); beInfo.getValue().addAll(tabletSet); int first = 0; while (first < beInfo.getValue().size()) { Set<Long> partitionTablets = new HashSet<>(beInfo.getValue().subList( first, Math.min(beInfo.getValue().size(), first + tabletsSize))); first = first + tabletsSize; PartitionDefinition partitionDefinition = new PartitionDefinition(database, table, cfg, beInfo.getKey(), partitionTablets, opaquedQueryPlan); logger.debug("Generate one PartitionDefinition '{}'.", partitionDefinition); partitions.add(partitionDefinition); } } return partitions; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testLocallyFrequentItemsBasic() { List<SequenceItem> prefixSequence = new ArrayList<SequenceItem>(); prefixSequence.add(new SequenceItem("A", 0)); prefixSequence.add(new SequenceItem("A", 1)); ProjectedDatabase projDatabase = new ProjectedDatabase(database, prefixSequence); Set<FrequentSequenceItem> globallyFrequent = database.getGloballyFrequentItems(4); Set<FrequentSequenceItem> locallyFrequent = projDatabase.getLocallyFrequentItems(globallyFrequent, 4); "<AssertPlaceHolder>"; assertTrue(locallyFrequent.contains(new FrequentSequenceItem(4, new SequenceItem("B", 3)))); assertTrue(locallyFrequent.contains(new FrequentSequenceItem(4, new SequenceItem("A", 2)))); }
getLocallyFrequentItems(Set<FrequentSequenceItem> globallyFrequentItems, int minSupport) { Map<SequenceItem, Integer> frequentItemBag = new HashMap<SequenceItem, Integer>(); for (ProjectedSequenceInfo currentProjSeq : projectedInfo) { for (FrequentSequenceItem globFreqItem : globallyFrequentItems) { SequenceItem globalItem = globFreqItem.getItem(); int index = globalItem.getIndex(); if (index < currentProjSeq.getProjectedIndex()) { continue;//the globally frequent item is in a position in the prefix, no need to check } Sequence fullSequence = database.getSequences().get(currentProjSeq.getSequenceIndex()); String symbol = fullSequence.getSequenceAsString().substring(index, index + 1);  if (!symbol.equals(globalItem.getSymbol())) { continue;//symbols are different, check next item }  Integer count = frequentItemBag.get(globalItem); if (count == null) { frequentItemBag.put(globalItem, new Integer(fullSequence.getCount())); } else { frequentItemBag.put(globalItem, count + fullSequence.getCount()); } } }  TreeSet<FrequentSequenceItem> frequentItemSet = new TreeSet<FrequentSequenceItem>(); for (Entry<SequenceItem, Integer> itemAndCount : frequentItemBag.entrySet()) { int count = itemAndCount.getValue(); if (count >= minSupport) { frequentItemSet.add(new FrequentSequenceItem(count, itemAndCount.getKey())); } } return frequentItemSet; }
[*] target: assertEquals(2, locallyFrequent.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locallyFrequent. size ( ) )
************************************
************************************
[+] input: testGetDataType_ByName() {  String name = "string"; String dtmId = "3295333330922457057"; FakeDataTypeManager manager = new FakeDataTypeManager(dtmId); FakeDataType dt = new FakeDataType(name, manager);  String dtId = ""; // no id; name only String urlString = "datatype:/" + dtmId + "?uid=" + dtId + "&name=" + name; DataTypeUrl dtUrl = new DataTypeUrl(urlString);  DataTypeManagerService service = new FakeDataTypeManagerService(manager); DataType actualDt = dtUrl.getDataType(service); "<AssertPlaceHolder>"; }
getDataType(DataTypeManagerService service) {  DataTypeManager manager = findManager(service); if (manager == null) { return null; }  if (dataTypeId == null) { // The ID will be null for built-in types.  In that case, the name will not be // null.  Further, built-in types live at the root, so we can just ask for the // type by name. return manager.getDataType(new DataTypePath(CategoryPath.ROOT, dataTypeName)); }  DataType dt = manager.findDataTypeForID(dataTypeId); return dt; }
[*] target: assertEquals(dt, actualDt)
[-] pred: org. junit. Assert. assertEquals ( dt, actualDt )
************************************
************************************
[+] input: testSplitWithMaxNewlineAtBeginningAndEndOnly() { // newlines at begin and end do not create lines; no whitespace--max is below // MAX_WORD_LENGTH, so single line only List<String> lines = HtmlLineSplitter.split("\nabcdefghi\n", 4); "<AssertPlaceHolder>"; assertEquals("", lines.get(0)); assertEquals("abcdefghi", lines.get(1)); assertEquals("", lines.get(2)); }
split(String text, int maxLineLength) { return split(text, maxLineLength, false); }
[*] target: assertEquals(3, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 3, lines. size ( ) )
************************************
************************************
[+] input: remove_canRemoveValues() { IntIntMap map = new IntIntMap(); Assert.assertEquals(IntIntMap.NO_VALUE, map.remove(0)); map.put(1234, 5678); Assert.assertEquals(5678, map.remove(1234)); Assert."<AssertPlaceHolder>"; }
isEmpty() { return size == 0; }
[*] target: assertTrue(map.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( map. isEmpty() )
************************************
************************************
[+] input: Exception { DorisCopyCommittable expectCommittable = new DorisCopyCommittable( "fe:8040", "COPY INTO db.table FROM @u FILES=('label_0_1') FILE_FORMAT=('type'='csv','line_delimiter'='\n','column_separator'=',')"); CopyCommittableSerializer serializer = new CopyCommittableSerializer(); DorisCopyCommittable committable = serializer.deserialize(1, serializer.serialize(expectCommittable)); Assert."<AssertPlaceHolder>"; }
serialize(DorisCopyCommittable copyCommittable) throws IOException { try (final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final DataOutputStream out = new DataOutputStream(baos)) { out.writeUTF(copyCommittable.getHostPort());  // writeUTF has a length limit, but the copysql is sometimes very long final byte[] copySqlBytes = copyCommittable.getCopySQL().getBytes(StandardCharsets.UTF_8); out.writeInt(copySqlBytes.length); out.write(copySqlBytes); out.flush(); return baos.toByteArray(); } }
[*] target: assertEquals(expectCommittable, committable)
[-] pred: org. junit. Assert. assertEquals ( expectCommittable, committable )
************************************
************************************
[+] input: ProtocolException { BAOStreamBuilder builder = new BAOStreamBuilder(); builder.addByte(PROTOCOL_UNKNOWN); ByteArrayInputStream istream = builder.getStream(); MockConnection connection = new MockConnection(istream); Proto proto = ProtocolSelector.getProto(connection, null, null); "<AssertPlaceHolder>"; }
getProto( ServerConnection connection, AndroidUtils utils, StatusNotifier notifier) throws ProtocolException { if (connection == null) { return null; } byte[] proto_v = {PROTO_MAX}; if (connection.send(proto_v)) { return null; } if (connection.receive(proto_v)) { return null; } int selectedProto = PROTO_MAX; if (proto_v[0] == ProtocolSelector.PROTOCOL_OBSOLETE) { throw new ProtocolException("Obsolete client"); } else if (proto_v[0] == ProtocolSelector.PROTOCOL_UNKNOWN) { byte[] serverProto = new byte[1]; if (connection.receive(serverProto)) { return null; } byte serverMaxProto = serverProto[0]; if (serverMaxProto < PROTO_MIN) { serverProto[0] = 0; connection.send(serverProto); throw new ProtocolException("Obsolete server"); } if (acceptProto(connection, serverMaxProto)) { return null; } selectedProto = serverMaxProto; } else if (proto_v[0] != ProtocolSelector.PROTOCOL_SUPPORTED) { return null; } switch (selectedProto) { case 1: return new Proto_v1(connection, utils, notifier); case 2: return new Proto_v2(connection, utils, notifier); case 3: return new Proto_v3(connection, utils, notifier); default: throw new ProtocolException("Unknown protocol"); } }
[*] target: assertNull(proto)
[-] pred: org. junit. Assert. assertNull ( proto )
************************************
************************************
[+] input: getTransitionShouldReturnNullWhenThisStateHasNoTransitions() { ByteTransition transition = state.getTransition((byte) 'a'); "<AssertPlaceHolder>"; }
getTransition(byte utf8byte) { // Saving the value to avoid reading an updated value Object transitionStore = this.transitionStore; if (transitionStore == null) { return null; } else if (transitionStore instanceof SingleByteTransitionEntry) { SingleByteTransitionEntry entry = (SingleByteTransitionEntry) transitionStore; return utf8byte == entry.utf8byte ? entry.transition : null; } ByteMap map = (ByteMap) transitionStore; return map.getTransition(utf8byte); }
[*] target: assertNull(transition)
[-] pred: org. junit. Assert. assertNull ( transition )
************************************
************************************
[+] input: JsonProcessingException { ServerNamingAbility expected = new ServerNamingAbility(); expected.setSupportJraft(true); String serializeJson = jacksonMapper.writeValueAsString(expected); ServerNamingAbility actual = jacksonMapper.readValue(serializeJson, ServerNamingAbility.class); assertEquals(expected, actual); actual = new ServerNamingAbility(); assertNotEquals(expected, actual); actual.setSupportJraft(true); "<AssertPlaceHolder>"; }
setSupportJraft(boolean supportJraft) { this.supportJraft = supportJraft; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testSouthWestNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.compactNine(population, 5);  TestSuiteChromosome exepcted_individual = population.get(8); TestSuiteChromosome returned_individual = neighbors.get(5);  "<AssertPlaceHolder>"; }
compactNine(List<T> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: addPassenger() { // init Passenger expectedPassenger = new Passenger(1, "Passenger1", "Lastname1", "Male", 25, "05554443322", "passenger1@mail.com");  // stub - when when(passengerRepository.save(expectedPassenger)).thenReturn(expectedPassenger);  // then passengerService.addPassenger(expectedPassenger); //        Passenger byId = passengerRepository.getById(1); // //        Assert."<AssertPlaceHolder>";  verify(passengerRepository, times(1)).save(expectedPassenger); }
addPassenger(Passenger passenger) { passengerRepository.save(passenger); log.info("Passenger sent to Producer Queue : {}", passenger); PassengerProducer.addToQueue(passenger); }
[*] target: assertEquals(expectedPassenger, byId)
[-] pred: org. junit. Assert. assertEquals ( expectedPassenger, byId )
************************************
************************************
[+] input: testRuntimeTypeDiscovery_MixedHierarchy_AbstractClassAndInterfaceBothDefineValues() {  // // Test to make sure that we get not only a directly hierarchy, but the lateral one // as well, where we pursue interfaces that may have defined some types. //  List<Class<?>> types = ReflectionUtilities.getTypeArguments(RuntimeBaseInterface.class, ChildExtendingPartiallyDefinedTypes.class); "<AssertPlaceHolder>"; assertEquals(String.class, types.get(0)); assertEquals(Double.class, types.get(1)); }
getTypeArguments(Class<T> baseClass, Class<? extends T> childClass) {  Objects.requireNonNull(baseClass); Objects.requireNonNull(childClass);  Map<Type, Type> resolvedTypesDictionary = new HashMap<>(); Type baseClassAsType = walkClassHierarchyAndResolveTypes(baseClass, resolvedTypesDictionary, childClass);  // try to resolve type arguments defined by 'baseClass' to the raw runtime class Type[] baseClassDeclaredTypeArguments = getDeclaredTypeArguments(baseClassAsType); return resolveBaseClassTypeArguments(resolvedTypesDictionary, baseClassDeclaredTypeArguments); }
[*] target: assertEquals(2, types.size())
[-] pred: org. junit. Assert. assertEquals ( 2, types. size ( ) )
************************************
************************************
[+] input: testNotedNotRemovedAfterActive() { mController.addCallback(new int[]{AppOpsManager.OP_FINE_LOCATION}, mCallback);  mController.onOpNoted(AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, AppOpsManager.MODE_ALLOWED);  mController.onOpActiveChanged( AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, true);  mTestableLooper.processAllMessages(); List<AppOpItem> list = mController.getActiveAppOps(); verify(mCallback).onActiveStateChanged( AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, true);  // Duplicates are not removed between active and noted assertEquals(2, list.size());  mController.onOpActiveChanged( AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, false);  mTestableLooper.processAllMessages();  verify(mCallback, never()).onActiveStateChanged( AppOpsManager.OP_FINE_LOCATION, TEST_UID, TEST_PACKAGE_NAME, false); list = mController.getActiveAppOps(); "<AssertPlaceHolder>"; }
getActiveAppOps();
[*] target: assertEquals(1, list.size())
[-] pred: org. junit. Assert. assertEquals ( 1, list. size ( ) )
************************************
************************************
[+] input: Exception {  List<Map<String, Object>> tTypeList = new ArrayList<>(); Map<String, Object> tTypeMap = new HashMap<>(); tTypeMap.put("name", "aws-all"); tTypeList.add(tTypeMap);  when(service.getAllAssetGroups()).thenReturn(tTypeList);  new Util().setassetService(service); boolean valid = Util.isValidAssetGroup("aws-all");  "<AssertPlaceHolder>";  }
isValidAssetGroup(String ag) { List<Map<String, Object>> agList = assetService.getAllAssetGroups(); return agList.stream().filter(obj -> ag.equals(obj.get("name"))).count() > 0 ? true : false; }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: Exception {  String typeName = "templated_name<int, void*, custom_type>"; StructureDataType structure = new StructureDataType(typeName, 0);  tx(program, () -> { programDTM.resolve(structure, null); });  DataTypeParser parser = new DataTypeParser(dtmService, AllowedDataTypes.ALL); DataType dt = parser.parse(typeName); "<AssertPlaceHolder>"; assertTrue(dt.isEquivalent(structure)); }
parse(String dataTypeString) throws InvalidDataTypeException, CancelledException { return parse(dataTypeString, (CategoryPath) null); }
[*] target: assertNotNull(dt)
[-] pred: org. junit. Assert. assertNotNull ( dt )
************************************
************************************
[+] input: span_combinesDisjointInterval() { // Arrange ZonedInterval earliestInterval = new ZonedInterval(SEVEN_DAYS_AGO, FIVE_DAYS_AGO); ZonedInterval latestInterval = new ZonedInterval(THREE_DAYS_AGO, ONE_DAY_AGO); ZonedInterval expectedInterval = new ZonedInterval(SEVEN_DAYS_AGO, ONE_DAY_AGO);  // Act ZonedInterval resultingInterval = earliestInterval.span(latestInterval);  // Assert "<AssertPlaceHolder>"; }
span(@Nonnull ZonedInterval interval) { ZonedDateTime startTime = ObjectUtils.min(interval.getStart(), this.getStart()); ZonedDateTime endTime = ObjectUtils.max(interval.getEndExclusive(), this.getEndExclusive()); return new ZonedInterval(startTime, endTime); }
[*] target: assertEquals(expectedInterval, resultingInterval)
[-] pred: org. junit. Assert. assertEquals ( expectedInterval, resultingInterval )
************************************
************************************
[+] input: testSouthNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.linearFive(population, 5);  TestSuiteChromosome exepcted_individual = population.get(9); TestSuiteChromosome returned_individual = neighbors.get(1);  "<AssertPlaceHolder>"; }
linearFive(List<T> collection, int position) { _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: Exception { ProgramModule root = treeManager.createRootModule("Test-One"); ProgramModule r2 = treeManager.createRootModule("Test-Two");  addBlock("TestBlock", 0x5000, 100); MemoryBlock b2 = addBlock("TestTwoBlock", 0x6000, 200); addBlock("TestThreeBlock", 0x6500, 100);  int r1FragCount = root.getChildren().length; int r2FragCount = r2.getChildren().length; assertEquals(r1FragCount, r2FragCount); assertEquals(5, r1FragCount); Address startAddr = b2.getStart(); Address endAddr = b2.getEnd(); treeManager.deleteAddressRange(startAddr, endAddr, TaskMonitorAdapter.DUMMY_MONITOR); r1FragCount = root.getChildren().length; r2FragCount = r2.getChildren().length; "<AssertPlaceHolder>"; assertEquals(4, r1FragCount); }
deleteAddressRange(Address startAddr, Address endAddr, TaskMonitor monitor) throws CancelledException { lock.acquire(); try { Iterator<String> keys = treeMap.keySet().iterator(); while (keys.hasNext()) { if (monitor.isCancelled()) { throw new CancelledException(); } ModuleManager m = treeMap.get(keys.next()); m.removeMemoryBlock(startAddr, endAddr, monitor); } } catch (IOException e) { errHandler.dbError(e);  } finally { lock.release(); } }
[*] target: assertEquals(r1FragCount, r2FragCount)
[-] pred: org. junit. Assert. assertEquals ( r1FragCount, r2FragCount )
************************************
************************************
[+] input: shouldCountWorkflows() { int counts = 1100; for (int i = 0; i < counts; i++) { WorkflowSummary workflowSummary = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); indexDAO.indexWorkflow(workflowSummary); }  // wait for workflow to be indexed long result = tryGetCount(() -> getWorkflowCount("template_workflow", "RUNNING"), counts); "<AssertPlaceHolder>"; }
getWorkflowCount(String query, String freeText) { try { return getObjectCounts(query, freeText, WORKFLOW_DOC_TYPE); } catch (Exception e) { throw new NonTransientException(e.getMessage(), e); } }
[*] target: assertEquals(counts, result)
[-] pred: org. junit. Assert. assertEquals ( counts, result )
************************************
************************************
[+] input: Exception {  DockingAction copySpecialAction = getAction(codeBrowserClipboardProvider, COPY_SPECIAL_ACTION_NAME); waitForSwing(); assertFalse(copySpecialAction.isEnabled());  codeBrowserPlugin.goTo(new MnemonicFieldLocation(program, addr("1001050"))); assertTrue(copySpecialAction.isEnabled());  makeSelection(codeViewerWrapper); assertTrue(copySpecialAction.isEnabled());  copySpecial(codeViewerWrapper, copySpecialAction); String clipboardContents = getClipboardContents(); String expectedBytes = "f4 77 33 58 f4 77 91 45"; "<AssertPlaceHolder>"; }
copySpecial(ClipboardContentProviderService clipboardService, ClipboardType type) { Clipboard systemClipboard = getSystemClipboard(); Transferable transferable = clipboardService.copySpecial(type, TaskMonitor.DUMMY); if (transferable != null) { setClipboardContents(systemClipboard, transferable); updatePasteState(); } }
[*] target: assertEquals(expectedBytes, clipboardContents)
[-] pred: org. junit. Assert. assertEquals ( expectedBytes, clipboardContents )
************************************
************************************
[+] input: Exception { Enum enumm = new EnumDataType("Color", 1); enumm.add("Red", 10); enumm.add("Green", 15); enumm.add("Blue", 20);  Enum enummDT = (Enum) dataMgr.resolve(enumm, null); "<AssertPlaceHolder>";  long id = dataMgr.getResolvedID(enummDT);  assertEquals(enummDT, dataMgr.getDataType(id)); }
add(String name, long value);
[*] target: assertNotNull(enummDT)
[-] pred: org. junit. Assert. assertNotNull ( enummDT )
************************************
************************************
[+] input: testDumpSnapshot() { InputStream inputStream = serviceMetadataSnapshotOperation.dumpSnapshot();  Assert."<AssertPlaceHolder>"; }
dumpSnapshot() { Map<Service, ServiceMetadata> snapshot = metadataManager.getServiceMetadataSnapshot(); return new ByteArrayInputStream(serializer.serialize(snapshot)); }
[*] target: assertNotNull(inputStream)
[-] pred: org. junit. Assert. assertNotNull ( inputStream )
************************************
************************************
[+] input: Exception { List<Long> tablets1 = new ArrayList<>(); tablets1.add(1L); tablets1.add(2L); List<Long> tablets2 = new ArrayList<>(); tablets2.add(3L); tablets2.add(4L); Map<String, List<Long>> beToTablets = new HashMap<>(); beToTablets.put("be1", tablets1); beToTablets.put("be2", tablets2);  String opaquedQueryPlan = "query_plan"; String cluster = "c"; String database = "d"; String table = "t";  Set<Long> be1Tablet = new HashSet<>(); be1Tablet.add(1L); be1Tablet.add(2L); PartitionDefinition pd1 = new PartitionDefinition(database, table, "be1", be1Tablet, opaquedQueryPlan);  Set<Long> be2Tablet = new HashSet<>(); be2Tablet.add(3L); be2Tablet.add(4L); PartitionDefinition pd2 = new PartitionDefinition(database, table, "be2", be2Tablet, opaquedQueryPlan);  List<PartitionDefinition> expected = new ArrayList<>(); expected.add(pd1); expected.add(pd2); Collections.sort(expected); DorisOptions options = DorisOptions.builder().setFenodes("127.0.0.1:8030").build(); DorisReadOptions readOptions = DorisReadOptions.builder().setRequestTabletSize(2).build(); List<PartitionDefinition> actual = RestService.tabletsMapToPartition( options, readOptions, beToTablets, opaquedQueryPlan, database, table, logger); Collections.sort(actual);  Assert."<AssertPlaceHolder>"; }
tabletsMapToPartition( DorisOptions options, DorisReadOptions readOptions, Map<String, List<Long>> be2Tablets, String opaquedQueryPlan, String database, String table, Logger logger) throws IllegalArgumentException { int tabletsSize = tabletCountLimitForOnePartition(readOptions, logger); List<PartitionDefinition> partitions = new ArrayList<>(); for (Entry<String, List<Long>> beInfo : be2Tablets.entrySet()) { logger.debug("Generate partition with beInfo: '{}'.", beInfo); HashSet<Long> tabletSet = new HashSet<>(beInfo.getValue()); beInfo.getValue().clear(); beInfo.getValue().addAll(tabletSet); int first = 0; while (first < beInfo.getValue().size()) { Set<Long> partitionTablets = new HashSet<>( beInfo.getValue() .subList( first, Math.min( beInfo.getValue().size(), first + tabletsSize))); first = first + tabletsSize; PartitionDefinition partitionDefinition = new PartitionDefinition( database, table, beInfo.getKey(), partitionTablets, opaquedQueryPlan); logger.debug("Generate one PartitionDefinition '{}'.", partitionDefinition); partitions.add(partitionDefinition); } } return partitions; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());  JsonObject json = WycheproofTestUtil.readJson("../wycheproof/testvectors/aes_gcm_test.json"); int errors = 0; int cntSkippedTests = 0; JsonArray testGroups = json.get("testGroups").getAsJsonArray(); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); int keySize = group.get("keySize").getAsInt(); JsonArray tests = group.get("tests").getAsJsonArray(); if (!Arrays.asList(keySizeInBytes).contains(keySize / 8)) { cntSkippedTests += tests.size(); continue; } for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); String tcId = String.format("testcase %d (%s)", testcase.get("tcId").getAsInt(), testcase.get("comment").getAsString()); byte[] iv = Hex.decode(testcase.get("iv").getAsString()); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] msg = Hex.decode(testcase.get("msg").getAsString()); byte[] associatedData = Hex.decode(testcase.get("aad").getAsString()); @Nullable Integer androidApiLevel = Util.getAndroidApiLevel(); if (androidApiLevel != null && androidApiLevel <= 19 && associatedData.length != 0) { cntSkippedTests++; continue; } byte[] ct = Hex.decode(testcase.get("ct").getAsString()); byte[] tag = Hex.decode(testcase.get("tag").getAsString()); byte[] ciphertext = Bytes.concat(ct, tag); // Result is one of "valid", "invalid", "acceptable". // "valid" are test vectors with matching plaintext, ciphertext and tag. // "invalid" are test vectors with invalid parameters or invalid ciphertext and tag. // "acceptable" are test vectors with weak parameters or legacy formats. String result = testcase.get("result").getAsString(); // Tink only supports 12-byte iv. if (iv.length != 12) { result = "invalid"; }  try { InsecureNonceAesGcmJce gcm = new InsecureNonceAesGcmJce(key); // Encryption. byte[] encrypted = gcm.encrypt(iv, msg, associatedData); boolean ciphertextMatches = TestUtil.arrayEquals(encrypted, ciphertext); if (result.equals("valid") && !ciphertextMatches) { System.out.printf( "FAIL %s: incorrect encryption, result: %s, expected: %s%n", tcId, Hex.encode(encrypted), Hex.encode(ciphertext)); errors++; } // Decryption. byte[] decrypted = gcm.decrypt(iv, ciphertext, associatedData); boolean plaintextMatches = TestUtil.arrayEquals(decrypted, msg); if (result.equals("invalid")) { System.out.printf( "FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n", tcId, Hex.encode(msg), Hex.encode(decrypted)); errors++; } else { if (!plaintextMatches) { System.out.printf( "FAIL %s: incorrect decryption, result: %s, expected: %s%n", tcId, Hex.encode(decrypted), Hex.encode(msg)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("FAIL %s: cannot decrypt, exception %s%n", tcId, ex); errors++; } } } } System.out.printf("Number of tests skipped: %d", cntSkippedTests); "<AssertPlaceHolder>"; }
decrypt(final byte[] iv, final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException { return decrypt(iv, ciphertext, /* ciphertextOffset= */ 0, associatedData); }
[*] target: assertEquals(0, errors)
[-] pred: org. junit. Assert. assertEquals ( 0, errors )
************************************
************************************
[+] input: isAvailable_appScreen_notIfNoDeletedChannels() { when(mBackend.getDeletedChannelCount(any(), anyInt())).thenReturn(0); mController.onResume(new NotificationBackend.AppRow(), null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } // only visible on app screen if (mChannel != null || hasValidGroup()) { return false; }  return mBackend.getDeletedChannelCount(mAppRow.pkg, mAppRow.uid) > 0; }
[*] target: assertFalse(mController.isAvailable())
[-] pred: org. junit. Assert. assertFalse ( mController. isAvailable() )
************************************
************************************
[+] input: testGetNewAddressSpace() { AddressSpace space = trans12.getNewAddressSpace("ram"); "<AssertPlaceHolder>"; assertEquals("ram", space.getName()); }
getNewAddressSpace(String oldSpaceName) { if (spaceMap == null) { throw new IllegalStateException("Address space map has not been validated"); } return spaceMap.get(oldSpaceName); }
[*] target: assertNotNull(space)
[-] pred: org. junit. Assert. assertNotNull ( space )
************************************
************************************
[+] input: testGetPushData() { ServiceInfo pushData = serviceStorage.getPushData(SERVICE);  Mockito.verify(switchDomain).getDefaultPushCacheMillis(); Assert."<AssertPlaceHolder>"; }
getPushData(Service service) { ServiceInfo result = emptyServiceInfo(service); if (!ServiceManager.getInstance().containSingleton(service)) { return result; } result.setHosts(getAllInstancesFromIndex(service)); serviceDataIndexes.put(service, result); return result; }
[*] target: assertNotNull(pushData)
[-] pred: org. junit. Assert. assertNotNull ( pushData )
************************************
************************************
[+] input: testGetColor_StateActive_ReturnActiveColor() { final int color = mTileColorPicker.getColor(Tile.STATE_ACTIVE); final int expectedColor = mTintColorStateList.getColorForState( TileColorPicker.ENABLE_STATE_SET, DEFAULT_COLOR);  "<AssertPlaceHolder>"; }
getColor(int state) { final int defaultColor = 0;  switch (state) { case Tile.STATE_UNAVAILABLE: return mColorStateList.getColorForState(DISABLE_STATE_SET, defaultColor); case Tile.STATE_INACTIVE: return mColorStateList.getColorForState(INACTIVE_STATE_SET, defaultColor); case Tile.STATE_ACTIVE: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); default: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); } }
[*] target: assertEquals(expectedColor, color)
[-] pred: org. junit. Assert. assertEquals ( expectedColor, color )
************************************
************************************
[+] input: testEscapeString2() { String orig = "//"; String escaped = CategoryPath.escapeString(orig); String unescaped = CategoryPath.unescapeString(escaped); "<AssertPlaceHolder>"; assertEquals("\\/\\/", escaped); }
unescapeString(String escapedString) { return escapedString.replace(ESCAPED_DELIMITER_STRING, DELIMITER_STRING); }
[*] target: assertEquals(orig, unescaped)
[-] pred: org. junit. Assert. assertEquals ( orig, unescaped )
************************************
************************************
[+] input: testSelectInstances() { ServiceInfo serviceInfo = new ServiceInfo(); serviceInfo.setGroupName("groupName"); serviceInfo.setName("serviceName"); serviceInfo.setChecksum("checkSum"); serviceInfo.setAllIPs(false); ServiceInfo cluster = ServiceUtil.selectInstances(serviceInfo, "cluster"); "<AssertPlaceHolder>"; }
selectInstances(ServiceInfo serviceInfo, String cluster) { return selectInstances(serviceInfo, cluster, false, false); }
[*] target: assertNotNull(cluster)
[-] pred: org. junit. Assert. assertNotNull ( cluster )
************************************
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> a = new HttpRestResult<Object>(); a.setData("{"status":"UP"}"); a.setCode(200); when(nacosRestTemplate.exchangeForm(any(), any(), any(), any(), any(), any())).thenReturn(a);  SecurityProxy proxy = mock(SecurityProxy.class); ServerListManager mgr = mock(ServerListManager.class); when(mgr.getServerList()).thenReturn(Arrays.asList("localhost")); Properties props = new Properties(); ServiceInfoHolder holder = mock(ServiceInfoHolder.class); NamingHttpClientProxy clientProxy = new NamingHttpClientProxy("namespaceId", proxy, mgr, props, holder);  final Field nacosRestTemplateField = NamingHttpClientProxy.class.getDeclaredField("nacosRestTemplate"); nacosRestTemplateField.setAccessible(true); nacosRestTemplateField.set(clientProxy, nacosRestTemplate); String serviceName = "service1"; String groupName = "group1";  //when boolean serverHealthy = clientProxy.serverHealthy(); //then verify(nacosRestTemplate, times(1)) .exchangeForm(endsWith("/operator/metrics"), any(), any(), any(), eq(HttpMethod.GET), any()); Assert."<AssertPlaceHolder>"; }
serverHealthy() {  try { String result = reqApi(UtilAndComs.nacosUrlBase + "/operator/metrics", new HashMap<String, String>(8), HttpMethod.GET); JsonNode json = JacksonUtils.toObj(result); String serverStatus = json.get("status").asText(); return "UP".equals(serverStatus); } catch (Exception e) { return false; } }
[*] target: assertTrue(serverHealthy)
[-] pred: org. junit. Assert. assertTrue ( serverHealthy )
************************************
************************************
[+] input: span_combinesSubsetInterval() { // Arrange ZonedInterval earliestInterval = new ZonedInterval(SEVEN_DAYS_AGO, ONE_DAY_AGO); ZonedInterval latestInterval = new ZonedInterval(FIVE_DAYS_AGO, THREE_DAYS_AGO); ZonedInterval expectedInterval = new ZonedInterval(SEVEN_DAYS_AGO, ONE_DAY_AGO);  // Act ZonedInterval resultingInterval = earliestInterval.span(latestInterval);  // Assert "<AssertPlaceHolder>"; }
span(@Nonnull ZonedInterval interval) { ZonedDateTime startTime = ObjectUtils.min(interval.getStart(), this.getStart()); ZonedDateTime endTime = ObjectUtils.max(interval.getEndExclusive(), this.getEndExclusive()); return new ZonedInterval(startTime, endTime); }
[*] target: assertEquals(expectedInterval, resultingInterval)
[-] pred: org. junit. Assert. assertEquals ( expectedInterval, resultingInterval )
************************************
************************************
[+] input: givenCachedClassloader_whenLookup_thenDescriptorReturned() { final ClassLoader classLoader = getClass().getClassLoader(); final ClassLoaderStore classLoaderStore = new ClassLoaderStore(); final ClassLoaderDescriptor classLoaderDescriptor = classLoaderStore.store(classLoader);  final ClassLoader lookedUpClassLoader = classLoaderStore.lookup(classLoaderDescriptor);  Assert."<AssertPlaceHolder>"; }
lookup(ClassLoaderDescriptor classLoaderDescriptor) { if (classLoaderDescriptor == null) { // Bootstrap classloader return null; } final WeakReference<ClassLoader> classLoaderRef = classLoaders.get(classLoaderDescriptor); if (classLoaderRef == null) { return null; } final ClassLoader classLoader = classLoaderRef.get(); if (classLoader == null) { classLoaders.remove(classLoaderDescriptor); return null; } return classLoader; }
[*] target: assertEquals(classLoader, lookedUpClassLoader)
[-] pred: org. junit. Assert. assertEquals ( classLoader, lookedUpClassLoader )
************************************
************************************
[+] input: testStackAddressNegative() { AddressSpace stackSpace = p.getAddressFactory().getStackSpace(); Address a = stackSpace.getAddress(-1); long key = addrMap.getKey(a, false); assertEquals(0x40000000ffffffffl, key); Address b = addrMap.decodeAddress(key); "<AssertPlaceHolder>";  }
decodeAddress(long value) { return decodeAddress(value, true); }
[*] target: assertEquals(a, b)
[-] pred: org. junit. Assert. assertEquals ( a, b )
************************************
************************************
[+] input: testExtractCommentValueEmpty() { List<String> columnSpecs = Arrays.asList("default", null, "comment"); String actualComment = schemaManager.extractComment(columnSpecs); Assert."<AssertPlaceHolder>"; }
extractComment(List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } return extractAdjacentString(columnSpecs, COMMENT); }
[*] target: assertNull(actualComment)
[-] pred: org. junit. Assert. assertNull ( actualComment )
************************************
************************************
[+] input: testRingTopology_rightNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.ringTopology(population, 2);  TestSuiteChromosome exepcted_individual = population.get(3); TestSuiteChromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<T> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add(collection.get(_L)); chromosomes.add(collection.get(position)); chromosomes.add(collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testCreateAndFindParams() { OAuth2Info oAuth2Info = createDefaultOAuth2Info(); oAuth2Service.saveOAuth2Info(oAuth2Info); OAuth2Info foundOAuth2Info = oAuth2Service.findOAuth2Info(); Assert."<AssertPlaceHolder>"; // TODO ask if it's safe to check equality on AdditionalProperties Assert.assertEquals(oAuth2Info, foundOAuth2Info); }
findOAuth2Info();
[*] target: assertNotNull(foundOAuth2Info)
[-] pred: org. junit. Assert. assertNotNull ( foundOAuth2Info )
************************************
************************************
[+] input: testIsAvailable_notIfNull() { mController.onResume(null, null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } return mConversationInfo != null; }
[*] target: assertFalse(mController.isAvailable())
[-] pred: org. junit. Assert. assertFalse ( mController. isAvailable() )
************************************
************************************
[+] input: NetException { String mac = NetUtils.getLocalMac(); "<AssertPlaceHolder>"; log.info(mac); }
getLocalMac() throws NetException { try { // 通过InetAddress的方式 return getLocalMacByInetAddress(); } catch (Exception e) { try { // 通过 Oshi 的方式 return getLocalMacByOshi(); } catch (Exception e1) { try { // 通过 Sigar 的方式 return getLocalMacBySigar(); } catch (SigarException ex) { log.error("获取本机MAC地址异常：{}", e.getMessage()); throw new NetException(ex.getMessage()); } } } }
[*] target: assertNotNull(mac)
[-] pred: org. junit. Assert. assertNotNull ( mac )
************************************
************************************
[+] input: multiValuesAndNoneOrMoreWhitespace() { String nativeSql = "INSERT INTO ? USING traces TAGS (?, ?) VALUES (?, ?, ?, ?, ?, ?, ?)  (?, ?, ?, ?, ?, ?, ?)"; Object[] parameters = Stream.of("t1", "t1", "t2", 1632968284000L, 111.111, 119.001, 0.4, 90, 99.1, "WGS84", 1632968285000L, 111.21109999999999, 120.001, 0.5, 91, 99.19999999999999, "WGS84").toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO t1 USING traces TAGS ('t1', 't2') VALUES (1632968284000, 111.111, 119.001, 0.4, 90, 99.1, 'WGS84')  (1632968285000, 111.21109999999999, 120.001, 0.5, 91, 99.19999999999999, 'WGS84')"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testLoadX509FromStringWithProv() { X509Certificate certificate = PemUtil.loadX509FromString(MERCHANT_CERTIFICATE_STRING, "SUN"); Assert."<AssertPlaceHolder>"; }
loadX509FromString(String certificateString, String provider) { try (ByteArrayInputStream inputStream = new ByteArrayInputStream(certificateString.getBytes(StandardCharsets.UTF_8))) { return loadX509FromStream(inputStream, provider); } catch (IOException e) { throw new UncheckedIOException(e); } }
[*] target: assertNotNull(certificate)
[-] pred: org. junit. Assert. assertNotNull ( certificate )
************************************
************************************
[+] input: testBogusLocation() { SymbolServer symbolServer = symbolServerInstanceCreatorRegistry.newSymbolServer("blah://", symbolServerInstanceCreatorContext); "<AssertPlaceHolder>"; }
newSymbolServer(String symbolServerLocationString, SymbolServerInstanceCreatorContext symbolServerInstanceCreatorContext) { return newSymbolServer(symbolServerLocationString, symbolServerInstanceCreatorContext, SymbolServer.class); }
[*] target: assertNull(symbolServer)
[-] pred: org. junit. Assert. assertNull ( symbolServer )
************************************
************************************
[+] input: testWestWestNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 5);  TestSuiteChromosome exepcted_individual = population.get(7); TestSuiteChromosome returned_individual = neighbors.get(11);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: oneByte() { for (int i = 0; i <= 255; i++) { String expected = String.format("%02x", i);  StringBuilder sb = new StringBuilder(); Hex.toHex(ByteString.copyFrom(new byte[] { (byte) i }), sb); Assert."<AssertPlaceHolder>"; } }
toHex(ByteString bytes, StringBuilder sb) { sb.ensureCapacity(bytes.size()); for (int i = 0; i < bytes.size(); i++) { byte b = bytes.byteAt(i); sb.append(HEX_DIGITS[(b & 0xf0) >>> 4]); sb.append(HEX_DIGITS[b & 0x0f]); } }
[*] target: assertEquals(expected, sb.toString())
[-] pred: org. junit. Assert. assertEquals ( expected, sb. toString ( ) )
************************************
************************************
[+] input: whenResolve_withSubmodel_success() { Environment environment = AASFull.createEnvironment(); Reference submodelRef = AASFull.AAS_1.getSubmodels().get(0); Submodel expected = AASFull.SUBMODEL_3; Referable asReferable = AasUtils.resolve(submodelRef, environment); assertEquals(expected, asReferable); Submodel asSubmodel = AasUtils.resolve(submodelRef, environment, Submodel.class); "<AssertPlaceHolder>"; }
resolve(Reference reference, Environment env, Class<T> type) { if (reference == null || reference.getKeys() == null || reference.getKeys().isEmpty()) { return null; } GetChildrenVisitor findChildrenVisitor = new GetChildrenVisitor(env); findChildrenVisitor.visit(env); Referable current = null; for (int i = 0; i < reference.getKeys().size(); i++) { Key key = reference.getKeys().get(i); try { int index = Integer.parseInt(key.getValue()); if (Objects.isNull(current) || !SubmodelElementList.class.isAssignableFrom(current.getClass())) { throw new IllegalArgumentException("reference uses index notation on an element that is not a SubmodelElementList"); } List<SubmodelElement> list = ((SubmodelElementList) current).getValue(); if (list.size() <= index) { throw new IllegalArgumentException(String.format( "index notation out of bounds (list size: %s, requested index: %s)", list.size(), index)); } current = list.get(index); } catch (NumberFormatException e) { current = findChildrenVisitor.getChildren().stream() .filter(x -> Objects.equals(key.getValue(), GetIdentifierVisitor.getIdentifier(x))) .findFirst() .orElseThrow(() -> new IllegalArgumentException(String.format( "unable to resolve reference '%s' as element '%s' does not exist", asString(reference), key.getValue()))); } findChildrenVisitor.reset(); findChildrenVisitor.visit(current); } if (current == null) { return null; } if (!type.isAssignableFrom(current.getClass())) { throw new IllegalArgumentException(String.format( "reference '%s' could not be resolved as target type is not assignable from actual type (target: %s, actual: %s)", asString(reference), type.getName(), current.getClass().getName())); } return type.cast(current); }
[*] target: assertEquals(expected, asSubmodel)
[-] pred: org. junit. Assert. assertEquals ( expected, asSubmodel )
************************************
************************************
[+] input: NacosException { String dataId = "1"; String group = "2"; String content = "123"; String namespace = ""; String casMd5 = "96147704e3cb8be8597d55d75d244a02"; String type = ConfigType.getDefaultType().getType();  Mockito.when(mockWoker.publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type)) .thenReturn(true);  final boolean b = nacosConfigService.publishConfigCas(dataId, group, content, casMd5); Assert."<AssertPlaceHolder>";  Mockito.verify(mockWoker, Mockito.times(1)) .publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type); }
publishConfigCas(String dataId, String group, String content, String casMd5) throws NacosException { return publishConfigInner(namespace, dataId, group, null, null, null, content, ConfigType.getDefaultType().getType(), casMd5); }
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
************************************
************************************
[+] input: Exception {  // // Attempt to resolve a pointer to an existing type when that pointer does not already // exist. //  String typeName = "templated_name<int, void*, custom_type>"; StructureDataType structure = new StructureDataType(typeName, 0); PointerDataType pointer = new PointerDataType(structure); String pointerName = pointer.getName();  tx(program, () -> { programDTM.resolve(structure, null); });  DataTypeParser parser = new DataTypeParser(dtmService, AllowedDataTypes.ALL); DataType dt = parser.parse(pointerName); "<AssertPlaceHolder>"; assertTrue(dt.isEquivalent(pointer)); }
parse(String dataTypeString) throws InvalidDataTypeException, CancelledException { return parse(dataTypeString, (CategoryPath) null); }
[*] target: assertNotNull(dt)
[-] pred: org. junit. Assert. assertNotNull ( dt )
************************************
************************************
[+] input: testFindByActivateToken() { UserCredentials foundedUserCredentials = userCredentialsDao.findByActivateToken(SYSTEM_TENANT_ID, ACTIVATE_TOKEN); "<AssertPlaceHolder>"; assertEquals(neededUserCredentials.getId(), foundedUserCredentials.getId()); }
findByActivateToken(TenantId tenantId, String activateToken) { return DaoUtil.getData(userCredentialsRepository.findByActivateToken(activateToken)); }
[*] target: assertNotNull(foundedUserCredentials)
[-] pred: org. junit. Assert. assertNotNull ( foundedUserCredentials )
************************************
************************************
[+] input: testNorthEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.compactNine(population, 5);  TestSuiteChromosome exepcted_individual = population.get(2); TestSuiteChromosome returned_individual = neighbors.get(6);  "<AssertPlaceHolder>"; }
compactNine(List<T> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testExtractCommentValueQuotes() { String expectComment = "comment_test"; List<String> columnSpecs = Arrays.asList("Default", ""100"", "comment", ""comment_test""); String actualComment = schemaManager.extractComment(columnSpecs); Assert."<AssertPlaceHolder>"; }
extractComment(List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } return extractAdjacentString(columnSpecs, COMMENT); }
[*] target: assertEquals(expectComment, actualComment)
[-] pred: org. junit. Assert. assertEquals ( expectComment, actualComment )
************************************
************************************
[+] input: Exception { createLabel(addr(100), "primary"); createLabel(addr(100), "fred"); createLabel(addr(100), "joe"); Symbol s = st.getPrimarySymbol(addr(100)); "<AssertPlaceHolder>"; assertEquals("primary", s.getName()); }
getPrimarySymbol(Address addr) { if (!addr.isMemoryAddress() && !addr.isExternalAddress()) { return null; } if (addr.isExternalAddress()) { Symbol[] symbols = getSymbols(addr); return symbols.length > 0 ? symbols[0] : null; }  lock.acquire(); try { DBRecord record = adapter.getPrimarySymbol(addr); if (record != null) { return getSymbol(record); } if (addr.isMemoryAddress() && refManager.hasReferencesTo(addr)) { return getDynamicSymbol(addr); } } catch (IOException e) { program.dbError(e); } finally { lock.release(); } return null; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: testGetRemoteExecutorQueueSize() { int defaultExpectVal = 1 << 14; int defaultVal = RemoteUtils.getRemoteExecutorQueueSize(); Assert.assertEquals(defaultExpectVal, defaultVal);  System.setProperty("remote.executor.queue.size", "10"); int val1 = RemoteUtils.getRemoteExecutorQueueSize(); Assert.assertEquals(10, val1);  System.setProperty("remote.executor.queue.size", "-1"); int val2 = RemoteUtils.getRemoteExecutorQueueSize(); Assert."<AssertPlaceHolder>"; }
getRemoteExecutorQueueSize() { String queueSizeString = System.getProperty("remote.executor.queue.size"); if (NumberUtils.isDigits(queueSizeString)) { int size = Integer.parseInt(queueSizeString); return size > 0 ? size : REMOTE_EXECUTOR_QUEUE_SIZE; } else { return REMOTE_EXECUTOR_QUEUE_SIZE; } }
[*] target: assertEquals(defaultExpectVal, val2)
[-] pred: org. junit. Assert. assertEquals ( defaultExpectVal, val2 )
************************************
************************************
[+] input: multiValuesAndWhitespace() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,?,?)  (?,?,?,?) (?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 100, 3.14, "abc", 4, 200, 3.1415, "xyz", 5, 300, 3.141592, "uvw", 6).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (100,3.14,'abc',4)  (200,3.1415,'xyz',5) (300,3.141592,'uvw',6)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: DWARFExpressionException {  int count = 200; for (int i = 0; i < count; i++) { evaluator.push(i * 3); } for (int i = 0; i < count; i++) { long expected = (count - i - 1) * 3; evaluator.evaluate(new byte[] { DW_OP_pick, (byte) i }); long result = evaluator.pop(); "<AssertPlaceHolder>"; }  }
pop() throws DWARFExpressionException { if (stack.isEmpty()) { throw new DWARFExpressionException("DWARF expression stack empty"); } return stack.pop().longValue(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: sharedInfo_withDebugModeEnabled() { SharedInfo.Builder sharedInfoBuilder = SharedInfo.builder() .setVersion(VERSION_0_1) .setApi(ATTRIBUTION_REPORTING_API) .setScheduledReportTime(FIXED_TIME) .setReportingOrigin(REPORTING_ORIGIN) .setDestination(DESTINATION) .setSourceRegistrationTime(FIXED_TIME) .setReportId(RANDOM_UUID) .setReportDebugMode(true);  SharedInfo si = sharedInfoBuilder.build();  assertEquals(si.reportDebugModeString().get(), "enabled"); "<AssertPlaceHolder>"; }
getReportDebugMode() { return reportDebugModeString().isPresent() && reportDebugModeString().get().equals("enabled"); }
[*] target: assertTrue(si.getReportDebugMode())
[-] pred: org. junit. Assert. assertTrue ( si. getReportDebugMode ( ) )
************************************
************************************
[+] input: testUpdateRandomly() { final int COUNT = 100; Random rand = new Random(); ValueSortedMap<String, Integer> queue = TreeValueSortedMap.createWithNaturalOrder(); for (int i = 0; i < COUNT; i++) { queue.put("Element" + i, rand.nextInt(50)); } checkConsistent(queue);  for (int i = 0; i < COUNT; i++) { String e = "Element" + rand.nextInt(queue.size()); int oldCost = queue.get(e); int retCost = queue.put(e, rand.nextInt(50)); "<AssertPlaceHolder>"; checkConsistent(queue); } }
put(K key, V value) { Node n = nodeMap.get(key); if (n != null) { return n.setValue(value); } n = createNode(key, value); nodeMap.put(key, n); if (root == null) { root = n; head = n; tail = n; } else { root.insert(n); } return null; }
[*] target: assertEquals(oldCost, retCost)
[-] pred: org. junit. Assert. assertEquals ( oldCost, retCost )
************************************
************************************
[+] input: testDeleteAll() {  Structure s = new StructureDataType("test1", 0); s.add(new ByteDataType()); s.add(new FloatDataType());  struct.add(s);  DataType dt = struct.getDataTypeManager().getDataType(struct.getCategoryPath(), "test1"); s = (Structure) dt; s.deleteAll(); assertEquals(1, s.getLength()); assertTrue(s.isNotYetDefined()); assertTrue(s.isZeroLength()); "<AssertPlaceHolder>"; }
getNumComponents() { lock.acquire(); try { checkIsValid(); return numComponents; } finally { lock.release(); } }
[*] target: assertEquals(0, s.getNumComponents())
[-] pred: org. junit. Assert. assertEquals ( 0, s. getNumComponents ( ) )
************************************
************************************
[+] input: testRecoverPublicKey() { TreeRoot.Builder builder = TreeRoot.newBuilder(); builder.setERoot(ByteString.copyFrom("VXJIDGQECCIIYNY3GZEJSFSG6U".getBytes())); builder.setLRoot(ByteString.copyFrom("FDXN3SN67NA5DKA4J2GOK7BVQI".getBytes())); builder.setSeq(3447);  //String eth_msg = "enrtree-root:v1 e=VXJIDGQECCIIYNY3GZEJSFSG6U l=FDXN3SN67NA5DKA4J2GOK7BVQI seq=3447"; String msg = builder.toString(); byte[] sig = Algorithm.sigData(builder.toString(), privateKey); Assert.assertEquals(65, sig.length); String base64Sig = Algorithm.encode64(sig); Assert.assertEquals( "_Zfgv2g7IUzjhqkMGCPZuPT_HAA01hTxiKAa3D1dyokk8_OKee-Jy2dSNo-nqEr6WOFkxv3A9ukYuiJRsf2v8hs", base64Sig);  byte[] sigData; try { sigData = Algorithm.decode64(base64Sig); Assert.assertArrayEquals(sig, sigData); } catch (Exception e) { Assert.fail(); }  BigInteger publicKeyInt = Algorithm.generateKeyPair(privateKey).getPublicKey(); try { BigInteger recoverPublicKeyInt = Algorithm.recoverPublicKey(msg, sig); Assert."<AssertPlaceHolder>"; } catch (SignatureException e) { Assert.fail(); } }
recoverPublicKey(String msg, byte[] sig) throws SignatureException { int recId = sig[64]; if (recId < 27) { recId += 27; } Sign.SignatureData signature = new SignatureData((byte) recId, ByteArray.subArray(sig, 0, 32), ByteArray.subArray(sig, 32, 64)); return Sign.signedMessageToKey(msg.getBytes(), signature); }
[*] target: assertEquals(publicKeyInt, recoverPublicKeyInt)
[-] pred: org. junit. Assert. assertEquals ( publicKeyInt, recoverPublicKeyInt )
************************************
************************************
[+] input: addService() {  testRegistry.addService(new TestPlugin(), serviceProperties);  Mockito.verify(registrationService).notifyOfPluginRegistration(ArgumentMatchers.any(PluginMetadata.class)); PluginMetadata pluginMetadata = pluginMetadataCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(TEST_ID, pluginMetadata.getPluginName()); Assert.assertEquals(TaskType.DETECTOR, pluginMetadata.getPluginType()); // assertEquals(1, pluginMetadata.getFieldConfigs().size()); }
addService(S service, ServiceProperties props) { K serviceId = super.addService(service, props);  if (serviceId != null) { log.info("Performing scan on service {}", service.getClass()); PluginMetadata pluginMetadata = new PluginMetadata(serviceId.toString(), TaskType.DETECTOR); if (registrationService != null) { registrationService.notifyOfPluginRegistration(pluginMetadata); } }  return serviceId; }
[*] target: assertNotNull(pluginMetadata)
[-] pred: org. junit. Assert. assertNotNull ( pluginMetadata )
************************************
************************************
[+] input: testBuildPath() { String baseURL = "http://localhost"; OpenApiPathBuilder tools = OpenApiPathBuilder.newBuilder(); String path, expected, actual; String env = "test"; String appId = "appid-1001"; String clusterName = "cluster-1001"; String namespaceName = "application.yml"; String key = "spring.profile"; String operator = "junit"; long releaseId = 1L;  // AppOpenApiService path check  path = String.format("apps/%s/envclusters", tools.escapePath(appId)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .appsPathVal(appId) .customResource("envclusters") .buildPath(baseURL); assertEquals(expected, actual);  String param = "1,2,3"; path = String.format("apps?appIds=%s", tools.escapeParam(param)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .customResource("apps") .addParam("appIds", param) .buildPath(baseURL); assertEquals(expected, actual);  path = "apps/authorized"; expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .customResource("apps/authorized") .buildPath(baseURL); assertEquals(expected, actual);  // ClusterOpenApiService path check  path = String.format("envs/%s/apps/%s/clusters/%s", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters", tools.escapePath(env), tools.escapePath(appId)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .customResource("clusters") .buildPath(baseURL); assertEquals(expected, actual);  // ItemOpenApiService path check  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/items/%s", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName), tools.escapePath(key)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .itemsPathVal(key) .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/items", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .customResource("items") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format( "envs/%s/apps/%s/clusters/%s/namespaces/%s/items/%s?createIfNotExists=true", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName), tools.escapePath(key)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .itemsPathVal(key) .addParam("createIfNotExists", "true") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/items/%s?operator=%s", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName), tools.escapePath(key), tools.escapeParam(operator)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .itemsPathVal(key) .addParam("operator", operator) .buildPath(baseURL); assertEquals(expected, actual);  // NamespaceOpenApiService path check  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .customResource("namespaces") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("apps/%s/appnamespaces", tools.escapePath(appId)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .appsPathVal(appId) .customResource("appnamespaces") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/lock", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .customResource("lock") .buildPath(baseURL); assertEquals(expected, actual);  // ReleaseOpenApiService path check  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/releases", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .customResource("releases") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/apps/%s/clusters/%s/namespaces/%s/releases/latest", tools.escapePath(env), tools.escapePath(appId), tools.escapePath(clusterName), tools.escapePath(namespaceName)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .appsPathVal(appId) .clustersPathVal(clusterName) .namespacesPathVal(namespaceName) .releasesPathVal("latest") .buildPath(baseURL); assertEquals(expected, actual);  path = String.format("envs/%s/releases/%s/rollback?operator=%s", tools.escapePath(env), releaseId, tools.escapeParam(operator)); expected = String.format("%s/%s", baseURL, path); actual = OpenApiPathBuilder.newBuilder() .envsPathVal(env) .releasesPathVal(String.valueOf(releaseId)) .customResource("rollback") .addParam("operator", operator) .buildPath(baseURL); "<AssertPlaceHolder>"; }
buildPath(String baseUrl) { if (Strings.isNullOrEmpty(baseUrl)) { throw new IllegalArgumentException("Base url should not be null or empty"); } List<String> parts = new ArrayList<>(); parts.add(baseUrl);  for (String k : SORTED_PATH_KEYS) { if (pathVariable.containsKey(k)) { parts.add(k); String v = pathVariable.get(k); if (!Strings.isNullOrEmpty(v)) { parts.add(v); } } }  if (!Strings.isNullOrEmpty(this.customResource)) { parts.add(this.customResource); }  String path = PATH_JOIN.join(parts);  if (!params.isEmpty()) { StringBuilder sb = new StringBuilder(); for (Map.Entry<String, String> kv : params.entrySet()) { if (sb.length() > 0) { sb.append("&"); } sb.append(kv.getKey()).append("=").append(kv.getValue()); } path += "?" + sb; } return path; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetLastCodeColorBeforeFormat() { String input = BUKKIT_COLOR_CODE_PREFIX + "c" + BUKKIT_COLOR_CODE_PREFIX + "oHello"; String expectedResult = BUKKIT_COLOR_CODE_PREFIX + "c" + BUKKIT_COLOR_CODE_PREFIX + "o";  String result = Format.getLastCode(input);  "<AssertPlaceHolder>"; }
getLastCode(String s) { String ts = ""; char[] ch = s.toCharArray(); for (int a = 0; a < s.length() - 1; a++) { if (String.valueOf(ch[a + 1]).matches("[lkomnLKOMN]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts += String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (String.valueOf(ch[a + 1]).matches("[0123456789abcdefrABCDEFR]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (ch[a + 1] == 'x' && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { if (ch.length > a + 13) { if (String.valueOf(ch[a + 3]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 5]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 7]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 9]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 11]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 13]).matches("[0123456789abcdefABCDEF]") && ch[a + 2] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 4] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 6] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 8] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 10] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 12] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1] + ch[a + 2] + ch[a + 3] + ch[a + 4] + ch[a + 5] + ch[a + 6] + ch[a + 7] + ch[a + 8] + ch[a + 9] + ch[a + 10] + ch[a + 11] + ch[a + 12] + ch[a + 13]; a += 13; } } } } return ts; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: Exception { Map<String, String> param = Maps.newHashMap(); param.put(PacmanSdkConstants.ACCOUNT_ID, "acc123"); param.put(PacmanSdkConstants.REGION, "region123"); param.put(PacmanSdkConstants.RESOURCE_ID, "resou123"); param.put(PacmanSdkConstants.REGION, "region"); boolean response = PolicyExecutionUtils.ifFilterMatchesTheCurrentResource(param, param); "<AssertPlaceHolder>"; }
ifFilterMatchesTheCurrentResource(Map<String, String> policyParam, Map<String, String> resource) {  String ruleParam_account = !Strings.isNullOrEmpty(policyParam.get(PacmanSdkConstants.ACCOUNT_ID)) ? policyParam.get(PacmanSdkConstants.ACCOUNT_ID) : resource.get(PacmanSdkConstants.ACCOUNT_ID); String ruleParam_region = !Strings.isNullOrEmpty(policyParam.get(PacmanSdkConstants.REGION)) ? policyParam.get(PacmanSdkConstants.REGION) : resource.get(PacmanSdkConstants.REGION); String ruleParam_resourceId = !Strings.isNullOrEmpty(policyParam.get(PacmanSdkConstants.RESOURCE_ID)) ? policyParam.get(PacmanSdkConstants.RESOURCE_ID) : resource.get(PacmanSdkConstants.RESOURCE_ID);  String ruleString = new StringBuilder(ruleParam_account).append(ruleParam_region).append(ruleParam_resourceId) .toString(); String resourceString = new StringBuilder(resource.get(PacmanSdkConstants.ACCOUNT_ID)) .append(resource.get(PacmanSdkConstants.REGION)).append(resource.get(PacmanSdkConstants.RESOURCE_ID)) .toString(); ;  return ruleString.equals(resourceString);  }
[*] target: assertTrue(response)
[-] pred: org. junit. Assert. assertTrue ( response )
************************************
************************************
[+] input: extractTaxonomyIdFromPolicyTagId() {  String input = "projects/<project>/locations/<location>/taxonomies/<taxonomyID>/policyTags/<policyTagID"; String expected = "projects/<project>/locations/<location>/taxonomies/<taxonomyID>"; String actual = Utils.extractTaxonomyIdFromPolicyTagId(input);  "<AssertPlaceHolder>"; }
extractTaxonomyIdFromPolicyTagId(String policyTagId){  List<String> tokens = tokenize(policyTagId, "/", true); int taxonomiesIndex = tokens.indexOf("taxonomies"); return String.join("/", tokens.subList(0,taxonomiesIndex+2)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testShouldRollbackValidatedDeviceIfDeviceCredentialsValidationFailed() { Mockito.reset(validator); Mockito.doThrow(new DataValidationException("mock message")) .when(validator).validate(any(), any());  Device device = new Device(); device.setTenantId(tenantId); device.setName(StringUtils.randomAlphabetic(10)); device.setType("default");  assertThatThrownBy(() -> deviceService.saveDevice(device)) .isInstanceOf(DataValidationException.class) .hasMessageContaining("mock message");  Device deviceByName = deviceService.findDeviceByTenantIdAndName(tenantId, device.getName()); Assertions."<AssertPlaceHolder>"; }
findDeviceByTenantIdAndName(TenantId tenantId, String name);
[*] target: assertNull(deviceByName)
[-] pred: org. junit. Assert. assertNull ( deviceByName )
************************************
************************************
[+] input: testAsList_VarArgs_Null() {  List<String> list = CollectionUtils.asList((String) null); assertNotNull(list); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty ( ) )
************************************
************************************
[+] input: NetException { boolean isIpAddress = IpAddressUtils.isIpAddress(NetUtils.getLocalIp()); "<AssertPlaceHolder>"; }
isIpAddress(String str) { if (StringUtils.isBlank(str) || str.length() < 7 || str.length() > 15) { return false; } String rexp = "([1-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])){3}"; Pattern pat = Pattern.compile(rexp); Matcher mat = pat.matcher(str); return mat.find(); }
[*] target: assertTrue(isIpAddress)
[-] pred: org. junit. Assert. assertTrue ( isIpAddress )
************************************
************************************
[+] input: substituteParametersInSqlString_UuidListType() {  List<UUID> guids = List.of(UUID.fromString("634a8d03-6871-4e01-94d0-876bf3e67dff"), UUID.fromString("3adbb5b8-4dc6-4faf-80dc-681a7b518b5e"), UUID.fromString("63a50f0c-2058-4d1d-8f15-812eb7f84412"));  String sql = "Select * from Table Where guid IN (:guids)"; String sqlToUse = "Select * from Table Where guid IN ('634a8d03-6871-4e01-94d0-876bf3e67dff', '3adbb5b8-4dc6-4faf-80dc-681a7b518b5e', '63a50f0c-2058-4d1d-8f15-812eb7f84412')";  ctx.addUuidListParameter("guids", guids);  String sqlToUseResult = queryLog.substituteParametersInSqlString(sql, ctx); "<AssertPlaceHolder>"; }
substituteParametersInSqlString(String sql, SqlParameterSource paramSource) {  ParsedSql parsedSql = NamedParameterUtils.parseSqlStatement(sql); List<SqlParameter> declaredParams = NamedParameterUtils.buildSqlParameterList(parsedSql, paramSource);  if (declaredParams.isEmpty()) { return sql; }  for (SqlParameter parSQL: declaredParams) { String paramName = parSQL.getName(); if (!paramSource.hasValue(paramName)) { continue; }  Object value = paramSource.getValue(paramName); if (value instanceof SqlParameterValue) { value = ((SqlParameterValue)value).getValue(); }  if (!(value instanceof Iterable)) {  String ValueForSQLQuery = getValueForSQLQuery(value); sql = sql.replace(":" + paramName, ValueForSQLQuery); continue; }  //Iterable int count = 0; String valueArrayStr = "";  for (Object valueTemp: (Iterable)value) {  if (count > 0) { valueArrayStr+=", "; }  String valueForSQLQuery = getValueForSQLQuery(valueTemp); valueArrayStr += valueForSQLQuery; ++count; }  sql = sql.replace(":" + paramName, valueArrayStr);  }  return sql; }
[*] target: assertEquals(sqlToUse, sqlToUseResult)
[-] pred: org. junit. Assert. assertEquals ( sqlToUse, sqlToUseResult )
************************************
************************************
[+] input: testFoo() { String targetClassName = Foo.class.getCanonicalName(); GetStaticGraph graph = GetStaticGraphGenerator .generate(targetClassName);  Set<String> expectedClasses = new HashSet<>(Arrays.asList( Foo.class.getCanonicalName(), Bar1.class.getCanonicalName(), Bar2.class.getCanonicalName(), Bar3.class.getCanonicalName(), Bar4.class.getCanonicalName(), Bar5.class.getCanonicalName(), Bar6.class.getCanonicalName(), Bar7.class.getCanonicalName(), BarBar1.class.getCanonicalName()));  Set<String> allClasses = new HashSet<>(); allClasses.addAll(graph.getSourceClasses()); allClasses.addAll(graph.getTargetClasses());  assertEquals(expectedClasses, allClasses);  Map<String, Set<String>> expectedStaticFields = new HashMap<>(); expectedStaticFields.put(Bar2.class.getCanonicalName(), new HashSet<>(Arrays.asList("fieldBar2"))); expectedStaticFields.put(Bar6.class.getCanonicalName(), new HashSet<>(Arrays.asList("fieldBar6"))); expectedStaticFields.put(Bar7.class.getCanonicalName(), new HashSet<>(Arrays.asList("fieldBar7")));  Map<String, Set<String>> staticFields = graph.getStaticFields(); "<AssertPlaceHolder>"; }
getStaticFields() { Map<String, Set<String>> staticFields = new LinkedHashMap<>(); for (StaticFieldReadEntry read : this.staticFieldReads) { String className = read.getTargetClass().replace('/', '.'); if (!staticFields.containsKey(className)) { staticFields.put(className, new LinkedHashSet<>()); } staticFields.get(className).add(read.getTargetField()); } return staticFields; }
[*] target: assertEquals(expectedStaticFields, staticFields)
[-] pred: org. junit. Assert. assertEquals ( expectedStaticFields, staticFields )
************************************
************************************
[+] input: Exception { IntelHexRecord rawRecord = new IntelHexRecord(3, 0x0030, 0, new byte[] { 0x02, 0x33, 0x7a }, 0x1e); IntelHexRecord readRecord = IntelHexRecordReader.readRecord(":0300300002337A1E"); "<AssertPlaceHolder>"; }
readRecord(String line) { line = line.replaceAll("\\s+", ""); if (line.length() < DATA_START + CHECKSUM_LENGTH) { throw new IllegalArgumentException("line too short to contain record"); } String recordMark = line.substring(RECORD_MARK_START, RECORD_MARK_END); if (!":".equals(recordMark)) { throw new IllegalArgumentException("line does not start with record mark (:)"); } String recordLengthString = line.substring(RECORD_LENGTH_START, RECORD_LENGTH_END); int recordLength; try { recordLength = Integer.parseInt(recordLengthString, 16); } catch (NumberFormatException e) { throw new IllegalArgumentException("error parsing record length: " + e.getMessage()); } String loadOffsetString = line.substring(LOAD_OFFSET_START, LOAD_OFFSET_END); int loadOffset; try { loadOffset = Integer.parseInt(loadOffsetString, 16); } catch (NumberFormatException e) { throw new IllegalArgumentException("error parsing load offset: " + e.getMessage()); } String recordTypeString = line.substring(RECORD_TYPE_START, RECORD_TYPE_END); int recordType; try { recordType = Integer.parseInt(recordTypeString, 16); } catch (NumberFormatException e) { throw new IllegalArgumentException("error parsing record type: " + e.getMessage()); } final int data_end = DATA_START + recordLength * 2; final int checksum_start = data_end; final int checksum_end = checksum_start + CHECKSUM_LENGTH; if (line.length() != checksum_end) { throw new IllegalArgumentException("line invalid length to contain record with record length " + recordLength); } String dataString = line.substring(DATA_START, data_end); byte[] data = convertData(dataString); String checksumString = line.substring(checksum_start, checksum_end); int checksum; try { checksum = Integer.parseInt(checksumString, 16); } catch (NumberFormatException e) { throw new IllegalArgumentException("error parsing checksum: " + e.getMessage()); } return new IntelHexRecord(recordLength, loadOffset, recordType, data, checksum); }
[*] target: assertEquals(rawRecord, readRecord)
[-] pred: org. junit. Assert. assertEquals ( rawRecord, readRecord )
************************************
************************************
[+] input: testExtractDefaultValue() { String expectDefault = "100"; List<String> columnSpecs = Arrays.asList("default", "'100'", "comment", ""); String actualDefault = schemaManager.extractDefaultValue(DorisType.INT, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertEquals(expectDefault, actualDefault)
[-] pred: org. junit. Assert. assertEquals ( expectDefault, actualDefault )
************************************
************************************
[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setLong(3, Long.MAX_VALUE); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred: org. junit. Assert. assertEquals ( 1, ret )
************************************
************************************
[+] input: upperCase() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 123, 3.14, 220, 4).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (123,3.14,220,4)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setFloat(4, 3.14f); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred: org. junit. Assert. assertEquals ( 1, ret )
************************************
************************************
[+] input: ProtocolException { BAOStreamBuilder builder = new BAOStreamBuilder(); builder.addByte(4); // 4 is invalid ByteArrayInputStream istream = builder.getStream(); MockConnection connection = new MockConnection(istream); Proto proto = ProtocolSelector.getProto(connection, null, null); "<AssertPlaceHolder>"; }
getProto( ServerConnection connection, AndroidUtils utils, StatusNotifier notifier) throws ProtocolException { if (connection == null) { return null; } byte[] proto_v = {PROTO_MAX}; if (connection.send(proto_v)) { return null; } if (connection.receive(proto_v)) { return null; } int selectedProto = PROTO_MAX; if (proto_v[0] == ProtocolSelector.PROTOCOL_OBSOLETE) { throw new ProtocolException("Obsolete client"); } else if (proto_v[0] == ProtocolSelector.PROTOCOL_UNKNOWN) { byte[] serverProto = new byte[1]; if (connection.receive(serverProto)) { return null; } byte serverMaxProto = serverProto[0]; if (serverMaxProto < PROTO_MIN) { serverProto[0] = 0; connection.send(serverProto); throw new ProtocolException("Obsolete server"); } if (acceptProto(connection, serverMaxProto)) { return null; } selectedProto = serverMaxProto; } else if (proto_v[0] != ProtocolSelector.PROTOCOL_SUPPORTED) { return null; } switch (selectedProto) { case 1: return new Proto_v1(connection, utils, notifier); case 2: return new Proto_v2(connection, utils, notifier); case 3: return new Proto_v3(connection, utils, notifier); default: throw new ProtocolException("Unknown protocol"); } }
[*] target: assertNull(proto)
[-] pred: org. junit. Assert. assertNull ( proto )
************************************
************************************
[+] input: testIsAvailable_notIfNull() { mController.onResume(null, mock(NotificationChannel.class), null, null, null, null); assertFalse(mController.isAvailable());  mController.onResume(mock(NotificationBackend.AppRow.class), null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } return mChannel != null && NotificationChannel.DEFAULT_CHANNEL_ID.equals(mChannel.getId());  }
[*] target: assertFalse(mController.isAvailable())
[-] pred: org. junit. Assert. assertFalse ( mController. isAvailable() )
************************************
************************************
[+] input: fromFullResource() {  String input = "//bigquery.googleapis.com/projects/test_project/datasets/test_dataset/tables/test_table"; TableSpec expected = new TableSpec("test_project", "test_dataset", "test_table"); TableSpec actual = TableSpec.fromFullResource(input);  "<AssertPlaceHolder>"; }
fromFullResource(String fullResource){ List<String> tokens = Utils.tokenize(fullResource, "/", true); return new TableSpec( tokens.get(2), tokens.get(4), tokens.get(6) ); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: whenResolve_insideSubmodelElementCollection_success() { String submodelId = "http://example.org/submodel"; String submodelElementIdShort = "foo"; String submodelElementListIdShort = "list"; SubmodelElement expected = new DefaultProperty.Builder() .idShort(submodelElementIdShort) .value("bar") .build(); SubmodelElementCollection list = new DefaultSubmodelElementCollection.Builder() .idShort(submodelElementListIdShort) .value(expected) .build(); Environment environment = new DefaultEnvironment.Builder() .submodels(new DefaultSubmodel.Builder() .id(submodelId) .submodelElements(list) .build()) .build(); Reference reference = new DefaultReference.Builder() .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL) .value(submodelId) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT_LIST) .value(submodelElementListIdShort) .build()) .keys(new DefaultKey.Builder() .type(KeyTypes.SUBMODEL_ELEMENT) .value(submodelElementIdShort) .build()) .build(); Referable actual = AasUtils.resolve(reference, environment); Assert."<AssertPlaceHolder>"; }
resolve(Reference reference, Environment env) { return resolve(reference, env, Referable.class); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: success_search_test_1() { String pattern = "xyz"; String text = "abcabcxyzabcxxyzyxyz"; String exceptedOutput = "Found pattern at index 6\n" + "Found pattern at index 13\n" + "Found pattern at index 17\n"; String actual = CaptureOutput.captureStandardOutput(() -> Question1.search(pattern, text)); "<AssertPlaceHolder>"; }
search(String pattern, String txt) { int M = pattern.length(); int N = txt.length();  // create lps[] that will hold the longest // prefix suffix values for pattern int lps[] = new int[M]; int j = 0; // index for pat[]  // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pattern, M, lps);  int i = 0; // index for txt[] boolean notFound = true; while ((N - i) >= (M - j)) { if (pattern.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == M) { System.out.println("Found pattern " + "at index " + (i - j)); notFound = false; j = lps[j - 1]; }  // mismatch after j matches else if (i < N && pattern.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j - 1]; else i = i + 1; } } if (notFound){ System.out.println("No Pattern Found"); } }
[*] target: assertEquals(exceptedOutput, actual)
[-] pred: org. junit. Assert. assertEquals ( exceptedOutput, actual )
************************************
************************************
[+] input: testEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.linearFive(population, 5);  TestSuiteChromosome exepcted_individual = population.get(6); TestSuiteChromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
linearFive(List<T> collection, int position) { _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: SerializationException { File file = tempFolder.newFile("output.json"); serializerToTest.write(new FileOutputStream(file), Examples.EXAMPLE_SIMPLE.getModel()); "<AssertPlaceHolder>"; }
write(OutputStream out, Object aasInstance) throws SerializationException { write(out, StandardCharsets.UTF_8, aasInstance); }
[*] target: assertTrue(file.exists())
[-] pred: org. junit. Assert. assertTrue ( file. exists ( ) )
************************************
************************************
[+] input: testDeleteUser() { User tenantAdminUser = userService.findUserByEmail(tenantId, "tenant@thingsboard.org"); User user = new User(); user.setAuthority(Authority.TENANT_ADMIN); user.setTenantId(tenantAdminUser.getTenantId()); user.setEmail("tenant2@thingsboard.org"); User savedUser = userService.saveUser(TenantId.SYS_TENANT_ID, user); Assert.assertNotNull(savedUser); Assert.assertNotNull(savedUser.getId()); User foundUser = userService.findUserById(tenantId, savedUser.getId()); Assert.assertNotNull(foundUser); UserCredentials userCredentials = userService.findUserCredentialsByUserId(tenantId, foundUser.getId()); Assert.assertNotNull(userCredentials); userService.deleteUser(tenantId, foundUser); userCredentials = userService.findUserCredentialsByUserId(tenantId, foundUser.getId()); foundUser = userService.findUserById(tenantId, foundUser.getId()); Assert."<AssertPlaceHolder>"; Assert.assertNull(userCredentials); }
findUserById(TenantId tenantId, UserId userId);
[*] target: assertNull(foundUser)
[-] pred: org. junit. Assert. assertNull ( foundUser )
************************************
************************************
[+] input: givenUnknownClassDescriptor_whenLookup_thenClassLoaderIsNull() { final ClassLoaderStore classLoaderStore = new ClassLoaderStore(); final ClassLoaderDescriptor classLoaderDescriptor = ClassLoaderDescriptor.builder() .description("desc") .id("id") .simpleClassName("ClassLoader") .build();  final ClassLoader correspondingClassLoader = classLoaderStore.lookup(classLoaderDescriptor);  Assert."<AssertPlaceHolder>"; }
lookup(ClassLoaderDescriptor classLoaderDescriptor) { if (classLoaderDescriptor == null) { // Bootstrap classloader return null; } final WeakReference<ClassLoader> classLoaderRef = classLoaders.get(classLoaderDescriptor); if (classLoaderRef == null) { return null; } final ClassLoader classLoader = classLoaderRef.get(); if (classLoader == null) { classLoaders.remove(classLoaderDescriptor); return null; } return classLoader; }
[*] target: assertNull(correspondingClassLoader)
[-] pred: org. junit. Assert. assertNull ( correspondingClassLoader )
************************************
************************************
[+] input: testRingTopology_mostRightNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.ringTopology(population, 15);  TestSuiteChromosome exepcted_individual = population.get(0); TestSuiteChromosome returned_individual = neighbors.get(2);  "<AssertPlaceHolder>"; }
ringTopology(List<T> collection, int position) {  if (position-1 < 0){ _L = collection.size() - 1; }else{ _L = position - 1; }  if (position+1 > collection.size() - 1){ _R = 0; }else{ _R = position + 1; }  chromosomes.add(collection.get(_L)); chromosomes.add(collection.get(position)); chromosomes.add(collection.get(_R));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: Exception { Namespace scope = st.createNameSpace(null, "MyNamespace", SourceType.USER_DEFINED); Symbol s = createLabel(addr(0x200), "printf", scope); "<AssertPlaceHolder>"; }
createLabel(Address addr, String name, SourceType source) throws InvalidInputException { return createLabel(addr, name, null, source); }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: testGetColor_StateUnavailable_ReturnUnavailableColor() { final int color = mTileColorPicker.getColor(Tile.STATE_UNAVAILABLE); final int expectedColor = mTintColorStateList.getColorForState( TileColorPicker.DISABLE_STATE_SET, DEFAULT_COLOR);  "<AssertPlaceHolder>"; }
getColor(int state) { final int defaultColor = 0;  switch (state) { case Tile.STATE_UNAVAILABLE: return mColorStateList.getColorForState(DISABLE_STATE_SET, defaultColor); case Tile.STATE_INACTIVE: return mColorStateList.getColorForState(INACTIVE_STATE_SET, defaultColor); case Tile.STATE_ACTIVE: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); default: return mColorStateList.getColorForState(ENABLE_STATE_SET, defaultColor); } }
[*] target: assertEquals(expectedColor, color)
[-] pred: org. junit. Assert. assertEquals ( expectedColor, color )
************************************
************************************
[+] input: testLoadX509FromStream() { ByteArrayInputStream inputStream = new ByteArrayInputStream(MERCHANT_CERTIFICATE_STRING.getBytes(StandardCharsets.UTF_8)); X509Certificate certificate = PemUtil.loadX509FromStream(inputStream); Assert."<AssertPlaceHolder>"; }
loadX509FromStream(InputStream inputStream) { try { return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(inputStream); } catch (CertificateException e) { throw new IllegalArgumentException(e); } }
[*] target: assertNotNull(certificate)
[-] pred: org. junit. Assert. assertNotNull ( certificate )
************************************
************************************
[+] input: shouldFilterOtherNotificationWhenDisabled() { // GIVEN that the media feature is disabled when(mMediaFeatureFlag.getEnabled()).thenReturn(false); NotificationFilter filter = new NotificationFilter(mStatusBarStateController, mMediaFeatureFlag); // WHEN the media filter is asked about an entry NotificationEntry otherEntry = new NotificationEntryBuilder().build(); final boolean shouldFilter = filter.shouldFilterOut(otherEntry); // THEN it shouldn't be filtered "<AssertPlaceHolder>"; }
shouldFilterOut(NotificationEntry entry) { final StatusBarNotification sbn = entry.getSbn(); if (!(getEnvironment().isDeviceProvisioned() || showNotificationEvenIfUnprovisioned(sbn))) { return true; }  if (!getEnvironment().isNotificationForCurrentProfiles(sbn)) { return true; }  if (getUserManager().isLockscreenPublicMode(sbn.getUserId()) && (sbn.getNotification().visibility == Notification.VISIBILITY_SECRET || getUserManager().shouldHideNotifications(sbn.getUserId()) || getUserManager().shouldHideNotifications(sbn.getKey()))) { return true; }  if (mStatusBarStateController.isDozing() && entry.shouldSuppressAmbient()) { return true; }  if (!mStatusBarStateController.isDozing() && entry.shouldSuppressNotificationList()) { return true; }  if (entry.getRanking().isSuspended()) { return true; }  if (getFsc().isDisclosureNotification(sbn) && !getFsc().isDisclosureNeededForUser(sbn.getUserId())) { // this is a foreground-service disclosure for a user that does not need to show one return true; } if (getFsc().isSystemAlertNotification(sbn)) { final String[] apps = sbn.getNotification().extras.getStringArray( Notification.EXTRA_FOREGROUND_APPS); if (apps != null && apps.length >= 1) { if (!getFsc().isSystemAlertWarningNeeded(sbn.getUserId(), apps[0])) { return true; } } }  if (mIsMediaFlagEnabled && isMediaNotification(sbn)) { return true; } return false; }
[*] target: assertFalse(shouldFilter)
[-] pred: org. junit. Assert. assertFalse ( shouldFilter )
************************************
************************************
[+] input: testNonNull_Collection_Null() { Collection<String> c = null; c = CollectionUtils.nonNull(c); assertNotNull(c); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(c.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( c. isEmpty() )
************************************
************************************
[+] input: Exception { IEclipsePreferences node = InstanceScope.INSTANCE.getNode(AntUIPlugin.getUniqueIdentifier()); if (node != null) { node.putBoolean(AntEditorPreferenceConstants.FORMATTER_WRAP_LONG, true); node.putInt(AntEditorPreferenceConstants.FORMATTER_MAX_LINE_LENGTH, 40); node.putBoolean(AntEditorPreferenceConstants.FORMATTER_ALIGN, false); node.putBoolean(AntEditorPreferenceConstants.FORMATTER_TAB_CHAR, true); node.putInt(AntEditorPreferenceConstants.FORMATTER_TAB_SIZE, 4); node.flush(); } String lineSep = System.getProperty("line.separator"); //$NON-NLS-1$ String xmlDoc = "<project default="go"><target name="go" description="Demonstrate the wrapping of long tags."><echo>hi</echo></target></project>"; //$NON-NLS-1$ String formattedDoc = XmlFormatter.format(xmlDoc); String expected = "<project default="go">" + lineSep + "\t<target name="go"" + lineSep //$NON-NLS-1$ //$NON-NLS-2$ + "\t        description="Demonstrate the wrapping of long tags.">" + lineSep + "\t\t<echo>hi</echo>" //$NON-NLS-1$ //$NON-NLS-2$ + lineSep + "\t</target>" + lineSep + "</project>"; //$NON-NLS-1$ //$NON-NLS-2$ "<AssertPlaceHolder>"; }
format(String text) { return format(text, null); }
[*] target: assertEquals(expected, formattedDoc)
[-] pred: org. junit. Assert. assertEquals ( expected, formattedDoc )
************************************
************************************
[+] input: testValueAsStringWithString() { final String string = "some-string"; final String valueAsString = FieldValueHelper.getValueAsString(string); Assert."<AssertPlaceHolder>"; }
getValueAsString(Object value) { if (value != null && value.getClass().isArray()) { if (value.getClass().getComponentType().isPrimitive()) { final Class<?> primitiveType = value.getClass().getComponentType(); if (primitiveType == int.class) { return Arrays.toString((int[]) value); } else if (primitiveType == char.class) { return Arrays.toString((char[]) value); } else if (primitiveType == byte.class) { return Arrays.toString((byte[]) value); } else if (primitiveType == boolean.class) { return Arrays.toString((boolean[]) value); } else if (primitiveType == long.class) { return Arrays.toString((long[]) value); } else if (primitiveType == short.class) { return Arrays.toString((short[]) value); } else if (primitiveType == double.class) { return Arrays.toString((double[]) value); } else if (primitiveType == float.class) { return Arrays.toString((float[]) value); } // We've covered all primitives. This isn't possible. throw new IllegalStateException(); } return Arrays.deepToString((Object[]) value); } return String.valueOf(value); }
[*] target: assertEquals(string, valueAsString)
[-] pred: org. junit. Assert. assertEquals ( string, valueAsString )
************************************
************************************
[+] input: testCreateDataOnInstructionFailure() { // Should NOT be able to create data on top of an instruction Instruction instr1 = listing.getInstructionAfter(addr(0)); Address addr = instr1.getMinAddress(); CreateDataCmd cmd = new CreateDataCmd(addr, new ByteDataType()); cmd.applyTo(program); Instruction instr2 = listing.getInstructionAfter(addr(0)); "<AssertPlaceHolder>"; assertNull(listing.getDataAt(addr)); }
applyTo(DomainObject obj) { try { DataUtilities.createData((Program) obj, addr, newDataType, -1, stackPointers, clearMode); return true; } catch (Exception e) { msg = e.getMessage(); return false; } }
[*] target: assertEquals(instr1, instr2)
[-] pred: org. junit. Assert. assertEquals ( instr1, instr2 )
************************************
************************************
[+] input: testSignString() { String stringToSign = "1576478257344\n/configs/100004458/default/application?ip=10.0.0.1"; String accessKeySecret = "df23df3f59884980844ff3dada30fa97";  String actualSignature = HmacSha1Utils.signString(stringToSign, accessKeySecret);  String expectedSignature = "EoKyziXvKqzHgwx+ijDJwgVTDgE="; "<AssertPlaceHolder>"; }
signString(String stringToSign, String accessKeySecret) { try { Mac mac = Mac.getInstance(ALGORITHM_NAME); mac.init(new SecretKeySpec( accessKeySecret.getBytes(ENCODING), ALGORITHM_NAME )); byte[] signData = mac.doFinal(stringToSign.getBytes(ENCODING)); return BaseEncoding.base64().encode(signData); } catch (NoSuchAlgorithmException | UnsupportedEncodingException | InvalidKeyException e) { throw new IllegalArgumentException(e.toString()); } }
[*] target: assertEquals(expectedSignature, actualSignature)
[-] pred: org. junit. Assert. assertEquals ( expectedSignature, actualSignature )
************************************
************************************
[+] input: testConstructorRoot3() { CategoryPath c = new CategoryPath(""); assertEquals("/", c.getPath()); assertEquals("", c.getName()); "<AssertPlaceHolder>"; }
isRoot() { // parent can only be null for ROOT return parent == null; }
[*] target: assertTrue(c.isRoot())
[-] pred: org. junit. Assert. assertTrue ( c. isRoot() )
************************************
************************************
[+] input: getNextByteStateShouldReturnNull() { SingleByteTransition nextState = match.getNextByteState(); "<AssertPlaceHolder>"; }
getNextByteState() { return null; }
[*] target: assertNull(nextState)
[-] pred: org. junit. Assert. assertNull ( nextState )
************************************
************************************
[+] input: testDisplayString_LabelFieldLocation() {  Address address = addr("01002d0f"); String labelText = "LAB_01002d0f"; LabelFieldLocation location = new LabelFieldLocation(program, address, labelText);  PreviewTableCellData data = new PreviewTableCellData(location, formatter); String preview = data.getDisplayString();  "<AssertPlaceHolder>"; }
getDisplayString() { if (displayString != null) { return displayString; } displayString = getPreview(false); return displayString; }
[*] target: assertEquals(labelText, preview)
[-] pred: org. junit. Assert. assertEquals ( labelText, preview )
************************************
************************************
[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred: org. junit. Assert. assertEquals ( 1, ret )
************************************
************************************
[+] input: testIssue18() { String template = """ bugged "here" """;  assertEquals("bugged "here"\n", template);  String actual = CodeAppendable.stringConcat(template); String expected = "\n" + "    "bugged \\"here\\"\\n"";  "<AssertPlaceHolder>";  }
stringConcat(String s) { int i = 0; StringBuilder code = new StringBuilder(); for (String line : split(s, "\n")) { if (i > 0) { code.append(" +"); } code.append("\n    ""); code.append(EscapeUtils.escapeJava(line)); code.append("""); i++; } String result = code.toString(); if (result.isEmpty()) { result = """"; } return result; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { Assume.assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());  JsonObject json = WycheproofTestUtil.readJson("../wycheproof/testvectors/aes_gcm_test.json"); int errors = 0; int cntSkippedTests = 0; JsonArray testGroups = json.get("testGroups").getAsJsonArray(); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); int keySize = group.get("keySize").getAsInt(); JsonArray tests = group.get("tests").getAsJsonArray(); if (!Arrays.asList(keySizeInBytes).contains(keySize / 8)) { cntSkippedTests += tests.size(); continue; } for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); String tcId = String.format("testcase %d (%s)", testcase.get("tcId").getAsInt(), testcase.get("comment").getAsString()); byte[] iv = Hex.decode(testcase.get("iv").getAsString()); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] msg = Hex.decode(testcase.get("msg").getAsString()); byte[] aad = Hex.decode(testcase.get("aad").getAsString()); @Nullable Integer apiLevel = Util.getAndroidApiLevel(); if (apiLevel != null && apiLevel <= 19 && aad.length != 0) { cntSkippedTests++; continue; } byte[] ct = Hex.decode(testcase.get("ct").getAsString()); byte[] tag = Hex.decode(testcase.get("tag").getAsString()); byte[] ciphertext = Bytes.concat(iv, ct, tag); // Result is one of "valid", "invalid", "acceptable". // "valid" are test vectors with matching plaintext, ciphertext and tag. // "invalid" are test vectors with invalid parameters or invalid ciphertext and tag. // "acceptable" are test vectors with weak parameters or legacy formats. String result = testcase.get("result").getAsString(); // Tink only supports 12-byte iv. if (iv.length != 12) { result = "invalid"; }  try { AesGcmJce gcm = new AesGcmJce(key); byte[] decrypted = gcm.decrypt(ciphertext, aad); boolean eq = TestUtil.arrayEquals(decrypted, msg); if (result.equals("invalid")) { System.out.printf( "FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n", tcId, Hex.encode(msg), Hex.encode(decrypted)); errors++; } else { if (!eq) { System.out.printf( "FAIL %s: incorrect decryption, result: %s, expected: %s%n", tcId, Hex.encode(decrypted), Hex.encode(msg)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("FAIL %s: cannot decrypt, exception %s%n", tcId, ex); errors++; } } } } System.out.printf("Number of tests skipped: %d", cntSkippedTests); "<AssertPlaceHolder>"; }
decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException { if (ciphertext == null) { throw new NullPointerException("ciphertext is null"); } if (ciphertext.length < outputPrefix.length + IV_SIZE_IN_BYTES + TAG_SIZE_IN_BYTES) { throw new GeneralSecurityException("ciphertext too short"); } if (!isPrefix(outputPrefix, ciphertext)) { throw new GeneralSecurityException("Decryption failed (OutputPrefix mismatch)."); } // IV is at position outputPrefix.length in ciphertext. AlgorithmParameterSpec params = AesGcmJceUtil.getParams(ciphertext, outputPrefix.length, IV_SIZE_IN_BYTES); Cipher cipher = AesGcmJceUtil.getThreadLocalCipher(); cipher.init(Cipher.DECRYPT_MODE, keySpec, params); if (associatedData != null && associatedData.length != 0) { cipher.updateAAD(associatedData); } int offset = outputPrefix.length + IV_SIZE_IN_BYTES; int len = ciphertext.length - outputPrefix.length - IV_SIZE_IN_BYTES; return cipher.doFinal(ciphertext, offset, len); }
[*] target: assertEquals(0, errors)
[-] pred: org. junit. Assert. assertEquals ( 0, errors )
************************************
************************************
[+] input: testEscapeStringEmpty() { String orig = ""; String escaped = CategoryPath.escapeString(orig); String unescaped = CategoryPath.unescapeString(escaped); "<AssertPlaceHolder>"; assertEquals("", escaped); }
unescapeString(String escapedString) { return escapedString.replace(ESCAPED_DELIMITER_STRING, DELIMITER_STRING); }
[*] target: assertEquals(orig, unescaped)
[-] pred: org. junit. Assert. assertEquals ( orig, unescaped )
************************************
************************************
[+] input: testUpdateApiDestination() { Mockito.when(apiDestinationRepository.getApiDestination(any(), any())).thenReturn(new ApiDestinationDTO()); ApiDestinationDTO apiDestinationDTO = new ApiDestinationDTO(); apiDestinationDTO.setName(UUID.randomUUID().toString()); apiDestinationDTO.setAccountId(UUID.randomUUID().toString()); HttpApiParameters httpApiParameters = new HttpApiParameters(); httpApiParameters.setMethod("POST"); httpApiParameters.setEndpoint("http://127.0.0.1:8001"); apiDestinationDTO.setApiParams(httpApiParameters); final Boolean aBoolean = apiDestinationService.updateApiDestination(apiDestinationDTO); Assert."<AssertPlaceHolder>"; }
updateApiDestination(ApiDestinationDTO apiDestinationDTO) { if (checkApiDestination(apiDestinationDTO.getAccountId(), apiDestinationDTO.getName()) == null) { throw new EventBridgeException(EventBridgeErrorCode.ApiDestinationNotExist, apiDestinationDTO.getName()); } ApiDestinationDTO oldApiDestination = getApiDestination(apiDestinationDTO.getAccountId(), apiDestinationDTO.getName()); if (StringUtils.isNotBlank(apiDestinationDTO.getConnectionName())) { connectionService.getConnection(apiDestinationDTO.getAccountId(), apiDestinationDTO.getConnectionName()); } else { apiDestinationDTO.setConnectionName(oldApiDestination.getConnectionName()); } if (apiDestinationDTO.getApiParams() == null) { apiDestinationDTO.setApiParams(oldApiDestination.getApiParams()); } else { HttpApiParameters apiParams = apiDestinationDTO.getApiParams(); HttpApiParameters oldApiParams = oldApiDestination.getApiParams(); if (StringUtils.isBlank(apiParams.getEndpoint())) { apiParams.setEndpoint(oldApiParams.getEndpoint()); } if (StringUtils.isBlank(apiParams.getMethod())) { apiParams.setMethod(oldApiParams.getMethod()); } apiDestinationDTO.setApiParams(apiParams); } return apiDestinationRepository.updateApiDestination(apiDestinationDTO); }
[*] target: assertTrue(aBoolean)
[-] pred: org. junit. Assert. assertTrue ( aBoolean )
************************************
************************************
[+] input: testSimpleNameEmptyString() { final String className = ""; final String simpleName = ClassNameHelper.getSimpleName(className); Assert."<AssertPlaceHolder>"; }
getSimpleName(String name) { final int lastIndex = name.lastIndexOf('.'); if (lastIndex == name.length()) { // Somehow the '.' is the last name. Should never happen but let's be safe. return ""; } return name.substring(name.lastIndexOf('.') + 1); }
[*] target: assertEquals(className, simpleName)
[-] pred: org. junit. Assert. assertEquals ( className, simpleName )
************************************
************************************
[+] input: verify_that_tobytearray_returns_same_as_passed_in_constructor() { byte[] bytes = Bytes.fromHexString("dead000000000000000000000000beef"); EUID euid = new EUID(bytes); "<AssertPlaceHolder>"; }
toByteArray() { return value.toByteArray(); }
[*] target: assertArrayEquals(bytes, euid.toByteArray())
[-] pred: org. junit. Assert. assertArrayEquals ( bytes, euid. toByteArray ( ) )
************************************
************************************
[+] input: ProcessingException { StringBuilder sb = new StringBuilder(); CatalogClassWriter w = new CatalogClassWriter("com.company", "MyCatalog"); w.addTemplateClasses(List.of("com.company.tmp.MyTemplate")); w.addTemplateClasses(List.of("com.company.tmp.MyTemplate")); w.addTemplateClasses(List.of("com.company.tmp.AnotherTemplate")); w.write(sb);  String expected = """ package com.company;  /** * Generated template catalog. */ public class MyCatalog implements io.jstach.jstachio.spi.TemplateProvider.GeneratedTemplateProvider {  /** * Generated template catalog constructor for ServiceLoader. */ public MyCatalog() { }  @Override public java.util.List<io.jstach.jstachio.Template<?>> provideTemplates(io.jstach.jstachio.TemplateConfig templateConfig) { return java.util.List.of(// new com.company.tmp.AnotherTemplate(templateConfig), // new com.company.tmp.MyTemplate(templateConfig)); } } """; String actual = sb.toString();  "<AssertPlaceHolder>"; }
write(Appendable a) throws IOException {  String packageName = catalogClass.getPackageName(); String catalogName = catalogClass.getSimpleName(); String _TemplateProvider = Prisms.GENERATED_TEMPLATE_PROVIDER_CLASS; String _List = List.class.getCanonicalName(); String _Template = Prisms.TEMPLATE_CLASS; String _TemplateConfig = Prisms.TEMPLATE_CONFIG_CLASS;  a.append("package " + packageName + ";\n"); a.append("\n"); a.append("/**\n"); a.append(" * Generated template catalog.\n"); a.append(" */\n"); a.append("public class " + catalogName + " implements " + _TemplateProvider + " {\n"); a.append("\n"); a.append("    /**\n"); a.append("     * Generated template catalog constructor for ServiceLoader.\n"); a.append("     */\n"); a.append("    public " + catalogName + "() {\n"); a.append("    }\n"); a.append("\n"); a.append("    @Override\n"); a.append("    public " + _List + "<" + _Template + "<?>> provideTemplates(" + _TemplateConfig + " templateConfig) {\n"); a.append("        return " + _List + ".of(//\n"); a.append(listTemplates("        new ", "(templateConfig)")).append(");\n"); a.append("    }\n"); a.append("}\n"); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { Enum enumm = new EnumDataType("Color", 1); enumm.add("Red", 10); enumm.add("Green", 15); enumm.add("Blue", 20); Category root = dataMgr.getRootCategory(); Category c = root.createCategory("enumms"); Enum enummDT = (Enum) c.addDataType(enumm, DataTypeConflictHandler.DEFAULT_HANDLER);  Enum copyDT = (Enum) enummDT.copy(null); "<AssertPlaceHolder>";  Enum c2 = (Enum) root.addDataType(copyDT, DataTypeConflictHandler.DEFAULT_HANDLER); assertNotNull(c2); assertTrue(copyDT.isEquivalent(c2)); }
add(String name, long value);
[*] target: assertNotNull(copyDT)
[-] pred: org. junit. Assert. assertNotNull ( copyDT )
************************************
************************************
[+] input: testIsValidColor() { String color = "red";  boolean result = Format.isValidColor(color); "<AssertPlaceHolder>"; }
isValidColor(String color) { Boolean bFound = false; for (ChatColor bkColors : ChatColor.values()) { if (color.equalsIgnoreCase(bkColors.name())) { bFound = true; } } return bFound; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testGettingTaskDescription() { TaskDescriptionProvider provider = TaskDescriptionProvider.getDefault(); String description = provider.getDescriptionForTask("apply"); //$NON-NLS-1$ "<AssertPlaceHolder>"; assertTrue(description.length() > 0); }
getDescriptionForTask(String aTaskName) { ProposalNode task = taskNodes.get(aTaskName); if (task != null) { return task.desc; } return null; }
[*] target: assertNotNull(description)
[-] pred: org. junit. Assert. assertNotNull ( description )
************************************
************************************
[+] input: Exception {  Program testProgram = buildProgram("libopencoreplayer.so", false);  Listing listing = testProgram.getListing(); AddressSpace space = testProgram.getLanguage().getAddressFactory().getDefaultAddressSpace();  // Offsets where there shouldn't be strings because existing refs were "in the way" int[] nonExpectedOffsets = new int[] { 0xa7195fd4, 0xa7196ee8 }; Data dataHere;  // Verify these aren't here before running Strings Analyzer for (int nonExpectedOffset : nonExpectedOffsets) { dataHere = listing.getDefinedDataAt(addr(space, nonExpectedOffset)); assertNull(dataHere); }  // Create references ReferenceManager refMgr = testProgram.getReferenceManager(); refMgr.addMemoryReference(addr(space, 0xa7197898), addr(space, 0xa7195fda), RefType.DATA, SourceType.USER_DEFINED, 1);  refMgr.addMemoryReference(addr(space, 0xa7196f62), addr(space, 0xa7196efc), RefType.DATA, SourceType.USER_DEFINED, 1);  AutoAnalysisManager manager = AutoAnalysisManager.getAnalysisManager(testProgram);  // Run strings analyzer StringsAnalyzer analyzer = new StringsAnalyzer(); analyzer.setCreateStringOverExistingReference(false);// Option is unchecked analyzer.setStringEndAlignment(1); analyzer.added(testProgram, null, monitor, manager.getMessageLog());  for (int nonExpectedOffset : nonExpectedOffsets) { dataHere = listing.getDefinedDataAt(addr(space, nonExpectedOffset)); assertNull(dataHere); }  // String that would have been created if parameter is checked String[] largerStrs = new String[] { "PVFMVideoMIO", "set to invalid mode (%d)" }; String[] nullBits = new String[] { "00", "00" };  // Now run again with parameter enabled and verify strings are there analyzer.setCreateStringOverExistingReference(true);// Option is checked analyzer.added(testProgram, null, monitor, manager.getMessageLog());  String stringHere; for (int i = 0; i < nonExpectedOffsets.length; i++) { dataHere = listing.getDefinedDataAt(addr(space, nonExpectedOffsets[i])); "<AssertPlaceHolder>"; stringHere = dataHere.getDefaultValueRepresentation(); assertEquals(""" + largerStrs[i] + """, stringHere); } }
added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log) throws CancelledException {  AddressFactory factory = program.getAddressFactory(); AddressSpace[] addressSpaces = factory.getAddressSpaces();  AddressSetView initializedMemory = program.getMemory().getLoadedAndInitializedAddressSet();  try {  NGramUtils.startNewSession(trigramFile, forceModelReload);  isLowerCaseModel = NGramUtils.isLowerCaseModel();  if (set == null) { set = new AddressSet(initializedMemory); }  AddressSet searchSet = initializedMemory.intersect(set);  if (searchOnlyAccessibleMemBlocks) {  // Intersect current AddressSet with accessible memory blocks MemoryBlock[] blocks = program.getMemory().getBlocks(); AddressSet memoryBlockAddresses = getMemoryBlockAddresses(blocks); searchSet = searchSet.intersect(memoryBlockAddresses); }  for (AddressSpace space : addressSpaces) {  monitor.checkCanceled();  // Portion of current address space that intersects with initialized memory AddressSet intersecting = searchSet.intersectRange(space.getMinAddress(), space.getMaxAddress());  // Initialize, because we don't want to use the same iterators or // code units when we change address spaces instructionIterator = null; definedDataIterator = null; currInstrCU = null; currDataCU = null;  findStrings(program, intersecting, minStringLength, startAlignment, requireNullEnd, allCharWidths, monitor); } } catch (CancelledException e) { throw e; } catch (IOException e) { String msg = "Error accessing string model file: " + trigramFile + ": " + e.getMessage(); log.appendMsg(msg); log.setStatus(msg); return false; } catch (Exception e) { Msg.error(this, "Unexpected exception during string analysis", e); log.setStatus("Unexpected exception during string analysis (see console)"); return false; }  return true; }
[*] target: assertNotNull(dataHere)
[-] pred: org. junit. Assert. assertNotNull ( dataHere )
************************************
************************************
[+] input: testFin() { lista.comenzar(); assertTrue(lista.fin());  lista.agregarFinal(0); lista.comenzar(); assertFalse(lista.fin()); lista.proximo(); assertTrue(lista.fin());  lista.agregarEn(1, 1); lista.comenzar(); assertFalse(lista.fin()); lista.proximo(); assertFalse(lista.fin()); lista.proximo(); "<AssertPlaceHolder>";  }
fin() { return (this.actual == null); }
[*] target: assertTrue(lista.fin())
[-] pred: org. junit. Assert. assertTrue ( lista. fin() )
************************************
************************************
[+] input: testAsList_List_Empty() {  List<String> list = new ArrayList<>(); list = CollectionUtils.asList(list); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty ( ) )
************************************
************************************
[+] input: testLoadX509FromString() { X509Certificate certificate = PemUtil.loadX509FromString(MERCHANT_CERTIFICATE_STRING); Assert."<AssertPlaceHolder>"; }
loadX509FromString(String certificateString) { try (ByteArrayInputStream inputStream = new ByteArrayInputStream(certificateString.getBytes(StandardCharsets.UTF_8))) { return loadX509FromStream(inputStream); } catch (IOException e) { throw new UncheckedIOException(e); } }
[*] target: assertNotNull(certificate)
[-] pred: org. junit. Assert. assertNotNull ( certificate )
************************************
************************************
[+] input: testAddSubtractWrap() { Address a1 = new GenericAddress(space, 10); long offset = 0x7fffffffffL; Address a2 = a1.addWrap(offset); Address a3 = a2.subtractWrap(offset); Assert."<AssertPlaceHolder>"; }
subtractWrap(long displacement) { if (displacement == 0) return this; return addrSpace.subtractWrap(this, displacement); }
[*] target: assertEquals(a1, a3)
[-] pred: org. junit. Assert. assertEquals ( a1, a3 )
************************************
************************************
[+] input: NacosException { rpcClient.rpcClientStatus.set(RpcClientStatus.RUNNING); rpcClient.currentConnection = connection; doThrow(new NacosException()).when(connection).asyncRequest(any(), any()); RequestCallBack<?> requestCallBack = mock(RequestCallBack.class); doReturn(10000L).when(requestCallBack).getTimeout(); Exception exception = null;  try { rpcClient.asyncRequest(null, requestCallBack); } catch (NacosException e) { exception = e; }  verify(connection, atLeastOnce()).asyncRequest(any(), any()); verify(rpcClient).switchServerAsyncOnRequestFail(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(RpcClientStatus.UNHEALTHY, rpcClient.rpcClientStatus.get()); }
switchServerAsyncOnRequestFail() { switchServerAsync(null, true); }
[*] target: assertNotNull(exception)
[-] pred: org. junit. Assert. assertNotNull ( exception )
************************************
************************************
[+] input: Exception { QueryServiceResponse res = new QueryServiceResponse(); ServiceInfo info = new ServiceInfo(GROUP_NAME + "@@" + SERVICE_NAME + "@@" + CLUSTERS); res.setServiceInfo(info); when(this.rpcClient.request(any())).thenReturn(res); ServiceInfo actual = client.queryInstancesOfService(SERVICE_NAME, GROUP_NAME, CLUSTERS, 0, false); Assert."<AssertPlaceHolder>"; }
queryInstancesOfService(String serviceName, String groupName, String clusters, int udpPort, boolean healthyOnly) throws NacosException { ServiceQueryRequest request = new ServiceQueryRequest(namespaceId, serviceName, groupName); request.setCluster(clusters); request.setHealthyOnly(healthyOnly); request.setUdpPort(udpPort); QueryServiceResponse response = requestToServer(request, QueryServiceResponse.class); return response.getServiceInfo(); }
[*] target: assertEquals(info, actual)
[-] pred: org. junit. Assert. assertEquals ( info, actual )
************************************
************************************
[+] input: success_search_test_0() { String pattern = "glx"; String text = "abcbcglx"; String exceptedOutput = "Found pattern at index 5\n"; String actual = CaptureOutput.captureStandardOutput(() -> Question1.search(pattern, text)); "<AssertPlaceHolder>"; }
search(String pattern, String txt) { int M = pattern.length(); int N = txt.length();  // create lps[] that will hold the longest // prefix suffix values for pattern int lps[] = new int[M]; int j = 0; // index for pat[]  // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pattern, M, lps);  int i = 0; // index for txt[] boolean notFound = true; while ((N - i) >= (M - j)) { if (pattern.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == M) { System.out.println("Found pattern " + "at index " + (i - j)); notFound = false; j = lps[j - 1]; }  // mismatch after j matches else if (i < N && pattern.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j - 1]; else i = i + 1; } } if (notFound){ System.out.println("No Pattern Found"); } }
[*] target: assertEquals(exceptedOutput, actual)
[-] pred: org. junit. Assert. assertEquals ( exceptedOutput, actual )
************************************
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); //when nacosClientAuthService.login(properties); //then boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>";  }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (StringUtils.isNotBlank(identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN))) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred: org. junit. Assert. assertTrue ( ret )
************************************
************************************
[+] input: removeNotif_inOverflow_intercepted() { // Get bubble with notif in shade. mEntryListener.onPendingEntryAdded(mRow.getEntry()); mBubbleController.updateBubble(mRow.getEntry()); assertTrue(mBubbleController.hasBubbles()); assertFalse(mBubbleController.isBubbleNotificationSuppressedFromShade( mRow.getEntry()));  // Dismiss the bubble into overflow. mBubbleController.removeBubble( mRow.getEntry().getKey(), BubbleController.DISMISS_USER_GESTURE); assertFalse(mBubbleController.hasBubbles());  boolean intercepted = mRemoveInterceptor.onNotificationRemoveRequested( mRow.getEntry().getKey(), mRow.getEntry(), REASON_CANCEL);  // Notif is no longer a bubble, but still in overflow, so we intercept removal. "<AssertPlaceHolder>"; }
onNotificationRemoveRequested( String key, NotificationEntry entry, int dismissReason) { final boolean isClearAll = dismissReason == REASON_CANCEL_ALL; final boolean isUserDimiss = dismissReason == REASON_CANCEL || dismissReason == REASON_CLICK; final boolean isAppCancel = dismissReason == REASON_APP_CANCEL || dismissReason == REASON_APP_CANCEL_ALL; final boolean isSummaryCancel = dismissReason == REASON_GROUP_SUMMARY_CANCELED;  // Need to check for !appCancel here because the notification may have // previously been dismissed & entry.isRowDismissed would still be true boolean userRemovedNotif = (entry != null && entry.isRowDismissed() && !isAppCancel) || isClearAll || isUserDimiss || isSummaryCancel;  if (userRemovedNotif) { return handleDismissalInterception(entry); } return false; }
[*] target: assertTrue(intercepted)
[-] pred: org. junit. Assert. assertTrue ( intercepted )
************************************
************************************
[+] input: Exception {  // // Mangled: _ZNK2cc14ScrollSnapTypeneERKS0_ // // Demangled: cc::ScrollSnapType::operator!=(cc::ScrollSnapType const&) const //  String mangled = "_ZNK2cc14ScrollSnapTypeneERKS0_"; String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals("undefined cc::ScrollSnapType::operator!=(cc::ScrollSnapType const &)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: testEmptyList() { SetBackedList list = new SetBackedList(EMPTY_SET); assertEquals(0, list.size()); assertEquals(true, list.isEmpty()); assertEquals(false, list.contains(1)); assertEquals(false, list.iterator().hasNext()); ListIterator it = list.listIterator(); assertEquals(false, it.hasNext()); assertEquals(-1, it.previousIndex()); "<AssertPlaceHolder>"; }
nextIndex() { return idx; }
[*] target: assertEquals(0, it.nextIndex())
[-] pred: org. junit. Assert. assertEquals ( 0, it. nextIndex() )
************************************
************************************
[+] input: Exception { File expectedFile = new File(DEFAULT_FILENAME);  // Act dumper.run("--connector", connector.getName());  // Assert "<AssertPlaceHolder>"; }
run(@Nonnull Connector connector, @Nonnull ConnectorArguments arguments) throws Exception { List<Task<?>> tasks = new ArrayList<>(); tasks.add(new VersionTask()); tasks.add(new ArgumentsTask(arguments)); { File sqlScript = arguments.getSqlScript(); if (sqlScript != null) { tasks.add(new JdbcRunSQLScript(sqlScript)); } } connector.addTasksTo(tasks, arguments);  // The default output file is based on the connector. // We had a customer request to base it on the database, but that isn't well-defined, // as there may be 0 or N databases in a single file. String outputFileLocation = getOutputFileLocation(connector, arguments);  if (arguments.isDryRun()) { String title = "Dry run: Printing task list for " + connector.getName(); System.out.println(title); System.out.println(repeat('=', title.length())); System.out.println("Writing to " + outputFileLocation); for (Task<?> task : tasks) { print(task, 1); } return true; } else { Stopwatch stopwatch = Stopwatch.createStarted(); long outputFileLength = 0; TaskSetState.Impl state = new TaskSetState.Impl();  LOG.info("Using " + connector); SummaryPrinter summaryPrinter = new SummaryPrinter(); try (Closer closer = Closer.create()) { Path outputPath = prepareOutputPath(outputFileLocation, closer, arguments);  URI outputUri = URI.create("jar:" + outputPath.toUri()); // LOG.debug("Is a zip file: " + outputUri); Map<String, Object> fileSystemProperties = ImmutableMap.<String, Object>builder() .put("create", "true") .put("useTempFile", Boolean.TRUE) .build(); FileSystem fileSystem = closer.register(FileSystems.newFileSystem(outputUri, fileSystemProperties)); OutputHandleFactory sinkFactory = new FileSystemOutputHandleFactory(fileSystem, "/"); // It's required to be "/" LOG.debug("Target filesystem is " + sinkFactory);  Handle handle = closer.register(connector.open(arguments));  new TasksRunner(sinkFactory, handle, arguments.getThreadPoolSize(), state, tasks).run(); } finally { // We must do this in finally after the ZipFileSystem has been closed. File outputFile = new File(outputFileLocation); if (outputFile.isFile()) { outputFileLength = outputFile.length(); } }  printTaskResults(summaryPrinter, state); boolean requiredTaskSucceeded = checkRequiredTaskSuccess(summaryPrinter, state, outputFileLocation); logFinalSummary( summaryPrinter, state, outputFileLength, stopwatch, outputFileLocation, requiredTaskSucceeded); return requiredTaskSucceeded; } }
[*] target: assertTrue(expectedFile.exists())
[-] pred: org. junit. Assert. assertTrue ( expectedFile. exists ( ) )
************************************
************************************
[+] input: testFormatStringLegacyColor_LegacyCodeOnly() { String input = "Hello &cThere Austin"; String expectedResult = "Hello " + BUKKIT_COLOR_CODE_PREFIX + "cThere Austin";  String result = Format.FormatStringLegacyColor(input); "<AssertPlaceHolder>"; }
FormatStringLegacyColor(String string) { String allFormated = string;  allFormated = LEGACY_CHAT_COLOR_PATTERN.matcher(allFormated).replaceAll("\u00A7$13"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[A]", BUKKIT_COLOR_CODE_PREFIX + "a"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[B]", BUKKIT_COLOR_CODE_PREFIX + "b"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[C]", BUKKIT_COLOR_CODE_PREFIX + "c"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[D]", BUKKIT_COLOR_CODE_PREFIX + "d"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[E]", BUKKIT_COLOR_CODE_PREFIX + "e"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[F]", BUKKIT_COLOR_CODE_PREFIX + "f");  allFormated = allFormated.replaceAll("%", "\\%"); return allFormated; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: replaceNothing2() { // given String nativeSql = "insert into test.t1 (ts, temperature, humidity) using test.weather tags('beijing',1) values(now, 12.2, 4)"; Object[] parameters = Stream.of("test", "t1", "test", "weather", "beijing", 1, 12.2, 4).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(nativeSql, actual)
[-] pred: org. junit. Assert. assertEquals ( nativeSql, actual )
************************************
************************************
[+] input: testGetOrCreateClientDefault() { OpenSergoClientManager manager = new OpenSergoClientManager(); OpenSergoClient client1 = manager.getOrCreateClient("127.0.0.1", 12345); OpenSergoClient client2 = manager.getOrCreateClient("127.0.0.1", 12345); OpenSergoClient client3 = manager.getOrCreateClient("1.2.3.4", 12345);  "<AssertPlaceHolder>"; assertNotEquals(client1, client3); }
getOrCreateClient(String host, int port) { return this.getOrCreateClient(host, port, new OpenSergoClientConfig()); }
[*] target: assertSame(client1, client2)
[-] pred: org. junit. Assert. assertSame ( client1, client2 )
************************************
************************************
[+] input: Exception {  // // Mangled: _ZN13SoloGimbalEKFUt_C2Ev // // Demangled: SoloGimbalEKF::{unnamed type#1}::SoloGimbalEKF() // String mangled = "_ZN13SoloGimbalEKFUt_C2Ev"; String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals("undefined SoloGimbalEKF::{unnamed_type#1}::SoloGimbalEKF(void)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: testGetData() { ServiceInfo serviceInfo = serviceStorage.getData(SERVICE);  Assert."<AssertPlaceHolder>"; }
getData(Service service) { return serviceDataIndexes.containsKey(service) ? serviceDataIndexes.get(service) : getPushData(service); }
[*] target: assertNotNull(serviceInfo)
[-] pred: org. junit. Assert. assertNotNull ( serviceInfo )
************************************
************************************
[+] input: lineTerminatorAndMultiValues() { String nativeSql = "INSERT Into ? TAGS(?) VALUES(?,?,\r\n?,?),(?,? ,\r\n?,?) t? tags (?) Values (?,?,?\r\n,?),(?,?,?,?) t? Tags(?) values  (?,?,?,?) , (?,?,?,?)"; Object[] parameters = Stream.of("t1", "abc", 100, 1.1, "xxx", "xxx", 200, 2.2, "xxx", "xxx", 2, "bcd", 300, 3.3, "xxx", "xxx", 400, 4.4, "xxx", "xxx", 3, "cde", 500, 5.5, "xxx", "xxx", 600, 6.6, "xxx", "xxx").toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT Into t1 TAGS('abc') VALUES(100,1.1,\r\n'xxx','xxx'),(200,2.2 ,\r\n'xxx','xxx') t2 tags ('bcd') Values (300,3.3,'xxx'\r\n,'xxx'),(400,4.4,'xxx','xxx') t3 Tags('cde') values  (500,5.5,'xxx','xxx') , (600,6.6,'xxx','xxx')"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: NetException { String ip = NetUtils.getLocalIp(); "<AssertPlaceHolder>"; log.info(ip); }
getLocalIp() throws NetException { try { // Windows操作系统 if (OsUtils.isWindowsOs()) { return getWindowsLocalIp(); } else { return getLinuxLocalIp(); } } catch (Exception e) { String exp = "获取本机IP地址异常！"; log.error(exp, e); throw new NetException(exp); } }
[*] target: assertNotNull(ip)
[-] pred: org. junit. Assert. assertNotNull ( ip )
************************************
************************************
[+] input: testConstructorRoot1() { CategoryPath c = CategoryPath.ROOT; assertEquals("/", c.getPath()); assertEquals("", c.getName()); "<AssertPlaceHolder>"; }
isRoot() { // parent can only be null for ROOT return parent == null; }
[*] target: assertTrue(c.isRoot())
[-] pred: org. junit. Assert. assertTrue ( c. isRoot() )
************************************
************************************
[+] input: testFormatWithPreferenceParameter() { FormattingPreferences prefs = new FormattingPreferences() { @Override public boolean wrapLongTags() { return true; }  @Override public int getMaximumLineWidth() { return 40; }  @Override public boolean alignElementCloseChar() { return false; }  @Override public boolean useSpacesInsteadOfTabs() { return true; }  @Override public int getTabWidth() { return 6; } }; String lineSep = System.getProperty("line.separator"); //$NON-NLS-1$ String xmlDoc = "<project default="go"><target name="go" description="Demonstrate the wrapping of long tags."><echo>hi</echo></target></project>"; //$NON-NLS-1$ String formattedDoc = XmlFormatter.format(xmlDoc, prefs); String expected = "<project default="go">" + lineSep + "      <target name="go"" + lineSep //$NON-NLS-1$ //$NON-NLS-2$ + "              description="Demonstrate the wrapping of long tags.">" + lineSep //$NON-NLS-1$ + "            <echo>hi</echo>" + lineSep + "      </target>" + lineSep + "</project>"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ "<AssertPlaceHolder>"; }
format(String text, FormattingPreferences prefs) {  return format(text, prefs, -1); }
[*] target: assertEquals(expected, formattedDoc)
[-] pred: org. junit. Assert. assertEquals ( expected, formattedDoc )
************************************
************************************
[+] input: testShowingAsLowPriority_lowPriority() { mChildrenContainer.setIsLowPriority(true); Assert."<AssertPlaceHolder>"; }
showingAsLowPriority() { return mIsLowPriority && !mContainingNotification.isExpanded(); }
[*] target: assertTrue(mChildrenContainer.showingAsLowPriority())
[-] pred: org. junit. Assert. assertTrue ( mChildrenContainer. showingAsLowPriority() )
************************************
************************************
[+] input: IOException { // given String tempFilePath = temporaryFolder.newFile("output.gif").getAbsolutePath(); AbstractGifEncoder encoder = new GifFileEncoder.Builder() .delay(300) .repeat(1) .filename(tempFilePath) .build(); List<BufferedImage> images = Arrays.asList( TestUtils.getImageFromResource("input/frame/frame-0.jpg"), TestUtils.getImageFromResource("input/frame/frame-1.jpg"), TestUtils.getImageFromResource("input/frame/frame-2.jpg") );  // when encoder.encode(images);  // then GifDecoder decoder = new GifDecoder(); decoder.read(tempFilePath); List<BufferedImage> restoredImages = new ArrayList<>(); for (int i = 0; i < decoder.getFrameCount(); i++) { restoredImages.add(decoder.getFrame(i)); }  /* * The gif format is a compressed format.The parsed buffered image cannot be * directly compared with the original image because original image has been * compressed when written to file. */ Assert."<AssertPlaceHolder>";  /* * The repeat count equals loop count, and the delay time of every frame is 300ms. */ Assert.assertEquals(1, decoder.getLoopCount()); Assert.assertEquals(300, decoder.getDelay(0)); Assert.assertEquals(300, decoder.getDelay(1)); Assert.assertEquals(300, decoder.getDelay(2)); }
build() { if (StringUtils.isEmpty(filename)) { throw new InvalidSettingException("Filename has not been set."); } return new GifFileEncoder(this); }
[*] target: assertEquals(images.size(), restoredImages.size())
[-] pred: org. junit. Assert. assertEquals ( images. size ( ), restoredImages. size ( ) )
************************************
************************************
[+] input: testFindByDeviceId() { DeviceCredentials foundedDeviceCredentials = deviceCredentialsDao.findByDeviceId(SYSTEM_TENANT_ID, neededDeviceCredentials.getDeviceId().getId()); "<AssertPlaceHolder>"; assertEquals(neededDeviceCredentials.getId(), foundedDeviceCredentials.getId()); assertEquals(neededDeviceCredentials.getCredentialsId(), foundedDeviceCredentials.getCredentialsId()); }
findByDeviceId(TenantId tenantId, UUID deviceId) { return DaoUtil.getData(deviceCredentialsRepository.findByDeviceId(deviceId)); }
[*] target: assertNotNull(foundedDeviceCredentials)
[-] pred: org. junit. Assert. assertNotNull ( foundedDeviceCredentials )
************************************
************************************
[+] input: testBuilderHeader() { Header header = NamingHttpUtil.builderHeader(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(header.getValue(HttpHeaderConsts.CLIENT_VERSION_HEADER), VersionUtils.version); Assert.assertEquals(header.getValue(HttpHeaderConsts.USER_AGENT_HEADER), VersionUtils.getFullClientVersion()); Assert.assertEquals(header.getValue(HttpHeaderConsts.ACCEPT_ENCODING), "gzip,deflate,sdch"); Assert.assertEquals(header.getValue(HttpHeaderConsts.CONNECTION), "Keep-Alive"); Assert.assertNotNull(header.getValue(HttpHeaderConsts.REQUEST_ID)); Assert.assertEquals(header.getValue(HttpHeaderConsts.REQUEST_MODULE), "Naming"); }
builderHeader() { Header header = Header.newInstance(); header.addParam(HttpHeaderConsts.CLIENT_VERSION_HEADER, VersionUtils.version); header.addParam(HttpHeaderConsts.USER_AGENT_HEADER, VersionUtils.getFullClientVersion()); header.addParam(HttpHeaderConsts.ACCEPT_ENCODING, "gzip,deflate,sdch"); header.addParam(HttpHeaderConsts.CONNECTION, "Keep-Alive"); header.addParam(HttpHeaderConsts.REQUEST_ID, UuidUtils.generateUuid()); header.addParam(HttpHeaderConsts.REQUEST_MODULE, "Naming"); return header; }
[*] target: assertNotNull(header)
[-] pred: org. junit. Assert. assertNotNull ( header )
************************************
************************************
[+] input: testClipboardMethods() { String text = "Sample text for clipboard test testClipboardMethods"; try { Context appContext = getInstrumentation().getTargetContext(); AndroidUtils androidUtils = new AndroidUtils(appContext, activity);  androidUtils.setClipboardText(text);  String received = androidUtils.getClipboardText(); "<AssertPlaceHolder>"; } catch (Exception ignored) { } }
getClipboardText() { try { ClipboardManager clipboard = this.getClipboardManager(); if (clipboard == null || !(clipboard.hasPrimaryClip()) || !(clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN) || !clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_HTML))) { return null; } ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0); CharSequence clipDataSequence = item.getText(); if (clipDataSequence == null) { return null; } return clipDataSequence.toString(); } catch (Exception ignored) { return null; } }
[*] target: assertEquals(text, received)
[-] pred: org. junit. Assert. assertEquals ( text, received )
************************************
************************************
[+] input: multiValuesMultiSeparator() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,?,?) (?,?,?,?), (?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 100, 3.14, "abc", 4, 200, 3.1415, "xyz", 5, 300, 3.141592, "uvw", 6).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (100,3.14,'abc',4) (200,3.1415,'xyz',5), (300,3.141592,'uvw',6)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: failure_search_test_0() { String pattern = "xyz"; String text = "abcdef ghijkl"; String exceptedOutput = "No Pattern Found\n"; String actual = CaptureOutput.captureStandardOutput(() -> Question1.search(pattern, text)); "<AssertPlaceHolder>"; }
search(String pattern, String txt) { int M = pattern.length(); int N = txt.length();  // create lps[] that will hold the longest // prefix suffix values for pattern int lps[] = new int[M]; int j = 0; // index for pat[]  // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pattern, M, lps);  int i = 0; // index for txt[] boolean notFound = true; while ((N - i) >= (M - j)) { if (pattern.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == M) { System.out.println("Found pattern " + "at index " + (i - j)); notFound = false; j = lps[j - 1]; }  // mismatch after j matches else if (i < N && pattern.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j - 1]; else i = i + 1; } } if (notFound){ System.out.println("No Pattern Found"); } }
[*] target: assertEquals(exceptedOutput, actual)
[-] pred: org. junit. Assert. assertEquals ( exceptedOutput, actual )
************************************
************************************
[+] input: Exception { Symbol symbol = getUniqueSymbol(program, "entry"); Address addr = symbol.getAddress(); String originalText = "this is a plate comment that is meant to be longer than the available " + "width, as to trigger clipping"; int transactionID = program.startTransaction("test"); try { CodeUnit cu = program.getListing().getCodeUnitAt(addr); cu.setCommentAsArray(CodeUnit.PLATE_COMMENT, new String[] { originalText }); // create a reference to addr program.getReferenceManager() .addMemoryReference(getAddr(0x010023ee), addr, RefType.DATA, SourceType.USER_DEFINED, 0); } finally { program.endTransaction(transactionID, true); }  program.flushEvents(); waitForPostedSwingRunnables(); cb.updateNow();  goToService.goTo(addr);  setBooleanOption(PlateFieldFactory.SHOW_FUNCTION_PLATES_OPTION, true);  assertTrue(cb.goToField(addr, PlateFieldFactory.FIELD_NAME, 1, 1)); ListingTextField tf = (ListingTextField) cb.getCurrentField(); assertEquals(3, tf.getNumRows()); String text = tf.getText(); assertTrue("Text does not have ellipses: " + text, text.indexOf("... *") != -1);  // check tooltip String fullText = tf.getTextWithLineSeparators(); "<AssertPlaceHolder>"; }
getTextWithLineSeparators() { return commentText; }
[*] target: assertEquals(originalText, fullText)
[-] pred: org. junit. Assert. assertEquals ( originalText, fullText )
************************************
************************************
[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setBoolean(8, true); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred: org. junit. Assert. assertEquals ( 1, ret )
************************************
************************************
[+] input: isAvailable_NOTIFICATION_BUBBLESisOff_shouldReturnFalse() { Settings.Global.putInt(mContext.getContentResolver(), NOTIFICATION_BUBBLES, SYSTEM_WIDE_OFF); mController.onResume(mAppRow, null, null, null, null, null);  "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mAppRow == null) { return false; } if (mChannel != null) { if (!isGloballyEnabled()) { return false; } if (isDefaultChannel()) { return true; } else { return mAppRow != null; } } return isGloballyEnabled() && mBackend.hasSentValidMsg(mAppRow.pkg, mAppRow.uid); }
[*] target: assertFalse(mController.isAvailable())
[-] pred: org. junit. Assert. assertFalse ( mController. isAvailable() )
************************************
************************************
[+] input: Exception { Category sub1 = root.createCategory("SubCat-A"); Category s = sub1.createCategory("Sub-cat"); DataTypeManager dtm = s.getDataTypeManager(); "<AssertPlaceHolder>"; assertEquals(dataMgr, dtm); }
getDataTypeManager();
[*] target: assertNotNull(dtm)
[-] pred: org. junit. Assert. assertNotNull ( dtm )
************************************
************************************
[+] input: testGetThreadInfo() { ThreadDomain threadDomain = JvmUtils.getThreadInfo(); "<AssertPlaceHolder>"; log.info(threadDomain.toJsonString()); }
getThreadInfo() { return ThreadDomain.builder() .threadCount(THREADMX_BEAN.getThreadCount()) .peakThreadCount(THREADMX_BEAN.getPeakThreadCount()) .daemonThreadCount(THREADMX_BEAN.getDaemonThreadCount()) .totalStartedThreadCount(THREADMX_BEAN.getTotalStartedThreadCount()) .build(); }
[*] target: assertNotNull(threadDomain)
[-] pred: org. junit. Assert. assertNotNull ( threadDomain )
************************************
************************************
[+] input: testConstructorRoot4() { CategoryPath c = new CategoryPath("/"); assertEquals("/", c.getPath()); assertEquals("", c.getName()); "<AssertPlaceHolder>"; }
isRoot() { // parent can only be null for ROOT return parent == null; }
[*] target: assertTrue(c.isRoot())
[-] pred: org. junit. Assert. assertTrue ( c. isRoot() )
************************************
************************************
[+] input: testGetInstance() { AuthPluginManager instance = AuthPluginManager.getInstance();  Assert."<AssertPlaceHolder>"; }
getInstance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
************************************
[+] input: testIsAvailable_notIfNull() { mController.onResume(null, null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } return mAppRow.settingsIntent != null; }
[*] target: assertFalse(mController.isAvailable())
[-] pred: org. junit. Assert. assertFalse ( mController. isAvailable() )
************************************
************************************
[+] input: MalformedURLException { StringBuilder sb = new StringBuilder(); for (int i = 0; i < 255; i++) { char c = (char) (i & 0xff); sb.append(c); } String orig = sb.toString(); String encoded = FSUtilities.escapeEncode(orig); String decoded = FSUtilities.escapeDecode(encoded); "<AssertPlaceHolder>"; }
toString() { StringBuilder sb = new StringBuilder(); appendToStringBuilder(sb, true, true, true); return sb.toString(); }
[*] target: assertEquals(orig, decoded)
[-] pred: org. junit. Assert. assertEquals ( orig, decoded )
************************************
************************************
[+] input: Exception { JMustacheRenderer jmustacheExt = jmustache(); ContextModel m = new ContextModel("hello"); String expected = """ boo """; /* * JMustache does not support context at the moment. This is just to check the * context gets through the filters. */ jmustacheExt.use(false); Map<String, Object> context = Map.of("message", "boo"); String actual = ContextJStachio.of(JStachio.of()) .execute(m, ContextNode.of(context::get), Output.of(new StringBuilder())).toString(); "<AssertPlaceHolder>"; }
use(boolean flag) { use.set(flag); log(flag); return this; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testDeleteApiDestination() { Mockito.when(apiDestinationRepository.getApiDestination(any(), any())).thenReturn(new ApiDestinationDTO()); final Boolean aBoolean = apiDestinationService.deleteApiDestination(UUID.randomUUID().toString(), UUID.randomUUID().toString()); Assert."<AssertPlaceHolder>"; }
deleteApiDestination(String accountId, String apiDestinationName) { if (checkApiDestination(accountId, apiDestinationName) == null) { throw new EventBridgeException(EventBridgeErrorCode.ApiDestinationNotExist, apiDestinationName); } return apiDestinationRepository.deleteApiDestination(accountId, apiDestinationName); }
[*] target: assertTrue(aBoolean)
[-] pred: org. junit. Assert. assertTrue ( aBoolean )
************************************
************************************
[+] input: testJoinQueryParametersWithLocaleIT() {  Locale.setDefault(new Locale("it", "IT"));  String joinedQuery = String.format("key1=%s&key2=%s", extensiveDecimalsDouble, highDouble); String buildQuery = UrlBuilder.joinQueryParameters(mockDoubleParameters); "<AssertPlaceHolder>"; }
joinQueryParameters(LinkedHashMap<String, Object> parameters) { return joinQueryParameters(new StringBuilder(), parameters).toString(); }
[*] target: assertEquals(joinedQuery, buildQuery)
[-] pred: org. junit. Assert. assertEquals ( joinedQuery, buildQuery )
************************************
************************************
[+] input: testSouthSouthNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 10);  TestSuiteChromosome exepcted_individual = population.get(2); TestSuiteChromosome returned_individual = neighbors.get(9);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testHandle() { String dataId = "dataId"; String group = "group"; String tenant = "tenant"; String groupKey = GroupKey2 .getKey(dataId, group, tenant); groupKey = StringPool.get(groupKey); when(ConfigCacheService.isUptodate(eq(groupKey), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(false); ConfigBatchListenRequest configChangeListenRequest = new ConfigBatchListenRequest(); configChangeListenRequest.addConfigListenContext(group, dataId, tenant, " "); try { ConfigChangeBatchListenResponse configChangeBatchListenResponse = configQueryRequestHandler .handle(configChangeListenRequest, requestMeta); boolean hasChange = false; for (ConfigChangeBatchListenResponse.ConfigContext changedConfig : configChangeBatchListenResponse.getChangedConfigs()) { if (changedConfig.getDataId().equals(dataId)) { hasChange = true; break; } } "<AssertPlaceHolder>"; } catch (NacosException e) { e.printStackTrace(); } }
handle(ConfigBatchListenRequest configChangeListenRequest, RequestMeta meta) throws NacosException { String connectionId = StringPool.get(meta.getConnectionId()); String tag = configChangeListenRequest.getHeader(Constants.VIPSERVER_TAG);  ConfigChangeBatchListenResponse configChangeBatchListenResponse = new ConfigChangeBatchListenResponse(); for (ConfigBatchListenRequest.ConfigListenContext listenContext : configChangeListenRequest .getConfigListenContexts()) { String groupKey = GroupKey2 .getKey(listenContext.getDataId(), listenContext.getGroup(), listenContext.getTenant()); groupKey = StringPool.get(groupKey);  String md5 = StringPool.get(listenContext.getMd5());  if (configChangeListenRequest.isListen()) { configChangeListenContext.addListen(groupKey, md5, connectionId); boolean isUptoDate = ConfigCacheService.isUptodate(groupKey, md5, meta.getClientIp(), tag); if (!isUptoDate) { configChangeBatchListenResponse.addChangeConfig(listenContext.getDataId(), listenContext.getGroup(), listenContext.getTenant()); } } else { configChangeListenContext.removeListen(groupKey, connectionId); } }  return configChangeBatchListenResponse;  }
[*] target: assertTrue(hasChange)
[-] pred: org. junit. Assert. assertTrue ( hasChange )
************************************
************************************
[+] input: testExtractDefaultValueEmpty() { String expectDefault = null; List<String> columnSpecs = Arrays.asList("DEFAULT", "comment", null); String actualDefault = schemaManager.extractDefaultValue(DorisType.STRING, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertEquals(expectDefault, actualDefault)
[-] pred: org. junit. Assert. assertEquals ( expectDefault, actualDefault )
************************************
************************************
[+] input: IOException { // prepare File src = temporaryFolder.newFolder("src"); File dest = temporaryFolder.newFolder("dest");  // act contributor.copyToDir(src, dest); log.debug("Destination folder {}: {}", dest, dest.list()); log.debug("Source folder {}: {}", src, src.list());  // check "<AssertPlaceHolder>"; assertTrue(src.exists()); }
copyToDir(File src, File dest) throws IOException { LOGGER.debug( "Copying {} [{}] to directory [{}]", src.isFile() ? "file" : "directory", src.getAbsolutePath(), dest.getAbsolutePath() );  try { helper.copyToDir(src, dest); } catch (FilesHelperException e) { throw (IOException) e.getCause(); } }
[*] target: assertTrue(dest.exists())
[-] pred: org. junit. Assert. assertTrue ( dest. exists ( ) )
************************************
************************************
[+] input: testAsList_Array_Null() {  String[] array = null; List<String> list = CollectionUtils.asList(array); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty ( ) )
************************************
************************************
[+] input: testFormatStringLegacyColor_NoColorCode() { String input = "Hello There Austin"; String expectedResult = "Hello There Austin";  String result = Format.FormatStringLegacyColor(input); "<AssertPlaceHolder>"; }
FormatStringLegacyColor(String string) { String allFormated = string;  allFormated = LEGACY_CHAT_COLOR_PATTERN.matcher(allFormated).replaceAll("\u00A7$13"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[A]", BUKKIT_COLOR_CODE_PREFIX + "a"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[B]", BUKKIT_COLOR_CODE_PREFIX + "b"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[C]", BUKKIT_COLOR_CODE_PREFIX + "c"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[D]", BUKKIT_COLOR_CODE_PREFIX + "d"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[E]", BUKKIT_COLOR_CODE_PREFIX + "e"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[F]", BUKKIT_COLOR_CODE_PREFIX + "f");  allFormated = allFormated.replaceAll("%", "\\%"); return allFormated; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testFilter() { Mockito.when(authConfigs.isAuthEnabled()).thenReturn(true);  Request healthCheckRequest = new HealthCheckRequest();  try { Response healthCheckResponse = remoteRequestAuthFilter .filter(healthCheckRequest, new RequestMeta(), MockRequestHandler.class); Assert."<AssertPlaceHolder>"; } catch (NacosException e) { e.printStackTrace(); Assert.fail(e.getMessage()); } }
filter(Request request, RequestMeta meta, Class handlerClazz) throws NacosException {  try {  Method method = getHandleMethod(handlerClazz); if (method.isAnnotationPresent(Secured.class) && authConfigs.isAuthEnabled()) {  if (Loggers.AUTH.isDebugEnabled()) { Loggers.AUTH.debug("auth start, request: {}", request.getClass().getSimpleName()); }  Secured secured = method.getAnnotation(Secured.class); if (!protocolAuthService.enableAuth(secured)) { return null; } String clientIp = meta.getClientIp(); request.putHeader(Constants.Identity.X_REAL_IP, clientIp); Resource resource = protocolAuthService.parseResource(request, secured); IdentityContext identityContext = protocolAuthService.parseIdentity(request); boolean result = protocolAuthService.validateIdentity(identityContext, resource); if (!result) { // TODO Get reason of failure throw new AccessException("Validate Identity failed."); } String action = secured.action().toString(); result = protocolAuthService.validateAuthority(identityContext, new Permission(resource, action)); if (!result) { // TODO Get reason of failure throw new AccessException("Validate Authority failed."); } } } catch (AccessException e) { if (Loggers.AUTH.isDebugEnabled()) { Loggers.AUTH.debug("access denied, request: {}, reason: {}", request.getClass().getSimpleName(), e.getErrMsg()); } Response defaultResponseInstance = getDefaultResponseInstance(handlerClazz); defaultResponseInstance.setErrorInfo(NacosException.NO_RIGHT, e.getErrMsg()); return defaultResponseInstance; } catch (Exception e) { Response defaultResponseInstance = getDefaultResponseInstance(handlerClazz);  defaultResponseInstance.setErrorInfo(NacosException.SERVER_ERROR, ExceptionUtil.getAllExceptionMsg(e)); return defaultResponseInstance; }  return null; }
[*] target: assertNull(healthCheckResponse)
[-] pred: org. junit. Assert. assertNull ( healthCheckResponse )
************************************
************************************
[+] input: Exception {  Memory memory = program.getMemory(); memory.setBytes(addr(0x2000), new byte[] { (byte) 0xd7, (byte) 05 }); Pointer p = new PointerDataType(); listing.createData(addr(0x2000), p, addr(0x2000).getPointerSize()); Data data = listing.getDataAt(addr(0x2000));  "<AssertPlaceHolder>"; Object obj = data.getValue(); assertNotNull(obj); assertTrue(obj instanceof Address); assertEquals(addr(0xd7050000), obj); }
getDataAt(Address address) { return getDataAt(address, addrMap.getKey(address, false)); }
[*] target: assertNotNull(data)
[-] pred: org. junit. Assert. assertNotNull ( data )
************************************
************************************
[+] input: Exception { createLabel(addr(100), "A"); createLabel(addr(100), "fred"); createLabel(addr(100), "joe"); Namespace scope = st.createNameSpace(null, "MyNamespace", SourceType.USER_DEFINED); createLabel(addr(200), "fred", scope);  Symbol s = st.getSymbol("fred", addr(200), scope); "<AssertPlaceHolder>"; assertEquals("fred", s.getName()); assertTrue(!s.isGlobal()); assertTrue(s.getSource() == SourceType.USER_DEFINED); assertTrue(s.isPrimary()); }
getSymbol(String name, Address address, Namespace namespace) { if (namespace == null) { namespace = program.getGlobalNamespace(); }  if (isDeletedNamespace(namespace)) { return null; } checkValidNamespaceArgument(namespace);  long namespaceId = namespace.getID();  lock.acquire(); try { DBRecord record = adapter.getSymbolRecord(address, name, namespaceId); if (record != null) { return getSymbol(record); } } catch (IOException e) { program.dbError(e); } finally { lock.release(); }  // check for default external symbol if (namespace.isExternal() && SymbolUtilities.isPossibleDefaultExternalName(name)) { return searchNamespaceForSymbol(namespace, name, address); }  // also check for possible default parameter or local variable symbol if (namespace instanceof Function && SymbolUtilities.isPossibleDefaultLocalOrParamName(name)) { return searchNamespaceForSymbol(namespace, name, address); }  // check if name is a default name Symbol symbol = getSymbolForDynamicName(name); if (symbol != null && address.equals(symbol.getAddress()) && namespace.equals(symbol.getParentNamespace())) { return symbol; } return null; }
[*] target: assertNotNull(s)
[-] pred: org. junit. Assert. assertNotNull ( s )
************************************
************************************
[+] input: testGetSuccessfulSyncCount() { long expected = DistroRecordsHolder.getInstance().getSuccessfulSyncCount() + 1; DistroRecordsHolder.getInstance().getRecord("testGetSuccessfulSyncCount").syncSuccess(); "<AssertPlaceHolder>"; }
getSuccessfulSyncCount() { final AtomicLong result = new AtomicLong(); distroRecords.forEach((s, distroRecord) -> result.addAndGet(distroRecord.getSuccessfulSyncCount())); return result.get(); }
[*] target: assertEquals(expected, DistroRecordsHolder.getInstance().getSuccessfulSyncCount())
[-] pred: org. junit. Assert. assertEquals ( expected, DistroRecordsHolder.getInstance ( ). getSuccessfulSyncCount ( ) )
************************************
************************************
[+] input: Exception { DomainFolder aFolder = fileMgr.getFolder("/a"); "<AssertPlaceHolder>"; aFolder.getFolders(); // visit folder to receive change events for it  sharedFS.renameFolder("/a", "y", "bigY"); flushFileSystemEvents(); // wait for FileSystemListener callback to update folder  assertEventsSize(2); checkEvent(events.get(0), "Folder Removed", "/a", null, null, null, "y"); checkEvent(events.get(1), "Folder Added", null, "/a/bigY", null, null, null);  }
getFolder(String path) { int len = path.length(); if (len == 0 || path.charAt(0) != FileSystem.SEPARATOR_CHAR) { throw new IllegalArgumentException( "Absolute path must begin with '" + FileSystem.SEPARATOR_CHAR + "'"); } try { return getRootFolder().getFolderPathData(path).getDomainFolder(); } catch (FileNotFoundException e) { return null; } }
[*] target: assertNotNull(aFolder)
[-] pred: org. junit. Assert. assertNotNull ( aFolder )
************************************
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); //when boolean ret = nacosClientAuthService.login(properties); //then Assert."<AssertPlaceHolder>"; }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (StringUtils.isNotBlank(identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN))) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred: org. junit. Assert. assertTrue ( ret )
************************************
************************************
[+] input: testAsList_List_Null() {  List<String> list = null; list = CollectionUtils.asList(list); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: Exception {  String mangled = "_ZZNK4entt14basic_registryI8EntityIdE6assureI32FilteredTransformationAttributesI26PreHillsEdgeTransformationEEERKNS2_12pool_handlerIT_EEvENKUlRNS_10sparse_setIS1_EERS2_S1_E_cvPFvSE_SF_S1_EEv"; String demangled = process.demangle(mangled);  /*  Full demangled:  Operator Text  entt:: basic_registry<EntityId>:: assure<FilteredTransformationAttributes<PreHillsEdgeTransformation> >() const:: {lambda(entt::sparse_set<EntityId>&, entt::basic_registry<EntityId>&, EntityId)#1}:: operator void (*)(entt::sparse_set<EntityId>&, entt::basic_registry<EntityId>&, EntityId)() const  Operartor Without Namespace  operator void (*)(entt::sparse_set<EntityId>&, entt::basic_registry<EntityId>&, EntityId)()  Simplified Cast Operator Construct  operator void (*)(A,B,C)()  */  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  //@formatter:off String expected = "void (* " + "entt::" + "basic_registry::" + "assure() const::" + "{lambda(entt::sparse_set&,entt::basic_registry&,EntityId)#1}::" + "operator.cast.to.function.pointer(void)" + ")(entt::sparse_set<EntityId> &,entt::basic_registry<EntityId> &,EntityId)"; //@formatter:on String signature = object.getSignature(false); assertEquals(expected, signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: UnmodifiableClassException { final byte[] classBytes = new byte[10]; final ClassFileSaveTransformer[] classFileSaveTransformer = new ClassFileSaveTransformer[1]; final Class<?> targetClass = String.class; Mockito.doAnswer(new Answer<Void>() { @Override public Void answer(final InvocationOnMock invocation) { classFileSaveTransformer[0] = invocation.getArgument(0, ClassFileSaveTransformer.class); return null; } }) .when(instrumentation) .addTransformer(ArgumentMatchers.any(ClassFileTransformer.class), ArgumentMatchers.anyBoolean()); Mockito.doAnswer(new Answer<Void>() { @Override public Void answer(final InvocationOnMock invocation) { classFileSaveTransformer[0].transform(targetClass.getClassLoader(), targetClass.getName(), targetClass, targetClass.getProtectionDomain(), classBytes); return null; } }).when(instrumentation).retransformClasses(ArgumentMatchers.any(Class.class));  final byte[] classBytesResult = instrumentationHelper.getClassBytes(targetClass);  Assert."<AssertPlaceHolder>"; }
getClassBytes(Class<?> klass) { final ClassFileSaveTransformer transformer = new ClassFileSaveTransformer(klass.getName()); instrumentation.addTransformer(transformer, true); try { instrumentation.retransformClasses(klass); } catch (InternalError e) { // This provides a better error message if there is a linking problem try { klass.getDeclaredFields(); } catch (NoClassDefFoundError error) { Log.warn("Problem linking class while retransforming", error); // Let's return an empty array so if we are exporting it doesn't fail. return new byte[0]; } throw e; } catch (Exception e) { Log.warn("Encountered exception retransforming classes", e); } finally { instrumentation.removeTransformer(transformer); } return transformer.getBytes() != null ? transformer.getBytes() : new byte[0]; }
[*] target: assertEquals(classBytes, classBytesResult)
[-] pred: org. junit. Assert. assertEquals ( classBytes, classBytesResult )
************************************
************************************
[+] input: Exception { selectRow(3); JButton upButton = findButtonByIcon(pathManager.getComponent(), ResourceManager.loadImage("images/up.png")); "<AssertPlaceHolder>"; pressButton(upButton, true); waitForSwing();  int row = table.getSelectedRow(); assertEquals(2, row); assertEquals(new Path("c:\\path_four"), table.getModel().getValueAt(row, 1));  pressButton(upButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(1, row); assertEquals(new Path("c:\\path_four"), table.getModel().getValueAt(row, 1));  pressButton(upButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(0, row); assertEquals(new Path("c:\\path_four"), table.getModel().getValueAt(row, 1));  pressButton(upButton, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(3, row); assertEquals(new Path("c:\\path_four"), table.getModel().getValueAt(row, 1)); }
getComponent() { return panel; }
[*] target: assertNotNull(upButton)
[-] pred: org. junit. Assert. assertNotNull ( upButton )
************************************
************************************
[+] input: Exception { String[][] records = {{"flink", "1", "true"}, {"doris", "2", "false"}}; SimpleCollector collector = new SimpleCollector(); RowDataDeserializationSchema deserializationSchema = new RowDataDeserializationSchema(PHYSICAL_TYPE); for (String[] record : records) { deserializationSchema.deserialize(Arrays.asList(record), collector); }  List<String> expected = Arrays.asList("+I(flink,1,true)", "+I(doris,2,false)");  List<String> actual = collector.list.stream().map(Object::toString).collect(Collectors.toList()); "<AssertPlaceHolder>"; }
deserialize(List<?> record, Collector<RowData> out) throws Exception { RowData row = rowConverter.convertInternal(record); out.collect(row); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetComponent() { Structure struct = createStructure("struct_1", 0); struct.add(new ByteDataType()); struct.add(new StringDataType(), 10); DataTypeComponent newdtc = union.add(struct, "field5", "comments"); DataTypeComponent dtc = union.getComponent(4); "<AssertPlaceHolder>"; assertEquals("field5", dtc.getFieldName()); assertEquals("comments", dtc.getComment());  }
getComponent(int ordinal) { lock.acquire(); try { checkIsValid(); if (ordinal < 0 || ordinal >= components.size()) { return null; } return components.get(ordinal); } finally { lock.release(); } }
[*] target: assertEquals(newdtc, dtc)
[-] pred: org. junit. Assert. assertEquals ( newdtc, dtc )
************************************
************************************
[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setFloat(4, 3.14f); int result = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: shouldFilterMediaNotificationWhenDisabled() { // GIVEN that the media feature is disabled when(mMediaFeatureFlag.getEnabled()).thenReturn(false); NotificationFilter filter = new NotificationFilter(mStatusBarStateController, mMediaFeatureFlag); // WHEN the media filter is asked about a media entry final boolean shouldFilter = filter.shouldFilterOut(mMediaEntry); // THEN it shouldn't be filtered "<AssertPlaceHolder>"; }
shouldFilterOut(NotificationEntry entry) { final StatusBarNotification sbn = entry.getSbn(); if (!(getEnvironment().isDeviceProvisioned() || showNotificationEvenIfUnprovisioned(sbn))) { return true; }  if (!getEnvironment().isNotificationForCurrentProfiles(sbn)) { return true; }  if (getUserManager().isLockscreenPublicMode(sbn.getUserId()) && (sbn.getNotification().visibility == Notification.VISIBILITY_SECRET || getUserManager().shouldHideNotifications(sbn.getUserId()) || getUserManager().shouldHideNotifications(sbn.getKey()))) { return true; }  if (mStatusBarStateController.isDozing() && entry.shouldSuppressAmbient()) { return true; }  if (!mStatusBarStateController.isDozing() && entry.shouldSuppressNotificationList()) { return true; }  if (entry.getRanking().isSuspended()) { return true; }  if (getFsc().isDisclosureNotification(sbn) && !getFsc().isDisclosureNeededForUser(sbn.getUserId())) { // this is a foreground-service disclosure for a user that does not need to show one return true; } if (getFsc().isSystemAlertNotification(sbn)) { final String[] apps = sbn.getNotification().extras.getStringArray( Notification.EXTRA_FOREGROUND_APPS); if (apps != null && apps.length >= 1) { if (!getFsc().isSystemAlertWarningNeeded(sbn.getUserId(), apps[0])) { return true; } } }  if (mIsMediaFlagEnabled && isMediaNotification(sbn)) { return true; } return false; }
[*] target: assertFalse(shouldFilter)
[-] pred: org. junit. Assert. assertFalse ( shouldFilter )
************************************
************************************
[+] input: Exception { Assume.assumeFalse(TinkFips.useOnlyFips());  JsonObject json = WycheproofTestUtil.readJson("../wycheproof/testvectors/aes_eax_test.json"); int errors = 0; int cntSkippedTests = 0; JsonArray testGroups = json.getAsJsonArray("testGroups"); for (int i = 0; i < testGroups.size(); i++) { JsonObject group = testGroups.get(i).getAsJsonObject(); int keySize = group.get("keySize").getAsInt(); int ivSize = group.get("ivSize").getAsInt(); JsonArray tests = group.getAsJsonArray("tests"); if (!Arrays.asList(keySizeInBytes).contains(keySize / 8) || !Arrays.asList(ivSizeInBytes).contains(ivSize / 8)) { cntSkippedTests += tests.size(); continue; } for (int j = 0; j < tests.size(); j++) { JsonObject testcase = tests.get(j).getAsJsonObject(); String tcId = String.format( "testcase %d (%s)", testcase.get("tcId").getAsInt(), testcase.get("comment").getAsString()); byte[] iv = Hex.decode(testcase.get("iv").getAsString()); byte[] key = Hex.decode(testcase.get("key").getAsString()); byte[] msg = Hex.decode(testcase.get("msg").getAsString()); byte[] aad = Hex.decode(testcase.get("aad").getAsString()); byte[] ct = Hex.decode(testcase.get("ct").getAsString()); byte[] tag = Hex.decode(testcase.get("tag").getAsString()); byte[] ciphertext = Bytes.concat(iv, ct, tag); String result = testcase.get("result").getAsString(); try { AesEaxJce eax = new AesEaxJce(key, iv.length); byte[] decrypted = eax.decrypt(ciphertext, aad); boolean eq = TestUtil.arrayEquals(decrypted, msg); if (result.equals("invalid")) { System.out.printf( "FAIL %s: accepting invalid ciphertext, cleartext: %s, decrypted: %s%n", tcId, Hex.encode(msg), Hex.encode(decrypted)); errors++; } else { if (!eq) { System.out.printf( "FAIL %s: incorrect decryption, result: %s, expected: %s%n", tcId, Hex.encode(decrypted), Hex.encode(msg)); errors++; } } } catch (GeneralSecurityException ex) { if (result.equals("valid")) { System.out.printf("FAIL %s: cannot decrypt, exception %s%n", tcId, ex); errors++; } } } } System.out.printf("Number of tests skipped: %d", cntSkippedTests); "<AssertPlaceHolder>"; }
decrypt(final byte[] ciphertext, final byte[] associatedData) throws GeneralSecurityException { int plaintextLength = ciphertext.length - outputPrefix.length - ivSizeInBytes - TAG_SIZE_IN_BYTES; if (plaintextLength < 0) { throw new GeneralSecurityException("ciphertext too short"); } if (!isPrefix(outputPrefix, ciphertext)) { throw new GeneralSecurityException("Decryption failed (OutputPrefix mismatch)."); } Cipher ecb = localEcbCipher.get(); ecb.init(Cipher.ENCRYPT_MODE, keySpec); byte[] n = omac(ecb, 0, ciphertext, outputPrefix.length, ivSizeInBytes); byte[] aad = associatedData; if (aad == null) { aad = new byte[0]; } byte[] h = omac(ecb, 1, aad, 0, aad.length); byte[] t = omac(ecb, 2, ciphertext, outputPrefix.length + ivSizeInBytes, plaintextLength); byte res = 0; int offset = ciphertext.length - TAG_SIZE_IN_BYTES; for (int i = 0; i < TAG_SIZE_IN_BYTES; i++) { res = (byte) (res | (ciphertext[offset + i] ^ h[i] ^ n[i] ^ t[i])); } if (res != 0) { throw new AEADBadTagException("tag mismatch"); } Cipher ctr = localCtrCipher.get(); ctr.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(n)); return ctr.doFinal(ciphertext, outputPrefix.length + ivSizeInBytes, plaintextLength); }
[*] target: assertEquals(0, errors)
[-] pred: org. junit. Assert. assertEquals ( 0, errors )
************************************
************************************
[+] input: testIsAvailable_notIfNull() { mController.onResume(null, null, null, null, null, null); "<AssertPlaceHolder>"; }
isAvailable() { if (!super.isAvailable()) { return false; } if (mChannel == null && !hasValidGroup()) { return false; } if (mChannel != null && !TextUtils.isEmpty(mChannel.getDescription())) { return true; } if (hasValidGroup() && !TextUtils.isEmpty(mChannelGroup.getDescription())) { return true; } return false; }
[*] target: assertFalse(mController.isAvailable())
[-] pred: org. junit. Assert. assertFalse ( mController. isAvailable() )
************************************
************************************
[+] input: Exception { Enum enumm = new EnumDataType("Color", 1); enumm.add("Red", 10); enumm.add("Green", 15); enumm.add("Blue", 20); Category root = dataMgr.getRootCategory(); Category c = root.createCategory("enumms"); Enum enummDT = (Enum) c.addDataType(enumm, DataTypeConflictHandler.DEFAULT_HANDLER); "<AssertPlaceHolder>";  c.remove(enummDT, TaskMonitor.DUMMY); assertNull(c.getDataType("Color"));  assertTrue(enummDT.isDeleted());  }
add(String name, long value);
[*] target: assertNotNull(enummDT)
[-] pred: org. junit. Assert. assertNotNull ( enummDT )
************************************
************************************
[+] input: testConvertHexColorCodeStringToBukkitColorCodeString() { String input = "#ff00ffHello" + BUKKIT_COLOR_CODE_PREFIX + "cThere#00ff00Austin"; String expectedResult = BUKKIT_COLOR_CODE_PREFIX + "x" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "fHello" + BUKKIT_COLOR_CODE_PREFIX + "cThere" + BUKKIT_COLOR_CODE_PREFIX + "x" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "0Austin";  String result = Format.convertHexColorCodeStringToBukkitColorCodeString(input); "<AssertPlaceHolder>"; }
convertHexColorCodeStringToBukkitColorCodeString(String string) { Pattern pattern = Pattern.compile("(&?#[0-9a-fA-F]{6})"); Matcher matcher = pattern.matcher(string); while (matcher.find()) { int indexStart = matcher.start(); int indexEnd = matcher.end(); String hexColor = string.substring(indexStart, indexEnd); String bukkitColor = convertHexColorCodeToBukkitColorCode(hexColor); string = string.replaceAll(hexColor, bukkitColor); matcher.reset(string); } return string; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost"); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>"; }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (StringUtils.isNotBlank(identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN))) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred: org. junit. Assert. assertTrue ( ret )
************************************
************************************
[+] input: SQLException { ParameterMetaData parameterMetaData = pstmt_insert.getParameterMetaData(); Assert."<AssertPlaceHolder>"; //TODO: modify the test case }
getParameterMetaData() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); //        throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_UNSUPPORTED_METHOD);  return this.parameterMetaData; }
[*] target: assertNotNull(parameterMetaData)
[-] pred: org. junit. Assert. assertNotNull ( parameterMetaData )
************************************
************************************
[+] input: testFindDefaultAssetProfile() { AssetProfile foundDefaultAssetProfile = assetProfileService.findDefaultAssetProfile(tenantId); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(foundDefaultAssetProfile.getId()); Assert.assertNotNull(foundDefaultAssetProfile.getName()); }
findDefaultAssetProfile(TenantId tenantId);
[*] target: assertNotNull(foundDefaultAssetProfile)
[-] pred: org. junit. Assert. assertNotNull ( foundDefaultAssetProfile )
************************************
************************************
[+] input: testWestNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.linearFive(population, 5);  TestSuiteChromosome exepcted_individual = population.get(4); TestSuiteChromosome returned_individual = neighbors.get(3);  "<AssertPlaceHolder>"; }
linearFive(List<T> collection, int position) { _N = neighbour[position][Positions.N.ordinal()]; _S = neighbour[position][Positions.S.ordinal()]; _E = neighbour[position][Positions.E.ordinal()]; _W = neighbour[position][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testSplitWithoutMaxNewlineAtBeginningAndEndOnly() { List<String> lines = HtmlLineSplitter.split("\nabcdefghi\n", 0); "<AssertPlaceHolder>"; assertEquals("", lines.get(0)); assertEquals("abcdefghi", lines.get(1)); assertEquals("", lines.get(2)); }
split(String text, int maxLineLength) { return split(text, maxLineLength, false); }
[*] target: assertEquals(3, lines.size())
[-] pred: org. junit. Assert. assertEquals ( 3, lines. size ( ) )
************************************
************************************
[+] input: testAsList_Collection_FromNull() {  List<String> list = CollectionUtils.asList((Collection<String>) null); assertNotNull(list); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: Exception { Enum enumm = new EnumDataType("Color", 1); enumm.add("Red", 10); enumm.add("Green", 15); enumm.add("Blue", 20); Category root = dataMgr.getRootCategory(); Category c = root.createCategory("enumms"); Enum enummDT = (Enum) c.addDataType(enumm, DataTypeConflictHandler.DEFAULT_HANDLER);  Enum copyDT = (Enum) enummDT.clone(null); "<AssertPlaceHolder>";  Enum c2 = (Enum) root.addDataType(copyDT, DataTypeConflictHandler.DEFAULT_HANDLER); assertNotNull(c2); assertTrue(copyDT.isEquivalent(c2)); }
add(String name, long value);
[*] target: assertNotNull(copyDT)
[-] pred: org. junit. Assert. assertNotNull ( copyDT )
************************************
************************************
[+] input: testConvertHexColorCodeToBukkitColorCode() { String hexColor = "#ff00ff"; String expectedResult = BUKKIT_COLOR_CODE_PREFIX + "x" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "0" + BUKKIT_COLOR_CODE_PREFIX + "f" + BUKKIT_COLOR_CODE_PREFIX + "f";  String result = Format.convertHexColorCodeToBukkitColorCode(hexColor); "<AssertPlaceHolder>"; }
convertHexColorCodeToBukkitColorCode(String color) { color = color.replace("&", ""); StringBuilder bukkitColorCode = new StringBuilder(BUKKIT_COLOR_CODE_PREFIX + BUKKIT_HEX_COLOR_CODE_PREFIX); for (int a = 1; a < color.length(); a++) { bukkitColorCode.append(BUKKIT_COLOR_CODE_PREFIX + color.charAt(a)); } return bukkitColorCode.toString().toLowerCase(); }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testFindDefaultAssetProfileInfo() { AssetProfileInfo foundDefaultAssetProfileInfo = assetProfileService.findDefaultAssetProfileInfo(tenantId); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(foundDefaultAssetProfileInfo.getId()); Assert.assertNotNull(foundDefaultAssetProfileInfo.getName()); }
findDefaultAssetProfileInfo(TenantId tenantId);
[*] target: assertNotNull(foundDefaultAssetProfileInfo)
[-] pred: org. junit. Assert. assertNotNull ( foundDefaultAssetProfileInfo )
************************************
************************************
[+] input: Exception { AddressSet set = new AddressSet(); set.addRange(getAddr(0), getAddr(0x200)); set.addRange(getAddr(0x205), getAddr(0x1000)); set.addRange(getAddr(0x5000), getAddr(0x6001));  IntRangeMap map = program.createIntRangeMap("MyMap"); int value = 0x11223344; map.setValue(set, value);  AddressSet s = new AddressSet(); s.addRange(getAddr(5), getAddr(0x6000));  map.clearValue(s);  s = set.subtract(new AddressSet(getAddr(5), getAddr(0x6000))); AddressSet resultSet = map.getAddressSet(); "<AssertPlaceHolder>"; }
getAddressSet();
[*] target: assertEquals(s, resultSet)
[-] pred: org. junit. Assert. assertEquals ( s, resultSet )
************************************
************************************
[+] input: testIterator2() { for (int i = 0; i < 10000; i++) { ps.putString(i, "" + i); } LongIterator it = ps.getPropertyIterator(); int i = 0; while (it.hasNext()) { long l = it.next(); "<AssertPlaceHolder>"; i++; } assertEquals(i, 10000); }
putString(long index, String value) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.addString(getPageOffset(index), value); numProperties += page.getSize() - n; }
[*] target: assertEquals(i, l)
[-] pred: org. junit. Assert. assertEquals ( i, l )
************************************
************************************
[+] input: testMostSouthEastNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 15);  TestSuiteChromosome exepcted_individual = population.get(0); TestSuiteChromosome returned_individual = neighbors.get(7);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: notificationDataEntry_testIsLastMessageFromReply() { Person.Builder person = new Person.Builder() .setName("name") .setKey("abc") .setUri("uri") .setBot(true);  // EXTRA_MESSAGING_PERSON is the same Person as the sender in last message in EXTRA_MESSAGES Bundle bundle = new Bundle(); bundle.putParcelable(Notification.EXTRA_MESSAGING_PERSON, person.build()); Bundle[] messagesBundle = new Bundle[]{new Notification.MessagingStyle.Message( "text", 0, person.build()).toBundle()}; bundle.putParcelableArray(Notification.EXTRA_MESSAGES, messagesBundle);  Notification notification = new Notification.Builder(mContext, "test") .addExtras(bundle) .build();  NotificationEntry entry = new NotificationEntryBuilder() .setPkg("pkg") .setOpPkg("pkg") .setTag("tag") .setNotification(notification) .setUser(mContext.getUser()) .setOverrideGroupKey("") .build(); entry.setHasSentReply();  "<AssertPlaceHolder>"; }
isLastMessageFromReply() { if (!hasSentReply) { return false; } Bundle extras = mSbn.getNotification().extras; RemoteInputHistoryItem[] replyTexts = (RemoteInputHistoryItem[]) extras.getParcelableArray( Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS); if (!ArrayUtils.isEmpty(replyTexts)) { return true; } List<Message> messages = Message.getMessagesFromBundleArray( extras.getParcelableArray(Notification.EXTRA_MESSAGES)); if (messages != null && !messages.isEmpty()) { Message lastMessage = messages.get(messages.size() -1);  if (lastMessage != null) { Person senderPerson = lastMessage.getSenderPerson(); if (senderPerson == null) { return true; } Person user = extras.getParcelable(Notification.EXTRA_MESSAGING_PERSON); return Objects.equals(user, senderPerson); } } return false; }
[*] target: assertTrue(entry.isLastMessageFromReply())
[-] pred: org. junit. Assert. assertTrue ( entry. isLastMessageFromReply ( ) )
************************************
************************************
[+] input: testReplaceFailure() {// bigger, no space below DataTypeComponent dtc = null; try { dtc = struct.replace(0, new QWordDataType(), 8); } catch (IllegalArgumentException e) { // Not enough undefined bytes so should throw this. } "<AssertPlaceHolder>"; }
replace(int index, DataType dataType, int length) { return replace(index, dataType, length, null, null); }
[*] target: assertNull(dtc)
[-] pred: org. junit. Assert. assertNull ( dtc )
************************************
************************************
[+] input: IOException { // prepare File src = new File(temporaryFolder.newFolder("src"), "test.dat"); src.createNewFile(); File dest = new File(temporaryFolder.newFolder("dest"), "renamed.dat");  // act contributor.copyToFile(src, dest); log.debug("Destination file {}: {}", dest, dest.exists() ? "exists" : "not exists"); log.debug("Source file {}: {}", src, src.exists() ? "exists" : "not exists");  // check "<AssertPlaceHolder>"; assertTrue(src.exists()); }
copyToFile(File src, File dest) throws IOException { LOGGER.debug( "Copying {} [{}] to file [{}]", src.isFile() ? "file" : "directory", src.getAbsolutePath(), dest.getAbsolutePath() );  try { helper.copyToFile(src, dest); } catch (FilesHelperException e) { throw (IOException) e.getCause(); } }
[*] target: assertTrue(dest.exists())
[-] pred: org. junit. Assert. assertTrue ( dest. exists ( ) )
************************************
************************************
[+] input: testCreateNewTemplate() { OAuth2ClientRegistrationTemplate clientRegistrationTemplate = validClientRegistrationTemplate(UUID.randomUUID().toString()); OAuth2ClientRegistrationTemplate savedClientRegistrationTemplate = oAuth2ConfigTemplateService.saveClientRegistrationTemplate(clientRegistrationTemplate);  Assert."<AssertPlaceHolder>"; Assert.assertNotNull(savedClientRegistrationTemplate.getId()); clientRegistrationTemplate.setId(savedClientRegistrationTemplate.getId()); clientRegistrationTemplate.setCreatedTime(savedClientRegistrationTemplate.getCreatedTime()); Assert.assertEquals(clientRegistrationTemplate, savedClientRegistrationTemplate); }
saveClientRegistrationTemplate(OAuth2ClientRegistrationTemplate clientRegistrationTemplate);
[*] target: assertNotNull(savedClientRegistrationTemplate)
[-] pred: org. junit. Assert. assertNotNull ( savedClientRegistrationTemplate )
************************************
************************************
[+] input: test_getGraynessValue_fixedR() { // given int red = 67, green = 255, blue = 184;  // when FixedGrayingStrategy strategy = new FixedGrayingStrategy(FixedGrayingStrategy.FixedOption.R); int graynessValue = strategy.getGraynessValue(red, green, blue);  // then Assert."<AssertPlaceHolder>"; }
getGraynessValue(int r, int g, int b) { return fo.chose(r, g, b); }
[*] target: assertEquals(red, graynessValue)
[-] pred: org. junit. Assert. assertEquals ( red, graynessValue )
************************************
************************************
[+] input: testExtractDefaultValueA() { String expectDefault = "aaa"; List<String> columnSpecs = Arrays.asList("default", "aaa"); String actualDefault = schemaManager.extractDefaultValue(DorisType.STRING, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertEquals(expectDefault, actualDefault)
[-] pred: org. junit. Assert. assertEquals ( expectDefault, actualDefault )
************************************
************************************
[+] input: Exception {  // // The demangled string contains this string: {default arg#1} // String mangled = "_ZZN12PackManifest18CapabilityRegistry18registerCapabilityEN3gsl17basic_string_spanIKcLln1EEEbSt8functionIFbRS_R10PackReportbEEEd_NKUlS6_S8_bE_clES6_S8_b";  String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals( "PackManifest::CapabilityRegistry::registerCapability(gsl::basic_string_span<char_const,-1l>,bool,std::function<bool(PackManifest&,PackReport&,bool)>)::{default arg#1}::{lambda(PackManifest&,PackReport&,bool)#1}::operator()(PackManifest &,PackReport &,bool)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: load() { AviatorFunctionLoader.load(); AviatorFunction function = AviatorEvaluator.getFunction("time.plusDay"); System.out.println(function); "<AssertPlaceHolder>"; String exp = "time.plusDay(num,date)"; Expression expression = AviatorEvaluator.compile(exp, true); Map<String, Object> env = new HashMap<>(); env.put("num", 5); env.put("date", DateTimeUtils.formatDate(new Date(), DateTimeUtils.DEFAULT_DATE_PATTERN)); System.out.println(env); Object v = expression.execute(env); System.out.println(v); }
load() { if (loaded) { return; } try { AviatorEvaluator.addStaticFunctions("time", Dcal.class); AviatorEvaluator.addStaticFunctions("time", Dtcal.class); AviatorEvaluator.addStaticFunctions("time", Tcal.class); AviatorEvaluator.addStaticFunctions("ts", Tscal.class); AviatorEvaluator.addStaticFunctions("time", DtDiff.class); AviatorEvaluator.addStaticFunctions("time", TF.class); AviatorEvaluator.addStaticFunctions("ts", TsDiff.class); AviatorEvaluator.addStaticFunctions("ts", Ts.class); AviatorEvaluator.addStaticFunctions("ts", TsEx.class); AviatorEvaluator.addStaticFunctions("regular", Regular.class); AviatorEvaluator.addStaticFunctions("af", UdafCount.class); AviatorEvaluator.addStaticFunctions("af", UdafSum.class); AviatorEvaluator.addStaticFunctions("af", UdafAvg.class); } catch (IllegalAccessException | NoSuchMethodException e) { logger.error(e.getMessage(), e); } loaded = true; }
[*] target: assertNotNull(function)
[-] pred: org. junit. Assert. assertNotNull ( function )
************************************
************************************
[+] input: testDeleteWidgetsBundle() { WidgetsBundle widgetsBundle = new WidgetsBundle(); widgetsBundle.setTenantId(tenantId); widgetsBundle.setTitle("My widgets bundle"); WidgetsBundle savedWidgetsBundle = widgetsBundleService.saveWidgetsBundle(widgetsBundle); WidgetsBundle foundWidgetsBundle = widgetsBundleService.findWidgetsBundleById(tenantId, savedWidgetsBundle.getId()); Assert.assertNotNull(foundWidgetsBundle); widgetsBundleService.deleteWidgetsBundle(tenantId, savedWidgetsBundle.getId()); foundWidgetsBundle = widgetsBundleService.findWidgetsBundleById(tenantId, savedWidgetsBundle.getId()); Assert."<AssertPlaceHolder>"; }
findWidgetsBundleById(TenantId tenantId, WidgetsBundleId widgetsBundleId);
[*] target: assertNull(foundWidgetsBundle)
[-] pred: org. junit. Assert. assertNull ( foundWidgetsBundle )
************************************
************************************
[+] input: testGetEventTypeRecorderSyncTapDataEvent3() { List<TapdataEvent> list = new ArrayList<>(); TapdataEvent event = new TapdataEvent(); event.setTapEvent(tapEvent); event.setSourceTime(System.nanoTime()); list.add(event); handler = new SyncGetMemorySizeHandler(new AtomicLong(100)); HandlerUtil.EventTypeRecorder recorder = handler.getEventTypeRecorderSyncTapDataEvent(list); Assert."<AssertPlaceHolder>"; Assert.assertEquals(100, recorder.getMemorySize()); }
getEventTypeRecorderSyncTapDataEvent(List<TapdataEvent> events) { if (null == events) events = new ArrayList<>(); if (null == memorySize) return HandlerUtil.countTapdataEvent(events); HandlerUtil.EventTypeRecorder recorder; synchronized (memorySize) { if (memorySize.get() >= 0) { recorder = HandlerUtil.countTapDataEvent(events, memorySize.get()); memorySize.set(-1); } else { recorder = HandlerUtil.countTapdataEvent(events); memorySize.set(recorder.getMemorySize()); } } return recorder; }
[*] target: assertNotNull(recorder)
[-] pred: org. junit. Assert. assertNotNull ( recorder )
************************************
************************************
[+] input: testGetRemoteExecutorTimesOfProcessors() { int defaultExpectVal = 1 << 4; int defaultVal = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert.assertEquals(defaultExpectVal, defaultVal);  System.setProperty("remote.executor.times.of.processors", "10"); int val1 = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert.assertEquals(10, val1);  System.setProperty("remote.executor.times.of.processors", "-1"); int val2 = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert."<AssertPlaceHolder>"; }
getRemoteExecutorTimesOfProcessors() { String timesString = System.getProperty("remote.executor.times.of.processors"); if (NumberUtils.isDigits(timesString)) { int times = Integer.parseInt(timesString); return times > 0 ? times : REMOTE_EXECUTOR_TIMES_OF_PROCESSORS; } else { return REMOTE_EXECUTOR_TIMES_OF_PROCESSORS; } }
[*] target: assertEquals(defaultExpectVal, val2)
[-] pred: org. junit. Assert. assertEquals ( defaultExpectVal, val2 )
************************************
************************************
[+] input: ProtocolException { BAOStreamBuilder builder = new BAOStreamBuilder(); ByteArrayInputStream istream = builder.getStream(); MockConnection connection = new MockConnection(istream); Proto proto = ProtocolSelector.getProto(connection, null, null); "<AssertPlaceHolder>"; }
getProto( ServerConnection connection, AndroidUtils utils, StatusNotifier notifier) throws ProtocolException { if (connection == null) { return null; } byte[] proto_v = {PROTO_MAX}; if (connection.send(proto_v)) { return null; } if (connection.receive(proto_v)) { return null; } int selectedProto = PROTO_MAX; if (proto_v[0] == ProtocolSelector.PROTOCOL_OBSOLETE) { throw new ProtocolException("Obsolete client"); } else if (proto_v[0] == ProtocolSelector.PROTOCOL_UNKNOWN) { byte[] serverProto = new byte[1]; if (connection.receive(serverProto)) { return null; } byte serverMaxProto = serverProto[0]; if (serverMaxProto < PROTO_MIN) { serverProto[0] = 0; connection.send(serverProto); throw new ProtocolException("Obsolete server"); } if (acceptProto(connection, serverMaxProto)) { return null; } selectedProto = serverMaxProto; } else if (proto_v[0] != ProtocolSelector.PROTOCOL_SUPPORTED) { return null; } switch (selectedProto) { case 1: return new Proto_v1(connection, utils, notifier); case 2: return new Proto_v2(connection, utils, notifier); case 3: return new Proto_v3(connection, utils, notifier); default: throw new ProtocolException("Unknown protocol"); } }
[*] target: assertNull(proto)
[-] pred: org. junit. Assert. assertNull ( proto )
************************************
************************************
[+] input: Exception { WorkflowSummary oldWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); oldWorkflow.setStatus(WorkflowStatus.RUNNING); oldWorkflow.setUpdateTime(getFormattedTime(new DateTime().minusHours(2).toDate()));  WorkflowSummary recentWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); recentWorkflow.setStatus(WorkflowStatus.RUNNING); recentWorkflow.setUpdateTime(getFormattedTime(new DateTime().minusHours(1).toDate()));  WorkflowSummary tooRecentWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); tooRecentWorkflow.setStatus(WorkflowStatus.RUNNING); tooRecentWorkflow.setUpdateTime(getFormattedTime(new DateTime().toDate()));  indexDAO.indexWorkflow(oldWorkflow); indexDAO.indexWorkflow(recentWorkflow); indexDAO.indexWorkflow(tooRecentWorkflow);  Thread.sleep(1000);  List<String> ids = indexDAO.searchRecentRunningWorkflows(2, 1);  "<AssertPlaceHolder>"; assertEquals(recentWorkflow.getWorkflowId(), ids.get(0)); }
searchRecentRunningWorkflows( int lastModifiedHoursAgoFrom, int lastModifiedHoursAgoTo) { DateTime dateTime = new DateTime(); QueryBuilder q = QueryBuilders.boolQuery() .must( QueryBuilders.rangeQuery("updateTime") .gt(dateTime.minusHours(lastModifiedHoursAgoFrom))) .must( QueryBuilders.rangeQuery("updateTime") .lt(dateTime.minusHours(lastModifiedHoursAgoTo))) .must(QueryBuilders.termQuery("status", "RUNNING"));  SearchResult<String> workflowIds; try { workflowIds = searchObjectIds( workflowIndexName, q, 0, 5000, Collections.singletonList("updateTime:ASC")); } catch (IOException e) { logger.error("Unable to communicate with ES to find recent running workflows", e); return Collections.emptyList(); }  return workflowIds.getResults(); }
[*] target: assertEquals(1, ids.size())
[-] pred: org. junit. Assert. assertEquals ( 1, ids. size ( ) )
************************************
************************************
[+] input: Exception { Map<String, String> param = Maps.newHashMap(); param.put(PacmanSdkConstants.ACCOUNT_ID, "acc123"); param.put(PacmanSdkConstants.REGION, "region123"); param.put(PacmanSdkConstants.RESOURCE_ID, "resou123"); param.put(PacmanSdkConstants.REGION, "region"); Map<String, String> response = PolicyExecutionUtils.getLocalPolicyParam(param, param); "<AssertPlaceHolder>"; }
getLocalPolicyParam(Map<String, String> policyParam, Map<String, String> resource) { Map<String, String> localRuleParam = new HashMap<>(); localRuleParam.putAll(policyParam); localRuleParam.put(PacmanSdkConstants.RESOURCE_ID, resource.get(PacmanSdkConstants.RESOURCE_ID)); if (null != resource.get(PacmanSdkConstants.ACCOUNT_ID)) localRuleParam.put(PacmanSdkConstants.ACCOUNT_ID, resource.get(PacmanSdkConstants.ACCOUNT_ID)); if (null != resource.get(PacmanSdkConstants.ACCOUNT_NAME)) localRuleParam.put(PacmanSdkConstants.ACCOUNT_NAME, resource.get(PacmanSdkConstants.ACCOUNT_NAME)); if (null != resource.get(PacmanSdkConstants.REGION)) localRuleParam.put(PacmanSdkConstants.REGION, resource.get(PacmanSdkConstants.REGION)); return ImmutableMap.<String, String>builder().putAll(localRuleParam).build(); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: Exception { mgr = new RepositoryManager(root, false, 0, false);  Repository rep = mgr.createRepository("User_0", "REPOSITORY_A"); "<AssertPlaceHolder>"; }
createRepository(String currentUser, String name) throws IOException {  if (isAnonymousUser(currentUser)) { throw new UserAccessException("Anonymous user not permitted to create repository"); }  validateUser(currentUser);  if (!NamingUtilities.isValidProjectName(name)) { throw new IOException("Invalid repository name: " + name); } if (repositoryMap.containsKey(name)) { throw new DuplicateFileException("Repository named " + name + " already exists"); }  File f = new File(rootDirFile, NamingUtilities.mangle(name)); if (!f.mkdir()) { throw new IOException("Failed to make directory for " + f.getAbsolutePath()); }  Repository rep = new Repository(this, currentUser, f, name); log(name, null, "repository created", currentUser); repositoryMap.put(name, rep); return rep; }
[*] target: assertNotNull(rep)
[-] pred: org. junit. Assert. assertNotNull ( rep )
************************************
************************************
[+] input: testConstructorRoot2() { CategoryPath c = new CategoryPath(null); assertEquals("/", c.getPath()); assertEquals("", c.getName()); "<AssertPlaceHolder>"; }
isRoot() { // parent can only be null for ROOT return parent == null; }
[*] target: assertTrue(c.isRoot())
[-] pred: org. junit. Assert. assertTrue ( c. isRoot() )
************************************
************************************
[+] input: testInstance() { EncryptionPluginManager instance = EncryptionPluginManager.instance(); Assert."<AssertPlaceHolder>"; }
instance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
************************************
[+] input: testDisplayString_ArrayFieldLocation() {  Integer16DataType intDataType = new Integer16DataType(); ArrayDataType innerArray = new ArrayDataType(intDataType, 4, 4); ArrayDataType parentArray = new ArrayDataType(innerArray, 4, innerArray.getElementLength());  Address arrayAddress = addr("0100f2f0"); CreateDataCmd cmd = new CreateDataCmd(arrayAddress, true, parentArray); assertTrue(applyCmd(program, cmd));  int[] componentPath = new int[] { 17 }; String displayText = "int16 0h (int16[4][0][1])"; int index = 0; int charOffset = 0; Address subElementAddress = arrayAddress.add(20); ArrayElementFieldLocation location = new ArrayElementFieldLocation(program, subElementAddress, componentPath, displayText, index, charOffset); PreviewTableCellData data = new PreviewTableCellData(location, formatter); String preview = data.getDisplayString();  "<AssertPlaceHolder>"; }
getDisplayString() { if (displayString != null) { return displayString; } displayString = getPreview(false); return displayString; }
[*] target: assertEquals(displayText, preview)
[-] pred: org. junit. Assert. assertEquals ( displayText, preview )
************************************
************************************
[+] input: testGettingAttribute() { TaskDescriptionProvider provider = TaskDescriptionProvider.getDefault(); String description = provider.getDescriptionForTaskAttribute("apply", "executable"); //$NON-NLS-1$ //$NON-NLS-2$ "<AssertPlaceHolder>"; assertTrue(description.length() > 0); }
getDescriptionForTaskAttribute(String aTaskName, String anAttributeName) { ProposalNode task = taskNodes.get(aTaskName); if (task != null) { ProposalNode att = task.getChild(anAttributeName); if (att != null) { return att.desc; } } return null; }
[*] target: assertNotNull(description)
[-] pred: org. junit. Assert. assertNotNull ( description )
************************************
************************************
[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setShort(6, (short) 2); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred: org. junit. Assert. assertEquals ( 1, ret )
************************************
************************************
[+] input: lineTerminator() { // given String nativeSql = "INSERT INTO ? (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (?)  VALUES (?,?,\r\n?,?),(?,?,?,?)"; Object[] parameters = Stream.of("d1", 1, 100, 3.14, "abc", 4, 200, 3.1415, "xyz", 5).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT INTO d1 (TS,CURRENT,VOLTAGE,PHASE) USING METERS TAGS (1)  VALUES (100,3.14,\r\n'abc',4),(200,3.1415,'xyz',5)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testEquals() { ArraySortedSet<Integer> set1 = ArraySortedSet.of(Comparator.naturalOrder(), Arrays.asList(1, 2, 3)); ArraySortedSet<Integer> set2 = ArraySortedSet.of(Comparator.naturalOrder(), Arrays.asList(1, 2, 3)); Assert."<AssertPlaceHolder>"; }
equals(Object o) { if (o == null) { return false; } if (o instanceof SortedSet) { SortedSet other = (SortedSet)o; if (arr.length != other.size()) { return false; } return IteratorUtils.elementsEqual(iterator(), other.iterator()); } if (o instanceof Set) { Set other = (Set)o; if (arr.length != other.size()) { return false; } return this.containsAll(other); } return false; }
[*] target: assertTrue(set1.equals(set2))
[-] pred: org. junit. Assert. assertTrue ( set1. equals ( set2 ) )
************************************
************************************
[+] input: testGetCurrentDirectory() {  JFileChooser chooser = new MockJFileChooser(); File dir = chooser.getCurrentDirectory();  Assert."<AssertPlaceHolder>"; Assert.assertTrue(dir instanceof MockFile); }
getCurrentDirectory() { return currentDirectory; }
[*] target: assertTrue(dir.exists())
[-] pred: org. junit. Assert. assertTrue ( dir. exists ( ) )
************************************
************************************
[+] input: testGetSubscribedService() { Collection<Service> subscribedService = clientServiceIndexesManager.getSubscribedService();  Assert."<AssertPlaceHolder>"; Assert.assertEquals(subscribedService.size(), 1); }
getSubscribedService() { return subscriberIndexes.keySet(); }
[*] target: assertNotNull(subscribedService)
[-] pred: org. junit. Assert. assertNotNull ( subscribedService )
************************************
************************************
[+] input: testPowPm5d8() { CafeFieldElement a = CafeFieldElement.decode(A_BYTES); CafeFieldElement ap58 = CafeFieldElement.decode(A_POWER_P_MINUS_5_DIV_8_BYTES); Assert."<AssertPlaceHolder>"; }
powPm5d8() { int[] result = Curve25519FieldUtils.createZero(); Curve25519FieldUtils.powPm5d8(t, result); return new CafeFieldElement(result); }
[*] target: assertEquals(ap58, a.powPm5d8())
[-] pred: org. junit. Assert. assertEquals ( ap58, a. powPm5d8 ( ) )
************************************
************************************
[+] input: testConfirmToString() { String res = new OverrideToString().toString(); String diff = res + " a different string";  OverrideToString obj = mock(OverrideToString.class); when(obj.toString()).thenReturn(diff);  "<AssertPlaceHolder>"; }
toString() { return "mock(" + retval.getType() +")"; }
[*] target: assertEquals(diff, obj.toString())
[-] pred: org. junit. Assert. assertEquals ( diff, obj. toString ( ) )
************************************
************************************
[+] input: testAsList_Iterator_Null() {  List<String> list = CollectionUtils.asList((Iterator<String>) null); assertNotNull(list); "<AssertPlaceHolder>"; }
isEmpty() { return removed.isEmpty() && added.isEmpty(); }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty ( ) )
************************************
************************************
[+] input: testDoubleInit() { int n = ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks();  Runtime.getRuntime().addShutdownHook(new Thread(){});  //this should remove the above hook thread ShutdownHookHandler.getInstance().initHandler();  Assert."<AssertPlaceHolder>"; }
getNumberOfAllExistingHooks() { if(hooksReference==null) { return -1; } return hooksReference.size(); }
[*] target: assertEquals(n, ShutdownHookHandler.getInstance().getNumberOfAllExistingHooks())
[-] pred: org. junit. Assert. assertEquals ( n, ShutdownHookHandler.getInstance ( ). getNumberOfAllExistingHooks() )
************************************
************************************
[+] input: testExtractCommentValueA() { String expectComment = "test"; List<String> columnSpecs = Arrays.asList("comment", "test"); String actualComment = schemaManager.extractComment(columnSpecs); Assert."<AssertPlaceHolder>"; }
extractComment(List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } return extractAdjacentString(columnSpecs, COMMENT); }
[*] target: assertEquals(expectComment, actualComment)
[-] pred: org. junit. Assert. assertEquals ( expectComment, actualComment )
************************************
************************************
[+] input: testLoadPrivateKeyFromPath() { PrivateKey privateKey = PemUtil.loadPrivateKeyFromPath(MERCHANT_PRIVATE_KEY_PATH); Assert."<AssertPlaceHolder>"; }
loadPrivateKeyFromPath(String keyPath) { return loadPrivateKeyFromString(readPrivateKeyStringFromPath(keyPath)); }
[*] target: assertNotNull(privateKey)
[-] pred: org. junit. Assert. assertNotNull ( privateKey )
************************************
************************************
[+] input: NacosException { String dataId = "1"; String group = "2"; String content = "123"; String namespace = ""; String casMd5 = "96147704e3cb8be8597d55d75d244a02"; String type = ConfigType.PROPERTIES.getType();  Mockito.when(mockWoker.publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type)) .thenReturn(true);  final boolean b = nacosConfigService.publishConfigCas(dataId, group, content, casMd5, type); Assert."<AssertPlaceHolder>";  Mockito.verify(mockWoker, Mockito.times(1)) .publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type); }
publishConfigCas(String dataId, String group, String content, String casMd5, String type) throws NacosException { return publishConfigInner(namespace, dataId, group, null, null, null, content, type, casMd5); }
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
************************************
************************************
[+] input: testFormatStringLegacyColor_SpigotHexCodeOnly() { String input = "&x&f&f&f&f&f&fHello There Austin"; String expectedResult = "&x&f&f&f&f&f&fHello There Austin";  String result = Format.FormatStringLegacyColor(input); "<AssertPlaceHolder>"; }
FormatStringLegacyColor(String string) { String allFormated = string;  allFormated = LEGACY_CHAT_COLOR_PATTERN.matcher(allFormated).replaceAll("\u00A7$13"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[A]", BUKKIT_COLOR_CODE_PREFIX + "a"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[B]", BUKKIT_COLOR_CODE_PREFIX + "b"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[C]", BUKKIT_COLOR_CODE_PREFIX + "c"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[D]", BUKKIT_COLOR_CODE_PREFIX + "d"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[E]", BUKKIT_COLOR_CODE_PREFIX + "e"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[F]", BUKKIT_COLOR_CODE_PREFIX + "f");  allFormated = allFormated.replaceAll("%", "\\%"); return allFormated; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testEscapeString1() { String orig = "/"; String escaped = CategoryPath.escapeString(orig); String unescaped = CategoryPath.unescapeString(escaped); "<AssertPlaceHolder>"; assertEquals("\\/", escaped); }
unescapeString(String escapedString) { return escapedString.replace(ESCAPED_DELIMITER_STRING, DELIMITER_STRING); }
[*] target: assertEquals(orig, unescaped)
[-] pred: org. junit. Assert. assertEquals ( orig, unescaped )
************************************
************************************
[+] input: testDisplayString_FunctionLocation() {  Address address = addr("01002cf5");  //@formatter:off String signature = "undefined ghidra(" + "undefined4 param_1, " + "undefined4 param_2, " + "undefined4 param_3, " + "undefined4 param_4, " + "undefined4 param_5)"; //@formatter:on FunctionNameFieldLocation location = new FunctionNameFieldLocation(program, address, 0, signature, "ghidra");  PreviewTableCellData data = new PreviewTableCellData(location, formatter); String preview = data.getDisplayString(); "<AssertPlaceHolder>"; }
getDisplayString() { if (displayString != null) { return displayString; } displayString = getPreview(false); return displayString; }
[*] target: assertEquals(signature, preview)
[-] pred: org. junit. Assert. assertEquals ( signature, preview )
************************************
************************************
[+] input: testFilterChat() { String test = "I am an ass"; String expectedResult = "I am an donut";  String result = Format.FilterChat(test); "<AssertPlaceHolder>"; }
FilterChat(String msg) { int t = 0; List<String> filters = getInstance().getConfig().getStringList("filters"); for (String s : filters) { t = 0; String[] pparse = new String[2]; pparse[0] = " "; pparse[1] = " "; StringTokenizer st = new StringTokenizer(s, ","); while (st.hasMoreTokens()) { if (t < 2) { pparse[t++] = st.nextToken(); } } // (?i) = case insensitive msg = msg.replaceAll("(?i)" + pparse[0], pparse[1]); } return msg; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: Exception {  List<String> names = functionManager.getCallingConventionNames(); assertTrue(names.size() >= 1);  for (String name : names) { if (Function.UNKNOWN_CALLING_CONVENTION_STRING.equals(name)) { assertNull(functionManager.getCallingConvention(name)); } else { "<AssertPlaceHolder>"; } } }
getCallingConvention(String name) { return functions.getCallingConvention(name); }
[*] target: assertNotNull(functionManager.getCallingConvention(name))
[-] pred: org. junit. Assert. assertNotNull ( functionManager. getCallingConvention(name) )
************************************
************************************
[+] input: testDeleteAssetProfile() { AssetProfile assetProfile = this.createAssetProfile(tenantId, "Asset Profile"); AssetProfile savedAssetProfile = assetProfileService.saveAssetProfile(assetProfile); assetProfileService.deleteAssetProfile(tenantId, savedAssetProfile.getId()); AssetProfile foundAssetProfile = assetProfileService.findAssetProfileById(tenantId, savedAssetProfile.getId()); Assert."<AssertPlaceHolder>"; }
findAssetProfileById(TenantId tenantId, AssetProfileId assetProfileId);
[*] target: assertNull(foundAssetProfile)
[-] pred: org. junit. Assert. assertNull ( foundAssetProfile )
************************************
************************************
[+] input: IOException { // prepare File src = new File(temporaryFolder.newFolder("src"), "test.dat"); src.createNewFile(); File dest = new File(temporaryFolder.getRoot(), "dest/renamed.dat");  // act contributor.copyToFile(src, dest); log.debug("Destination file {}: {}", dest, dest.exists() ? "exists" : "not exists"); log.debug("Source file {}: {}", src, src.exists() ? "exists" : "not exists");  // check "<AssertPlaceHolder>"; assertTrue(src.exists()); }
copyToFile(File src, File dest) throws IOException { LOGGER.debug( "Copying {} [{}] to file [{}]", src.isFile() ? "file" : "directory", src.getAbsolutePath(), dest.getAbsolutePath() );  try { helper.copyToFile(src, dest); } catch (FilesHelperException e) { throw (IOException) e.getCause(); } }
[*] target: assertTrue(dest.exists())
[-] pred: org. junit. Assert. assertTrue ( dest. exists ( ) )
************************************
************************************
[+] input: testDeleteRuleChain() { RuleChain ruleChain = new RuleChain(); ruleChain.setTenantId(tenantId); ruleChain.setName("My RuleChain"); RuleChain savedRuleChain = ruleChainService.saveRuleChain(ruleChain); RuleChain foundRuleChain = ruleChainService.findRuleChainById(tenantId, savedRuleChain.getId()); Assert.assertNotNull(foundRuleChain); ruleChainService.deleteRuleChainById(tenantId, savedRuleChain.getId()); foundRuleChain = ruleChainService.findRuleChainById(tenantId, savedRuleChain.getId()); Assert."<AssertPlaceHolder>"; }
findRuleChainById(TenantId tenantId, RuleChainId ruleChainId);
[*] target: assertNull(foundRuleChain)
[-] pred: org. junit. Assert. assertNull ( foundRuleChain )
************************************
************************************
[+] input: testFindAssetInfoByTenantIdAndType() { Customer customer = new Customer(); customer.setTitle("Customer X"); customer.setTenantId(tenantId); Customer savedCustomer = customerService.saveCustomer(customer);  Asset asset = new Asset(); asset.setTenantId(tenantId); asset.setName("default"); asset.setType("default"); asset.setLabel("label"); asset.setCustomerId(savedCustomer.getId()); Asset savedAsset = assetService.saveAsset(asset);  PageLink pageLinkWithLabel = new PageLink(100, 0, "label"); List<AssetInfo> assetInfosWithLabel = assetService .findAssetInfosByTenantIdAndType(tenantId, asset.getType(), pageLinkWithLabel).getData();  Assert.assertFalse(assetInfosWithLabel.isEmpty()); Assert.assertTrue( assetInfosWithLabel.stream() .anyMatch( d -> d.getId().equals(savedAsset.getId()) && d.getTenantId().equals(tenantId) && d.getAssetProfileName().equals(savedAsset.getType()) && d.getLabel().equals(savedAsset.getLabel()) ) );  PageLink pageLinkWithCustomer = new PageLink(100, 0, savedCustomer.getTitle()); List<AssetInfo> assetInfosWithCustomer = assetService .findAssetInfosByTenantIdAndType(tenantId, asset.getType(), pageLinkWithCustomer).getData();  Assert."<AssertPlaceHolder>"; Assert.assertTrue( assetInfosWithCustomer.stream() .anyMatch( d -> d.getId().equals(savedAsset.getId()) && d.getTenantId().equals(tenantId) && d.getAssetProfileName().equals(savedAsset.getType()) && d.getCustomerId().equals(savedCustomer.getId()) && d.getCustomerTitle().equals(savedCustomer.getTitle()) ) ); }
findAssetInfosByTenantIdAndType(TenantId tenantId, String type, PageLink pageLink);
[*] target: assertFalse(assetInfosWithCustomer.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( assetInfosWithCustomer. isEmpty ( ) )
************************************
************************************
[+] input: testSimpleNameNoPackage() { final String className = "MyClass"; final String simpleName = ClassNameHelper.getSimpleName(className); Assert."<AssertPlaceHolder>"; }
getSimpleName(String name) { final int lastIndex = name.lastIndexOf('.'); if (lastIndex == name.length()) { // Somehow the '.' is the last name. Should never happen but let's be safe. return ""; } return name.substring(name.lastIndexOf('.') + 1); }
[*] target: assertEquals(className, simpleName)
[-] pred: org. junit. Assert. assertEquals ( className, simpleName )
************************************
************************************
[+] input: Exception { selectRow(3);  JButton button = findButtonByIcon(pathManager.getComponent(), ResourceManager.loadImage("images/edit-delete.png")); "<AssertPlaceHolder>"; pressButton(button, true); waitForSwing(); int row = table.getSelectedRow(); assertEquals(2, row);  pressButton(button, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(1, row);  pressButton(button, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(0, row);  pressButton(button, true); waitForSwing(); row = table.getSelectedRow(); assertEquals(-1, row);  assertTrue(!button.isEnabled()); }
getComponent() { return panel; }
[*] target: assertNotNull(button)
[-] pred: org. junit. Assert. assertNotNull ( button )
************************************
************************************
[+] input: SQLException { pstmt_insert.setTimestamp(1, new Timestamp(System.currentTimeMillis())); pstmt_insert.setByte(7, (byte) 0x001); int ret = pstmt_insert.executeUpdate(); Assert."<AssertPlaceHolder>"; }
executeUpdate() throws SQLException { if (isClosed()) throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_STATEMENT_CLOSED); if (!isPrepared) return executeUpdate(this.rawSql);  final String sql = Utils.getNativeSql(rawSql, this.parameters); return executeUpdate(sql); }
[*] target: assertEquals(1, ret)
[-] pred: org. junit. Assert. assertEquals ( 1, ret )
************************************
************************************
[+] input: InterruptedException { AtomicBoolean result = new AtomicBoolean(false); NamingSnapshotOperation operation = new NamingSnapshotOperation(storage, lock); final Writer writer = new Writer(snapshotDir); final CountDownLatch latch = new CountDownLatch(1);  operation.onSnapshotSave(writer, (isOk, throwable) -> { result.set(isOk && throwable == null); latch.countDown(); }); latch.await(10, TimeUnit.SECONDS); Assert.assertTrue(isSnapshoted); Assert.assertTrue(result.get());  final Reader reader = new Reader(snapshotDir, writer.listFiles()); boolean res = operation.onSnapshotLoad(reader); Assert."<AssertPlaceHolder>"; }
onSnapshotLoad(Reader reader) { final String readerPath = reader.getPath(); final String sourceFile = Paths.get(readerPath, snapshotArchive).toString();  TimerContext.start(NAMING_SNAPSHOT_LOAD); final Lock lock = writeLock; lock.lock(); try { final Checksum checksum = new CRC64(); DiskUtils.decompress(sourceFile, readerPath, checksum); LocalFileMeta fileMeta = reader.getFileMeta(snapshotArchive); if (fileMeta.getFileMeta().containsKey(checkSumKey)) { if (!Objects.equals(Long.toHexString(checksum.getValue()), fileMeta.get(checkSumKey))) { throw new IllegalArgumentException("Snapshot checksum failed"); } }  final String loadPath = Paths.get(readerPath, snapshotDir).toString(); storage.snapshotLoad(loadPath); Loggers.RAFT.info("snapshot load from : {}", loadPath); DiskUtils.deleteDirectory(loadPath); return true; } catch (final Throwable t) { Loggers.RAFT.error("Fail to load snapshot, path={}, file list={}, {}.", Paths.get(readerPath, snapshotDir).toString(), reader.listFiles(), t); return false; } finally { lock.unlock(); TimerContext.end(NAMING_SNAPSHOT_LOAD, Loggers.RAFT); } }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: lineTerminatorAndMultiValuesAndNoneOrMoreWhitespace() { String nativeSql = "INSERT Into ? TAGS(?) VALUES(?,?,\r\n?,?),(?,? ,\r\n?,?) t? tags (?) Values (?,?,?\r\n,?) (?,?,?,?) t? Tags(?) values  (?,?,?,?) , (?,?,?,?)"; Object[] parameters = Stream.of("t1", "abc", 100, 1.1, "xxx", "xxx", 200, 2.2, "xxx", "xxx", 2, "bcd", 300, 3.3, "xxx", "xxx", 400, 4.4, "xxx", "xxx", 3, "cde", 500, 5.5, "xxx", "xxx", 600, 6.6, "xxx", "xxx").toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "INSERT Into t1 TAGS('abc') VALUES(100,1.1,\r\n'xxx','xxx'),(200,2.2 ,\r\n'xxx','xxx') t2 tags ('bcd') Values (300,3.3,'xxx'\r\n,'xxx') (400,4.4,'xxx','xxx') t3 Tags('cde') values  (500,5.5,'xxx','xxx') , (600,6.6,'xxx','xxx')"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testNorthWestNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.compactNine(population, 5);  TestSuiteChromosome exepcted_individual = population.get(0); TestSuiteChromosome returned_individual = neighbors.get(4);  "<AssertPlaceHolder>"; }
compactNine(List<T> collection, int position) {  _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: testEncryptHandler() { Pair<String, String> pair = EncryptionHandler.encryptHandler("test-dataId", "content"); Assert."<AssertPlaceHolder>"; }
encryptHandler(String dataId, String content) { if (!checkCipher(dataId)) { return Pair.with("", content); } String algorithmName = parseAlgorithmName(dataId); Optional<EncryptionPluginService> optional = EncryptionPluginManager.instance() .findEncryptionService(algorithmName); if (!optional.isPresent()) { LOGGER.warn("[EncryptionHandler] [encryptHandler] No encryption program with the corresponding name found"); return Pair.with("", content); } EncryptionPluginService encryptionPluginService = optional.get(); String secretKey = encryptionPluginService.generateSecretKey(); String encryptContent = encryptionPluginService.encrypt(secretKey, content); return Pair.with(encryptionPluginService.encryptSecretKey(secretKey), encryptContent); }
[*] target: assertNotNull(pair)
[-] pred: org. junit. Assert. assertNotNull ( pair )
************************************
************************************
[+] input: testEmpty() { MonotonicQueue<Integer> q = new MonotonicQueue<>(); Assert.assertTrue(q.isEmpty()); Assert.assertNull(q.max()); Assert."<AssertPlaceHolder>"; }
pop() { if (dq.isEmpty()) { return null; } return dq.poll(); // Returns & remove head of deque }
[*] target: assertNull(q.pop())
[-] pred: org. junit. Assert. assertNull ( q. pop() )
************************************
************************************
[+] input: testIterator2() { for (int i = 0; i < 10000; i++) { ps.put(i); } LongIterator it = ps.getPropertyIterator(); int i = 0; while (it.hasNext()) { long l = it.next(); "<AssertPlaceHolder>"; i++; } assertEquals(i, 10000); }
put(long index) { PropertyPage page = getOrCreatePage(getPageID(index)); int n = page.getSize(); page.add(getPageOffset(index)); numProperties += page.getSize() - n; }
[*] target: assertEquals(i, l)
[-] pred: org. junit. Assert. assertEquals ( i, l )
************************************
************************************
[+] input: testGetAllAuiStr() { // TODO: by catching Exception, the test succedes even if the umlsDao.getAllAuiStr fails try { List<Object[]> auis = umlsDao.getAllAuiStr(""); // TODO: not a sufficient integration test Assert."<AssertPlaceHolder>"; log.debug("testGetAllAuiStr()" + auis.size()); } catch (Exception e) { log.warn("sql exception - mrconso probably doesn't exist, check error", e); } }
getAllAuiStr(String lastAui);
[*] target: assertNotNull(auis)
[-] pred: org. junit. Assert. assertNotNull ( auis )
************************************
************************************
[+] input: Exception { String text = "Hello World!"; SmartUtURL url = new SmartUtURL("http://smartut.org/hello.txt");  NetworkHandling.createRemoteTextFile(url,text);  URL mock = MockURL.URL(url.getUrl()); URLConnection connection = mock.openConnection(); Scanner in = new Scanner(connection.getInputStream()); String res = in.nextLine(); Assert."<AssertPlaceHolder>"; }
createRemoteTextFile(SmartUtURL url, String text){ if(url == null){ return false; } return VirtualNetwork.getInstance().addRemoteTextFile(url.getUrl(),text); }
[*] target: assertEquals(text,res)
[-] pred: org. junit. Assert. assertEquals ( text, res )
************************************
************************************
[+] input: replaceNothing() { // given String nativeSql = "insert into test.t1 (ts, temperature, humidity) using test.weather tags('beijing',1) values(now, 12.2, 4)";  // when String actual = Utils.getNativeSql(nativeSql, null);  // then Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(nativeSql, actual)
[-] pred: org. junit. Assert. assertEquals ( nativeSql, actual )
************************************
************************************
[+] input: IOException { String expectedName = "admin456"; ConnectorArguments arguments = new ConnectorArguments("--connector", "abcABC123", "--user", expectedName);  String actualName = arguments.getUserOrFail();  "<AssertPlaceHolder>"; }
getUserOrFail() { String user = getOptions().valueOf(optionUser); if (user == null) { throw new MetadataDumperUsageException( "Required username was not provided. Please use the '--" + OPT_USER + "' flag to provide the username."); } return user; }
[*] target: assertEquals(expectedName, actualName)
[-] pred: org. junit. Assert. assertEquals ( expectedName, actualName )
************************************
************************************
[+] input: testMazeSolution() {  int ret_val = MazeClient.walk('s', 's', 's', 's', 'd', 'd', 'd', 'd', 'w', 'w', 'a', 'a', 'w', 'w', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 'd', 'd', 'w', 'w', 'w', 'w', (char) 0, (char) 0, 28); "<AssertPlaceHolder>"; }
walk(char move0, char move1, char move2, char move3, char move4, char move5, char move6, char move7, char move8, char move9, char move10, char move11, char move12, char move13, char move14, char move15, char move16, char move17, char move18, char move19, char move20, char move21, char move22, char move23, char move24, char move25, char move26, char move27, char move28, char move29, int moveLength) {  char[] moves = new char[] {move0, move1, move2, move3, move4, move5, move6, move7, move8, move9, move10, move11, move12, move13, move14, move15, move16, move17, move18, move19, move20, move21, move22, move23, move24, move25, move26, move27, move28, move29};  return walk(moves, moveLength); }
[*] target: assertEquals(1, ret_val)
[-] pred: org. junit. Assert. assertEquals ( 1, ret_val )
************************************
************************************
[+] input: testGetEventTypeRecorderSyncTapEvent3() { List<TapEvent> list = new ArrayList<>(); list.add(tapEvent); handler = new SyncGetMemorySizeHandler(new AtomicLong(100)); HandlerUtil.EventTypeRecorder recorder = handler.getEventTypeRecorderSyncTapEvent(list); Assert."<AssertPlaceHolder>"; Assert.assertEquals(100, recorder.getMemorySize()); }
getEventTypeRecorderSyncTapEvent(List<? extends TapEvent> events) { if (null == events) events = new ArrayList<>(); if (null == memorySize) return HandlerUtil.countTapEvent(events); HandlerUtil.EventTypeRecorder recorder; synchronized (memorySize) { if (memorySize.get() >= 0) { recorder = HandlerUtil.countTapEvent(events, memorySize.get()); memorySize.set(-1); } else { recorder = HandlerUtil.countTapEvent(events); memorySize.set(recorder.getMemorySize()); } } return recorder; }
[*] target: assertNotNull(recorder)
[-] pred: org. junit. Assert. assertNotNull ( recorder )
************************************
************************************
[+] input: testGetComponent() { Structure struct = createStructure("struct_1", 0); struct.add(new ByteDataType()); struct.add(new StringDataType(), 10); DataTypeComponent newdtc = union.add(struct, "field5", "comments"); DataTypeComponent dtc = union.getComponent(4); "<AssertPlaceHolder>"; assertEquals("field5", dtc.getFieldName()); assertEquals("comments", dtc.getComment());  }
getComponent(int ordinal) { return components.get(ordinal); }
[*] target: assertEquals(newdtc, dtc)
[-] pred: org. junit. Assert. assertEquals ( newdtc, dtc )
************************************
************************************
[+] input: test_bothHeapifyMethods_shouldConstructArray() { MaxHeap<Integer> heap = new MaxHeap<>(); // 1st heapify, takes in a list of values heap.heapify(Arrays.asList(1, 9, 11, 4, 7, 6, 3, 2, 13)); String firstHeap = heap.toString();  // 2nd heapify, take sin sequence of values heap.heapify(2, 9, 11, 4, 7, 6, 3, 13, 1); String secondHeap = heap.toString();  Assert."<AssertPlaceHolder>"; // should be the same String expected = "[13, 9, 11, 4, 7, 6, 3, 2, 1]"; Assert.assertEquals(expected, firstHeap); }
toString() { StringBuilder ret = new StringBuilder("["); for (int i = 0; i < size(); i++) { ret.append(heap.get(i)); ret.append(", "); } return ret.substring(0, ret.length() - 2) + "]"; }
[*] target: assertEquals(firstHeap, secondHeap)
[-] pred: org. junit. Assert. assertEquals ( firstHeap, secondHeap )
************************************
************************************
[+] input: SAXException { XmlSerializer serializer = new XmlSerializer(); XmlDeserializer deserializer = new XmlDeserializer();  // This is the only way to make the serialization to work. Set<Class<?>> subtypes = ReflectionHelper.SUBTYPES.get(DataSpecificationContent.class); subtypes.add(DefaultDummyDataSpecification.class);  String xmlString = serializer.write(Examples.ENVIRONMENT_WITH_DUMMYDATASPEC); "<AssertPlaceHolder>";  validateAgainstXsdSchema(xmlString);  Environment copy = deserializer.read(xmlString); assertNotNull(copy);  assertTrue(Examples.ENVIRONMENT_WITH_DUMMYDATASPEC.equals(copy)); }
write(Environment aasEnvironment) throws SerializationException { try { ObjectWriter writer = mapper.writer(); return writer.writeValueAsString(aasEnvironment); } catch (JsonProcessingException ex) { throw new SerializationException("serialization failed", ex); } }
[*] target: assertNotNull(xmlString)
[-] pred: org. junit. Assert. assertNotNull ( xmlString )
************************************
************************************
[+] input: testDeleteCustomer() { Customer customer = new Customer(); customer.setTitle("My customer"); customer.setTenantId(tenantId); Customer savedCustomer = customerService.saveCustomer(customer); customerService.deleteCustomer(tenantId, savedCustomer.getId()); Customer foundCustomer = customerService.findCustomerById(tenantId, savedCustomer.getId()); Assert."<AssertPlaceHolder>"; }
findCustomerById(TenantId tenantId, CustomerId customerId);
[*] target: assertNull(foundCustomer)
[-] pred: org. junit. Assert. assertNull ( foundCustomer )
************************************
************************************
[+] input: Exception { String mangled = "_ZN12LayerDetails15RandomProviderTIZNKS_9LayerBase10initRandomEllEUlRljE_EclIiLm2EEET_RAT0__KS6_";  String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals( "int LayerDetails::RandomProviderT<LayerDetails::LayerBase::initRandom(long,long)const::{lambda(long&,unsigned_int)#1}>::operator()<int,2ul>(LayerDetails::RandomProviderT<LayerDetails::LayerBase::initRandom(long,long)const::{lambda(long&,unsigned_int)#1}>::operator() const &[])", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: Exception { SubscribeServiceResponse res = new SubscribeServiceResponse(); ServiceInfo info = new ServiceInfo(GROUP_NAME + "@@" + SERVICE_NAME + "@@" + CLUSTERS); res.setServiceInfo(info); when(this.rpcClient.request(any())).thenReturn(res); ServiceInfo actual = client.subscribe(SERVICE_NAME, GROUP_NAME, CLUSTERS); Assert."<AssertPlaceHolder>"; }
subscribe(String serviceName, String groupName, String clusters) throws NacosException { if (NAMING_LOGGER.isDebugEnabled()) { NAMING_LOGGER.debug("[GRPC-SUBSCRIBE] service:{}, group:{}, cluster:{} ", serviceName, groupName, clusters); } redoService.cacheSubscriberForRedo(serviceName, groupName, clusters); return doSubscribe(serviceName, groupName, clusters); }
[*] target: assertEquals(info, actual)
[-] pred: org. junit. Assert. assertEquals ( info, actual )
************************************
************************************
[+] input: testGetLastCodeSingleColor() { String input = BUKKIT_COLOR_CODE_PREFIX + "cHello"; String expectedResult = BUKKIT_COLOR_CODE_PREFIX + "c";  String result = Format.getLastCode(input);  "<AssertPlaceHolder>"; }
getLastCode(String s) { String ts = ""; char[] ch = s.toCharArray(); for (int a = 0; a < s.length() - 1; a++) { if (String.valueOf(ch[a + 1]).matches("[lkomnLKOMN]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts += String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (String.valueOf(ch[a + 1]).matches("[0123456789abcdefrABCDEFR]") && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1]; a++; } else if (ch[a + 1] == 'x' && ch[a] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { if (ch.length > a + 13) { if (String.valueOf(ch[a + 3]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 5]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 7]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 9]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 11]).matches("[0123456789abcdefABCDEF]") && String.valueOf(ch[a + 13]).matches("[0123456789abcdefABCDEF]") && ch[a + 2] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 4] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 6] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 8] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 10] == BUKKIT_COLOR_CODE_PREFIX_CHAR && ch[a + 12] == BUKKIT_COLOR_CODE_PREFIX_CHAR) { ts = String.valueOf(ch[a]) + ch[a + 1] + ch[a + 2] + ch[a + 3] + ch[a + 4] + ch[a + 5] + ch[a + 6] + ch[a + 7] + ch[a + 8] + ch[a + 9] + ch[a + 10] + ch[a + 11] + ch[a + 12] + ch[a + 13]; a += 13; } } } } return ts; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: Exception { ViewConfigurationContext result = testObj.generateForTable("medias", ctx); Assert."<AssertPlaceHolder>";  }
generateForTable(final String tableName, final MigrationContext migrationContext) throws Exception { try { Set<String> columns = migrationContext.getDataSourceRepository().getAllColumnNames(tableName); if (columns.isEmpty()) { return null; } String viewPrefix = migrationContext.getItemTypeViewNamePattern(); String tableVieName = String.format(StringUtils.trimToEmpty(viewPrefix), tableName); String whereView = migrationContext.getViewWhereClause(tableName); Map<String, String> customColumns = migrationContext.getCustomColumnsForView(tableName); final String viewColumnPrefix = migrationContext.getViewColumnPrefixFor(tableName); return new ViewConfigurationContext(tableName, tableVieName, columns, customColumns, whereView, viewColumnPrefix); } catch (Exception e) { LOG.error(String.format("could not get source data repository for table: %s", tableName), e); throw e; } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testExtractDefaultValueQuotes() { String expectDefault = "100"; List<String> columnSpecs = Arrays.asList("default", ""100"", "comment", ""); String actualDefault = schemaManager.extractDefaultValue(DorisType.BIGINT, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertEquals(expectDefault, actualDefault)
[-] pred: org. junit. Assert. assertEquals ( expectDefault, actualDefault )
************************************
************************************
[+] input: testVisitINT_SEXT() { Address instructionAddress = Utils.getDefaultAddress(0x1010); SequenceNumber seq = new SequenceNumber(instructionAddress, 0); AbsEnv tmpEnv = new AbsEnv(); ConstraintSolver constraintSolver = new ConstraintSolver();  Varnode[] in1 = {new Varnode(Utils.getConstantAddress(0xFFFFFFFFL), GlobalState.arch.getDefaultPointerSize())}; Varnode out1 = new Varnode(Utils.getRegisterAddress(8), GlobalState.arch.getDefaultPointerSize()); PcodeOp pcode = new PcodeOp(seq, PcodeOp.COPY, in1, out1); constraintSolver.visit_COPY(pcode, tmpEnv);  Varnode[] in2 = { new Varnode(Utils.getRegisterAddress(8), GlobalState.arch.getDefaultPointerSize()), };  Varnode out2 = new Varnode(Utils.getUniqueAddress(0x10), 8); pcode = new PcodeOp(seq, PcodeOp.INT_ZEXT, in2, out2);  constraintSolver.visit_INT_SEXT(pcode, tmpEnv); optimize = constraintSolver.getOptimize();  optimize.Push(); Assert.assertEquals( optimize.Check(), Status.SATISFIABLE ); Expr res = optimize.getModel() .eval(constraintSolver.getALocExprHashMap().get(ALoc.getALoc(out2)), false); BitVecExpr bitVecExpr = (BitVecExpr) res; BigInteger expect = new BigInteger("FFFFFFFFFFFFFFFF", 16); BigInteger actual = new BigInteger(bitVecExpr.toString()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(bitVecExpr.getSortSize(), 64); optimize.Pop(); }
getALocExprHashMap() { return aLocExprHashMap; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testLoadPrivateKeyFromString() { PrivateKey privateKey = PemUtil.loadPrivateKeyFromString(MERCHANT_PRIVATE_KEY_STRING); Assert."<AssertPlaceHolder>"; }
loadPrivateKeyFromString(String keyString) { try { keyString = keyString .replace("-----BEGIN PRIVATE KEY-----", "") .replace("-----END PRIVATE KEY-----", "") .replaceAll("\\s+", ""); return KeyFactory.getInstance("RSA") .generatePrivate(new PKCS8EncodedKeySpec(Base64.getDecoder().decode(keyString))); } catch (NoSuchAlgorithmException e) { throw new UnsupportedOperationException(e); } catch (InvalidKeySpecException e) { throw new IllegalArgumentException(e); } }
[*] target: assertNotNull(privateKey)
[-] pred: org. junit. Assert. assertNotNull ( privateKey )
************************************
************************************
[+] input: testFormatStringLegacyColor_BothColorCodes() { String input = "&x&f&f&f&f&f&f&cHello There Austin"; String expectedResult = "&x&f&f&f&f&f&f" + BUKKIT_COLOR_CODE_PREFIX + "cHello There Austin";  String result = Format.FormatStringLegacyColor(input); "<AssertPlaceHolder>"; }
FormatStringLegacyColor(String string) { String allFormated = string;  allFormated = LEGACY_CHAT_COLOR_PATTERN.matcher(allFormated).replaceAll("\u00A7$13"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[A]", BUKKIT_COLOR_CODE_PREFIX + "a"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[B]", BUKKIT_COLOR_CODE_PREFIX + "b"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[C]", BUKKIT_COLOR_CODE_PREFIX + "c"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[D]", BUKKIT_COLOR_CODE_PREFIX + "d"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[E]", BUKKIT_COLOR_CODE_PREFIX + "e"); allFormated = allFormated.replaceAll(BUKKIT_COLOR_CODE_PREFIX + "[F]", BUKKIT_COLOR_CODE_PREFIX + "f");  allFormated = allFormated.replaceAll("%", "\\%"); return allFormated; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: sharedInfo_withDebugModeEnabledInTwoWays() { SharedInfo.Builder sharedInfoBuilder1 = SharedInfo.builder() .setVersion(VERSION_0_1) .setApi(ATTRIBUTION_REPORTING_API) .setScheduledReportTime(FIXED_TIME) .setReportingOrigin(REPORTING_ORIGIN) .setDestination(DESTINATION) .setSourceRegistrationTime(FIXED_TIME) .setReportId(RANDOM_UUID) .setReportDebugModeString("enabled"); SharedInfo si1 = sharedInfoBuilder1.build();  SharedInfo.Builder sharedInfoBuilder2 = SharedInfo.builder() .setVersion(VERSION_0_1) .setApi(ATTRIBUTION_REPORTING_API) .setScheduledReportTime(FIXED_TIME) .setReportingOrigin(REPORTING_ORIGIN) .setDestination(DESTINATION) .setSourceRegistrationTime(FIXED_TIME) .setReportId(RANDOM_UUID) .setReportDebugMode(true); SharedInfo si2 = sharedInfoBuilder2.build();  "<AssertPlaceHolder>"; }
build();
[*] target: assertEquals(si1, si2)
[-] pred: org. junit. Assert. assertEquals ( si1, si2 )
************************************
************************************
[+] input: testMostSouthWestNeighbour() {  this.constructPopulation();  Neighbourhood<TestSuiteChromosome> neighbourhood = new Neighbourhood<>(Properties.POPULATION);  List<TestSuiteChromosome> neighbors = neighbourhood.CompactThirteen(population, 12);  TestSuiteChromosome exepcted_individual = population.get(3); TestSuiteChromosome returned_individual = neighbors.get(5);  "<AssertPlaceHolder>"; }
CompactThirteen(List<T> collection, int position) { _N  = neighbour[position][Positions.N.ordinal()]; _S  = neighbour[position][Positions.S.ordinal()]; _E  = neighbour[position][Positions.E.ordinal()]; _W  = neighbour[position][Positions.W.ordinal()]; _NW = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.W.ordinal()]; _SW = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.W.ordinal()]; _NE = neighbour[neighbour[position][Positions.N.ordinal()]][Positions.E.ordinal()]; _SE = neighbour[neighbour[position][Positions.S.ordinal()]][Positions.E.ordinal()]; _NN = neighbour[_N][Positions.N.ordinal()]; _SS = neighbour[_S][Positions.S.ordinal()]; _EE = neighbour[_E][Positions.E.ordinal()]; _WW = neighbour[_W][Positions.W.ordinal()];  chromosomes.add(collection.get(_N)); chromosomes.add(collection.get(_S)); chromosomes.add(collection.get(_E)); chromosomes.add(collection.get(_W)); chromosomes.add(collection.get(_NW)); chromosomes.add(collection.get(_SW)); chromosomes.add(collection.get(_NE)); chromosomes.add(collection.get(_SE)); chromosomes.add(collection.get(_NN)); chromosomes.add(collection.get(_SS)); chromosomes.add(collection.get(_EE)); chromosomes.add(collection.get(_WW)); chromosomes.add(collection.get(position));  return chromosomes; }
[*] target: assertEquals(exepcted_individual, returned_individual)
[-] pred: org. junit. Assert. assertEquals ( exepcted_individual, returned_individual )
************************************
************************************
[+] input: Throwable { List<Integer> list = Arrays.asList(new Integer[] { 1, 2, 4, 3 }); List<String> res = new ArrayList<>(); each(TypeSpec.VOID, list.iterator(), (e, seq) -> { append("" + e, res).handle(seq::repeat); }).get(1000, TimeUnit.MILLISECONDS);  List<String> exp = Arrays.asList(new String[] { "1", "2", "4", "3" }); "<AssertPlaceHolder>"; }
each(TypeSpec<T> loopType, Iterator<E> it, AsyncLoopFirstActionConsumesAndProduces<T, E, U> producer, TypeSpec<U> iterateType, AsyncLoopSecondActionConsumes<T, U> consumer) { return loop(loopType, (handler) -> { if (it.hasNext()) { E elem; try { elem = it.next(); } catch (Throwable exc) { handler.exit(null, exc); return; } producer.accept(elem, handler); } else { handler.exit(null, null); } }, iterateType, consumer); }
[*] target: assertEquals(exp, res)
[-] pred: org. junit. Assert. assertEquals ( exp, res )
************************************
************************************
[+] input: InterruptedException { Node node1 = new Node(new InetSocketAddress("127.0.0.1", 10001)); NodeEntry ne1 = new NodeEntry(NetUtil.getNodeId(), node1); Thread.sleep(1); Node node2 = new Node(new InetSocketAddress("127.0.0.1", 10002)); NodeEntry ne2 = new NodeEntry(NetUtil.getNodeId(), node2); TimeComparator tc = new TimeComparator(); int result = tc.compare(ne1, ne2); Assert."<AssertPlaceHolder>";  }
compare(NodeEntry e1, NodeEntry e2) { long t1 = e1.getModified(); long t2 = e2.getModified();  if (t1 < t2) { return 1; } else if (t1 > t2) { return -1; } else { return 0; } }
[*] target: assertEquals(1, result)
[-] pred: org. junit. Assert. assertEquals ( 1, result )
************************************
************************************
[+] input: testGetExpiredMetadataInfos() { Set<ExpiredMetadataInfo> expiredMetadataInfos = namingMetadataManager.getExpiredMetadataInfos();  Assert."<AssertPlaceHolder>"; }
getExpiredMetadataInfos() { return expiredMetadataInfos; }
[*] target: assertNotNull(expiredMetadataInfos)
[-] pred: org. junit. Assert. assertNotNull ( expiredMetadataInfos )
************************************
************************************
[+] input: randomizedTest() { BuggyAList<Integer> ba = new BuggyAList<>(); AListNoResizing<Integer> anr = new AListNoResizing<>();  int N = 5000; for (int i = 0; i < N; i += 1) { int operationNumber = StdRandom.uniform(0, 4); if (operationNumber == 0) { // addLast int randVal = StdRandom.uniform(0, 100); ba.addLast(randVal); anr.addLast(randVal); System.out.println("addLast(" + randVal + ")"); } else if (operationNumber == 1) { // size int size = ba.size(); int size2 = anr.size(); System.out.println("size: " + size + " size2: " + size2); assertEquals(size, size2); } else if (operationNumber == 2) { // getLast if (ba.size() > 0 && anr.size() > 0) { int ret = ba.getLast(); int ret2 = anr.getLast(); System.out.println("getLast(" + ret + ")" + " getLast(" + ret2 + ")"); assertEquals(ret, ret2); } } else if (operationNumber == 3) { // removeLast if (ba.size() > 0 && anr.size() > 0) { int ret = ba.removeLast(); int ret2 = anr.removeLast(); System.out.println("removeLast(" + ret + ")" + " removeLast(" + ret2 + ")"); "<AssertPlaceHolder>"; } } } }
removeLast() { if ((size < items.length / 4) && (size > 4)) { resize(items.length / 4); } Item x = getLast(); items[size - 1] = null; size = size - 1; return x; }
[*] target: assertEquals(ret, ret2)
[-] pred: org. junit. Assert. assertEquals ( ret, ret2 )
************************************
************************************
[+] input: Exception { Namespace scope = st.createNameSpace(null, "TestNameSpace", SourceType.USER_DEFINED); "<AssertPlaceHolder>"; assertEquals("TestNameSpace", scope.getName()); assertTrue(scope.getBody().isEmpty()); assertEquals(globalScope, scope.getParentNamespace()); Symbol symbol = scope.getSymbol(); assertEquals(scope.getName(), symbol.getName()); assertEquals(globalScope, symbol.getParentNamespace()); }
createNameSpace(Namespace parent, String name, SourceType source) throws DuplicateNameException, InvalidInputException { SymbolDB s = createNamespaceSymbol(name, parent, source, true); return new NamespaceDB(s, namespaceMgr); }
[*] target: assertNotNull(scope)
[-] pred: org. junit. Assert. assertNotNull ( scope )
************************************
************************************
[+] input: Exception {  /*  Note: the empty template type: '<, std...' <, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>   std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > std::_Bind<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > (EduAppConfigs::*(EduAppConfigs const*))() const>::operator()<, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >()  */ String mangled = "_ZNSt5_BindIFM13EduAppConfigsKFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEPKS0_EEclIJES6_EET0_DpOT_";  String demangled = process.demangle(mangled);  DemangledObject object = parser.parse(mangled, demangled); "<AssertPlaceHolder>"; assertType(object, DemangledFunction.class);  String signature = object.getSignature(false); assertEquals( "std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>> std::_Bind<std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>(EduAppConfigs::*(EduAppConfigs_const*))()const>::operator()<missing_argument,std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>>(void)", signature); }
parse(String mangled, String demangled) throws DemanglerParseException {  this.mangledSource = mangled; this.demangledSource = demangled;  DemangledObjectBuilder builder = getSpecializedBuilder(demangled); if (builder != null) { return builder.build(); }  return parseFunctionOrVariable(demangled); }
[*] target: assertNotNull(object)
[-] pred: org. junit. Assert. assertNotNull ( object )
************************************
************************************
[+] input: testReentry() { // This is very contrived. A real use would pass ownership to some method which cannot // assume that it already holds the lock Deque<CompletableFuture<Void>> queue = new LinkedList<>(); AsyncLock l = new AsyncLock(); AtomicReference<AsyncLock.Hold> hold = new AtomicReference<>(); AtomicReference<AsyncLock.Hold> hold2 = new AtomicReference<>(); List<Integer> result = new ArrayList<>();  l.with(TypeSpec.VOID, null, hold).then((seq) -> { result.add(1); CompletableFuture<Void> future = new CompletableFuture<>(); queue.add(future); future.handle(seq::next); }).then((seq) -> { l.with(TypeSpec.VOID, hold.get(), hold2).then((seq2) -> { result.add(2); CompletableFuture<Void> future = new CompletableFuture<>(); queue.add(future); future.handle(seq2::next); }).finish().handle(seq::next); }).then((seq) -> { result.add(3); seq.exit(); });  CompletableFuture<Void> future; while (null != (future = queue.poll())) { future.complete(null); }  List<Integer> exp = Arrays.asList(new Integer[] { 1, 2, 3 }); "<AssertPlaceHolder>"; }
with(TypeSpec<R> type, Hold hold, AtomicReference<Hold> handle) { return sequence(type).then((seq) -> { acquire(hold).handle(seq::next); }, handle).onExit((result, exc) -> { handle.get().release(); }); }
[*] target: assertEquals(exp, result)
[-] pred: org. junit. Assert. assertEquals ( exp, result )
************************************
************************************
[+] input: hasNoTransitionsShouldReturnFalseWhenThisStateHasTransitions() { state.addTransition((byte) 'a', new ByteState());  boolean hasNoTransitions = state.hasNoTransitions();  "<AssertPlaceHolder>"; }
hasNoTransitions() { return transitionStore == null; }
[*] target: assertFalse(hasNoTransitions)
[-] pred: org. junit. Assert. assertFalse ( hasNoTransitions )
************************************
************************************
[+] input: Exception { IPackageFragment pack = fSourceFolder.createPackageFragment("test", false, null); String klazz = "package test;\n" + "import test.foo.TestMessages;\n" + TEST_KLAZZ; ICompilationUnit cu= pack.createCompilationUnit("Test.java", klazz, false, null);  IPackageFragment fooPackage = fSourceFolder.createPackageFragment("test.foo", false, null); klazz = "package test.foo;\n" + ACCESSOR_KLAZZ; fooPackage.createCompilationUnit("TestMessages.java", klazz, false, null);  NLSHint hint = createNLSHint(cu); "<AssertPlaceHolder>"; }
getAccessorClassPackage() { return fAccessorPackage; }
[*] target: assertEquals(fooPackage, hint.getAccessorClassPackage())
[-] pred: org. junit. Assert. assertEquals ( fooPackage, hint. getAccessorClassPackage ( ) )
************************************
************************************
[+] input: Exception { AddressSet set = new AddressSet(); set.addRange(getAddr(0), getAddr(0x200)); set.addRange(getAddr(0x205), getAddr(0x1000)); set.addRange(getAddr(0x5000), getAddr(0x6001)); AddressSetPropertyMap pm = program.createAddressSetPropertyMap("MyMap"); pm.add(set);  AddressSet s = new AddressSet(); s.addRange(getAddr(5), getAddr(0x6000));  pm.remove(s);  s = set.subtract(new AddressSet(getAddr(5), getAddr(0x6000))); AddressSet pset = pm.getAddressSet(); "<AssertPlaceHolder>";  }
getAddressSet();
[*] target: assertEquals(s, pset)
[-] pred: org. junit. Assert. assertEquals ( s, pset )
************************************
************************************
[+] input: lowerCase() { // given String nativeSql = "insert into ?.? (ts, temperature, humidity) using ?.? tags(?,?) values(now, ?, ?)"; Object[] parameters = Stream.of("test", "t1", "test", "weather", "beijing", 1, 12.2, 4).toArray();  // when String actual = Utils.getNativeSql(nativeSql, parameters);  // then String expected = "insert into test.t1 (ts, temperature, humidity) using test.weather tags('beijing',1) values(now, 12.2, 4)"; Assert."<AssertPlaceHolder>"; }
getNativeSql(String rawSql, Object[] parameters) { if (parameters == null || !rawSql.contains("?")) return rawSql; // toLowerCase String preparedSql = rawSql.trim().toLowerCase(); String[] clause = new String[]{"tags\\s*\\([\\s\\S]*?\\)", "where[\\s\\S]*"}; Map<Integer, Integer> placeholderPositions = new HashMap<>(); RangeSet<Integer> clauseRangeSet = TreeRangeSet.create(); findPlaceholderPosition(preparedSql, placeholderPositions); // find tags and where clause's position findClauseRangeSet(preparedSql, clause, clauseRangeSet); // find values clause's position findValuesClauseRangeSet(preparedSql, clauseRangeSet);  return transformSql(rawSql, parameters, placeholderPositions, clauseRangeSet); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testExtractDefaultValueNull() { List<String> columnSpecs = Arrays.asList("Default", null, "comment", null); String actualDefault = schemaManager.extractDefaultValue(DorisType.STRING, columnSpecs); Assert."<AssertPlaceHolder>"; }
extractDefaultValue(String dateType, List<String> columnSpecs) { if (CollectionUtils.isEmpty(columnSpecs)) { return null; } String adjacentDefaultValue = extractAdjacentString(columnSpecs, DEFAULT); return parseDorisDefaultValue(dateType, adjacentDefaultValue); }
[*] target: assertNull(actualDefault)
[-] pred: org. junit. Assert. assertNull ( actualDefault )
************************************
************************************

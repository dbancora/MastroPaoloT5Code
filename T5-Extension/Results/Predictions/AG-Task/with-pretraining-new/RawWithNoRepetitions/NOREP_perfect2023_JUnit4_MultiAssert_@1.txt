[+] input: testSetRootLevel() { Logger root = logger("root"); root.setLevel(Level.ERROR);  Logger p = logger("a.b.c.p"); Logger x = logger("a.b.c.p.X"); Logger y = logger("a.b.c.p.Y"); Logger z = logger("a.b.c.p.Z"); Logger w = logger("a.b.c.s.W"); x.setLevel(Level.INFO); y.setLevel(Level.INFO); z.setLevel(Level.INFO); w.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, x, y, z, w);  List<String> modified = loggers.setLevel("root", Level.DEBUG); assertEquals(Arrays.asList("a.b.c.p.X", "a.b.c.p.Y", "a.b.c.p.Z", "a.b.c.s.W", "root"), modified);  assertNull(p.getLevel());  assertEquals(root.getLevel(), Level.DEBUG);  assertEquals(w.getLevel(), Level.DEBUG); assertEquals(x.getLevel(), Level.DEBUG); assertEquals(y.getLevel(), Level.DEBUG); assertEquals(z.getLevel(), Level.DEBUG);  Map<String, LoggerLevel> expectedLevels = new HashMap<>(); expectedLevels.put("root", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.p.X", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.p.Y", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.p.Z", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.s.W", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME));  Map<String, LoggerLevel> actualLevels = loggers.allLevels(); "<AssertPlaceHolder>"; }
allLevels() { Map<String, LoggerLevel> result = new TreeMap<>();  Enumeration<org.apache.log4j.Logger> enumeration = currentLoggers(); Collections.list(enumeration) .stream() .filter(logger -> logger.getLevel() != null) .forEach(logger -> result.put(logger.getName(), loggerLevel(logger)));  org.apache.log4j.Logger root = rootLogger(); if (root.getLevel() != null) { result.put(ROOT_LOGGER_NAME, loggerLevel(root)); }  return result; }
[*] target: assertEquals(expectedLevels, actualLevels)
[-] pred: org. junit. Assert. assertEquals ( expectedLevels, actualLevels )
************************************
************************************
[+] input: connectorConfig() { final String connName = "sink6"; final Map<String, String> expectedConfig = Collections.singletonMap("key", "value");  @SuppressWarnings("unchecked") ArgumentCaptor<Callback<Map<String, String>>> callback = ArgumentCaptor.forClass(Callback.class); doAnswer(invocation -> { callback.getValue().onCompletion(null, expectedConfig); return null; }).when(herder).connectorConfig(eq(connName), callback.capture());  Map<String, String> actualConfig = connectClusterState.connectorConfig(connName);  "<AssertPlaceHolder>"; assertNotSame( "Config should be copied in order to avoid mutation by REST extensions", expectedConfig, actualConfig ); }
connectorConfig(String connName) { FutureCallback<Map<String, String>> connectorConfigCallback = new FutureCallback<>(); herder.connectorConfig(connName, connectorConfigCallback); try { return new HashMap<>(connectorConfigCallback.get(herderRequestTimeoutMs, TimeUnit.MILLISECONDS)); } catch (InterruptedException | ExecutionException | TimeoutException e) { throw new ConnectException( String.format("Failed to retrieve configuration for connector '%s'", connName), e ); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: shouldInstantiateAndConfigureExplicitlySetHeaderConverterWithCurrentClassLoader() { assertNotNull(props.get(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG)); HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNotNull(headerConverter); assertInstanceOf(TestHeaderConverter.class, headerConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config"));  headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertInstanceOf(TestHeaderConverter.class, headerConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config")); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { Class<? extends HeaderConverter> klass = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) klass = pluginClassFromConfig(config, classPropertyName, HeaderConverter.class, scanResult.headerConverters()); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(scanResult.headerConverters()) ); } } if (klass == null) { throw new ConnectException("Unable to initialize the HeaderConverter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration keys:{}{}", System.lineSeparator(), converterConfig.keySet());  HeaderConverter plugin; try (LoaderSwap loaderSwap = withClassLoader(klass.getClassLoader())) { plugin = newPlugin(klass); plugin.configure(converterConfig); } return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: shouldInstantiateAndConfigureConnectRestExtension() { props.clear(); props.put(RestServerConfig.REST_EXTENSION_CLASSES_CONFIG, TestConnectRestExtension.class.getName()); config = RestServerConfig.forPublic(null, props);  List<ConnectRestExtension> connectRestExtensions = plugins.newPlugins(config.getList(RestServerConfig.REST_EXTENSION_CLASSES_CONFIG), config, ConnectRestExtension.class); "<AssertPlaceHolder>"; assertEquals("One Rest Extension expected", 1, connectRestExtensions.size()); assertNotNull(connectRestExtensions.get(0)); assertTrue("Should be instance of TestConnectRestExtension", connectRestExtensions.get(0) instanceof TestConnectRestExtension); assertNotNull(((TestConnectRestExtension) connectRestExtensions.get(0)).configs); assertEquals(config.originals(), ((TestConnectRestExtension) connectRestExtensions.get(0)).configs); }
newPlugins(List<String> klassNames, AbstractConfig config, Class<T> pluginKlass) { List<T> plugins = new ArrayList<>(); if (klassNames != null) { for (String klassName : klassNames) { plugins.add(newPlugin(klassName, config, pluginKlass)); } } return plugins; }
[*] target: assertNotNull(connectRestExtensions)
[-] pred: org. junit. Assert. assertNotNull ( connectRestExtensions )
************************************
************************************
[+] input: shouldInstantiateAndConfigureDefaultHeaderConverter() { props.remove(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG); createConfig();  // Because it's not explicitly set on the supplied configuration, the logic to use the current classloader for the connector // will exit immediately, and so this method always returns null HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNull(headerConverter); // But we should always find it (or the worker's default) when using the plugins classloader ... headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertInstanceOf(SimpleHeaderConverter.class, headerConverter); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { Class<? extends HeaderConverter> klass = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) klass = pluginClassFromConfig(config, classPropertyName, HeaderConverter.class, scanResult.headerConverters()); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(scanResult.headerConverters()) ); } } if (klass == null) { throw new ConnectException("Unable to initialize the HeaderConverter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration keys:{}{}", System.lineSeparator(), converterConfig.keySet());  HeaderConverter plugin; try (LoaderSwap loaderSwap = withClassLoader(klass.getClassLoader())) { plugin = newPlugin(klass); plugin.configure(converterConfig); } return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: testToTargetState() { assertEquals(TargetState.STARTED, CreateConnectorRequest.InitialState.RUNNING.toTargetState()); assertEquals(TargetState.PAUSED, CreateConnectorRequest.InitialState.PAUSED.toTargetState()); assertEquals(TargetState.STOPPED, CreateConnectorRequest.InitialState.STOPPED.toTargetState());  CreateConnectorRequest createConnectorRequest = new CreateConnectorRequest("test-name", Collections.emptyMap(), null); "<AssertPlaceHolder>"; }
initialTargetState() { if (initialState != null) { return initialState.toTargetState(); } else { return null; } }
[*] target: assertNull(createConnectorRequest.initialTargetState())
[-] pred: org. junit. Assert. assertNull ( createConnectorRequest. initialTargetState() )
************************************
************************************
[+] input: shouldGetAllStreamInstances() { final StreamsMetadata one = new StreamsMetadataImpl(hostOne, mkSet(globalTable, "table-one", "table-two", "merged-table"), mkSet(topic1P0, topic2P1, topic4P0), mkSet("table-one", "table-two", "merged-table"), mkSet(topic2P0, topic1P1)); final StreamsMetadata two = new StreamsMetadataImpl(hostTwo, mkSet(globalTable, "table-two", "table-one", "merged-table"), mkSet(topic2P0, topic1P1), mkSet("table-three"), mkSet(topic3P0)); final StreamsMetadata three = new StreamsMetadataImpl(hostThree, mkSet(globalTable, "table-three"), Collections.singleton(topic3P0), mkSet("table-one", "table-two", "merged-table"), mkSet(topic1P0, topic2P1, topic4P0));  final Collection<StreamsMetadata> actual = metadataState.getAllMetadata(); "<AssertPlaceHolder>"; assertTrue("expected " + actual + " to contain " + one, actual.contains(one)); assertTrue("expected " + actual + " to contain " + two, actual.contains(two)); assertTrue("expected " + actual + " to contain " + three, actual.contains(three)); }
getAllMetadata() { return Collections.unmodifiableList(allMetadata); }
[*] target: assertEquals(3, actual.size())
[-] pred: org. junit. Assert. assertEquals ( 3, actual. size ( ) )
************************************
************************************
[+] input: shouldEnableRackAwareAssignorWithStandbyDescribingTopics() { final MockInternalTopicManager spyTopicManager = spy(mockInternalTopicManager); doReturn( Collections.singletonMap( TP_0_NAME, Collections.singletonList( new TopicPartitionInfo(0, NODE_0, Arrays.asList(REPLICA_1), Collections.emptyList()) ) ) ).when(spyTopicManager).getTopicPartitionInfo(Collections.singleton(TP_0_NAME));  doReturn( Collections.singletonMap( CHANGELOG_TP_0_NAME, Collections.singletonList( new TopicPartitionInfo(0, NODE_0, Arrays.asList(REPLICA_1), Collections.emptyList()) ) ) ).when(spyTopicManager).getTopicPartitionInfo(Collections.singleton(CHANGELOG_TP_0_NAME));  final RackAwareTaskAssignor assignor = spy(new RackAwareTaskAssignor( getClusterWithNoNode(), getTaskTopicPartitionMapForTask0(), getTaskChangeLogTopicPartitionMapForTask0(), getTopologyGroupTaskMap(), getProcessRacksForProcess0(), spyTopicManager, getRackAwareEnabledConfigWithStandby(1), time ));  assertTrue(assignor.canEnableRackAwareAssignor()); verify(assignor, times(1)).populateTopicsToDescribe(anySet(), eq(false)); verify(assignor, times(1)).populateTopicsToDescribe(anySet(), eq(true));  final Map<TopicPartition, Set<String>> racksForPartition = assignor.racksForPartition(); final Map<TopicPartition, Set<String>> expected = mkMap( mkEntry(TP_0_0, mkSet(RACK_1, RACK_2)), mkEntry(CHANGELOG_TP_0_0, mkSet(RACK_1, RACK_2)) ); "<AssertPlaceHolder>"; }
racksForPartition() { return Collections.unmodifiableMap(racksForPartition); }
[*] target: assertEquals(expected, racksForPartition)
[-] pred: org. junit. Assert. assertEquals ( expected, racksForPartition )
************************************
************************************
[+] input: shouldOptimizeEmptyActiveTasks() { final RackAwareTaskAssignor assignor = new RackAwareTaskAssignor( getClusterForAllTopics(), getTaskTopicPartitionMapForAllTasks(), mkMap(), getTopologyGroupTaskMap(), getProcessRacksForAllProcess(), mockInternalTopicManager, getRackAwareEnabledConfig(), time );  final ClientState clientState1 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1);  clientState1.assignActiveTasks(mkSet(TASK_0_1, TASK_1_1));  final SortedMap<UUID, ClientState> clientStateMap = new TreeMap<>(mkMap( mkEntry(UUID_1, clientState1) )); final SortedSet<TaskId> taskIds = mkSortedSet();  assertTrue(assignor.canEnableRackAwareAssignor()); final long originalCost = assignor.activeTasksCost(taskIds, clientStateMap, trafficCost, nonOverlapCost); assertEquals(0, originalCost);  final long cost = assignor.optimizeActiveTasks(taskIds, clientStateMap, trafficCost, nonOverlapCost); "<AssertPlaceHolder>";  assertEquals(mkSet(TASK_0_1, TASK_1_1), clientState1.activeTasks()); }
optimizeActiveTasks(final SortedSet<TaskId> activeTasks, final SortedMap<UUID, ClientState> clientStates, final int trafficCost, final int nonOverlapCost) { if (activeTasks.isEmpty()) { return 0; }  log.info("Assignment before active task optimization is {}\n with cost {}", clientStates, activeTasksCost(activeTasks, clientStates, trafficCost, nonOverlapCost));  final long startTime = time.milliseconds(); final List<UUID> clientList = new ArrayList<>(clientStates.keySet()); final List<TaskId> taskIdList = new ArrayList<>(activeTasks); final Map<TaskId, UUID> taskClientMap = new HashMap<>(); final Map<UUID, Integer> originalAssignedTaskNumber = new HashMap<>(); final RackAwareGraphConstructor<ClientState> graphConstructor = RackAwareGraphConstructorFactory.create(assignmentConfigs, tasksForTopicGroup); final Graph<Integer> graph = graphConstructor.constructTaskGraph( clientList, taskIdList, clientStates, taskClientMap, originalAssignedTaskNumber, ClientState::hasActiveTask, this::getCost, trafficCost, nonOverlapCost, false, false );  graph.solveMinCostFlow(); final long cost = graph.totalCost();  graphConstructor.assignTaskFromMinCostFlow(graph, clientList, taskIdList, clientStates, originalAssignedTaskNumber, taskClientMap, ClientState::assignActive, ClientState::unassignActive, ClientState::hasActiveTask);  final long duration = time.milliseconds() - startTime; log.info("Assignment after {} milliseconds for active task optimization is {}\n with cost {}", duration, clientStates, cost); return cost; }
[*] target: assertEquals(0, cost)
[-] pred: org. junit. Assert. assertEquals ( 0, cost )
************************************
************************************
[+] input: shouldOptimizeActiveTasks() { final Map<Subtopology, Set<TaskId>> tasksForTopicGroup = mkMap( mkEntry(new Subtopology(0, null), mkSet(TASK_0_0, TASK_0_1)), mkEntry(new Subtopology(1, null), mkSet(TASK_1_0, TASK_1_1)) ); final RackAwareTaskAssignor assignor = new RackAwareTaskAssignor( getClusterForAllTopics(), getTaskTopicPartitionMapForAllTasks(), mkMap(), tasksForTopicGroup, getProcessRacksForAllProcess(), mockInternalTopicManager, getRackAwareEnabledConfig(), time );  final ClientState clientState1 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1); final ClientState clientState2 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1); final ClientState clientState3 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1);  clientState1.assignActiveTasks(mkSet(TASK_0_1, TASK_1_1)); clientState2.assignActive(TASK_1_0); clientState3.assignActive(TASK_0_0);  // task_0_0 has same rack as UUID_1 // task_0_1 has same rack as UUID_2 and UUID_3 // task_1_0 has same rack as UUID_1 and UUID_3 // task_1_1 has same rack as UUID_2 // Optimal assignment is UUID_1: {0_0, 1_0}, UUID_2: {1_1}, UUID_3: {0_1} which result in no cross rack traffic final SortedMap<UUID, ClientState> clientStateMap = new TreeMap<>(mkMap( mkEntry(UUID_1, clientState1), mkEntry(UUID_2, clientState2), mkEntry(UUID_3, clientState3) )); final SortedSet<TaskId> taskIds = mkSortedSet(TASK_0_0, TASK_0_1, TASK_1_0, TASK_1_1);  assertTrue(assignor.canEnableRackAwareAssignor()); int expected = stateful ? 40 : 4; final long originalCost = assignor.activeTasksCost(taskIds, clientStateMap, trafficCost, nonOverlapCost); assertEquals(expected, originalCost);  expected = stateful ? 4 : 0; final long cost = assignor.optimizeActiveTasks(taskIds, clientStateMap, trafficCost, nonOverlapCost); "<AssertPlaceHolder>";  assertEquals(mkSet(TASK_0_0, TASK_1_0), clientState1.activeTasks()); assertEquals(mkSet(TASK_1_1), clientState2.activeTasks()); assertEquals(mkSet(TASK_0_1), clientState3.activeTasks()); }
optimizeActiveTasks(final SortedSet<TaskId> activeTasks, final SortedMap<UUID, ClientState> clientStates, final int trafficCost, final int nonOverlapCost) { if (activeTasks.isEmpty()) { return 0; }  log.info("Assignment before active task optimization is {}\n with cost {}", clientStates, activeTasksCost(activeTasks, clientStates, trafficCost, nonOverlapCost));  final long startTime = time.milliseconds(); final List<UUID> clientList = new ArrayList<>(clientStates.keySet()); final List<TaskId> taskIdList = new ArrayList<>(activeTasks); final Map<TaskId, UUID> taskClientMap = new HashMap<>(); final Map<UUID, Integer> originalAssignedTaskNumber = new HashMap<>(); final RackAwareGraphConstructor<ClientState> graphConstructor = RackAwareGraphConstructorFactory.create(assignmentConfigs, tasksForTopicGroup); final Graph<Integer> graph = graphConstructor.constructTaskGraph( clientList, taskIdList, clientStates, taskClientMap, originalAssignedTaskNumber, ClientState::hasActiveTask, this::getCost, trafficCost, nonOverlapCost, false, false );  graph.solveMinCostFlow(); final long cost = graph.totalCost();  graphConstructor.assignTaskFromMinCostFlow(graph, clientList, taskIdList, clientStates, originalAssignedTaskNumber, taskClientMap, ClientState::assignActive, ClientState::unassignActive, ClientState::hasActiveTask);  final long duration = time.milliseconds() - startTime; log.info("Assignment after {} milliseconds for active task optimization is {}\n with cost {}", duration, clientStates, cost); return cost; }
[*] target: assertEquals(expected, cost)
[-] pred: org. junit. Assert. assertEquals ( expected, cost )
************************************
************************************
[+] input: shouldCreateWriteBatches() { final String key = "a"; final Collection<ConsumerRecord<byte[], byte[]>> records = new ArrayList<>(); records.add(new ConsumerRecord<>("", 0, 0L, serializeKey(new Windowed<>(key, windows[0]), true).get(), serializeValue(50L))); records.add(new ConsumerRecord<>("", 0, 0L, serializeKey(new Windowed<>(key, windows[3]), true).get(), serializeValue(100L))); final Map<S, WriteBatch> writeBatchMap = bytesStore.getWriteBatches(records); "<AssertPlaceHolder>";  final int expectedCount = getIndexSchema() == null ? 1 : 2; for (final WriteBatch batch : writeBatchMap.values()) { // 2 includes base and index record assertEquals(expectedCount, batch.count()); } }
getWriteBatches(final Collection<ConsumerRecord<byte[], byte[]>> records);  @Override public Position getPosition() { return position; }
[*] target: assertEquals(2, writeBatchMap.size())
[-] pred: org. junit. Assert. assertEquals ( 2, writeBatchMap. size ( ) )
************************************
************************************
[+] input: shouldReturnTimestampedKeyValueStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlyKeyValueStore<String, ValueAndTimestamp<String>>> stores = provider.stores("ts-kv-store", QueryableStoreTypes.timestampedKeyValueStore()); "<AssertPlaceHolder>"; for (final ReadOnlyKeyValueStore<String, ValueAndTimestamp<String>> store : stores) { assertThat(store, instanceOf(ReadOnlyKeyValueStore.class)); assertThat(store, instanceOf(TimestampedKeyValueStore.class)); } }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { final StateStore store = globalStateStores.get(storeName); if (store == null || !queryableStoreType.accepts(store)) { return Collections.emptyList(); } if (!store.isOpen()) { throw new InvalidStateStoreException("the state store, " + storeName + ", is not open."); } if (store instanceof TimestampedKeyValueStore && queryableStoreType instanceof QueryableStoreTypes.KeyValueStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyKeyValueStoreFacade((TimestampedKeyValueStore<Object, Object>) store)); } else if (store instanceof TimestampedWindowStore && queryableStoreType instanceof QueryableStoreTypes.WindowStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyWindowStoreFacade((TimestampedWindowStore<Object, Object>) store)); } return (List<T>) Collections.singletonList(store); }
[*] target: assertEquals(1, stores.size())
[-] pred: org. junit. Assert. assertEquals ( 1, stores. size ( ) )
************************************
************************************
[+] input: shouldReturnSessionStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlySessionStore<String, String>> stores = provider.stores("s-store", QueryableStoreTypes.sessionStore()); "<AssertPlaceHolder>"; for (final ReadOnlySessionStore<String, String> store : stores) { assertThat(store, instanceOf(ReadOnlySessionStore.class)); } }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { final StateStore store = globalStateStores.get(storeName); if (store == null || !queryableStoreType.accepts(store)) { return Collections.emptyList(); } if (!store.isOpen()) { throw new InvalidStateStoreException("the state store, " + storeName + ", is not open."); } if (store instanceof TimestampedKeyValueStore && queryableStoreType instanceof QueryableStoreTypes.KeyValueStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyKeyValueStoreFacade((TimestampedKeyValueStore<Object, Object>) store)); } else if (store instanceof TimestampedWindowStore && queryableStoreType instanceof QueryableStoreTypes.WindowStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyWindowStoreFacade((TimestampedWindowStore<Object, Object>) store)); } return (List<T>) Collections.singletonList(store); }
[*] target: assertEquals(1, stores.size())
[-] pred: org. junit. Assert. assertEquals ( 1, stores. size ( ) )
************************************
************************************
[+] input: testTaskOps() { List<TaskModel> tasks = new LinkedList<>(); String workflowId = UUID.randomUUID().toString();  for (int i = 0; i < 3; i++) { TaskModel task = new TaskModel(); task.setScheduledTime(1L); task.setSeq(1); task.setTaskId(workflowId + "_t" + i); task.setReferenceTaskName("testTaskOps" + i); task.setRetryCount(0); task.setWorkflowInstanceId(workflowId); task.setTaskDefName("testTaskOps" + i); task.setStatus(TaskModel.Status.IN_PROGRESS); tasks.add(task); }  for (int i = 0; i < 3; i++) { TaskModel task = new TaskModel(); task.setScheduledTime(1L); task.setSeq(1); task.setTaskId("x" + workflowId + "_t" + i); task.setReferenceTaskName("testTaskOps" + i); task.setRetryCount(0); task.setWorkflowInstanceId("x" + workflowId); task.setTaskDefName("testTaskOps" + i); task.setStatus(TaskModel.Status.IN_PROGRESS); getExecutionDAO().createTasks(Collections.singletonList(task)); }  List<TaskModel> created = getExecutionDAO().createTasks(tasks); assertEquals(tasks.size(), created.size());  List<TaskModel> pending = getExecutionDAO().getPendingTasksForTaskType(tasks.get(0).getTaskDefName()); assertNotNull(pending); assertEquals(2, pending.size()); // Pending list can come in any order.  finding the one we are looking for and then // comparing TaskModel matching = pending.stream() .filter(task -> task.getTaskId().equals(tasks.get(0).getTaskId())) .findAny() .get(); assertTrue(EqualsBuilder.reflectionEquals(matching, tasks.get(0)));  for (int i = 0; i < 3; i++) { TaskModel found = getExecutionDAO().getTask(workflowId + "_t" + i); assertNotNull(found); found.getOutputData().put("updated", true); found.setStatus(TaskModel.Status.COMPLETED); getExecutionDAO().updateTask(found); }  List<String> taskIds = tasks.stream().map(TaskModel::getTaskId).collect(Collectors.toList()); List<TaskModel> found = getExecutionDAO().getTasks(taskIds); assertEquals(taskIds.size(), found.size()); found.forEach( task -> { assertTrue(task.getOutputData().containsKey("updated")); assertEquals(true, task.getOutputData().get("updated")); boolean removed = getExecutionDAO().removeTask(task.getTaskId()); assertTrue(removed); });  found = getExecutionDAO().getTasks(taskIds); "<AssertPlaceHolder>"; }
getTasks(List<String> taskIds);
[*] target: assertTrue(found.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( found. isEmpty ( ) )
************************************
************************************
[+] input: IOException { String path = "test/payload";  Map<String, Object> payload = new HashMap<>(); payload.put("key1", "value1"); payload.put("key2", 200); byte[] payloadBytes = objectMapper.writeValueAsString(payload).getBytes(); when(externalPayloadStorage.download(path)) .thenReturn(new ByteArrayInputStream(payloadBytes));  Map<String, Object> result = externalPayloadStorageUtils.downloadPayload(path); "<AssertPlaceHolder>"; assertEquals(payload, result); }
downloadPayload(String path) { try (InputStream inputStream = externalPayloadStorage.download(path)) { return objectMapper.readValue( IOUtils.toString(inputStream, StandardCharsets.UTF_8), Map.class); } catch (TransientException te) { throw te; } catch (Exception e) { LOGGER.error("Unable to download payload from external storage path: {}", path, e); throw new NonTransientException( "Unable to download payload from external storage path: " + path, e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testFailWorkflowWithInputPayload() { WorkflowModel workflow = new WorkflowModel(); workflow.setInput(new HashMap<>());  expectedException.expect(TerminateWorkflowException.class); externalPayloadStorageUtils.failWorkflow( workflow, ExternalPayloadStorage.PayloadType.TASK_INPUT, "error"); "<AssertPlaceHolder>"; assertTrue(workflow.getInput().isEmpty()); assertEquals(WorkflowModel.Status.FAILED, workflow.getStatus()); }
failWorkflow(WorkflowModel workflow, PayloadType payloadType, String errorMsg) { LOGGER.error(errorMsg); if (payloadType == PayloadType.WORKFLOW_INPUT) { workflow.setInput(new HashMap<>()); } else { workflow.setOutput(new HashMap<>()); } throw new TerminateWorkflowException(errorMsg); }
[*] target: assertNotNull(workflow)
[-] pred: org. junit. Assert. assertNotNull ( workflow )
************************************
************************************
[+] input: shouldFindTask() { TaskSummary taskSummary = TestUtils.loadTaskSnapshot(objectMapper, "task_summary"); indexDAO.indexTask(taskSummary);  List<TaskSummary> tasks = tryFindResults(() -> searchTaskSummary(taskSummary)); "<AssertPlaceHolder>"; assertEquals(taskSummary, tasks.get(0)); }
indexTask(TaskSummary task) { try { long startTime = Instant.now().toEpochMilli(); String id = task.getTaskId(); byte[] doc = objectMapper.writeValueAsBytes(task); String docType = StringUtils.isBlank(docTypeOverride) ? TASK_DOC_TYPE : docTypeOverride;  UpdateRequest req = new UpdateRequest(taskIndexName, docType, id); req.doc(doc, XContentType.JSON); req.upsert(doc, XContentType.JSON); indexObject(req, TASK_DOC_TYPE); long endTime = Instant.now().toEpochMilli(); LOGGER.debug( "Time taken {} for  indexing task:{} in workflow: {}", endTime - startTime, task.getTaskId(), task.getWorkflowId()); Monitors.recordESIndexTime("index_task", TASK_DOC_TYPE, endTime - startTime); Monitors.recordWorkerQueueSize( "indexQueue", ((ThreadPoolExecutor) executorService).getQueue().size()); } catch (Exception e) { LOGGER.error("Failed to index task: {}", task.getTaskId(), e); } }
[*] target: assertEquals(1, tasks.size())
[-] pred: org. junit. Assert. assertEquals ( 1, tasks. size ( ) )
************************************
************************************
[+] input: Exception { WorkflowSummary oldWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); oldWorkflow.setStatus(WorkflowStatus.RUNNING); oldWorkflow.setUpdateTime(getFormattedTime(new DateTime().minusHours(2).toDate()));  WorkflowSummary recentWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); recentWorkflow.setStatus(WorkflowStatus.RUNNING); recentWorkflow.setUpdateTime(getFormattedTime(new DateTime().minusHours(1).toDate()));  WorkflowSummary tooRecentWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); tooRecentWorkflow.setStatus(WorkflowStatus.RUNNING); tooRecentWorkflow.setUpdateTime(getFormattedTime(new DateTime().toDate()));  indexDAO.indexWorkflow(oldWorkflow); indexDAO.indexWorkflow(recentWorkflow); indexDAO.indexWorkflow(tooRecentWorkflow);  Thread.sleep(1000);  List<String> ids = indexDAO.searchRecentRunningWorkflows(2, 1);  "<AssertPlaceHolder>"; assertEquals(recentWorkflow.getWorkflowId(), ids.get(0)); }
searchRecentRunningWorkflows( int lastModifiedHoursAgoFrom, int lastModifiedHoursAgoTo) { DateTime dateTime = new DateTime(); QueryBuilder q = QueryBuilders.boolQuery() .must( QueryBuilders.rangeQuery("updateTime") .gt(dateTime.minusHours(lastModifiedHoursAgoFrom))) .must( QueryBuilders.rangeQuery("updateTime") .lt(dateTime.minusHours(lastModifiedHoursAgoTo))) .must(QueryBuilders.termQuery("status", "RUNNING"));  SearchResult<String> workflowIds; try { workflowIds = searchObjectIds( workflowIndexName, q, 0, 5000, Collections.singletonList("updateTime:ASC")); } catch (IOException e) { logger.error("Unable to communicate with ES to find recent running workflows", e); return Collections.emptyList(); }  return workflowIds.getResults(); }
[*] target: assertEquals(1, ids.size())
[-] pred: org. junit. Assert. assertEquals ( 1, ids. size ( ) )
************************************
************************************
[+] input: testGetAllWorkflowDefsLatestVersions() { WorkflowDef def = new WorkflowDef(); def.setName("test1"); def.setVersion(1); def.setDescription("description"); def.setCreatedBy("unit_test"); def.setCreateTime(1L); def.setOwnerApp("ownerApp"); def.setUpdatedBy("unit_test2"); def.setUpdateTime(2L); metadataDAO.createWorkflowDef(def);  def.setName("test2"); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def);  def.setName("test3"); def.setVersion(1); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def); def.setVersion(3); metadataDAO.createWorkflowDef(def);  // Placed the values in a map because they might not be stored in order of defName. // To test, needed to confirm that the versions are correct for the definitions. Map<String, WorkflowDef> allMap = metadataDAO.getAllWorkflowDefsLatestVersions().stream() .collect(Collectors.toMap(WorkflowDef::getName, Function.identity()));  "<AssertPlaceHolder>"; assertEquals(3, allMap.size()); assertEquals(1, allMap.get("test1").getVersion()); assertEquals(2, allMap.get("test2").getVersion()); assertEquals(3, allMap.get("test3").getVersion()); }
getAllWorkflowDefsLatestVersions() { final String GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY = "SELECT json_data FROM meta_workflow_def wd WHERE wd.version = (SELECT MAX(version) FROM meta_workflow_def wd2 WHERE wd2.name = wd.name)"; return queryWithTransaction( GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY, q -> q.executeAndFetch(WorkflowDef.class)); }
[*] target: assertNotNull(allMap)
[-] pred: org. junit. Assert. assertNotNull ( allMap )
************************************
************************************
[+] input: testGetAllWorkflowDefsLatestVersions() { WorkflowDef def = new WorkflowDef(); def.setName("test1"); def.setVersion(1); def.setDescription("description"); def.setCreatedBy("unit_test"); def.setCreateTime(1L); def.setOwnerApp("ownerApp"); def.setUpdatedBy("unit_test2"); def.setUpdateTime(2L); metadataDAO.createWorkflowDef(def);  def.setName("test2"); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def);  def.setName("test3"); def.setVersion(1); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def); def.setVersion(3); metadataDAO.createWorkflowDef(def);  // Placed the values in a map because they might not be stored in order of defName. // To test, needed to confirm that the versions are correct for the definitions. Map<String, WorkflowDef> allMap = metadataDAO.getAllWorkflowDefsLatestVersions().stream() .collect(Collectors.toMap(WorkflowDef::getName, Function.identity()));  "<AssertPlaceHolder>"; assertEquals(4, allMap.size()); assertEquals(1, allMap.get("test1").getVersion()); assertEquals(2, allMap.get("test2").getVersion()); assertEquals(3, allMap.get("test3").getVersion()); }
getAllWorkflowDefsLatestVersions() { final String GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY = "SELECT json_data FROM meta_workflow_def wd WHERE wd.version = (SELECT MAX(version) FROM meta_workflow_def wd2 WHERE wd2.name = wd.name)"; return queryWithTransaction( GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY, q -> q.executeAndFetch(WorkflowDef.class)); }
[*] target: assertNotNull(allMap)
[-] pred: org. junit. Assert. assertNotNull ( allMap )
************************************
************************************
[+] input: InterruptedException { redisson.getKeys().flushall(); String lockId = "abcd-1234"; boolean isLocked = redisLock.acquireLock(lockId, 1000, 1000, TimeUnit.MILLISECONDS); "<AssertPlaceHolder>";  Thread.sleep(2000);  RLock lock = redisson.getLock(lockId); assertFalse(lock.isLocked()); }
acquireLock(String lockId, long timeToTry, long leaseTime, TimeUnit unit) { RLock lock = redisson.getLock(parseLockId(lockId)); try { return lock.tryLock(timeToTry, leaseTime, unit); } catch (Exception e) { return handleAcquireLockFailure(lockId, e); } }
[*] target: assertTrue(isLocked)
[-] pred: org. junit. Assert. assertTrue ( isLocked )
************************************
************************************
[+] input: test1() { TestConditionAnnotationParser1 parser = new TestConditionAnnotationParser1(SimpleAnnotationFinder.INSTANCE); Field field1 = AbstractConditionParserTest.class.getDeclaredField("field1"); Assert.assertNotNull(field1); KeyTriggerOperation operation1 = SimpleKeyTriggerOperation.builder() .source(field1).id(field1.getName()).key(field1.getName()) .build(); Condition condition1 = CollectionUtils.getFirstNotNull(parser.parse(field1, operation1)); Assert."<AssertPlaceHolder>"; Assert.assertTrue(condition1.test(null, operation1)); }
parse( AnnotatedElement element, KeyTriggerOperation operation) { if (ignored.contains(element)) { return Collections.emptyList(); } List<Condition> results = doParse(element, operation); if (results.isEmpty()) { ignored.add(element); return Collections.emptyList(); } return results; }
[*] target: assertNotNull(condition1)
[-] pred: org. junit. Assert. assertNotNull ( condition1 )
************************************
************************************
[+] input: testGetBeanOperations() { BeanOperations ops = crane4jTemplate.getBeanOperations(Foo.class); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, ops.getAssembleOperations().size()); Assert.assertTrue(ops.getDisassembleOperations().isEmpty()); }
getBeanOperations(@NonNull AnnotatedElement element) { BeanOperationParser parser = configuration.getBeanOperationsParser(BeanOperationParser.class); return parser.parse(element); }
[*] target: assertNotNull(ops)
[-] pred: org. junit. Assert. assertNotNull ( ops )
************************************
************************************
[+] input: testRegisterOperatorProxyMethodFactory() { Crane4jTemplate.OpsForProxy ops = crane4jTemplate.opsForProxy(); AtomicBoolean processed = new AtomicBoolean(false); Assert.assertSame( ops, ops.registerOperatorProxyMethodFactory(new OperatorProxyMethodFactory() { @Override public int getSort() { return -1; } @Override public @Nullable MethodInvoker get( BeanOperations beanOperations, Method method, BeanOperationExecutor beanOperationExecutor) { processed.set(true); return null; } }) ); ops.createOperatorProxy(TestOperatorProxy.class); Assert."<AssertPlaceHolder>"; }
createOperatorProxy(@NonNull Class<T> operator) { return operatorProxyFactory.get(operator); }
[*] target: assertTrue(processed.get())
[-] pred: org. junit. Assert. assertTrue ( processed. get ( ) )
************************************
************************************
[+] input: testCreateOperatorProxy() { Crane4jTemplate.OpsForProxy ops = crane4jTemplate.opsForProxy(); TestOperatorProxy proxy = ops.createOperatorProxy(TestOperatorProxy.class); Assert."<AssertPlaceHolder>"; Foo foo = new Foo("1"); proxy.fill(foo); Assert.assertEquals("name" + foo.getId(), foo.getName()); }
createOperatorProxy(@NonNull Class<T> operator) { return operatorProxyFactory.get(operator); }
[*] target: assertNotNull(proxy)
[-] pred: org. junit. Assert. assertNotNull ( proxy )
************************************
************************************
[+] input: get() { List<Container<Object>> containers = factory.get(service, annotatedMethod, findAnnotations(annotatedMethod)); Container<Object> container = CollectionUtils.get(containers, 0); Assert.assertTrue(container instanceof CacheableContainer);  Object cachedA = container.get(Collections.singleton("a")).get("a"); Assert.assertNotNull(cachedA); Object a = container.get(Collections.singleton("a")).get("a"); Assert."<AssertPlaceHolder>"; }
get(@Nullable Object source, Method method, Collection<ContainerMethod> annotations) { log.debug("create cacheable method container from [{}]", method); ContainerCache annotation = annotationFinder.findAnnotation(method, ContainerCache.class); if (Objects.isNull(annotation)) { return super.get(source, method, annotations); } // wrap method container as cacheable container String managerName = StringUtils.emptyToDefault(annotation.cacheManager(), CacheManager.DEFAULT_MAP_CACHE_MANAGER_NAME); CacheManager cacheManager = configuration.getCacheManager(managerName); return super.get(source, method, annotations).stream() .map(container -> { CacheDefinition cacheDefinition = new CacheDefinition.Impl( container.getNamespace(), managerName, annotation.expirationTime(), annotation.timeUnit() ); return new CacheableContainer<>(container, cacheDefinition, cacheManager); }) .collect(Collectors.toList()); }
[*] target: assertSame(cachedA, a)
[-] pred: org. junit. Assert. assertSame ( cachedA, a )
************************************
************************************
[+] input: getConverter() { HutoolConverterManager hutoolConverterManager = new HutoolConverterManager(); // force cast object to collection hutoolConverterManager.getConverter(Object.class, Collection.class); @SuppressWarnings("rawtypes") BiFunction<Object, Collection, Collection> converter = hutoolConverterManager .getConverter(Object.class, Collection.class); Assert."<AssertPlaceHolder>";  Object obj = new Object(); Assert.assertEquals(CollectionUtils.newCollection(ArrayList::new, obj), converter.apply(obj, null)); Assert.assertEquals(converter.apply(Collections.singleton(obj), null), converter.apply(Collections.singleton(obj), null)); }
getConverter(Class<T> targetType, Class<R> resultType) { return (source, defaultValue) -> { if (resultType.isInstance(source)) { return (R)source; } return Convert.convert(resultType, source, defaultValue); }; }
[*] target: assertNotNull(converter)
[-] pred: org. junit. Assert. assertNotNull ( converter )
************************************
************************************
[+] input: testRegister() { context.setAllowContainerOverriding(true); beanMethodContainerRegistrar.register(service, Service.class);  // mappedMethod Container<?> mappedMethod = context.getContainer("mappedMethod"); Assert."<AssertPlaceHolder>"; Assert.assertEquals("mappedMethod", mappedMethod.getNamespace());  // onoToOneMethod Container<?> onoToOneMethod = context.getContainer("onoToOneMethod"); Assert.assertNotNull(onoToOneMethod); Assert.assertEquals("onoToOneMethod", onoToOneMethod.getNamespace());  // oneToManyMethod Container<?> oneToManyMethod = context.getContainer("oneToManyMethod"); Assert.assertTrue(oneToManyMethod instanceof CacheableContainer); Assert.assertEquals("oneToManyMethod", oneToManyMethod.getNamespace()); }
register(Object target, Class<?> targetType) { register(target, targetType, null); }
[*] target: assertNotNull(mappedMethod)
[-] pred: org. junit. Assert. assertNotNull ( mappedMethod )
************************************
************************************
[+] input: test() { ConversionService conversionService = DefaultConversionService.getSharedInstance(); SpringConverterManager converterManager = new SpringConverterManager(conversionService); Assert.assertSame(conversionService, converterManager.getConversionService());  BiFunction<String, Integer, Integer> converter = converterManager.getConverter(String.class, Integer.class); Assert."<AssertPlaceHolder>"; Assert.assertEquals((Integer)1, converter.apply("1", 0)); Assert.assertEquals((Integer)0, converter.apply("NaN", 0)); }
getConverter(Class<T> targetType, Class<R> resultType) { return (target, def) -> { try { return conversionService.convert(target, resultType); } catch (Exception e) { return def; } }; }
[*] target: assertNotNull(converter)
[-] pred: org. junit. Assert. assertNotNull ( converter )
************************************
************************************
[+] input: testToByteArray() { GeometryBuffer buffer = GeometryBufferFactory.create(bufferType, 2); buffer.putByte(0, (byte) 1); buffer.putByte(1, (byte) 2); byte[] bytes = buffer.toByteArray(); "<AssertPlaceHolder>"; assertEquals((byte) 1, bytes[0]); assertEquals((byte) 2, bytes[1]); }
toByteArray();
[*] target: assertEquals(2, bytes.length)
[-] pred: org. junit. Assert. assertEquals ( 2, bytes. length )
************************************
************************************
[+] input: createOKHttpClient() { OkHttpClient okHttpClient = WebUtils.okHttpClientWithTimeout(Duration.ofMinutes(10)); Assert."<AssertPlaceHolder>"; int timeout = okHttpClient.callTimeoutMillis(); Assert.assertEquals(10 * 60 * 1000, timeout); }
okHttpClientWithTimeout(Duration timeout) { log.info("Creating OkHttpClient with timeout {}", timeout); OkHttpClient client = new OkHttpClient.Builder() .callTimeout(timeout) .readTimeout(timeout) .connectTimeout(timeout) .build(); log.info("OkHttpClient created"); return client; }
[*] target: assertNotNull(okHttpClient)
[-] pred: org. junit. Assert. assertNotNull ( okHttpClient )
************************************
************************************
[+] input: test_get_tls_no_cert() { clientConnection.setAuthCipherSuite("cipher"); clientConnection.setAuthProtocol("TLSv1.2");  final ClientTlsInformation clientTlsInformation = ExtensionInformationUtil.getTlsInformationFromChannel(channel); "<AssertPlaceHolder>"; assertEquals("cipher", clientTlsInformation.getCipherSuite()); assertEquals("TLSv1.2", clientTlsInformation.getProtocol()); assertTrue(clientTlsInformation.getHostname().isEmpty()); assertTrue(clientTlsInformation.getClientCertificate().isEmpty()); }
getTlsInformationFromChannel(final @NotNull Channel channel) {  Preconditions.checkNotNull(channel, "channel must never be null");  final ClientConnection clientConnection = channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get(); try { final String cipher = clientConnection.getAuthCipherSuite(); final String protocol = clientConnection.getAuthProtocol(); final String sniHostname = clientConnection.getAuthSniHostname();  final SslClientCertificate sslClientCertificate = clientConnection.getAuthCertificate();  if (cipher == null || protocol == null) { return null; }  if (sslClientCertificate == null) { return new ClientTlsInformationImpl(null, null, cipher, protocol, sniHostname);  } else { final X509Certificate certificate = (X509Certificate) sslClientCertificate.certificate(); final X509Certificate[] certificateChain = (X509Certificate[]) sslClientCertificate.certificateChain();  return new ClientTlsInformationImpl(certificate, certificateChain, cipher, protocol, sniHostname); }  } catch (final Exception e) { log.debug("Tls information creation failed: ", e); }  return null; }
[*] target: assertNotNull(clientTlsInformation)
[-] pred: org. junit. Assert. assertNotNull ( clientTlsInformation )
************************************
************************************
[+] input: test_get_tls_with_sni() {  clientConnection.setAuthCipherSuite("cipher"); clientConnection.setAuthProtocol("TLSv1.2"); clientConnection.setAuthSniHostname("test.hostname.domain");  final ClientTlsInformation clientTlsInformation = ExtensionInformationUtil.getTlsInformationFromChannel(channel); "<AssertPlaceHolder>"; assertEquals("cipher", clientTlsInformation.getCipherSuite()); assertEquals("TLSv1.2", clientTlsInformation.getProtocol()); assertTrue(clientTlsInformation.getHostname().isPresent()); assertEquals("test.hostname.domain", clientTlsInformation.getHostname().get()); assertEquals("TLSv1.2", clientTlsInformation.getProtocol()); assertTrue(clientTlsInformation.getClientCertificate().isEmpty()); }
getTlsInformationFromChannel(final @NotNull Channel channel) {  Preconditions.checkNotNull(channel, "channel must never be null");  final ClientConnection clientConnection = channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get(); try { final String cipher = clientConnection.getAuthCipherSuite(); final String protocol = clientConnection.getAuthProtocol(); final String sniHostname = clientConnection.getAuthSniHostname();  final SslClientCertificate sslClientCertificate = clientConnection.getAuthCertificate();  if (cipher == null || protocol == null) { return null; }  if (sslClientCertificate == null) { return new ClientTlsInformationImpl(null, null, cipher, protocol, sniHostname);  } else { final X509Certificate certificate = (X509Certificate) sslClientCertificate.certificate(); final X509Certificate[] certificateChain = (X509Certificate[]) sslClientCertificate.certificateChain();  return new ClientTlsInformationImpl(certificate, certificateChain, cipher, protocol, sniHostname); }  } catch (final Exception e) { log.debug("Tls information creation failed: ", e); }  return null; }
[*] target: assertNotNull(clientTlsInformation)
[-] pred: org. junit. Assert. assertNotNull ( clientTlsInformation )
************************************
************************************
[+] input: test_fail() { output.authorizerPresent(); output.failAuthorization(); task.onSuccess(output);  channel.runPendingTasks();  final AuthorizeWillResultEvent resultEvent = eventsCollector.pollEvent(); "<AssertPlaceHolder>"; assertEquals(AckReasonCode.NOT_AUTHORIZED, resultEvent.getResult().getAckReasonCode()); assertEquals( "Not allowed to connect with Will Publish for unauthorized topic 'topic' with QoS '2' and retain 'false'", resultEvent.getResult().getReasonString()); }
onSuccess(@Nullable final PublishAuthorizerOutputImpl output) { if (output == null) { //this does not happen return; }  DisconnectReasonCode disconnectReasonCode = null; AckReasonCode reasonCode = null; String reasonString = null;  switch (output.getAuthorizationState()) { case DISCONNECT: disconnectReasonCode = output.getDisconnectReasonCode(); reasonCode = output.getAckReasonCode() != null ? output.getAckReasonCode() : AckReasonCode.NOT_AUTHORIZED; reasonString = output.getReasonString() != null ? output.getReasonString() : getReasonString(connect); break; case FAIL: reasonCode = output.getAckReasonCode() != null ? output.getAckReasonCode() : AckReasonCode.NOT_AUTHORIZED; reasonString = output.getReasonString() != null ? output.getReasonString() : getReasonString(connect); break; case UNDECIDED: if (!output.isAuthorizerPresent()) { //providers never returned an authorizer, same as continue break; } reasonCode = AckReasonCode.NOT_AUTHORIZED; reasonString = getReasonString(connect); break; case SUCCESS: reasonCode = AckReasonCode.SUCCESS; break; case CONTINUE: break; default: //no state left throw new IllegalStateException("Unknown type"); }  final PublishAuthorizerResult result = new PublishAuthorizerResult(reasonCode, reasonString, output.isAuthorizerPresent(), disconnectReasonCode); ctx.pipeline().fireUserEventTriggered(new PluginAuthorizerServiceImpl.AuthorizeWillResultEvent(connect, result)); }
[*] target: assertNotNull(resultEvent)
[-] pred: org. junit. Assert. assertNotNull ( resultEvent )
************************************
************************************
[+] input: test_fail_code_string() { output.authorizerPresent(); output.failAuthorization(AckReasonCode.TOPIC_NAME_INVALID, "test-string"); task.onSuccess(output);  channel.runPendingTasks();  final AuthorizeWillResultEvent resultEvent = eventsCollector.pollEvent(); "<AssertPlaceHolder>"; assertEquals(AckReasonCode.TOPIC_NAME_INVALID, resultEvent.getResult().getAckReasonCode()); assertEquals("test-string", resultEvent.getResult().getReasonString()); }
onSuccess(@Nullable final PublishAuthorizerOutputImpl output) { if (output == null) { //this does not happen return; }  DisconnectReasonCode disconnectReasonCode = null; AckReasonCode reasonCode = null; String reasonString = null;  switch (output.getAuthorizationState()) { case DISCONNECT: disconnectReasonCode = output.getDisconnectReasonCode(); reasonCode = output.getAckReasonCode() != null ? output.getAckReasonCode() : AckReasonCode.NOT_AUTHORIZED; reasonString = output.getReasonString() != null ? output.getReasonString() : getReasonString(connect); break; case FAIL: reasonCode = output.getAckReasonCode() != null ? output.getAckReasonCode() : AckReasonCode.NOT_AUTHORIZED; reasonString = output.getReasonString() != null ? output.getReasonString() : getReasonString(connect); break; case UNDECIDED: if (!output.isAuthorizerPresent()) { //providers never returned an authorizer, same as continue break; } reasonCode = AckReasonCode.NOT_AUTHORIZED; reasonString = getReasonString(connect); break; case SUCCESS: reasonCode = AckReasonCode.SUCCESS; break; case CONTINUE: break; default: //no state left throw new IllegalStateException("Unknown type"); }  final PublishAuthorizerResult result = new PublishAuthorizerResult(reasonCode, reasonString, output.isAuthorizerPresent(), disconnectReasonCode); ctx.pipeline().fireUserEventTriggered(new PluginAuthorizerServiceImpl.AuthorizeWillResultEvent(connect, result)); }
[*] target: assertNotNull(resultEvent)
[-] pred: org. junit. Assert. assertNotNull ( resultEvent )
************************************
************************************
[+] input: InterruptedException {  when(retainedMessagePersistence.clear()).thenReturn(Futures.immediateFuture(null));  final CompletableFuture<Void> clear = retainedMessageStore.clear();  "<AssertPlaceHolder>"; while (!clear.isDone()) { Thread.sleep(10); } assertTrue(clear.isDone()); assertFalse(clear.isCompletedExceptionally());  }
clear() { if (pluginServiceRateLimitService.rateLimitExceeded()) { return CompletableFuture.failedFuture(PluginServiceRateLimitService.RATE_LIMIT_EXCEEDED_EXCEPTION); } return ListenableFutureConverter.toCompletable(retainedMessagePersistence.clear(), globalManagedExtensionExecutorService); }
[*] target: assertNotNull(clear)
[-] pred: org. junit. Assert. assertNotNull ( clear )
************************************
************************************
[+] input: Exception { final SettableFuture<PublishStatus> future = SettableFuture.create(); final PUBLISH publish = new PUBLISHFactory.Mqtt3Builder() .withHivemqId("hivemqId") .withPayload(new byte[]{0}) .withTopic("topic") .withQoS(QoS.AT_MOST_ONCE) .withOnwardQos(QoS.AT_MOST_ONCE) .withMessageExpiryInterval(MESSAGE_EXPIRY_INTERVAL_NOT_SET) .withPublishId(1L) .withPersistence(publishPayloadPersistence) .build();  final PublishWithFuture publishWithFuture = new PublishWithFuture(publish, future, false, publishPayloadPersistence); final boolean messageDropped = handler.checkChannelNotWritable(ctx, publishWithFuture, promise); "<AssertPlaceHolder>"; assertEquals(PublishStatus.CHANNEL_NOT_WRITABLE, future.get()); verify(promise).setSuccess(); verify(messageDroppedService).notWritable("clientId", "topic", 0); }
checkChannelNotWritable(final ChannelHandlerContext ctx, final @NotNull Object msg, final @NotNull ChannelPromise promise) throws Exception { if (!ctx.channel().isWritable()) {  if (msg instanceof PUBLISH) { if (notWritableMessages.get() < notWritableQueueSize) { notWritableMessages.incrementAndGet(); promise.addListeners(decrementCounterListener); return false; }  final PUBLISH publish = (PUBLISH) msg; if ((publish).getQoS() == QoS.AT_MOST_ONCE) { if (msg instanceof PublishWithFuture) { final SettableFuture<PublishStatus> future = ((PublishWithFuture) msg).getFuture(); future.set(PublishStatus.CHANNEL_NOT_WRITABLE); } //Drop message final String clientId = ctx.channel().attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get().getClientId(); log.trace("Dropped qos 0 message for client {} on topic {} because the channel was not writable", clientId, publish.getTopic()); messageDroppedService.notWritable(clientId, publish.getTopic(), publish.getQoS().getQosNumber()); promise.setSuccess(); return true; } } }  return false; }
[*] target: assertTrue(messageDropped)
[-] pred: org. junit. Assert. assertTrue ( messageDropped )
************************************
************************************
[+] input: Exception { final ByteBuf byteBuf = Bytes.prefixBytes(new byte[0], Unpooled.buffer()); final int size = byteBuf.readUnsignedShort();  "<AssertPlaceHolder>"; assertEquals(false, byteBuf.isReadable()); }
prefixBytes(final byte[] bytes, final ByteBuf buffer) { checkNotNull(bytes); checkNotNull(buffer);  buffer.writeShort(bytes.length); buffer.writeBytes(bytes);  return buffer; }
[*] target: assertEquals(0, size)
[-] pred: org. junit. Assert. assertEquals ( 0, size )
************************************
************************************
[+] input: Exception { File directory = createTempDirectory("testInitRepository"); InitCommand command = new InitCommand(); command.setDirectory(directory); command.setInitialBranch("main"); command.setInitialBranch(null); try (Git git = command.call()) { Repository r = git.getRepository(); "<AssertPlaceHolder>"; assertEquals("refs/heads/master", r.getFullBranch()); } }
call() throws GitAPIException { try { RepositoryBuilder builder = new RepositoryBuilder(); if (bare) builder.setBare(); if (fs != null) { builder.setFS(fs); } builder.readEnvironment(); if (gitDir != null) builder.setGitDir(gitDir); else gitDir = builder.getGitDir(); if (directory != null) { if (bare) builder.setGitDir(directory); else { builder.setWorkTree(directory); if (gitDir == null) builder.setGitDir(new File(directory, Constants.DOT_GIT)); } } else if (builder.getGitDir() == null) { String dStr = SystemReader.getInstance() .getProperty("user.dir"); //$NON-NLS-1$ if (dStr == null) dStr = "."; //$NON-NLS-1$ File d = new File(dStr); if (!bare) d = new File(d, Constants.DOT_GIT); builder.setGitDir(d); } else { // directory was not set but gitDir was set if (!bare) { String dStr = SystemReader.getInstance().getProperty( "user.dir"); //$NON-NLS-1$ if (dStr == null) dStr = "."; //$NON-NLS-1$ builder.setWorkTree(new File(dStr)); } } builder.setInitialBranch(StringUtils.isEmptyOrNull(initialBranch) ? SystemReader.getInstance().getUserConfig().getString( ConfigConstants.CONFIG_INIT_SECTION, null, ConfigConstants.CONFIG_KEY_DEFAULT_BRANCH) : initialBranch); Repository repository = builder.build(); if (!repository.getObjectDatabase().exists()) repository.create(bare); return new Git(repository, true); } catch (IOException | ConfigInvalidException e) { throw new JGitInternalException(e.getMessage(), e); } }
[*] target: assertNotNull(r)
[-] pred: org. junit. Assert. assertNotNull ( r )
************************************
************************************
[+] input: Exception { File directory = createTempDirectory("testInitRepository"); InitCommand command = new InitCommand(); command.setDirectory(directory); command.setInitialBranch("main"); command.setInitialBranch(""); try (Git git = command.call()) { Repository r = git.getRepository(); "<AssertPlaceHolder>"; assertEquals("refs/heads/master", r.getFullBranch()); } }
call() throws GitAPIException { try { RepositoryBuilder builder = new RepositoryBuilder(); if (bare) builder.setBare(); if (fs != null) { builder.setFS(fs); } builder.readEnvironment(); if (gitDir != null) builder.setGitDir(gitDir); else gitDir = builder.getGitDir(); if (directory != null) { if (bare) builder.setGitDir(directory); else { builder.setWorkTree(directory); if (gitDir == null) builder.setGitDir(new File(directory, Constants.DOT_GIT)); } } else if (builder.getGitDir() == null) { String dStr = SystemReader.getInstance() .getProperty("user.dir"); //$NON-NLS-1$ if (dStr == null) dStr = "."; //$NON-NLS-1$ File d = new File(dStr); if (!bare) d = new File(d, Constants.DOT_GIT); builder.setGitDir(d); } else { // directory was not set but gitDir was set if (!bare) { String dStr = SystemReader.getInstance().getProperty( "user.dir"); //$NON-NLS-1$ if (dStr == null) dStr = "."; //$NON-NLS-1$ builder.setWorkTree(new File(dStr)); } } builder.setInitialBranch(StringUtils.isEmptyOrNull(initialBranch) ? SystemReader.getInstance().getUserConfig().getString( ConfigConstants.CONFIG_INIT_SECTION, null, ConfigConstants.CONFIG_KEY_DEFAULT_BRANCH) : initialBranch); Repository repository = builder.build(); if (!repository.getObjectDatabase().exists()) repository.create(bare); return new Git(repository, true); } catch (IOException | ConfigInvalidException e) { throw new JGitInternalException(e.getMessage(), e); } }
[*] target: assertNotNull(r)
[-] pred: org. junit. Assert. assertNotNull ( r )
************************************
************************************
[+] input: Exception { List<RevCommit> commits = new ArrayList<>(); Git git = Git.wrap(db);  writeTrashFile("Test.txt", "Hello world"); git.add().addFilepattern("Test.txt").call(); commits.add(git.commit().setMessage("initial commit").call());  git.branchCreate().setName("branch1").call(); Ref checkedOut = git.checkout().setName("branch1").call(); assertEquals("refs/heads/branch1", checkedOut.getName()); writeTrashFile("Test1.txt", "Hello world!"); git.add().addFilepattern("Test1.txt").call(); commits.add(git.commit().setMessage("branch1 commit").call());  checkedOut = git.checkout().setName("master").call(); assertEquals("refs/heads/master", checkedOut.getName()); writeTrashFile("Test2.txt", "Hello world!!"); git.add().addFilepattern("Test2.txt").call(); commits.add(git.commit().setMessage("branch1 commit").call());  Iterator<RevCommit> log = git.log().all().call().iterator(); "<AssertPlaceHolder>"; assertTrue(commits.contains(log.next())); assertTrue(log.hasNext()); assertTrue(commits.contains(log.next())); assertTrue(log.hasNext()); assertTrue(commits.contains(log.next())); assertFalse(log.hasNext()); }
call() throws GitAPIException, NoHeadException { checkCallable(); List<TreeFilter> filters = new ArrayList<>(); if (!pathFilters.isEmpty()) { filters.add(AndTreeFilter.create(PathFilterGroup.create(pathFilters), TreeFilter.ANY_DIFF)); } if (!excludeTreeFilters.isEmpty()) { for (TreeFilter f : excludeTreeFilters) { filters.add(AndTreeFilter.create(f, TreeFilter.ANY_DIFF)); } } if (!filters.isEmpty()) { if (filters.size() == 1) { filters.add(TreeFilter.ANY_DIFF); } walk.setTreeFilter(AndTreeFilter.create(filters));  } if (skip > -1 && maxCount > -1) walk.setRevFilter(AndRevFilter.create(SkipRevFilter.create(skip), MaxCountRevFilter.create(maxCount))); else if (skip > -1) walk.setRevFilter(SkipRevFilter.create(skip)); else if (maxCount > -1) walk.setRevFilter(MaxCountRevFilter.create(maxCount)); if (!startSpecified) { try { ObjectId headId = repo.resolve(Constants.HEAD); if (headId == null) throw new NoHeadException( JGitText.get().noHEADExistsAndNoExplicitStartingRevisionWasSpecified); add(headId); } catch (IOException e) { // all exceptions thrown by add() shouldn't occur and represent // severe low-level exception which are therefore wrapped throw new JGitInternalException( JGitText.get().anExceptionOccurredWhileTryingToAddTheIdOfHEAD, e); } }  if (this.revFilter != null) { walk.setRevFilter(this.revFilter); }  setCallable(false); return walk; }
[*] target: assertTrue(log.hasNext())
[-] pred: org. junit. Assert. assertTrue ( log. hasNext ( ) )
************************************
************************************
[+] input: Exception { commitGraph = CommitGraphLoader .open(JGitTestUtil.getTestResourceFile("commit-graph.v1")); "<AssertPlaceHolder>"; assertEquals(10, commitGraph.getCommitCnt()); verifyGraphObjectIndex();  assertCommitData("85b0176af27fa1640868f061f224d01e0b295f59", new int[] { 5, 6 }, 1670570408L, 3, 0); assertCommitData("d4f7c00aab3f0160168c9e5991abb6194a4e0d9e", new int[] {}, 1670569901L, 1, 1); assertCommitData("4d03aaf9c20c97d6ccdc05cb7f146b1deb6c01d5", new int[] { 5 }, 1670570119L, 3, 2); assertCommitData("a2f409b753880bf83b18bfb433dd340a6185e8be", new int[] { 7 }, 1670569935L, 3, 3); assertCommitData("431343847343979bbe31127ed905a24fed9a636c", new int[] { 3, 2, 8 }, 1670570644L, 4, 4); assertCommitData("c3f745ad8928ef56b5dbf33740fc8ede6b598290", new int[] { 1 }, 1670570106L, 2, 5); assertCommitData("95b12422c8ea4371e54cd58925eeed9d960ff1f0", new int[] { 1 }, 1670570163L, 2, 6); assertCommitData("de0ea882503cdd9c984c0a43238014569a123cac", new int[] { 1 }, 1670569921L, 2, 7); assertCommitData("102c9d6481559b1a113eb66bf55085903de6fb00", new int[] { 6 }, 1670570616L, 3, 8); assertCommitData("b5de2a84867f8ffc6321649dabf8c0680661ec03", new int[] { 7, 5 }, 1670570364L, 3, 9); }
open(File graphFile) throws FileNotFoundException, CommitGraphFormatException, IOException { try (SilentFileInputStream fd = new SilentFileInputStream(graphFile)) { try { return read(fd); } catch (CommitGraphFormatException fe) { throw fe; } catch (IOException ioe) { throw new IOException(MessageFormat.format( JGitText.get().unreadableCommitGraph, graphFile.getAbsolutePath()), ioe); } } }
[*] target: assertNotNull(commitGraph)
[-] pred: org. junit. Assert. assertNotNull ( commitGraph )
************************************
************************************
[+] input: testBitmapCounts() { TestPackBitmapIndex index = new TestPackBitmapIndex(bitmaps);  assertEquals(1, index.getBaseBitmapCount()); "<AssertPlaceHolder>"; assertEquals(2, index.getBitmapCount()); }
getXorBitmapCount() { int xored = 0; for (StoredBitmap sb : getBitmaps()) { if (!sb.isBase()) { xored += 1; } } return xored; }
[*] target: assertEquals(1, index.getXorBitmapCount())
[-] pred: org. junit. Assert. assertEquals ( 1, index. getXorBitmapCount() )
************************************
************************************
[+] input: IOException { final String newRef = "refs/heads/abc"; final RefUpdate ru = updateRef(newRef); final SubclassedId newid = new SubclassedId(ru.getNewObjectId()); ru.setNewObjectId(newid); Result update = ru.update(); assertEquals(Result.NEW, update); final Ref r = getRef(db, newRef).get(); "<AssertPlaceHolder>"; assertNotNull(r.getObjectId()); assertNotSame(newid, r.getObjectId()); assertSame(ObjectId.class, r.getObjectId().getClass()); assertEquals(newid, r.getObjectId()); List<ReflogEntry> reverseEntries1 = db .getReflogReader("refs/heads/abc").getReverseEntries(); ReflogEntry entry1 = reverseEntries1.get(0); assertEquals(1, reverseEntries1.size()); assertEquals(ObjectId.zeroId(), entry1.getOldId()); assertEquals(r.getObjectId(), entry1.getNewId()); assertEquals(new PersonIdent(db).toString(),  entry1.getWho().toString()); assertEquals("", entry1.getComment()); List<ReflogEntry> reverseEntries2 = db.getReflogReader("HEAD") .getReverseEntries(); assertEquals(0, reverseEntries2.size()); }
getName() { return getRef().getName(); }
[*] target: assertEquals(newRef, r.getName())
[-] pred: org. junit. Assert. assertEquals ( newRef, r. getName ( ) )
************************************
************************************
[+] input: Exception { CancelledTestMonitor m = new CancelledTestMonitor(); try (CancellableDigestOutputStream out = new CancellableDigestOutputStream( m, NullOutputStream.INSTANCE)) { byte[] KB = new byte[1024]; int triggerCancelWriteCnt = BYTES_TO_WRITE_BEFORE_CANCEL_CHECK / KB.length; for (int i = 0; i < triggerCancelWriteCnt + 1; i++) { out.write(KB); } assertTrue(out.length() > BYTES_TO_WRITE_BEFORE_CANCEL_CHECK); m.setCancelled(true);  for (int i = 0; i < triggerCancelWriteCnt - 1; i++) { out.write(KB); }  long lastLength = out.length(); assertThrows(InterruptedIOException.class, () -> { out.write(1); }); assertEquals(lastLength, out.length());  assertThrows(InterruptedIOException.class, () -> { out.write(new byte[1]); }); "<AssertPlaceHolder>"; } }
length() { return count; }
[*] target: assertEquals(lastLength, out.length())
[-] pred: org. junit. Assert. assertEquals ( lastLength, out. length() )
************************************
************************************
[+] input: Exception { if (!FS.DETECTED.supportsExecute()) return;  ChangeRecorder recorder = new ChangeRecorder(); ListenerHandle handle = null; try (Git git = new Git(db)) { handle = db.getListenerList() .addWorkingTreeModifiedListener(recorder); // Add non-executable file File file = writeTrashFile("file.txt", "a"); git.add().addFilepattern("file.txt").call(); git.commit().setMessage("commit1").call(); assertFalse(db.getFS().canExecute(file));  // Create branch git.branchCreate().setName("b1").call();  // Make file executable db.getFS().setExecute(file, true); git.add().addFilepattern("file.txt").call(); git.commit().setMessage("commit2").call();  // Verify executable and working directory is clean Status status = git.status().call(); assertTrue(status.getModified().isEmpty()); assertTrue(status.getChanged().isEmpty()); assertTrue(db.getFS().canExecute(file));  writeTrashFile("file.txt", "b");  // Switch branches CheckoutCommand checkout = git.checkout().setName("b1"); try { checkout.call(); fail("Checkout exception not thrown"); } catch (org.eclipse.jgit.api.errors.CheckoutConflictException e) { CheckoutResult result = checkout.getResult(); "<AssertPlaceHolder>"; assertNotNull(result.getConflictList()); assertEquals(1, result.getConflictList().size()); assertTrue(result.getConflictList().contains("file.txt")); } recorder.assertNoEvent(); } finally { if (handle != null) { handle.remove(); } } }
checkout() throws IOException { try { return doCheckout(); } catch (CanceledException ce) { // should actually be propagated, but this would change a LOT of // APIs throw new IOException(ce); } finally { try { dc.unlock(); } finally { if (performingCheckout) { Set<String> touched = new HashSet<>(conflicts); touched.addAll(getUpdated().keySet()); touched.addAll(kept); WorkingTreeModifiedEvent event = new WorkingTreeModifiedEvent( touched, getRemoved()); if (!event.isEmpty()) { repo.fireEvent(event); } } } } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testParseGitFileName_FailFooBar() { final FileHeader fh = data("a/foo b/bar\n-"); assertTrue(fh.parseGitFileName(0, fh.buf.length) > 0); assertNull(fh.getOldPath()); assertNull(fh.getNewPath()); "<AssertPlaceHolder>"; }
hasMetaDataChanges() { return changeType != ChangeType.MODIFY || newMode != oldMode; }
[*] target: assertFalse(fh.hasMetaDataChanges())
[-] pred: org. junit. Assert. assertFalse ( fh. hasMetaDataChanges() )
************************************
************************************
[+] input: Exception { String[] lines = { "command=fetch\n", "server-option=one\n", "server-option=two\n", PacketLineIn.delimiter(), PacketLineIn.end() };  TestV2Hook testHook = new TestV2Hook(); uploadPackSetup(TransferConfig.ProtocolVersion.V2.version(), (UploadPack up) -> { up.setProtocolV2Hook(testHook); }, lines);  FetchV2Request req = testHook.fetchRequest; "<AssertPlaceHolder>"; assertEquals(2, req.getServerOptions().size()); assertThat(req.getServerOptions(), hasItems("one", "two")); }
setProtocolV2Hook(@Nullable ProtocolV2Hook hook) { this.protocolV2Hook = hook != null ? hook : ProtocolV2Hook.DEFAULT; }
[*] target: assertNotNull(req)
[-] pred: org. junit. Assert. assertNotNull ( req )
************************************
************************************
[+] input: Exception { String str = "http://example.com/"; URIish u = new URIish(str); assertEquals("example.com", u.getHost()); assertEquals("/", u.getPath()); assertEquals(str, u.toString());  str = "http://example.com"; u = new URIish(str); assertEquals("example.com", u.getHost()); assertEquals("", u.getPath()); "<AssertPlaceHolder>"; }
toString() { return format(false, false); }
[*] target: assertEquals(str, u.toString())
[-] pred: org. junit. Assert. assertEquals ( str, u. toString ( ) )
************************************
************************************
[+] input: testParseEncoding_Accept_Latin_One_AsISO8859_1() { Charset result = RawParseUtils.parseEncoding(Constants .encodeASCII("encoding latin-1\n")); "<AssertPlaceHolder>"; assertEquals("ISO-8859-1", result.name()); }
parseEncoding(byte[] b) { String enc = parseEncodingName(b); if (enc == null) { return UTF_8; }  String name = enc.trim(); try { return Charset.forName(name); } catch (IllegalCharsetNameException | UnsupportedCharsetException badName) { Charset aliased = charsetForAlias(name); if (aliased != null) { return aliased; } throw badName; } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testClear() { final Ref master = newRef("refs/heads/master", ID_ONE); loose = toList(master);  RefMap map = new RefMap("", packed, loose, resolved); assertSame(master, map.get("refs/heads/master"));  map.clear(); assertNull(map.get("refs/heads/master")); assertTrue(map.isEmpty()); "<AssertPlaceHolder>"; }
size() { if (!sizeIsValid) { size = 0; Iterator<?> i = entrySet().iterator(); for (; i.hasNext(); i.next()) size++; sizeIsValid = true; } return size; }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size() )
************************************
************************************
[+] input: Exception { // Generate a PQ for random 2D vectors var vectors = createRandomVectors(512, 2); var ravv = new ListRandomAccessVectorValues(vectors, 2); var pq = ProductQuantization.compute(ravv, 1, 256, false);  // Compress the vectors var compressed = pq.encodeAll(ravv); var cv = new PQVectors(pq, compressed); assertEquals(2 * Float.BYTES, cv.getOriginalSize()); assertEquals(1, cv.getCompressedSize());  // Write compressed vectors File cvFile = File.createTempFile("pqtest", ".cv"); try (var out = new DataOutputStream(new FileOutputStream(cvFile))) { cv.write(out); } // Read compressed vectors try (var in = new SimpleMappedReader(cvFile.getAbsolutePath())) { var cv2 = PQVectors.load(in, 0); "<AssertPlaceHolder>"; } }
write(DataOutput out) throws IOException { write(out, OnDiskGraphIndex.CURRENT_VERSION); }
[*] target: assertEquals(cv, cv2)
[-] pred: org. junit. Assert. assertEquals ( cv, cv2 )
************************************
************************************
[+] input: Exception { // Generate a PQ for random vectors var vectors = createRandomVectors(512, 64); var ravv = new ListRandomAccessVectorValues(vectors, 64); var bq = new BinaryQuantization(ravv.dimension());  // Compress the vectors var compressed = bq.encodeAll(ravv); var cv = new BQVectors(bq, compressed); assertEquals(64 * Float.BYTES, cv.getOriginalSize()); assertEquals(8, cv.getCompressedSize());  // Write compressed vectors File cvFile = File.createTempFile("bqtest", ".cv"); try (var out = new DataOutputStream(new FileOutputStream(cvFile))) { cv.write(out); } // Read compressed vectors try (var in = new SimpleMappedReader(cvFile.getAbsolutePath())) { var cv2 = BQVectors.load(in, 0); "<AssertPlaceHolder>"; } }
write(DataOutput out) throws IOException { write(out, OnDiskGraphIndex.CURRENT_VERSION); }
[*] target: assertEquals(cv, cv2)
[-] pred: org. junit. Assert. assertEquals ( cv, cv2 )
************************************
************************************
[+] input: Exception { ComponentName cn = new ComponentName(getContext(), TEST_ACTIVITY); initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), false  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: Exception { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = new ComponentName(mContext.getPackageName(), "placeholder-do"); WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), true  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: testEquals() { ServerConfigAbility ability = new ServerConfigAbility(); ability.setSupportRemoteMetrics(true); assertEquals(ability, ability); assertFalse(ability.equals(null)); assertFalse(ability.equals(new ClientConfigAbility())); ServerConfigAbility newOne = new ServerConfigAbility(); assertNotEquals(ability, newOne); newOne.setSupportRemoteMetrics(true); "<AssertPlaceHolder>"; }
setSupportRemoteMetrics(boolean supportRemoteMetrics) { this.supportRemoteMetrics = supportRemoteMetrics; }
[*] target: assertEquals(ability, newOne)
[-] pred: org. junit. Assert. assertEquals ( ability, newOne )
************************************
************************************
[+] input: JsonProcessingException { String json = "{"supportRemoteConnection":true,"grpcReportEnabled":true}"; ServerRemoteAbility abilities = mapper.readValue(json, ServerRemoteAbility.class); assertTrue(abilities.isSupportRemoteConnection()); "<AssertPlaceHolder>"; }
isGrpcReportEnabled() { return grpcReportEnabled; }
[*] target: assertTrue(abilities.isGrpcReportEnabled())
[-] pred: org. junit. Assert. assertTrue ( abilities. isGrpcReportEnabled() )
************************************
************************************
[+] input: JsonProcessingException { ServerNamingAbility expected = new ServerNamingAbility(); expected.setSupportJraft(true); String serializeJson = jacksonMapper.writeValueAsString(expected); ServerNamingAbility actual = jacksonMapper.readValue(serializeJson, ServerNamingAbility.class); assertEquals(expected, actual); actual = new ServerNamingAbility(); assertNotEquals(expected, actual); actual.setSupportJraft(true); "<AssertPlaceHolder>"; }
setSupportJraft(boolean supportJraft) { this.supportJraft = supportJraft; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { ConnectResetRequest request = new ConnectResetRequest(); request.setServerIp("127.0.0.1"); request.setServerPort("8888"); request.setRequestId("1"); request.setConnectionId("11111_127.0.0.1_8888"); String json = mapper.writeValueAsString(request); Assert."<AssertPlaceHolder>"; Assert.assertTrue(json.contains(""serverIp":"127.0.0.1"")); Assert.assertTrue(json.contains(""serverPort":"8888"")); Assert.assertTrue(json.contains(""module":"internal"")); Assert.assertTrue(json.contains(""requestId":"1"")); Assert.assertTrue(json.contains(""connectionId":"11111_127.0.0.1_8888"")); }
setConnectionId(String connectionId) { this.connectionId = connectionId; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: Exception { ServerReloadRequest request = new ServerReloadRequest(); request.setReloadCount(10); request.setReloadServer("1.1.1.1"); request.setRequestId("1"); String json = mapper.writeValueAsString(request); System.out.println(json); Assert."<AssertPlaceHolder>"; Assert.assertTrue(json.contains(""reloadCount":10")); Assert.assertTrue(json.contains(""reloadServer":"1.1.1.1"")); Assert.assertTrue(json.contains(""module":"internal"")); Assert.assertTrue(json.contains(""requestId":"1"")); }
setReloadServer(String reloadServer) { this.reloadServer = reloadServer; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: testBuilderHeader() { Header header = NamingHttpUtil.builderHeader(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(header.getValue(HttpHeaderConsts.CLIENT_VERSION_HEADER), VersionUtils.version); Assert.assertEquals(header.getValue(HttpHeaderConsts.USER_AGENT_HEADER), VersionUtils.getFullClientVersion()); Assert.assertEquals(header.getValue(HttpHeaderConsts.ACCEPT_ENCODING), "gzip,deflate,sdch"); Assert.assertEquals(header.getValue(HttpHeaderConsts.CONNECTION), "Keep-Alive"); Assert.assertNotNull(header.getValue(HttpHeaderConsts.REQUEST_ID)); Assert.assertEquals(header.getValue(HttpHeaderConsts.REQUEST_MODULE), "Naming"); }
builderHeader() { Header header = Header.newInstance(); header.addParam(HttpHeaderConsts.CLIENT_VERSION_HEADER, VersionUtils.version); header.addParam(HttpHeaderConsts.USER_AGENT_HEADER, VersionUtils.getFullClientVersion()); header.addParam(HttpHeaderConsts.ACCEPT_ENCODING, "gzip,deflate,sdch"); header.addParam(HttpHeaderConsts.CONNECTION, "Keep-Alive"); header.addParam(HttpHeaderConsts.REQUEST_ID, UuidUtils.generateUuid()); header.addParam(HttpHeaderConsts.REQUEST_MODULE, "Naming"); return header; }
[*] target: assertNotNull(header)
[-] pred: org. junit. Assert. assertNotNull ( header )
************************************
************************************
[+] input: IllegalAccessException { HttpClientFactory factory = new AbstractApacheHttpClientFactory() { @Override protected HttpClientConfig buildHttpClientConfig() { return HttpClientConfig.builder().build(); }  @Override protected Logger assignLogger() { return logger; } }; NacosRestTemplate template = factory.createNacosRestTemplate(); "<AssertPlaceHolder>"; Field field = NacosRestTemplate.class.getDeclaredField("requestClient"); field.setAccessible(true); HttpClientRequest requestClient = (HttpClientRequest) field.get(template); assertTrue(requestClient instanceof DefaultHttpClientRequest); }
createNacosRestTemplate() { final HttpClientConfig originalRequestConfig = buildHttpClientConfig(); final RequestConfig defaultConfig = getRequestConfig(); return new NacosRestTemplate(assignLogger(), new DefaultHttpClientRequest( HttpClients.custom() .addInterceptorLast(new RequestContent(true)) .setDefaultRequestConfig(defaultConfig) .setUserAgent(originalRequestConfig.getUserAgent()) .setMaxConnTotal(originalRequestConfig.getMaxConnTotal()) .setMaxConnPerRoute(originalRequestConfig.getMaxConnPerRoute()) .setConnectionTimeToLive(originalRequestConfig.getConnTimeToLive(), originalRequestConfig.getConnTimeToLiveTimeUnit()).build(), defaultConfig)); }
[*] target: assertNotNull(template)
[-] pred: org. junit. Assert. assertNotNull ( template )
************************************
************************************
[+] input: testValueOf3() { MediaType mediaType = MediaType.valueOf("application/x-www-form-urlencoded", "ISO-8859-1"); String type = "application/x-www-form-urlencoded"; String charset = "ISO-8859-1"; String excepted = "application/x-www-form-urlencoded;charset=ISO-8859-1"; assertEquals(type, mediaType.getType()); assertEquals(charset, mediaType.getCharset()); "<AssertPlaceHolder>"; }
toString() { return type + ";charset=" + charset; }
[*] target: assertEquals(excepted, mediaType.toString())
[-] pred: org. junit. Assert. assertEquals ( excepted, mediaType. toString ( ) )
************************************
************************************
[+] input: NacosException { when(rpcClientConfig.timeOutMills()).thenReturn(5000L); when(rpcClientConfig.retryTimes()).thenReturn(3); rpcClient.rpcClientStatus.set(RpcClientStatus.RUNNING); rpcClient.currentConnection = connection; doThrow(NacosException.class).when(connection).requestFuture(any()); Exception exception = null;  try { rpcClient.requestFuture(null); } catch (NacosException e) { exception = e; }  verify(connection, times(4)).requestFuture(any()); verify(rpcClient).switchServerAsyncOnRequestFail(); Assert."<AssertPlaceHolder>"; assertEquals(RpcClientStatus.UNHEALTHY, rpcClient.rpcClientStatus.get()); }
switchServerAsyncOnRequestFail() { switchServerAsync(null, true); }
[*] target: assertNotNull(exception)
[-] pred: org. junit. Assert. assertNotNull ( exception )
************************************
************************************
[+] input: testDefault() { DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) DefaultGrpcClientConfig.newBuilder().build(); assertNull(config.name()); assertEquals(3, config.retryTimes()); assertEquals(3000L, config.timeOutMills()); assertEquals(5000L, config.connectionKeepAlive()); assertEquals(10000L, config.threadPoolKeepAlive()); assertEquals(4, config.threadPoolCoreSize()); assertEquals(16, config.threadPoolMaxSize()); assertEquals(3000L, config.serverCheckTimeOut()); assertEquals(10000, config.threadPoolQueueSize()); assertEquals(10 * 1024 * 1024, config.maxInboundMessageSize()); assertEquals(6 * 60 * 1000, config.channelKeepAlive()); assertEquals(TimeUnit.SECONDS.toMillis(20L), config.channelKeepAliveTimeout()); assertEquals(3, config.healthCheckRetryTimes()); assertEquals(3000L, config.healthCheckTimeOut()); assertEquals(5000L, config.capabilityNegotiationTimeout()); assertEquals(1, config.labels().size()); "<AssertPlaceHolder>"; }
tlsConfig() { return tlsConfig; }
[*] target: assertNotNull(config.tlsConfig())
[-] pred: org. junit. Assert. assertNotNull ( config. tlsConfig() )
************************************
************************************
[+] input: IOException { Properties properties = ResourceUtils.getResourceAsProperties("resource_utils_test.properties"); "<AssertPlaceHolder>"; assertTrue(properties.containsKey("a")); }
getResourceAsProperties(String resource) throws IOException { ClassLoader loader = ResourceUtils.class.getClassLoader(); return getResourceAsProperties(loader, resource); }
[*] target: assertNotNull(properties)
[-] pred: org. junit. Assert. assertNotNull ( properties )
************************************
************************************
[+] input: testLoadObject() { ConfigMetadata configMetadata = YamlParserUtil.loadObject(CONFIG_METADATA_STRING, ConfigMetadata.class); Assert."<AssertPlaceHolder>";  List<ConfigMetadata.ConfigExportItem> metadataList = configMetadata.getMetadata(); Assert.assertNotNull(metadataList); Assert.assertEquals(metadataList.size(), 2); ConfigMetadata.ConfigExportItem configExportItem1 = metadataList.get(0); ConfigMetadata.ConfigExportItem configExportItem2 = metadataList.get(1); Assert.assertEquals(configExportItem1, item1); Assert.assertEquals(configExportItem2, item2); }
loadObject(String content, Class<T> type) { return new Yaml(new YamlParserConstructor(), new CustomRepresenter()).loadAs(content, type); }
[*] target: assertNotNull(configMetadata)
[-] pred: org. junit. Assert. assertNotNull ( configMetadata )
************************************
************************************
[+] input: testMemberLeave() { Member member = Member.builder().ip("1.1.3.3").port(8848).state(NodeState.DOWN).build(); boolean joinResult = serverMemberManager.memberJoin(Collections.singletonList(member)); assertTrue(joinResult);  List<String> ips = serverMemberManager.getServerListUnhealth(); assertEquals(1, ips.size());  boolean result = serverMemberManager.memberLeave(Collections.singletonList(member)); "<AssertPlaceHolder>"; }
memberLeave(Collection<Member> members) { Set<Member> set = new HashSet<>(allMembers()); set.removeAll(members); return memberChange(set); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testRejected() { HealthCheckRequest healthCheckRequest = new HealthCheckRequest(); RequestMeta requestMeta = new RequestMeta(); TpsCheckResponse tpsCheckResponse = new TpsCheckResponse(false, 5031, "rejected"); Mockito.when(tpsControlManager.check(any(TpsCheckRequest.class))).thenReturn(tpsCheckResponse); Response filterResponse = tpsControlRequestFilter.filter(healthCheckRequest, requestMeta, HealthCheckRequestHandler.class); Assert."<AssertPlaceHolder>"; Assert.assertEquals(NacosException.OVER_THRESHOLD, filterResponse.getErrorCode()); Assert.assertEquals("Tps Flow restricted:" + tpsCheckResponse.getMessage(), filterResponse.getMessage()); }
filter(Request request, RequestMeta meta, Class handlerClazz) {  Method method; try { method = getHandleMethod(handlerClazz); } catch (NacosException e) { return null; }  if (method.isAnnotationPresent(TpsControl.class) && TpsControlConfig.isTpsControlEnabled()) {  try { TpsControl tpsControl = method.getAnnotation(TpsControl.class); String pointName = tpsControl.pointName(); TpsCheckRequest tpsCheckRequest = null; String parseName = StringUtils.isBlank(tpsControl.name()) ? pointName : tpsControl.name(); RemoteTpsCheckRequestParser parser = RemoteTpsCheckRequestParserRegistry.getParser(parseName); if (parser != null) { tpsCheckRequest = parser.parse(request, meta); } if (tpsCheckRequest == null) { tpsCheckRequest = new TpsCheckRequest(); } if (StringUtils.isBlank(tpsCheckRequest.getPointName())) { tpsCheckRequest.setPointName(pointName); }  initTpsControlManager();  TpsCheckResponse check = tpsControlManager.check(tpsCheckRequest);  if (!check.isSuccess()) { Response response; try { response = super.getDefaultResponseInstance(handlerClazz); response.setErrorInfo(NacosException.OVER_THRESHOLD, "Tps Flow restricted:" + check.getMessage()); return response; } catch (Exception e) { com.alibaba.nacos.plugin.control.Loggers.TPS.warn("Tps check fail , request: {},exception:{}", request.getClass().getSimpleName(), e); return null; }  } } catch (Throwable throwable) { com.alibaba.nacos.plugin.control.Loggers.TPS.warn("Tps check exception , request: {},exception:{}", request.getClass().getSimpleName(), throwable); } }  return null; }
[*] target: assertNotNull(filterResponse)
[-] pred: org. junit. Assert. assertNotNull ( filterResponse )
************************************
************************************
[+] input: testErrorThroughRpc() { final AtomicReference<Response> reference = new AtomicReference<>();  RpcContext context = new RpcContext() { @Override public void sendResponse(Object responseObj) { reference.set((Response) responseObj); }  @Override public Connection getConnection() { return null; }  @Override public String getRemoteAddress() { return null; } }; AbstractProcessor processor = new NacosWriteRequestProcessor(server, SerializeFactory.getDefault()); processor.execute(server, context, WriteRequest.newBuilder().build(), new JRaftServer.RaftGroupTuple());  Response response = reference.get(); Assert."<AssertPlaceHolder>";  Assert.assertEquals("Error message transmission", response.getErrMsg()); Assert.assertFalse(response.getSuccess()); }
execute(JRaftServer server, final RpcContext asyncCtx, final Message message, final JRaftServer.RaftGroupTuple tuple) { FailoverClosure closure = new FailoverClosure() {  Response data;  Throwable ex;  @Override public void setResponse(Response data) { this.data = data; }  @Override public void setThrowable(Throwable throwable) { this.ex = throwable; }  @Override public void run(Status status) { if (Objects.nonNull(ex)) { Loggers.RAFT.error("execute has error : ", ex); asyncCtx.sendResponse(Response.newBuilder().setErrMsg(ex.toString()).setSuccess(false).build()); } else { asyncCtx.sendResponse(data); } } };  server.applyOperation(tuple.getNode(), message, closure); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testGetRemoteExecutorTimesOfProcessors() { int defaultExpectVal = 1 << 4; int defaultVal = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert.assertEquals(defaultExpectVal, defaultVal);  System.setProperty("remote.executor.times.of.processors", "10"); int val1 = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert.assertEquals(10, val1);  System.setProperty("remote.executor.times.of.processors", "-1"); int val2 = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert."<AssertPlaceHolder>"; }
getRemoteExecutorTimesOfProcessors() { String timesString = System.getProperty("remote.executor.times.of.processors"); if (NumberUtils.isDigits(timesString)) { int times = Integer.parseInt(timesString); return times > 0 ? times : REMOTE_EXECUTOR_TIMES_OF_PROCESSORS; } else { return REMOTE_EXECUTOR_TIMES_OF_PROCESSORS; } }
[*] target: assertEquals(defaultExpectVal, val2)
[-] pred: org. junit. Assert. assertEquals ( defaultExpectVal, val2 )
************************************
************************************
[+] input: testGetRemoteExecutorQueueSize() { int defaultExpectVal = 1 << 14; int defaultVal = RemoteUtils.getRemoteExecutorQueueSize(); Assert.assertEquals(defaultExpectVal, defaultVal);  System.setProperty("remote.executor.queue.size", "10"); int val1 = RemoteUtils.getRemoteExecutorQueueSize(); Assert.assertEquals(10, val1);  System.setProperty("remote.executor.queue.size", "-1"); int val2 = RemoteUtils.getRemoteExecutorQueueSize(); Assert."<AssertPlaceHolder>"; }
getRemoteExecutorQueueSize() { String queueSizeString = System.getProperty("remote.executor.queue.size"); if (NumberUtils.isDigits(queueSizeString)) { int size = Integer.parseInt(queueSizeString); return size > 0 ? size : REMOTE_EXECUTOR_QUEUE_SIZE; } else { return REMOTE_EXECUTOR_QUEUE_SIZE; } }
[*] target: assertEquals(defaultExpectVal, val2)
[-] pred: org. junit. Assert. assertEquals ( defaultExpectVal, val2 )
************************************
************************************
[+] input: testGetSubscribedService() { Collection<Service> subscribedService = clientServiceIndexesManager.getSubscribedService();  Assert."<AssertPlaceHolder>"; Assert.assertEquals(subscribedService.size(), 1); }
getSubscribedService() { return subscriberIndexes.keySet(); }
[*] target: assertNotNull(subscribedService)
[-] pred: org. junit. Assert. assertNotNull ( subscribedService )
************************************
************************************
[+] input: testEncrypt() { String dataId = "cipher-mockAlgo-application"; String content = "content"; String sec = mockEncryptionPluginService.generateSecretKey(); Pair<String, String> pair = EncryptionHandler.encryptHandler(dataId, content); Assert."<AssertPlaceHolder>"; Assert.assertEquals("should return encrypted content.", mockEncryptionPluginService.encrypt(sec, content), pair.getSecond()); Assert.assertEquals("should return encrypted secret key.", mockEncryptionPluginService.encryptSecretKey(sec), pair.getFirst()); }
encryptHandler(String dataId, String content) { if (!checkCipher(dataId)) { return Pair.with("", content); } Optional<String> algorithmName = parseAlgorithmName(dataId); Optional<EncryptionPluginService> optional = algorithmName.flatMap( EncryptionPluginManager.instance()::findEncryptionService); if (!optional.isPresent()) { LOGGER.warn("[EncryptionHandler] [encryptHandler] No encryption program with the corresponding name found"); return Pair.with("", content); } EncryptionPluginService encryptionPluginService = optional.get(); String secretKey = encryptionPluginService.generateSecretKey(); String encryptContent = encryptionPluginService.encrypt(secretKey, content); return Pair.with(encryptionPluginService.encryptSecretKey(secretKey), encryptContent); }
[*] target: assertNotNull(pair)
[-] pred: org. junit. Assert. assertNotNull ( pair )
************************************
************************************
[+] input: metaPropertyInitialize() { String[] keys = new String[] { "JDBC_URL", "JDBC_USERNAME", "JDBC_PASSWORD" }; Map<String, String> backup = new HashMap<>(); for (String key : keys) { backup.put(key, System.clearProperty(key)); } try { MetaPropertyInitializer initializer = new MetaPropertyInitializer(); assertFalse(initializer.isPropertyReady()); System.setProperty("JDBC_USERNAME", "test"); assertFalse(initializer.isPropertyReady()); initializer.initialize("127.0.0.1:2881", "test", "user", "pswd"); "<AssertPlaceHolder>"; } finally { for (Entry<String, String> entry : backup.entrySet()) { if (entry.getValue() != null) { System.setProperty(entry.getKey(), entry.getValue()); } } } }
isPropertyReady() { String jdbcUrl = getProperty("JDBC_URL"); String jdbcUsername = getProperty("JDBC_USERNAME"); return !Strings.isNullOrEmpty(jdbcUrl) && !Strings.isNullOrEmpty(jdbcUsername); }
[*] target: assertTrue(initializer.isPropertyReady())
[-] pred: org. junit. Assert. assertTrue ( initializer. isPropertyReady ( ) )
************************************
************************************
[+] input: Exception { PowerMockito.whenNew(DefaultConnector.class).withAnyArguments().thenReturn(defaultConnector); Method methodGetObVersion = PowerMockito.method(ObConnectTemplate.class, "getObVersion"); PowerMockito.replace(methodGetObVersion).with((proxy, method, args) -> "2.4.0");  ObOperator operator = ObOperators.newObOperator(connectProperties.withCompatibilityMode(CompatibilityMode.MYSQL)); "<AssertPlaceHolder>"; assertNotNull(operator.cluster()); assertNotNull(operator.resource()); assertNotNull(operator.session()); assertNotNull(operator.stats()); assertNotNull(operator.tenant()); }
newObOperator(ConnectProperties connectProperties) { validate(connectProperties);  ObConnectTemplate obConnectTemplate = new ObConnectTemplate(connectProperties); return ObOperator.builder() .resourceOperator(newResourceOperator(obConnectTemplate)) .objectOperator(newObjectOperator(obConnectTemplate)) .clusterOperator(newClusterOperator(obConnectTemplate)) .parameterOperator(newParameterOperator(obConnectTemplate)) .sessionOperator(newSessionOperator(obConnectTemplate)) .statsOperator(newStatsOperator(obConnectTemplate)) .tenantOperator(newTenantOperator(obConnectTemplate)) .sqlTuningOperator(newSqlTuningOperator(obConnectTemplate)) .sqlExecuteOperator(newSqlExecuteOperator(obConnectTemplate)) .sqlAuditOperator(newSqlAuditOperator(obConnectTemplate)) .compactionOperator(newCompactionOperator(obConnectTemplate)) .sqlPlanOperator(newSqlPlanOperator(obConnectTemplate)) .sqlPlanExplainOperator(newSqlPlanExplainOperator(obConnectTemplate)) .build(); }
[*] target: assertNotNull(operator)
[-] pred: org. junit. Assert. assertNotNull ( operator )
************************************
************************************
[+] input: Exception { PowerMockito.whenNew(DefaultConnector.class).withAnyArguments().thenReturn(defaultConnector); Method methodGetObVersion = PowerMockito.method(ObConnectTemplate.class, "getObVersion"); PowerMockito.replace(methodGetObVersion).with((proxy, method, args) -> "2.4.0");  ObOperator operator = ObOperators.newMetaOperator(connectProperties.withCompatibilityMode(CompatibilityMode.MYSQL)); "<AssertPlaceHolder>"; assertNotNull(operator.cluster()); assertNotNull(operator.parameter()); }
newMetaOperator(ConnectProperties connectProperties) { ObConnectTemplate obConnectTemplate = new ObConnectTemplate(connectProperties); return ObOperator.builder() .clusterOperator(newClusterOperator(obConnectTemplate)) .parameterOperator(newParameterOperator(obConnectTemplate)) .build(); }
[*] target: assertNotNull(operator)
[-] pred: org. junit. Assert. assertNotNull ( operator )
************************************
************************************
[+] input: listTableIndex_get_all_index_in_schema_Success() { Map<String, List<DBTableIndex>> map = accessor.listTableIndexes(getMySQLDataBaseName()); Assert."<AssertPlaceHolder>"; Assert.assertTrue(map.size() > 0); }
listTableIndexes(String schemaName) { String sql = sqlMapper.getSql(Statements.LIST_SCHEMA_INDEX); Map<String, DBTableIndex> fullIndexName2Index = new LinkedHashMap<>(); jdbcOperations.query(sql, new Object[] {schemaName}, (rs, num) -> { String tableName = rs.getString("TABLE_NAME"); String indexName = rs.getString("INDEX_NAME");  if (!fullIndexName2Index.containsKey(tableName + indexName)) { DBTableIndex index = new DBTableIndex(); index.setSchemaName(rs.getString("TABLE_SCHEMA")); index.setTableName(rs.getString("TABLE_NAME")); index.setName(indexName); index.setOrdinalPosition(rs.getInt("SEQ_IN_INDEX")); index.setPrimary(indexName.equalsIgnoreCase("PRIMARY")); index.setCardinality(rs.getLong("CARDINALITY")); index.setComment(rs.getString("INDEX_COMMENT")); index.setAdditionalInfo(rs.getString("COMMENT")); index.setNonUnique(rs.getInt("NON_UNIQUE") != 0); if (isIndexDistinguishesVisibility()) { String visible = rs.getString("IS_VISIBLE"); if (Objects.nonNull(visible)) { index.setVisible(visible.equalsIgnoreCase("YES")); } } else { index.setVisible(true); } index.setCollation(rs.getString("COLLATION")); index.setAlgorithm(DBIndexAlgorithm.fromString(rs.getString("INDEX_TYPE"))); if (index.getAlgorithm() == DBIndexAlgorithm.FULLTEXT) { index.setType(DBIndexType.FULLTEXT); } else if (index.getAlgorithm() == DBIndexAlgorithm.RTREE || index.getAlgorithm() == DBIndexAlgorithm.SPATIAL) { index.setType(DBIndexType.SPATIAL); } else { if (index.isNonUnique()) { index.setType(DBIndexType.NORMAL); } else { index.setType(DBIndexType.UNIQUE); } } List<String> columnNames = new ArrayList<>(); columnNames.add(rs.getString("COLUMN_NAME")); index.setColumnNames(columnNames); index.setGlobal(true); fullIndexName2Index.put(tableName + indexName, index); } else { fullIndexName2Index.get(tableName + indexName).getColumnNames() .add(rs.getString(MySQLConstants.IDX_COLUMN_NAME)); } return null; });  Map<String, List<DBTableIndex>> tableName2Indexes = fullIndexName2Index.values().stream().collect(Collectors.groupingBy(DBTableIndex::getTableName)); for (List<DBTableIndex> columns : tableName2Indexes.values()) { columns.stream().sorted(Comparator.comparing(DBTableIndex::getOrdinalPosition)) .collect(Collectors.toList()); } return tableName2Indexes; }
[*] target: assertNotNull(map)
[-] pred: org. junit. Assert. assertNotNull ( map )
************************************
************************************
[+] input: getDatabase_Success() { DBDatabase database = accessor.getDatabase(getOracleSchema()); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(database.getId()); Assert.assertNotNull(database.getCharset()); Assert.assertNotNull(database.getCollation()); Assert.assertEquals(getOracleSchema(), database.getName()); }
getDatabase(String schemaName) { DBDatabase database = new DBDatabase(); String sql = this.sqlMapper.getSql(Statements.GET_DATABASE); jdbcOperations.query(sql, new Object[] {schemaName}, rs -> { database.setId(rs.getString(2)); database.setName(rs.getString(1)); }); try { sql = "select value from v$nls_parameters where PARAMETER = 'NLS_CHARACTERSET'"; jdbcOperations.query(sql, rs -> { database.setCharset(rs.getString(1)); }); sql = "SELECT value from v$nls_parameters where parameter = 'NLS_SORT'"; jdbcOperations.query(sql, rs -> { database.setCollation(rs.getString(1)); }); } catch (Exception e) { log.warn("Failed to get oracle charset and collation, error message:{}", e.getMessage()); sql = "select value from v_$nls_parameters where PARAMETER = 'NLS_CHARACTERSET'"; jdbcOperations.query(sql, rs -> { database.setCharset(rs.getString(1)); }); sql = "SELECT value from v_$nls_parameters where parameter = 'NLS_SORT'"; jdbcOperations.query(sql, rs -> { database.setCollation(rs.getString(1)); }); } return database; }
[*] target: assertNotNull(database)
[-] pred: org. junit. Assert. assertNotNull ( database )
************************************
************************************
[+] input: listTypes_Success() { List<DBPLObjectIdentity> types = accessor.listTypes(getOracleSchema()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, types.size()); }
listTypes(String schemaName) { OracleSqlBuilder sb = new OracleSqlBuilder();  sb.append("select OBJECT_NAME as name, STATUS, OBJECT_TYPE as type, OWNER as schema_name from "); sb.append(dataDictTableNames.OBJECTS()); sb.append(" where OBJECT_TYPE='TYPE' and OWNER="); sb.value(schemaName); sb.append(" order by OBJECT_NAME asc");  List<DBPLObjectIdentity> types = jdbcOperations.query(sb.toString(), new BeanPropertyRowMapper<>(DBPLObjectIdentity.class));  return fillTypeErrorMessage(types, schemaName); }
[*] target: assertNotNull(types)
[-] pred: org. junit. Assert. assertNotNull ( types )
************************************
************************************
[+] input: getSynonym_testPublicSynonymInfoForOracle() { DBSynonym synonym = accessor.getSynonym(getOracleSchema(), "PUBLIC_SYNONYM_ACCESSOR", DBSynonymType.PUBLIC); Assert."<AssertPlaceHolder>"; Assert.assertEquals(DBSynonymType.PUBLIC, synonym.getSynonymType()); Assert.assertEquals("PUBLIC_SYNONYM_ACCESSOR", synonym.getSynonymName()); }
getSynonym(String schemaName, String synonymName, DBSynonymType synonymType) { OracleSqlBuilder sb = new OracleSqlBuilder(); sb.append( "select s.OWNER,s.SYNONYM_NAME,s.TABLE_OWNER,s.TABLE_NAME,s.DB_LINK,o.CREATED,o.LAST_DDL_TIME,o.STATUS from "); sb.append(dataDictTableNames.SYNONYMS()); sb.append(" s left join (select * from "); sb.append(dataDictTableNames.OBJECTS()); sb.append(" where OBJECT_TYPE='SYNONYM') o on s.SYNONYM_NAME=o.OBJECT_NAME and s.OWNER=o.OWNER where s.OWNER="); sb.value(getSynonymOwnerSymbol(synonymType, schemaName)); sb.append(" and s.SYNONYM_NAME="); sb.value(synonymName);  DBSynonym synonym = new DBSynonym(); synonym.setSynonymType(synonymType); jdbcOperations.query(sb.toString(), rs -> { synonym.setOwner(rs.getString("OWNER")); synonym.setSynonymName(rs.getString("SYNONYM_NAME")); synonym.setTableOwner(rs.getString("TABLE_OWNER")); synonym.setTableName(rs.getString("TABLE_NAME")); synonym.setDbLink(rs.getString("DB_LINK")); synonym.setCreated(rs.getTimestamp("CREATED")); synonym.setLastDdlTime(rs.getTimestamp("LAST_DDL_TIME")); synonym.setStatus(rs.getString("STATUS")); }); synonym.setDdl(getSynonymDDL(synonym));  return synonym; }
[*] target: assertNotNull(synonym)
[-] pred: org. junit. Assert. assertNotNull ( synonym )
************************************
************************************
[+] input: getSynonym_testCommonSynonymInfoForOracle() { DBSynonym synonym = accessor.getSynonym(getOracleSchema(), "COMMON_SYNONYM_ACCESSOR", DBSynonymType.COMMON); Assert."<AssertPlaceHolder>"; Assert.assertEquals(DBSynonymType.COMMON, synonym.getSynonymType()); Assert.assertEquals("COMMON_SYNONYM_ACCESSOR", synonym.getSynonymName()); }
getSynonym(String schemaName, String synonymName, DBSynonymType synonymType) { OracleSqlBuilder sb = new OracleSqlBuilder(); sb.append( "select s.OWNER,s.SYNONYM_NAME,s.TABLE_OWNER,s.TABLE_NAME,s.DB_LINK,o.CREATED,o.LAST_DDL_TIME,o.STATUS from "); sb.append(dataDictTableNames.SYNONYMS()); sb.append(" s left join (select * from "); sb.append(dataDictTableNames.OBJECTS()); sb.append(" where OBJECT_TYPE='SYNONYM') o on s.SYNONYM_NAME=o.OBJECT_NAME and s.OWNER=o.OWNER where s.OWNER="); sb.value(getSynonymOwnerSymbol(synonymType, schemaName)); sb.append(" and s.SYNONYM_NAME="); sb.value(synonymName);  DBSynonym synonym = new DBSynonym(); synonym.setSynonymType(synonymType); jdbcOperations.query(sb.toString(), rs -> { synonym.setOwner(rs.getString("OWNER")); synonym.setSynonymName(rs.getString("SYNONYM_NAME")); synonym.setTableOwner(rs.getString("TABLE_OWNER")); synonym.setTableName(rs.getString("TABLE_NAME")); synonym.setDbLink(rs.getString("DB_LINK")); synonym.setCreated(rs.getTimestamp("CREATED")); synonym.setLastDdlTime(rs.getTimestamp("LAST_DDL_TIME")); synonym.setStatus(rs.getString("STATUS")); }); synonym.setDdl(getSynonymDDL(synonym));  return synonym; }
[*] target: assertNotNull(synonym)
[-] pred: org. junit. Assert. assertNotNull ( synonym )
************************************
************************************
[+] input: currentSession() { DBSession session = accessor.currentSession(); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(session.getId()); }
currentSession() { return jdbcOperations.queryForObject(GET_CURRENT_SESSION, new BeanPropertyRowMapper<>(DBSession.class)); }
[*] target: assertNotNull(session)
[-] pred: org. junit. Assert. assertNotNull ( session )
************************************
************************************
[+] input: test_findByExpireTimeBefore() { long currentTime = System.currentTimeMillis(); PermissionEntity entity = createPermissionEntity("query", "ODC_DATABASE:1", new Date(currentTime - 90 * 1000L)); createPermissionEntity("change", "ODC_DATABASE:2", new Date(currentTime - 30 * 1000L)); createPermissionEntity("change", "ODC_DATABASE:3", TimeUtils.getMySQLMaxDatetime()); Assert.assertEquals(3, permissionRepository.findAllNoCareExpireTime().size()); List<PermissionEntity> entities = permissionRepository.findByExpireTimeBefore(new Date(currentTime - 60 * 1000L)); Assert."<AssertPlaceHolder>"; Assert.assertEquals(entity.getId(), entities.get(0).getId()); }
findByExpireTimeBefore(@Param("expireTime") Date expireTime);  @Modifying @Transactional @Query(value = "delete from iam_permission p where p.id in (:ids)", nativeQuery = true) int deleteByIds(@Param("ids") Collection<Long> ids);  @Modifying @Transactional @Query(value = "delete from iam_permission p where 1=1", nativeQuery = true) void deleteAll();  default List<PermissionEntity> batchCreate(List<PermissionEntity> entities) { String sql = InsertSqlTemplateBuilder.from("iam_permission") .field(PermissionEntity_.action) .field(PermissionEntity_.resourceIdentifier) .field(PermissionEntity_.type) .field(PermissionEntity_.creatorId) .field(PermissionEntity_.organizationId) .field("is_builtin") .field(PermissionEntity_.expireTime) .field(PermissionEntity_.authorizationType) .field(PermissionEntity_.ticketId) .field(PermissionEntity_.resourceType) .field(PermissionEntity_.resourceId) .build(); List<Function<PermissionEntity, Object>> getter = valueGetterBuilder() .add(PermissionEntity::getAction) .add(PermissionEntity::getResourceIdentifier) .add((PermissionEntity e) -> e.getType().name()) .add(PermissionEntity::getCreatorId) .add(PermissionEntity::getOrganizationId) .add(PermissionEntity::getBuiltIn) .add(PermissionEntity::getExpireTime) .add((PermissionEntity e) -> e.getAuthorizationType().name()) .add(PermissionEntity::getTicketId) .add((PermissionEntity e) -> e.getResourceType().name()) .add(PermissionEntity::getResourceId) .build();  return batchCreate(entities, sql, getter, PermissionEntity::setId); }
[*] target: assertEquals(1, entities.size())
[-] pred: org. junit. Assert. assertEquals ( 1, entities. size ( ) )
************************************
************************************
[+] input: listDatabaseChangingOrderTemplates_useQueryCondition_succeed() { Database database = new Database(); when(databaseService.listDatabasesByIds(any())).thenReturn(Arrays.asList(database)); createDatabaseChangingOrderTemplate_saveEntity_succeed(); Pageable pageable = Pageable.unpaged(); QueryDatabaseChangeChangingOrderParams params = QueryDatabaseChangeChangingOrderParams.builder() .projectId(PROJECT_ID).creatorId(CURRENT_USER_ID).name(TEMPLATE_NAME).build(); Page<DatabaseChangeChangingOrderTemplateResp> result = templateService.listTemplates(pageable, params); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, result.getContent().size()); }
listTemplates(@NotNull Pageable pageable, @NotNull @Valid QueryDatabaseChangeChangingOrderParams params) { projectPermissionValidator.checkProjectRole(params.getProjectId(), ResourceRoleName.all()); Specification<DatabaseChangeChangingOrderTemplateEntity> specification = Specification .where(DatabaseChangeChangingOrderTemplateSpecs.projectIdEquals(params.getProjectId())) .and(params.getName() == null ? null : DatabaseChangeChangingOrderTemplateSpecs.nameLikes(params.getName())) .and(params.getCreatorId() == null ? null : DatabaseChangeChangingOrderTemplateSpecs .creatorIdIn(Collections.singleton(params.getCreatorId()))); Page<DatabaseChangeChangingOrderTemplateEntity> pageResult = templateRepository.findAll(specification, pageable); List<DatabaseChangeChangingOrderTemplateEntity> entityList = pageResult.getContent(); if (CollectionUtils.isEmpty(entityList)) { return Page.empty(); } List<Long> databaseIds = entityList.stream() .flatMap(entity -> entity.getDatabaseSequences().stream()) .flatMap(Collection::stream) .distinct().collect(Collectors.toList()); Map<Long, DatabaseChangeDatabase> id2DatabaseChangeDatabase = databaseService.listDatabasesDetailsByIds(databaseIds).stream() .collect(Collectors.toMap(Database::getId, DatabaseChangeDatabase::new)); List<DatabaseChangeChangingOrderTemplateResp> templateRespList = entityList.stream().map(entity -> { DatabaseChangeChangingOrderTemplateResp templateResp = new DatabaseChangeChangingOrderTemplateResp(); templateResp.setId(entity.getId()); templateResp.setName(entity.getName()); templateResp.setCreatorId(entity.getCreatorId()); templateResp.setProjectId(entity.getProjectId()); templateResp.setOrganizationId(entity.getOrganizationId()); templateResp.setEnabled(entity.getEnabled()); List<List<DatabaseChangeDatabase>> databaseSequenceList = entity.getDatabaseSequences().stream() .map(s -> s.stream().map(id2DatabaseChangeDatabase::get) .collect(Collectors.toList())) .collect(Collectors.toList()); templateResp.setDatabaseSequenceList(databaseSequenceList); return templateResp; }).collect(Collectors.toList()); return new PageImpl<>(templateRespList, pageable, pageResult.getTotalElements()); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { File target = dumpSchemaAndDataForLoad(DialectType.OB_ORACLE); assertOracleModeTableNotExists();  UploadFileResult actual = dataTransferService.getMetaInfo(target.getAbsolutePath()); UploadFileResult expect = new UploadFileResult(); expect.setFormat(DataFormat.SQL); expect.setFileType("ZIP"); expect.setFileName(target.getAbsolutePath()); expect.setContainsData(true); expect.setContainsSchema(true); Map<ObjectType, Set<String>> importFileNames = new HashMap<>(); importFileNames.putIfAbsent(ObjectType.TABLE, Collections.singleton(TEST_TABLE_NAME)); expect.setImportObjects(importFileNames);  Assert."<AssertPlaceHolder>"; }
getMetaInfo(@NonNull String fileName) throws IOException { File uploadFile = fileManager.findByName(TaskType.IMPORT, LocalFileManager.UPLOAD_BUCKET, fileName).orElseThrow( () -> new FileNotFoundException("File not found")); if (!uploadFile.exists() || !uploadFile.isFile()) { throw new IllegalArgumentException("Target is not a file or does not exist, " + fileName); }  // If the file is from third party like PL/SQL, this will convert it compatible with ob-loader. ThirdPartyOutputConverter.convert(uploadFile);  String uploadFileName = uploadFile.getName(); if (StringUtils.endsWithIgnoreCase(uploadFileName, ".zip")) { // 疑似 zip 压缩文件，需要进一步确认是否合法 try { ExportOutput dumperOutput = new ExportOutput(uploadFile); return UploadFileResult.ofExportOutput(fileName, dumperOutput); } catch (Exception e) { log.warn("Not a valid zip file, file={}", fileName, e); return UploadFileResult.ofFail(ErrorCodes.ImportInvalidFileType, new Object[] {uploadFileName}); } } else if (StringUtils.endsWithIgnoreCase(uploadFileName, ".csv")) { return UploadFileResult.ofCsv(fileName); } else if (StringUtils.endsWithIgnoreCase(uploadFileName, ".sql") || StringUtils.endsWithIgnoreCase(uploadFileName, ".txt")) { return UploadFileResult.ofSql(fileName); } return UploadFileResult.ofFail(ErrorCodes.ImportInvalidFileType, new Object[] {uploadFileName}); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: getClaims_getJwtLoad_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Map<String, Claim> claims = jwtService.getClaims(token); Assert."<AssertPlaceHolder>"; Assert.assertEquals(new Integer(123), claims.get("userId").asInt()); Assert.assertEquals("testUser", claims.get("username").asString()); }
getClaims(String token) { Algorithm algorithm = Algorithm.HMAC256(jwtProperties.getTokenSecret()); JWTVerifier verifier = JWT.require(algorithm).build(); return verifier.verify(token).getClaims(); }
[*] target: assertNotNull(claims)
[-] pred: org. junit. Assert. assertNotNull ( claims )
************************************
************************************
[+] input: test_AES256_BASE64() { String raw = RandomStringUtils.random(256); Encryption encryption = createEncryption(EncryptionAlgorithm.AES256_BASE64); String encrypted = EncryptionUtil.encrypt(raw, encryption); Assert.assertNotEquals(raw, encrypted); String decrypted = EncryptionUtil.decrypt(encrypted, encryption); Assert."<AssertPlaceHolder>"; }
decrypt(String encryptedText, Encryption encryption) { return Objects.requireNonNull(encryptorCache.get(encryption)).decrypt(encryptedText); }
[*] target: assertEquals(raw, decrypted)
[-] pred: org. junit. Assert. assertEquals ( raw, decrypted )
************************************
************************************
[+] input: test_RAW() { String raw = RandomStringUtils.random(256); Encryption encryption = createEncryption(EncryptionAlgorithm.RAW); String encrypted = EncryptionUtil.encrypt(raw, encryption); Assert.assertEquals(raw, encrypted); String decrypted = EncryptionUtil.decrypt(encrypted, encryption); Assert."<AssertPlaceHolder>"; }
decrypt(String encryptedText, Encryption encryption) { return Objects.requireNonNull(encryptorCache.get(encryption)).decrypt(encryptedText); }
[*] target: assertEquals(raw, decrypted)
[-] pred: org. junit. Assert. assertEquals ( raw, decrypted )
************************************
************************************
[+] input: test_CreateChannel_withChannelConfig() { Channel saved = notificationService.createChannel(PROJECT_ID, getChannel()); Assert."<AssertPlaceHolder>"; List<ChannelPropertyEntity> properties = channelPropertyRepository.findAllByChannelId(saved.getId()); Assert.assertEquals(2, properties.size()); }
createChannel(@NotNull Long projectId, @NotNull Channel channel) { PreConditions.notBlank(channel.getName(), "channel.name"); PreConditions.notNull(channel.getType(), "channel.type"); PreConditions.validNoDuplicated(ResourceType.ODC_NOTIFICATION_CHANNEL, "channel.name", channel.getName(), () -> existsChannel(projectId, channel.getName())); validator.validate(channel.getType(), channel.getChannelConfig());  if (StringUtils.isEmpty(channel.getChannelConfig().getTitleTemplate())) { channel.getChannelConfig().setTitleTemplate("${taskType}-${taskStatus}"); } ChannelEntity entity = channelMapper.toEntity(channel); entity.setCreatorId(authenticationFacade.currentUserId()); entity.setOrganizationId(authenticationFacade.currentOrganizationId()); entity.setProjectId(projectId);  return channelMapper.fromEntity(channelRepository.save(entity)); }
[*] target: assertNotNull(saved)
[-] pred: org. junit. Assert. assertNotNull ( saved )
************************************
************************************
[+] input: testGetOrCreateLocalFile_Success() { MultipartFile mockFile = new MockMultipartFile("some-file", "some-file", null, new byte[10]); localFileOperator.saveLocalFile(BUCKET, mockFile.getOriginalFilename(), mockFile.getSize(), mockFile.getInputStream()); File file = localFileOperator.getOrCreateLocalFile(BUCKET, "some-file"); "<AssertPlaceHolder>"; assertTrue(file.exists()); }
getOrCreateLocalFile(String bucketName, String objectId) { Verify.notEmpty(bucketName, "bucketName"); Verify.notEmpty(objectId, "objectId"); PreConditions.validNoPathTraversal(generateFilePath(bucketName, objectId), generateFilePath(bucketName)); File file = new File(absolutePathName(bucketName, objectId)); createParentDirs(file); return file; }
[*] target: assertNotNull(file)
[-] pred: org. junit. Assert. assertNotNull ( file )
************************************
************************************
[+] input: testWebUtil() { SecuritySession session = Mockito.mock(SecuritySession.class); Mockito.when(session.getId()).thenReturn("abcde"); Mockito.when(session.getTimeoutMillis()).thenReturn(100000L); Cookie cookie = WebUtil.generateSecurityCookie(session); Assert."<AssertPlaceHolder>"; Assert.assertEquals(cookie.getValue(), session.getId()); Assert.assertEquals(cookie.getMaxAge(), TimeUnit.SECONDS.convert(session.getTimeoutMillis(), TimeUnit.MILLISECONDS)); Assert.assertTrue(cookie.isHttpOnly()); Assert.assertEquals(cookie.getPath(), "/"); }
generateSecurityCookie(@NonNull SecuritySession session) { Cookie cookie = new Cookie(SecurityConstants.CUSTOM_COOKIE_NAME, (String) session.getId()); cookie.setHttpOnly(true); long maxAgeSeconds = TimeUnit.SECONDS.convert(session.getTimeoutMillis(), TimeUnit.MILLISECONDS); if (maxAgeSeconds > Integer.MAX_VALUE) { cookie.setMaxAge(Integer.MAX_VALUE); } else { cookie.setMaxAge((int) maxAgeSeconds); } cookie.setPath("/"); return cookie; }
[*] target: assertNotNull(cookie)
[-] pred: org. junit. Assert. assertNotNull ( cookie )
************************************
************************************
[+] input: testWebUtilWithIntMaxValue() { SecuritySession session = Mockito.mock(SecuritySession.class); Mockito.when(session.getId()).thenReturn("abcde"); Mockito.when(session.getTimeoutMillis()).thenReturn(Integer.MAX_VALUE * 1000L + 100000); Cookie cookie = WebUtil.generateSecurityCookie(session); Assert."<AssertPlaceHolder>"; Assert.assertEquals(cookie.getValue(), session.getId()); Assert.assertEquals(cookie.getMaxAge(), Integer.MAX_VALUE); Assert.assertTrue(cookie.isHttpOnly()); Assert.assertEquals(cookie.getPath(), "/"); }
generateSecurityCookie(@NonNull SecuritySession session) { Cookie cookie = new Cookie(SecurityConstants.CUSTOM_COOKIE_NAME, (String) session.getId()); cookie.setHttpOnly(true); long maxAgeSeconds = TimeUnit.SECONDS.convert(session.getTimeoutMillis(), TimeUnit.MILLISECONDS); if (maxAgeSeconds > Integer.MAX_VALUE) { cookie.setMaxAge(Integer.MAX_VALUE); } else { cookie.setMaxAge((int) maxAgeSeconds); } cookie.setPath("/"); return cookie; }
[*] target: assertNotNull(cookie)
[-] pred: org. junit. Assert. assertNotNull ( cookie )
************************************
************************************
[+] input: IOException { ResourceManager manager = getResourceManager(); ResourceSpec defaultEntity = getDefaultResourceEntity(manager);  TableTemplate entity = defaultEntity.getTemplates().get(0); List<DataRecord> permissions = getDataRecords(defaultEntity, manager, entity); Assert.assertEquals(1, permissions.size());  DataRecord permission = permissions.get(0); DataRecordRepository repository = new DataRecordRepository(dataSource); Assert.assertFalse(repository.exists(permission)); repository.save(permission); Assert."<AssertPlaceHolder>"; }
exists(@NonNull DataRecord record) { List<DataSpec> conditions = record.getUniqueKeyData(); String sql = generateSelectSql(record.getTableName(), "COUNT(1)", conditions); List<Long> result = query(sql, conditions, (resultSet, i) -> resultSet.getLong(1)); Verify.singleton(result, "Count(1) has to be singleton"); return result.get(0) >= 1; }
[*] target: assertTrue(repository.exists(permission))
[-] pred: org. junit. Assert. assertTrue ( repository. exists ( permission ) )
************************************
************************************
[+] input: IOException { Map<Integer, String> index2Content = new HashMap<>(); Map<Integer, BinaryContentMetaData> index2MetaData = new HashMap<>();  BinaryDataManager dataManager = getDataManager(); for (int i = 0; i < 3; i++) { String content = getInputContent(); index2Content.putIfAbsent(i, content); index2MetaData.putIfAbsent(i, dataManager.write(getInputContentStream(content))); }  for (int i = 0; i < 3; i++) { BinaryContentMetaData metaData = index2MetaData.get(i); Assert.assertNotNull(metaData); InputStream inputStream = dataManager.read(metaData); String fromFile = String.join("", IOUtils.readLines(inputStream)); String fromMemory = index2Content.get(i); Assert."<AssertPlaceHolder>"; } }
read(@NonNull BinaryContentMetaData metaData) throws IOException;
[*] target: assertEquals(fromFile, fromMemory)
[-] pred: org. junit. Assert. assertEquals ( fromFile, fromMemory )
************************************
************************************
[+] input: testPollBatch() { try { ClosableBlockingQueue<String> queue = new ClosableBlockingQueue<>();  assertNull(queue.pollBatch());  queue.add("a"); queue.add("b");  assertEquals(asList("a", "b"), queue.pollBatch()); assertNull(queue.pollBatch());  queue.add("c");  assertEquals(singletonList("c"), queue.pollBatch()); "<AssertPlaceHolder>";  assertTrue(queue.close());  try { queue.pollBatch(); fail("should cause an exception"); } catch (IllegalStateException ignored) { // expected } } catch (Exception e) { e.printStackTrace(); fail(e.getMessage()); } }
pollBatch() { lock.lock(); try { if (open) { if (elements.size() > 0) { ArrayList<E> result = new ArrayList<>(elements); elements.clear(); return result; } else { return null; } } else { throw new IllegalStateException("queue is closed"); } } finally { lock.unlock(); } }
[*] target: assertNull(queue.pollBatch())
[-] pred: org. junit. Assert. assertNull ( queue. pollBatch ( ) )
************************************
************************************

[+] input: testLoadObject() { ConfigMetadata configMetadata = YamlParserUtil.loadObject(CONFIG_METADATA_STRING, ConfigMetadata.class); Assert."<AssertPlaceHolder>";  List<ConfigMetadata.ConfigExportItem> metadataList = configMetadata.getMetadata(); Assert.assertNotNull(metadataList); Assert.assertEquals(metadataList.size(), 2); ConfigMetadata.ConfigExportItem configExportItem1 = metadataList.get(0); ConfigMetadata.ConfigExportItem configExportItem2 = metadataList.get(1); Assert.assertEquals(configExportItem1, item1); Assert.assertEquals(configExportItem2, item2); }
loadObject(String content, Class<T> type) { return new Yaml(new YamlParserConstructor(), new CustomRepresenter()).loadAs(content, type); }
[*] target: assertNotNull(configMetadata)
[-] pred: org. junit. Assert. assertNotNull ( configMetadata )
************************************
************************************
[+] input: getResource_whenResourcePathIsNull_thenResourceIsNull() { final URL resource = ManifestUtils.getResource(HiveMQEdgeMain.class, null); "<AssertPlaceHolder>"; }
getResource(final Class clazz, final String resourcePath) {  try {  if (clazz == null || resourcePath == null) { return null; }  final ClassLoader cl = clazz.getClassLoader(); final Enumeration<URL> resources = cl.getResources(resourcePath); final List<URL> urls = new ArrayList<>(); // There could be multiple jar file (windows service for example) while (resources.hasMoreElements()) { urls.add(resources.nextElement()); } if (urls.isEmpty()) { // There is no Resource return null; } URL url = null; if (urls.size() == 1) { // There is only one jar file url = urls.get(0); } else { for (final URL currentUrl : urls) { if (currentUrl.getPath().contains("hivemq.jar")) { // If there are multiple jar files, we pick the one that contains the substring "hivemq.jar" url = currentUrl; break; } } if (url == null) { // If non of the urls contains the substring "hivemq.jar" we return the first one url = urls.get(0); } }  return url; } catch (final IOException e) { log.warn("Could not read resource " + resourcePath); log.debug("Original exception: ", e); return null; } }
[*] target: assertNull(resource)
[-] pred: org. junit. Assert. assertNull ( resource )
************************************
************************************
[+] input: InterruptedException { FailedLoginAttemptLimiter limiter = new FailedLoginAttemptLimiter(1, 1L);  limiter.attempt(() -> false); TimeUnit.MILLISECONDS.sleep(2L); Boolean result = limiter.attempt(() -> true);  Assert."<AssertPlaceHolder>"; }
attempt(Supplier<Boolean> attemptResultSupplier) { long currentTimeMillis = System.currentTimeMillis(); if (isLocked && (currentTimeMillis > lastLockedMills + lockTimeoutMillis || lockTimeoutMillis <= 0)) { isLocked = false; failedAttempt = 0; } if (isLocked) { long remainSeconds = (lastLockedMills + lockTimeoutMillis - currentTimeMillis) / 1000L; throw new AttemptLoginOverLimitException((double) maxFailedAttempt, remainSeconds, String.format("failed attempt over limit, failedAttempt=%d, limit=%d, remainSeconds=%d", failedAttempt, maxFailedAttempt, remainSeconds)); } Boolean result = null; try { result = attemptResultSupplier.get(); return result; } finally { if (result == null || !result) { log.info("attempt failed, currentFailedAttempt={}", failedAttempt); failedAttempt++; if (failedAttempt >= maxFailedAttempt) { isLocked = true; lastLockedMills = currentTimeMillis; } } } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: buildDataSource() { DataSource dataSource = SQLUtils.buildDataSource("127.0.0.1:2881", "test", "teat", "test"); "<AssertPlaceHolder>"; }
buildDataSource(String address, String database, String username, String password) { String url = dataSourceUrl(address, database); DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setTestWhileIdle(true); dataSource.setTestOnBorrow(false); dataSource.setTestOnReturn(false); dataSource.setValidationQuery("select 1 from dual"); dataSource.setInitialSize(2); dataSource.setMinIdle(2); dataSource.setMaxActive(16); return dataSource; }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: generateSyncData() { ClientSyncData clientSyncData = abstractClient.generateSyncData(); Assert."<AssertPlaceHolder>"; }
generateSyncData() { List<String> namespaces = new LinkedList<>(); List<String> groupNames = new LinkedList<>(); List<String> serviceNames = new LinkedList<>();  List<String> batchNamespaces = new LinkedList<>(); List<String> batchGroupNames = new LinkedList<>(); List<String> batchServiceNames = new LinkedList<>();  List<InstancePublishInfo> instances = new LinkedList<>(); List<BatchInstancePublishInfo> batchInstancePublishInfos = new LinkedList<>(); BatchInstanceData  batchInstanceData = new BatchInstanceData(); for (Map.Entry<Service, InstancePublishInfo> entry : publishers.entrySet()) { InstancePublishInfo instancePublishInfo = entry.getValue(); if (instancePublishInfo instanceof BatchInstancePublishInfo) { BatchInstancePublishInfo batchInstance = (BatchInstancePublishInfo) instancePublishInfo; batchInstancePublishInfos.add(batchInstance); buildBatchInstanceData(batchInstanceData, batchNamespaces, batchGroupNames, batchServiceNames, entry); batchInstanceData.setBatchInstancePublishInfos(batchInstancePublishInfos); } else { namespaces.add(entry.getKey().getNamespace()); groupNames.add(entry.getKey().getGroup()); serviceNames.add(entry.getKey().getName()); instances.add(entry.getValue()); } } ClientSyncData data = new ClientSyncData(getClientId(), namespaces, groupNames, serviceNames, instances, batchInstanceData); data.getAttributes().addClientAttribute(REVISION, getRevision()); return data; }
[*] target: assertNotNull(clientSyncData)
[-] pred: org. junit. Assert. assertNotNull ( clientSyncData )
************************************
************************************
[+] input: generate_countAllExprList_generateFunctionCallSucceed() { ExprContext context = getExprContext("count(unique a,b,c)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, null, "a"))); params.add(new ExpressionParam(new ColumnReference(null, null, "b"))); params.add(new ExpressionParam(new ColumnReference(null, null, "c"))); FunctionCall expect = new FunctionCall("count", params); expect.addOption(new ConstExpression("unique")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: getAllPublishedService() { Collection<Service> allPublishedService = abstractClient.getAllPublishedService(); Assert."<AssertPlaceHolder>"; }
getAllPublishedService() { return publishers.keySet(); }
[*] target: assertNotNull(allPublishedService)
[-] pred: org. junit. Assert. assertNotNull ( allPublishedService )
************************************
************************************
[+] input: generate_predicateNotLikeEscapeMix_generateSucceed() { ExprContext context = getExprContext("tab.col not like 'abc' escape col"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression e1 = new ConstExpression("'abc'"); Expression e2 = new ColumnReference(null, null, "col"); Expression right = new CompoundExpression(e1, e2, Operator.ESCAPE); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetRolesByUserName() { Page<RoleInfo> userName = externalRolePersistService .getRolesByUserNameAndRoleName("userName", "roleName", 1, 10); Assert."<AssertPlaceHolder>"; }
getRolesByUserNameAndRoleName(String username, String role, int pageNo, int pageSize) {  AuthPaginationHelper<RoleInfo> helper = createPaginationHelper();  String sqlCountRows = "SELECT count(*) FROM roles ";  String sqlFetchRows = "SELECT role,username FROM roles ";  StringBuilder where = new StringBuilder(" WHERE 1 = 1 "); List<String> params = new ArrayList<>(); if (StringUtils.isNotBlank(username)) { where.append(" AND username = ? "); params.add(username); } if (StringUtils.isNotBlank(role)) { where.append(" AND role = ? "); params.add(role); }  try { return helper.fetchPage(sqlCountRows + where, sqlFetchRows + where, params.toArray(), pageNo, pageSize, ROLE_INFO_ROW_MAPPER); } catch (CannotGetJdbcConnectionException e) { LogUtil.FATAL_LOG.error("[db-error] " + e.toString(), e); throw e; } }
[*] target: assertNotNull(userName)
[-] pred: org. junit. Assert. assertNotNull ( userName )
************************************
************************************
[+] input: testTypeWeightFilterSampleByWeight() { AbstractResult indexResult = new CommonResult(typeIndex, Arrays.asList(0, 2, 4, 5, 6, 9));  String sampleMeta = "topk(by=weight, limit=3, reverse=false, replacement=false)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(0, 2, 4); "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { Map<Integer, String> index2Content = new HashMap<>(); Map<Integer, BinaryContentMetaData> index2MetaData = new HashMap<>();  BinaryDataManager dataManager = getDataManager(); for (int i = 0; i < 3; i++) { String content = getInputContent(); index2Content.putIfAbsent(i, content); index2MetaData.putIfAbsent(i, dataManager.write(getInputContentStream(content))); }  for (int i = 0; i < 3; i++) { BinaryContentMetaData metaData = index2MetaData.get(i); Assert.assertNotNull(metaData); InputStream inputStream = dataManager.read(metaData); String fromFile = String.join("", IOUtils.readLines(inputStream)); String fromMemory = index2Content.get(i); Assert."<AssertPlaceHolder>"; } }
read(@NonNull BinaryContentMetaData metaData) throws IOException;
[*] target: assertEquals(fromFile, fromMemory)
[-] pred: org. junit. Assert. assertEquals ( fromFile, fromMemory )
************************************
************************************
[+] input: generate_modifyListPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition by list(a,b) (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress," + "partition values ('aaaddd') id 15 tablespace tbs)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setNoCompress(true); options1.setId(14); e2.setPartitionOptions(options1); ListPartitionElement e3 = new ListPartitionElement(null, Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); expect.setModifyPartition(new ListPartition(cols, Arrays.asList(e1, e2, e3), null, null, false)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_cubeGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by CUBE(col, col1)"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();  ExpressionParam p1 = new ExpressionParam(new RelationReference("col", null)); ExpressionParam p2 = new ExpressionParam(new RelationReference("col1", null)); FunctionCall fCall = new FunctionCall("CUBE", Arrays.asList(p1, p2)); GroupBy expect = new GeneralGroupBy(fCall); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.groupbyElementContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_noChanges() { final PublishPacketImpl packet = new PublishPacketImpl("topic", Qos.AT_LEAST_ONCE, Qos.AT_LEAST_ONCE, 1, false, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, ImmutableIntArray.of(), UserPropertiesImpl.of(ImmutableList.of()), System.currentTimeMillis()); final ModifiablePublishPacketImpl modifiablePacket = new ModifiablePublishPacketImpl(packet, configurationService);  final PublishPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new PublishPacketImpl(topic, qos, onwardQos, packetId, dupFlag, payload, retain, messageExpiryInterval, payloadFormatIndicator, contentType, responseTopic, correlationData, subscriptionIdentifiers, userProperties.copy(), timestamp); }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
************************************
[+] input: aes() { String text = "abcdefg"; String key = "test"; String result = Functions.aesDecrypt(key, Functions.aesEncrypt(key, text)); "<AssertPlaceHolder>"; }
aesEncrypt(String key, String data) { AESEncryptor encryptor = new AESEncryptor(key); return encryptor.encrypt(data); }
[*] target: assertEquals(text, result)
[-] pred: org. junit. Assert. assertEquals ( text, result )
************************************
************************************
[+] input: listPackages_invalidPackageList() { List<DBPLObjectIdentity> packages = accessor.listPackages(getOracleSchema()); boolean flag = false; for (DBPLObjectIdentity dbPackage : packages) { if (StringUtils.containsIgnoreCase(dbPackage.getErrorMessage(), "ORA")) { flag = true; } } Assert."<AssertPlaceHolder>"; }
listPackages(String schemaName) { OracleSqlBuilder sb = new OracleSqlBuilder();  sb.append("select object_name as name, object_type as type, owner, status from "); sb.append(dataDictTableNames.OBJECTS()); sb.append(" where (object_type = 'PACKAGE' or object_type = 'PACKAGE BODY') and owner="); sb.value(schemaName); sb.append(" order by name asc");  List<DBPLObjectIdentity> packages = jdbcOperations.query(sb.toString(), (rs, rowNum) -> { DBPLObjectIdentity dbPackage = new DBPLObjectIdentity(); dbPackage.setName(rs.getString("name")); dbPackage.setStatus(rs.getString("status")); dbPackage.setSchemaName(rs.getString("owner")); dbPackage.setType(DBObjectType.getEnumByName(rs.getString("type"))); return dbPackage; });  List<DBPLObjectIdentity> filtered = new ArrayList<>(); Map<String, String> name2Status = new HashMap<>(); for (DBPLObjectIdentity dbPackage : packages) { String pkgName = dbPackage.getName(); String status = dbPackage.getStatus(); // merge status of 'package' and 'package body' if (name2Status.containsKey(pkgName)) { if (PLConstants.PL_OBJECT_STATUS_INVALID.equalsIgnoreCase(status)) { name2Status.put(pkgName, status); } } else { name2Status.put(pkgName, status); } } Map<String, String> errorText = PLObjectErrMsgUtils.acquireErrorMessage(jdbcOperations, schemaName, DBObjectType.PACKAGE.name(), null); String pkgName = null; for (DBPLObjectIdentity pkg : packages) { if (Objects.isNull(pkgName) || !StringUtils.equals(pkgName, pkg.getName())) { pkgName = pkg.getName(); DBPLObjectIdentity dbPackage = new DBPLObjectIdentity(); dbPackage.setName(pkg.getName()); dbPackage.setStatus(name2Status.get(pkg.getName())); dbPackage.setSchemaName(pkg.getSchemaName()); dbPackage.setType(pkg.getType()); if (StringUtils.containsIgnoreCase(dbPackage.getStatus(), PLConstants.PL_OBJECT_STATUS_INVALID)) { dbPackage.setErrorMessage(errorText.get(dbPackage.getName())); } filtered.add(dbPackage); } } return filtered; }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: generate_addColumn_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("add id varchar(64)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); CharacterType type = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition d = new ColumnDefinition(new ColumnReference(null, null, "id"), type); expect.setAddColumns(Collections.singletonList(d)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: ParseException { String dateStr = "Wed, 21 Feb 2007 15:35:00 +0100"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
************************************
[+] input: deleteByUserId_Exists_ReturnAffectRows() { UserConfigEntity entity = createEntity(); userConfigDAO.batchUpsert(Arrays.asList(entity));  int affectRows = userConfigDAO.deleteByUserId(USER_ID);  Assert."<AssertPlaceHolder>"; }
deleteByUserId(Long userId) { PreConditions.notNull(userId, "userId"); String sql = "DELETE FROM config_user_configuration WHERE user_id = ?"; return jdbcTemplate.update(sql, userId); }
[*] target: assertEquals(1, affectRows)
[-] pred: org. junit. Assert. assertEquals ( 1, affectRows )
************************************
************************************
[+] input: generate_predicateNotLikeSimpleExpr_generateSucceed() { ExprContext context = getExprContext("tab.col not like abc"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new ColumnReference(null, null, "abc"); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: migrate_labelIdExists_migrateSucceed() { ConnectionEntity connectionEntity = getConnectionEntiy(); connectionEntity.setVisibleScope(ConnectionVisibleScope.PRIVATE); Map<String, String> map = new HashMap<>(); long labelId = 12L; map.put(PropertiesKeys.LABEL_ID, Long.toString(labelId)); connectionEntity.setProperties(map); connectionEntity = repository.save(connectionEntity);  V4103ConnectionLabelMigrate migrate = new V4103ConnectionLabelMigrate(); migrate.migrate(dataSource);  List<ConnectionLabelRelationEntity> actual = labelRelationRepository.findByUserId(connectionEntity.getCreatorId()); actual.forEach(e -> { e.setId(null); e.setCreateTime(null); e.setUpdateTime(null); }); List<ConnectionLabelRelationEntity> expect = new ArrayList<>(); ConnectionLabelRelationEntity entity = new ConnectionLabelRelationEntity(); entity.setUserId(connectionEntity.getCreatorId()); entity.setConnectionId(connectionEntity.getId()); entity.setLabelId(labelId); expect.add(entity); Assert."<AssertPlaceHolder>"; }
migrate(DataSource dataSource) { JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); String querySql = "SELECT `id`,`properties_json`,`creator_id` FROM `connect_connection` WHERE `visible_scope`='PRIVATE'"; List<Object[]> params = jdbcTemplate.query(querySql, (rs, rowNum) -> { String json = rs.getString("properties_json"); if (StringUtils.isBlank(json)) { return null; } Map<String, String> map = JsonUtils.fromJson(json, new TypeReference<Map<String, String>>() {}); if (map == null) { return null; } String labelIdStr = map.get(PropertiesKeys.LABEL_ID); if (StringUtils.isBlank(labelIdStr)) { return null; } return new Object[] {rs.getLong("id"), Long.valueOf(labelIdStr), rs.getLong("creator_id")}; }).stream().filter(Objects::nonNull).collect(Collectors.toList());  String insertSql = "INSERT INTO `connect_connection_label`(`connection_id`,`label_id`,`user_id`) VALUES (?,?,?)"; jdbcTemplate.batchUpdate(insertSql, params); log.info("Migrate connection label succeed"); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { List<RevCommit> commits = new ArrayList<>(); Git git = Git.wrap(db);  writeTrashFile("Test.txt", "Hello world"); git.add().addFilepattern("Test.txt").call(); commits.add(git.commit().setMessage("initial commit").call());  git.branchCreate().setName("branch1").call(); Ref checkedOut = git.checkout().setName("branch1").call(); assertEquals("refs/heads/branch1", checkedOut.getName()); writeTrashFile("Test1.txt", "Hello world!"); git.add().addFilepattern("Test1.txt").call(); commits.add(git.commit().setMessage("branch1 commit").call());  checkedOut = git.checkout().setName("master").call(); assertEquals("refs/heads/master", checkedOut.getName()); writeTrashFile("Test2.txt", "Hello world!!"); git.add().addFilepattern("Test2.txt").call(); commits.add(git.commit().setMessage("branch1 commit").call());  Iterator<RevCommit> log = git.log().all().call().iterator(); "<AssertPlaceHolder>"; assertTrue(commits.contains(log.next())); assertTrue(log.hasNext()); assertTrue(commits.contains(log.next())); assertTrue(log.hasNext()); assertTrue(commits.contains(log.next())); assertFalse(log.hasNext()); }
call() throws GitAPIException, NoHeadException { checkCallable(); List<TreeFilter> filters = new ArrayList<>(); if (!pathFilters.isEmpty()) { filters.add(AndTreeFilter.create(PathFilterGroup.create(pathFilters), TreeFilter.ANY_DIFF)); } if (!excludeTreeFilters.isEmpty()) { for (TreeFilter f : excludeTreeFilters) { filters.add(AndTreeFilter.create(f, TreeFilter.ANY_DIFF)); } } if (!filters.isEmpty()) { if (filters.size() == 1) { filters.add(TreeFilter.ANY_DIFF); } walk.setTreeFilter(AndTreeFilter.create(filters));  } if (skip > -1 && maxCount > -1) walk.setRevFilter(AndRevFilter.create(SkipRevFilter.create(skip), MaxCountRevFilter.create(maxCount))); else if (skip > -1) walk.setRevFilter(SkipRevFilter.create(skip)); else if (maxCount > -1) walk.setRevFilter(MaxCountRevFilter.create(maxCount)); if (!startSpecified) { try { ObjectId headId = repo.resolve(Constants.HEAD); if (headId == null) throw new NoHeadException( JGitText.get().noHEADExistsAndNoExplicitStartingRevisionWasSpecified); add(headId); } catch (IOException e) { // all exceptions thrown by add() shouldn't occur and represent // severe low-level exception which are therefore wrapped throw new JGitInternalException( JGitText.get().anExceptionOccurredWhileTryingToAddTheIdOfHEAD, e); } }  if (this.revFilter != null) { walk.setRevFilter(this.revFilter); }  setCallable(false); return walk; }
[*] target: assertTrue(log.hasNext())
[-] pred: org. junit. Assert. assertTrue ( log. hasNext ( ) )
************************************
************************************
[+] input: list_listLabels_listSucceed() { ConnectionLabel label = TestRandom.nextObject(ConnectionLabel.class); labelDAO.insert(label); List<ConnectionLabel> actual = labelDAO.list(label.getUserId()); List<ConnectionLabel> expect = Collections.singletonList(label); actual.forEach(connectionLabel -> { connectionLabel.setGmtCreated(null); connectionLabel.setGmtModified(null); }); expect.forEach(connectionLabel -> { connectionLabel.setGmtCreated(null); connectionLabel.setGmtModified(null); }); Assert."<AssertPlaceHolder>"; }
list(long userId);
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: parse2_withClusterWithMultipleWhitespace_expectSuccess() { ConnectionStringParseResult expected = new ConnectionStringParseResult(); expected.setClusterName("C1"); expected.setTenantName("tenant1"); expected.setHost("127.0.0.1"); expected.setPort(2883); expected.setUsername("root"); expected.setDefaultSchema("oceanbase"); expected.setPassword("pwd");  String connStr = "obclient -h127.0.0.1  -P2883   -uroot@tenant1#C1 -Doceanbase -ppwd"; ConnectionStringParseResult result = MySQLClientArgsParser.parse2(connStr);  Assert."<AssertPlaceHolder>"; }
parse2(String commandLineStr) { OdcConnectionParseResult result1 = parse(commandLineStr); ConnectionStringParseResult result = new ConnectionStringParseResult(); result.setDialectType(DialectType.fromValue(result1.getDbMode())); result.setHost(result1.getHost()); result.setPort(result1.getPort()); result.setClusterName(result1.getCluster()); result.setTenantName(result1.getTenant()); result.setUsername(result1.getDbUser()); result.setPassword(result1.getPassword()); result.setDefaultSchema(result1.getDefaultDBName()); return result; }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: generate_indexHashPartitioned_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index idx_name (col, col1) partition by hash(col)")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); HashPartition p = new HashPartition(Collections.singletonList(new ColumnReference(null, null, "col")), null, null, null); expect.setPartition(p); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_noChanges() { final SubscribePacketImpl packet = new SubscribePacketImpl( ImmutableList.of(new SubscriptionImpl("topic", Qos.AT_LEAST_ONCE, RetainHandling.SEND, false, false)), UserPropertiesImpl.of(ImmutableList.of()), 1, 1); final ModifiableSubscribePacketImpl modifiablePacket = new ModifiableSubscribePacketImpl(packet, configurationService);  final SubscribePacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { final ImmutableList.Builder<SubscriptionImpl> builder = ImmutableList.builder(); subscriptions.forEach(subscription -> builder.add(subscription.copy())); return new SubscribePacketImpl( builder.build(), userProperties.copy(), subscriptionIdentifier, packetIdentifier); }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
************************************
[+] input: generate_withColumnGroup_customGroup_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(g1(col), g2(col, col1))")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); List<ColumnGroupElement> columnGroupElements = Arrays.asList( new ColumnGroupElement("g1", Collections.singletonList("col")), new ColumnGroupElement("g2", Arrays.asList("col", "col1"))); expect.setColumnGroupElements(columnGroupElements); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_alterIndex_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("alter index abc visible")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexVisibility("abc", true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { Callable callable = mock(Callable.class); when(callable.call()).thenThrow(new RuntimeException("test")); String actual = TemplateUtils.stringEmptyAndThenExecute(null, callable); "<AssertPlaceHolder>"; }
stringEmptyAndThenExecute(String source, Callable<String> callable) {  if (StringUtils.isEmpty(source)) {  try { return callable.call(); } catch (Exception e) { LogUtils.NAMING_LOGGER.error("string empty and then execute cause an exception.", e); } }  return source == null ? null : source.trim(); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: testIsBucketExist_ReturnTrue() { when(bucketRepository.findByName(anyString())).thenReturn(Optional.of(new BucketEntity())); boolean exists = bucketOperation.isBucketExist("whatever"); verify(bucketRepository, times(1)).findByName(anyString()); "<AssertPlaceHolder>"; }
isBucketExist(String name) { validateName(name); return bucketRepository.findByName(name).isPresent(); }
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
************************************
[+] input: testReceiveConfigInfoIsNotProperties() { final Deque<Properties> q2 = new ArrayDeque<Properties>(); PropertiesListener a = new PropertiesListener() { @Override public void innerReceive(Properties properties) { q2.offer(properties); } }; a.receiveConfigInfo(null); final Properties actual = q2.poll(); Assert."<AssertPlaceHolder>"; }
receiveConfigInfo(String configInfo) { if (StringUtils.isEmpty(configInfo)) { return; }  Properties properties = new Properties(); try { properties.load(new StringReader(configInfo)); innerReceive(properties); } catch (IOException e) { LOGGER.error("load properties error：" + configInfo, e); }  }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: generate_decimalWithDecimalPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("dec(2E2)")); DataType actual = factory.generate();  DataType expect = new NumberType("dec", new BigDecimal("2E2"), null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: IOException { final boolean[] called = new boolean[1]; os = new TimeoutOutputStream(new OutputStream() { @Override public void write(int b) throws IOException { fail("should not have written"); }  @Override public void flush() throws IOException { called[0] = true; } }, timer); os.setTimeout(timeout); os.flush(); "<AssertPlaceHolder>"; }
flush() throws IOException { try { beginWrite(); dst.flush(); } catch (InterruptedIOException e) { throw writeTimedOut(e); } finally { endWrite(); } }
[*] target: assertTrue(called[0])
[-] pred: org. junit. Assert. assertTrue ( called[0] )
************************************
************************************
[+] input: testEquals_trueWhenCountersBothNull() { DataVersion dataVersion = new DataVersion(); dataVersion.setCounter(null); DataVersion other = new DataVersion(); other.setCounter(null); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
equals(final Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  final DataVersion that = (DataVersion) o;  if (timestamp != that.timestamp) { return false; }  if (counter != null && that.counter != null) { return counter.longValue() == that.counter.longValue(); }  return (null == counter) && (null == that.counter); }
[*] target: assertTrue(dataVersion.equals(other))
[-] pred: org. junit. Assert. assertTrue ( dataVersion. equals ( other ) )
************************************
************************************
[+] input: test_EntityToModel_Success() { AuditEventMetaEntity entity = new AuditEventMetaEntity(); entity.setSidExtractExpression("test"); entity.setMethodSignature("controller"); entity.setEnabled(true); entity.setType(AuditEventType.PERSONAL_CONFIGURATION); entity.setAction(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION); entity.setInConnection(true);  AuditEventMeta expected = AuditEventMeta.builder() .action(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION) .type(AuditEventType.PERSONAL_CONFIGURATION) .enabled(true) .inConnection(true) .methodSignature("controller") .sidExtractExpression("test") .build();  AuditEventMeta actual = mapper.entityToModel(entity); Assert."<AssertPlaceHolder>"; }
entityToModel(AuditEventMetaEntity entity);
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test_fail_code_string() { output.authorizerPresent(); output.failAuthorization(AckReasonCode.TOPIC_NAME_INVALID, "test-string"); task.onSuccess(output);  channel.runPendingTasks();  final AuthorizeWillResultEvent resultEvent = eventsCollector.pollEvent(); "<AssertPlaceHolder>"; assertEquals(AckReasonCode.TOPIC_NAME_INVALID, resultEvent.getResult().getAckReasonCode()); assertEquals("test-string", resultEvent.getResult().getReasonString()); }
onSuccess(@Nullable final PublishAuthorizerOutputImpl output) { if (output == null) { //this does not happen return; }  DisconnectReasonCode disconnectReasonCode = null; AckReasonCode reasonCode = null; String reasonString = null;  switch (output.getAuthorizationState()) { case DISCONNECT: disconnectReasonCode = output.getDisconnectReasonCode(); reasonCode = output.getAckReasonCode() != null ? output.getAckReasonCode() : AckReasonCode.NOT_AUTHORIZED; reasonString = output.getReasonString() != null ? output.getReasonString() : getReasonString(connect); break; case FAIL: reasonCode = output.getAckReasonCode() != null ? output.getAckReasonCode() : AckReasonCode.NOT_AUTHORIZED; reasonString = output.getReasonString() != null ? output.getReasonString() : getReasonString(connect); break; case UNDECIDED: if (!output.isAuthorizerPresent()) { //providers never returned an authorizer, same as continue break; } reasonCode = AckReasonCode.NOT_AUTHORIZED; reasonString = getReasonString(connect); break; case SUCCESS: reasonCode = AckReasonCode.SUCCESS; break; case CONTINUE: break; default: //no state left throw new IllegalStateException("Unknown type"); }  final PublishAuthorizerResult result = new PublishAuthorizerResult(reasonCode, reasonString, output.isAuthorizerPresent(), disconnectReasonCode); ctx.pipeline().fireUserEventTriggered(new PluginAuthorizerServiceImpl.AuthorizeWillResultEvent(connect, result)); }
[*] target: assertNotNull(resultEvent)
[-] pred: org. junit. Assert. assertNotNull ( resultEvent )
************************************
************************************
[+] input: generate_columnDefConstraintState_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "tb.col varchar2(64) constraint abcd not null rely using index global storing(a,b) enable novalidate")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); ConstraintState state = new ConstraintState(); state.setRely(true); state.setUsingIndexFlag(true); IndexOptions indexOptions = new IndexOptions(); indexOptions .setStoring(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); indexOptions.setGlobal(true); state.setIndexOptions(indexOptions); state.setEnable(true); state.setValidate(false); InLineConstraint attribute = new InLineConstraint("abcd", state); attribute.setNullable(false); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: test_Operate_Number() { boolean contains = EventParseUtil.validate(1234567, "contains", 123); Assert."<AssertPlaceHolder>"; }
validate(Object root, String operation, Object value) { if (root.getClass().isArray()) { String json = JsonUtils.toJson(root); root = JsonUtils.fromJsonList(json, String.class); } String assertStr = "'" + root.toString() + "'." + operation + "('" + value.toString() + "')"; Object result = PARSER.parseExpression(assertStr).getValue(); if (Objects.isNull(result)) { throw new UnexpectedException(String.format("Validate condition failed, assertStr=%s", assertStr)); } return (boolean) result; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
************************************
[+] input: generate_lnnvl_generateSucceed() { PredicateContext context = getPredicateContext("lnnvl(col = '12')"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("lnnvl", Collections.singletonList( new ExpressionParam(new CompoundExpression(new RelationReference("col", null), new ConstExpression("'12'"), Operator.EQ)))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_countKeep_generateSucceed() { Bit_exprContext context = getBitExprContext("count(all *) keep (DENSE_RANK first order by col desc) "); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("*"))); FunctionCall expect = new FunctionCall("count", params); SortKey s0 = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.setKeep(new KeepClause("first", new OrderBy(Collections.singletonList(s0)))); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: test_Operate_Regex() { boolean contains = EventParseUtil.validate("Hello world!", "matches", "Hello.*"); Assert."<AssertPlaceHolder>"; }
validate(Object root, String operation, Object value) { if (root.getClass().isArray()) { String json = JsonUtils.toJson(root); root = JsonUtils.fromJsonList(json, String.class); } String assertStr = "'" + root.toString() + "'." + operation + "('" + value.toString() + "')"; Object result = PARSER.parseExpression(assertStr).getValue(); if (Objects.isNull(result)) { throw new UnexpectedException(String.format("Validate condition failed, assertStr=%s", assertStr)); } return (boolean) result; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
************************************
[+] input: getConfigContext() { ConfigResponse configResponse = new ConfigResponse(); IConfigContext configContext = configResponse.getConfigContext(); Assert."<AssertPlaceHolder>"; }
getConfigContext() { return configContext; }
[*] target: assertNotNull(configContext)
[-] pred: org. junit. Assert. assertNotNull ( configContext )
************************************
************************************
[+] input: generate_updateAssignmentUseDefault_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=DEFAULT, col2=1"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), null, true), new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col2")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testCopartitioning() { final Random rand = new Random(); @SuppressWarnings("deprecation") final org.apache.kafka.clients.producer.internals.DefaultPartitioner defaultPartitioner = new org.apache.kafka.clients.producer.internals.DefaultPartitioner(); final WindowedSerializer<Integer> timeWindowedSerializer = new TimeWindowedSerializer<>(intSerializer); final WindowedStreamPartitioner<Integer, String> streamPartitioner = new WindowedStreamPartitioner<>(timeWindowedSerializer);  for (int k = 0; k < 10; k++) { final Integer key = rand.nextInt(); final byte[] keyBytes = intSerializer.serialize(topicName, key);  final String value = key.toString(); final byte[] valueBytes = stringSerializer.serialize(topicName, value);  final Integer expected = defaultPartitioner.partition("topic", key, keyBytes, value, valueBytes, cluster);  for (int w = 1; w < 10; w++) { final TimeWindow window = new TimeWindow(10 * w, 20 * w);  final Windowed<Integer> windowedKey = new Windowed<>(key, window); @SuppressWarnings("deprecation") final Integer actual = streamPartitioner.partition(topicName, windowedKey, value, infos.size());  "<AssertPlaceHolder>"; } }  defaultPartitioner.close(); }
partition(final String topic, final Windowed<K> windowedKey, final V value, final int numPartitions) { // for windowed key, the key bytes should never be null final byte[] keyBytes = serializer.serializeBaseKey(topic, windowedKey);  // stick with the same built-in partitioner util functions that producer used // to make sure its behavior is consistent with the producer return BuiltInPartitioner.partitionForKey(keyBytes, numPartitions); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testFilter() { Mockito.when(authConfigs.isAuthEnabled()).thenReturn(true);  Request healthCheckRequest = new HealthCheckRequest();  try { Response healthCheckResponse = remoteRequestAuthFilter .filter(healthCheckRequest, new RequestMeta(), MockRequestHandler.class); Assert."<AssertPlaceHolder>"; } catch (NacosException e) { e.printStackTrace(); Assert.fail(e.getMessage()); } }
filter(Request request, RequestMeta meta, Class handlerClazz) throws NacosException {  try {  Method method = getHandleMethod(handlerClazz); if (method.isAnnotationPresent(Secured.class) && authConfigs.isAuthEnabled()) {  if (Loggers.AUTH.isDebugEnabled()) { Loggers.AUTH.debug("auth start, request: {}", request.getClass().getSimpleName()); }  Secured secured = method.getAnnotation(Secured.class); if (!protocolAuthService.enableAuth(secured)) { return null; } String clientIp = meta.getClientIp(); request.putHeader(Constants.Identity.X_REAL_IP, clientIp); Resource resource = protocolAuthService.parseResource(request, secured); IdentityContext identityContext = protocolAuthService.parseIdentity(request); boolean result = protocolAuthService.validateIdentity(identityContext, resource); if (!result) { // TODO Get reason of failure throw new AccessException("Validate Identity failed."); } String action = secured.action().toString(); result = protocolAuthService.validateAuthority(identityContext, new Permission(resource, action)); if (!result) { // TODO Get reason of failure throw new AccessException("Validate Authority failed."); } } } catch (AccessException e) { if (Loggers.AUTH.isDebugEnabled()) { Loggers.AUTH.debug("access denied, request: {}, reason: {}", request.getClass().getSimpleName(), e.getErrMsg()); } Response defaultResponseInstance = getDefaultResponseInstance(handlerClazz); defaultResponseInstance.setErrorInfo(NacosException.NO_RIGHT, e.getErrMsg()); return defaultResponseInstance; } catch (Exception e) { Response defaultResponseInstance = getDefaultResponseInstance(handlerClazz);  defaultResponseInstance.setErrorInfo(NacosException.SERVER_ERROR, ExceptionUtil.getAllExceptionMsg(e)); return defaultResponseInstance; }  return null; }
[*] target: assertNull(healthCheckResponse)
[-] pred: org. junit. Assert. assertNull ( healthCheckResponse )
************************************
************************************
[+] input: testBatchPublishAggrSuccess() {  String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; //mock query datumId and equal with current content param. when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, "d1"}), eq(String.class))).thenReturn("c1"); when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, "d2"}), eq(String.class))).thenReturn("c2"); when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, "d3"}), eq(String.class))).thenReturn("c3"); Map<String, String> datumMap = new HashMap<>(); datumMap.put("d1", "c1"); datumMap.put("d2", "c2"); datumMap.put("d3", "c3"); String appName = "appname1234"; boolean result = externalConfigInfoAggrPersistService.batchPublishAggr(dataId, group, tenant, datumMap, appName); Assert."<AssertPlaceHolder>"; }
batchPublishAggr(final String dataId, final String group, final String tenant, final Map<String, String> datumMap, final String appName) { try { Boolean isPublishOk = tjt.execute(status -> { for (Map.Entry<String, String> entry : datumMap.entrySet()) { try { if (!addAggrConfigInfo(dataId, group, tenant, entry.getKey(), appName, entry.getValue())) { throw new TransactionSystemException("error in batchPublishAggr"); } } catch (Throwable e) { throw new TransactionSystemException("error in batchPublishAggr"); } } return Boolean.TRUE; }); if (isPublishOk == null) { return false; } return isPublishOk; } catch (TransactionException e) { LogUtil.FATAL_LOG.error("[db-error] " + e, e); return false; } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: parserAnonymousBlock_callProcedure_3_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_4, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("IN_PARAM"); int actual = procedureCall.getCallLine(); int expect = 4; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetSubscribedService() { Collection<Service> subscribedService = clientServiceIndexesManager.getSubscribedService();  Assert."<AssertPlaceHolder>"; Assert.assertEquals(subscribedService.size(), 1); }
getSubscribedService() { return subscriberIndexes.keySet(); }
[*] target: assertNotNull(subscribedService)
[-] pred: org. junit. Assert. assertNotNull ( subscribedService )
************************************
************************************
[+] input: test_AES256_BASE64() { String raw = RandomStringUtils.random(256); Encryption encryption = createEncryption(EncryptionAlgorithm.AES256_BASE64); String encrypted = EncryptionUtil.encrypt(raw, encryption); Assert.assertNotEquals(raw, encrypted); String decrypted = EncryptionUtil.decrypt(encrypted, encryption); Assert."<AssertPlaceHolder>"; }
decrypt(String encryptedText, Encryption encryption) { return Objects.requireNonNull(encryptorCache.get(encryption)).decrypt(encryptedText); }
[*] target: assertEquals(raw, decrypted)
[-] pred: org. junit. Assert. assertEquals ( raw, decrypted )
************************************
************************************
[+] input: listTypes_Success() { List<DBPLObjectIdentity> types = accessor.listTypes(getOracleSchema()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, types.size()); }
listTypes(String schemaName) { OracleSqlBuilder sb = new OracleSqlBuilder();  sb.append("select OBJECT_NAME as name, STATUS, OBJECT_TYPE as type, OWNER as schema_name from "); sb.append(dataDictTableNames.OBJECTS()); sb.append(" where OBJECT_TYPE='TYPE' and OWNER="); sb.value(schemaName); sb.append(" order by OBJECT_NAME asc");  List<DBPLObjectIdentity> types = jdbcOperations.query(sb.toString(), new BeanPropertyRowMapper<>(DBPLObjectIdentity.class));  return fillTypeErrorMessage(types, schemaName); }
[*] target: assertNotNull(types)
[-] pred: org. junit. Assert. assertNotNull ( types )
************************************
************************************
[+] input: testPrefixAndBeanNameConnectUseLine() { JoinAliasGenerator generator = new HyphenAliasGenerator(); Map<String, String> table = new HashMap<>(); table.put("users", "users-bean"); table.put("spring.users", "springUsers-bean"); table.put("spring.users.zhangsan", "springUsersZhangsan-bean");  table.forEach((key, value) -> { String alias = generator.generateAlias(key, beanName, clazz); "<AssertPlaceHolder>"; });  }
generateAlias(String prefix, String beanName, Class<?> configClass);
[*] target: assertEquals(value, alias)
[-] pred: org. junit. Assert. assertEquals ( value, alias )
************************************
************************************
[+] input: testDuplicateInserts() { DependencyFlowNodesDao.instance.getMCollection().drop();  DependencyFlowNodesDao.instance.createIndicesIfAbsent(); Node node = new Node("0", "url", "GET", new HashMap<>()); DependencyFlowNodesDao.instance.insertOne(node);  boolean erroredOut = false; node.getConnections().put("param", new Connection("param", Collections.singletonList(new Edge("0", "url_new", "POST", "param_new", false,20, 0)), false, false)); try { DependencyFlowNodesDao.instance.insertOne(node); } catch (Exception e) { erroredOut = true; }  "<AssertPlaceHolder>"; }
createIndicesIfAbsent() { boolean exists = false; for (String col: clients[0].getDatabase(Context.accountId.get()+"").listCollectionNames()){ if (getCollName().equalsIgnoreCase(col)){ exists = true; break; } };  if (!exists) { clients[0].getDatabase(Context.accountId.get()+"").createCollection(getCollName()); }  String[] fieldNames = {Node._API_COLLECTION_ID, Node._URL, Node._METHOD}; MCollection.createUniqueIndex(getDBName(), getCollName(), fieldNames, true);  fieldNames = new String[]{Node._API_COLLECTION_ID, Node._MAX_DEPTH}; MCollection.createIndexIfAbsent(getDBName(), getCollName(), fieldNames, true); }
[*] target: assertTrue(erroredOut)
[-] pred: org. junit. Assert. assertTrue ( erroredOut )
************************************
************************************
[+] input: IOException { PageManager pageManager = getPageManager(5); List<Page> pages = pageManager.create(13); List<Page> readPages = pageManager.get(pages.stream().map(Page::getPhysicalPageId).collect(Collectors.toList())); Assert."<AssertPlaceHolder>"; }
size() { return this.maxPageCountInMem - this.pageCountSemaphore.availablePermits(); }
[*] target: assertEquals(pages.size(), readPages.size())
[-] pred: org. junit. Assert. assertEquals ( pages. size ( ), readPages. size ( ) )
************************************
************************************
[+] input: copy_changes() { final SubscribePacketImpl packet = new SubscribePacketImpl( ImmutableList.of(new SubscriptionImpl("topic", Qos.AT_LEAST_ONCE, RetainHandling.SEND, false, false)), UserPropertiesImpl.of(ImmutableList.of()), 1, 1); final ModifiableSubscribePacketImpl modifiablePacket = new ModifiableSubscribePacketImpl(packet, configurationService);  modifiablePacket.getSubscriptions().get(0).setTopicFilter("test"); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final SubscribePacketImpl copy = modifiablePacket.copy();  final SubscribePacketImpl expectedPacket = new SubscribePacketImpl( ImmutableList.of(new SubscriptionImpl("test", Qos.AT_LEAST_ONCE, RetainHandling.SEND, false, false)), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue"))), 1, 1); "<AssertPlaceHolder>"; }
copy() { final ImmutableList.Builder<SubscriptionImpl> builder = ImmutableList.builder(); subscriptions.forEach(subscription -> builder.add(subscription.copy())); return new SubscribePacketImpl( builder.build(), userProperties.copy(), subscriptionIdentifier, packetIdentifier); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred: org. junit. Assert. assertEquals ( expectedPacket, copy )
************************************
************************************
[+] input: generate_withNamedWindow_generateSelectSucceed() { Select_stmtContext context = getSelectContext( "select col.* abc from dual window name_w as (name_spec_1 partition by 1,2,3 order by col desc rows interval 1 day FOLLOWING), name_w2 as (range 1 PRECEDING)"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); SelectBody selectBody = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); WindowSpec s1 = new WindowSpec(); s1.setName("name_spec_1"); s1.getPartitionBy().add(new ConstExpression("1")); s1.getPartitionBy().add(new ConstExpression("2")); s1.getPartitionBy().add(new ConstExpression("3")); SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); s1.setOrderBy(new OrderBy(Collections.singletonList(sortKey))); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("1"), "day")); WindowBody windowBody = new WindowBody(WindowType.ROWS, offset); s1.setBody(windowBody); Window w1 = new Window("name_w", s1);  WindowSpec s2 = new WindowSpec(); offset = new WindowOffset(WindowOffsetType.PRECEDING); offset.setInterval(new ConstExpression("1")); windowBody = new WindowBody(WindowType.RANGE, offset); s2.setBody(windowBody); Window w2 = new Window("name_w2", s2); selectBody.getWindows().add(w1); selectBody.getWindows().add(w2); Select expect = new Select(selectBody); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_withColumnGroup_allColumns_eachColumn_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns, each column)"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_orderByNullsFirst_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select 1 from dual order by col asc nulls first"); StatementFactory<OrderBy> factory = new OracleOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new RelationReference("col", null), SortDirection.ASC, SortNullPosition.FIRST); OrderBy expect = new OrderBy(false, Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_onlyColumnDefExists_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: parserAnonymousBlock_callProcedure_2_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_3, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("PL_TEST_2"); int actual = procedureCall.getCallLine(); int expect = 9; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_rowExprList_generateSucceed() { ExprContext context = getExprContext("row(12,13,14)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); params.add(new ExpressionParam(new ConstExpression("13"))); params.add(new ExpressionParam(new ConstExpression("14"))); FunctionCall expect = new FunctionCall("row", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetValuesWithPrefixNotFound() { List<String> result = tree.getValuesWithPrefix("cheese"); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: generate_xmlagg_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("xmlagg(1 order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("xmlagg", Collections.singletonList( new ExpressionParam(new ConstExpression("1")))); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.addOption(new OrderBy(Collections.singletonList(s))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_parallel_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) parallel 12, noparallel"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: createContainerMethodAnnotationProcessor() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); ContainerMethodAnnotationProcessor processor = ConfigurationUtil.createContainerMethodAnnotationProcessor(configuration); Assert."<AssertPlaceHolder>"; }
createContainerMethodAnnotationProcessor(Crane4jGlobalConfiguration configuration) { MethodInvokerContainerCreator methodInvokerContainerCreator = createMethodInvokerContainerCreator(configuration); AnnotationFinder annotationFinder = SimpleAnnotationFinder.INSTANCE; DefaultMethodContainerFactory factory = new DefaultMethodContainerFactory(methodInvokerContainerCreator, annotationFinder); List<MethodContainerFactory> methodContainerFactories = CollectionUtils.newCollection(ArrayList::new, factory); return new ContainerMethodAnnotationProcessor(methodContainerFactories, annotationFinder); }
[*] target: assertNotNull(processor)
[-] pred: org. junit. Assert. assertNotNull ( processor )
************************************
************************************
[+] input: testDeleteQuietly_Exists_ReturnTrue() { MultipartFile mockFile = new MockMultipartFile("some-file", "some-file", null, new byte[10]); localFileOperator.saveLocalFile(BUCKET, mockFile.getOriginalFilename(), mockFile.getSize(), mockFile.getInputStream());  boolean result = localFileOperator.deleteLocalFile(BUCKET, "some-file"); Assert."<AssertPlaceHolder>"; }
deleteLocalFile(String bucketName, String objectId) { Verify.notEmpty(bucketName, "bucketName"); Verify.notEmpty(objectId, "objectId"); String absolutePath = absolutePathName(bucketName, objectId); PreConditions.validNoPathTraversal(generateFilePath(bucketName, objectId), generateFilePath(bucketName)); File localFile = new File(absolutePath); return deleteFileQuietly(localFile); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testTaskOps() { List<TaskModel> tasks = new LinkedList<>(); String workflowId = UUID.randomUUID().toString();  for (int i = 0; i < 3; i++) { TaskModel task = new TaskModel(); task.setScheduledTime(1L); task.setSeq(1); task.setTaskId(workflowId + "_t" + i); task.setReferenceTaskName("testTaskOps" + i); task.setRetryCount(0); task.setWorkflowInstanceId(workflowId); task.setTaskDefName("testTaskOps" + i); task.setStatus(TaskModel.Status.IN_PROGRESS); tasks.add(task); }  for (int i = 0; i < 3; i++) { TaskModel task = new TaskModel(); task.setScheduledTime(1L); task.setSeq(1); task.setTaskId("x" + workflowId + "_t" + i); task.setReferenceTaskName("testTaskOps" + i); task.setRetryCount(0); task.setWorkflowInstanceId("x" + workflowId); task.setTaskDefName("testTaskOps" + i); task.setStatus(TaskModel.Status.IN_PROGRESS); getExecutionDAO().createTasks(Collections.singletonList(task)); }  List<TaskModel> created = getExecutionDAO().createTasks(tasks); assertEquals(tasks.size(), created.size());  List<TaskModel> pending = getExecutionDAO().getPendingTasksForTaskType(tasks.get(0).getTaskDefName()); assertNotNull(pending); assertEquals(2, pending.size()); // Pending list can come in any order.  finding the one we are looking for and then // comparing TaskModel matching = pending.stream() .filter(task -> task.getTaskId().equals(tasks.get(0).getTaskId())) .findAny() .get(); assertTrue(EqualsBuilder.reflectionEquals(matching, tasks.get(0)));  for (int i = 0; i < 3; i++) { TaskModel found = getExecutionDAO().getTask(workflowId + "_t" + i); assertNotNull(found); found.getOutputData().put("updated", true); found.setStatus(TaskModel.Status.COMPLETED); getExecutionDAO().updateTask(found); }  List<String> taskIds = tasks.stream().map(TaskModel::getTaskId).collect(Collectors.toList()); List<TaskModel> found = getExecutionDAO().getTasks(taskIds); assertEquals(taskIds.size(), found.size()); found.forEach( task -> { assertTrue(task.getOutputData().containsKey("updated")); assertEquals(true, task.getOutputData().get("updated")); boolean removed = getExecutionDAO().removeTask(task.getTaskId()); assertTrue(removed); });  found = getExecutionDAO().getTasks(taskIds); "<AssertPlaceHolder>"; }
getTasks(List<String> taskIds);
[*] target: assertTrue(found.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( found. isEmpty ( ) )
************************************
************************************
[+] input: generate_withCycle_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name (col1, col2) as (select * from dual) search breadth first by col2 desc, col3 asc set varname cycle col2,col3 set cyclename to 'abcd' default '1234' select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); expect.setSearchMode(SearchMode.BREADTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); expect.setCycleAliasList(Arrays.asList("col2", "col3")); expect.setCycleValueSet(new SetValue("cyclename", "'abcd'", "'1234'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_WMSYS_Dot_WM_CONCATWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "WMSYS.WM_CONCAT(1) keep (DENSE_RANK first order by col asc) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); FunctionCall expect = new FunctionCall("WMSYS.WM_CONCAT", params); SortKey s0 = new SortKey(new RelationReference("col", null), SortDirection.ASC); expect.setKeep(new KeepClause("first", new OrderBy(Collections.singletonList(s0)))); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost"); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>"; }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (identityContext.getAllKey().contains(NacosAuthLoginConstant.ACCESSTOKEN)) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred: org. junit. Assert. assertTrue ( ret )
************************************
************************************
[+] input: generate_modifyRangePartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("partition by range(a) subpartition by range columns (c,b) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue engine=InnoDB)," + "partition d values less than (+3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); se2.setPartitionOptions(o); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Arrays.asList(new ColumnReference(null, null, "c"), new ColumnReference(null, null, "b")), "range columns"); expect.setModifyPartition(new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: attempt_FirstSuccess_ReturnSuccess() { FailedLoginAttemptLimiter limiter = new FailedLoginAttemptLimiter(1, 1000L);  Boolean result = limiter.attempt(() -> true);  Assert."<AssertPlaceHolder>"; }
attempt(Supplier<Boolean> attemptResultSupplier) { long currentTimeMillis = System.currentTimeMillis(); if (isLocked && (currentTimeMillis > lastLockedMills + lockTimeoutMillis || lockTimeoutMillis <= 0)) { isLocked = false; failedAttempt = 0; } if (isLocked) { long remainSeconds = (lastLockedMills + lockTimeoutMillis - currentTimeMillis) / 1000L; throw new AttemptLoginOverLimitException((double) maxFailedAttempt, remainSeconds, String.format("failed attempt over limit, failedAttempt=%d, limit=%d, remainSeconds=%d", failedAttempt, maxFailedAttempt, remainSeconds)); } Boolean result = null; try { result = attemptResultSupplier.get(); return result; } finally { if (result == null || !result) { log.info("attempt failed, currentFailedAttempt={}", failedAttempt); failedAttempt++; if (failedAttempt >= maxFailedAttempt) { isLocked = true; lastLockedMills = currentTimeMillis; } } } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: IllegalAccessException { HttpClientFactory factory = new AbstractApacheHttpClientFactory() { @Override protected HttpClientConfig buildHttpClientConfig() { return HttpClientConfig.builder().build(); }  @Override protected Logger assignLogger() { return logger; } }; NacosRestTemplate template = factory.createNacosRestTemplate(); "<AssertPlaceHolder>"; Field field = NacosRestTemplate.class.getDeclaredField("requestClient"); field.setAccessible(true); HttpClientRequest requestClient = (HttpClientRequest) field.get(template); assertTrue(requestClient instanceof DefaultHttpClientRequest); }
createNacosRestTemplate() { final HttpClientConfig originalRequestConfig = buildHttpClientConfig(); final RequestConfig defaultConfig = getRequestConfig(); return new NacosRestTemplate(assignLogger(), new DefaultHttpClientRequest( HttpClients.custom() .addInterceptorLast(new RequestContent(true)) .setDefaultRequestConfig(defaultConfig) .setUserAgent(originalRequestConfig.getUserAgent()) .setMaxConnTotal(originalRequestConfig.getMaxConnTotal()) .setMaxConnPerRoute(originalRequestConfig.getMaxConnPerRoute()) .setConnectionTimeToLive(originalRequestConfig.getConnTimeToLive(), originalRequestConfig.getConnTimeToLiveTimeUnit()).build(), defaultConfig)); }
[*] target: assertNotNull(template)
[-] pred: org. junit. Assert. assertNotNull ( template )
************************************
************************************
[+] input: generate_countStarNameWin_generateSucceed() { Bit_exprContext context = getBitExprContext("count(all *) over name_ob"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("*"))); FunctionCall expect = new FunctionCall("count", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); expect.setWindow(window); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_functionNameExprAsList_generateFunctionCallSucceed() { ExprContext context = getExprContext("function_name(tab.col as new_label)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); ExpressionParam p = new ExpressionParam(new ColumnReference(null, "tab", "col")); p.addOption(new ConstExpression("new_label")); params.add(p); FunctionCall expect = new FunctionCall("function_name", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldNotCheckpointOffsetsOnCommitIfEosIsEnabled() { task = createStatefulTask(createConfig(StreamsConfig.EXACTLY_ONCE_V2, "100"), true);  task.initializeIfNeeded(); task.completeRestoration(noOpResetter -> { }); task.prepareCommit(); task.postCommit(false); final File checkpointFile = new File( stateDirectory.getOrCreateDirectoryForTask(taskId), StateManagerUtil.CHECKPOINT_FILE_NAME );  "<AssertPlaceHolder>"; }
postCommit(final boolean enforceCheckpoint) { switch (state()) { case CREATED: // We should never write a checkpoint for a CREATED task as we may overwrite an existing checkpoint // with empty uninitialized offsets log.debug("Skipped writing checkpoint for {} task", state());  break;  case RESTORING: case SUSPENDED: maybeCheckpoint(enforceCheckpoint); log.debug("Finalized commit for {} task with enforce checkpoint {}", state(), enforceCheckpoint);  break;  case RUNNING: if (enforceCheckpoint || !eosEnabled) { maybeCheckpoint(enforceCheckpoint); } log.debug("Finalized commit for {} task with eos {} enforce checkpoint {}", state(), eosEnabled, enforceCheckpoint);  break;  case CLOSED: throw new IllegalStateException("Illegal state " + state() + " while post committing active task " + id);  default: throw new IllegalStateException("Unknown state " + state() + " while post committing active task " + id); }  clearCommitStatuses(); }
[*] target: assertFalse(checkpointFile.exists())
[-] pred: org. junit. Assert. assertFalse ( checkpointFile. exists ( ) )
************************************
************************************
[+] input: isODPSharding_ODP_SHARDING_OB_MYSQL_ReturnTrue() { boolean isODPSharding = ConnectType.ODP_SHARDING_OB_MYSQL.isODPSharding(); Assert."<AssertPlaceHolder>"; }
isODPSharding() { return this == ODP_SHARDING_OB_MYSQL || this == ODP_SHARDING_OB_ORACLE; }
[*] target: assertTrue(isODPSharding)
[-] pred: org. junit. Assert. assertTrue ( isODPSharding )
************************************
************************************
[+] input: generate_relationRelationKeyword_generateSucceed() { ExprContext context = getExprContext("chz.tab.BEFORE"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference("chz", "tab", "BEFORE"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testBatchPublishAggrSuccess() {  String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; //mock query datumId and equal with current content param. Mockito.when( databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, "d1"}), eq(String.class))) .thenReturn("c1"); Mockito.when( databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, "d2"}), eq(String.class))) .thenReturn("c2"); Mockito.when( databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, "d3"}), eq(String.class))) .thenReturn("c3"); Mockito.when(databaseOperate.update(any(List.class))).thenReturn(true);  Map<String, String> datumMap = new HashMap<>(); datumMap.put("d1", "c1"); datumMap.put("d2", "c2"); datumMap.put("d3", "c3"); String appName = "appname1234"; boolean result = embededConfigInfoAggrPersistService.batchPublishAggr(dataId, group, tenant, datumMap, appName); Assert."<AssertPlaceHolder>"; }
batchPublishAggr(final String dataId, final String group, final String tenant, final Map<String, String> datumMap, final String appName) { try { Boolean isPublishOk = false; for (Map.Entry<String, String> entry : datumMap.entrySet()) { addAggrConfigInfo(dataId, group, tenant, entry.getKey(), appName, entry.getValue()); }  isPublishOk = databaseOperate.update(EmbeddedStorageContextHolder.getCurrentSqlContext());  if (isPublishOk == null) { return false; } return isPublishOk; } finally { EmbeddedStorageContextHolder.cleanAllContext(); } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { String[] lines = { "command=fetch\n", "server-option=one\n", "server-option=two\n", PacketLineIn.delimiter(), PacketLineIn.end() };  TestV2Hook testHook = new TestV2Hook(); uploadPackSetup(TransferConfig.ProtocolVersion.V2.version(), (UploadPack up) -> { up.setProtocolV2Hook(testHook); }, lines);  FetchV2Request req = testHook.fetchRequest; "<AssertPlaceHolder>"; assertEquals(2, req.getServerOptions().size()); assertThat(req.getServerOptions(), hasItems("one", "two")); }
setProtocolV2Hook(@Nullable ProtocolV2Hook hook) { this.protocolV2Hook = hook != null ? hook : ProtocolV2Hook.DEFAULT; }
[*] target: assertNotNull(req)
[-] pred: org. junit. Assert. assertNotNull ( req )
************************************
************************************
[+] input: split_splitBySlashAndContainsMultiComment_splitSucceed() { List<String> sqls = new ArrayList<>(); sqls.add("CREATE\n" + "OR REPLACE PACKAGE BODY BASE_ACCESS_CONTROL_PKG IS\n" + "/* $Header:  BASE_ACCESS_CONTROL_PKG.bdy 3.1.0 2016/10/1 18:48:48 Midea ship $ */\n" + "BEGIN\n" + "    DBMS_OUTPUT.PUT_LINE('a');\n" + "END;\n"); sqls.add("select 1+3 from dual"); SqlCommentProcessor processor = new SqlCommentProcessor(DialectType.OB_ORACLE, true, true); processor.setDelimiter("/"); StringBuffer buffer = new StringBuffer(); List<String> actual = processor.split(buffer, String.join("/", sqls) + "/").stream().map(OffsetString::getStr).collect( Collectors.toList()); Assert."<AssertPlaceHolder>"; }
setDelimiter(String delimiter) { this.delimiter = delimiter; }
[*] target: assertEquals(sqls, actual)
[-] pred: org. junit. Assert. assertEquals ( sqls, actual )
************************************
************************************
[+] input: generate_valuesStatementUnion_generateSelectSucceed() { String sql = "values row(1, '2'), row(2, '3') union values row(1, '2')"; Select_stmtContext context = getSelectContext(sql); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); values.add(Arrays.asList(new ConstExpression("2"), new ConstExpression("'3'"))); SelectBody body = new SelectBody(values);  values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); SelectBody second = new SelectBody(values); body.setRelatedSelect(new RelatedSelectBody(second, RelationType.UNION)); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_rangePartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by range(a,b) (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress," + "partition values less than (func(1,2)) id 15 tablespace tbs)")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement(null, Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); RangePartition expect = new RangePartition(cols, Arrays.asList(e1, e2, e3), null, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_columnProjectionWithLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col label from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new RelationReference("col", null), "label"); Assert."<AssertPlaceHolder>"; }
generate() { return visitProjection(projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetSuccessfulSyncCount() { long expected = DistroRecordsHolder.getInstance().getSuccessfulSyncCount() + 1; DistroRecordsHolder.getInstance().getRecord("testGetSuccessfulSyncCount").syncSuccess(); "<AssertPlaceHolder>"; }
getSuccessfulSyncCount() { final AtomicLong result = new AtomicLong(); distroRecords.forEach((s, distroRecord) -> result.addAndGet(distroRecord.getSuccessfulSyncCount())); return result.get(); }
[*] target: assertEquals(expected, DistroRecordsHolder.getInstance().getSuccessfulSyncCount())
[-] pred: org. junit. Assert. assertEquals ( expected, DistroRecordsHolder.getInstance ( ). getSuccessfulSyncCount ( ) )
************************************
************************************
[+] input: generate_alterConstraintNotEnforced_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter constraint abcd not enforced")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ConstraintState state = new ConstraintState(); state.setEnforced(false); expect.modifyConstraint("abcd", state); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldOptimizeActiveTasks() { final Map<Subtopology, Set<TaskId>> tasksForTopicGroup = mkMap( mkEntry(new Subtopology(0, null), mkSet(TASK_0_0, TASK_0_1)), mkEntry(new Subtopology(1, null), mkSet(TASK_1_0, TASK_1_1)) ); final RackAwareTaskAssignor assignor = new RackAwareTaskAssignor( getClusterForAllTopics(), getTaskTopicPartitionMapForAllTasks(), mkMap(), tasksForTopicGroup, getProcessRacksForAllProcess(), mockInternalTopicManager, getRackAwareEnabledConfig(), time );  final ClientState clientState1 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1); final ClientState clientState2 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1); final ClientState clientState3 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1);  clientState1.assignActiveTasks(mkSet(TASK_0_1, TASK_1_1)); clientState2.assignActive(TASK_1_0); clientState3.assignActive(TASK_0_0);  // task_0_0 has same rack as UUID_1 // task_0_1 has same rack as UUID_2 and UUID_3 // task_1_0 has same rack as UUID_1 and UUID_3 // task_1_1 has same rack as UUID_2 // Optimal assignment is UUID_1: {0_0, 1_0}, UUID_2: {1_1}, UUID_3: {0_1} which result in no cross rack traffic final SortedMap<UUID, ClientState> clientStateMap = new TreeMap<>(mkMap( mkEntry(UUID_1, clientState1), mkEntry(UUID_2, clientState2), mkEntry(UUID_3, clientState3) )); final SortedSet<TaskId> taskIds = mkSortedSet(TASK_0_0, TASK_0_1, TASK_1_0, TASK_1_1);  assertTrue(assignor.canEnableRackAwareAssignor()); int expected = stateful ? 40 : 4; final long originalCost = assignor.activeTasksCost(taskIds, clientStateMap, trafficCost, nonOverlapCost); assertEquals(expected, originalCost);  expected = stateful ? 4 : 0; final long cost = assignor.optimizeActiveTasks(taskIds, clientStateMap, trafficCost, nonOverlapCost); "<AssertPlaceHolder>";  assertEquals(mkSet(TASK_0_0, TASK_1_0), clientState1.activeTasks()); assertEquals(mkSet(TASK_1_1), clientState2.activeTasks()); assertEquals(mkSet(TASK_0_1), clientState3.activeTasks()); }
optimizeActiveTasks(final SortedSet<TaskId> activeTasks, final SortedMap<UUID, ClientState> clientStates, final int trafficCost, final int nonOverlapCost) { if (activeTasks.isEmpty()) { return 0; }  log.info("Assignment before active task optimization is {}\n with cost {}", clientStates, activeTasksCost(activeTasks, clientStates, trafficCost, nonOverlapCost));  final long startTime = time.milliseconds(); final List<UUID> clientList = new ArrayList<>(clientStates.keySet()); final List<TaskId> taskIdList = new ArrayList<>(activeTasks); final Map<TaskId, UUID> taskClientMap = new HashMap<>(); final Map<UUID, Integer> originalAssignedTaskNumber = new HashMap<>(); final RackAwareGraphConstructor<ClientState> graphConstructor = RackAwareGraphConstructorFactory.create(assignmentConfigs, tasksForTopicGroup); final Graph<Integer> graph = graphConstructor.constructTaskGraph( clientList, taskIdList, clientStates, taskClientMap, originalAssignedTaskNumber, ClientState::hasActiveTask, this::getCost, trafficCost, nonOverlapCost, false, false );  graph.solveMinCostFlow(); final long cost = graph.totalCost();  graphConstructor.assignTaskFromMinCostFlow(graph, clientList, taskIdList, clientStates, originalAssignedTaskNumber, taskClientMap, ClientState::assignActive, ClientState::unassignActive, ClientState::hasActiveTask);  final long duration = time.milliseconds() - startTime; log.info("Assignment after {} milliseconds for active task optimization is {}\n with cost {}", duration, clientStates, cost); return cost; }
[*] target: assertEquals(expected, cost)
[-] pred: org. junit. Assert. assertEquals ( expected, cost )
************************************
************************************
[+] input: generate_updateWithTableReferences_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE chz.t1, chz.t2 PARTITION(p2, p2) SET t1.c2 = 100, t2.c2 = 200"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference1 = new NameReference("chz", "t1", null); NameReference nameReference2 = new NameReference("chz", "t2", null); nameReference2.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p2", "p2"))); Update expect = new Update(Arrays.asList(nameReference1, nameReference2), Arrays.asList( new UpdateAssign( Arrays.asList(new ColumnReference(null, "t1", "c2")), new ConstExpression("100"), false), new UpdateAssign( Arrays.asList(new ColumnReference(null, "t2", "c2")), new ConstExpression("200"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: get() { RecyclebinSettings settings = recyclebinSettingsService.get(session); Assert."<AssertPlaceHolder>"; }
get(@NonNull ConnectionSession connectionSession) { List<OdcDBVariable> variables = variablesService.list(connectionSession, SETTINGS_SCOPE); Map<String, OdcDBVariable> key2Variable = variables.stream().collect(Collectors.toMap(OdcDBVariable::getKey, t -> t)); RecyclebinSettings settings = new RecyclebinSettings(); if (key2Variable.containsKey(RECYCLEBIN_ENABLED_VARIABLE)) { settings.setRecyclebinEnabled(StringUtils.equalsIgnoreCase(ENABLED_VALUE, key2Variable.get(RECYCLEBIN_ENABLED_VARIABLE).getValue())); } if (key2Variable.containsKey(TRUNCATE_FLASHBACK_ENABLED_VARIABLE)) { settings.setTruncateFlashbackEnabled(StringUtils.equalsIgnoreCase(ENABLED_VALUE, key2Variable.get(TRUNCATE_FLASHBACK_ENABLED_VARIABLE).getValue())); } settings.setObjectExpireTime(getExpireTime(connectionSession)); return settings; }
[*] target: assertNotNull(settings)
[-] pred: org. junit. Assert. assertNotNull ( settings )
************************************
************************************
[+] input: IOException { final String newRef = "refs/heads/abc"; final RefUpdate ru = updateRef(newRef); final SubclassedId newid = new SubclassedId(ru.getNewObjectId()); ru.setNewObjectId(newid); Result update = ru.update(); assertEquals(Result.NEW, update); final Ref r = getRef(db, newRef).get(); "<AssertPlaceHolder>"; assertNotNull(r.getObjectId()); assertNotSame(newid, r.getObjectId()); assertSame(ObjectId.class, r.getObjectId().getClass()); assertEquals(newid, r.getObjectId()); List<ReflogEntry> reverseEntries1 = db .getReflogReader("refs/heads/abc").getReverseEntries(); ReflogEntry entry1 = reverseEntries1.get(0); assertEquals(1, reverseEntries1.size()); assertEquals(ObjectId.zeroId(), entry1.getOldId()); assertEquals(r.getObjectId(), entry1.getNewId()); assertEquals(new PersonIdent(db).toString(),  entry1.getWho().toString()); assertEquals("", entry1.getComment()); List<ReflogEntry> reverseEntries2 = db.getReflogReader("HEAD") .getReverseEntries(); assertEquals(0, reverseEntries2.size()); }
getName() { return getRef().getName(); }
[*] target: assertEquals(newRef, r.getName())
[-] pred: org. junit. Assert. assertEquals ( newRef, r. getName ( ) )
************************************
************************************
[+] input: generate_splitRangePartition1_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); actions.setIntos(Arrays.asList(e1, e2)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: ParseException { String dateStr = "2007-02-21 15:35:00 +0100"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
************************************
[+] input: InterruptedException { final EmbeddedChannel channel = new EmbeddedChannel(); final ClientConnection clientConnection = new ClientConnection(channel, null); clientConnection.setProtocolVersion(ProtocolVersion.MQTTv5); channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).set(clientConnection); when(connectionPersistence.get("client")).thenReturn(clientConnection); when(localPersistence.getSession(eq("client"), anyBoolean(), anyBoolean())).thenReturn(new ClientSession(true, 0)); final ListenableFuture<Boolean> future = clientSessionPersistence.forceDisconnectClient("client", true, ClientSessionPersistenceImpl.DisconnectSource.EXTENSION, Mqtt5DisconnectReasonCode.SESSION_TAKEN_OVER, "reason-string"); channel.disconnect(); final Boolean result = future.get(); "<AssertPlaceHolder>"; verify(pendingWillMessages).cancelWillIfPending("client"); verify(mqttServerDisconnector).disconnect(any(Channel.class), anyString(), anyString(), eq(Mqtt5DisconnectReasonCode.SESSION_TAKEN_OVER), eq("reason-string")); }
forceDisconnectClient( final @NotNull String clientId, final boolean preventLwtMessage, final @NotNull DisconnectSource source, final @Nullable Mqtt5DisconnectReasonCode reasonCode, final @Nullable String reasonString) {  checkNotNull(clientId, "Parameter clientId cannot be null"); checkNotNull(source, "Disconnect source cannot be null");  final ClientSession session = getSession(clientId, false); if (session == null) { log.trace("Ignoring forced client disconnect request for client '{}', because client is not connected.", clientId); return Futures.immediateFuture(false); } if (preventLwtMessage) { pendingWillMessages.cancelWillIfPending(clientId); }  log.debug("Request forced client disconnect for client {}.", clientId); final ClientConnection clientConnection = connectionPersistence.get(clientId);  if (clientConnection == null) { log.trace("Ignoring forced client disconnect request for client '{}', because client is not connected.", clientId); return Futures.immediateFuture(false); } clientConnection.setPreventLwt(preventLwtMessage); if (session.getSessionExpiryIntervalSec() != SESSION_EXPIRY_NOT_SET) { clientConnection.setClientSessionExpiryInterval(session.getSessionExpiryIntervalSec()); }  final String logMessage = String.format("Disconnecting client with clientId '%s' forcibly via extension system.", clientId); final String eventLogMessage = "Disconnected via extension system";  final Mqtt5DisconnectReasonCode usedReasonCode = reasonCode == null ? Mqtt5DisconnectReasonCode.ADMINISTRATIVE_ACTION : Mqtt5DisconnectReasonCode.valueOf(reasonCode.name());  mqttServerDisconnector.disconnect(clientConnection.getChannel(), logMessage, eventLogMessage, usedReasonCode, reasonString);  final SettableFuture<Boolean> resultFuture = SettableFuture.create(); clientConnection.getChannel().closeFuture().addListener((ChannelFutureListener) future -> { resultFuture.set(true); }); return resultFuture; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: bytesToIntOffsetTest1() { int l1 = 123; int width1 = 64 - Integer.numberOfLeadingZeros(l1); int l2 = -124; int width2 = 64 - Integer.numberOfLeadingZeros(l2); byte[] bs = new byte[1000]; BytesUtils.intToBytes(l1, bs, 0, width1); int res_val1_1 = BytesUtils.bytesToInt(bs, 0, width1); BytesUtils.intToBytes(l2, bs, width1, width2); int res_val1_2 = BytesUtils.bytesToInt(bs, 0, width1); Assert."<AssertPlaceHolder>"; }
bytesToInt(byte[] result, int pos, int width) { int ret = 0; int cnt = pos & 0x07; int index = pos >> 3; while (width > 0) { int m = width + cnt >= 8 ? 8 - cnt : width; width -= m; ret = ret << m; byte y = (byte) (result[index] & (0xff >> cnt)); y = (byte) ((y & 0xff) >>> (8 - cnt - m)); ret = ret | (y & 0xff); cnt += m; if (cnt == 8) { cnt = 0; index++; } } return ret; }
[*] target: assertEquals(res_val1_1, res_val1_2)
[-] pred: org. junit. Assert. assertEquals ( res_val1_1, res_val1_2 )
************************************
************************************
[+] input: testDeleteQuietly_NonExists_ReturnFalse() { boolean result = localFileOperator.deleteLocalFile(BUCKET, "any-file-name");  Assert."<AssertPlaceHolder>"; }
deleteLocalFile(String bucketName, String objectId) { Verify.notEmpty(bucketName, "bucketName"); Verify.notEmpty(objectId, "objectId"); String absolutePath = absolutePathName(bucketName, objectId); PreConditions.validNoPathTraversal(generateFilePath(bucketName, objectId), generateFilePath(bucketName)); File localFile = new File(absolutePath); return deleteFileQuietly(localFile); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: generate_characterUsingUtf8_generateFunctionCallSucceed() { ExprContext context = getExprContext("character('123', 'abc' using utf8)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); params.add(p); FunctionCall expect = new FunctionCall("character", params); expect.addOption(new ConstExpression("using utf8")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_nthValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "NTH_VALUE(5,6) from first respect nulls over (name_ob partition by (1,2) order by col desc RANGE interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); FunctionCall expect = new FunctionCall("NTH_VALUE", params); expect.addOption(new ConstExpression("from first")); expect.addOption(new ConstExpression("respect nulls")); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_waitIntNum_generateForUpdateSucceed() { For_update_clauseContext context = getForUpdateContext("select 1 from tab for update wait 10"); StatementFactory<ForUpdate> factory = new MySQLForUpdateFactory(context); ForUpdate actual = factory.generate();  ForUpdate expect = new ForUpdate(new ArrayList<>(), WaitOption.WAIT, new BigDecimal("10")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateClauseContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_indexPrimaryKey_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("primary key (col, col1) using index using btree comment 'abcd'")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setComment("'abcd'"); state.setIndexOptions(indexOptions); state.setUsingIndexFlag(true); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { write(new File(db.getDirectory().getParent(), "test.txt"), "test"); File folder = new File(db.getDirectory().getParent(), "folder"); FileUtils.mkdir(folder); write(new File(folder, "folder.txt"), "folder"); try (Git git = new Git(db); ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(new BufferedOutputStream(os))) { git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); write(new File(folder, "folder.txt"), "folder change"); dfmt.setRepository(db); dfmt.setPathFilter(PathFilter.create("folder")); DirCacheIterator oldTree = new DirCacheIterator(db.readDirCache()); FileTreeIterator newTree = new FileTreeIterator(db);  dfmt.format(oldTree, newTree); dfmt.flush();  String actual = os.toString("UTF-8"); String expected = "diff --git a/folder/folder.txt b/folder/folder.txt\n" + "index 0119635..95c4c65 100644\n" + "--- a/folder/folder.txt\n" + "+++ b/folder/folder.txt\n" + "@@ -1 +1 @@\n" + "-folder\n" + "\\ No newline at end of file\n" + "+folder change\n" + "\\ No newline at end of file\n";  "<AssertPlaceHolder>"; } }
flush() throws IOException { out.flush(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testInstance() { MapperManager instance = MapperManager.instance(false); Assert."<AssertPlaceHolder>"; }
instance(boolean isDataSourceLogEnable) { INSTANCE.dataSourceLogEnable = isDataSourceLogEnable; return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
************************************
[+] input: testParameter() { ConfigContext context = new ConfigContext(); String key = "key"; String v = "v"; context.setParameter(key, v);  String actual = (String) context.getParameter(key);  Assert."<AssertPlaceHolder>"; }
getParameter(String key) { return param.get(key); }
[*] target: assertEquals(v, actual)
[-] pred: org. junit. Assert. assertEquals ( v, actual )
************************************
************************************
[+] input: testDetailPreviousConfigHistory() { long nid = 256789; //mock query ConfigHistoryInfo mockConfigHistoryInfo = createMockConfigHistoryInfo(0); Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {nid}), eq(HISTORY_DETAIL_ROW_MAPPER))) .thenReturn(mockConfigHistoryInfo); //execute & verify ConfigHistoryInfo historyReturn = embeddedHistoryConfigInfoPersistService.detailPreviousConfigHistory(nid); Assert."<AssertPlaceHolder>"; }
detailPreviousConfigHistory(Long id) { HistoryConfigInfoMapper historyConfigInfoMapper = mapperManager.findMapper( dataSourceService.getDataSourceType(), TableConstant.HIS_CONFIG_INFO); MapperContext context = new MapperContext(); context.putWhereParameter(FieldConstant.ID, id); MapperResult sqlFetchRows = historyConfigInfoMapper.detailPreviousConfigHistory(context); return databaseOperate.queryOne(sqlFetchRows.getSql(), sqlFetchRows.getParamList().toArray(), HISTORY_DETAIL_ROW_MAPPER); }
[*] target: assertEquals(mockConfigHistoryInfo, historyReturn)
[-] pred: org. junit. Assert. assertEquals ( mockConfigHistoryInfo, historyReturn )
************************************
************************************
[+] input: ParseException { String dateStr = "Wed Feb 21 15:35:00 2007 +0100"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("EEE MMM dd HH:mm:ss yyyy Z") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
************************************
[+] input: generate_readWrite_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) read write"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setReadWrite(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testRelativize_whitespaces() { String base = toOSPathString("/home/eclipse 3.4/runtime New_configuration/project_1"); String other = toOSPathString("/home/eclipse 3.4/runtime New_configuration/project_1/file"); String expected = "file";  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
relativizeNativePath(String base, String other) { return FS.DETECTED.relativize(base, other); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_accessFuncWith_UPDATING_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(UPDATING('regexp_str', 'value', 'value1'))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'regexp_str'")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'value'")); FunctionParam p3 = new ExpressionParam(new ConstExpression("'value1'")); FunctionCall pCall = new FunctionCall("UPDATING", Arrays.asList(p1, p2, p3)); ExpressionParam param1 = new ExpressionParam(pCall); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetBeanOperations() { BeanOperations ops = crane4jTemplate.getBeanOperations(Foo.class); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, ops.getAssembleOperations().size()); Assert.assertTrue(ops.getDisassembleOperations().isEmpty()); }
getBeanOperations(@NonNull AnnotatedElement element) { BeanOperationParser parser = configuration.getBeanOperationsParser(BeanOperationParser.class); return parser.parse(element); }
[*] target: assertNotNull(ops)
[-] pred: org. junit. Assert. assertNotNull ( ops )
************************************
************************************
[+] input: Exception { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = new ComponentName(mContext.getPackageName(), "placeholder-do"); WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), true  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: listTableIndex_get_all_index_in_schema_Success() { Map<String, List<DBTableIndex>> map = accessor.listTableIndexes(getMySQLDataBaseName()); Assert."<AssertPlaceHolder>"; Assert.assertTrue(map.size() > 0); }
listTableIndexes(String schemaName) { String sql = sqlMapper.getSql(Statements.LIST_SCHEMA_INDEX); Map<String, DBTableIndex> fullIndexName2Index = new LinkedHashMap<>(); jdbcOperations.query(sql, new Object[] {schemaName}, (rs, num) -> { String tableName = rs.getString("TABLE_NAME"); String indexName = rs.getString("INDEX_NAME");  if (!fullIndexName2Index.containsKey(tableName + indexName)) { DBTableIndex index = new DBTableIndex(); index.setSchemaName(rs.getString("TABLE_SCHEMA")); index.setTableName(rs.getString("TABLE_NAME")); index.setName(indexName); index.setOrdinalPosition(rs.getInt("SEQ_IN_INDEX")); index.setPrimary(indexName.equalsIgnoreCase("PRIMARY")); index.setCardinality(rs.getLong("CARDINALITY")); index.setComment(rs.getString("INDEX_COMMENT")); index.setAdditionalInfo(rs.getString("COMMENT")); index.setNonUnique(rs.getInt("NON_UNIQUE") != 0); if (isIndexDistinguishesVisibility()) { String visible = rs.getString("IS_VISIBLE"); if (Objects.nonNull(visible)) { index.setVisible(visible.equalsIgnoreCase("YES")); } } else { index.setVisible(true); } index.setCollation(rs.getString("COLLATION")); index.setAlgorithm(DBIndexAlgorithm.fromString(rs.getString("INDEX_TYPE"))); if (index.getAlgorithm() == DBIndexAlgorithm.FULLTEXT) { index.setType(DBIndexType.FULLTEXT); } else if (index.getAlgorithm() == DBIndexAlgorithm.RTREE || index.getAlgorithm() == DBIndexAlgorithm.SPATIAL) { index.setType(DBIndexType.SPATIAL); } else { if (index.isNonUnique()) { index.setType(DBIndexType.NORMAL); } else { index.setType(DBIndexType.UNIQUE); } } List<String> columnNames = new ArrayList<>(); columnNames.add(rs.getString("COLUMN_NAME")); index.setColumnNames(columnNames); index.setGlobal(true); fullIndexName2Index.put(tableName + indexName, index); } else { fullIndexName2Index.get(tableName + indexName).getColumnNames() .add(rs.getString(MySQLConstants.IDX_COLUMN_NAME)); } return null; });  Map<String, List<DBTableIndex>> tableName2Indexes = fullIndexName2Index.values().stream().collect(Collectors.groupingBy(DBTableIndex::getTableName)); for (List<DBTableIndex> columns : tableName2Indexes.values()) { columns.stream().sorted(Comparator.comparing(DBTableIndex::getOrdinalPosition)) .collect(Collectors.toList()); } return tableName2Indexes; }
[*] target: assertNotNull(map)
[-] pred: org. junit. Assert. assertNotNull ( map )
************************************
************************************
[+] input: generate_uniqueIndexColumnAscIdNoIndexOps_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("unique index idx_name (col asc id 16, col1) global with parser 'aaaa'")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); state.setIndexOptions(indexOptions); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_firstValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "FIRST_VALUE (5 respect nulls) over (name_ob partition by (1,2) order by col desc RANGE interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p1 = new ExpressionParam(new ConstExpression("5")); params.add(p1); FunctionCall expect = new FunctionCall("FIRST_VALUE", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); expect.addOption(new ConstExpression("respect nulls")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_xmlSerializeEncodingVersion1_generateSucceed() { ExprContext context = getExprContext( "xmlSerialize(content 'aaa' as int encoding 'aaa' version 12 indent size=12 hide defaults)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlSerialize", Collections.singletonList(p1)); expect.addOption(new ConstExpression("content")); expect.addOption(new ConstExpression("encoding 'aaa'")); expect.addOption(new ConstExpression("version 12")); expect.addOption( new CompoundExpression(new ConstExpression("indent size"), new ConstExpression("12"), Operator.EQ)); expect.addOption(new ConstExpression("hide defaults")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { write(new File(db.getDirectory().getParent(), "test.txt"), "test"); File folder = new File(db.getDirectory().getParent(), "folder"); FileUtils.mkdir(folder); write(new File(folder, "folder.txt"), "folder"); try (Git git = new Git(db); ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(new BufferedOutputStream(os));) { git.add().addFilepattern(".").call(); RevCommit commit = git.commit().setMessage("Initial commit").call(); write(new File(folder, "folder.txt"), "folder change");  dfmt.setRepository(db); dfmt.setPathFilter(PathFilter.create("folder")); dfmt.format(commit.getTree().getId(), null); dfmt.flush();  String actual = os.toString("UTF-8"); String expected = "diff --git a/folder/folder.txt b/folder/folder.txt\n" + "deleted file mode 100644\n" + "index 0119635..0000000\n" + "--- a/folder/folder.txt\n" + "+++ /dev/null\n" + "@@ -1 +0,0 @@\n" + "-folder\n" + "\\ No newline at end of file\n";  "<AssertPlaceHolder>"; } }
flush() throws IOException { out.flush(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldNotReturnWindowStoreAsTimestampedStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlyWindowStore<String, ValueAndTimestamp<String>>> stores = provider.stores("w-store", QueryableStoreTypes.timestampedWindowStore()); "<AssertPlaceHolder>"; }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { final StateStore store = globalStateStores.get(storeName); if (store == null || !queryableStoreType.accepts(store)) { return Collections.emptyList(); } if (!store.isOpen()) { throw new InvalidStateStoreException("the state store, " + storeName + ", is not open."); } if (store instanceof TimestampedKeyValueStore && queryableStoreType instanceof QueryableStoreTypes.KeyValueStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyKeyValueStoreFacade((TimestampedKeyValueStore<Object, Object>) store)); } else if (store instanceof TimestampedWindowStore && queryableStoreType instanceof QueryableStoreTypes.WindowStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyWindowStoreFacade((TimestampedWindowStore<Object, Object>) store)); } return (List<T>) Collections.singletonList(store); }
[*] target: assertEquals(0, stores.size())
[-] pred: org. junit. Assert. assertEquals ( 0, stores. size ( ) )
************************************
************************************
[+] input: getClaims_getJwtLoad_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Map<String, Claim> claims = jwtService.getClaims(token); Assert."<AssertPlaceHolder>"; Assert.assertEquals(new Integer(123), claims.get("userId").asInt()); Assert.assertEquals("testUser", claims.get("username").asString()); }
getClaims(String token) { Algorithm algorithm = Algorithm.HMAC256(jwtProperties.getTokenSecret()); JWTVerifier verifier = JWT.require(algorithm).build(); return verifier.verify(token).getClaims(); }
[*] target: assertNotNull(claims)
[-] pred: org. junit. Assert. assertNotNull ( claims )
************************************
************************************
[+] input: testBitmapCounts() { TestPackBitmapIndex index = new TestPackBitmapIndex(bitmaps);  assertEquals(1, index.getBaseBitmapCount()); "<AssertPlaceHolder>"; assertEquals(2, index.getBitmapCount()); }
getXorBitmapCount() { int xored = 0; for (StoredBitmap sb : getBitmaps()) { if (!sb.isBase()) { xored += 1; } } return xored; }
[*] target: assertEquals(1, index.getXorBitmapCount())
[-] pred: org. junit. Assert. assertEquals ( 1, index. getXorBitmapCount() )
************************************
************************************
[+] input: generate_leadWithWinBody1_generateSucceed() { Bit_exprContext context = getBitExprContext( "LEAD (5,1,2) respect nulls over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); FunctionCall expect = new FunctionCall("LEAD", params); expect.addOption(new ConstExpression("respect nulls")); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetLoggersIgnoresNullLevels() { Logger root = logger("root");  Logger a = logger("a"); a.setLevel(null); Logger b = logger("b"); b.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, a, b);  Map<String, LoggerLevel> expectedLevels = Collections.singletonMap( "b", new LoggerLevel(Level.INFO.toString(), null) ); Map<String, LoggerLevel> actualLevels = loggers.allLevels(); "<AssertPlaceHolder>"; }
allLevels() { Map<String, LoggerLevel> result = new TreeMap<>();  Enumeration<org.apache.log4j.Logger> enumeration = currentLoggers(); Collections.list(enumeration) .stream() .filter(logger -> logger.getLevel() != null) .forEach(logger -> result.put(logger.getName(), loggerLevel(logger)));  org.apache.log4j.Logger root = rootLogger(); if (root.getLevel() != null) { result.put(ROOT_LOGGER_NAME, loggerLevel(root)); }  return result; }
[*] target: assertEquals(expectedLevels, actualLevels)
[-] pred: org. junit. Assert. assertEquals ( expectedLevels, actualLevels )
************************************
************************************
[+] input: generate_predicateNotLikeEscapeSimpleExpr_generateSucceed() { ExprContext context = getExprContext("tab.col not like abc escape bcd"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new CompoundExpression(new ColumnReference(null, null, "abc"), new ColumnReference(null, null, "bcd"), Operator.ESCAPE); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: addServiceInstance() { boolean result = abstractClient.addServiceInstance(service, instancePublishInfo); Assert."<AssertPlaceHolder>"; }
addServiceInstance(Service service, InstancePublishInfo instancePublishInfo) { if (instancePublishInfo instanceof BatchInstancePublishInfo) { InstancePublishInfo old = publishers.put(service, instancePublishInfo); MetricsMonitor.incrementIpCountWithBatchRegister(old, (BatchInstancePublishInfo) instancePublishInfo); } else { if (null == publishers.put(service, instancePublishInfo)) { MetricsMonitor.incrementInstanceCount(); } } NotifyCenter.publishEvent(new ClientEvent.ClientChangedEvent(this)); Loggers.SRV_LOG.info("Client change for service {}, {}", service, getClientId()); return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: generate_createIndexWithColumnGroup_allColumns_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_formatTableOp_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) kv_attributes='12' format=(ENCODING='aaaa',LINE_DELIMITER=123,SKIP_HEADER=12," + "EMPTY_FIELD_AS_NULL=true,NULL_IF_EXETERNAL=(1,2,3))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); Map<String, Expression> map = new HashMap<>(); map.put("ENCODING", new ConstExpression("'aaaa'")); map.put("EMPTY_FIELD_AS_NULL", new BoolValue(true)); map.put("SKIP_HEADER", new ConstExpression("12")); CollectionExpression es = new CollectionExpression(); es.addExpression(new ConstExpression("1")); es.addExpression(new ConstExpression("2")); es.addExpression(new ConstExpression("3")); map.put("NULL_IF_EXETERNAL", es); map.put("LINE_DELIMITER", new ConstExpression("123")); tableOptions.setFormat(map); tableOptions.setKvAttributes("'12'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testStringBlankAndThenExecuteSuccess() { String word = "success"; String actual = TemplateUtils.stringBlankAndThenExecute(word, () -> "call"); Assert."<AssertPlaceHolder>"; }
stringBlankAndThenExecute(String source, Callable<String> callable) {  if (StringUtils.isBlank(source)) {  try { return callable.call(); } catch (Exception e) { LogUtils.NAMING_LOGGER.error("string empty and then execute cause an exception.", e); } }  return source == null ? null : source.trim(); }
[*] target: assertEquals(word, actual)
[-] pred: org. junit. Assert. assertEquals ( word, actual )
************************************
************************************
[+] input: generate_rollUpGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by ROLLUP(col, col1)"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();  ExpressionParam p1 = new ExpressionParam(new RelationReference("col", null)); ExpressionParam p2 = new ExpressionParam(new RelationReference("col1", null)); FunctionCall fCall = new FunctionCall("ROLLUP", Arrays.asList(p1, p2)); GroupBy expect = new GeneralGroupBy(fCall); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.groupbyElementContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: listDatabaseChangingOrderTemplates_useQueryCondition_succeed() { Database database = new Database(); when(databaseService.listDatabasesByIds(any())).thenReturn(Arrays.asList(database)); createDatabaseChangingOrderTemplate_saveEntity_succeed(); Pageable pageable = Pageable.unpaged(); QueryDatabaseChangeChangingOrderParams params = QueryDatabaseChangeChangingOrderParams.builder() .projectId(PROJECT_ID).creatorId(CURRENT_USER_ID).name(TEMPLATE_NAME).build(); Page<DatabaseChangeChangingOrderTemplateResp> result = templateService.listTemplates(pageable, params); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, result.getContent().size()); }
listTemplates(@NotNull Pageable pageable, @NotNull @Valid QueryDatabaseChangeChangingOrderParams params) { projectPermissionValidator.checkProjectRole(params.getProjectId(), ResourceRoleName.all()); Specification<DatabaseChangeChangingOrderTemplateEntity> specification = Specification .where(DatabaseChangeChangingOrderTemplateSpecs.projectIdEquals(params.getProjectId())) .and(params.getName() == null ? null : DatabaseChangeChangingOrderTemplateSpecs.nameLikes(params.getName())) .and(params.getCreatorId() == null ? null : DatabaseChangeChangingOrderTemplateSpecs .creatorIdIn(Collections.singleton(params.getCreatorId()))); Page<DatabaseChangeChangingOrderTemplateEntity> pageResult = templateRepository.findAll(specification, pageable); List<DatabaseChangeChangingOrderTemplateEntity> entityList = pageResult.getContent(); if (CollectionUtils.isEmpty(entityList)) { return Page.empty(); } List<Long> databaseIds = entityList.stream() .flatMap(entity -> entity.getDatabaseSequences().stream()) .flatMap(Collection::stream) .distinct().collect(Collectors.toList()); Map<Long, DatabaseChangeDatabase> id2DatabaseChangeDatabase = databaseService.listDatabasesDetailsByIds(databaseIds).stream() .collect(Collectors.toMap(Database::getId, DatabaseChangeDatabase::new)); List<DatabaseChangeChangingOrderTemplateResp> templateRespList = entityList.stream().map(entity -> { DatabaseChangeChangingOrderTemplateResp templateResp = new DatabaseChangeChangingOrderTemplateResp(); templateResp.setId(entity.getId()); templateResp.setName(entity.getName()); templateResp.setCreatorId(entity.getCreatorId()); templateResp.setProjectId(entity.getProjectId()); templateResp.setOrganizationId(entity.getOrganizationId()); templateResp.setEnabled(entity.getEnabled()); List<List<DatabaseChangeDatabase>> databaseSequenceList = entity.getDatabaseSequences().stream() .map(s -> s.stream().map(id2DatabaseChangeDatabase::get) .collect(Collectors.toList())) .collect(Collectors.toList()); templateResp.setDatabaseSequenceList(databaseSequenceList); return templateResp; }).collect(Collectors.toList()); return new PageImpl<>(templateRespList, pageable, pageResult.getTotalElements()); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: generate_listPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list(a) partitions 145 (" + "partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); ListPartition expect = new ListPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 145, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldNotAbortTxnOnEOSCloseDirtyIfNothingSent() { final AtomicBoolean functionCalled = new AtomicBoolean(false); final RecordCollector collector = new RecordCollectorImpl( logContext, taskId, new StreamsProducer( eosConfig, "-StreamThread-1", new MockClientSupplier() { @Override public Producer<byte[], byte[]> getProducer(final Map<String, Object> config) { return new MockProducer<byte[], byte[]>(cluster, true, byteArraySerializer, byteArraySerializer) { @Override public void abortTransaction() { functionCalled.set(true); } }; } }, taskId, processId, logContext, Time.SYSTEM ), productionExceptionHandler, streamsMetrics, topology );  collector.closeDirty(); "<AssertPlaceHolder>"; }
closeDirty();  /** * The last acked offsets from the internal {@link Producer}
[*] target: assertFalse(functionCalled.get())
[-] pred: org. junit. Assert. assertFalse ( functionCalled. get ( ) )
************************************
************************************
[+] input: listDBSchemasWithSqlTypes_anonymousBlock_listSucceed() { String pl = "DECLARE\n" + "    i VARCHAR2(300);\n" + "BEGIN\n" + "    select ps_auto_refresh_publish_pkg.getloopup_meaning('YES_NO', 'Y') into i from dual;\n" + "    dbms_output.put_line(i);\n" + "END;"; Map<DBSchemaIdentity, Set<SqlType>> actual = DBSchemaExtractor.listDBSchemasWithSqlTypes( Collections.singletonList(SqlTuple.newTuple(pl)), DialectType.OB_ORACLE, "aps"); Map<DBSchemaIdentity, Set<SqlType>> expect = new HashMap<>(); DBSchemaIdentity dbSchemaIdentity = new DBSchemaIdentity(); dbSchemaIdentity.setSchema("PS_AUTO_REFRESH_PUBLISH_PKG"); expect.put(dbSchemaIdentity, Collections.singleton(SqlType.OTHERS)); Assert."<AssertPlaceHolder>"; }
listDBSchemasWithSqlTypes(List<SqlTuple> sqlTuples, DialectType dialectType, String defaultSchema) { Map<DBSchemaIdentity, Set<SqlType>> res = new HashMap<>(); for (SqlTuple sqlTuple : sqlTuples) { try { AbstractSyntaxTree ast = sqlTuple.getAst(); if (ast == null) { sqlTuple.initAst(AbstractSyntaxTreeFactories.getAstFactory(dialectType, 0)); ast = sqlTuple.getAst(); } Set<DBSchemaIdentity> identities = listDBSchemas(ast, dialectType, defaultSchema); SqlType sqlType = SqlType.OTHERS; BasicResult basicResult = ast.getParseResult(); if (Objects.nonNull(basicResult) && Objects.nonNull(basicResult.getSqlType()) && basicResult.getSqlType() != SqlType.UNKNOWN) { sqlType = basicResult.getSqlType(); } for (DBSchemaIdentity identity : identities) { res.computeIfAbsent(identity, k -> new HashSet<>()).add(sqlType); } } catch (Exception e) { // just eat exception due to parse failed } } return res; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_createIndexUsingBtree_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create unique index abc using btree on tb (col, col1) using hash")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setUnique(true); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setUsingHash(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: createBuilderWithBardHeader() { Request.Builder builder = BardUtils.createBuilderWithBardHeader(token); Assert."<AssertPlaceHolder>"; }
createBuilderWithBardHeader(String token) { String[] tokens = token.split(";"); if (tokens.length < 2) { throw new RuntimeException("Please provide the correct token:" + TOKEN_COOKIE_1PSID + ";" + TOKEN_COOKIE_1PSIDTS); } String token1PSID = tokens[0]; String token1PSIDTS = tokens[1]; return new Request.Builder() .addHeader("Host", HOSTNAME) .addHeader("Content-Type", CONTENT_TYPE) .addHeader("X-Same-Domain", "1") .addHeader("User-Agent", USER_AGENT) .addHeader("Origin", BASE_URL) .addHeader("Referer", BASE_URL) .addHeader("Cookie", TOKEN_COOKIE_1PSID + "=" + token1PSID + ";" + TOKEN_COOKIE_1PSIDTS + "=" + token1PSIDTS); }
[*] target: assertNotNull(builder)
[-] pred: org. junit. Assert. assertNotNull ( builder )
************************************
************************************
[+] input: generate_addIndex_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("add key abc (a,b)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SortColumn c1 = new SortColumn(new ColumnReference(null, null, "a")); SortColumn c2 = new SortColumn(new ColumnReference(null, null, "b")); expect.setAddIndex(new OutOfLineIndex("abc", Arrays.asList(c1, c2))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_timestampWithPrescision_generateSucceed() { StatementFactory<DataType> factory = new MySQLDataTypeFactory(getDataTypeContext("timestamp(12)")); DataType actual = factory.generate();  DataType expect = new TimestampType(new BigDecimal("12"), false, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_multiInsert_succeed() { StatementFactory<Insert> factory = new OracleInsertFactory(getInsertContext( "insert all into a partition(p1, p2) " + "into b (c1, c2) " + "into c values (1, default) " + "into d (c3, c4) values(1, 2) " + "select col.* abc from dual order by col desc offset 12 rows fetch first 12 rows only")); Insert actual = factory.generate();  InsertTable t1 = new InsertTable(new RelationFactor("a")); t1.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p1", "p2"))); InsertTable t2 = new InsertTable(new RelationFactor("b")); t2.setColumns(Arrays.asList(new ColumnReference(null, null, "c1"), new ColumnReference(null, null, "c2"))); InsertTable t3 = new InsertTable(new RelationFactor("c")); List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("default"))); t3.setValues(values); InsertTable t4 = new InsertTable(new RelationFactor("d")); values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("2"))); t4.setValues(values); t4.setColumns(Arrays.asList(new ColumnReference(null, null, "c3"), new ColumnReference(null, null, "c4"))); RelationReference r = new RelationReference("col", new RelationReference("*", null)); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); SortKey s1 = new SortKey(new RelationReference("col", null), SortDirection.DESC, null); OrderBy orderBy = new OrderBy(false, Collections.singletonList(s1)); Select select = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); select.setOrderBy(orderBy); select.setFetch(new Fetch(new ConstExpression("12"), FetchDirection.FIRST, FetchType.COUNT, FetchAddition.ONLY, new ConstExpression("12"))); Insert expect = new Insert(Arrays.asList(t1, t2, t3, t4), null); expect.setAll(true); expect.setSelect(select); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.insertStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_withCycleAliasWithoutAlias_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name as (select * from dual) search breadth first by col2 desc, col3 asc set varname cycle col2,col3 set cyclename to 'abcd' default '1234' select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setSearchMode(SearchMode.BREADTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); expect.setCycleAliasList(Arrays.asList("col2", "col3")); expect.setCycleValueSet(new SetValue("cyclename", "'abcd'", "'1234'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testNonCollidingAliases() { SortedSet<PluginDesc<SinkConnector>> sinkConnectors = new TreeSet<>(); sinkConnectors.add(new PluginDesc<>(MockSinkConnector.class, null, PluginType.SINK, MockSinkConnector.class.getClassLoader())); SortedSet<PluginDesc<SourceConnector>> sourceConnectors = new TreeSet<>(); sourceConnectors.add(new PluginDesc<>(MockSourceConnector.class, null, PluginType.SOURCE, MockSourceConnector.class.getClassLoader())); SortedSet<PluginDesc<Converter>> converters = new TreeSet<>(); converters.add(new PluginDesc<>(CollidingConverter.class, null, PluginType.CONVERTER, CollidingConverter.class.getClassLoader())); PluginScanResult result = new PluginScanResult( sinkConnectors, sourceConnectors, converters, Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet() ); Map<String, String> aliases = PluginUtils.computeAliases(result); Map<String, String> actualAliases = PluginUtils.computeAliases(result); Map<String, String> expectedAliases = new HashMap<>(); expectedAliases.put("MockSinkConnector", MockSinkConnector.class.getName()); expectedAliases.put("MockSink", MockSinkConnector.class.getName()); expectedAliases.put("MockSourceConnector", MockSourceConnector.class.getName()); expectedAliases.put("MockSource", MockSourceConnector.class.getName()); expectedAliases.put("CollidingConverter", CollidingConverter.class.getName()); expectedAliases.put("Colliding", CollidingConverter.class.getName()); "<AssertPlaceHolder>"; }
computeAliases(PluginScanResult scanResult) { Map<String, Set<String>> aliasCollisions = new HashMap<>(); scanResult.forEach(pluginDesc -> { aliasCollisions.computeIfAbsent(simpleName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); aliasCollisions.computeIfAbsent(prunedName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); }); Map<String, String> aliases = new HashMap<>(); for (Map.Entry<String, Set<String>> entry : aliasCollisions.entrySet()) { String alias = entry.getKey(); Set<String> classNames = entry.getValue(); if (classNames.size() == 1) { aliases.put(alias, classNames.stream().findAny().get()); } else { log.debug("Ignoring ambiguous alias '{}' since it refers to multiple distinct plugins {}", alias, classNames); } } return aliases; }
[*] target: assertEquals(expectedAliases, actualAliases)
[-] pred: org. junit. Assert. assertEquals ( expectedAliases, actualAliases )
************************************
************************************
[+] input: generate_noWait_generateForUpdateSucceed() { For_update_clauseContext context = getForUpdateContext("select 1 from tab for update nowait"); StatementFactory<ForUpdate> factory = new MySQLForUpdateFactory(context); ForUpdate actual = factory.generate();  ForUpdate expect = new ForUpdate(new ArrayList<>(), WaitOption.NOWAIT, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateClauseContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_fromTableExpr_generateNameRefSucceed() { Table_referenceContext context = getTableReferenceContext("select a from table(generator(1000)) as abcd"); StatementFactory<FromReference> factory = new MySQLFromReferenceFactory(context); FromReference actual = factory.generate();  FunctionCall functionCall = new FunctionCall("generator", Collections.singletonList(new ExpressionParam(new ConstExpression("1000")))); ExpressionReference expect = new ExpressionReference(functionCall, "abcd"); Assert."<AssertPlaceHolder>"; }
generate() { if (this.tableReferenceContext != null) { return visit(this.tableReferenceContext); } return visit(this.tableNameContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetConfigContext() { ConfigRequest configRequest = new ConfigRequest(); IConfigContext configContext = configRequest.getConfigContext(); Assert."<AssertPlaceHolder>"; }
getConfigContext() { return configContext; }
[*] target: assertNotNull(configContext)
[-] pred: org. junit. Assert. assertNotNull ( configContext )
************************************
************************************
[+] input: generate_partition_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (" + "id varchar(64)) partition by hash(a) partitions 12 (" + "partition a.b," + "partition d id 14)"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); expect.setPartition(new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 12)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_cur_timestamp_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("CURRENT_TIMESTAMP(123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("CURRENT_TIMESTAMP", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_functionNameWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "function_name(5, 1,2) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); FunctionCall expect = new FunctionCall("function_name", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_externalTable_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create external table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setExternal(true); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: get() { List<Container<Object>> containers = factory.get(service, annotatedMethod, findAnnotations(annotatedMethod)); Container<Object> container = CollectionUtils.get(containers, 0); Assert.assertTrue(container instanceof CacheableContainer);  Object cachedA = container.get(Collections.singleton("a")).get("a"); Assert.assertNotNull(cachedA); Object a = container.get(Collections.singleton("a")).get("a"); Assert."<AssertPlaceHolder>"; }
get(@Nullable Object source, Method method, Collection<ContainerMethod> annotations) { log.debug("create cacheable method container from [{}]", method); ContainerCache annotation = annotationFinder.findAnnotation(method, ContainerCache.class); if (Objects.isNull(annotation)) { return super.get(source, method, annotations); } // wrap method container as cacheable container String managerName = StringUtils.emptyToDefault(annotation.cacheManager(), CacheManager.DEFAULT_MAP_CACHE_MANAGER_NAME); CacheManager cacheManager = configuration.getCacheManager(managerName); return super.get(source, method, annotations).stream() .map(container -> { CacheDefinition cacheDefinition = new CacheDefinition.Impl( container.getNamespace(), managerName, annotation.expirationTime(), annotation.timeUnit() ); return new CacheableContainer<>(container, cacheDefinition, cacheManager); }) .collect(Collectors.toList()); }
[*] target: assertSame(cachedA, a)
[-] pred: org. junit. Assert. assertSame ( cachedA, a )
************************************
************************************
[+] input: generate_createIndexWithUv_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc@uv1 on tb@uv2 (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor r1 = new RelationFactor("abc"); r1.setUserVariable("@uv1"); RelationFactor r2 = new RelationFactor("tb"); r2.setUserVariable("@uv2"); CreateIndex expect = new CreateIndex(r1, r2, Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_columnProjectionWithAsLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col as label from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new RelationReference("col", null), "label"); Assert."<AssertPlaceHolder>"; }
generate() { return visitProjection(projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_nthValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "NTH_VALUE(5,6) from first respect nulls over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); FunctionCall expect = new FunctionCall("NTH_VALUE", params); expect.addOption(new ConstExpression("from first")); expect.addOption(new ConstExpression("respect nulls")); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_modifyPartitionAddListSubPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition a.b add " + "subpartition a.b values (2) INITRANS 12," + "subpartition b values ('maxvalue') MAXTRANS 13")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setIniTrans(12); se1.setPartitionOptions(sop1);  SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setMaxTrans(13); se2.setPartitionOptions(sop2); RelationFactor factor = new RelationFactor("b"); factor.setSchema("a"); expect.addSubpartitionElements(factor, Arrays.asList(se1, se2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testStructDeserialize() { Deserializer deserializer = new Deserializer.Builder() .schema(CUSTOMER_SCHEMA) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(CUSTOMER_SCHEMA)) .sourceInspector(CUSTOMER_OBJECT_INSPECTOR) .build();  Record expected = GenericRecord.create(CUSTOMER_SCHEMA); expected.set(0, 1L); expected.set(1, "Bob");  Record actual = deserializer.deserialize(new Object[] {new LongWritable(1L), new Text("Bob")});  Assert."<AssertPlaceHolder>"; }
build() { return new Deserializer(schema, new ObjectInspectorPair(writerInspector, sourceInspector)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testQuery() { //        LogQuery logQuery = new LogQuery(); //        logQuery.setStoreId(120042L); //        logQuery.setTailIds(Lists.newArrayList(90028L)); //        logQuery.setTail("hera-app"); //        logQuery.setStartTime(1699427646178L); //        logQuery.setEndTime(1699958631197L); //        logQuery.setPage(1); //        logQuery.setPageSize(100); //        logQuery.setFullTextSearch("level="ERROR""); // //        Result<LogDTO> logDTOResult = esDataService.logQuery(logQuery); //        Assert."<AssertPlaceHolder>"; //    }
logQuery(LogQuery logQuery);
[*] target: assertNotNull(logDTOResult)
[-] pred: org. junit. Assert. assertNotNull ( logDTOResult )
************************************
************************************
[+] input: generate_comment_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) lob_inrow_threshold=456 comment 'aaaaa'"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setComment("'aaaaa'"); tableOptions.setLobInRowThreshold(456); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetAllWorkflowDefsLatestVersions() { WorkflowDef def = new WorkflowDef(); def.setName("test1"); def.setVersion(1); def.setDescription("description"); def.setCreatedBy("unit_test"); def.setCreateTime(1L); def.setOwnerApp("ownerApp"); def.setUpdatedBy("unit_test2"); def.setUpdateTime(2L); metadataDAO.createWorkflowDef(def);  def.setName("test2"); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def);  def.setName("test3"); def.setVersion(1); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def); def.setVersion(3); metadataDAO.createWorkflowDef(def);  // Placed the values in a map because they might not be stored in order of defName. // To test, needed to confirm that the versions are correct for the definitions. Map<String, WorkflowDef> allMap = metadataDAO.getAllWorkflowDefsLatestVersions().stream() .collect(Collectors.toMap(WorkflowDef::getName, Function.identity()));  "<AssertPlaceHolder>"; assertEquals(3, allMap.size()); assertEquals(1, allMap.get("test1").getVersion()); assertEquals(2, allMap.get("test2").getVersion()); assertEquals(3, allMap.get("test3").getVersion()); }
getAllWorkflowDefsLatestVersions() { final String GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY = "SELECT json_data FROM meta_workflow_def wd WHERE wd.version = (SELECT MAX(version) FROM meta_workflow_def wd2 WHERE wd2.name = wd.name)"; return queryWithTransaction( GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY, q -> q.executeAndFetch(WorkflowDef.class)); }
[*] target: assertNotNull(allMap)
[-] pred: org. junit. Assert. assertNotNull ( allMap )
************************************
************************************
[+] input: generate_waitDecimal_generateForUpdateSucceed() { For_update_clauseContext context = getForUpdateContext("select 1 from tab for update wait 2E2"); StatementFactory<ForUpdate> factory = new MySQLForUpdateFactory(context); ForUpdate actual = factory.generate();  ForUpdate expect = new ForUpdate(new ArrayList<>(), WaitOption.WAIT, new BigDecimal("2E2")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateClauseContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_orderAndLimitUnion_generateSelectSucceed() { Select_stmtContext context = getSelectContext( "select col.* abc from tab order by col desc limit 3 union distinct select * from dual"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "col", "*"); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); selectBody.setOrderBy(new OrderBy(Collections.singletonList(s))); selectBody.setLimit(new Limit(new ConstExpression("3"))); selectBody.setRelatedSelect(new RelatedSelectBody(getDefaultSelectSimple(), RelationType.UNION_DISTINCT)); Select expect = new Select(selectBody); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: base64Encode_null() { String encoded = EncodeUtils.base64EncodeToString(null); Assert."<AssertPlaceHolder>"; }
base64EncodeToString(byte[] src) { byte[] encoded = base64Encode(src); if (Objects.isNull(encoded)) { return null; } return new String(encoded, StandardCharsets.UTF_8); }
[*] target: assertNull(encoded)
[-] pred: org. junit. Assert. assertNull ( encoded )
************************************
************************************
[+] input: generate_accessFuncWith_a_between_b_and_c_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a between c and b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CompoundExpression right = new CompoundExpression( new RelationReference("c", null), new RelationReference("b", null), Operator.AND); ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), right, Operator.BETWEEN)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: validNotSqlInjection_ParamIsNull_ReturnTrue() { boolean isNotInjection = PreConditions.validNotSqlInjection(null, "cluster"); Assert."<AssertPlaceHolder>";  }
validNotSqlInjection(String param, String paramName) { if (StringUtils.isEmpty(param)) { return true; } String message = String.format("%s may contain invalid characters", paramName); if (SqlInjectionDetector.isSqlInjection(param)) { throw new BadArgumentException(ErrorCodes.BadArgument, new Object[] {message}, message); } return true; }
[*] target: assertTrue(isNotInjection)
[-] pred: org. junit. Assert. assertTrue ( isNotInjection )
************************************
************************************
[+] input: testFindConfigInfoTags() { String dataId = "dataId1112222"; String group = "group22"; String tenant = "tenant2"; List<String> mockedTags = Arrays.asList("tags1", "tags11", "tags111"); Mockito.when(jdbcTemplate.queryForList(anyString(), eq(new Object[] {dataId, group, tenant}), eq(String.class))) .thenReturn(mockedTags);  List<String> configInfoTags = externalConfigInfoTagPersistService.findConfigInfoTags(dataId, group, tenant); Assert."<AssertPlaceHolder>";  }
findConfigInfoTags(final String dataId, final String group, final String tenant) { String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; ConfigInfoTagMapper configInfoTagMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_TAG); String selectSql = configInfoTagMapper.select(Collections.singletonList("tag_id"), Arrays.asList("data_id", "group_id", "tenant_id")); return jt.queryForList(selectSql, new Object[] {dataId, group, tenantTmp}, String.class); }
[*] target: assertEquals(mockedTags, configInfoTags)
[-] pred: org. junit. Assert. assertEquals ( mockedTags, configInfoTags )
************************************
************************************
[+] input: generate_updateWithoutWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_existSelect_generateSucceed() { PredicateContext context = getPredicateContext("exists(select 1 from dual)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Projection p = new Projection(new ConstExpression("1"), null); NameReference from = new NameReference(null, "dual", null); FunctionCall expect = new FunctionCall("exists", Collections.singletonList( new ExpressionParam(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_autoIncrement_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) expire_info=(1) auto_increment=15"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setExpireInfo(new ConstExpression("1")); tableOptions.setAutoIncrement(new BigDecimal("15")); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_modifyConstraint_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify constraint abc rely enable validate")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ConstraintState constraintState = new ConstraintState(); constraintState.setValidate(true); constraintState.setEnable(true); constraintState.setRely(true); expect.modifyConstraint("abc", constraintState); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: insert_insertLabel_insertSucceed() { ConnectionLabel label = TestRandom.nextObject(ConnectionLabel.class); long actual = labelDAO.insert(label); Assert."<AssertPlaceHolder>"; }
insert(ConnectionLabel connectionLabel);
[*] target: assertEquals(1, actual)
[-] pred: org. junit. Assert. assertEquals ( 1, actual )
************************************
************************************
[+] input: generate_createTableAsSelect_generateSucceed() { Create_table_stmtContext context = getCreateTableContext( "create table .abcd as select * from tab order by c desc fetch first 12 rows only"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(new Projection()), Collections.singletonList(from)); Select select = new Select(selectBody); select.setOrderBy(new OrderBy( Collections.singletonList(new SortKey(new RelationReference("c", null), SortDirection.DESC)))); select.setFetch( new Fetch(new ConstExpression("12"), FetchDirection.FIRST, FetchType.COUNT, FetchAddition.ONLY, null)); expect.setAs(select); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_splitListPartition1_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress, partition id 12)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setNoCompress(true); options1.setId(14); e2.setPartitionOptions(options1); SpecialPartitionElement e3 = new SpecialPartitionElement(null); PartitionOptions o2 = new PartitionOptions(); o2.setId(12); e3.setPartitionOptions(o2); actions.setIntos(Arrays.asList(e1, e2, e3)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testRejected() { HealthCheckRequest healthCheckRequest = new HealthCheckRequest(); RequestMeta requestMeta = new RequestMeta(); TpsCheckResponse tpsCheckResponse = new TpsCheckResponse(false, 5031, "rejected"); Mockito.when(tpsControlManager.check(any(TpsCheckRequest.class))).thenReturn(tpsCheckResponse); Response filterResponse = tpsControlRequestFilter.filter(healthCheckRequest, requestMeta, HealthCheckRequestHandler.class); Assert."<AssertPlaceHolder>"; Assert.assertEquals(NacosException.OVER_THRESHOLD, filterResponse.getErrorCode()); Assert.assertEquals("Tps Flow restricted:" + tpsCheckResponse.getMessage(), filterResponse.getMessage()); }
filter(Request request, RequestMeta meta, Class handlerClazz) {  Method method; try { method = getHandleMethod(handlerClazz); } catch (NacosException e) { return null; }  if (method.isAnnotationPresent(TpsControl.class) && TpsControlConfig.isTpsControlEnabled()) {  try { TpsControl tpsControl = method.getAnnotation(TpsControl.class); String pointName = tpsControl.pointName(); TpsCheckRequest tpsCheckRequest = null; String parseName = StringUtils.isBlank(tpsControl.name()) ? pointName : tpsControl.name(); RemoteTpsCheckRequestParser parser = RemoteTpsCheckRequestParserRegistry.getParser(parseName); if (parser != null) { tpsCheckRequest = parser.parse(request, meta); } if (tpsCheckRequest == null) { tpsCheckRequest = new TpsCheckRequest(); } if (StringUtils.isBlank(tpsCheckRequest.getPointName())) { tpsCheckRequest.setPointName(pointName); }  initTpsControlManager();  TpsCheckResponse check = tpsControlManager.check(tpsCheckRequest);  if (!check.isSuccess()) { Response response; try { response = super.getDefaultResponseInstance(handlerClazz); response.setErrorInfo(NacosException.OVER_THRESHOLD, "Tps Flow restricted:" + check.getMessage()); return response; } catch (Exception e) { com.alibaba.nacos.plugin.control.Loggers.TPS.warn("Tps check fail , request: {},exception:{}", request.getClass().getSimpleName(), e); return null; }  } } catch (Throwable throwable) { com.alibaba.nacos.plugin.control.Loggers.TPS.warn("Tps check exception , request: {},exception:{}", request.getClass().getSimpleName(), throwable); } }  return null; }
[*] target: assertNotNull(filterResponse)
[-] pred: org. junit. Assert. assertNotNull ( filterResponse )
************************************
************************************
[+] input: generate_castAsYear_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as year(3))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam ppp = new ExpressionParam(new ConstExpression("'abc'")); GeneralDataType type = new GeneralDataType("year", Collections.singletonList("3")); ppp.addOption(type); params.add(ppp); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_firstValueWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "FIRST_VALUE (5 respect nulls) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p1 = new ExpressionParam(new ConstExpression("5")); params.add(p1); FunctionCall expect = new FunctionCall("FIRST_VALUE", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); expect.addOption(new ConstExpression("respect nulls")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldFlushDirtyEntriesForNamespace() { final ThreadCache cache = new ThreadCache(logContext, 100000, new MockStreamsMetrics(new Metrics())); final List<byte[]> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace1, dirty -> { for (final ThreadCache.DirtyEntry dirtyEntry : dirty) { received.add(dirtyEntry.key().get()); } }); final List<byte[]> expected = Arrays.asList(new byte[]{0}, new byte[]{1}, new byte[]{2}); for (final byte[] bytes : expected) { cache.put(namespace1, Bytes.wrap(bytes), dirtyEntry(bytes)); } cache.put(namespace2, Bytes.wrap(new byte[]{4}), dirtyEntry(new byte[]{4}));  cache.flush(namespace1); "<AssertPlaceHolder>"; }
flush(final String namespace) { numFlushes++;  final NamedCache cache = getCache(namespace); if (cache == null) { return; }  synchronized (cache) { final long oldSize = cache.sizeInBytes(); cache.flush(); sizeInBytes.getAndAdd(cache.sizeInBytes() - oldSize); }  if (log.isTraceEnabled()) { log.trace("Cache stats on flush: #puts={}, #gets={}, #evicts={}, #flushes={}", puts(), gets(), evicts(), flushes()); } }
[*] target: assertEquals(expected, received)
[-] pred: org. junit. Assert. assertEquals ( expected, received )
************************************
************************************
[+] input: getExpireAt_getJwtExpirationTime_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Date expiresAt = jwtService.getExpiresAt(token); Assert."<AssertPlaceHolder>"; }
getExpiresAt(String token) { Algorithm algorithm = Algorithm.HMAC256(jwtProperties.getTokenSecret()); return JWT.require(algorithm).build().verify(token).getExpiresAt(); }
[*] target: assertNotNull(expiresAt)
[-] pred: org. junit. Assert. assertNotNull ( expiresAt )
************************************
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); //when boolean ret = nacosClientAuthService.login(properties); //then Assert."<AssertPlaceHolder>"; }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (identityContext.getAllKey().contains(NacosAuthLoginConstant.ACCESSTOKEN)) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred: org. junit. Assert. assertTrue ( ret )
************************************
************************************
[+] input: generate_withColumnGroup_allColumns_eachColumn_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns, each column)"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldMatchPositionAfterPut() { inMemoryKeyValueStore.init((StateStoreContext) context, inMemoryKeyValueStore);  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); inMemoryKeyValueStore.put(bytesKey("key1"), bytesValue("value1")); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); inMemoryKeyValueStore.put(bytesKey("key2"), bytesValue("value2")); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); inMemoryKeyValueStore.put(bytesKey("key3"), bytesValue("value3"));  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 3L))))); final Position actual = inMemoryKeyValueStore.getPosition(); "<AssertPlaceHolder>"; }
getPosition() { return position; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_predicateNotLikeEscapeStringList_generateSucceed() { ExprContext context = getExprContext("tab.col not like 'abc' escape 'bcd' 'abcde'"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression e1 = new ConstExpression("'abc'"); CollectionExpression e2 = new CollectionExpression(); e2.addExpression(new ConstExpression("'bcd'")); e2.addExpression(new ConstExpression("'abcde'")); Expression right = new CompoundExpression(e1, e2, Operator.ESCAPE); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_fromSelectStatment_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select abc.* from (select * from tab order by col1 desc) as of scn 1 abc"); StatementFactory<Select> factory = new OracleSelectFactory(context); Select actual = factory.generate();  RelationReference r = new RelationReference("abc", new RelationReference("*", null)); Projection p = new Projection(r, null); SelectBody fromBody = new SelectBody(Collections.singletonList( new Projection()), Collections.singletonList(new NameReference(null, "tab", null))); OrderBy orderBy = new OrderBy(false, Collections.singletonList( new SortKey(new RelationReference("col1", null), SortDirection.DESC, null))); fromBody.setOrderBy(orderBy); FlashbackUsage flashbackUsage = new FlashbackUsage(FlashBackType.AS_OF_SCN, new ConstExpression("1")); ExpressionReference from = new ExpressionReference(fromBody, "abc"); from.setFlashbackUsage(flashbackUsage); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testReplaceVariables_VariableNotExists_ReplaceEmptyString() { String template = "name=${name}, project=${project}";  Map<String, String> variables = new HashMap<>(); variables.put("name", "fake name");  String expected = "name=fake name, project="; String actual = MessageTemplateProcessor.replaceVariables(template, Locale.getDefault(), variables);  Assert."<AssertPlaceHolder>"; }
replaceVariables(final String template, Locale locale, final Map<String, String> variables) { if (StringUtils.isEmpty(template)) { return ""; } if (CollectionUtils.isEmpty(variables)) { return template; } Map<String, String> copiedVariables = new HashMap<>(variables); if (copiedVariables.containsKey("taskType")) { String taskTypeI18nKey = String.format("${com.oceanbase.odc.TaskType.%s}", copiedVariables.get("taskType")); copiedVariables.put("taskType", taskTypeI18nKey); } if (copiedVariables.containsKey("taskStatus")) { String taskStatusI18nKey = String.format("${com.oceanbase.odc.event.TASK.%s.name}", copiedVariables.get("taskStatus")); copiedVariables.put("taskStatus", taskStatusI18nKey); } StringSubstitutor sub = new StringSubstitutor(copiedVariables) .setDisableSubstitutionInValues(true) .setVariableResolver(key -> copiedVariables.getOrDefault(key, "")); String message = sub.replace(template); message = getLocalMessage(locale, message); return message; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test_Operate_Array() { String[] array = new String[] {"DeptA"}; boolean contains = EventParseUtil.validate(array, "contains", "Dept"); Assert."<AssertPlaceHolder>"; }
validate(Object root, String operation, Object value) { if (root.getClass().isArray()) { String json = JsonUtils.toJson(root); root = JsonUtils.fromJsonList(json, String.class); } String assertStr = "'" + root.toString() + "'." + operation + "('" + value.toString() + "')"; Object result = PARSER.parseExpression(assertStr).getValue(); if (Objects.isNull(result)) { throw new UnexpectedException(String.format("Validate condition failed, assertStr=%s", assertStr)); } return (boolean) result; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
************************************
[+] input: testSmallCandidateSizeWithoutReplacement() { String sampleMeta = "weighted_sampler(by=weight, limit=5, replacement=false)"; WeightedSampler sampler = new WeightedSampler(new SampleCondition(sampleMeta), neighborDataset); AbstractResult indexResult = new RangeResult(weightIndex, Collections.singletonList(new RangeUnit(0, 2))); List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(0, 1, 2); "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { // get weights from the neighborDataset by the key in the sampleCondition weights = getNeighborDataset().getNumberAttributeList(getSampleCondition().getKey()); int candidateCount = indexResult.getSize(); // If there are fewer candidates than the limit and we are sampling without replacement, return all of neighbors if (candidateCount <= getSampleCondition().getLimit() && !getSampleCondition() .isReplacement()) { return indexResult.getIndices(); } // If there is no filter condition, and we don't need to sample with replacement, and the limit is small, use the alias method if (!indexResult.hasFilterCondition() && candidateCount == weights.size() // if there is no filter condition, then candidateCount should be equal to all neighbor count && (getSampleCondition().isReplacement() || getSampleCondition().getLimit() <= candidateCount * sampleCountToCandidateCountRatio)) { return sampleByAliasMethod(getSampleCondition().isReplacement()); } // If we need to sample without replacement, and the limit is close to candidate size , use the order statistic tree if (!getSampleCondition().isReplacement() && getSampleCondition().getLimit() > candidateCount * sampleCountToCandidateCountRatio) { return sampleByOrderStatisticTree(indexResult); } // If all other options fail, use the prefix sum array return sampleByPrefixSum(indexResult, getSampleCondition().isReplacement()); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testInitNamespaceFromJvmNamespaceWithCloudParsing() { String expect = "jvm_namespace"; System.setProperty(PropertyKeyConst.NAMESPACE, expect); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
initNamespaceForNaming(NacosClientProperties properties) { String tmpNamespace = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) {  tmpNamespace = TenantUtil.getUserTenantForAns(); LogUtils.NAMING_LOGGER.info("initializer namespace from ans.namespace attribute : {}", tmpNamespace);  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from ALIBABA_ALIWARE_NAMESPACE attribute :" + namespace); return namespace; }); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getPropertyFrom(SourceType.JVM, PropertyKeyConst.NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from namespace attribute :" + namespace); return namespace; });  if (StringUtils.isEmpty(tmpNamespace)) { tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> UtilAndComs.DEFAULT_NAMESPACE_ID); return tmpNamespace; }
[*] target: assertEquals(expect, ns)
[-] pred: org. junit. Assert. assertEquals ( expect, ns )
************************************
************************************
[+] input: getIssuedAt_getJwtIssueTime_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Date issuedAt = jwtService.getIssuedAt(token); Assert."<AssertPlaceHolder>"; }
getIssuedAt(String token) { Algorithm algorithm = Algorithm.HMAC256(jwtProperties.getTokenSecret()); return JWT.require(algorithm).build().verify(token).getIssuedAt(); }
[*] target: assertNotNull(issuedAt)
[-] pred: org. junit. Assert. assertNotNull ( issuedAt )
************************************
************************************
[+] input: generate_autoPartition1_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getAutoPartitionContext( "partition by range(b) partition size 'auto' PARTITIONS AUTO")); Partition actual = factory.generate();  RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "b")), null, null, null, false); expect.setAuto(true); expect.setPartitionSize(new ConstExpression("'auto'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_deleteWithoutWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab"); StatementFactory<Delete> factory = new MySQLDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: convert_jsonToXml() { String json = "{"bookstore":{"book":{"author":"odc","price":99.99,"title":"oceanbase"}}}"; String excepted = "<bookstore><book><author>odc</author><price>99.99</price><title>oceanbase</title></book></bookstore>"; String xml = JsonUtils.jsonToXml(json); Assert."<AssertPlaceHolder>"; }
jsonToXml(String json) { if (StringUtils.isBlank(json)) { return json; } try { JSONObject jsonObject = new JSONObject(json); return XML.toString(jsonObject); } catch (Exception e) { log.error("failed to convert json to xml string, reason:{}", e.getMessage()); return null; } }
[*] target: assertEquals(excepted, xml)
[-] pred: org. junit. Assert. assertEquals ( excepted, xml )
************************************
************************************
[+] input: testCreateOperatorProxy() { Crane4jTemplate.OpsForProxy ops = crane4jTemplate.opsForProxy(); TestOperatorProxy proxy = ops.createOperatorProxy(TestOperatorProxy.class); Assert."<AssertPlaceHolder>"; Foo foo = new Foo("1"); proxy.fill(foo); Assert.assertEquals("name" + foo.getId(), foo.getName()); }
createOperatorProxy(@NonNull Class<T> operator) { return operatorProxyFactory.get(operator); }
[*] target: assertNotNull(proxy)
[-] pred: org. junit. Assert. assertNotNull ( proxy )
************************************
************************************
[+] input: generate_onlyColumnDefExists_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: test_CreateChannel_withChannelConfig() { Channel saved = notificationService.createChannel(PROJECT_ID, getChannel()); Assert."<AssertPlaceHolder>"; List<ChannelPropertyEntity> properties = channelPropertyRepository.findAllByChannelId(saved.getId()); Assert.assertEquals(2, properties.size()); }
createChannel(@NotNull Long projectId, @NotNull Channel channel) { PreConditions.notBlank(channel.getName(), "channel.name"); PreConditions.notNull(channel.getType(), "channel.type"); PreConditions.validNoDuplicated(ResourceType.ODC_NOTIFICATION_CHANNEL, "channel.name", channel.getName(), () -> existsChannel(projectId, channel.getName())); validator.validate(channel.getType(), channel.getChannelConfig());  if (StringUtils.isEmpty(channel.getChannelConfig().getTitleTemplate())) { channel.getChannelConfig().setTitleTemplate("${taskType}-${taskStatus}"); } ChannelEntity entity = channelMapper.toEntity(channel); entity.setCreatorId(authenticationFacade.currentUserId()); entity.setOrganizationId(authenticationFacade.currentOrganizationId()); entity.setProjectId(projectId);  return channelMapper.fromEntity(channelRepository.save(entity)); }
[*] target: assertNotNull(saved)
[-] pred: org. junit. Assert. assertNotNull ( saved )
************************************
************************************
[+] input: generate_rangePartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range columns (a,b) partitions 123(" + "partition a.b values less than (-2, maxvalue) engine=InnoDB," + "partition d values less than (func(1,2)) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement("d", Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e3.setPartitionOptions(o1); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartition expect = new RangePartition(cols, Arrays.asList(e1, e3), null, 123, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: queryByUserId_NotConfigured_Empty() { List<UserConfigEntity> entities = userConfigDAO.queryByUserId(USER_ID); Assert."<AssertPlaceHolder>"; }
queryByUserId(Long userId) { PreConditions.notNull(userId, "userId"); String sql = "SELECT user_id, `key`, `value`, create_time, update_time, description" + " FROM config_user_configuration WHERE user_id = ?"; return jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(UserConfigEntity.class), userId); }
[*] target: assertEquals(0, entities.size())
[-] pred: org. junit. Assert. assertEquals ( 0, entities. size ( ) )
************************************
************************************
[+] input: Exception { SubscribeServiceResponse res = new SubscribeServiceResponse(); ServiceInfo info = new ServiceInfo(GROUP_NAME + "@@" + SERVICE_NAME + "@@" + CLUSTERS); res.setServiceInfo(info); when(this.rpcClient.request(any())).thenReturn(res); ServiceInfo actual = client.subscribe(SERVICE_NAME, GROUP_NAME, CLUSTERS); Assert."<AssertPlaceHolder>"; }
subscribe(String serviceName, String groupName, String clusters) throws NacosException { NAMING_LOGGER.info("[GRPC-SUBSCRIBE] service:{}, group:{}, cluster:{} ", serviceName, groupName, clusters); redoService.cacheSubscriberForRedo(serviceName, groupName, clusters); return doSubscribe(serviceName, groupName, clusters); }
[*] target: assertEquals(info, actual)
[-] pred: org. junit. Assert. assertEquals ( info, actual )
************************************
************************************
[+] input: copy_noChanges() { final ConnackPacketImpl packet = new ConnackPacketImpl( ConnackReasonCode.SUCCESS, true, 10, 60, null, null, null, 3, 1000, 10, Qos.AT_LEAST_ONCE, true, true, true, true, null, null, "reason", UserPropertiesImpl.of(ImmutableList.of())); final ModifiableConnackPacketImpl modifiablePacket = new ModifiableConnackPacketImpl(packet, configurationService, true);  final ConnackPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new ConnackPacketImpl(reasonCode, sessionPresent, sessionExpiryInterval, serverKeepAlive, assignedClientId, authenticationMethod, authenticationData, receiveMaximum, maximumPacketSize, topicAliasMaximum, maximumQos, retainAvailable, wildCardSubscriptionAvailable, sharedSubscriptionsAvailable, subscriptionIdentifiersAvailable, responseInformation, serverReference, reasonString, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
************************************
[+] input: implies_SameResourceTypeAndId_impliesTrue() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "OWNER, DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "OWNER"); Assert."<AssertPlaceHolder>"; }
implies(Permission permission) { if (!(permission instanceof ResourceRoleBasedPermission)) { return false; } return this.resourceId.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceId()) && this.resourceType.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceType()) && !Collections.disjoint(((ResourceRoleBasedPermission) permission).getResourceRoles(), this.resourceRoles); }
[*] target: assertTrue(permission.implies(permission1))
[-] pred: org. junit. Assert. assertTrue ( permission. implies( permission1 ) )
************************************
************************************
[+] input: generate_rangePartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) subpartition by range columns (c,b) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue engine=InnoDB)," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); se2.setPartitionOptions(o); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Arrays.asList(new ColumnReference(null, null, "c"), new ColumnReference(null, null, "b")), "range columns"); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: test() { ConversionService conversionService = DefaultConversionService.getSharedInstance(); SpringConverterManager converterManager = new SpringConverterManager(conversionService); Assert.assertSame(conversionService, converterManager.getConversionService());  BiFunction<String, Integer, Integer> converter = converterManager.getConverter(String.class, Integer.class); Assert."<AssertPlaceHolder>"; Assert.assertEquals((Integer)1, converter.apply("1", 0)); Assert.assertEquals((Integer)0, converter.apply("NaN", 0)); }
getConverter(Class<T> targetType, Class<R> resultType) { return (target, def) -> { try { return conversionService.convert(target, resultType); } catch (Exception e) { return def; } }; }
[*] target: assertNotNull(converter)
[-] pred: org. junit. Assert. assertNotNull ( converter )
************************************
************************************
[+] input: parserAnonymousBlock_callProcedureSucceed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_2, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("PROC"); int actual = procedureCall.getCallLine(); int expect = 6; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_changes() { final PublishPacketImpl packet = new PublishPacketImpl("topic", Qos.AT_LEAST_ONCE, Qos.AT_LEAST_ONCE, 1, false, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, ImmutableIntArray.of(), UserPropertiesImpl.of(ImmutableList.of()), 1234L); final ModifiablePublishPacketImpl modifiablePacket = new ModifiablePublishPacketImpl(packet, configurationService);  modifiablePacket.setTopic("modifiedTopic"); modifiablePacket.setQos(Qos.EXACTLY_ONCE); modifiablePacket.setPayload(ByteBuffer.wrap("modifiedPayload".getBytes())); modifiablePacket.setRetain(true); modifiablePacket.setMessageExpiryInterval(30); modifiablePacket.setPayloadFormatIndicator(PayloadFormatIndicator.UNSPECIFIED); modifiablePacket.setContentType("contentType"); modifiablePacket.setResponseTopic("responseTopic"); modifiablePacket.setCorrelationData(ByteBuffer.wrap("correlationData".getBytes())); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final PublishPacketImpl copy = modifiablePacket.copy();  final PublishPacketImpl expectedPacket = new PublishPacketImpl("modifiedTopic", Qos.AT_LEAST_ONCE, Qos.EXACTLY_ONCE, 1, false, ByteBuffer.wrap("modifiedPayload".getBytes()), true, 30, PayloadFormatIndicator.UNSPECIFIED, "contentType", "responseTopic", ByteBuffer.wrap("correlationData".getBytes()), ImmutableIntArray.of(), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue"))), 1234L); "<AssertPlaceHolder>"; }
copy() { return new PublishPacketImpl(topic, qos, onwardQos, packetId, dupFlag, payload, retain, messageExpiryInterval, payloadFormatIndicator, contentType, responseTopic, correlationData, subscriptionIdentifiers, userProperties.copy(), timestamp); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred: org. junit. Assert. assertEquals ( expectedPacket, copy )
************************************
************************************
[+] input: ParseException { String dateStr = "21.02.2007"; Date exp = SystemReader.getInstance().getSimpleDateFormat("dd.MM.yyyy") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
************************************
[+] input: InterruptedException { redisson.getKeys().flushall(); String lockId = "abcd-1234"; boolean isLocked = redisLock.acquireLock(lockId, 1000, 1000, TimeUnit.MILLISECONDS); "<AssertPlaceHolder>";  Thread.sleep(2000);  RLock lock = redisson.getLock(lockId); assertFalse(lock.isLocked()); }
acquireLock(String lockId, long timeToTry, long leaseTime, TimeUnit unit) { RLock lock = redisson.getLock(parseLockId(lockId)); try { return lock.tryLock(timeToTry, leaseTime, unit); } catch (Exception e) { return handleAcquireLockFailure(lockId, e); } }
[*] target: assertTrue(isLocked)
[-] pred: org. junit. Assert. assertTrue ( isLocked )
************************************
************************************
[+] input: generate_castAsFloat_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as float(2))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); NumberType type = new NumberType("float", new BigDecimal("2"), null); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_dropCheckConstraint_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop check abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropConstraintNames(Collections.singletonList("abcd")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_accessFuncWith_a_not_like_b_escape_c_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a like b escape c)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CompoundExpression right = new CompoundExpression( new RelationReference("b", null), new RelationReference("c", null), Operator.ESCAPE); ExpressionParam param1 = new ExpressionParam( new CompoundExpression(new RelationReference("a", null), right, Operator.LIKE)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldReturnTimestampedKeyValueStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlyKeyValueStore<String, ValueAndTimestamp<String>>> stores = provider.stores("ts-kv-store", QueryableStoreTypes.timestampedKeyValueStore()); "<AssertPlaceHolder>"; for (final ReadOnlyKeyValueStore<String, ValueAndTimestamp<String>> store : stores) { assertThat(store, instanceOf(ReadOnlyKeyValueStore.class)); assertThat(store, instanceOf(TimestampedKeyValueStore.class)); } }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { final StateStore store = globalStateStores.get(storeName); if (store == null || !queryableStoreType.accepts(store)) { return Collections.emptyList(); } if (!store.isOpen()) { throw new InvalidStateStoreException("the state store, " + storeName + ", is not open."); } if (store instanceof TimestampedKeyValueStore && queryableStoreType instanceof QueryableStoreTypes.KeyValueStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyKeyValueStoreFacade((TimestampedKeyValueStore<Object, Object>) store)); } else if (store instanceof TimestampedWindowStore && queryableStoreType instanceof QueryableStoreTypes.WindowStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyWindowStoreFacade((TimestampedWindowStore<Object, Object>) store)); } return (List<T>) Collections.singletonList(store); }
[*] target: assertEquals(1, stores.size())
[-] pred: org. junit. Assert. assertEquals ( 1, stores. size ( ) )
************************************
************************************
[+] input: listTriggers_test_invalid_trigger() { List<DBPLObjectIdentity> triggers = accessor.listTriggers(getOracleSchema()); boolean flag = false; for (DBPLObjectIdentity trigger : triggers) { if (StringUtils.containsIgnoreCase(trigger.getErrorMessage(), "ORA")) { flag = true; } } Assert."<AssertPlaceHolder>"; }
listTriggers(String schemaName) { OracleSqlBuilder sb = new OracleSqlBuilder();  sb.append("select o.OWNER,s.STATUS,o.STATUS as ENABLE_STATUS,TRIGGER_NAME from " + "(select * from "); sb.append(dataDictTableNames.OBJECTS()); sb.append(" where OBJECT_TYPE='TRIGGER') s right join "); sb.append(dataDictTableNames.TRIGGERS()); sb.append(" o on s.OBJECT_NAME=o.TRIGGER_NAME and s.OWNER=o.OWNER where o.OWNER="); sb.value(schemaName); sb.append(" order by TRIGGER_NAME asc");  List<DBPLObjectIdentity> triggers = jdbcOperations.query(sb.toString(), (rs, rowNum) -> { DBPLObjectIdentity trigger = new DBPLObjectIdentity(); trigger.setName(rs.getString("TRIGGER_NAME")); trigger.setSchemaName(rs.getString("OWNER")); trigger.setStatus(rs.getString("STATUS")); trigger.setEnable("ENABLED".equals(rs.getString("ENABLE_STATUS"))); trigger.setType(DBObjectType.TRIGGER); return trigger; });  Map<String, String> errorText = PLObjectErrMsgUtils.acquireErrorMessage(jdbcOperations, schemaName, DBObjectType.TRIGGER.name(), null); for (DBPLObjectIdentity trigger : triggers) { if (StringUtils.containsIgnoreCase(trigger.getStatus(), PLConstants.PL_OBJECT_STATUS_INVALID)) { trigger.setErrorMessage(errorText.get(trigger.getName())); } }  return triggers; }
[*] target: assertTrue(flag)
[-] pred: org. junit. Assert. assertTrue ( flag )
************************************
************************************
[+] input: generate_spatialIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("spatial index using btree (col asc id 16, col1) invisible")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setVisible(false); expect.setIndexOptions(indexOptions); expect.setSpatial(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_changes() { final ImmutableList<MqttUserProperty> list = ImmutableList.of( MqttUserProperty.of("name1", "value1"), MqttUserProperty.of("name2", "value2")); final ModifiableUserPropertiesImpl modifiableUserProperties = new ModifiableUserPropertiesImpl(list, true);  modifiableUserProperties.removeName("name1"); modifiableUserProperties.addUserProperty("name3", "value3"); final UserPropertiesImpl copy = modifiableUserProperties.copy();  final ImmutableList<MqttUserProperty> expectedList = ImmutableList.of( MqttUserProperty.of("name2", "value2"), MqttUserProperty.of("name3", "value3")); "<AssertPlaceHolder>"; }
asInternalList() { final Lock lock = readWriteLock.readLock(); lock.lock(); try { return ImmutableList.copyOf(list); } finally { lock.unlock(); } }
[*] target: assertEquals(expectedList, copy.asInternalList())
[-] pred: org. junit. Assert. assertEquals ( expectedList, copy. asInternalList ( ) )
************************************
************************************
[+] input: generate_ob40NewTableOptions_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) delay_key_write=12 avg_row_length=13 checksum=15 auto_increment_mode='aaa' " + "enable_extended_rowid=true" + " TTL(col1 + interval 12 year, abcd.col2 + interval 45 day, db1.abcd.col3 + interval 45 day)"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setDelayKeyWrite(12); tableOptions.setAvgRowLength(13); tableOptions.setChecksum(15); tableOptions.setAutoIncrementMode("'aaa'"); tableOptions.setEnableExtendedRowId(true); tableOptions.setTtls(Arrays.asList( new CompoundExpression(new ColumnReference(null, null, "col1"), new IntervalExpression(new ConstExpression("12"), "year"), Operator.ADD), new CompoundExpression(new ColumnReference(null, "abcd", "col2"), new IntervalExpression(new ConstExpression("45"), "day"), Operator.ADD), new CompoundExpression(new ColumnReference("db1", "abcd", "col3"), new IntervalExpression(new ConstExpression("45"), "day"), Operator.ADD))); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_noNameIndex_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("index (col, col1) noparallel pctfree 12")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setNoParallel(true); indexOptions.setPctFree(12); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_valuesStatementOrderByLimit_generateSelectSucceed() { String sql = "values row(1, '2'), row(2, '3') order by 1 desc limit 3"; Select_stmtContext context = getSelectContext(sql); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); values.add(Arrays.asList(new ConstExpression("2"), new ConstExpression("'3'"))); SelectBody body = new SelectBody(values); SortKey s1 = new SortKey(new ConstExpression("1"), SortDirection.DESC, null); OrderBy orderBy = new OrderBy(false, Collections.singletonList(s1)); body.setOrderBy(orderBy); Limit limit = new Limit(new ConstExpression("3")); body.setLimit(limit); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_locality_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) locality='abcd' force"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setLocality("'abcd' force"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { write(new File(db.getWorkTree(), "test.txt"), "test"); try (Git git = new Git(db)) { git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); write(new File(db.getWorkTree(), "test.txt"), "test change");  OutputStream out = new ByteArrayOutputStream(); git.diff().setOutputStream(out).setSourcePrefix("old/") .setDestinationPrefix("new/").call();  String actual = out.toString(); String expected = "diff --git old/test.txt new/test.txt\n" + "index 30d74d2..4dba797 100644\n" + "--- old/test.txt\n" + "+++ new/test.txt\n" + "@@ -1 +1 @@\n" + "-test\n" + "\\ No newline at end of file\n" + "+test change\n" + "\\ No newline at end of file\n"; "<AssertPlaceHolder>"; } }
call() throws GitAPIException { try (DiffFormatter diffFmt = getDiffFormatter()) { diffFmt.setRepository(repo); diffFmt.setProgressMonitor(monitor); if (cached) { if (oldTree == null) { ObjectId head = repo.resolve(HEAD + "^{tree}"); //$NON-NLS-1$ if (head == null) throw new NoHeadException(JGitText.get().cannotReadTree); CanonicalTreeParser p = new CanonicalTreeParser(); try (ObjectReader reader = repo.newObjectReader()) { p.reset(reader, head); } oldTree = p; } newTree = new DirCacheIterator(repo.readDirCache()); } else { if (oldTree == null) { oldTree = new DirCacheIterator(repo.readDirCache()); } if (newTree == null) { newTree = new FileTreeIterator(repo); } }  diffFmt.setPathFilter(pathFilter);  List<DiffEntry> result = diffFmt.scan(oldTree, newTree); if (showNameAndStatusOnly || showNameOnly) { return result; } if (contextLines >= 0) { diffFmt.setContext(contextLines); } if (destinationPrefix != null) { diffFmt.setNewPrefix(destinationPrefix); } if (sourcePrefix != null) { diffFmt.setOldPrefix(sourcePrefix); } diffFmt.format(result); diffFmt.flush(); return result; } catch (IOException e) { throw new JGitInternalException(e.getMessage(), e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_updateWithSelectParens_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE (SELECT * FROM tab) v SET v.col2 = 10 WHERE v.col1 = 1;"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference from = new NameReference(null, "tab", null); SelectBody selectBody = new SelectBody(Collections.singletonList(new Projection()), Collections.singletonList(from)); ExpressionReference updateTable = new ExpressionReference(selectBody, "v"); Update expect = new Update(Arrays.asList(updateTable), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, "v", "col2")), new ConstExpression("10"), false))); RelationReference left = new RelationReference("v", new RelationReference("col1", null)); ConstExpression right = new ConstExpression("1"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_leadWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "LEAD (5 respect nulls, 1,2) over (partition by (1,2) order by col desc RANGE 123 FOLLOWING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p1 = new ExpressionParam(new ConstExpression("5")); params.add(p1); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); FunctionCall expect = new FunctionCall("LEAD", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); expect.addOption(new ConstExpression("respect nulls")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: getByVisibleScopeAndOwnerIdAndName_NotExists_isPresentFalse() { Optional<ConnectionEntity> optionalEntity = repository.findByVisibleScopeAndOwnerIdAndName(ConnectionVisibleScope.PRIVATE, CREATOR_ID, NAME);  Assert."<AssertPlaceHolder>"; }
findByVisibleScopeAndOwnerIdAndName(ConnectionVisibleScope visibleScope, Long ownerId, String name);  Optional<ConnectionEntity> findByOrganizationIdAndName(Long organizationId, String name);  List<ConnectionEntity> findByOrganizationId(Long organizationId);  List<ConnectionEntity> findByOrganizationIdIn(Collection<Long> organizationIds);  List<ConnectionEntity> findByProjectId(Long projectId);  @Transactional @Query(value = "select distinct(c_c.*) from `connect_connection` as c_c inner join `connect_database` as c_d " + "on c_c.id = c_d.connection_id where c_d.project_id = :projectId", nativeQuery = true) List<ConnectionEntity> findByDatabaseProjectId(@Param("projectId") Long projectId);  @Transactional @Query(value = "select `id` from `connect_connection` where `host`=:host", nativeQuery = true) @Modifying Set<Long> findIdsByHost(@Param("host") String host);  List<ConnectionEntity> findByIdIn(Collection<Long> ids);  List<ConnectionEntity> findByVisibleScopeAndOrganizationId(ConnectionVisibleScope visibleScope, Long organizationId);  List<ConnectionEntity> findByVisibleScopeAndCreatorId(ConnectionVisibleScope visibleScope, Long creatorId);  List<ConnectionEntity> findByVisibleScope(ConnectionVisibleScope visibleScope);  List<ConnectionEntity> findByOrganizationIdAndEnvironmentId(Long organizationId, Long environmentId);  @Transactional int deleteByVisibleScopeAndOwnerId(ConnectionVisibleScope visibleScope, Long ownerId);  @Query("SELECT e.id FROM #{#entityName}
[*] target: assertFalse(optionalEntity.isPresent())
[-] pred: org. junit. Assert. assertFalse ( optionalEntity. isPresent ( ) )
************************************
************************************
[+] input: testGetUserTenantForAcm() { String expect = "test"; System.setProperty("acm.namespace", expect); String actual = TenantUtil.getUserTenantForAcm(); Assert."<AssertPlaceHolder>"; }
getUserTenantForAcm() { String tmp = USER_TENANT;  if (StringUtils.isBlank(USER_TENANT)) { tmp = NacosClientProperties.PROTOTYPE.getProperty(ACM_NAMESPACE_PROPERTY, DEFAULT_ACM_NAMESPACE); }  return tmp; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_parallel_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) parallel 12, noparallel"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_xmlSerializeEncodingVersion2_generateSucceed() { ExprContext context = getExprContext( "xmlSerialize(content 'aaa' as int encoding 'aaa' version 12 indent size=-12 hide defaults)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlSerialize", Collections.singletonList(p1)); expect.addOption(new ConstExpression("content")); expect.addOption(new ConstExpression("encoding 'aaa'")); expect.addOption(new ConstExpression("version 12")); expect.addOption(new CompoundExpression(new ConstExpression("indent size"), new CompoundExpression(new ConstExpression("12"), null, Operator.SUB), Operator.EQ)); expect.addOption(new ConstExpression("hide defaults")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: encryptAndDecryptOkay() { String originalTxt = "whatever"; String key = "ThisIs128BitKey@"; BlowFishBytesEncryptor blowFishBytesEncryptor = new BlowFishBytesEncryptor(key); byte[] encrypt = blowFishBytesEncryptor.encrypt(originalTxt.getBytes(StandardCharsets.UTF_8)); String decrypted = new String(blowFishBytesEncryptor.decrypt(encrypt), StandardCharsets.UTF_8); "<AssertPlaceHolder>"; }
decrypt(byte[] encrypted) { Validate.notNull(encrypted, "null input for decrypt"); try { Cipher cipher = Cipher.getInstance("Blowfish"); SecretKeySpec key = new SecretKeySpec(this.key, "Blowfish"); cipher.init(Cipher.DECRYPT_MODE, key); return cipher.doFinal(encrypted); } catch (Exception e) { String rootCauseMessage = ExceptionUtils.getRootCauseMessage(e); throw new RuntimeException(rootCauseMessage); } }
[*] target: assertEquals(originalTxt, decrypted)
[-] pred: org. junit. Assert. assertEquals ( originalTxt, decrypted )
************************************
************************************
[+] input: generate_addListPartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("add partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1);  expect.setAddPartitionElements(Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_indexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col asc id 16, col1) using btree visible")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setVisible(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_accessFunctionWithObject_accessFunctionAccess_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(ALL 1).obj_access(2)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall af = new FunctionCall("obj_access", Collections.singletonList(new ExpressionParam(new ConstExpression("2")))); ExpressionParam p = new ExpressionParam(new ConstExpression("1")); FunctionCall expect = new FunctionCall("function", Collections.singletonList(p)); expect.addOption(new ConstExpression("ALL")); expect.reference(af, ReferenceOperator.DOT); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testEquals() { ServerConfigAbility ability = new ServerConfigAbility(); ability.setSupportRemoteMetrics(true); assertEquals(ability, ability); assertFalse(ability.equals(null)); assertFalse(ability.equals(new ClientConfigAbility())); ServerConfigAbility newOne = new ServerConfigAbility(); assertNotEquals(ability, newOne); newOne.setSupportRemoteMetrics(true); "<AssertPlaceHolder>"; }
setSupportRemoteMetrics(boolean supportRemoteMetrics) { this.supportRemoteMetrics = supportRemoteMetrics; }
[*] target: assertEquals(ability, newOne)
[-] pred: org. junit. Assert. assertEquals ( ability, newOne )
************************************
************************************
[+] input: generate_hashPartitionWithSubPartitionOptions_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) subpartition by hash(c) subpartition template(" + "subpartition a.b pctfree=13," + "subpartition b pctused 14) partitions 12 (" + "partition a.b@c (" + "subpartition a.b pctfree=13," + "subpartition b pctused 14)," + "partition d id 14) noCompress")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); PartitionOptions o1 = new PartitionOptions(); o1.setPctFree(13); se1.setPartitionOptions(o1); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setPctUsed(14); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o7 = new PartitionOptions(); o7.setId(14); e2.setPartitionOptions(o7); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "hash"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2), subPartitionOption, 12); PartitionOptions o3 = new PartitionOptions(); o3.setNoCompress(true); expect.setPartitionOptions(o3); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: test_ModelToEntity_Success() { AuditEventMeta model = AuditEventMeta.builder() .action(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION) .type(AuditEventType.PERSONAL_CONFIGURATION) .enabled(true) .inConnection(true) .methodSignature("controller") .sidExtractExpression("test") .build();  AuditEventMetaEntity expected = new AuditEventMetaEntity(); expected.setSidExtractExpression("test"); expected.setMethodSignature("controller"); expected.setEnabled(true); expected.setType(AuditEventType.PERSONAL_CONFIGURATION); expected.setAction(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION); expected.setInConnection(true);  AuditEventMetaEntity actual = mapper.modelToEntity(model); Assert."<AssertPlaceHolder>"; }
modelToEntity(AuditEventMeta model);
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: shouldInstantiateAndConfigureDefaultHeaderConverter() { props.remove(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG); createConfig();  // Because it's not explicitly set on the supplied configuration, the logic to use the current classloader for the connector // will exit immediately, and so this method always returns null HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNull(headerConverter); // But we should always find it (or the worker's default) when using the plugins classloader ... headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertInstanceOf(SimpleHeaderConverter.class, headerConverter); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { Class<? extends HeaderConverter> klass = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) klass = pluginClassFromConfig(config, classPropertyName, HeaderConverter.class, scanResult.headerConverters()); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(scanResult.headerConverters()) ); } } if (klass == null) { throw new ConnectException("Unable to initialize the HeaderConverter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration keys:{}{}", System.lineSeparator(), converterConfig.keySet());  HeaderConverter plugin; try (LoaderSwap loaderSwap = withClassLoader(klass.getClassLoader())) { plugin = newPlugin(klass); plugin.configure(converterConfig); } return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: testRelativize_doc() { // This is the example from the javadoc String base = toOSPathString("c:\\Users\\jdoe\\eclipse\\git\\project"); String other = toOSPathString("c:\\Users\\jdoe\\eclipse\\git\\another_project\\pom.xml"); String expected = toOSPathString("..\\another_project\\pom.xml");  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
relativizeNativePath(String base, String other) { return FS.DETECTED.relativize(base, other); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testSchemaDeserialize() { StandardStructObjectInspector schemaObjectInspector = ObjectInspectorFactory.getStandardStructObjectInspector( Arrays.asList("0:col1", "1:col2"), Arrays.asList( PrimitiveObjectInspectorFactory.writableLongObjectInspector, PrimitiveObjectInspectorFactory.writableStringObjectInspector));  Deserializer deserializer = new Deserializer.Builder() .schema(CUSTOMER_SCHEMA) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(CUSTOMER_SCHEMA)) .sourceInspector(schemaObjectInspector) .build();  Record expected = GenericRecord.create(CUSTOMER_SCHEMA); expected.set(0, 1L); expected.set(1, "Bob");  Record actual = deserializer.deserialize(new Object[] {new LongWritable(1L), new Text("Bob")});  Assert."<AssertPlaceHolder>"; }
build() { return new Deserializer(schema, new ObjectInspectorPair(writerInspector, sourceInspector)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_trim1_generateFunctionCallSucceed() { ExprContext context = getExprContext("trim(both from 'abc')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); params.add(p); FunctionCall expect = new FunctionCall("trim", params); expect.addOption(new ConstExpression("both")); expect.addOption(new ConstExpression("from")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: test_Operate_BlankValue() { boolean contains = EventParseUtil.validate(Collections.singletonList("Hello World!"), "contains", ""); Assert."<AssertPlaceHolder>"; }
validate(Object root, String operation, Object value) { if (root.getClass().isArray()) { String json = JsonUtils.toJson(root); root = JsonUtils.fromJsonList(json, String.class); } String assertStr = "'" + root.toString() + "'." + operation + "('" + value.toString() + "')"; Object result = PARSER.parseExpression(assertStr).getValue(); if (Objects.isNull(result)) { throw new UnexpectedException(String.format("Validate condition failed, assertStr=%s", assertStr)); } return (boolean) result; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
************************************
[+] input: generate_boolPriAddBoolPri_generateSucceed() { ExprContext context = getExprContext("1>2+3"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ConstExpression("1"); Expression right = new CompoundExpression(new ConstExpression("2"), new ConstExpression("3"), Operator.ADD); Expression expect = new CompoundExpression(left, right, Operator.GT); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { final long segmentInterval = 60_000L; // the old segment file's naming system maxes out at 1 minute granularity.  segments = new KeyValueSegments(storeName,  METRICS_SCOPE, NUM_SEGMENTS * segmentInterval, segmentInterval);  final String storeDirectoryPath = stateDirectory.getAbsolutePath() + File.separator + storeName; final File storeDirectory = new File(storeDirectoryPath); //noinspection ResultOfMethodCallIgnored storeDirectory.mkdirs();  final SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMddHHmm"); formatter.setTimeZone(new SimpleTimeZone(0, "UTC"));  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final File oldSegment = new File(storeDirectoryPath + File.separator + storeName + "-" + formatter.format(new Date(segmentId * segmentInterval))); //noinspection ResultOfMethodCallIgnored Files.createFile(oldSegment.toPath()); }  segments.openExisting(context, -1L);  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final String segmentName = storeName + "." + (long) segmentId * segmentInterval; final File newSegment = new File(storeDirectoryPath + File.separator + segmentName); "<AssertPlaceHolder>"; } }
openExisting(final ProcessorContext context, final long streamTime) { metricsRecorder.init(ProcessorContextUtils.getMetricsImpl(context), context.taskId()); super.openExisting(context, streamTime); }
[*] target: assertTrue(newSegment.exists())
[-] pred: org. junit. Assert. assertTrue ( newSegment. exists ( ) )
************************************
************************************
[+] input: Exception { PowerMockito.whenNew(DefaultConnector.class).withAnyArguments().thenReturn(defaultConnector); Method methodGetObVersion = PowerMockito.method(ObConnectTemplate.class, "getObVersion"); PowerMockito.replace(methodGetObVersion).with((proxy, method, args) -> "2.4.0");  ObOperator operator = ObOperators.newObOperator(connectProperties.withCompatibilityMode(CompatibilityMode.MYSQL)); "<AssertPlaceHolder>"; assertNotNull(operator.cluster()); assertNotNull(operator.resource()); assertNotNull(operator.session()); assertNotNull(operator.stats()); assertNotNull(operator.tenant()); }
newObOperator(ConnectProperties connectProperties) { validate(connectProperties);  ObConnectTemplate obConnectTemplate = new ObConnectTemplate(connectProperties); return ObOperator.builder() .resourceOperator(newResourceOperator(obConnectTemplate)) .objectOperator(newObjectOperator(obConnectTemplate)) .clusterOperator(newClusterOperator(obConnectTemplate)) .parameterOperator(newParameterOperator(obConnectTemplate)) .sessionOperator(newSessionOperator(obConnectTemplate)) .statsOperator(newStatsOperator(obConnectTemplate)) .tenantOperator(newTenantOperator(obConnectTemplate)) .sqlTuningOperator(newSqlTuningOperator(obConnectTemplate)) .sqlExecuteOperator(newSqlExecuteOperator(obConnectTemplate)) .sqlAuditOperator(newSqlAuditOperator(obConnectTemplate)) .compactionOperator(newCompactionOperator(obConnectTemplate)) .sqlPlanOperator(newSqlPlanOperator(obConnectTemplate)) .sqlPlanExplainOperator(newSqlPlanExplainOperator(obConnectTemplate)) .build(); }
[*] target: assertNotNull(operator)
[-] pred: org. junit. Assert. assertNotNull ( operator )
************************************
************************************
[+] input: generate_autoPartition_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getAutoPartitionContext( "partition by range(a,b) partition size 'auto' PARTITIONS AUTO")); Partition actual = factory.generate();  RangePartition expect = new RangePartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")), null, null, null, false); expect.setAuto(true); expect.setPartitionSize(new ConstExpression("'auto'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_valuesStatement_generateSelectSucceed() { String sql = "values row(1, '2'), row(2, '3')"; Select_stmtContext context = getSelectContext(sql); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  List<List<Expression>> values = new ArrayList<>(); values.add(Arrays.asList(new ConstExpression("1"), new ConstExpression("'2'"))); values.add(Arrays.asList(new ConstExpression("2"), new ConstExpression("'3'"))); SelectBody body = new SelectBody(values); Select expect = new Select(body); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_memberOf_generateSucceed() { ExprContext context = getExprContext("tab.col member of(col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new ColumnReference(null, null, "col"); Expression expect = new CompoundExpression(left, right, Operator.MEMBER_OF); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_indexColumnDescNullsLast_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("index (col desc nulls last id 15, col1) pctused 14 tablespace abcd")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); s1.setId(15); s1.setDirection(SortDirection.DESC); s1.setNullPosition(SortNullPosition.LAST); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setPctUsed(14); indexOptions.setTableSpace("abcd"); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: ParseException { String dateStr = "2007-02-21"; Date exp = SystemReader.getInstance().getSimpleDateFormat("yyyy-MM-dd") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
************************************
[+] input: testContainsAny() { RuleExprParser ruleExprParser = new RuleExprParser(); Expr e = ruleExprParser.parse( "contains_any(s.entity, ["包膜"]) " + "and contains_any(s.inspection, ["MRI", "CT", "PETCT", "PETMRI"]) " + "and contains_any(s.status, ["完整"]) " + "and " + "not contains_any(s.status, ["无", "不", "未见"])");  Expr2QlexpressTransformer transformer = new Expr2QlexpressTransformer(RuleRunner::convertPropertyName);  List<String> rules = Lists.newArrayList(JavaConversions.asJavaCollection(transformer.transform(e))); Map<String, Object> context = new HashMap<>(); context.put("l", Lists.newArrayList("a", "b", "c")); context.put( "s", new HashMap<String, String>() { { put("entity", "包膜"); put("inspection", "MRI"); put("status", "完整"); } });  boolean rst = RuleRunner.getInstance().check(context, rules, ""); Assert."<AssertPlaceHolder>"; }
check(Map<String, Object> context, List<String> ruleList, String taskId) { DefaultContext<String, Object> ctx = new DefaultContext<>(); ctx.putAll(context); ctx.putAll(getRuleRunningContext(taskId)); for (int i = 0; i < ruleList.size(); ++i) { String rule = ruleList.get(i); try { Object tmpRet = EXPRESS_RUNNER.execute(rule, ctx, null, true, false); if ((1 + i) == ruleList.size()) { return (Boolean) tmpRet; }  } catch (QLCompileException e) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } catch (Exception e) { if (Utils.randomLog()) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } return false; } } return true; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
************************************
[+] input: shouldEnableRackAwareAssignorWithStandbyDescribingTopics() { final MockInternalTopicManager spyTopicManager = spy(mockInternalTopicManager); doReturn( Collections.singletonMap( TP_0_NAME, Collections.singletonList( new TopicPartitionInfo(0, NODE_0, Arrays.asList(REPLICA_1), Collections.emptyList()) ) ) ).when(spyTopicManager).getTopicPartitionInfo(Collections.singleton(TP_0_NAME));  doReturn( Collections.singletonMap( CHANGELOG_TP_0_NAME, Collections.singletonList( new TopicPartitionInfo(0, NODE_0, Arrays.asList(REPLICA_1), Collections.emptyList()) ) ) ).when(spyTopicManager).getTopicPartitionInfo(Collections.singleton(CHANGELOG_TP_0_NAME));  final RackAwareTaskAssignor assignor = spy(new RackAwareTaskAssignor( getClusterWithNoNode(), getTaskTopicPartitionMapForTask0(), getTaskChangeLogTopicPartitionMapForTask0(), getTopologyGroupTaskMap(), getProcessRacksForProcess0(), spyTopicManager, getRackAwareEnabledConfigWithStandby(1), time ));  assertTrue(assignor.canEnableRackAwareAssignor()); verify(assignor, times(1)).populateTopicsToDescribe(anySet(), eq(false)); verify(assignor, times(1)).populateTopicsToDescribe(anySet(), eq(true));  final Map<TopicPartition, Set<String>> racksForPartition = assignor.racksForPartition(); final Map<TopicPartition, Set<String>> expected = mkMap( mkEntry(TP_0_0, mkSet(RACK_1, RACK_2)), mkEntry(CHANGELOG_TP_0_0, mkSet(RACK_1, RACK_2)) ); "<AssertPlaceHolder>"; }
racksForPartition() { return Collections.unmodifiableMap(racksForPartition); }
[*] target: assertEquals(expected, racksForPartition)
[-] pred: org. junit. Assert. assertEquals ( expected, racksForPartition )
************************************
************************************
[+] input: shouldMatchPositionAfterPut() { rocksDBStore.init((StateStoreContext) context, rocksDBStore);  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); rocksDBStore.put(new Bytes(stringSerializer.serialize(null, "one")), stringSerializer.serialize(null, "A")); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); rocksDBStore.put(new Bytes(stringSerializer.serialize(null, "two")), stringSerializer.serialize(null, "B")); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); rocksDBStore.put(new Bytes(stringSerializer.serialize(null, "three")), stringSerializer.serialize(null, "C"));  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 3L))))); final Position actual = rocksDBStore.getPosition(); "<AssertPlaceHolder>"; }
getPosition() { return position; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_sortKey_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) sortkey (a,b)"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions .setSortKeys(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { Map<String, Object> requestToWrite = new HashMap<>(); requestToWrite.put("name", CONNECTOR_NAME); requestToWrite.put("config", CONNECTOR_CONFIG);  try (FileWriter writer = new FileWriter(connectorConfigurationFile)) { writer.write(new ObjectMapper().writeValueAsString(requestToWrite)); }  CreateConnectorRequest parsedRequest = connectStandalone.parseConnectorConfigurationFile(connectorConfigurationFile.getAbsolutePath()); CreateConnectorRequest expectedRequest = new CreateConnectorRequest(CONNECTOR_NAME, CONNECTOR_CONFIG, null); "<AssertPlaceHolder>"; }
parseConnectorConfigurationFile(String filePath) throws IOException { ObjectMapper objectMapper = new ObjectMapper();  File connectorConfigurationFile = Paths.get(filePath).toFile(); try { Map<String, String> connectorConfigs = objectMapper.readValue( connectorConfigurationFile, new TypeReference<Map<String, String>>() { });  if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into a Map with String keys and values", filePath); }  try { objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); CreateConnectorRequest createConnectorRequest = objectMapper.readValue(connectorConfigurationFile, new TypeReference<CreateConnectorRequest>() { }); if (createConnectorRequest.config().containsKey(NAME_CONFIG)) { if (!createConnectorRequest.config().get(NAME_CONFIG).equals(createConnectorRequest.name())) { throw new ConnectException("Connector name configuration in 'config' doesn't match the one specified in 'name' at '" + filePath + "'"); } } else { createConnectorRequest.config().put(NAME_CONFIG, createConnectorRequest.name()); } return createConnectorRequest; } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into an object of type {}", filePath, CreateConnectorRequest.class.getSimpleName()); }  Map<String, String> connectorConfigs = Utils.propsToStringMap(Utils.loadProps(filePath)); if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); }
[*] target: assertEquals(expectedRequest, parsedRequest)
[-] pred: org. junit. Assert. assertEquals ( expectedRequest, parsedRequest )
************************************
************************************
[+] input: generate_updateWithWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1 where col=100"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); RelationReference left = new RelationReference("col", null); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: base64Decode_null() { byte[] bytes = EncodeUtils.base64DecodeFromString(null); Assert."<AssertPlaceHolder>"; }
base64DecodeFromString(String encodedString) { if (Objects.isNull(encodedString)) { return null; } byte[] bytes = encodedString.getBytes(StandardCharsets.UTF_8); return base64Decode(bytes); }
[*] target: assertNull(bytes)
[-] pred: org. junit. Assert. assertNull ( bytes )
************************************
************************************
[+] input: generate_generalOrderByAsc_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select col from tab order by col asc;"); StatementFactory<OrderBy> factory = new MySQLOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.ASC); OrderBy expect = new OrderBy(Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_deleteWithoutWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_reorganizePartitionIntoList_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("REORGANIZE partition a,b into (" + "partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); expect.reorganizePartition(Arrays.asList("a", "b"), Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testEquals() { DataVersion dataVersion = new DataVersion(); DataVersion other = new DataVersion(); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
equals(final Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  final DataVersion that = (DataVersion) o;  if (timestamp != that.timestamp) { return false; }  if (counter != null && that.counter != null) { return counter.longValue() == that.counter.longValue(); }  return (null == counter) && (null == that.counter); }
[*] target: assertTrue(dataVersion.equals(other))
[-] pred: org. junit. Assert. assertTrue ( dataVersion. equals ( other ) )
************************************
************************************
[+] input: Exception { BranchTrackingStatus status = BranchTrackingStatus.of( util.getRepository(), "doesntexist");  "<AssertPlaceHolder>"; }
of(Repository repository, String branchName) throws IOException {  String shortBranchName = Repository.shortenRefName(branchName); String fullBranchName = Constants.R_HEADS + shortBranchName; BranchConfig branchConfig = new BranchConfig(repository.getConfig(), shortBranchName);  String trackingBranch = branchConfig.getTrackingBranch(); if (trackingBranch == null) return null;  Ref tracking = repository.exactRef(trackingBranch); if (tracking == null) return null;  Ref local = repository.exactRef(fullBranchName); if (local == null) return null;  try (RevWalk walk = new RevWalk(repository)) {  RevCommit localCommit = walk.parseCommit(local.getObjectId()); RevCommit trackingCommit = walk.parseCommit(tracking.getObjectId());  walk.setRevFilter(RevFilter.MERGE_BASE); walk.markStart(localCommit); walk.markStart(trackingCommit); RevCommit mergeBase = walk.next();  walk.reset(); walk.setRevFilter(RevFilter.ALL); int aheadCount = RevWalkUtils.count(walk, localCommit, mergeBase); int behindCount = RevWalkUtils.count(walk, trackingCommit, mergeBase);  return new BranchTrackingStatus(trackingBranch, aheadCount, behindCount); } }
[*] target: assertNull(status)
[-] pred: org. junit. Assert. assertNull ( status )
************************************
************************************
[+] input: generate_createIndexWithColumnGroup_allColumns_eachColumn_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns, each column)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testParseGitFileName_FailFooBar() { final FileHeader fh = data("a/foo b/bar\n-"); assertTrue(fh.parseGitFileName(0, fh.buf.length) > 0); assertNull(fh.getOldPath()); assertNull(fh.getNewPath()); "<AssertPlaceHolder>"; }
hasMetaDataChanges() { return changeType != ChangeType.MODIFY || newMode != oldMode; }
[*] target: assertFalse(fh.hasMetaDataChanges())
[-] pred: org. junit. Assert. assertFalse ( fh. hasMetaDataChanges() )
************************************
************************************
[+] input: testPollBatch() { try { ClosableBlockingQueue<String> queue = new ClosableBlockingQueue<>();  assertNull(queue.pollBatch());  queue.add("a"); queue.add("b");  assertEquals(asList("a", "b"), queue.pollBatch()); assertNull(queue.pollBatch());  queue.add("c");  assertEquals(singletonList("c"), queue.pollBatch()); "<AssertPlaceHolder>";  assertTrue(queue.close());  try { queue.pollBatch(); fail("should cause an exception"); } catch (IllegalStateException ignored) { // expected } } catch (Exception e) { e.printStackTrace(); fail(e.getMessage()); } }
pollBatch() { lock.lock(); try { if (open) { if (elements.size() > 0) { ArrayList<E> result = new ArrayList<>(elements); elements.clear(); return result; } else { return null; } } else { throw new IllegalStateException("queue is closed"); } } finally { lock.unlock(); } }
[*] target: assertNull(queue.pollBatch())
[-] pred: org. junit. Assert. assertNull ( queue. pollBatch ( ) )
************************************
************************************
[+] input: generate_hashPartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by hash(a) partitions 12 (" + "partition a.b (" + "subpartition a.b," + "subpartition b engine=InnoDB)," + "partition d id 14)")); Partition actual = factory.generate();  HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setEngine("InnoDB"); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 12); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_splitRangePartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress, partition id 12)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); SpecialPartitionElement e3 = new SpecialPartitionElement(null); PartitionOptions o2 = new PartitionOptions(); o2.setId(12); e3.setPartitionOptions(o2); actions.setIntos(Arrays.asList(e1, e2, e3)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetUnknownLogger() { Logger root = logger("root"); root.setLevel(Level.ERROR);  Hierarchy hierarchy = new Hierarchy(root); Logger a = hierarchy.getLogger("a"); a.setLevel(null); Logger b = hierarchy.getLogger("b"); b.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, a, b);  LoggerLevel level = loggers.level("c"); "<AssertPlaceHolder>"; }
level(String logger) { Objects.requireNonNull(logger, "Logger may not be null");  org.apache.log4j.Logger foundLogger = null; if (ROOT_LOGGER_NAME.equalsIgnoreCase(logger)) { foundLogger = rootLogger(); } else { Enumeration<org.apache.log4j.Logger> en = currentLoggers(); // search within existing loggers for the given name. // using LogManger.getLogger() will create a logger if it doesn't exist // (potential leak since these don't get cleaned up). while (en.hasMoreElements()) { org.apache.log4j.Logger l = en.nextElement(); if (logger.equals(l.getName())) { foundLogger = l; break; } } }  if (foundLogger == null) { log.warn("Unable to find level for logger {}", logger); return null; }  return loggerLevel(foundLogger); }
[*] target: assertNull(level)
[-] pred: org. junit. Assert. assertNull ( level )
************************************
************************************
[+] input: generate_tableWithPartition_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (" + "id varchar(64))" + "partition by range(id) (partition a values less than (-2))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); RangePartitionElement e1 = new RangePartitionElement("a", Collections.singletonList(new CompoundExpression(new ConstExpression("2"), null, Operator.SUB))); List<Expression> cols = Collections.singletonList(new ColumnReference(null, null, "id")); expect.setPartition(new RangePartition(cols, Collections.singletonList(e1), null, null, false)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_Compression_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) COMPRESSION 'aaa'"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setCompression("'aaa'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetAllWorkflowDefsLatestVersions() { WorkflowDef def = new WorkflowDef(); def.setName("test1"); def.setVersion(1); def.setDescription("description"); def.setCreatedBy("unit_test"); def.setCreateTime(1L); def.setOwnerApp("ownerApp"); def.setUpdatedBy("unit_test2"); def.setUpdateTime(2L); metadataDAO.createWorkflowDef(def);  def.setName("test2"); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def);  def.setName("test3"); def.setVersion(1); metadataDAO.createWorkflowDef(def); def.setVersion(2); metadataDAO.createWorkflowDef(def); def.setVersion(3); metadataDAO.createWorkflowDef(def);  // Placed the values in a map because they might not be stored in order of defName. // To test, needed to confirm that the versions are correct for the definitions. Map<String, WorkflowDef> allMap = metadataDAO.getAllWorkflowDefsLatestVersions().stream() .collect(Collectors.toMap(WorkflowDef::getName, Function.identity()));  "<AssertPlaceHolder>"; assertEquals(4, allMap.size()); assertEquals(1, allMap.get("test1").getVersion()); assertEquals(2, allMap.get("test2").getVersion()); assertEquals(3, allMap.get("test3").getVersion()); }
getAllWorkflowDefsLatestVersions() { final String GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY = "SELECT json_data FROM meta_workflow_def wd WHERE wd.version = (SELECT MAX(version) FROM meta_workflow_def wd2 WHERE wd2.name = wd.name)"; return queryWithTransaction( GET_ALL_WORKFLOW_DEF_LATEST_VERSIONS_QUERY, q -> q.executeAndFetch(WorkflowDef.class)); }
[*] target: assertNotNull(allMap)
[-] pred: org. junit. Assert. assertNotNull ( allMap )
************************************
************************************
[+] input: getSynonym_testPublicSynonymInfoForOracle() { DBSynonym synonym = accessor.getSynonym(getOracleSchema(), "PUBLIC_SYNONYM_ACCESSOR", DBSynonymType.PUBLIC); Assert."<AssertPlaceHolder>"; Assert.assertEquals(DBSynonymType.PUBLIC, synonym.getSynonymType()); Assert.assertEquals("PUBLIC_SYNONYM_ACCESSOR", synonym.getSynonymName()); }
getSynonym(String schemaName, String synonymName, DBSynonymType synonymType) { OracleSqlBuilder sb = new OracleSqlBuilder(); sb.append( "select s.OWNER,s.SYNONYM_NAME,s.TABLE_OWNER,s.TABLE_NAME,s.DB_LINK,o.CREATED,o.LAST_DDL_TIME,o.STATUS from "); sb.append(dataDictTableNames.SYNONYMS()); sb.append(" s left join (select * from "); sb.append(dataDictTableNames.OBJECTS()); sb.append(" where OBJECT_TYPE='SYNONYM') o on s.SYNONYM_NAME=o.OBJECT_NAME and s.OWNER=o.OWNER where s.OWNER="); sb.value(getSynonymOwnerSymbol(synonymType, schemaName)); sb.append(" and s.SYNONYM_NAME="); sb.value(synonymName);  DBSynonym synonym = new DBSynonym(); synonym.setSynonymType(synonymType); jdbcOperations.query(sb.toString(), rs -> { synonym.setOwner(rs.getString("OWNER")); synonym.setSynonymName(rs.getString("SYNONYM_NAME")); synonym.setTableOwner(rs.getString("TABLE_OWNER")); synonym.setTableName(rs.getString("TABLE_NAME")); synonym.setDbLink(rs.getString("DB_LINK")); synonym.setCreated(rs.getTimestamp("CREATED")); synonym.setLastDdlTime(rs.getTimestamp("LAST_DDL_TIME")); synonym.setStatus(rs.getString("STATUS")); }); synonym.setDdl(getSynonymDDL(synonym));  return synonym; }
[*] target: assertNotNull(synonym)
[-] pred: org. junit. Assert. assertNotNull ( synonym )
************************************
************************************
[+] input: testIsDecimalType() { boolean result = ColumnTypeUtil.isDecimalType("decimal"); Assert."<AssertPlaceHolder>"; }
isDecimalType(String typeName){ return typeName.toLowerCase().startsWith(TYPE_NAME); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: generate_splitPartitionList_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b values(a,b)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); actions.setListExprs(Arrays.asList(new RelationReference("a", null), new RelationReference("b", null))); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_deleteWithoutWhereClause_1_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete tab"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: ClassNotFoundException { JavaSerialization javaSerialization = new JavaSerialization();  // Test object to serialize String testString = "Hello, World!";  // Serialize the object byte[] serializedData = javaSerialization.serialize(testString);  // Deserialize the object String deserializedString = javaSerialization.deserialize(serializedData, String.class);  // Check if the original object and the deserialized object are equal Assert."<AssertPlaceHolder>"; }
deserialize(byte[] data, Class<T> cls) throws IOException, ClassNotFoundException { ByteArrayInputStream bis = new ByteArrayInputStream(data); ObjectInputStream ois = new ObjectInputStream(bis); Object obj = ois.readObject(); ois.close(); return cls.cast(obj); }
[*] target: assertEquals(testString, deserializedString)
[-] pred: org. junit. Assert. assertEquals ( testString, deserializedString )
************************************
************************************
[+] input: testEquals_falseWhenCounterDifferent2() { DataVersion dataVersion = new DataVersion(); DataVersion other = new DataVersion(); other.setCounter(null); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
equals(final Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  final DataVersion that = (DataVersion) o;  if (timestamp != that.timestamp) { return false; }  if (counter != null && that.counter != null) { return counter.longValue() == that.counter.longValue(); }  return (null == counter) && (null == that.counter); }
[*] target: assertFalse(dataVersion.equals(other))
[-] pred: org. junit. Assert. assertFalse ( dataVersion. equals ( other ) )
************************************
************************************
[+] input: testParseNamespace() { String expect = "test"; Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.NAMESPACE, expect);  final NacosClientProperties nacosClientProperties = NacosClientProperties.PROTOTYPE.derive(properties); String actual = ParamUtil.parseNamespace(nacosClientProperties); "<AssertPlaceHolder>"; }
parseNamespace(NacosClientProperties properties) { String namespaceTmp = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) { namespaceTmp = TenantUtil.getUserTenantForAcm();  namespaceTmp = TemplateUtils.stringBlankAndThenExecute(namespaceTmp, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); return StringUtils.isNotBlank(namespace) ? namespace : StringUtils.EMPTY; }); }  if (StringUtils.isBlank(namespaceTmp)) { namespaceTmp = properties.getProperty(PropertyKeyConst.NAMESPACE); } return StringUtils.isNotBlank(namespaceTmp) ? namespaceTmp.trim() : StringUtils.EMPTY; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: removeServiceSubscriber() { boolean result = abstractClient.removeServiceSubscriber(service); Assert."<AssertPlaceHolder>"; }
removeServiceSubscriber(Service service) { if (null != subscribers.remove(service)) { MetricsMonitor.decrementSubscribeCount(); } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: update_updateLabel_updateSucceed() { ConnectionLabel label = TestRandom.nextObject(ConnectionLabel.class); labelDAO.insert(label); label.setLabelName("new name"); label.setLabelColor("new color"); labelDAO.update(label); ConnectionLabel actual = labelDAO.get(label.getId()); label.setGmtCreated(null); label.setGmtModified(null); actual.setGmtCreated(null); actual.setGmtModified(null); Assert."<AssertPlaceHolder>"; }
get(Long id);
[*] target: assertEquals(label, actual)
[-] pred: org. junit. Assert. assertEquals ( label, actual )
************************************
************************************
[+] input: test1() { TestConditionAnnotationParser1 parser = new TestConditionAnnotationParser1(SimpleAnnotationFinder.INSTANCE); Field field1 = AbstractConditionParserTest.class.getDeclaredField("field1"); Assert.assertNotNull(field1); KeyTriggerOperation operation1 = SimpleKeyTriggerOperation.builder() .source(field1).id(field1.getName()).key(field1.getName()) .build(); Condition condition1 = CollectionUtils.getFirstNotNull(parser.parse(field1, operation1)); Assert."<AssertPlaceHolder>"; Assert.assertTrue(condition1.test(null, operation1)); }
parse( AnnotatedElement element, KeyTriggerOperation operation) { if (ignored.contains(element)) { return Collections.emptyList(); } List<Condition> results = doParse(element, operation); if (results.isEmpty()) { ignored.add(element); return Collections.emptyList(); } return results; }
[*] target: assertNotNull(condition1)
[-] pred: org. junit. Assert. assertNotNull ( condition1 )
************************************
************************************
[+] input: generate_intervalBitExpr_generateSucceed() { Bit_exprContext context = getBitExprContext("interval 4 day + 1"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression right = new ConstExpression("1"); Expression left = new IntervalExpression(new ConstExpression("4"), "day"); Expression expect = new CompoundExpression(left, right, Operator.ADD); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_indexColumnDescLenId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col(13) desc id 16, col1) comment 'abcd' storing(a,b) noparallel")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.DESC); s1.setLength(13); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setComment("'abcd'"); indexOptions.setNoParallel(true); indexOptions .setStoring(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: getIntentValue_getAccessibilityPermissionIndex_returnCameraPermissionMessage() { Intent mockIntent = new Intent(ApplicationProvider.getApplicationContext(), GrantPermissionActivity.class); mockIntent.putExtra("permission", "grantAccessibility");  GrantPermissionActivity grantPermissionActivityResume = Robolectric.buildActivity(GrantPermissionActivity.class, mockIntent).create().start().resume().get(); String description = grantPermissionActivityResume.getDescriptionTextViewValue(); String actual = "Change permissions in your device’s \napp settings. Give GameFace access to \nAccessibility.";  "<AssertPlaceHolder>"; }
getDescriptionTextViewValue() { TextView descriptionTextView = findViewById(R.id.description); return descriptionTextView.getText().toString(); }
[*] target: assertEquals(actual, description)
[-] pred: org. junit. Assert. assertEquals ( actual, description )
************************************
************************************
[+] input: testReduceSmallInput() { final StreamsBuilder builder = new StreamsBuilder(); final String topic = "topic"; final WindowBytesStoreSupplier storeSupplier = setupWindowBytesStoreSupplier(1); final Materialized<String, String, WindowStore<Bytes, byte[]>> materialized = setupMaterialized(emitFinal ? Materialized.as("store-name") : Materialized.as(storeSupplier));  final KTable<Windowed<String>, String> table = builder .stream(topic, Consumed.with(Serdes.String(), Serdes.String())) .groupByKey(Grouped.with(Serdes.String(), Serdes.String())) .windowedBy(SlidingWindows.ofTimeDifferenceAndGrace(ofMillis(10), ofMillis(5))) .emitStrategy(emitStrategy) .reduce( MockReducer.STRING_ADDER, materialized ); final MockApiProcessorSupplier<Windowed<String>, String, Void, Void> supplier = new MockApiProcessorSupplier<>(); table.toStream().process(supplier); try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) { final TestInputTopic<String, String> inputTopic = driver.createInputTopic(topic, new StringSerializer(), new StringSerializer()); inputTopic.pipeInput("A", "1", 10L); inputTopic.pipeInput("A", "2", 14L); inputTopic.pipeInput("A", "3", 15L); inputTopic.pipeInput("A", "4", 22L); inputTopic.pipeInput("A", "5", 26L); inputTopic.pipeInput("A", "6", 30L); }  final Map<Long, Set<ValueAndTimestamp<String>>> actual = gatherOutput(supplier); final Map<Long, Set<ValueAndTimestamp<String>>> expected = new HashMap<>();  if (emitFinal) { expected.put(0L, mkSet(ValueAndTimestamp.make("1", 10L))); expected.put(4L, mkSet(ValueAndTimestamp.make("1+2", 14L))); expected.put(5L, mkSet(ValueAndTimestamp.make("1+2+3", 15L))); expected.put(11L, mkSet(ValueAndTimestamp.make("2+3", 15L))); expected.put(12L, mkSet(ValueAndTimestamp.make("2+3+4", 22L))); } else { expected.put(0L, mkSet(ValueAndTimestamp.make("1", 10L))); expected.put(4L, mkSet(ValueAndTimestamp.make("1+2", 14L))); expected.put(5L, mkSet(ValueAndTimestamp.make("1+2+3", 15L))); expected.put(11L, mkSet( ValueAndTimestamp.make("2", 14L), ValueAndTimestamp.make("2+3", 15L) )); expected.put(12L, mkSet(ValueAndTimestamp.make("2+3+4", 22L))); expected.put(15L, mkSet( ValueAndTimestamp.make("3", 15L), ValueAndTimestamp.make("3+4", 22L) )); expected.put(16L, mkSet( ValueAndTimestamp.make("4", 22L), ValueAndTimestamp.make("4+5", 26L) )); expected.put(20L, mkSet(ValueAndTimestamp.make("4+5+6", 30L))); expected.put(23L, mkSet( ValueAndTimestamp.make("5", 26L), ValueAndTimestamp.make("5+6", 30L) )); expected.put(27L, mkSet(ValueAndTimestamp.make("6", 30L))); } "<AssertPlaceHolder>"; }
process(final Record<KIn, VIn> record) { if (record.key() == null || record.value() == null) { if (context().recordMetadata().isPresent()) { final RecordMetadata recordMetadata = context().recordMetadata().get(); log.warn( "Skipping record due to null key or value. " + "topic=[{}] partition=[{}] offset=[{}]", recordMetadata.topic(), recordMetadata.partition(), recordMetadata.offset() ); } else { log.warn( "Skipping record due to null key or value. Topic, partition, and offset not known." ); } droppedRecordsSensor.record(); return; }  updateObservedStreamTime(record.timestamp()); final long windowCloseTime = observedStreamTime - windows.gracePeriodMs();  final long windowStart = record.timestamp(); final long windowEnd = record.timestamp() + windows.timeDifferenceMs(); if (windowEnd < windowCloseTime) { final String window = "[" + windowStart + "," + windowEnd + "]"; logSkippedRecordForExpiredWindow(log, record.timestamp(), windowCloseTime, window); return; }  if (record.timestamp() < windows.timeDifferenceMs()) { processEarly(record, windowCloseTime); return; }  if (reverseIteratorPossible == null) { try { try (final WindowStoreIterator<ValueAndTimestamp<VAgg>> iterator = windowStore.backwardFetch(record.key(), 0L, 0L)) { reverseIteratorPossible = true; log.debug("Sliding Windows aggregate using a reverse iterator"); } } catch (final UnsupportedOperationException e)  { reverseIteratorPossible = false; log.debug("Sliding Windows aggregate using a forward iterator"); } }  if (reverseIteratorPossible) { processReverse(record, windowCloseTime); } else { processInOrder(record, windowCloseTime); }  maybeForwardFinalResult(record, windowCloseTime); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testToObjectId() { MutableLongObjectId m = new MutableLongObjectId(); m.fromRaw(new long[] { 1L, 2L, 3L, 4L }); "<AssertPlaceHolder>"; }
toObjectId() { return new LongObjectId(this); }
[*] target: assertEquals(m, m.toObjectId())
[-] pred: org. junit. Assert. assertEquals ( m, m. toObjectId() )
************************************
************************************
[+] input: generate_keyPartition_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by key (a,d) subpartition by key(c) subpartition template (" + "subpartition a," + "subpartition b engine=InnoDB) partitions 144 (" + "partition a.b," + "partition d id 14)")); Partition actual = factory.generate();  SubHashPartitionElement se1 = new SubHashPartitionElement("a"); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setEngine("InnoDB"); se2.setPartitionOptions(o2); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "key"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); KeyPartition expect = new KeyPartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "d")), Arrays.asList(e1, e2), subPartitionOption, 144); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_columnDefOrigDefaultExpr_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) orig_default((current_timestamp(1)))")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); FunctionCall expr = new FunctionCall("current_timestamp", Collections.singletonList(new ExpressionParam(new ConstExpression("1")))); attributes.setOrigDefault(expr); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_withColumnGroup_allColumns_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns)"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: NacosException { RpcClient rpcClient = new RpcClient(new RpcClientConfig() { @Override public String name() { return "test-client"; }  @Override public int retryTimes() { return 3; }  @Override public long timeOutMills() { return 3000L; }  @Override public long connectionKeepAlive() { return 5000L; }  @Override public int healthCheckRetryTimes() { return 1; }  @Override public long healthCheckTimeOut() { return 3000L; }  @Override public Map<String, String> labels() { return new HashMap<>(); } }) { @Override public ConnectionType getConnectionType() { return null; }  @Override public int rpcPortOffset() { return 0; }  @Override public Connection connectToServer(ServerInfo serverInfo) { return null; } };  rpcClient.shutdown(); "<AssertPlaceHolder>"; }
isShutdown() { return this.rpcClientStatus.get() == RpcClientStatus.SHUTDOWN; }
[*] target: assertTrue(rpcClient.isShutdown())
[-] pred: org. junit. Assert. assertTrue ( rpcClient. isShutdown() )
************************************
************************************
[+] input: createOperateTemplate() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); OperateTemplate operateTemplate = ConfigurationUtil.createOperateTemplate(configuration); Assert."<AssertPlaceHolder>"; }
createOperateTemplate(Crane4jGlobalConfiguration configuration) { return new OperateTemplate( configuration.getBeanOperationsParser(BeanOperationParser.class), configuration.getBeanOperationExecutor(BeanOperationExecutor.class), configuration.getTypeResolver() ); }
[*] target: assertNotNull(operateTemplate)
[-] pred: org. junit. Assert. assertNotNull ( operateTemplate )
************************************
************************************
[+] input: generate_top_k_fre_histWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "TOP_K_FRE_HIST(5,6,7) over (name_ob partition by (1,2) order by col desc RANGE interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); params.add(new ExpressionParam(new ConstExpression("7"))); FunctionCall expect = new FunctionCall("TOP_K_FRE_HIST", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset offset = new WindowOffset(WindowOffsetType.FOLLOWING); offset.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.RANGE, offset); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: fromJsonList_json_null_expect_null() { List<A> aList = JsonUtils.fromJsonList(null, A.class);  Assert."<AssertPlaceHolder>"; }
fromJsonList(String json, Class<T> classType) { if (json == null) { return null; } try { CollectionType javaType = OBJECT_MAPPER.getTypeFactory().constructCollectionType(List.class, classType); return OBJECT_MAPPER.readValue(json, javaType); } catch (JsonProcessingException e) { return null; } }
[*] target: assertNull(aList)
[-] pred: org. junit. Assert. assertNull ( aList )
************************************
************************************
[+] input: generate_insertChildXml_generateSucceed() { Xml_functionContext context = getXmlExprContext("insertchildxml(1,2,3,4)"); OracleExpressionFactory factory = new OracleExpressionFactory(); Expression actual = factory.visit(context);  FunctionCall expect = new FunctionCall("insertchildxml", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")), new ExpressionParam(new ConstExpression("3")), new ExpressionParam(new ConstExpression("4")))); Assert."<AssertPlaceHolder>"; }
visit(ParseTree parseTree) { if (parseTree == null) { return null; } return super.visit(parseTree); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_orderByNullsLast_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select 1 from dual order by col nulls last"); StatementFactory<OrderBy> factory = new OracleOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new RelationReference("col", null), null, SortNullPosition.LAST); OrderBy expect = new OrderBy(false, Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetLoggerFallsBackToEffectiveLogLevel() { Logger root = logger("root"); root.setLevel(Level.ERROR);  Hierarchy hierarchy = new Hierarchy(root); Logger a = hierarchy.getLogger("a"); a.setLevel(null); Logger b = hierarchy.getLogger("b"); b.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, a, b);  LoggerLevel expectedLevel = new LoggerLevel(Level.ERROR.toString(), null); LoggerLevel actualLevel = loggers.level("a"); "<AssertPlaceHolder>"; }
level(String logger) { Objects.requireNonNull(logger, "Logger may not be null");  org.apache.log4j.Logger foundLogger = null; if (ROOT_LOGGER_NAME.equalsIgnoreCase(logger)) { foundLogger = rootLogger(); } else { Enumeration<org.apache.log4j.Logger> en = currentLoggers(); // search within existing loggers for the given name. // using LogManger.getLogger() will create a logger if it doesn't exist // (potential leak since these don't get cleaned up). while (en.hasMoreElements()) { org.apache.log4j.Logger l = en.nextElement(); if (logger.equals(l.getName())) { foundLogger = l; break; } } }  if (foundLogger == null) { log.warn("Unable to find level for logger {}", logger); return null; }  return loggerLevel(foundLogger); }
[*] target: assertEquals(expectedLevel, actualLevel)
[-] pred: org. junit. Assert. assertEquals ( expectedLevel, actualLevel )
************************************
************************************
[+] input: testInitNamespaceFromAliwareWithCloudParsing() { String expect = "aliware"; System.setProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, "true"); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); properties.setProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE, expect); String actual = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
initNamespaceForNaming(NacosClientProperties properties) { String tmpNamespace = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) {  tmpNamespace = TenantUtil.getUserTenantForAns(); LogUtils.NAMING_LOGGER.info("initializer namespace from ans.namespace attribute : {}", tmpNamespace);  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from ALIBABA_ALIWARE_NAMESPACE attribute :" + namespace); return namespace; }); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getPropertyFrom(SourceType.JVM, PropertyKeyConst.NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from namespace attribute :" + namespace); return namespace; });  if (StringUtils.isEmpty(tmpNamespace)) { tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> UtilAndComs.DEFAULT_NAMESPACE_ID); return tmpNamespace; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testAddAggrConfigInfoOfAddNewContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and throw EmptyResultDataAccessException. when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenThrow(new EmptyResultDataAccessException(1)); //mock insert success when(jdbcTemplate.update(anyString(), eq(dataId), eq(group), eq(tenant), eq(datumId), eq(appName), eq(content), any(Timestamp.class))).thenReturn(1);  //execute boolean result = externalConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
addAggrConfigInfo(final String dataId, final String group, String tenant, final String datumId, String appName, final String content) { String appNameTmp = StringUtils.isBlank(appName) ? StringUtils.EMPTY : appName; String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; final Timestamp now = new Timestamp(System.currentTimeMillis()); ConfigInfoAggrMapper configInfoAggrMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_AGGR); String select = configInfoAggrMapper.select(Collections.singletonList("content"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id")); String insert = configInfoAggrMapper.insert( Arrays.asList("data_id", "group_id", "tenant_id", "datum_id", "app_name", "content", "gmt_modified")); String update = configInfoAggrMapper.update(Arrays.asList("content", "gmt_modified"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id"));  try { try { String dbContent = jt.queryForObject(select, new Object[] {dataId, group, tenantTmp, datumId}, String.class);  if (dbContent != null && dbContent.equals(content)) { return true; } else { return jt.update(update, content, now, dataId, group, tenantTmp, datumId) > 0; } } catch (EmptyResultDataAccessException ex) { // no data, insert return jt.update(insert, dataId, group, tenantTmp, datumId, appNameTmp, content, now) > 0; } } catch (DataAccessException e) { LogUtil.FATAL_LOG.error("[db-error] " + e, e); throw e; } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: ParseException { String dateStr = "Wed Feb 21 15:35:00 2007"; Date exp = SystemReader.getInstance() .getSimpleDateFormat("EEE MMM dd HH:mm:ss yyyy").parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
************************************
[+] input: invokeWithMapContainer() { Method mapContainerMethod = ReflectUtils.getMethod(OperatorInterface.class, "mapContainerMethod", Foo.class, HashMap.class); MethodInvoker invoker = proxyMethodFactory.get(beanOperations, mapContainerMethod, operationExecutor); Assert."<AssertPlaceHolder>"; checkFoo(1, "1", invoker, null);  Map<Integer, Object> map = new HashMap<>(); map.put(2, "name2"); checkFoo(2, "name2", invoker, map); }
get(BeanOperations beanOperations, Method method, BeanOperationExecutor beanOperationExecutor) { Map<String, Parameter> parameterNameMap = ReflectUtils.resolveParameterNames(parameterNameFinder, method); // not any other argument need adapting as container if (parameterNameMap.size() == 1) { return null; } // has other argument but no adapters were found ContainerParameterAdapter[] adaptors = resolveContainerParameterAdaptors(method, parameterNameMap); if (Arrays.stream(adaptors).allMatch(Objects::isNull)) { return null; } log.info("create dynamic container proxy method for method: {}", method); MethodInvoker invoker = new DynamicContainerMethodInvoker(beanOperations, beanOperationExecutor, adaptors); return ParameterConvertibleMethodInvoker.create(invoker, converterManager, method.getParameterTypes()); }
[*] target: assertNotNull(invoker)
[-] pred: org. junit. Assert. assertNotNull ( invoker )
************************************
************************************
[+] input: testWebUtil() { SecuritySession session = Mockito.mock(SecuritySession.class); Mockito.when(session.getId()).thenReturn("abcde"); Mockito.when(session.getTimeoutMillis()).thenReturn(100000L); Cookie cookie = WebUtil.generateSecurityCookie(session); Assert."<AssertPlaceHolder>"; Assert.assertEquals(cookie.getValue(), session.getId()); Assert.assertEquals(cookie.getMaxAge(), TimeUnit.SECONDS.convert(session.getTimeoutMillis(), TimeUnit.MILLISECONDS)); Assert.assertTrue(cookie.isHttpOnly()); Assert.assertEquals(cookie.getPath(), "/"); }
generateSecurityCookie(@NonNull SecuritySession session) { Cookie cookie = new Cookie(SecurityConstants.CUSTOM_COOKIE_NAME, (String) session.getId()); cookie.setHttpOnly(true); long maxAgeSeconds = TimeUnit.SECONDS.convert(session.getTimeoutMillis(), TimeUnit.MILLISECONDS); if (maxAgeSeconds > Integer.MAX_VALUE) { cookie.setMaxAge(Integer.MAX_VALUE); } else { cookie.setMaxAge((int) maxAgeSeconds); } cookie.setPath("/"); return cookie; }
[*] target: assertNotNull(cookie)
[-] pred: org. junit. Assert. assertNotNull ( cookie )
************************************
************************************
[+] input: generate_indexPrimaryKeyNoyAlgorithmAndComment_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("primary key (col, col1)")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineConstraint expect = new OutOfLineConstraint(null, Arrays.asList(s1, s2)); expect.setPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_uniqueIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "unique (col asc id 16, col1) using index using btree global with parser 'aaaa'")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); state.setIndexOptions(indexOptions); state.setUsingIndexFlag(true); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testDumpSnapshot() { InputStream inputStream = serviceMetadataSnapshotOperation.dumpSnapshot();  Assert."<AssertPlaceHolder>"; }
dumpSnapshot() { Map<Service, ServiceMetadata> snapshot = metadataManager.getServiceMetadataSnapshot(); return new ByteArrayInputStream(serializer.serialize(snapshot)); }
[*] target: assertNotNull(inputStream)
[-] pred: org. junit. Assert. assertNotNull ( inputStream )
************************************
************************************
[+] input: testSetMaxInboundMessageSize() { int maxInboundMessageSize = 10485760; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setMaxInboundMessageSize(maxInboundMessageSize); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
maxInboundMessageSize() { return maxInboundMessageSize; }
[*] target: assertEquals(maxInboundMessageSize, config.maxInboundMessageSize())
[-] pred: org. junit. Assert. assertEquals ( maxInboundMessageSize, config. maxInboundMessageSize ( ) )
************************************
************************************
[+] input: testRelativize_scheme() { String base = toOSPathString("file:/home/eclipse/runtime-New_configuration/project_1/file.java"); String other = toOSPathString("file:/home/eclipse/runtime-New_configuration/project"); // 'file.java' is treated as a folder String expected = toOSPathString("../../project");  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
relativizeNativePath(String base, String other) { return FS.DETECTED.relativize(base, other); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: isODPSharding_OB_MYSQL_ReturnFalse() { boolean isODPSharding = ConnectType.OB_MYSQL.isODPSharding(); Assert."<AssertPlaceHolder>"; }
isODPSharding() { return this == ODP_SHARDING_OB_MYSQL || this == ODP_SHARDING_OB_ORACLE; }
[*] target: assertFalse(isODPSharding)
[-] pred: org. junit. Assert. assertFalse ( isODPSharding )
************************************
************************************
[+] input: exists_Exists_ReturnTrue() { CreateUserReq req = buildCreateUserReq("detail"); User user = userService.create(req);  boolean exists = userService.exists(user.getOrganizationId(), user.getAccountName());  Assert."<AssertPlaceHolder>"; }
exists(Long organizationId, String accountName) { return userRepository.findByOrganizationIdAndAccountName(organizationId, accountName).isPresent(); }
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
************************************
[+] input: generate_modifyPK_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify primary key(id)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<SortColumn> columns = Collections.singletonList(new SortColumn(new ColumnReference(null, null, "id"))); OutOfLineConstraint pk = new OutOfLineConstraint(null, columns); pk.setPrimaryKey(true); expect.setModifyPrimaryKey(pk); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { try (Repository child = cloneRepository(groupADb, true); Repository dest = cloneRepository(db, true)) { StringBuilder xmlContent = new StringBuilder(); xmlContent.append("<?xml version="1.0" encoding="UTF-8"?>\n") .append("<manifest>") .append("<remote name="remote1" fetch=".." />") .append("<default revision="master" remote="remote1" />") .append("<project path="base" name="platform/base" />") .append("</manifest>"); RepoCommand cmd = new RepoCommand(dest);  IndexedRepos repos = new IndexedRepos(); repos.put("platform/base", child);  RevCommit commit = cmd .setInputStream(new ByteArrayInputStream( xmlContent.toString().getBytes(UTF_8))) .setRemoteReader(repos).setURI("platform/") .setTargetURI("platform/superproject") .setRecordRemoteBranch(true).setRecordSubmoduleLabels(true) .call();  String firstIdStr = commit.getId().name() + ":" + ".gitmodules"; commit = new RepoCommand(dest) .setInputStream(new ByteArrayInputStream( xmlContent.toString().getBytes(UTF_8))) .setRemoteReader(repos).setURI("platform/") .setTargetURI("platform/superproject") .setRecordRemoteBranch(true).setRecordSubmoduleLabels(true) .call(); String idStr = commit.getId().name() + ":" + ".gitmodules"; "<AssertPlaceHolder>"; } }
call() throws GitAPIException { checkCallable(); if (baseUri == null) { baseUri = ""; //$NON-NLS-1$ } if (inputStream == null) { if (manifestPath == null || manifestPath.length() == 0) throw new IllegalArgumentException( JGitText.get().pathNotConfigured); try { inputStream = new FileInputStream(manifestPath); } catch (IOException e) { throw new IllegalArgumentException( JGitText.get().pathNotConfigured, e); } }  List<RepoProject> filteredProjects; try { ManifestParser parser = new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo); parser.read(inputStream); filteredProjects = parser.getFilteredProjects(); } catch (IOException e) { throw new ManifestErrorException(e); } finally { try { inputStream.close(); } catch (IOException e) { // Just ignore it, it's not important. } }  if (repo.isBare()) { List<RepoProject> renamedProjects = renameProjects(filteredProjects); BareSuperprojectWriter writer = new BareSuperprojectWriter(repo, targetUri, targetBranch, author == null ? new PersonIdent(repo) : author, callback == null ? new DefaultRemoteReader() : callback, bareWriterConfig, extraContents); return writer.write(renamedProjects); }   RegularSuperprojectWriter writer = new RegularSuperprojectWriter(repo, monitor); return writer.write(filteredProjects); }
[*] target: assertEquals(firstIdStr, idStr)
[-] pred: org. junit. Assert. assertEquals ( firstIdStr, idStr )
************************************
************************************
[+] input: generate_complexStringLiteralExtract_generateSucceed() { ExprContext context = getExprContext("tab.col ->> _UTF8 'str'"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new ConstExpression("_UTF8 'str'"); Expression expect = new CompoundExpression(left, right, Operator.JSON_EXTRACT_UNQUOTED); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_topKFreHistBitExpr_generateFunctionCallSucceed() { ExprContext context = getExprContext("TOP_K_FRE_HIST(1, 1+2, tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); Expression left = new ConstExpression("1"); Expression right = new ConstExpression("2"); params.add(new ExpressionParam(new CompoundExpression(left, right, Operator.ADD))); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("TOP_K_FRE_HIST", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_defaultColumnRef_generateFunctionCallSucceed() { ExprContext context = getExprContext("default(tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("default", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_rangePartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than (maxvalue))," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_noChanges() { final ConnectPacketImpl packet = new ConnectPacketImpl( MqttVersion.V_5, "clientId", false, 100, 60, 3, 1000, 10, true, true, null, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiableConnectPacketImpl modifiablePacket = new ModifiableConnectPacketImpl(packet, configurationService);  final ConnectPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new ConnectPacketImpl(mqttVersion, clientId, cleanStart, sessionExpiryInterval, keepAlive, receiveMaximum, maximumPacketSize, topicAliasMaximum, requestProblemInformation, requestResponseInformation, userName, password, authenticationMethod, authenticationData, (willPublish == null) ? null : willPublish.copy(), userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
************************************
[+] input: generate_uniqueIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext( "unique index idx_name using btree (col asc id 16, col1) global with parser 'aaaa'")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); state.setIndexOptions(indexOptions); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldInstantiateAndConfigureConnectRestExtension() { props.clear(); props.put(RestServerConfig.REST_EXTENSION_CLASSES_CONFIG, TestConnectRestExtension.class.getName()); config = RestServerConfig.forPublic(null, props);  List<ConnectRestExtension> connectRestExtensions = plugins.newPlugins(config.getList(RestServerConfig.REST_EXTENSION_CLASSES_CONFIG), config, ConnectRestExtension.class); "<AssertPlaceHolder>"; assertEquals("One Rest Extension expected", 1, connectRestExtensions.size()); assertNotNull(connectRestExtensions.get(0)); assertTrue("Should be instance of TestConnectRestExtension", connectRestExtensions.get(0) instanceof TestConnectRestExtension); assertNotNull(((TestConnectRestExtension) connectRestExtensions.get(0)).configs); assertEquals(config.originals(), ((TestConnectRestExtension) connectRestExtensions.get(0)).configs); }
newPlugins(List<String> klassNames, AbstractConfig config, Class<T> pluginKlass) { List<T> plugins = new ArrayList<>(); if (klassNames != null) { for (String klassName : klassNames) { plugins.add(newPlugin(klassName, config, pluginKlass)); } } return plugins; }
[*] target: assertNotNull(connectRestExtensions)
[-] pred: org. junit. Assert. assertNotNull ( connectRestExtensions )
************************************
************************************
[+] input: generate_depthFirstSearch_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name (col1, col2) as (select * from dual) search depth first by col2 desc, col3 asc set varname select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); expect.setSearchMode(SearchMode.DEPTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldCreateWriteBatches() { final String key = "a"; final Collection<ConsumerRecord<byte[], byte[]>> records = new ArrayList<>(); records.add(new ConsumerRecord<>("", 0, 0L, serializeKey(new Windowed<>(key, windows[0]), true).get(), serializeValue(50L))); records.add(new ConsumerRecord<>("", 0, 0L, serializeKey(new Windowed<>(key, windows[3]), true).get(), serializeValue(100L))); final Map<S, WriteBatch> writeBatchMap = bytesStore.getWriteBatches(records); "<AssertPlaceHolder>";  final int expectedCount = getIndexSchema() == null ? 1 : 2; for (final WriteBatch batch : writeBatchMap.values()) { // 2 includes base and index record assertEquals(expectedCount, batch.count()); } }
getWriteBatches(final Collection<ConsumerRecord<byte[], byte[]>> records);  @Override public Position getPosition() { return position; }
[*] target: assertEquals(2, writeBatchMap.size())
[-] pred: org. junit. Assert. assertEquals ( 2, writeBatchMap. size ( ) )
************************************
************************************
[+] input: Exception { final File file = testKeyStoreGenerator.generateKeyStore("teststore", "JKS", "passwd1", "passwd2"); final String keystorePath = file.getAbsolutePath();   final Tls tls = new Tls.Builder() .withKeystorePath(keystorePath) .withKeystoreType("JKS") .withKeystorePassword("passwd1") .withPrivateKeyPassword("passwd2") .withProtocols(new ArrayList<>()) .withTruststorePath(keystorePath) .withTruststoreType("JKS") .withTruststorePassword("passwd1") .withClientAuthMode(Tls.ClientAuthMode.OPTIONAL) .withCipherSuites(new ArrayList<>()) .withHandshakeTimeout(10000) .build();   final SslContext sslContext1 = sslFactory.getSslContext(tls); final SslContext sslContext2 = sslFactory.getSslContext(tls);  "<AssertPlaceHolder>"; }
getSslContext(final @NotNull Tls tls) throws SslException { return sslContextStore.getAndInitAsync(tls); }
[*] target: assertEquals(sslContext1, sslContext2)
[-] pred: org. junit. Assert. assertEquals ( sslContext1, sslContext2 )
************************************
************************************
[+] input: test_exists_exist() { MaskingAlgorithm algorithm = createAlgorithm("test_exists", MaskingAlgorithmType.MASK, null); service.create(algorithm); Boolean exist = service.exists(algorithm.getName()); Assert."<AssertPlaceHolder>"; }
exists(@NotBlank String name) { MaskingAlgorithmEntity entity = new MaskingAlgorithmEntity(); entity.setName(name); entity.setOrganizationId(authenticationFacade.currentOrganizationId()); return algorithmRepository.exists(Example.of(entity)); }
[*] target: assertTrue(exist)
[-] pred: org. junit. Assert. assertTrue ( exist )
************************************
************************************
[+] input: testMemberLeave() { Member member = Member.builder().ip("1.1.3.3").port(8848).state(NodeState.DOWN).build(); boolean joinResult = serverMemberManager.memberJoin(Collections.singletonList(member)); assertTrue(joinResult);  List<String> ips = serverMemberManager.getServerListUnhealth(); assertEquals(1, ips.size());  boolean result = serverMemberManager.memberLeave(Collections.singletonList(member)); "<AssertPlaceHolder>"; }
memberLeave(Collection<Member> members) { Set<Member> set = new HashSet<>(allMembers()); set.removeAll(members); return memberChange(set); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: generate_addListPartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("add partition (partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1);  expect.setAddPartitionElements(Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: createShouldReturnFalseWhenSuppliedNullTopicDescription() { Cluster cluster = createCluster(1); try (TopicAdmin admin = new TopicAdmin(new MockAdminClient(cluster.nodes(), cluster.nodeById(0)))) { boolean created = admin.createTopic(null); "<AssertPlaceHolder>"; } }
createTopic(NewTopic topic) { if (topic == null) return false; Set<String> newTopicNames = createTopics(topic); return newTopicNames.contains(topic.name()); }
[*] target: assertFalse(created)
[-] pred: org. junit. Assert. assertFalse ( created )
************************************
************************************
[+] input: testInstance() { EncryptionPluginManager instance = EncryptionPluginManager.instance(); Assert."<AssertPlaceHolder>"; }
instance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
************************************
[+] input: testInitNamespaceFromPropNamespaceWithCloudParsing() { final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); String expect = "ns1"; properties.setProperty(PropertyKeyConst.NAMESPACE, expect); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
initNamespaceForNaming(NacosClientProperties properties) { String tmpNamespace = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) {  tmpNamespace = TenantUtil.getUserTenantForAns(); LogUtils.NAMING_LOGGER.info("initializer namespace from ans.namespace attribute : {}", tmpNamespace);  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from ALIBABA_ALIWARE_NAMESPACE attribute :" + namespace); return namespace; }); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getPropertyFrom(SourceType.JVM, PropertyKeyConst.NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from namespace attribute :" + namespace); return namespace; });  if (StringUtils.isEmpty(tmpNamespace)) { tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> UtilAndComs.DEFAULT_NAMESPACE_ID); return tmpNamespace; }
[*] target: assertEquals(expect, ns)
[-] pred: org. junit. Assert. assertEquals ( expect, ns )
************************************
************************************
[+] input: generate_uniqueIndexColumnAscIdNoUsingBtree_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("unique index (col asc id 16, col1)")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineConstraint expect = new OutOfLineConstraint(null, Arrays.asList(s1, s2)); expect.setUniqueKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_withAliasList_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext("WITH relation_name (col1, col2) as (select * from dual) select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_deleteWithWhereClauseCursor_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab where current of tab.col"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); RelationReference left = new RelationReference("tab", new RelationReference("col", null)); expect.setWhere(left); expect.setCursor(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testParseSquashFixupSequenceCount() { int count = RebaseCommand .parseSquashFixupSequenceCount("# This is a combination of 3 commits.\n# newline"); "<AssertPlaceHolder>"; }
parseSquashFixupSequenceCount(String currSquashMessage) { String regex = "This is a combination of (.*) commits"; //$NON-NLS-1$ String firstLine = currSquashMessage.substring(0, currSquashMessage.indexOf('\n')); Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(firstLine); if (!matcher.find()) throw new IllegalArgumentException(); return Integer.parseInt(matcher.group(1)); }
[*] target: assertEquals(3, count)
[-] pred: org. junit. Assert. assertEquals ( 3, count )
************************************
************************************
[+] input: testDerbySqlCorrect() { final String testSql = "INSERT INTO `config_info` (`id`, `data_id`, `group_id`, `content`, `md5`, `gmt_create`, `gmt_modified`, `src_user`, `src_ip`, `app_name`, `tenant_id`, `c_desc`, `c_use`, `effect`, `type`, `c_schema`) VALUES (1,'boot-test','ALIBABA','dept:123123123\\ngroup:123123123','2ca50d002a7dabf81497f666a7967e15','2020-04-13 13:44:43','2020-04-30 10:45:21',NULL,'127.0.0.1','','',NULL,NULL,NULL,NULL,NULL);"; final String result = DerbyUtils.insertStatementCorrection(testSql);  final String expect = "INSERT INTO CONFIG_INFO (ID, DATA_ID, GROUP_ID, CONTENT, MD5, GMT_CREATE, GMT_MODIFIED, SRC_USER, SRC_IP, APP_NAME, TENANT_ID, C_DESC, C_USE, EFFECT, TYPE, C_SCHEMA) VALUES (1,'boot-test','ALIBABA','dept:123123123\\ngroup:123123123','2ca50d002a7dabf81497f666a7967e15','2020-04-13 13:44:43','2020-04-30 10:45:21',NULL,'127.0.0.1','','',NULL,NULL,NULL,NULL,NULL)"; Assert."<AssertPlaceHolder>"; }
insertStatementCorrection(String sql) { Matcher matcher = INSERT_INTO_PATTERN.matcher(sql); if (!matcher.find()) { return sql; } final String target = matcher.group(0); final String upperCase = target.toUpperCase().replace("`", ""); return sql.replaceFirst(INSERT_INTO_VALUES, upperCase).replace(";", ""); }
[*] target: assertEquals(expect, result)
[-] pred: org. junit. Assert. assertEquals ( expect, result )
************************************
************************************
[+] input: testGetWithPrefixNotFound() { Map<String, String> result = tree.getWithPrefix("cheese"); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: generate_functionNameExprAsListAsString_generateFunctionCallSucceed() { ExprContext context = getExprContext("function_name(tab.col as 'new_label')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); ExpressionParam p = new ExpressionParam(new ColumnReference(null, "tab", "col")); p.addOption(new ConstExpression("'new_label'")); params.add(p); FunctionCall expect = new FunctionCall("function_name", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_withColumnGroup_customGroup_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(g1(id))"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); List<String> columnNames = Collections.singletonList("id"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement("g1", columnNames))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testListConnectorPlugins() { Set<PluginInfo> expectedConnectorPlugins = Stream.of(SINK_CONNECTOR_PLUGINS, SOURCE_CONNECTOR_PLUGINS) .flatMap(Collection::stream) .map(PluginInfo::new) .collect(Collectors.toSet()); Set<PluginInfo> actualConnectorPlugins = new HashSet<>(connectorPluginsResource.listConnectorPlugins(true)); "<AssertPlaceHolder>"; verify(herder, atLeastOnce()).plugins(); }
listConnectorPlugins( @DefaultValue("true") @QueryParam("connectorsOnly") @Parameter(description = "Whether to list only connectors instead of all plugins") boolean connectorsOnly ) { synchronized (this) { if (connectorsOnly) { return Collections.unmodifiableList(connectorPlugins.stream() .filter(p -> PluginType.SINK.toString().equals(p.type()) || PluginType.SOURCE.toString().equals(p.type())) .collect(Collectors.toList())); } else { return Collections.unmodifiableList(new ArrayList<>(connectorPlugins)); } } }
[*] target: assertEquals(expectedConnectorPlugins, actualConnectorPlugins)
[-] pred: org. junit. Assert. assertEquals ( expectedConnectorPlugins, actualConnectorPlugins )
************************************
************************************
[+] input: JsonProcessingException { String json = "{"supportRemoteConnection":true,"grpcReportEnabled":true}"; ServerRemoteAbility abilities = mapper.readValue(json, ServerRemoteAbility.class); assertTrue(abilities.isSupportRemoteConnection()); "<AssertPlaceHolder>"; }
isGrpcReportEnabled() { return grpcReportEnabled; }
[*] target: assertTrue(abilities.isGrpcReportEnabled())
[-] pred: org. junit. Assert. assertTrue ( abilities. isGrpcReportEnabled() )
************************************
************************************
[+] input: generate_trim_generateFunctionCallSucceed() { ExprContext context = getExprContext("trim(both '123' from 'abc')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'123'")); p.addOption(new ConstExpression("'abc'")); params.add(p); FunctionCall expect = new FunctionCall("trim", params); expect.addOption(new ConstExpression("both")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_accessFuncWith_a_member_of_b_Pri_generate_FunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(a member of b)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  CompoundExpression expr = new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.MEMBER_OF); ExpressionParam param1 = new ExpressionParam(expr); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testIdentical() { //given String ak = "ak"; String sk = "sk"; String tenantId = "100"; Credentials credentials1 = new Credentials(ak, sk, "101"); Credentials credentials2 = new Credentials(ak, sk, "100"); //then boolean actual = credentials1.identical(credentials2); //then Assert."<AssertPlaceHolder>"; }
identical(Credentials other) { return this == other || (other != null && (accessKey == null && other.accessKey == null || accessKey != null && accessKey.equals(other.accessKey)) && ( secretKey == null && other.secretKey == null || secretKey != null && secretKey .equals(other.secretKey))); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: generate_dotKeywordKeyword_generateSucceed() { ExprContext context = getExprContext(".BEFORE.BEFORE"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference(null, "BEFORE", "BEFORE"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testProject() { boolean rst = RuleRunner.getInstance() .check( new HashMap<>(), Lists.newArrayList("R1 = 1 == 1", "R2 = 10 > 9", "R1 && R2"), ""); Assert."<AssertPlaceHolder>"; }
getInstance() { if (null != instance) { return instance; } synchronized (RuleRunner.class) { if (null == instance) { RuleRunner runner = new RuleRunner(); runner.init(); instance = runner; } } return instance; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
************************************
[+] input: testDetailConfigHistory() { long nid = 256789;  //mock query ConfigHistoryInfo mockConfigHistoryInfo = createMockConfigHistoryInfo(0); Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {nid}), eq(HISTORY_DETAIL_ROW_MAPPER))) .thenReturn(mockConfigHistoryInfo); //execute & verify ConfigHistoryInfo historyReturn = embeddedHistoryConfigInfoPersistService.detailConfigHistory(nid); Assert."<AssertPlaceHolder>"; }
detailConfigHistory(Long nid) { HistoryConfigInfoMapper historyConfigInfoMapper = mapperManager.findMapper( dataSourceService.getDataSourceType(), TableConstant.HIS_CONFIG_INFO); String sqlFetchRows = historyConfigInfoMapper.select( Arrays.asList("nid", "data_id", "group_id", "tenant_id", "app_name", "content", "md5", "src_user", "src_ip", "op_type", "gmt_create", "gmt_modified", "encrypted_data_key"), Collections.singletonList("nid")); return databaseOperate.queryOne(sqlFetchRows, new Object[] {nid}, HISTORY_DETAIL_ROW_MAPPER); }
[*] target: assertEquals(mockConfigHistoryInfo, historyReturn)
[-] pred: org. junit. Assert. assertEquals ( mockConfigHistoryInfo, historyReturn )
************************************
************************************
[+] input: IOException { String msg = "test buff to string"; ByteBuffer buff = ByteBuffer.wrap(msg.getBytes(StandardCharsets.UTF_8)); String actual = ConcurrentDiskUtil.byteBufferToString(buff, "UTF-8"); Assert."<AssertPlaceHolder>"; }
byteBufferToString(ByteBuffer buffer, String charsetName) throws IOException { Charset charset = Charset.forName(charsetName); CharsetDecoder decoder = charset.newDecoder(); CharBuffer charBuffer = decoder.decode(buffer.asReadOnlyBuffer()); return charBuffer.toString(); }
[*] target: assertEquals(msg, actual)
[-] pred: org. junit. Assert. assertEquals ( msg, actual )
************************************
************************************
[+] input: generate_hashPartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) subpartition by hash(c) subpartitions 165 partitions 12 (" + "partition a.b@c (" + "subpartition a.b pctfree=13," + "subpartition b pctused 14)," + "partition d id 14) noCompress")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); PartitionOptions o1 = new PartitionOptions(); o1.setPctFree(13); se1.setPartitionOptions(o1); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setPctUsed(14); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o7 = new PartitionOptions(); o7.setId(14); e2.setPartitionOptions(o7); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "hash"); subPartitionOption.setSubPartitionNum(165); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2), subPartitionOption, 12); PartitionOptions o3 = new PartitionOptions(); o3.setNoCompress(true); expect.setPartitionOptions(o3); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_deleteWithWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab where col=100"); StatementFactory<Delete> factory = new OracleDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); RelationReference left = new RelationReference("col", null); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: getTsFilePrefixPathTest() { String tsFilePrefixPath = FilePathUtils.getTsFilePrefixPath(tsFile.getAbsolutePath()); String exceptPrefixPath = storageGroupName + File.separator + dataRegionId + File.separator + partitionId; Assert."<AssertPlaceHolder>"; }
getTsFilePrefixPath(String tsFileAbsolutePath) { if (tsFileAbsolutePath == null) { return null; } String[] pathSegments = splitTsFilePath(tsFileAbsolutePath); int pathLength = pathSegments.length; return pathSegments[pathLength - 4] + File.separator + pathSegments[pathLength - 3] + File.separator + pathSegments[pathLength - 2]; }
[*] target: assertEquals(exceptPrefixPath, tsFilePrefixPath)
[-] pred: org. junit. Assert. assertEquals ( exceptPrefixPath, tsFilePrefixPath )
************************************
************************************
[+] input: shouldGetAllStreamInstances() { final StreamsMetadata one = new StreamsMetadataImpl(hostOne, mkSet(globalTable, "table-one", "table-two", "merged-table"), mkSet(topic1P0, topic2P1, topic4P0), mkSet("table-one", "table-two", "merged-table"), mkSet(topic2P0, topic1P1)); final StreamsMetadata two = new StreamsMetadataImpl(hostTwo, mkSet(globalTable, "table-two", "table-one", "merged-table"), mkSet(topic2P0, topic1P1), mkSet("table-three"), mkSet(topic3P0)); final StreamsMetadata three = new StreamsMetadataImpl(hostThree, mkSet(globalTable, "table-three"), Collections.singleton(topic3P0), mkSet("table-one", "table-two", "merged-table"), mkSet(topic1P0, topic2P1, topic4P0));  final Collection<StreamsMetadata> actual = metadataState.getAllMetadata(); "<AssertPlaceHolder>"; assertTrue("expected " + actual + " to contain " + one, actual.contains(one)); assertTrue("expected " + actual + " to contain " + two, actual.contains(two)); assertTrue("expected " + actual + " to contain " + three, actual.contains(three)); }
getAllMetadata() { return Collections.unmodifiableList(allMetadata); }
[*] target: assertEquals(3, actual.size())
[-] pred: org. junit. Assert. assertEquals ( 3, actual. size ( ) )
************************************
************************************
[+] input: Exception { final String storeDirectoryPath = stateDirectory.getAbsolutePath() + File.separator + storeName; final File storeDirectory = new File(storeDirectoryPath); //noinspection ResultOfMethodCallIgnored storeDirectory.mkdirs();  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final File oldSegment = new File(storeDirectoryPath + File.separator + storeName + ":" + segmentId * (RETENTION_PERIOD / (NUM_SEGMENTS - 1))); //noinspection ResultOfMethodCallIgnored Files.createFile(oldSegment.toPath()); }  segments.openExisting(context, -1L);  for (int segmentId = 0; segmentId < NUM_SEGMENTS; ++segmentId) { final File newSegment = new File(storeDirectoryPath + File.separator + storeName + "." + segmentId * (RETENTION_PERIOD / (NUM_SEGMENTS - 1))); "<AssertPlaceHolder>"; } }
openExisting(final ProcessorContext context, final long streamTime) { metricsRecorder.init(ProcessorContextUtils.getMetricsImpl(context), context.taskId()); super.openExisting(context, streamTime); }
[*] target: assertTrue(newSegment.exists())
[-] pred: org. junit. Assert. assertTrue ( newSegment. exists ( ) )
************************************
************************************
[+] input: Exception { RevCommit parent; RevCommit head; try (Git git = new Git(db)) { writeTrashFile("foo.txt", "foo\n"); writeTrashFile("src/some.txt", "some\n"); writeTrashFile("src/image.png", "image\n"); writeTrashFile("src/test.pdf", "test\n"); writeTrashFile("src/xyz.txt", "xyz\n"); git.add().addFilepattern(".").call(); parent = git.commit().setMessage("initial").call(); writeTrashFile("foo.txt", "FOO\n"); writeTrashFile("src/some.txt", "SOME\n"); writeTrashFile("src/image.png", "IMAGE\n"); writeTrashFile("src/test.pdf", "TEST\n"); writeTrashFile("src/xyz.txt", "XYZ\n"); git.add().addFilepattern(".").call(); head = git.commit().setMessage("second").call(); } try (ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(os)) { dfmt.setRepository(db); List<TreeFilter> skip = new ArrayList<>(); skip.add(PathSuffixFilter.create(".png")); skip.add(PathSuffixFilter.create(".pdf")); dfmt.setPathFilter(OrTreeFilter.create(skip).negate()); dfmt.format( new CanonicalTreeParser(null, db.newObjectReader(), parent.getTree()), new CanonicalTreeParser(null, db.newObjectReader(), head.getTree())); dfmt.flush();  String actual = os.toString("UTF-8");  String expected = "diff --git a/foo.txt b/foo.txt\n" + "index 257cc56..b7d6715 100644\n" + "--- a/foo.txt\n" + "+++ b/foo.txt\n" + "@@ -1 +1 @@\n" + "-foo\n" + "+FOO\n" + "diff --git a/src/some.txt b/src/some.txt\n" + "index 363ef61..76cea5f 100644\n" + "--- a/src/some.txt\n" + "+++ b/src/some.txt\n" + "@@ -1 +1 @@\n" + "-some\n" + "+SOME\n" + "diff --git a/src/xyz.txt b/src/xyz.txt\n" + "index cd470e6..d4e3ab0 100644\n" + "--- a/src/xyz.txt\n" + "+++ b/src/xyz.txt\n" + "@@ -1 +1 @@\n" + "-xyz\n" + "+XYZ\n";  "<AssertPlaceHolder>"; } }
flush() throws IOException { out.flush(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: IOException { ResourceManager manager = getResourceManager(); ResourceSpec defaultEntity = getDefaultResourceEntity(manager);  TableTemplate entity = defaultEntity.getTemplates().get(0); List<DataRecord> permissions = getDataRecords(defaultEntity, manager, entity); Assert.assertEquals(1, permissions.size());  DataRecord permission = permissions.get(0); DataRecordRepository repository = new DataRecordRepository(dataSource); Assert.assertFalse(repository.exists(permission)); repository.save(permission); Assert."<AssertPlaceHolder>"; }
exists(@NonNull DataRecord record) { List<DataSpec> conditions = record.getUniqueKeyData(); String sql = generateSelectSql(record.getTableName(), "COUNT(1)", conditions); List<Long> result = query(sql, conditions, (resultSet, i) -> resultSet.getLong(1)); Verify.singleton(result, "Count(1) has to be singleton"); return result.get(0) >= 1; }
[*] target: assertTrue(repository.exists(permission))
[-] pred: org. junit. Assert. assertTrue ( repository. exists ( permission ) )
************************************
************************************
[+] input: loadProperties_WithEncryptedValue() { Map<String, String> load = EncryptableConfigurations.loadProperties(TEST_CONFIG_FILE);  Map<String, String> expected = new HashMap<>(); expected.put("key1", "oceanbase developer center"); expected.put("key2", "build the best database develop platform");  Assert."<AssertPlaceHolder>"; }
loadProperties(String path) { encryptFileIfRequires(path); File file = new File(path); PropertiesConfiguration config = new PropertiesConfiguration(); PropertiesConfigurationLayout layout = new PropertiesConfigurationLayout(); try { layout.load(config, new FileReader(file)); } catch (ConfigurationException | FileNotFoundException e) { throw new RuntimeException("load properties file failed:", e); } Map<String, String> properties = new HashMap<>(); Set<String> keys = layout.getKeys(); for (String key : keys) { String value = config.getProperty(key).toString(); value = decryptIfRequired(value); properties.put(key, value); } return properties; }
[*] target: assertEquals(expected, load)
[-] pred: org. junit. Assert. assertEquals ( expected, load )
************************************
************************************
[+] input: testFailWorkflowWithInputPayload() { WorkflowModel workflow = new WorkflowModel(); workflow.setInput(new HashMap<>());  expectedException.expect(TerminateWorkflowException.class); externalPayloadStorageUtils.failWorkflow( workflow, ExternalPayloadStorage.PayloadType.TASK_INPUT, "error"); "<AssertPlaceHolder>"; assertTrue(workflow.getInput().isEmpty()); assertEquals(WorkflowModel.Status.FAILED, workflow.getStatus()); }
failWorkflow(WorkflowModel workflow, PayloadType payloadType, String errorMsg) { LOGGER.error(errorMsg); if (payloadType == PayloadType.WORKFLOW_INPUT) { workflow.setInput(new HashMap<>()); } else { workflow.setOutput(new HashMap<>()); } throw new TerminateWorkflowException(errorMsg); }
[*] target: assertNotNull(workflow)
[-] pred: org. junit. Assert. assertNotNull ( workflow )
************************************
************************************
[+] input: Exception { String str = "http://example.com/"; URIish u = new URIish(str); assertEquals("example.com", u.getHost()); assertEquals("/", u.getPath()); assertEquals(str, u.toString());  str = "http://example.com"; u = new URIish(str); assertEquals("example.com", u.getHost()); assertEquals("", u.getPath()); "<AssertPlaceHolder>"; }
toString() { return format(false, false); }
[*] target: assertEquals(str, u.toString())
[-] pred: org. junit. Assert. assertEquals ( str, u. toString ( ) )
************************************
************************************
[+] input: generate_listPartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list columns (a,b) subpartition by list columns(c,f) (" + "partition a.b values in (default) (" + "subpartition a.b values in (2)," + "subpartition b values in ('maxvalue'))," + "partition d values in (3) id 14," + "partition f values in ('aaaddd') id 15)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); ListPartitionElement e3 = new ListPartitionElement("f", Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions o2 = new PartitionOptions(); o2.setId(15); e3.setPartitionOptions(o2); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); SubPartitionOption subPartitionOption = new SubPartitionOption( Arrays.asList(new ColumnReference(null, null, "c"), new ColumnReference(null, null, "f")), "list columns"); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2, e3), subPartitionOption, null, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: existsByNameAndProjectId_checkTemplateExist_succeed() { create(); Boolean result = templateRepository.existsByNameAndProjectId(TEMPLATE_NAME, PROJECT_ID); "<AssertPlaceHolder>"; }
existsByNameAndProjectId(String name, Long projectId);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { //        LogStorageData logStorageData = new LogStorageData(); //        logStorageData.setClusterId(120002L); //        logStorageData.setStoreId(10005L); //        logStorageData.setLogStoreName("测试logStore存储"); //        boolean table = dorisLogStorageService.deleteTable(logStorageData); //        Assert."<AssertPlaceHolder>"; //    }
deleteTable(LogStorageData storageData) { String tableName = buildTableName(storageData.getClusterId(), storageData.getStoreId()); DataSource dataSource = Ioc.ins().getBean(Constant.LOG_STORAGE_SERV_BEAN_PRE + storageData.getClusterId());  try (Statement statement = dataSource.getConnection().createStatement()) {  String createTableGrammar = String.format(DELETE_TABLE_FORMAT, tableName); statement.execute(createTableGrammar);  } // Automatically closes statement catch (SQLException e) { throw new MilogManageException("deleteTable error:" + e.getMessage()); } deleteLogStorageTable(storageData, tableName); return true; }
[*] target: assertTrue(table)
[-] pred: org. junit. Assert. assertTrue ( table )
************************************
************************************
[+] input: createIfNotExists_NotExists_ReturnNotNull() { Organization created = organizationService.createIfNotExists("123", "name123"); Assert."<AssertPlaceHolder>"; }
createIfNotExists(@NotBlank String identifier, @NotBlank String name) { return getByIdentifier(identifier).orElseGet(() -> { Organization organization = new Organization(); organization.setName(name); organization.setUniqueIdentifier(identifier); organization.setDescription("Auto created by identifier " + identifier); organization.setBuiltin(false); organization.setType(OrganizationType.TEAM); return create(organization); }); }
[*] target: assertNotNull(created)
[-] pred: org. junit. Assert. assertNotNull ( created )
************************************
************************************
[+] input: IOException { ZipFileTree zipFileTree = new ZipFileTree(getTestZipFile()); List<ZipElement> elementList = zipFileTree.filter(element -> !element.isDirectory()); List<String> urls = elementList.stream().map(element -> element.getUrl().getPath()).collect(Collectors.toList());  for (String url : urls) { boolean res = url.endsWith("test.zip") || url.endsWith("CHECKPOINT.bin") || url.endsWith("MANIFEST.bin") || url.endsWith("TEST-schema.sql") || url.endsWith("TEST.0.0.sql"); Assert."<AssertPlaceHolder>"; } }
filter(@NonNull Predicate<ZipElement> predicate) { return innerFilterEntryNode(e -> predicate.test(e.getContent())).stream().map( ZipElementNode::getContent).collect(Collectors.toList()); }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: testListAllPlugins() { List<PluginInfo> expectedConnectorPlugins = Stream.of( SINK_CONNECTOR_PLUGINS, SOURCE_CONNECTOR_PLUGINS, CONVERTER_PLUGINS, HEADER_CONVERTER_PLUGINS, TRANSFORMATION_PLUGINS, PREDICATE_PLUGINS ).flatMap(Collection::stream) .map(PluginInfo::new) .distinct() .collect(Collectors.toList()); List<PluginInfo> actualConnectorPlugins = new ArrayList<>(connectorPluginsResource.listConnectorPlugins(false)); Comparator<PluginInfo> compare = Comparator.comparing(PluginInfo::className) .thenComparing(PluginInfo::type) .thenComparing(PluginInfo::version); actualConnectorPlugins.sort(compare); expectedConnectorPlugins.sort(compare); "<AssertPlaceHolder>"; verify(herder, atLeastOnce()).plugins(); }
listConnectorPlugins( @DefaultValue("true") @QueryParam("connectorsOnly") @Parameter(description = "Whether to list only connectors instead of all plugins") boolean connectorsOnly ) { synchronized (this) { if (connectorsOnly) { return Collections.unmodifiableList(connectorPlugins.stream() .filter(p -> PluginType.SINK.toString().equals(p.type()) || PluginType.SOURCE.toString().equals(p.type())) .collect(Collectors.toList())); } else { return Collections.unmodifiableList(new ArrayList<>(connectorPlugins)); } } }
[*] target: assertEquals(expectedConnectorPlugins, actualConnectorPlugins)
[-] pred: org. junit. Assert. assertEquals ( expectedConnectorPlugins, actualConnectorPlugins )
************************************
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> a = new HttpRestResult<Object>(); a.setData("{"status":"UP"}"); a.setCode(200); when(nacosRestTemplate.exchangeForm(any(), any(), any(), any(), any(), any())).thenReturn(a);  final Field nacosRestTemplateField = NamingHttpClientProxy.class.getDeclaredField("nacosRestTemplate"); nacosRestTemplateField.setAccessible(true); nacosRestTemplateField.set(clientProxy, nacosRestTemplate);  //when boolean serverHealthy = clientProxy.serverHealthy(); //then verify(nacosRestTemplate, times(1)) .exchangeForm(endsWith("/operator/metrics"), any(), any(), any(), eq(HttpMethod.GET), any()); Assert."<AssertPlaceHolder>"; }
serverHealthy() { try { String result = reqApi(UtilAndComs.nacosUrlBase + "/operator/metrics", new HashMap<>(8), HttpMethod.GET); JsonNode json = JacksonUtils.toObj(result); String serverStatus = json.get("status").asText(); return "UP".equals(serverStatus); } catch (Exception e) { return false; } }
[*] target: assertTrue(serverHealthy)
[-] pred: org. junit. Assert. assertTrue ( serverHealthy )
************************************
************************************
[+] input: IOException { Properties properties = ResourceUtils.getResourceAsProperties("resource_utils_test.properties"); "<AssertPlaceHolder>"; assertTrue(properties.containsKey("a")); }
getResourceAsProperties(String resource) throws IOException { ClassLoader loader = ResourceUtils.class.getClassLoader(); return getResourceAsProperties(loader, resource); }
[*] target: assertNotNull(properties)
[-] pred: org. junit. Assert. assertNotNull ( properties )
************************************
************************************
[+] input: connectorConfig() { final String connName = "sink6"; final Map<String, String> expectedConfig = Collections.singletonMap("key", "value");  @SuppressWarnings("unchecked") ArgumentCaptor<Callback<Map<String, String>>> callback = ArgumentCaptor.forClass(Callback.class); doAnswer(invocation -> { callback.getValue().onCompletion(null, expectedConfig); return null; }).when(herder).connectorConfig(eq(connName), callback.capture());  Map<String, String> actualConfig = connectClusterState.connectorConfig(connName);  "<AssertPlaceHolder>"; assertNotSame( "Config should be copied in order to avoid mutation by REST extensions", expectedConfig, actualConfig ); }
connectorConfig(String connName) { FutureCallback<Map<String, String>> connectorConfigCallback = new FutureCallback<>(); herder.connectorConfig(connName, connectorConfigCallback); try { return new HashMap<>(connectorConfigCallback.get(herderRequestTimeoutMs, TimeUnit.MILLISECONDS)); } catch (InterruptedException | ExecutionException | TimeoutException e) { throw new ConnectException( String.format("Failed to retrieve configuration for connector '%s'", connName), e ); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: createOKHttpClient() { OkHttpClient okHttpClient = WebUtils.okHttpClientWithTimeout(Duration.ofMinutes(10)); Assert."<AssertPlaceHolder>"; int timeout = okHttpClient.callTimeoutMillis(); Assert.assertEquals(10 * 60 * 1000, timeout); }
okHttpClientWithTimeout(Duration timeout) { log.info("Creating OkHttpClient with timeout {}", timeout); OkHttpClient client = new OkHttpClient.Builder() .callTimeout(timeout) .readTimeout(timeout) .connectTimeout(timeout) .build(); log.info("OkHttpClient created"); return client; }
[*] target: assertNotNull(okHttpClient)
[-] pred: org. junit. Assert. assertNotNull ( okHttpClient )
************************************
************************************
[+] input: generate_starProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select * from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testWeightFilterSampleByTimestamp() { AbstractResult indexResult = new RangeResult(weightIndex, Collections.singletonList(new RangeUnit(1, 8)));  String sampleMeta = "topk(by=time, limit=5, reverse=false, replacement=false)"; TopKSampler<Long> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(8, 7, 6, 5, 4);  "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: convertBinaryToInvisibleStringTest() { Log.i(TAG, "------------ convertBinaryToInvisibleStringTest: ------------"); String binaryMessage = EncodeHelper.convertByteArrayToBinary(loremMessage.getBytes(StandardCharsets.UTF_8)); String invisibleResult = EncodeHelper.convertBinaryToInvisibleString(binaryMessage); "<AssertPlaceHolder>"; }
convertBinaryToInvisibleString(String binaryString) { StringBuilder result = new StringBuilder(); StringBuilder resultUnicode = new StringBuilder();  for (int i = 0; i < binaryString.length(); i += 4) { final int startInclusive = i; final int endExclusive = i + 4;  if (endExclusive >= binaryString.length() + 1) continue; String binaryDigits = binaryString.substring(startInclusive, endExclusive);  switch (binaryDigits) { case "0000": result.append("\u200C"); resultUnicode.append("\\u200C"); break; case "0001": result.append("\u200D"); resultUnicode.append("\\u200D"); break; case "0010": result.append("\u2060"); resultUnicode.append("\\u2060"); break; case "0011": result.append("\u2062"); resultUnicode.append("\\u2062"); break;  case "0100": result.append("\u200B"); resultUnicode.append("\\u200B"); break; case "0101": result.append("\u200E"); resultUnicode.append("\\u200E"); break; case "0110": result.append("\u200F"); resultUnicode.append("\\u200F"); break; case "0111": result.append("\u2064"); resultUnicode.append("\\u2064"); break;  case "1000": result.append("\u206A"); resultUnicode.append("\\u206A"); break; case "1001": result.append("\u206B"); resultUnicode.append("\\u206B"); break; case "1010": result.append("\u206C"); resultUnicode.append("\\u206C"); break; case "1011": result.append("\u206D"); resultUnicode.append("\\u206D"); break;  case "1100": result.append("\u206E"); resultUnicode.append("\\u206E"); break; case "1101": result.append("\u206F"); resultUnicode.append("\\u206F"); break; case "1110": result.append("\uFEFF"); resultUnicode.append("\\uFEFF"); break; case "1111": result.append("\u061C"); resultUnicode.append("\\u061C"); break; } }  Log.d(TAG, String.valueOf(resultUnicode)); return result.toString(); }
[*] target: assertNotNull(invisibleResult)
[-] pred: org. junit. Assert. assertNotNull ( invisibleResult )
************************************
************************************
[+] input: update_updateUser_updateSucceed() { UserInfo expect = TestRandom.nextObject(UserInfo.class); userDAO.insert(expect); expect = userDAO.detail(expect.getEmail()); expect.setName("new name"); expect.setPassword("new password"); expect.setRole("new role"); expect.setStatus(expect.getStatus() + 10); expect.setDesc("new desc"); expect.setCipher(Cipher.BCRYPT); userDAO.update(expect); UserInfo actual = userDAO.get(expect.getId()); Assert."<AssertPlaceHolder>"; }
get(long id);
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetOrCreateLocalFile_Success() { MultipartFile mockFile = new MockMultipartFile("some-file", "some-file", null, new byte[10]); localFileOperator.saveLocalFile(BUCKET, mockFile.getOriginalFilename(), mockFile.getSize(), mockFile.getInputStream()); File file = localFileOperator.getOrCreateLocalFile(BUCKET, "some-file"); "<AssertPlaceHolder>"; assertTrue(file.exists()); }
getOrCreateLocalFile(String bucketName, String objectId) { Verify.notEmpty(bucketName, "bucketName"); Verify.notEmpty(objectId, "objectId"); PreConditions.validNoPathTraversal(generateFilePath(bucketName, objectId), generateFilePath(bucketName)); File file = new File(absolutePathName(bucketName, objectId)); createParentDirs(file); return file; }
[*] target: assertNotNull(file)
[-] pred: org. junit. Assert. assertNotNull ( file )
************************************
************************************
[+] input: getStatement_selectOracleMode_getSelectStmt() { AbstractSyntaxTreeFactory factory = AbstractSyntaxTreeFactories.getAstFactory(DialectType.OB_ORACLE, 0); AbstractSyntaxTree ast = factory.buildAst("select col.* abc from dual"); Statement actual = ast.getStatement(); RelationReference r = new RelationReference("col", new RelationReference("*", null)); Projection p = new Projection(r, "abc"); NameReference from = new NameReference(null, "dual", null); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); Assert."<AssertPlaceHolder>"; }
getStatement();
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_noChanges() { final PubcompPacketImpl packet = new PubcompPacketImpl( 1, PubcompReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubcompPacketImpl modifiablePacket = new ModifiablePubcompPacketImpl(packet, configurationService);  final PubcompPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new PubcompPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
************************************
[+] input: generate_columnDefCheckConstraint_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "tb.col varchar2(64) constraint abcd check(true) rely using index global storing(a,b) enable novalidate")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); ConstraintState state = new ConstraintState(); state.setRely(true); state.setUsingIndexFlag(true); IndexOptions indexOptions = new IndexOptions(); indexOptions .setStoring(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); indexOptions.setGlobal(true); state.setIndexOptions(indexOptions); state.setEnable(true); state.setValidate(false); InLineConstraint attribute = new InLineCheckConstraint("abcd", state, new BoolValue(true)); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: implies_resourcePermission_impliesTrue() { ResourcePermission permission = new ResourcePermission(new DefaultSecurityResource("*", "*"), "create,write"); ResourcePermission permission1 = new ResourcePermission(new DefaultSecurityResource("12", "conn"), "create"); Assert."<AssertPlaceHolder>"; }
implies(Permission p) { if (!(p instanceof ResourcePermission)) { return false; } ResourcePermission that = (ResourcePermission) p; // we get the effective mask. i.e., the "and" of this and that. // They must be equal to that.mask for implies to return true. return ((this.mask & that.mask) == that.mask) && impliesIgnoreMask(that); }
[*] target: assertTrue(permission.implies(permission1))
[-] pred: org. junit. Assert. assertTrue ( permission. implies( permission1 ) )
************************************
************************************
[+] input: getYamlDataObjectTest() {  Map<String, Object> map = AclUtils.getYamlDataObject("src/test/resources/conf/plain_acl_correct.yml", Map.class); Assert."<AssertPlaceHolder>"; }
getYamlDataObject(String path, Class<T> clazz) { Yaml yaml = new Yaml(); FileInputStream fis = null; try { fis = new FileInputStream(new File(path)); return yaml.loadAs(fis, clazz); } catch (FileNotFoundException ignore) { return null; } catch (Exception e) { throw new AclException(e.getMessage()); } finally { if (fis != null) { try { fis.close(); } catch (IOException ignore) { } } } }
[*] target: assertFalse(map.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( map. isEmpty ( ) )
************************************
************************************
[+] input: Exception { final SettableFuture<PublishStatus> future = SettableFuture.create(); final PUBLISH publish = new PUBLISHFactory.Mqtt3Builder() .withHivemqId("hivemqId") .withPayload(new byte[]{0}) .withTopic("topic") .withQoS(QoS.AT_MOST_ONCE) .withOnwardQos(QoS.AT_MOST_ONCE) .withMessageExpiryInterval(MESSAGE_EXPIRY_INTERVAL_NOT_SET) .withPublishId(1L) .withPersistence(publishPayloadPersistence) .build();  final PublishWithFuture publishWithFuture = new PublishWithFuture(publish, future, false, publishPayloadPersistence); final boolean messageDropped = handler.checkChannelNotWritable(ctx, publishWithFuture, promise); "<AssertPlaceHolder>"; assertEquals(PublishStatus.CHANNEL_NOT_WRITABLE, future.get()); verify(promise).setSuccess(); verify(messageDroppedService).notWritable("clientId", "topic", 0); }
checkChannelNotWritable(final ChannelHandlerContext ctx, final @NotNull Object msg, final @NotNull ChannelPromise promise) throws Exception { if (!ctx.channel().isWritable()) {  if (msg instanceof PUBLISH) { if (notWritableMessages.get() < notWritableQueueSize) { notWritableMessages.incrementAndGet(); promise.addListeners(decrementCounterListener); return false; }  final PUBLISH publish = (PUBLISH) msg; if ((publish).getQoS() == QoS.AT_MOST_ONCE) { if (msg instanceof PublishWithFuture) { final SettableFuture<PublishStatus> future = ((PublishWithFuture) msg).getFuture(); future.set(PublishStatus.CHANNEL_NOT_WRITABLE); } //Drop message final String clientId = ctx.channel().attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get().getClientId(); log.trace("Dropped qos 0 message for client {} on topic {} because the channel was not writable", clientId, publish.getTopic()); messageDroppedService.notWritable(clientId, publish.getTopic(), publish.getQoS().getQosNumber()); promise.setSuccess(); return true; } } }  return false; }
[*] target: assertTrue(messageDropped)
[-] pred: org. junit. Assert. assertTrue ( messageDropped )
************************************
************************************
[+] input: generate_listPartitionWithSubPartitionOptions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list columns (a,b) subpartition by list(c) subpartition template(" + "subpartition a.b values in (2)," + "subpartition b values in ('maxvalue')) (" + "partition a.b values in (default) (" + "subpartition a.b values in (2)," + "subpartition b values in ('maxvalue'))," + "partition d values in (3) id 14," + "partition f values in ('aaaddd') id 15)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); ListPartitionElement e3 = new ListPartitionElement("f", Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions o2 = new PartitionOptions(); o2.setId(15); e3.setPartitionOptions(o2); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "list"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2, e3), subPartitionOption, null, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_modifyPartitionAddRangeSubPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition a.b add " + "subpartition a.b values less than (+3) storage(next 12 initial 15 minextents 16 maxextents 17)," + "subpartition b values less than (maxvalue) tablespace tbs")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setStorage(Arrays.asList("next 12", "initial 15", "minextents 16", "maxextents 17")); se1.setPartitionOptions(sop1); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setTableSpace("tbs"); se2.setPartitionOptions(sop2); RelationFactor factor = new RelationFactor("b"); factor.setSchema("a"); expect.addSubpartitionElements(factor, Arrays.asList(se1, se2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testTimeFilterSampleByTimestamp() { AbstractResult indexResult = new RangeResult(timeIndex, Collections.singletonList(new RangeUnit(1, 7)));  String sampleMeta = "topk(by=time, limit=5, reverse=false, replacement=false)"; TopKSampler<Long> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(8, 7, 6, 5, 4);  "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: verifyingTopicCleanupPolicyShouldReturnFalseWhenTopicAuthorizationError() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithTopicAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig, String topicPurpose) { Set<String> cleanupPolicies = topicCleanupPolicy(topic); if (cleanupPolicies.isEmpty()) { log.info("Unable to use admin client to verify the cleanup policy of '{}' " + "topic is '{}', either because the broker is an older " + "version or because the Kafka principal used for Connect " + "internal topics does not have the required permission to " + "describe topic configurations.", topic, TopicConfig.CLEANUP_POLICY_COMPACT); return false; } Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT); if (!cleanupPolicies.equals(expectedPolicies)) { String expectedPolicyStr = String.join(",", expectedPolicies); String cleanupPolicyStr = String.join(",", cleanupPolicies); String msg = String.format("Topic '%s' supplied via the '%s' property is required " + "to have '%s=%s' to guarantee consistency and durability of " + "%s, but found the topic currently has '%s=%s'. Continuing would likely " + "result in eventually losing %s and problems restarting this Connect " + "cluster in the future. Change the '%s' property in the " + "Connect worker configurations to use a topic with '%s=%s'.", topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr, topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr); throw new ConfigException(msg); } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: generate_predicateNotBetween_generateSucceed() { ExprContext context = getExprContext("tab.col not between col and col1"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); Expression right = new CompoundExpression(new ColumnReference(null, null, "col"), new ColumnReference(null, null, "col1"), Operator.AND); Expression expect = new CompoundExpression(left, right, Operator.NOT_BETWEEN); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_skipIndex_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table skip_index_tbl (id varchar(64) SKIP_INDEX(MIN_MAX,SUM))"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("skip_index_tbl"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnAttributes attributes = new ColumnAttributes(); attributes.setSkipIndexTypes(Arrays.asList("MIN_MAX", "SUM")); ColumnDefinition column = new ColumnDefinition(new ColumnReference(null, null, "id"), dataType); column.setColumnAttributes(attributes); expect.setTableElements(Collections.singletonList(column)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_updateAssignmentWithSubquery_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE tab1 SET col1 = (SELECT tab2.col1 from tab2 where tab2.col2='abcd');"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab1", null); RelationReference relationReference = new RelationReference("tab2", new RelationReference("col1", null)); Projection p = new Projection(relationReference, null); NameReference from = new NameReference(null, "tab2", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new RelationReference("tab2", new RelationReference("col2", null)); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col1")), body, false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_useBloomFilter_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) use_bloom_filter=false"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setUseBloomFilter(false); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testEquals_falseWhenCounterDifferent3() { DataVersion dataVersion = new DataVersion(); dataVersion.setCounter(null); DataVersion other = new DataVersion(); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
equals(final Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  final DataVersion that = (DataVersion) o;  if (timestamp != that.timestamp) { return false; }  if (counter != null && that.counter != null) { return counter.longValue() == that.counter.longValue(); }  return (null == counter) && (null == that.counter); }
[*] target: assertFalse(dataVersion.equals(other))
[-] pred: org. junit. Assert. assertFalse ( dataVersion. equals ( other ) )
************************************
************************************
[+] input: generate_timestampLTZWithPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp(2E5) with local time zone")); DataType actual = factory.generate();  DataType expect = new TimestampType(new BigDecimal("2E5"), false, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: SQLException { SingleConnectionDataSource dataSource = getDataSource(DialectType.OB_MYSQL); checkConnection(dataSource);  Connection connection = dataSource.getConnection(getUsername(DialectType.OB_MYSQL), getPassword(DialectType.OB_MYSQL)); Assert."<AssertPlaceHolder>"; }
getConnection(String username, String password) throws SQLException { if (Objects.equals(username, getUsername()) && Objects.equals(getPassword(), password)) { return getConnection(); } throw new SQLException("Invalid username or password"); }
[*] target: assertNotNull(connection)
[-] pred: org. junit. Assert. assertNotNull ( connection )
************************************
************************************
[+] input: Exception { if (!FS.DETECTED.supportsExecute()) return;  ChangeRecorder recorder = new ChangeRecorder(); ListenerHandle handle = null; try (Git git = new Git(db)) { handle = db.getListenerList() .addWorkingTreeModifiedListener(recorder); // Add non-executable file File file = writeTrashFile("file.txt", "a"); git.add().addFilepattern("file.txt").call(); git.commit().setMessage("commit1").call(); assertFalse(db.getFS().canExecute(file));  // Create branch git.branchCreate().setName("b1").call();  // Make file executable db.getFS().setExecute(file, true); git.add().addFilepattern("file.txt").call(); git.commit().setMessage("commit2").call();  // Verify executable and working directory is clean Status status = git.status().call(); assertTrue(status.getModified().isEmpty()); assertTrue(status.getChanged().isEmpty()); assertTrue(db.getFS().canExecute(file));  writeTrashFile("file.txt", "b");  // Switch branches CheckoutCommand checkout = git.checkout().setName("b1"); try { checkout.call(); fail("Checkout exception not thrown"); } catch (org.eclipse.jgit.api.errors.CheckoutConflictException e) { CheckoutResult result = checkout.getResult(); "<AssertPlaceHolder>"; assertNotNull(result.getConflictList()); assertEquals(1, result.getConflictList().size()); assertTrue(result.getConflictList().contains("file.txt")); } recorder.assertNoEvent(); } finally { if (handle != null) { handle.remove(); } } }
checkout() throws IOException { try { return doCheckout(); } catch (CanceledException ce) { // should actually be propagated, but this would change a LOT of // APIs throw new IOException(ce); } finally { try { dc.unlock(); } finally { if (performingCheckout) { Set<String> touched = new HashSet<>(conflicts); touched.addAll(getUpdated().keySet()); touched.addAll(kept); WorkingTreeModifiedEvent event = new WorkingTreeModifiedEvent( touched, getRemoved()); if (!event.isEmpty()) { repo.fireEvent(event); } } } } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testSmallCandidateSize() { AbstractResult indexResult = new RangeResult(typeIndex, Collections.singletonList(new RangeUnit(0, 3)));  String sampleMeta = "topk(by=weight, limit=5, reverse=false, replacement=False)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(0, 3, 5, 8); "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: InterruptedException {  when(retainedMessagePersistence.clear()).thenReturn(Futures.immediateFuture(null));  final CompletableFuture<Void> clear = retainedMessageStore.clear();  "<AssertPlaceHolder>"; while (!clear.isDone()) { Thread.sleep(10); } assertTrue(clear.isDone()); assertFalse(clear.isCompletedExceptionally());  }
clear() { if (pluginServiceRateLimitService.rateLimitExceeded()) { return CompletableFuture.failedFuture(PluginServiceRateLimitService.RATE_LIMIT_EXCEEDED_EXCEPTION); } return ListenableFutureConverter.toCompletable(retainedMessagePersistence.clear(), globalManagedExtensionExecutorService); }
[*] target: assertNotNull(clear)
[-] pred: org. junit. Assert. assertNotNull ( clear )
************************************
************************************
[+] input: testDeserializeEverySupportedType() { Assume.assumeFalse( "No test yet for Hive3 (Date/Timestamp creation)", HiveVersion.min(HiveVersion.HIVE_3));  Deserializer deserializer = new Deserializer.Builder() .schema(HiveIcebergTestUtils.FULL_SCHEMA) .writerInspector( (StructObjectInspector) IcebergObjectInspector.create(HiveIcebergTestUtils.FULL_SCHEMA)) .sourceInspector(HiveIcebergTestUtils.FULL_SCHEMA_OBJECT_INSPECTOR) .build();  Record expected = HiveIcebergTestUtils.getTestRecord(); Record actual = deserializer.deserialize(HiveIcebergTestUtils.valuesForTestRecord(expected));  HiveIcebergTestUtils."<AssertPlaceHolder>"; }
deserialize(Object data) { return (Record) fieldDeserializer.value(data); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testTypeTimeFilterSampleByWeight() { AbstractResult indexResult = new CommonResult(typeIndex, Arrays.asList(0, 2, 4, 5, 6, 9));  String sampleMeta = "topk(by=weight, limit=3, reverse=true, replacement=false)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(9, 6, 5); "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: extractResponse_WithoutNickName_ReturnUsernameAsNickName() { BastionAccount expected = new BastionAccount(); expected.setUsername("user1"); expected.setNickName("user1");  String responseBody = "{"success":true,"errorCode":0,"data":{"username":"user1"}}"; BastionAccount bastionAccount = accountClient.extractResponse(responseBody);  Assert."<AssertPlaceHolder>"; }
extractResponse(String responseBody) { QueryProperties query = bastionProperties.getAccount().getQuery();  String plainResponseBody = decryptResponse(responseBody);  log.debug("Extract response, responseBody={}, plainResponseBody={}", responseBody, plainResponseBody);  Object responseObject = JsonPathUtils.read(plainResponseBody, "$");  String responseBodyValidExpression = query.getResponseBodyValidExpression(); if (StringUtils.isNotBlank(responseBodyValidExpression)) { Expression responseBodyValid = SPEL_PARSER.parseExpression(responseBodyValidExpression); Boolean value = responseBodyValid.getValue(responseObject, Boolean.class); Verify.verify(Boolean.TRUE.equals(value), "Response body invalid, expect " + responseBodyValidExpression + " , response body " + plainResponseBody); }  String responseBodyUsernameExtractExpression = query.getResponseBodyUsernameExtractExpression(); Expression responseBodyUsernameExtract = SPEL_PARSER.parseExpression(responseBodyUsernameExtractExpression);  String username = responseBodyUsernameExtract.getValue(responseObject, String.class); Verify.notBlank(username, "Extract username got blank result, expression=" + responseBodyUsernameExtractExpression + ", response body " + plainResponseBody);  BastionAccount account = new BastionAccount(); account.setUsername(username);  String responseBodyNickNameExtractExpression = query.getResponseBodyNickNameExtractExpression(); String nickName = null; if (StringUtils.isNotBlank(responseBodyNickNameExtractExpression)) { Expression responseBodyNickNameExtract = SPEL_PARSER.parseExpression(responseBodyNickNameExtractExpression); nickName = responseBodyNickNameExtract.getValue(responseObject, String.class); } account.setNickName(StringUtils.isBlank(nickName) ? username : nickName); return account; }
[*] target: assertEquals(expected, bastionAccount)
[-] pred: org. junit. Assert. assertEquals ( expected, bastionAccount )
************************************
************************************
[+] input: testDefault() { DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) DefaultGrpcClientConfig.newBuilder().build(); assertNull(config.name()); assertEquals(3, config.retryTimes()); assertEquals(3000L, config.timeOutMills()); assertEquals(5000L, config.connectionKeepAlive()); assertEquals(10000L, config.threadPoolKeepAlive()); assertEquals(4, config.threadPoolCoreSize()); assertEquals(16, config.threadPoolMaxSize()); assertEquals(3000L, config.serverCheckTimeOut()); assertEquals(10000, config.threadPoolQueueSize()); assertEquals(10 * 1024 * 1024, config.maxInboundMessageSize()); assertEquals(6 * 60 * 1000, config.channelKeepAlive()); assertEquals(TimeUnit.SECONDS.toMillis(20L), config.channelKeepAliveTimeout()); assertEquals(3, config.healthCheckRetryTimes()); assertEquals(3000L, config.healthCheckTimeOut()); assertEquals(5000L, config.capabilityNegotiationTimeout()); assertEquals(1, config.labels().size()); "<AssertPlaceHolder>"; }
tlsConfig() { return tlsConfig; }
[*] target: assertNotNull(config.tlsConfig())
[-] pred: org. junit. Assert. assertNotNull ( config. tlsConfig() )
************************************
************************************
[+] input: testValid() { //given String ak = "ak"; String sk = "sk"; String tenantId = "100"; Credentials credentials = new Credentials(ak, sk, tenantId); //when boolean actual = credentials.valid(); //then Assert."<AssertPlaceHolder>"; }
valid() { return accessKey != null && !accessKey.isEmpty() && secretKey != null && !secretKey.isEmpty(); }
[*] target: assertTrue(actual)
[-] pred: org. junit. Assert. assertTrue ( actual )
************************************
************************************
[+] input: generate_createSpatialIndex_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create spatial index if not exists chz.abc on piaoyue.tb (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor relation = new RelationFactor("abc"); relation.setSchema("chz"); RelationFactor on = new RelationFactor("tb"); on.setSchema("piaoyue"); CreateIndex expect = new CreateIndex(relation, on, Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setSpatial(true); expect.setIfNotExists(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testClear() { final Ref master = newRef("refs/heads/master", ID_ONE); loose = toList(master);  RefMap map = new RefMap("", packed, loose, resolved); assertSame(master, map.get("refs/heads/master"));  map.clear(); assertNull(map.get("refs/heads/master")); assertTrue(map.isEmpty()); "<AssertPlaceHolder>"; }
size() { if (!sizeIsValid) { size = 0; Iterator<?> i = entrySet().iterator(); for (; i.hasNext(); i.next()) size++; sizeIsValid = true; } return size; }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size() )
************************************
************************************
[+] input: generate_addRangePartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext( "add partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp," + "partition d values less than (+3) id 14 nocompress")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1);  expect.setAddPartitionElements(Arrays.asList(e1, e2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { ComponentName cn = new ComponentName(getContext(), TEST_ACTIVITY); initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), false  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: testNoFilterSampleByTimestampReverse() { AbstractResult indexResult = new RangeResult(baseIndex, Collections.singletonList(new RangeUnit(0, 9)));  String sampleMeta = "topk(by=weight, limit=5, reverse=true, replacement=false)"; TopKSampler<Float> sampler = new TopKSampler<>(new SampleCondition(sampleMeta), neighborDataset);  List<Integer> actual = sampler.sample(indexResult); List<Integer> expected = Arrays.asList(9, 8, 7, 6, 5); "<AssertPlaceHolder>"; }
sample(AbstractResult indexResult) { int sampleCount = this.getSampleCondition().getLimit(); ArrayList<Integer> sampledIndex = new ArrayList<>(); String originIndexColumn = (indexResult.getIndex() == null) ? null : indexResult.getIndex().getIndexColumn(); if (indexResult instanceof RangeResult && originIndexColumn != null && originIndexColumn.compareTo(getSampleCondition().getKey()) == 0) { // reuse sorted neighbors in indexing stage if (indexResult instanceof RangeResult) { List<RangeUnit> sortedIntervals = ((RangeResult) indexResult).getRangeList(); if (getSampleCondition().isReverse()) { for (int i = sortedIntervals.size() - 1; i >= 0; i--) { RangeUnit range = sortedIntervals.get(i); for (int j = range.getHigh(); j >= range.getLow() && sampledIndex.size() < sampleCount; j--) { sampledIndex.add(indexResult.getOriginIndex(j)); } } } else { for (RangeUnit range : sortedIntervals) { for (int i = range.getLow(); i <= range.getHigh() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(indexResult.getOriginIndex(i)); } } } } else { List<Integer> sortedIndices = indexResult.getIndices(); if (sortedIndices.size() <= sampleCount) { sampledIndex.addAll(sortedIndices); if (getSampleCondition().isReverse()) { Collections.reverse(sampledIndex); } } if (getSampleCondition().isReverse()) { for (int i = sortedIndices.size() - 1; i >= 0 && sampledIndex.size() < sampleCount; i--) { sampledIndex.add(sortedIndices.get(i)); } } else { for (int i = 0; i < sortedIndices.size() && sampledIndex.size() < sampleCount; i++) { sampledIndex.add(sortedIndices.get(i)); } } } } else { // sort neighbors by attribute at runtime // if there is no filter condition, the selected samples are always the same, we can cache the result if (originIndexColumn == null && cachedIndex != null) { return new ArrayList<>(cachedIndex); // 一个节点上复用 } if (weights == null) { weights = getNeighborDataset().getAttributeList(getSampleCondition().getKey()); } if (priorityQueue == null) { setupPriorityQueue(getSampleCondition()); } priorityQueue.clear();  for (int idx : indexResult.getIndices()) { priorityQueue.add(idx); } for (int i = 0; i < sampleCount && !priorityQueue.isEmpty(); i++) { sampledIndex.add(priorityQueue.poll()); } if (originIndexColumn == null && cachedIndex == null) { cachedIndex = new ArrayList<>(sampledIndex); } } return sampledIndex; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_deleteWithWhereClause_generateSucceed() { Delete_stmtContext context = getDeleteContext("delete from tab where col=100"); StatementFactory<Delete> factory = new MySQLDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Delete expect = new Delete(context, nameReference); ColumnReference left = new ColumnReference(null, null, "col"); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_noChanges() { final PubackPacketImpl packet = new PubackPacketImpl( 1, AckReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubackPacketImpl modifiablePacket = new ModifiablePubackPacketImpl(packet, configurationService);  final PubackPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new PubackPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
************************************
[+] input: generate_dotRelationKeyword_generateSucceed() { ExprContext context = getExprContext(".tab.BEFORE"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  ColumnReference expect = new ColumnReference(null, "tab", "BEFORE"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetRemoteExecutorQueueSize() { int defaultExpectVal = 1 << 14; int defaultVal = RemoteUtils.getRemoteExecutorQueueSize(); Assert.assertEquals(defaultExpectVal, defaultVal);  System.setProperty("remote.executor.queue.size", "10"); int val1 = RemoteUtils.getRemoteExecutorQueueSize(); Assert.assertEquals(10, val1);  System.setProperty("remote.executor.queue.size", "-1"); int val2 = RemoteUtils.getRemoteExecutorQueueSize(); Assert."<AssertPlaceHolder>"; }
getRemoteExecutorQueueSize() { String queueSizeString = System.getProperty("remote.executor.queue.size"); if (NumberUtils.isDigits(queueSizeString)) { int size = Integer.parseInt(queueSizeString); return size > 0 ? size : REMOTE_EXECUTOR_QUEUE_SIZE; } else { return REMOTE_EXECUTOR_QUEUE_SIZE; } }
[*] target: assertEquals(defaultExpectVal, val2)
[-] pred: org. junit. Assert. assertEquals ( defaultExpectVal, val2 )
************************************
************************************
[+] input: Exception { final ByteBuf byteBuf = Bytes.prefixBytes(new byte[0], Unpooled.buffer()); final int size = byteBuf.readUnsignedShort();  "<AssertPlaceHolder>"; assertEquals(false, byteBuf.isReadable()); }
prefixBytes(final byte[] bytes, final ByteBuf buffer) { checkNotNull(bytes); checkNotNull(buffer);  buffer.writeShort(bytes.length); buffer.writeBytes(bytes);  return buffer; }
[*] target: assertEquals(0, size)
[-] pred: org. junit. Assert. assertEquals ( 0, size )
************************************
************************************
[+] input: generate_position_generateFunctionCallSucceed() { ExprContext context = getExprContext("position('123' in (1,col.tab))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); Expression left = new ConstExpression("'123'"); CollectionExpression right = new CollectionExpression(); right.addExpression(new ConstExpression("1")); right.addExpression(new ColumnReference(null, "col", "tab")); params.add(new ExpressionParam(new CompoundExpression(left, right, Operator.IN))); FunctionCall expect = new FunctionCall("position", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testDuplicateInserts() { DependencyNodeDao.instance.getMCollection().drop(); DependencyNodeDao.instance.createIndicesIfAbsent();  DependencyNode dependencyNode = new DependencyNode( "0", "url1", "GET", "0", "url2", "POST", new ArrayList<>(), 0 ); DependencyNodeDao.instance.insertOne(dependencyNode);  boolean erroredOut = false; try { DependencyNodeDao.instance.insertOne(dependencyNode); } catch (Exception e) { erroredOut = true; }  "<AssertPlaceHolder>"; }
createIndicesIfAbsent() { boolean exists = false; for (String col: clients[0].getDatabase(Context.accountId.get()+"").listCollectionNames()){ if (getCollName().equalsIgnoreCase(col)){ exists = true; break; } };  if (!exists) { clients[0].getDatabase(Context.accountId.get()+"").createCollection(getCollName()); }  String[] fieldNames = { DependencyNode.API_COLLECTION_ID_RESP, DependencyNode.URL_RESP, DependencyNode.METHOD_RESP, DependencyNode.API_COLLECTION_ID_REQ, DependencyNode.URL_REQ, DependencyNode.METHOD_REQ, }; MCollection.createUniqueIndex(getDBName(), getCollName(), fieldNames, true);  fieldNames = new String[]{ DependencyNode.API_COLLECTION_ID_RESP, DependencyNode.URL_RESP, DependencyNode.METHOD_RESP, DependencyNode.API_COLLECTION_ID_REQ, DependencyNode.URL_REQ, DependencyNode.METHOD_REQ, DependencyNode.PARAM_INFOS + "." + DependencyNode.ParamInfo.REQUEST_PARAM, DependencyNode.PARAM_INFOS + "." + DependencyNode.ParamInfo.RESPONSE_PARAM, DependencyNode.PARAM_INFOS + "." + DependencyNode.ParamInfo.IS_URL_PARAM, DependencyNode.PARAM_INFOS + "." + DependencyNode.ParamInfo.IS_HEADER, }; MCollection.createIndexIfAbsent(getDBName(), getCollName(), fieldNames, true);  fieldNames = new String[]{DependencyNode.LAST_UPDATED}; MCollection.createIndexIfAbsent(getDBName(), getCollName(), fieldNames, true); }
[*] target: assertTrue(erroredOut)
[-] pred: org. junit. Assert. assertTrue ( erroredOut )
************************************
************************************
[+] input: generate_forArchiveHighCompress_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) compress    for archive high"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setCompress("for archive high"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { Map<String, Object> requestToWrite = new HashMap<>(); requestToWrite.put("name", CONNECTOR_NAME); requestToWrite.put("config", CONNECTOR_CONFIG); requestToWrite.put("unknown-field", "random-value");  try (FileWriter writer = new FileWriter(connectorConfigurationFile)) { writer.write(new ObjectMapper().writeValueAsString(requestToWrite)); }  CreateConnectorRequest parsedRequest = connectStandalone.parseConnectorConfigurationFile(connectorConfigurationFile.getAbsolutePath()); CreateConnectorRequest expectedRequest = new CreateConnectorRequest(CONNECTOR_NAME, CONNECTOR_CONFIG, null); "<AssertPlaceHolder>"; }
parseConnectorConfigurationFile(String filePath) throws IOException { ObjectMapper objectMapper = new ObjectMapper();  File connectorConfigurationFile = Paths.get(filePath).toFile(); try { Map<String, String> connectorConfigs = objectMapper.readValue( connectorConfigurationFile, new TypeReference<Map<String, String>>() { });  if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into a Map with String keys and values", filePath); }  try { objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); CreateConnectorRequest createConnectorRequest = objectMapper.readValue(connectorConfigurationFile, new TypeReference<CreateConnectorRequest>() { }); if (createConnectorRequest.config().containsKey(NAME_CONFIG)) { if (!createConnectorRequest.config().get(NAME_CONFIG).equals(createConnectorRequest.name())) { throw new ConnectException("Connector name configuration in 'config' doesn't match the one specified in 'name' at '" + filePath + "'"); } } else { createConnectorRequest.config().put(NAME_CONFIG, createConnectorRequest.name()); } return createConnectorRequest; } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into an object of type {}", filePath, CreateConnectorRequest.class.getSimpleName()); }  Map<String, String> connectorConfigs = Utils.propsToStringMap(Utils.loadProps(filePath)); if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); }
[*] target: assertEquals(expectedRequest, parsedRequest)
[-] pred: org. junit. Assert. assertEquals ( expectedRequest, parsedRequest )
************************************
************************************
[+] input: generate_updateWithoutWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetGroupIdList() {  int page = 10; int pageSize = 100; //mock select config state List<String> groupStrings = Arrays.asList("group1", "group2", "group3"); when(jdbcTemplate.queryForList(anyString(), eq(new Object[] {}), eq(String.class))).thenReturn(groupStrings); //execute return mock obj List<String> returnGroups = externalConfigInfoPersistService.getGroupIdList(page, pageSize);  //expect check Assert."<AssertPlaceHolder>"; }
getGroupIdList(int page, int pageSize) { ConfigInfoMapper configInfoMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO); int from = (page - 1) * pageSize; MapperResult mapperResult = configInfoMapper.getGroupIdList(new MapperContext(from, pageSize)); return jt.queryForList(mapperResult.getSql(), mapperResult.getParamList().toArray(), String.class); }
[*] target: assertEquals(groupStrings, returnGroups)
[-] pred: org. junit. Assert. assertEquals ( groupStrings, returnGroups )
************************************
************************************
[+] input: generate_physicalAttrs_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) default_lob_inrow_threshold=123 pctfree=12 tablespace abc"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setPctFree(12); tableOptions.setTableSpace("abc"); tableOptions.setDefaultLobInRowThreshold(123); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_noChanges() { final PubrecPacketImpl packet = new PubrecPacketImpl( 1, AckReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubrecPacketImpl modifiablePacket = new ModifiablePubrecPacketImpl(packet, configurationService);  final PubrecPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new PubrecPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
************************************
[+] input: testFillTo0() { final IntList i = new IntList(); i.fillTo(0, Integer.MIN_VALUE); "<AssertPlaceHolder>"; }
size() { return count; }
[*] target: assertEquals(0, i.size())
[-] pred: org. junit. Assert. assertEquals ( 0, i. size() )
************************************
************************************
[+] input: testReplaceVariables_Success() { String template = "this is a test template, name=${name}"; Map<String, String> variables = new HashMap<>(); variables.put("name", "fake name");  String expected = "this is a test template, name=fake name"; String actual = MessageTemplateProcessor.replaceVariables(template, Locale.getDefault(), variables);  Assert."<AssertPlaceHolder>"; }
replaceVariables(final String template, Locale locale, final Map<String, String> variables) { if (StringUtils.isEmpty(template)) { return ""; } if (CollectionUtils.isEmpty(variables)) { return template; } Map<String, String> copiedVariables = new HashMap<>(variables); if (copiedVariables.containsKey("taskType")) { String taskTypeI18nKey = String.format("${com.oceanbase.odc.TaskType.%s}", copiedVariables.get("taskType")); copiedVariables.put("taskType", taskTypeI18nKey); } if (copiedVariables.containsKey("taskStatus")) { String taskStatusI18nKey = String.format("${com.oceanbase.odc.event.TASK.%s.name}", copiedVariables.get("taskStatus")); copiedVariables.put("taskStatus", taskStatusI18nKey); } StringSubstitutor sub = new StringSubstitutor(copiedVariables) .setDisableSubstitutionInValues(true) .setVariableResolver(key -> copiedVariables.getOrDefault(key, "")); String message = sub.replace(template); message = getLocalMessage(locale, message); return message; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetRemoteExecutorTimesOfProcessors() { int defaultExpectVal = 1 << 4; int defaultVal = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert.assertEquals(defaultExpectVal, defaultVal);  System.setProperty("remote.executor.times.of.processors", "10"); int val1 = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert.assertEquals(10, val1);  System.setProperty("remote.executor.times.of.processors", "-1"); int val2 = RemoteUtils.getRemoteExecutorTimesOfProcessors(); Assert."<AssertPlaceHolder>"; }
getRemoteExecutorTimesOfProcessors() { String timesString = System.getProperty("remote.executor.times.of.processors"); if (NumberUtils.isDigits(timesString)) { int times = Integer.parseInt(timesString); return times > 0 ? times : REMOTE_EXECUTOR_TIMES_OF_PROCESSORS; } else { return REMOTE_EXECUTOR_TIMES_OF_PROCESSORS; } }
[*] target: assertEquals(defaultExpectVal, val2)
[-] pred: org. junit. Assert. assertEquals ( defaultExpectVal, val2 )
************************************
************************************
[+] input: testRuleArrayParameter() { Map<String, Object> context = new HashMap<>(); context.put("dateArray", new Date[] {new Date(0), new Date(1000)}); boolean rst = RuleRunner.getInstance() .check( context, Lists.newArrayList( "R1 = "男女" == concat(["男", "女"])", "R2 = "123" == concat([1, 2, 3])", "R3 = "123" == concat([1L, 2L, 3L])", "R4 = "" == concat(dateArray)", "R1 && R2 && R3 && !R4"), ""); Assert."<AssertPlaceHolder>"; }
getInstance() { if (null != instance) { return instance; } synchronized (RuleRunner.class) { if (null == instance) { RuleRunner runner = new RuleRunner(); runner.init(); instance = runner; } } return instance; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
************************************
[+] input: shouldCountWorkflows() { int counts = 1100; for (int i = 0; i < counts; i++) { WorkflowSummary workflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); indexDAO.indexWorkflow(workflow); }  // wait for workflow to be indexed long result = tryGetCount(() -> getWorkflowCount("template_workflow", "RUNNING"), counts); "<AssertPlaceHolder>"; }
getWorkflowCount(String query, String freeText) { return count(query, freeText, WORKFLOW_DOC_TYPE); }
[*] target: assertEquals(counts, result)
[-] pred: org. junit. Assert. assertEquals ( counts, result )
************************************
************************************
[+] input: test_getInstance_not_present() { clientConnection.setConnectionAttributes(null);  final ConnectionAttributes returnConnectionAttributes = ConnectionAttributes.getInstance(channel);  "<AssertPlaceHolder>"; }
getInstance(@NotNull final Channel channel) { Preconditions.checkNotNull(channel, "Channel for connection attributes must not be null.");  final ConnectionAttributes connectionAttributes = getInstanceIfPresent(channel); if (connectionAttributes != null) { return connectionAttributes; }  final int maxValueSizeBytes = InternalConfigurations.CONNECTION_ATTRIBUTE_STORE_MAX_VALUE_SIZE_BYTES;  final ClientConnection clientConnection = channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get(); return clientConnection.setConnectionAttributesIfAbsent(new ConnectionAttributes(maxValueSizeBytes)); }
[*] target: assertNotNull(returnConnectionAttributes)
[-] pred: org. junit. Assert. assertNotNull ( returnConnectionAttributes )
************************************
************************************
[+] input: shouldDeleteKeyNoPropagateV0() { final MockProcessorContext<String, SubscriptionResponseWrapper<String>> context = new MockProcessorContext<>(); processor.init(context);  final SubscriptionWrapper<String> newValue = new SubscriptionWrapper<>( new long[]{1L}, Instruction.DELETE_KEY_NO_PROPAGATE, "pk1", SubscriptionWrapper.VERSION_0, null); final Record<CombinedKey<String, String>, Change<ValueAndTimestamp<SubscriptionWrapper<String>>>> record = new Record<>( new CombinedKey<>("fk1", "pk1"), new Change<>(ValueAndTimestamp.make(newValue, 1L), null), 1L ); processor.process(record); final List<CapturedForward<? extends String, ? extends SubscriptionResponseWrapper<String>>> forwarded = context.forwarded(); Assert."<AssertPlaceHolder>"; }
process(final Record<CombinedKey<KO, K>, Change<ValueAndTimestamp<SubscriptionWrapper<K>>>> record) { Objects.requireNonNull(record.key(), "This processor should never see a null key."); Objects.requireNonNull(record.value(), "This processor should never see a null value."); final ValueAndTimestamp<SubscriptionWrapper<K>> valueAndTimestamp = record.value().newValue; Objects.requireNonNull(valueAndTimestamp, "This processor should never see a null newValue."); final SubscriptionWrapper<K> value = valueAndTimestamp.value();  if (value.getVersion() > SubscriptionWrapper.CURRENT_VERSION) { //Guard against modifications to SubscriptionWrapper. Need to ensure that there is compatibility //with previous versions to enable rolling upgrades. Must develop a strategy for upgrading //from older SubscriptionWrapper versions to newer versions. throw new UnsupportedVersionException("SubscriptionWrapper is of an incompatible version."); }  final ValueAndTimestamp<VO> foreignValueAndTime = record.key().getForeignKey() == null ? null : foreignValues.get(record.key().getForeignKey());  final long resultTimestamp = foreignValueAndTime == null ? valueAndTimestamp.timestamp() : Math.max(valueAndTimestamp.timestamp(), foreignValueAndTime.timestamp());  switch (value.getInstruction()) { case DELETE_KEY_AND_PROPAGATE: context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<VO>( value.getHash(), null, value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); break; case PROPAGATE_NULL_IF_NO_FK_VAL_AVAILABLE: //This one needs to go through regardless of LEFT or INNER join, since the extracted FK was //changed and there is no match for it. We must propagate the (key, null) to ensure that the //downstream consumers are alerted to this fact. final VO valueToSend = foreignValueAndTime == null ? null : foreignValueAndTime.value();  context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<>( value.getHash(), valueToSend, value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); break; case PROPAGATE_ONLY_IF_FK_VAL_AVAILABLE: if (foreignValueAndTime != null) { context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<>( value.getHash(), foreignValueAndTime.value(), value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); } break; case DELETE_KEY_NO_PROPAGATE: break; default: throw new IllegalStateException("Unhandled instruction: " + value.getInstruction()); } }
[*] target: assertEquals(0, forwarded.size())
[-] pred: org. junit. Assert. assertEquals ( 0, forwarded. size ( ) )
************************************
************************************
[+] input: test_RAW() { String raw = RandomStringUtils.random(256); Encryption encryption = createEncryption(EncryptionAlgorithm.RAW); String encrypted = EncryptionUtil.encrypt(raw, encryption); Assert.assertEquals(raw, encrypted); String decrypted = EncryptionUtil.decrypt(encrypted, encryption); Assert."<AssertPlaceHolder>"; }
decrypt(String encryptedText, Encryption encryption) { return Objects.requireNonNull(encryptorCache.get(encryption)).decrypt(encryptedText); }
[*] target: assertEquals(raw, decrypted)
[-] pred: org. junit. Assert. assertEquals ( raw, decrypted )
************************************
************************************
[+] input: generate_noNameIndex_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col, col1) data_table_id=12 virtual_column_id=13 max_used_part_id=14")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setDataTableId(12); indexOptions.setVirtualColumnId(13); indexOptions.setMaxUsedPartId(14); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetPushData() { ServiceInfo pushData = serviceStorage.getPushData(SERVICE);  Mockito.verify(switchDomain).getDefaultPushCacheMillis(); Assert."<AssertPlaceHolder>"; }
getPushData(Service service) { ServiceInfo result = emptyServiceInfo(service); if (!ServiceManager.getInstance().containSingleton(service)) { return result; } Service singleton = ServiceManager.getInstance().getSingleton(service); result.setHosts(getAllInstancesFromIndex(singleton)); serviceDataIndexes.put(singleton, result); return result; }
[*] target: assertNotNull(pushData)
[-] pred: org. junit. Assert. assertNotNull ( pushData )
************************************
************************************
[+] input: Exception { q = new LIFORevQueue(AbstractRevQueue.EMPTY_QUEUE); "<AssertPlaceHolder>"; }
next() { final Block b = head; if (b == null) return null;  final RevCommit c = b.pop(); if (b.isEmpty()) { head = b.next; free.freeBlock(b); } return c; }
[*] target: assertNull(q.next())
[-] pred: org. junit. Assert. assertNull ( q. next() )
************************************
************************************
[+] input: generate_fromSelectStatment_generateSelectSucceed() { Select_stmtContext context = getSelectContext("select abc.* from (select * from tab order by col1 desc) as of snapshot 1 abc"); StatementFactory<Select> factory = new MySQLSelectFactory(context); Select actual = factory.generate();  ColumnReference r = new ColumnReference(null, "abc", "*"); Projection p = new Projection(r, null); SelectBody fromBody = new SelectBody(Collections.singletonList( new Projection()), Collections.singletonList(new NameReference(null, "tab", null))); OrderBy orderBy = new OrderBy(false, Collections.singletonList( new SortKey(new ColumnReference(null, null, "col1"), SortDirection.DESC, null))); fromBody.setOrderBy(orderBy); FlashbackUsage flashbackUsage = new FlashbackUsage(FlashBackType.AS_OF_SNAPSHOT, new ConstExpression("1")); ExpressionReference from = new ExpressionReference(fromBody, "abc"); from.setFlashbackUsage(flashbackUsage); Select expect = new Select(new SelectBody(Collections.singletonList(p), Collections.singletonList(from))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.selectStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_modifyHashPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition by hash(a,b)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); expect.setModifyPartition(new HashPartition(cols, null, null, null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetRolesByUserName() { Page<RoleInfo> page = embeddedRolePersistService.getRolesByUserNameAndRoleName("userName", "roleName", 1, 10);  Assert."<AssertPlaceHolder>"; }
getRolesByUserNameAndRoleName(String username, String role, int pageNo, int pageSize) {  AuthPaginationHelper<RoleInfo> helper = createPaginationHelper();  String sqlCountRows = "SELECT count(*) FROM roles ";  String sqlFetchRows = "SELECT role,username FROM roles ";  StringBuilder where = new StringBuilder(" WHERE 1 = 1 "); List<String> params = new ArrayList<>(); if (StringUtils.isNotBlank(username)) { where.append(" AND username = ? "); params.add(username); } if (StringUtils.isNotBlank(role)) { where.append(" AND role = ? "); params.add(role); }  return helper.fetchPage(sqlCountRows + where, sqlFetchRows + where, params.toArray(), pageNo, pageSize, ROLE_INFO_ROW_MAPPER);  }
[*] target: assertNotNull(page)
[-] pred: org. junit. Assert. assertNotNull ( page )
************************************
************************************
[+] input: generate_castAsJson_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as json)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); p.addOption(new GeneralDataType("json", null)); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testInitNamespaceFromAnsWithCloudParsing() { String expect = "ans"; System.setProperty(SystemPropertyKeyConst.ANS_NAMESPACE, expect); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); properties.setProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, "true"); String actual = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
initNamespaceForNaming(NacosClientProperties properties) { String tmpNamespace = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) {  tmpNamespace = TenantUtil.getUserTenantForAns(); LogUtils.NAMING_LOGGER.info("initializer namespace from ans.namespace attribute : {}", tmpNamespace);  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from ALIBABA_ALIWARE_NAMESPACE attribute :" + namespace); return namespace; }); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getPropertyFrom(SourceType.JVM, PropertyKeyConst.NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from namespace attribute :" + namespace); return namespace; });  if (StringUtils.isEmpty(tmpNamespace)) { tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> UtilAndComs.DEFAULT_NAMESPACE_ID); return tmpNamespace; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testEncrypt() { String dataId = "cipher-mockAlgo-application"; String content = "content"; String sec = mockEncryptionPluginService.generateSecretKey(); Pair<String, String> pair = EncryptionHandler.encryptHandler(dataId, content); Assert."<AssertPlaceHolder>"; Assert.assertEquals("should return encrypted content.", mockEncryptionPluginService.encrypt(sec, content), pair.getSecond()); Assert.assertEquals("should return encrypted secret key.", mockEncryptionPluginService.encryptSecretKey(sec), pair.getFirst()); }
encryptHandler(String dataId, String content) { if (!checkCipher(dataId)) { return Pair.with("", content); } Optional<String> algorithmName = parseAlgorithmName(dataId); Optional<EncryptionPluginService> optional = algorithmName.flatMap( EncryptionPluginManager.instance()::findEncryptionService); if (!optional.isPresent()) { LOGGER.warn("[EncryptionHandler] [encryptHandler] No encryption program with the corresponding name found"); return Pair.with("", content); } EncryptionPluginService encryptionPluginService = optional.get(); String secretKey = encryptionPluginService.generateSecretKey(); String encryptContent = encryptionPluginService.encrypt(secretKey, content); return Pair.with(encryptionPluginService.encryptSecretKey(secretKey), encryptContent); }
[*] target: assertNotNull(pair)
[-] pred: org. junit. Assert. assertNotNull ( pair )
************************************
************************************
[+] input: generate_weightStringBinary_generateFunctionCallSucceed() { ExprContext context = getExprContext("WEIGHT_STRING(123 AS Binary (12))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("123")); p.addOption(new GeneralDataType("Binary", Collections.singletonList("12"))); params.add(p); FunctionCall expect = new FunctionCall("WEIGHT_STRING", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: equalTest() { TimeRange r1 = new TimeRange(5, 8); TimeRange r2 = new TimeRange(5, 8); "<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } TimeRange that = (TimeRange) o; return (this.min == that.min && this.max == that.max); }
[*] target: assertTrue(r1.equals(r2))
[-] pred: org. junit. Assert. assertTrue ( r1. equals ( r2 ) )
************************************
************************************
[+] input: testValueOf3() { MediaType mediaType = MediaType.valueOf("application/x-www-form-urlencoded", "ISO-8859-1"); String type = "application/x-www-form-urlencoded"; String charset = "ISO-8859-1"; String excepted = "application/x-www-form-urlencoded;charset=ISO-8859-1"; assertEquals(type, mediaType.getType()); assertEquals(charset, mediaType.getCharset()); "<AssertPlaceHolder>"; }
toString() { return type + ";charset=" + charset; }
[*] target: assertEquals(excepted, mediaType.toString())
[-] pred: org. junit. Assert. assertEquals ( excepted, mediaType. toString ( ) )
************************************
************************************
[+] input: generate_withoutAliasList_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name as (select * from dual order by abc desc fetch next 12 rows only) select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  SelectBody selectBody = getDefaultSelect(); SortKey s1 = new SortKey(new RelationReference("abc", null), SortDirection.DESC, null); OrderBy orderBy = new OrderBy(false, Collections.singletonList(s1)); selectBody.setOrderBy(orderBy); Fetch fetch = new Fetch(new ConstExpression("12"), FetchDirection.NEXT, FetchType.COUNT, FetchAddition.ONLY, null); selectBody.setFetch(fetch); WithTable expect = new WithTable("relation_name", selectBody); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: clearInactiveTempConnectionConfigs_Empty_Return0() { int ret = recycleService.clearInactiveTempConnectionConfigs(); Assert."<AssertPlaceHolder>"; }
clearInactiveTempConnectionConfigs() { List<ConnectionEntity> entities = connectionSessionHistoryService.listInactiveConnections(true); if (CollectionUtils.isEmpty(entities)) { return 0; } int deletedCount = 0; for (ConnectionEntity entity : entities) { try { SecurityContextUtils.setCurrentUser(entity.getCreatorId(), entity.getOrganizationId(), null); connectionService.delete(entity.getId()); deletedCount++; } catch (Exception exception) { log.warn("Delete inactive temp connection failed, connectionId={}, reason={}", entity.getId(), exception.getMessage()); } finally { SecurityContextUtils.clear(); } } log.info("Clear inactive temp connection configs, deletedCount={}", deletedCount); return deletedCount; }
[*] target: assertEquals(0, ret)
[-] pred: org. junit. Assert. assertEquals ( 0, ret )
************************************
************************************
[+] input: Exception { File target = dumpSchemaAndDataForLoad(DialectType.OB_ORACLE); assertOracleModeTableNotExists();  UploadFileResult actual = dataTransferService.getMetaInfo(target.getAbsolutePath()); UploadFileResult expect = new UploadFileResult(); expect.setFormat(DataFormat.SQL); expect.setFileType("ZIP"); expect.setFileName(target.getAbsolutePath()); expect.setContainsData(true); expect.setContainsSchema(true); Map<ObjectType, Set<String>> importFileNames = new HashMap<>(); importFileNames.putIfAbsent(ObjectType.TABLE, Collections.singleton(TEST_TABLE_NAME)); expect.setImportObjects(importFileNames);  Assert."<AssertPlaceHolder>"; }
getMetaInfo(@NonNull String fileName) throws IOException { File uploadFile = fileManager.findByName(TaskType.IMPORT, LocalFileManager.UPLOAD_BUCKET, fileName).orElseThrow( () -> new FileNotFoundException("File not found")); if (!uploadFile.exists() || !uploadFile.isFile()) { throw new IllegalArgumentException("Target is not a file or does not exist, " + fileName); }  // If the file is from third party like PL/SQL, this will convert it compatible with ob-loader. ThirdPartyOutputConverter.convert(uploadFile);  String uploadFileName = uploadFile.getName(); if (StringUtils.endsWithIgnoreCase(uploadFileName, ".zip")) { // 疑似 zip 压缩文件，需要进一步确认是否合法 try { ExportOutput dumperOutput = new ExportOutput(uploadFile); return UploadFileResult.ofExportOutput(fileName, dumperOutput); } catch (Exception e) { log.warn("Not a valid zip file, file={}", fileName, e); return UploadFileResult.ofFail(ErrorCodes.ImportInvalidFileType, new Object[] {uploadFileName}); } } else if (StringUtils.endsWithIgnoreCase(uploadFileName, ".csv")) { return UploadFileResult.ofCsv(fileName); } else if (StringUtils.endsWithIgnoreCase(uploadFileName, ".sql") || StringUtils.endsWithIgnoreCase(uploadFileName, ".txt")) { return UploadFileResult.ofSql(fileName); } return UploadFileResult.ofFail(ErrorCodes.ImportInvalidFileType, new Object[] {uploadFileName}); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testSimplyEnvNameIfOverLimit() { StringBuilder envNameOverLimitBuilder = new StringBuilder("test"); for (int i = 0; i < 50; i++) { envNameOverLimitBuilder.append(i); } String envName = envNameOverLimitBuilder.toString(); String actual = ParamUtil.simplyEnvNameIfOverLimit(envName); String expect = envName.substring(0, 50) + MD5Utils.md5Hex(envName, "UTF-8"); "<AssertPlaceHolder>"; }
simplyEnvNameIfOverLimit(String envName) { if (StringUtils.isNotBlank(envName) && envName.length() > MAX_ENV_NAME_LENGTH) { return envName.substring(0, MAX_ENV_NAME_LENGTH) + MD5Utils.md5Hex(envName, "UTF-8"); } return envName; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: multipleNetaddressStrategyTest() { PlainAccessResource plainAccessResource = new PlainAccessResource(); plainAccessResource.setWhiteRemoteAddress("127.0.0.1,127.0.0.2,127.0.0.3"); RemoteAddressStrategy remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleNetaddressStrategyTest(remoteAddressStrategy);  plainAccessResource.setWhiteRemoteAddress("127.0.0.{1,2,3}"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleNetaddressStrategyTest(remoteAddressStrategy);  plainAccessResource.setWhiteRemoteAddress("192.100-150.*.*"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); plainAccessResource.setWhiteRemoteAddress("192.130.0.2"); boolean match = remoteAddressStrategy.match(plainAccessResource); Assert."<AssertPlaceHolder>";  plainAccessResource = new PlainAccessResource(); plainAccessResource.setWhiteRemoteAddress("1050::0005:0600:300c:1,1050::0005:0600:300c:2,1050::0005:0600:300c:3"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleIPv6NetaddressStrategyTest(remoteAddressStrategy);  plainAccessResource.setWhiteRemoteAddress("1050::0005:0600:300c:{1,2,3}"); remoteAddressStrategy = remoteAddressStrategyFactory.getRemoteAddressStrategy(plainAccessResource); multipleIPv6NetaddressStrategyTest(remoteAddressStrategy);  }
match(PlainAccessResource plainAccessResource);
[*] target: assertTrue(match)
[-] pred: org. junit. Assert. assertTrue ( match )
************************************
************************************
[+] input: generate_createUniqueIndex_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create unique index chz.abc@oakasda! on piaoyue.tb@uasid! (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor relation = new RelationFactor("abc"); relation.setSchema("chz"); relation.setUserVariable("@oakasda"); relation.setReverseLink(true); RelationFactor on = new RelationFactor("tb"); on.setSchema("piaoyue"); on.setUserVariable("@uasid"); on.setReverseLink(true); CreateIndex expect = new CreateIndex(relation, on, Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); expect.setUnique(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_columnProjectionWithLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col label from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new ColumnReference(null, null, "col"), "label"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_dateAdd_generateFunctionCallSucceed() { ExprContext context = getExprContext("DATE_ADD(tab, INTERVAL '12' DAY_HOUR)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, null, "tab"))); params.add(new ExpressionParam(new IntervalExpression(new ConstExpression("'12'"), "DAY_HOUR"))); FunctionCall expect = new FunctionCall("DATE_ADD", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testInstance() { CustomEnvironmentPluginManager instance = CustomEnvironmentPluginManager.getInstance(); Assert."<AssertPlaceHolder>"; }
getInstance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
************************************
[+] input: generate_columnDefAfter_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) after col")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); expect.setLocation(new Location("after", new ColumnReference(null, null, "col"))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_WMSYS_Dot_WM_CONCAT_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("wmsys.wm_concat(all col) keep (DENSE_RANK first order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("wmsys.wm_concat", Collections.singletonList(new ExpressionParam(new RelationReference("col", null)))); expect.addOption(new ConstExpression("all")); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.setKeep(new KeepClause("first", new OrderBy(Collections.singletonList(s)))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testPrefixAndBeanNameConnectUseUnderscore() { JoinAliasGenerator generator = new UnderScoreJoinAliasGenerator();  Map<String, String> table = new HashMap<>(); table.put("users", "users_bean"); table.put("spring.users", "springUsers_bean"); table.put("spring.users.zhangsan", "springUsersZhangsan_bean");  table.forEach((key, value) -> { String alias = generator.generateAlias(key, beanName, clazz); "<AssertPlaceHolder>"; });  }
generateAlias(String prefix, String beanName, Class<?> configClass);
[*] target: assertEquals(value, alias)
[-] pred: org. junit. Assert. assertEquals ( value, alias )
************************************
************************************
[+] input: generate_rowMovement_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) enable row movement, disable row movement enable_extended_rowid=false"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setEnableRowMovement(true); tableOptions.setDisableRowMovement(true); tableOptions.setEnableExtendedRowId(false); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldMatchPositionAfterPut() { final MeteredWindowStore<Integer, String> meteredSessionStore = (MeteredWindowStore<Integer, String>) windowStore; final ChangeLoggingWindowBytesStore changeLoggingSessionBytesStore = (ChangeLoggingWindowBytesStore) meteredSessionStore.wrapped(); final InMemoryWindowStore inMemoryWindowStore = (InMemoryWindowStore) changeLoggingSessionBytesStore.wrapped();  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); windowStore.put(0, "0", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); windowStore.put(1, "1", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); windowStore.put(2, "2", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 4, 0, "", new RecordHeaders())); windowStore.put(3, "3", SEGMENT_INTERVAL);  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 4L))))); final Position actual = inMemoryWindowStore.getPosition(); "<AssertPlaceHolder>"; }
getPosition() { return position; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_listPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by list(a,b) (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress," + "partition values ('aaaddd') id 15 tablespace tbs)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); ListPartitionElement e3 = new ListPartitionElement(null, Collections.singletonList(new ConstExpression("'aaaddd'"))); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2, e3), null, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generateCreateObjectDDL_sequence_generateSucceed() { DBObjectEditor<DBSequence> editor = new OracleSequenceEditor(); DBSequence sequence = new DBSequence(); sequence.setName("seq_t"); sequence.setMaxValue("1000"); sequence.setStartValue("10"); sequence.setIncreament(2L); sequence.setCached(false); sequence.setOrderd(true); sequence.setCycled(true);  String expect = "CREATE SEQUENCE "seq_t" NOMINVALUE MAXVALUE 1000 START WITH 10 INCREMENT BY 2 NOCACHE ORDER CYCLE;"; Assert."<AssertPlaceHolder>"; }
generateCreateDefinitionDDL(@NotNull DBSequence dbObject) { return generateCreateObjectDDL(dbObject); }
[*] target: assertEquals(expect, editor.generateCreateDefinitionDDL(sequence))
[-] pred: org. junit. Assert. assertEquals ( expect, editor. generateCreateDefinitionDDL ( sequence ) )
************************************
************************************
[+] input: testHandle() { MockedStatic<ConfigCacheService> configCacheServiceMockedStatic = Mockito.mockStatic(ConfigCacheService.class);  String dataId = "dataId"; String group = "group"; String tenant = "tenant"; String groupKey = GroupKey2.getKey(dataId, group, tenant); groupKey = StringPool.get(groupKey);  final String groupKeyCopy = groupKey; configCacheServiceMockedStatic.when( () -> ConfigCacheService.isUptodate(eq(groupKeyCopy), Mockito.any(), Mockito.any(), Mockito.any())) .thenReturn(false); ConfigBatchListenRequest configChangeListenRequest = new ConfigBatchListenRequest(); configChangeListenRequest.addConfigListenContext(group, dataId, tenant, " "); try { ConfigChangeBatchListenResponse configChangeBatchListenResponse = configQueryRequestHandler .handle(configChangeListenRequest, requestMeta); boolean hasChange = false; for (ConfigChangeBatchListenResponse.ConfigContext changedConfig : configChangeBatchListenResponse.getChangedConfigs()) { if (changedConfig.getDataId().equals(dataId)) { hasChange = true; break; } } "<AssertPlaceHolder>"; } catch (NacosException e) { e.printStackTrace(); } finally { configCacheServiceMockedStatic.close(); } }
handle(ConfigBatchListenRequest configChangeListenRequest, RequestMeta meta) throws NacosException { String connectionId = StringPool.get(meta.getConnectionId()); String tag = configChangeListenRequest.getHeader(Constants.VIPSERVER_TAG);  ConfigChangeBatchListenResponse configChangeBatchListenResponse = new ConfigChangeBatchListenResponse(); for (ConfigBatchListenRequest.ConfigListenContext listenContext : configChangeListenRequest .getConfigListenContexts()) { String groupKey = GroupKey2 .getKey(listenContext.getDataId(), listenContext.getGroup(), listenContext.getTenant()); groupKey = StringPool.get(groupKey);  String md5 = StringPool.get(listenContext.getMd5());  if (configChangeListenRequest.isListen()) { configChangeListenContext.addListen(groupKey, md5, connectionId); boolean isUptoDate = ConfigCacheService.isUptodate(groupKey, md5, meta.getClientIp(), tag); if (!isUptoDate) { configChangeBatchListenResponse.addChangeConfig(listenContext.getDataId(), listenContext.getGroup(), listenContext.getTenant()); } } else { configChangeListenContext.removeListen(groupKey, connectionId); } }  return configChangeBatchListenResponse;  }
[*] target: assertTrue(hasChange)
[-] pred: org. junit. Assert. assertTrue ( hasChange )
************************************
************************************
[+] input: generate_uniqueIndexHashPartition_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("unique index idx_name (col asc id 16, col1) partition by hash(col)")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); HashPartition p = new HashPartition(Collections.singletonList(new ColumnReference(null, null, "col")), null, null, null); state.setPartition(p); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: MalformedURLException { OSS oss = mock(OSSClient.class); Mockito.when(oss.generatePresignedUrl(any())).thenReturn(new URL("http://test.sql")); AlibabaCloudClient alibabaCloudClient = new AlibabaCloudClient(oss, null, "test", "test"); URL url = alibabaCloudClient.generatePresignedUrl("test", "test", new Date()); Assert."<AssertPlaceHolder>"; }
generatePresignedUrl(String bucketName, String key, Date expiration) throws CloudException { Verify.notBlank(key, "key"); return callOssMethod("Generate presigned URL", () -> { GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key); request.setBucketName(bucketName); request.setExpiration(expiration); request.setKey(key); ResponseHeaderOverrides responseHeaderOverrides = new ResponseHeaderOverrides(); responseHeaderOverrides.setContentDisposition( String.format("attachment;filename=%s", CloudObjectStorageUtil.getOriginalFileName(key))); request.setResponseHeaders(responseHeaderOverrides); return oss.generatePresignedUrl(request); }); }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
************************************
[+] input: generate_useBloomFilter_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) use_bloom_filter=false"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setUseBloomFilter(false); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: verifyingTopicCleanupPolicyShouldReturnTrueWhenTopicHasCorrectPolicy() { String topicName = "myTopic"; Map<String, String> topicConfigs = Collections.singletonMap("cleanup.policy", "compact"); Cluster cluster = createCluster(1); try (MockAdminClient mockAdminClient = new MockAdminClient(cluster.nodes(), cluster.nodeById(0))) { TopicPartitionInfo topicPartitionInfo = new TopicPartitionInfo(0, cluster.nodeById(0), cluster.nodes(), Collections.emptyList()); mockAdminClient.addTopic(false, topicName, Collections.singletonList(topicPartitionInfo), topicConfigs); TopicAdmin admin = new TopicAdmin(mockAdminClient); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig, String topicPurpose) { Set<String> cleanupPolicies = topicCleanupPolicy(topic); if (cleanupPolicies.isEmpty()) { log.info("Unable to use admin client to verify the cleanup policy of '{}' " + "topic is '{}', either because the broker is an older " + "version or because the Kafka principal used for Connect " + "internal topics does not have the required permission to " + "describe topic configurations.", topic, TopicConfig.CLEANUP_POLICY_COMPACT); return false; } Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT); if (!cleanupPolicies.equals(expectedPolicies)) { String expectedPolicyStr = String.join(",", expectedPolicies); String cleanupPolicyStr = String.join(",", cleanupPolicies); String msg = String.format("Topic '%s' supplied via the '%s' property is required " + "to have '%s=%s' to guarantee consistency and durability of " + "%s, but found the topic currently has '%s=%s'. Continuing would likely " + "result in eventually losing %s and problems restarting this Connect " + "cluster in the future. Change the '%s' property in the " + "Connect worker configurations to use a topic with '%s=%s'.", topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr, topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr); throw new ConfigException(msg); } return true; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: testMapDeserialize() { Schema schema = new Schema( optional( 1, "map_type", Types.MapType.ofOptional(2, 3, Types.LongType.get(), Types.StringType.get())));  StructObjectInspector inspector = ObjectInspectorFactory.getStandardStructObjectInspector( Arrays.asList("map_type"), Arrays.asList( ObjectInspectorFactory.getStandardMapObjectInspector( PrimitiveObjectInspectorFactory.writableLongObjectInspector, PrimitiveObjectInspectorFactory.writableStringObjectInspector)));  Deserializer deserializer = new Deserializer.Builder() .schema(schema) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(schema)) .sourceInspector(inspector) .build();  Record expected = GenericRecord.create(schema); expected.set(0, Collections.singletonMap(1L, "Taylor"));  MapWritable map = new MapWritable(); map.put(new LongWritable(1L), new Text("Taylor")); Object[] data = new Object[] {map}; Record actual = deserializer.deserialize(data);  Assert."<AssertPlaceHolder>"; }
deserialize(Object data) { return (Record) fieldDeserializer.value(data); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_fullTextIndexColumnAscId_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("fulltext index using btree (col asc id 16, col1) invisible")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setVisible(false); expect.setIndexOptions(indexOptions); expect.setFullText(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: NacosException { RpcClient rpcClient = buildTestStartClient(serverInfo -> null); rpcClient.shutdown(); rpcClient.start(); "<AssertPlaceHolder>"; }
isShutdown() { return this.rpcClientStatus.get() == RpcClientStatus.SHUTDOWN; }
[*] target: assertTrue(rpcClient.isShutdown())
[-] pred: org. junit. Assert. assertTrue ( rpcClient. isShutdown() )
************************************
************************************
[+] input: testSetRootLevel() { Logger root = logger("root"); root.setLevel(Level.ERROR);  Logger p = logger("a.b.c.p"); Logger x = logger("a.b.c.p.X"); Logger y = logger("a.b.c.p.Y"); Logger z = logger("a.b.c.p.Z"); Logger w = logger("a.b.c.s.W"); x.setLevel(Level.INFO); y.setLevel(Level.INFO); z.setLevel(Level.INFO); w.setLevel(Level.INFO);  Loggers loggers = new TestLoggers(root, x, y, z, w);  List<String> modified = loggers.setLevel("root", Level.DEBUG); assertEquals(Arrays.asList("a.b.c.p.X", "a.b.c.p.Y", "a.b.c.p.Z", "a.b.c.s.W", "root"), modified);  assertNull(p.getLevel());  assertEquals(root.getLevel(), Level.DEBUG);  assertEquals(w.getLevel(), Level.DEBUG); assertEquals(x.getLevel(), Level.DEBUG); assertEquals(y.getLevel(), Level.DEBUG); assertEquals(z.getLevel(), Level.DEBUG);  Map<String, LoggerLevel> expectedLevels = new HashMap<>(); expectedLevels.put("root", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.p.X", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.p.Y", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.p.Z", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME)); expectedLevels.put("a.b.c.s.W", new LoggerLevel(Level.DEBUG.toString(), INITIAL_TIME));  Map<String, LoggerLevel> actualLevels = loggers.allLevels(); "<AssertPlaceHolder>"; }
allLevels() { Map<String, LoggerLevel> result = new TreeMap<>();  Enumeration<org.apache.log4j.Logger> enumeration = currentLoggers(); Collections.list(enumeration) .stream() .filter(logger -> logger.getLevel() != null) .forEach(logger -> result.put(logger.getName(), loggerLevel(logger)));  org.apache.log4j.Logger root = rootLogger(); if (root.getLevel() != null) { result.put(ROOT_LOGGER_NAME, loggerLevel(root)); }  return result; }
[*] target: assertEquals(expectedLevels, actualLevels)
[-] pred: org. junit. Assert. assertEquals ( expectedLevels, actualLevels )
************************************
************************************
[+] input: generate_updateWithWhereClauseCursor_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1 where current of tab.col"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); RelationReference left = new RelationReference("tab", new RelationReference("col", null)); expect.setWhere(left); expect.setCursor(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: IOException { File file = ResourceUtils .getResourceAsFile(ResourceUtils.class.getClassLoader(), "resource_utils_test.properties"); "<AssertPlaceHolder>"; }
getResourceAsFile(ClassLoader loader, String resource) throws IOException { return new File(getResourceUrl(loader, resource).getFile()); }
[*] target: assertNotNull(file)
[-] pred: org. junit. Assert. assertNotNull ( file )
************************************
************************************
[+] input: testGetIntN() { int src = 54243342; int dest = 0; for (int i = 0; i < 32; i++) { int a = BytesUtils.getIntN(src, i); dest = BytesUtils.setIntN(dest, i, a); } "<AssertPlaceHolder>"; }
setIntN(int data, int offset, int value) { offset %= 32; if (value == 1) { return (data | (1 << (offset))); } else { return (data & ~(1 << (offset))); } }
[*] target: assertEquals(src, dest)
[-] pred: org. junit. Assert. assertEquals ( src, dest )
************************************
************************************
[+] input: testToByteArray() { GeometryBuffer buffer = GeometryBufferFactory.create(bufferType, 2); buffer.putByte(0, (byte) 1); buffer.putByte(1, (byte) 2); byte[] bytes = buffer.toByteArray(); "<AssertPlaceHolder>"; assertEquals((byte) 1, bytes[0]); assertEquals((byte) 2, bytes[1]); }
toByteArray();
[*] target: assertEquals(2, bytes.length)
[-] pred: org. junit. Assert. assertEquals ( 2, bytes. length )
************************************
************************************
[+] input: generate_skipIndex_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table skip_index_tbl (id varchar(64) SKIP_INDEX(MIN_MAX,SUM))"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("skip_index_tbl"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnAttributes attributes = new ColumnAttributes(); attributes.setSkipIndexTypes(Arrays.asList("MIN_MAX", "SUM")); ColumnDefinition column = new ColumnDefinition(new ColumnReference(null, null, "id"), dataType); column.setColumnAttributes(attributes); expect.setTableElements(Collections.singletonList(column)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testEncryptHandler() { Pair<String, String> pair = EncryptionHandler.encryptHandler("test-dataId", "content"); Assert."<AssertPlaceHolder>"; }
encryptHandler(String dataId, String content) { if (!checkCipher(dataId)) { return Pair.with("", content); } Optional<String> algorithmName = parseAlgorithmName(dataId); Optional<EncryptionPluginService> optional = algorithmName.flatMap( EncryptionPluginManager.instance()::findEncryptionService); if (!optional.isPresent()) { LOGGER.warn("[EncryptionHandler] [encryptHandler] No encryption program with the corresponding name found"); return Pair.with("", content); } EncryptionPluginService encryptionPluginService = optional.get(); String secretKey = encryptionPluginService.generateSecretKey(); String encryptContent = encryptionPluginService.encrypt(secretKey, content); return Pair.with(encryptionPluginService.encryptSecretKey(secretKey), encryptContent); }
[*] target: assertNotNull(pair)
[-] pred: org. junit. Assert. assertNotNull ( pair )
************************************
************************************
[+] input: generate_createIndexWithColumnGroup_allColumns_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_relationNameFunctionNameExprAsListNoAlias_generateFunctionCallSucceed() { ExprContext context = getExprContext("relation_name.function_name(tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("relation_name.function_name", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_generatedColumnDefAsIdentity_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("tb.col varchar2(64) generated always as identity " + "cycle minvalue -12 increment by 13 maxvalue 15 start with 1 " + "nomaxvalue nominvalue cycle nocycle cache 13 " + "nocache order noorder")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); SequenceOptions options = new SequenceOptions(); options.setCycle(true); options.setMinValue(new BigDecimal("-12")); options.setIncrementBy(new BigDecimal("13")); options.setMaxValue(new BigDecimal("15")); options.setStartWith(new BigDecimal("1")); options.setNoMaxValue(true); options.setNoMinValue(true); options.setCycle(true); options.setNoCycle(true); options.setCache(new BigDecimal("13")); options.setNoCache(true); options.setOrder(true); options.setNoOrder(true); GenerateOption option = new GenerateOption(options); option.setGenerateOption("always"); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_deleteSingleTableWithPartition_generateSucceed() { Delete_stmtContext context = getDeleteContext("DELETE FROM tab PARTITION(p1) WHERE user = 'test' ORDER BY col LIMIT 100;"); StatementFactory<Delete> factory = new MySQLDeleteFactory(context); Delete actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab", null); nameReference.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p1"))); Delete expect = new Delete(context, nameReference); ColumnReference left = new ColumnReference(null, null, "user"); ConstExpression right = new ConstExpression("'test'"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); expect.setLimit(new Limit(new ConstExpression("100"))); SortKey s1 = new SortKey(new ColumnReference(null, null, "col"), null); expect.setOrderBy(new OrderBy(Arrays.asList(s1))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.deleteStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: currentSession() { DBSession session = accessor.currentSession(); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(session.getId()); }
currentSession() { return jdbcOperations.queryForObject(GET_CURRENT_SESSION, new BeanPropertyRowMapper<>(DBSession.class)); }
[*] target: assertNotNull(session)
[-] pred: org. junit. Assert. assertNotNull ( session )
************************************
************************************
[+] input: getStatement_createTableOracleMode_getCreateTableStmt() { AbstractSyntaxTreeFactory factory = AbstractSyntaxTreeFactories.getAstFactory(DialectType.OB_MYSQL, 0); AbstractSyntaxTree ast = factory.buildAst("create table abcd (id varchar(64))"); Statement actual = ast.getStatement(); CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
getStatement();
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: InterruptedException { when(localPersistence.getSession("client")).thenReturn(new ClientSession(false, 100)); when(subscriptionPersistence.removeAll("client")).thenReturn(Futures.immediateFuture(null)); final Boolean result = clientSessionPersistence.setSessionExpiryInterval("client", 0).get(); "<AssertPlaceHolder>"; verify(subscriptionPersistence).removeAll("client"); }
setSessionExpiryInterval( final @NotNull String clientId, final long sessionExpiryInterval) {  checkNotNull(clientId, "Client id must not be null");  final ListenableFuture<Boolean> setTTlFuture = singleWriter.submit(clientId, (bucketIndex) -> {  final boolean clientSessionExists = localPersistence.getSession(clientId) != null;  if (!clientSessionExists) { return false; }  localPersistence.setSessionExpiryInterval(clientId, sessionExpiryInterval, bucketIndex); return true; });  final SettableFuture<Boolean> settableFuture = SettableFuture.create();  Futures.addCallback(setTTlFuture, new FutureCallback<>() { @Override public void onSuccess(final @Nullable Boolean sessionExists) { if (sessionExpiryInterval == SESSION_EXPIRE_ON_DISCONNECT) {  final ListenableFuture<Void> removeAllFuture = subscriptionPersistence.removeAll(clientId);  Futures.addCallback(removeAllFuture, new FutureCallback<>() { @Override public void onSuccess(final @Nullable Void result) { settableFuture.set(sessionExists); }  @Override public void onFailure(final @NotNull Throwable t) { settableFuture.setException(t); } }, MoreExecutors.directExecutor()); } else { settableFuture.set(sessionExists); } }  @Override public void onFailure(final @NotNull Throwable t) { settableFuture.setException(t); } }, MoreExecutors.directExecutor());  return settableFuture; }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: implies_SameResourceTypeAndId_impliesFalse() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "OWNER"); Assert."<AssertPlaceHolder>"; }
implies(Permission permission) { if (!(permission instanceof ResourceRoleBasedPermission)) { return false; } return this.resourceId.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceId()) && this.resourceType.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceType()) && !Collections.disjoint(((ResourceRoleBasedPermission) permission).getResourceRoles(), this.resourceRoles); }
[*] target: assertFalse(permission.implies(permission1))
[-] pred: org. junit. Assert. assertFalse ( permission. implies( permission1 ) )
************************************
************************************
[+] input: testContextLoss() { Map<String, Object> context = new HashMap<>(); context.put("A", 1000); boolean rst = RuleRunner.getInstance().check(context, Lists.newArrayList("A > B"), ""); Assert."<AssertPlaceHolder>"; }
check(Map<String, Object> context, List<String> ruleList, String taskId) { DefaultContext<String, Object> ctx = new DefaultContext<>(); ctx.putAll(context); ctx.putAll(getRuleRunningContext(taskId)); for (int i = 0; i < ruleList.size(); ++i) { String rule = ruleList.get(i); try { Object tmpRet = EXPRESS_RUNNER.execute(rule, ctx, null, true, false); if ((1 + i) == ruleList.size()) { return (Boolean) tmpRet; }  } catch (QLCompileException e) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } catch (Exception e) { if (Utils.randomLog()) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } return false; } } return true; }
[*] target: assertFalse(rst)
[-] pred: org. junit. Assert. assertFalse ( rst )
************************************
************************************
[+] input: Exception { File directory = createTempDirectory("testInitRepository"); InitCommand command = new InitCommand(); command.setDirectory(directory); command.setInitialBranch("main"); command.setInitialBranch(null); try (Git git = command.call()) { Repository r = git.getRepository(); "<AssertPlaceHolder>"; assertEquals("refs/heads/master", r.getFullBranch()); } }
call() throws GitAPIException { try { RepositoryBuilder builder = new RepositoryBuilder(); if (bare) builder.setBare(); if (fs != null) { builder.setFS(fs); } builder.readEnvironment(); if (gitDir != null) builder.setGitDir(gitDir); else gitDir = builder.getGitDir(); if (directory != null) { if (bare) builder.setGitDir(directory); else { builder.setWorkTree(directory); if (gitDir == null) builder.setGitDir(new File(directory, Constants.DOT_GIT)); } } else if (builder.getGitDir() == null) { String dStr = SystemReader.getInstance() .getProperty("user.dir"); //$NON-NLS-1$ if (dStr == null) dStr = "."; //$NON-NLS-1$ File d = new File(dStr); if (!bare) d = new File(d, Constants.DOT_GIT); builder.setGitDir(d); } else { // directory was not set but gitDir was set if (!bare) { String dStr = SystemReader.getInstance().getProperty( "user.dir"); //$NON-NLS-1$ if (dStr == null) dStr = "."; //$NON-NLS-1$ builder.setWorkTree(new File(dStr)); } } builder.setInitialBranch(StringUtils.isEmptyOrNull(initialBranch) ? SystemReader.getInstance().getUserConfig().getString( ConfigConstants.CONFIG_INIT_SECTION, null, ConfigConstants.CONFIG_KEY_DEFAULT_BRANCH) : initialBranch); Repository repository = builder.build(); if (!repository.getObjectDatabase().exists()) repository.create(bare); return new Git(repository, true); } catch (IOException | ConfigInvalidException e) { throw new JGitInternalException(e.getMessage(), e); } }
[*] target: assertNotNull(r)
[-] pred: org. junit. Assert. assertNotNull ( r )
************************************
************************************
[+] input: testDecryptHandler() { Pair<String, String> pair = EncryptionHandler.decryptHandler("test-dataId", "12345678", "content"); Assert."<AssertPlaceHolder>"; }
decryptHandler(String dataId, String secretKey, String content) { if (!checkCipher(dataId)) { return Pair.with(secretKey, content); } Optional<String> algorithmName = parseAlgorithmName(dataId); Optional<EncryptionPluginService> optional = algorithmName.flatMap( EncryptionPluginManager.instance()::findEncryptionService); if (!optional.isPresent()) { LOGGER.warn("[EncryptionHandler] [decryptHandler] No encryption program with the corresponding name found"); return Pair.with(secretKey, content); } EncryptionPluginService encryptionPluginService = optional.get(); String decryptSecretKey = encryptionPluginService.decryptSecretKey(secretKey); String decryptContent = encryptionPluginService.decrypt(decryptSecretKey, content); return Pair.with(decryptSecretKey, decryptContent); }
[*] target: assertNotNull(pair)
[-] pred: org. junit. Assert. assertNotNull ( pair )
************************************
************************************
[+] input: metaPropertyInitialize() { String[] keys = new String[] { "JDBC_URL", "JDBC_USERNAME", "JDBC_PASSWORD" }; Map<String, String> backup = new HashMap<>(); for (String key : keys) { backup.put(key, System.clearProperty(key)); } try { MetaPropertyInitializer initializer = new MetaPropertyInitializer(); assertFalse(initializer.isPropertyReady()); System.setProperty("JDBC_USERNAME", "test"); assertFalse(initializer.isPropertyReady()); initializer.initialize("127.0.0.1:2881", "test", "user", "pswd"); "<AssertPlaceHolder>"; } finally { for (Entry<String, String> entry : backup.entrySet()) { if (entry.getValue() != null) { System.setProperty(entry.getKey(), entry.getValue()); } } } }
isPropertyReady() { String jdbcUrl = getProperty("JDBC_URL"); String jdbcUsername = getProperty("JDBC_USERNAME"); return !Strings.isNullOrEmpty(jdbcUrl) && !Strings.isNullOrEmpty(jdbcUsername); }
[*] target: assertTrue(initializer.isPropertyReady())
[-] pred: org. junit. Assert. assertTrue ( initializer. isPropertyReady ( ) )
************************************
************************************
[+] input: shouldMatchPositionAfterPut() { final MeteredWindowStore<Integer, String> meteredSessionStore = (MeteredWindowStore<Integer, String>) windowStore; final ChangeLoggingWindowBytesStore changeLoggingSessionBytesStore = (ChangeLoggingWindowBytesStore) meteredSessionStore.wrapped(); final WrappedStateStore rocksDBWindowStore = (WrappedStateStore) changeLoggingSessionBytesStore.wrapped();  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); windowStore.put(0, "0", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); windowStore.put(1, "1", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); windowStore.put(2, "2", SEGMENT_INTERVAL); context.setRecordContext(new ProcessorRecordContext(0, 4, 0, "", new RecordHeaders())); windowStore.put(3, "3", SEGMENT_INTERVAL);  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 4L))))); final Position actual = rocksDBWindowStore.getPosition(); "<AssertPlaceHolder>"; }
put(final Bytes key, final byte[] value, final long windowStartTimestamp) { // Skip if value is null and duplicates are allowed since this delete is a no-op if (!(value == null && retainDuplicates)) { maybeUpdateSeqnumForDups(); wrapped().put(WindowKeySchema.toStoreKeyBinary(key, windowStartTimestamp, seqnum), value); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_duplicateScope_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) duplicate_scope='abcd'"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setDuplicateScope("'abcd'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: getSynonym_testCommonSynonymInfoForOracle() { DBSynonym synonym = accessor.getSynonym(getOracleSchema(), "COMMON_SYNONYM_ACCESSOR", DBSynonymType.COMMON); Assert."<AssertPlaceHolder>"; Assert.assertEquals(DBSynonymType.COMMON, synonym.getSynonymType()); Assert.assertEquals("COMMON_SYNONYM_ACCESSOR", synonym.getSynonymName()); }
getSynonym(String schemaName, String synonymName, DBSynonymType synonymType) { OracleSqlBuilder sb = new OracleSqlBuilder(); sb.append( "select s.OWNER,s.SYNONYM_NAME,s.TABLE_OWNER,s.TABLE_NAME,s.DB_LINK,o.CREATED,o.LAST_DDL_TIME,o.STATUS from "); sb.append(dataDictTableNames.SYNONYMS()); sb.append(" s left join (select * from "); sb.append(dataDictTableNames.OBJECTS()); sb.append(" where OBJECT_TYPE='SYNONYM') o on s.SYNONYM_NAME=o.OBJECT_NAME and s.OWNER=o.OWNER where s.OWNER="); sb.value(getSynonymOwnerSymbol(synonymType, schemaName)); sb.append(" and s.SYNONYM_NAME="); sb.value(synonymName);  DBSynonym synonym = new DBSynonym(); synonym.setSynonymType(synonymType); jdbcOperations.query(sb.toString(), rs -> { synonym.setOwner(rs.getString("OWNER")); synonym.setSynonymName(rs.getString("SYNONYM_NAME")); synonym.setTableOwner(rs.getString("TABLE_OWNER")); synonym.setTableName(rs.getString("TABLE_NAME")); synonym.setDbLink(rs.getString("DB_LINK")); synonym.setCreated(rs.getTimestamp("CREATED")); synonym.setLastDdlTime(rs.getTimestamp("LAST_DDL_TIME")); synonym.setStatus(rs.getString("STATUS")); }); synonym.setDdl(getSynonymDDL(synonym));  return synonym; }
[*] target: assertNotNull(synonym)
[-] pred: org. junit. Assert. assertNotNull ( synonym )
************************************
************************************
[+] input: generate_substring_generateFunctionCallSucceed() { ExprContext context = getExprContext("SUBSTRING('123' from 'abc' for 123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); params.add(new ExpressionParam(new ConstExpression("'abc'"))); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("SUBSTRING", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_weightString3Int_generateFunctionCallSucceed() { ExprContext context = getExprContext("WEIGHT_STRING('123', 1,2,3,4)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("'123'"))); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); params.add(new ExpressionParam(new ConstExpression("3"))); params.add(new ExpressionParam(new ConstExpression("4"))); FunctionCall expect = new FunctionCall("WEIGHT_STRING", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_columnDefBefore_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col varchar(64) before col")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); expect.setLocation(new Location("before", new ColumnReference(null, null, "col"))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_PERCENTILE_DISC_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("PERCENTILE_DISC(all col) within group(order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("PERCENTILE_DISC", Collections.singletonList(new ExpressionParam(new RelationReference("col", null)))); expect.addOption(new ConstExpression("all")); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); expect.setWithinGroup(new OrderBy(Collections.singletonList(s))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_stddevPopExpr_generateFunctionCallSucceed() { ExprContext context = getExprContext("STDDEV_POP(all 1)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); FunctionCall expect = new FunctionCall("STDDEV_POP", params); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: extractResponse_WithNickName_ReturnMatched() { String responseBody = "{"success":true,"errorCode":0,"data":{"username":"user1","nickName":"zhangsan"}}"; when(bastionEncryptionService.decrypt(anyString())).thenReturn(responseBody);  BastionAccount expected = new BastionAccount(); expected.setUsername("user1"); expected.setNickName("zhangsan");  BastionAccount bastionAccount = accountClient.extractResponse(responseBody);  Assert."<AssertPlaceHolder>"; }
extractResponse(String responseBody) { QueryProperties query = bastionProperties.getAccount().getQuery();  String plainResponseBody = decryptResponse(responseBody);  log.debug("Extract response, responseBody={}, plainResponseBody={}", responseBody, plainResponseBody);  Object responseObject = JsonPathUtils.read(plainResponseBody, "$");  String responseBodyValidExpression = query.getResponseBodyValidExpression(); if (StringUtils.isNotBlank(responseBodyValidExpression)) { Expression responseBodyValid = SPEL_PARSER.parseExpression(responseBodyValidExpression); Boolean value = responseBodyValid.getValue(responseObject, Boolean.class); Verify.verify(Boolean.TRUE.equals(value), "Response body invalid, expect " + responseBodyValidExpression + " , response body " + plainResponseBody); }  String responseBodyUsernameExtractExpression = query.getResponseBodyUsernameExtractExpression(); Expression responseBodyUsernameExtract = SPEL_PARSER.parseExpression(responseBodyUsernameExtractExpression);  String username = responseBodyUsernameExtract.getValue(responseObject, String.class); Verify.notBlank(username, "Extract username got blank result, expression=" + responseBodyUsernameExtractExpression + ", response body " + plainResponseBody);  BastionAccount account = new BastionAccount(); account.setUsername(username);  String responseBodyNickNameExtractExpression = query.getResponseBodyNickNameExtractExpression(); String nickName = null; if (StringUtils.isNotBlank(responseBodyNickNameExtractExpression)) { Expression responseBodyNickNameExtract = SPEL_PARSER.parseExpression(responseBodyNickNameExtractExpression); nickName = responseBodyNickNameExtract.getValue(responseObject, String.class); } account.setNickName(StringUtils.isBlank(nickName) ? username : nickName); return account; }
[*] target: assertEquals(expected, bastionAccount)
[-] pred: org. junit. Assert. assertEquals ( expected, bastionAccount )
************************************
************************************
[+] input: fromJsonList() { String json = "[{"col1":"abc"}]";  List<A> aList = JsonUtils.fromJsonList(json, A.class);  List<A> expected = new ArrayList<>(); expected.add(new A("abc")); Assert."<AssertPlaceHolder>"; }
fromJsonList(String json, Class<T> classType) { if (json == null) { return null; } try { CollectionType javaType = OBJECT_MAPPER.getTypeFactory().constructCollectionType(List.class, classType); return OBJECT_MAPPER.readValue(json, javaType); } catch (JsonProcessingException e) { return null; } }
[*] target: assertEquals(expected, aList)
[-] pred: org. junit. Assert. assertEquals ( expected, aList )
************************************
************************************
[+] input: NacosException { String dataId = "1"; String group = "2"; String content = "123"; String namespace = ""; String casMd5 = "96147704e3cb8be8597d55d75d244a02"; String type = ConfigType.getDefaultType().getType();  Mockito.when(mockWoker.publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type)) .thenReturn(true);  final boolean b = nacosConfigService.publishConfigCas(dataId, group, content, casMd5); Assert."<AssertPlaceHolder>";  Mockito.verify(mockWoker, Mockito.times(1)) .publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type); }
publishConfigCas(String dataId, String group, String content, String casMd5) throws NacosException { return publishConfigInner(namespace, dataId, group, null, null, null, content, ConfigType.getDefaultType().getType(), casMd5); }
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
************************************
************************************
[+] input: generate_modifyHashPartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("partition by hash(a)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setModifyPartition(new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), null, null, null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_alterExternalTable1_succeed() { StatementFactory<AlterTable> factory = new MySQLAlterTableFactory( getAlterContext("alter external table a.b refresh")); AlterTable actual = factory.generate();  AlterTableAction a = new AlterTableAction(); a.setRefresh(true); AlterTable expect = new AlterTable("b", Collections.singletonList(a)); expect.setExternal(true); expect.setSchema("a"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testSetConnectionKeepAlive() { long connectionKeepAlive = 5000; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setConnectionKeepAlive(connectionKeepAlive); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
connectionKeepAlive() { return connectionKeepAlive; }
[*] target: assertEquals(connectionKeepAlive, config.connectionKeepAlive())
[-] pred: org. junit. Assert. assertEquals ( connectionKeepAlive, config. connectionKeepAlive() )
************************************
************************************
[+] input: getAllSubscribeService() { Collection<Service> allSubscribeService = abstractClient.getAllSubscribeService(); Assert."<AssertPlaceHolder>"; }
getAllSubscribeService() { return subscribers.keySet(); }
[*] target: assertNotNull(allSubscribeService)
[-] pred: org. junit. Assert. assertNotNull ( allSubscribeService )
************************************
************************************
[+] input: Exception { CancelledTestMonitor m = new CancelledTestMonitor(); try (CancellableDigestOutputStream out = new CancellableDigestOutputStream( m, NullOutputStream.INSTANCE)) { byte[] KB = new byte[1024]; int triggerCancelWriteCnt = BYTES_TO_WRITE_BEFORE_CANCEL_CHECK / KB.length; for (int i = 0; i < triggerCancelWriteCnt + 1; i++) { out.write(KB); } assertTrue(out.length() > BYTES_TO_WRITE_BEFORE_CANCEL_CHECK); m.setCancelled(true);  for (int i = 0; i < triggerCancelWriteCnt - 1; i++) { out.write(KB); }  long lastLength = out.length(); assertThrows(InterruptedIOException.class, () -> { out.write(1); }); assertEquals(lastLength, out.length());  assertThrows(InterruptedIOException.class, () -> { out.write(new byte[1]); }); "<AssertPlaceHolder>"; } }
length() { return count; }
[*] target: assertEquals(lastLength, out.length())
[-] pred: org. junit. Assert. assertEquals ( lastLength, out. length() )
************************************
************************************
[+] input: listAll_NoRecord_Empty() { List<SchemaHistory> list = repository.listAll();  Assert."<AssertPlaceHolder>"; }
listAll() { String sql = new StringBuilder() .append("select ") .append(ALL_COLUMNS) .append(" from ") .append("`").append(table).append("`") .toString(); return jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(SchemaHistory.class)); }
[*] target: assertEquals(0, list.size())
[-] pred: org. junit. Assert. assertEquals ( 0, list. size ( ) )
************************************
************************************
[+] input: getSubscriber() { addServiceSubscriber(); Subscriber subscriber1 = abstractClient.getSubscriber(service); Assert."<AssertPlaceHolder>"; }
getSubscriber(Service service) { return subscribers.get(service); }
[*] target: assertNotNull(subscriber1)
[-] pred: org. junit. Assert. assertNotNull ( subscriber1 )
************************************
************************************
[+] input: validateExists_Exists_ReturnTrue() { boolean ret = PreConditions.validExists(ResourceType.OB_TABLE, "tableName", "t1", () -> true); Assert."<AssertPlaceHolder>"; }
validExists(ResourceType resourceType, String parameterName, Object parameterValue, BooleanSupplier existsChecker) { if (existsChecker.getAsBoolean()) { return true; } throw new NotFoundException(ErrorCodes.NotFound, new Object[] {resourceType.getLocalizedMessage(), parameterName, parameterValue}, String.format("%s not found by %s=%s", resourceType, parameterName, parameterValue.toString())); }
[*] target: assertTrue(ret)
[-] pred: org. junit. Assert. assertTrue ( ret )
************************************
************************************
[+] input: createOperatorProxyFactory() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); OperatorProxyFactory factory = ConfigurationUtil.createOperatorProxyFactory(configuration); Assert."<AssertPlaceHolder>"; }
createOperatorProxyFactory(Crane4jGlobalConfiguration configuration) { AnnotationFinder annotationFinder = SimpleAnnotationFinder.INSTANCE; OperatorProxyFactory operatorProxyFactory = OperatorProxyFactory.builder() .globalConfiguration(configuration) .annotationFinder(annotationFinder) .proxyFactory(DefaultProxyFactory.INSTANCE) .build(); operatorProxyFactory.addProxyMethodFactory(new OperationAnnotationProxyMethodFactory(configuration.getConverterManager())); operatorProxyFactory.addProxyMethodFactory(new DynamicContainerOperatorProxyMethodFactory( configuration.getConverterManager(), SimpleParameterNameFinder.INSTANCE, annotationFinder, DefaultContainerAdapterRegister.INSTANCE )); operatorProxyFactory.addProxyMethodFactory(new ParametersFillProxyMethodFactory( configuration.getBeanOperationsParser(BeanOperationParser.class) )); return operatorProxyFactory; }
[*] target: assertNotNull(factory)
[-] pred: org. junit. Assert. assertNotNull ( factory )
************************************
************************************
[+] input: shouldNotForwardCleanEntryOnEviction() { final ThreadCache cache = new ThreadCache(logContext, 0, new MockStreamsMetrics(new Metrics())); final List<ThreadCache.DirtyEntry> received = new ArrayList<>(); cache.addDirtyEntryFlushListener(namespace, received::addAll); cache.put(namespace, Bytes.wrap(new byte[]{1}), cleanEntry(new byte[]{0})); "<AssertPlaceHolder>"; }
size() { long size = 0; for (final NamedCache cache : caches.values()) { size += cache.size(); if (isOverflowing(size)) { return Long.MAX_VALUE; } } return size; }
[*] target: assertEquals(0, received.size())
[-] pred: org. junit. Assert. assertEquals ( 0, received. size ( ) )
************************************
************************************
[+] input: getInstancePublishInfo() { addServiceInstance(); InstancePublishInfo publishInfo = abstractClient.getInstancePublishInfo(service); Assert."<AssertPlaceHolder>"; }
getInstancePublishInfo(Service service) { return publishers.get(service); }
[*] target: assertNotNull(publishInfo)
[-] pred: org. junit. Assert. assertNotNull ( publishInfo )
************************************
************************************
[+] input: generate_sortKey_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) sortkey (a,b)"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions .setSortKeys(Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b"))); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_splitPartitionRange_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b at(1,2) into (partition,partition id 12,partition a.b id 13)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); actions.setRangeExprs(Arrays.asList(new ConstExpression("1"), new ConstExpression("2"))); SpecialPartitionElement e1 = new SpecialPartitionElement(null); SpecialPartitionElement e2 = new SpecialPartitionElement(null); PartitionOptions o1 = new PartitionOptions(); o1.setId(12); e2.setPartitionOptions(o1); SpecialPartitionElement e3 = new SpecialPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setId(13); e3.setPartitionOptions(o2); e3.setSchema("a"); actions.setIntos(Arrays.asList(e1, e2, e3)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: implies_resourcePermissionWithWildChar_impliesTrue() { ResourcePermission permission = new ResourcePermission( new DefaultSecurityResource("12", "conn"), "create,write,update, delete, readwrite,read"); ResourcePermission permission1 = new ResourcePermission(new DefaultSecurityResource("12", "conn"), "*"); Assert."<AssertPlaceHolder>"; }
implies(Permission p) { if (!(p instanceof ResourcePermission)) { return false; } ResourcePermission that = (ResourcePermission) p; // we get the effective mask. i.e., the "and" of this and that. // They must be equal to that.mask for implies to return true. return ((this.mask & that.mask) == that.mask) && impliesIgnoreMask(that); }
[*] target: assertTrue(permission.implies(permission1))
[-] pred: org. junit. Assert. assertTrue ( permission. implies( permission1 ) )
************************************
************************************
[+] input: shouldLogAWarningIfCheckpointThrowsAnIOException() { final ProcessorStateManager stateMgr = getStateManager(Task.TaskType.ACTIVE); stateMgr.registerStore(persistentStore, persistentStore.stateRestoreCallback, null); stateDirectory.clean();  try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(ProcessorStateManager.class)) { stateMgr.updateChangelogOffsets(singletonMap(persistentStorePartition, 10L)); stateMgr.checkpoint();  boolean foundExpectedLogMessage = false; for (final LogCaptureAppender.Event event : appender.getEvents()) { if ("WARN".equals(event.getLevel()) && event.getMessage().startsWith("process-state-manager-test Failed to write offset checkpoint file to [") && event.getMessage().endsWith(".checkpoint]." + " This may occur if OS cleaned the state.dir in case when it located in ${java.io.tmpdir} directory." + " This may also occur due to running multiple instances on the same machine using the same state dir." + " Changing the location of state.dir may resolve the problem.") && event.getThrowableInfo().get().startsWith("java.io.FileNotFoundException: ")) {  foundExpectedLogMessage = true; break; } } "<AssertPlaceHolder>"; } }
checkpoint() { // checkpoint those stores that are only logged and persistent to the checkpoint file final Map<TopicPartition, Long> checkpointingOffsets = new HashMap<>(); for (final StateStoreMetadata storeMetadata : stores.values()) { if (storeMetadata.commitCallback != null && !storeMetadata.corrupted) { try { storeMetadata.commitCallback.onCommit(); } catch (final IOException e) { throw new ProcessorStateException( format("%sException caught while trying to checkpoint store, " + "changelog partition %s", logPrefix, storeMetadata.changelogPartition), e ); } }  // store is logged, persistent, not corrupted, and has a valid current offset if (storeMetadata.changelogPartition != null && storeMetadata.stateStore.persistent() && !storeMetadata.corrupted) {  final long checkpointableOffset = checkpointableOffsetFromChangelogOffset(storeMetadata.offset); checkpointingOffsets.put(storeMetadata.changelogPartition, checkpointableOffset); } }  log.debug("Writing checkpoint: {} for task {}", checkpointingOffsets, taskId); try { checkpointFile.write(checkpointingOffsets); } catch (final IOException e) { log.warn("Failed to write offset checkpoint file to [{}]." + " This may occur if OS cleaned the state.dir in case when it located in ${java.io.tmpdir} directory." + " This may also occur due to running multiple instances on the same machine using the same state dir." + " Changing the location of state.dir may resolve the problem.", checkpointFile, e); } }
[*] target: assertTrue(foundExpectedLogMessage)
[-] pred: org. junit. Assert. assertTrue ( foundExpectedLogMessage )
************************************
************************************
[+] input: generate_exprGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by col"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();  GroupBy expect = new GeneralGroupBy(new RelationReference("col", null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.groupbyElementContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_createIndex_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_alterIndex_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter index abc visible")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexVisibility("abc", true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_updateWithPartitionUsage_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE schema.tab PARTITION(p1,p2) SET col=1;"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference("schema", "tab", null); nameReference.setPartitionUsage(new PartitionUsage(PartitionType.PARTITION, Arrays.asList("p1", "p2"))); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: NacosException { when(rpcClientConfig.timeOutMills()).thenReturn(5000L); when(rpcClientConfig.retryTimes()).thenReturn(3); rpcClient.rpcClientStatus.set(RpcClientStatus.RUNNING); rpcClient.currentConnection = connection; doThrow(NacosException.class).when(connection).requestFuture(any()); Exception exception = null;  try { rpcClient.requestFuture(null); } catch (NacosException e) { exception = e; }  verify(connection, times(4)).requestFuture(any()); verify(rpcClient).switchServerAsyncOnRequestFail(); Assert."<AssertPlaceHolder>"; assertEquals(RpcClientStatus.UNHEALTHY, rpcClient.rpcClientStatus.get()); }
switchServerAsyncOnRequestFail() { switchServerAsync(null, true); }
[*] target: assertNotNull(exception)
[-] pred: org. junit. Assert. assertNotNull ( exception )
************************************
************************************
[+] input: Exception { PowerMockito.whenNew(DefaultConnector.class).withAnyArguments().thenReturn(defaultConnector); Method methodGetObVersion = PowerMockito.method(ObConnectTemplate.class, "getObVersion"); PowerMockito.replace(methodGetObVersion).with((proxy, method, args) -> "2.4.0");  ObOperator operator = ObOperators.newMetaOperator(connectProperties.withCompatibilityMode(CompatibilityMode.MYSQL)); "<AssertPlaceHolder>"; assertNotNull(operator.cluster()); assertNotNull(operator.parameter()); }
newMetaOperator(ConnectProperties connectProperties) { ObConnectTemplate obConnectTemplate = new ObConnectTemplate(connectProperties); return ObOperator.builder() .clusterOperator(newClusterOperator(obConnectTemplate)) .parameterOperator(newParameterOperator(obConnectTemplate)) .build(); }
[*] target: assertNotNull(operator)
[-] pred: org. junit. Assert. assertNotNull ( operator )
************************************
************************************
[+] input: IOException { final Map<TopicPartition, Long> expected = writeCheckpoint();  stateManager.initialize(); final Map<TopicPartition, Long> offsets = stateManager.changelogOffsets(); "<AssertPlaceHolder>"; }
changelogOffsets() { return Collections.unmodifiableMap(checkpointFileCache); }
[*] target: assertEquals(expected, offsets)
[-] pred: org. junit. Assert. assertEquals ( expected, offsets )
************************************
************************************
[+] input: testToEntity_putDropStatementInComments_success() { String actual = buildResult().toEntity(1L, DialectType.OB_MYSQL).getChangeSqlScript(); String expected = "-- Unsupported operation to drop primary key constraint\n" + "\n" + "/*\n" + "ALTER TABLE `tgtSchema`.`t1` DROP COLUMN `c1`;\n" + "*/\n" + "\n" + "/*\n" + "ALTER TABLE `tgtSchema`.`t1` DROP PARTITION (p1);\n" + "*/\n" + "\n" + "/*\n" + "ALTER TABLE `tgtSchema`.`t1` DROP PARTITION (p2);\n" + "*/\n" + "\n" + "ALTER TABLE `tgtSchema`.`t1` ADD PARTITION (p2);\n" + "\n" + "ALTER TABLE `tgtSchema`.`t1` COMMENT = 'comment1';\n" + "-- Unsupported operation to modify table charset\n"; Assert."<AssertPlaceHolder>";  }
toEntity(@NonNull Long structureComparisonTaskId, @NonNull DialectType dialectType) { StructureComparisonTaskResultEntity entity = new StructureComparisonTaskResultEntity(); entity.setStructureComparisonTaskId(structureComparisonTaskId); entity.setDatabaseObjectType(dbObjectType); entity.setDatabaseObjectName(dbObjectName); entity.setComparingResult(comparisonResult); entity.setSourceDatabaseObjectDdl(sourceDdl); entity.setTargetDatabaseObjectDdl(targetDdl);  /** * DDL operations involving deletion of database objects are placed in comments */ if (ComparisonResult.ONLY_IN_TARGET == comparisonResult) { entity.setChangeSqlScript("/*\n " + changeScript + "*/\n"); return entity; } StringBuilder totalSubScript = new StringBuilder(); if (!subDBObjectComparisonResult.isEmpty()) { for (DBObjectComparisonResult subResult : subDBObjectComparisonResult) { if (subResult.getChangeScript() == null || subResult.getChangeScript().isEmpty()) { continue; } DBObjectType objectType = subResult.getDbObjectType(); if (subResult.getComparisonResult() == ComparisonResult.ONLY_IN_TARGET) { totalSubScript.append("/*\n") .append(subResult.getChangeScript()) .append("*/\n\n"); } else if (objectType == DBObjectType.PARTITION || objectType == DBObjectType.CONSTRAINT || objectType == DBObjectType.INDEX) { List<String> sqls = SqlUtils.split(dialectType, subResult.getChangeScript(), ";"); for (String sql : sqls) { String sqlWithoutComment = SqlUtils.removeComments(new SqlCommentProcessor(dialectType, false, false), sql); String comments = sql.replace(sqlWithoutComment, ""); if (SqlType.DROP.equals(parseSingleSqlType(dialectType, sqlWithoutComment))) { totalSubScript.append(comments) .append("/*\n") .append(appendDelimiterIfNotExists(sqlWithoutComment)) .append("*/\n\n"); } else { if (StringUtils.isNotEmpty(sqlWithoutComment)) { totalSubScript.append(appendDelimiterIfNotExists(sqlWithoutComment)); } if (StringUtils.isNotEmpty(comments)) { totalSubScript.append(comments).append("\n"); } } } } else { totalSubScript.append(subResult.getChangeScript()).append("\n"); } } } if (StringUtils.isNotEmpty(changeScript)) { entity.setChangeSqlScript(totalSubScript + "\n" + changeScript); } else { entity.setChangeSqlScript(totalSubScript.toString()); } return entity; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_charsetAndCollation_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) default charset=utf8,collate=u8mb4,locality='abcd' force"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setLocality("'abcd' force"); tableOptions.setCharset("utf8"); tableOptions.setCollation("u8mb4"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testUdfQuery() { boolean rst = RuleRunner.getInstance() .check( new HashMap<>(), Lists.newArrayList("'0123456789' == concat(0,1,2,3,4,5,6,7,8,9)"), ""); Assert."<AssertPlaceHolder>"; }
getInstance() { if (null != instance) { return instance; } synchronized (RuleRunner.class) { if (null == instance) { RuleRunner runner = new RuleRunner(); runner.init(); instance = runner; } } return instance; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
************************************
[+] input: testStringEmptyAndThenExecuteFail() { String word = ""; final String expect = "call"; String actual = TemplateUtils.stringEmptyAndThenExecute(word, () -> expect); Assert."<AssertPlaceHolder>"; }
stringEmptyAndThenExecute(String source, Callable<String> callable) {  if (StringUtils.isEmpty(source)) {  try { return callable.call(); } catch (Exception e) { LogUtils.NAMING_LOGGER.error("string empty and then execute cause an exception.", e); } }  return source == null ? null : source.trim(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_xmlSerializeEncodingVersion3_generateSucceed() { ExprContext context = getExprContext( "xmlSerialize(content 'aaa' as int encoding 'aaa' version 12 indent)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlSerialize", Collections.singletonList(p1)); expect.addOption(new ConstExpression("content")); expect.addOption(new ConstExpression("encoding 'aaa'")); expect.addOption(new ConstExpression("version 12")); expect.addOption(new ConstExpression("indent")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: test_findByUpdateTimeBeforeAndTemp_return1() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.PRIVATE); connection.setTemp(true); repository.save(connection); List<ConnectionEntity> entities = repository.findByUpdateTimeBeforeAndTemp(new Date(new Date().getTime() + 5 * 1000L), true); Assert."<AssertPlaceHolder>"; }
findByUpdateTimeBeforeAndTemp(Date updateTime, Boolean temp);  List<ConnectionEntity> findByOrganizationIdAndNameIn(Long organizationId, Collection<String> names);  Optional<ConnectionEntity> findByVisibleScopeAndOwnerIdAndName(ConnectionVisibleScope visibleScope, Long ownerId, String name);  Optional<ConnectionEntity> findByOrganizationIdAndName(Long organizationId, String name);  List<ConnectionEntity> findByOrganizationId(Long organizationId);  List<ConnectionEntity> findByOrganizationIdIn(Collection<Long> organizationIds);  List<ConnectionEntity> findByProjectId(Long projectId);  @Transactional @Query(value = "select distinct(c_c.*) from `connect_connection` as c_c inner join `connect_database` as c_d " + "on c_c.id = c_d.connection_id where c_d.project_id = :projectId", nativeQuery = true) List<ConnectionEntity> findByDatabaseProjectId(@Param("projectId") Long projectId);  @Transactional @Query(value = "select `id` from `connect_connection` where `host`=:host", nativeQuery = true) @Modifying Set<Long> findIdsByHost(@Param("host") String host);  List<ConnectionEntity> findByIdIn(Collection<Long> ids);  List<ConnectionEntity> findByVisibleScopeAndOrganizationId(ConnectionVisibleScope visibleScope, Long organizationId);  List<ConnectionEntity> findByVisibleScopeAndCreatorId(ConnectionVisibleScope visibleScope, Long creatorId);  List<ConnectionEntity> findByVisibleScope(ConnectionVisibleScope visibleScope);  List<ConnectionEntity> findByOrganizationIdAndEnvironmentId(Long organizationId, Long environmentId);  @Transactional int deleteByVisibleScopeAndOwnerId(ConnectionVisibleScope visibleScope, Long ownerId);  @Query("SELECT e.id FROM #{#entityName}
[*] target: assertEquals(1, entities.size())
[-] pred: org. junit. Assert. assertEquals ( 1, entities. size ( ) )
************************************
************************************
[+] input: generate_jsonTable2_generateSucceed() { ExprContext context = getExprContext("json_table('123' format json, 'aaa' " + "error_p on error_p null on empty columns " + ""abcd" FOR ORDINALITY, " + "col1 int truncate exists path 123 asis true on empty, " + "col2 json DISALLOW SCALARS WITH CONDITIONAL ARRAY WRAPPER path col21 asis empty on empty, " + "col3 blob format json truncate allow SCALARS WITH ARRAY WRAPPER path col31 asis empty on empty, " + "col4 nchar(12) truncate path col41[*] asis default -3 on empty, " + "nested path 123 columns(col5))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'123'")); p1.addOption(new ConstExpression("format json")); FunctionParam p2 = new ExpressionParam(new ConstExpression("'aaa'")); FunctionCall expect = new FunctionCall("json_table", Arrays.asList(p1, p2)); JsonOnOption onOption = new JsonOnOption(); onOption.setOnError(new ConstExpression("error_p")); onOption.setOnEmpty(new NullExpression()); expect.addOption(onOption);  FunctionParam op1 = new ExpressionParam(new ColumnReference(null, null, ""abcd"")); op1.addOption(new ConstExpression("FOR ORDINALITY")); expect.addOption(op1); FunctionParam op2 = new ExpressionParam(new ColumnReference(null, null, "col1")); op2.addOption(new NumberType("int", null, null)); op2.addOption(new ConstExpression("truncate")); op2.addOption(new ConstExpression("exists")); op2.addOption(new ConstExpression("123")); onOption = new JsonOnOption(); onOption.setOnEmpty(new BoolValue(true)); op2.addOption(onOption); expect.addOption(op2); FunctionParam op3 = new ExpressionParam(new ColumnReference(null, null, "col2")); op3.addOption(new GeneralDataType("json", null)); JsonConstraint jc = new JsonConstraint(); jc.setScalarsMode(ScalarsMode.DISALLOW_SCALARS); jc.setWrapperMode(WrapperMode.WITH_CONDITIONAL_ARRAY_WRAPPER); op3.addOption(jc); op3.addOption(new ColumnReference(null, null, "col21")); onOption = new JsonOnOption(); onOption.setOnEmpty(new ConstExpression("empty")); op3.addOption(onOption); expect.addOption(op3);  FunctionParam op4 = new ExpressionParam(new ColumnReference(null, null, "col3")); op4.addOption(new GeneralDataType("blob", null)); op4.addOption(new ConstExpression("format json")); op4.addOption(new ConstExpression("truncate")); jc = new JsonConstraint(); jc.setScalarsMode(ScalarsMode.ALLOW_SCALARS); jc.setWrapperMode(WrapperMode.WITH_ARRAY_WRAPPER); op4.addOption(jc); op4.addOption(new ColumnReference(null, null, "col31")); op4.addOption(onOption); expect.addOption(op4);  FunctionParam op5 = new ExpressionParam(new ColumnReference(null, null, "col4")); op5.addOption(new CharacterType("nchar", new BigDecimal("12"))); op5.addOption(new ConstExpression("truncate")); ColumnReference rc = new ColumnReference(null, null, "col41"); CollectionExpression es = new CollectionExpression(); es.addExpression(new ConstExpression("*")); rc.reference(es, ReferenceOperator.BRACKET); op5.addOption(rc); onOption = new JsonOnOption(); onOption.setOnEmpty(new CompoundExpression(new ConstExpression("3"), null, Operator.SUB)); op5.addOption(onOption); expect.addOption(op5); FunctionParam op6 = new ExpressionParam(new ConstExpression("nested path")); op6.addOption(new ConstExpression("123")); op6.addOption(new ExpressionParam(new ColumnReference(null, null, "col5"))); expect.addOption(op6); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { CreateConnectorRequest requestToWrite = new CreateConnectorRequest( CONNECTOR_NAME, CONNECTOR_CONFIG, CreateConnectorRequest.InitialState.STOPPED );  try (FileWriter writer = new FileWriter(connectorConfigurationFile)) { writer.write(new ObjectMapper().writeValueAsString(requestToWrite)); }  CreateConnectorRequest parsedRequest = connectStandalone.parseConnectorConfigurationFile(connectorConfigurationFile.getAbsolutePath()); "<AssertPlaceHolder>"; }
parseConnectorConfigurationFile(String filePath) throws IOException { ObjectMapper objectMapper = new ObjectMapper();  File connectorConfigurationFile = Paths.get(filePath).toFile(); try { Map<String, String> connectorConfigs = objectMapper.readValue( connectorConfigurationFile, new TypeReference<Map<String, String>>() { });  if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into a Map with String keys and values", filePath); }  try { objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); CreateConnectorRequest createConnectorRequest = objectMapper.readValue(connectorConfigurationFile, new TypeReference<CreateConnectorRequest>() { }); if (createConnectorRequest.config().containsKey(NAME_CONFIG)) { if (!createConnectorRequest.config().get(NAME_CONFIG).equals(createConnectorRequest.name())) { throw new ConnectException("Connector name configuration in 'config' doesn't match the one specified in 'name' at '" + filePath + "'"); } } else { createConnectorRequest.config().put(NAME_CONFIG, createConnectorRequest.name()); } return createConnectorRequest; } catch (StreamReadException | DatabindException e) { log.debug("Could not parse connector configuration file '{}' into an object of type {}", filePath, CreateConnectorRequest.class.getSimpleName()); }  Map<String, String> connectorConfigs = Utils.propsToStringMap(Utils.loadProps(filePath)); if (!connectorConfigs.containsKey(NAME_CONFIG)) { throw new ConnectException("Connector configuration at '" + filePath + "' is missing the mandatory '" + NAME_CONFIG + "' " + "configuration"); } return new CreateConnectorRequest(connectorConfigs.get(NAME_CONFIG), connectorConfigs, null); }
[*] target: assertEquals(requestToWrite, parsedRequest)
[-] pred: org. junit. Assert. assertEquals ( requestToWrite, parsedRequest )
************************************
************************************
[+] input: generate_expireInfo_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) expire_info=(1)"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setExpireInfo(new ConstExpression("1")); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_changes() { final ConnectPacketImpl packet = new ConnectPacketImpl( MqttVersion.V_5, "clientId", false, 100, 60, 3, 1000, 10, true, true, null, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiableConnectPacketImpl modifiablePacket = new ModifiableConnectPacketImpl(packet, configurationService);  modifiablePacket.setClientId("modifiedClientId"); modifiablePacket.setCleanStart(true); modifiablePacket.setSessionExpiryInterval(60); modifiablePacket.setKeepAlive(10); modifiablePacket.setReceiveMaximum(2); modifiablePacket.setMaximumPacketSize(100); modifiablePacket.setTopicAliasMaximum(1); modifiablePacket.setRequestProblemInformation(false); modifiablePacket.setRequestResponseInformation(false); modifiablePacket.setUserName("username"); modifiablePacket.setPassword(ByteBuffer.wrap("password".getBytes())); modifiablePacket.setAuthenticationMethod("authMethod"); modifiablePacket.setAuthenticationData(ByteBuffer.wrap("authData".getBytes())); modifiablePacket.setWillPublish(new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, null, false, 10, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L)); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final ConnectPacketImpl copy = modifiablePacket.copy();  final ConnectPacketImpl expectedPacket = new ConnectPacketImpl( MqttVersion.V_5, "modifiedClientId", true, 60, 10, 2, 100, 1, false, false, "username", ByteBuffer.wrap("password".getBytes()), "authMethod", ByteBuffer.wrap("authData".getBytes()), new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, null, false, 10, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue")))); "<AssertPlaceHolder>"; }
copy() { return new ConnectPacketImpl(mqttVersion, clientId, cleanStart, sessionExpiryInterval, keepAlive, receiveMaximum, maximumPacketSize, topicAliasMaximum, requestProblemInformation, requestResponseInformation, userName, password, authenticationMethod, authenticationData, (willPublish == null) ? null : willPublish.copy(), userProperties.copy()); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred: org. junit. Assert. assertEquals ( expectedPacket, copy )
************************************
************************************
[+] input: generate_sys_interval_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("INTERVAL(12, 13,15)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); params.add(new ExpressionParam(new ConstExpression("13"))); params.add(new ExpressionParam(new ConstExpression("15"))); FunctionCall expect = new FunctionCall("INTERVAL", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_regExp_generateSucceed() { PredicateContext context = getPredicateContext("regexp_like(1,2)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("regexp_like", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")))); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: queryByNameTest() { String name = "doris"; LogStorageTypeEnum storageTypeEnum = LogStorageTypeEnum.queryByName(name); Assert."<AssertPlaceHolder>"; log.info("result:{}", storageTypeEnum); }
queryByName(String name) { if (null == name || name.isEmpty()) { return null; } for (LogStorageTypeEnum value : values()) { if (value.name().equals(name.toUpperCase())) { return value; } } return null; }
[*] target: assertNotNull(storageTypeEnum)
[-] pred: org. junit. Assert. assertNotNull ( storageTypeEnum )
************************************
************************************
[+] input: generate_createTableLike_generateSucceed() { Create_table_like_stmtContext context = getCreateTableLikeContext("create table if not exists abcd like a.b"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setIfNotExists(true); RelationFactor likeTable = new RelationFactor("b"); likeTable.setSchema("a"); expect.setLikeTable(likeTable); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_xmlFunction_generateSucceed() { ExprContext context = getExprContext("xmlcast('aaa' as int)."aaa".count(*)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionParam p1 = new ExpressionParam(new ConstExpression("'aaa'")); p1.addOption(new NumberType("int", null, null)); FunctionCall expect = new FunctionCall("xmlcast", Collections.singletonList(p1)); expect.reference(new RelationReference(""aaa"", null), ReferenceOperator.DOT) .reference(new FunctionCall("count", Collections.singletonList( new ExpressionParam(new ConstExpression("*")))), ReferenceOperator.DOT); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: test_ModelToEntity_Success() { AuditEvent model = AuditEvent.builder() .connectionName("test") .connectionId(1L) .clientIpAddress("0.0.0.0") .serverIpAddress("0.0.0.0") .organizationId(1L) .taskId("1") .action(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION) .type(AuditEventType.PERSONAL_CONFIGURATION) .userId(1L) .username("account") .result(AuditEventResult.SUCCESS) .detail("{detail:null}") .build();  AuditEventEntity expected = new AuditEventEntity(); expected.setConnectionName("test"); expected.setConnectionId(1L); expected.setTaskId("1"); expected.setResult(AuditEventResult.SUCCESS); expected.setDetail("{detail:null}"); expected.setUserId(1L); expected.setOrganizationId(1L); expected.setServerIpAddress("0.0.0.0"); expected.setClientIpAddress("0.0.0.0"); expected.setAction(AuditEventAction.UPDATE_PERSONAL_CONFIGURATION); expected.setType(AuditEventType.PERSONAL_CONFIGURATION); expected.setUsername("account");  AuditEventEntity actual = mapper.modelToEntity(model); Assert."<AssertPlaceHolder>"; }
modelToEntity(AuditEvent model);
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_modifyListPartition_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("partition by list(a) partitions 145 (" + "partition a.b values in (default) engine=InnoDB," + "partition d values in (3) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); expect.setModifyPartition(new ListPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 145, false)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testKeywordConvert() { RuleExprParser ruleExprParser = new RuleExprParser(); Expr e = ruleExprParser.parse("A.alias == B.alias && A.when == B.id");  Expr2QlexpressTransformer transformer = new Expr2QlexpressTransformer(RuleRunner::convertPropertyName);  List<String> rules = Lists.newArrayList(JavaConversions.asJavaCollection(transformer.transform(e))); Map<String, Object> context = new HashMap<>(); context.put( "A", new HashMap<String, String>() { { put(RuleRunner.convertPropertyName("alias"), "alias_value"); put(RuleRunner.convertPropertyName("when"), "id_value"); } });  context.put( "B", new HashMap<String, String>() { { put(RuleRunner.convertPropertyName("alias"), "alias_value"); put(RuleRunner.convertPropertyName("id"), "id_value"); } });  boolean rst = RuleRunner.getInstance().check(context, rules, ""); Assert."<AssertPlaceHolder>"; }
check(Map<String, Object> context, List<String> ruleList, String taskId) { DefaultContext<String, Object> ctx = new DefaultContext<>(); ctx.putAll(context); ctx.putAll(getRuleRunningContext(taskId)); for (int i = 0; i < ruleList.size(); ++i) { String rule = ruleList.get(i); try { Object tmpRet = EXPRESS_RUNNER.execute(rule, ctx, null, true, false); if ((1 + i) == ruleList.size()) { return (Boolean) tmpRet; }  } catch (QLCompileException e) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } catch (Exception e) { if (Utils.randomLog()) { log.warn("RuleRunner error, rule=" + rule + ",ctx=" + JSON.toJSONString(context), e); } return false; } } return true; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
************************************
[+] input: testPatchConfig() { HashMap<String, String> config = new HashMap<>(); config.put("unaffected-key", "unaffected-value"); config.put("to-be-changed-key", "to-be-changed-value-old"); config.put("to-be-deleted-key", "to-be-deleted-value");  HashMap<String, String> patch = new HashMap<>(); patch.put("to-be-changed-key", "to-be-changed-value-new"); patch.put("to-be-deleted-key", null); patch.put("to-be-added-key", "to-be-added-value");  HashMap<String, String> expectedResult = new HashMap<>(); expectedResult.put("unaffected-key", "unaffected-value"); expectedResult.put("to-be-changed-key", "to-be-changed-value-new"); expectedResult.put("to-be-added-key", "to-be-added-value");  Map<String, String> result = ConnectUtils.patchConfig(config, patch); "<AssertPlaceHolder>"; }
patchConfig( Map<String, String> config, Map<String, String> patch ) { Map<String, String> result = new HashMap<>(config); patch.forEach((k, v) -> { if (v != null) { result.put(k, v); } else { result.remove(k); } }); return result; }
[*] target: assertEquals(expectedResult, result)
[-] pred: org. junit. Assert. assertEquals ( expectedResult, result )
************************************
************************************
[+] input: testCollidingSimpleAlias() { SortedSet<PluginDesc<Converter>> converters = new TreeSet<>(); converters.add(new PluginDesc<>(CollidingConverter.class, null, PluginType.CONVERTER, CollidingConverter.class.getClassLoader())); SortedSet<PluginDesc<Transformation<?>>> transformations = new TreeSet<>(); transformations.add(new PluginDesc<>((Class<? extends Transformation<?>>) (Class<?>) Colliding.class, null, PluginType.TRANSFORMATION, Colliding.class.getClassLoader())); PluginScanResult result = new PluginScanResult( Collections.emptySortedSet(), Collections.emptySortedSet(), converters, Collections.emptySortedSet(), transformations, Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet() ); Map<String, String> actualAliases = PluginUtils.computeAliases(result); Map<String, String> expectedAliases = new HashMap<>(); expectedAliases.put("CollidingConverter", CollidingConverter.class.getName()); "<AssertPlaceHolder>"; }
computeAliases(PluginScanResult scanResult) { Map<String, Set<String>> aliasCollisions = new HashMap<>(); scanResult.forEach(pluginDesc -> { aliasCollisions.computeIfAbsent(simpleName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); aliasCollisions.computeIfAbsent(prunedName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); }); Map<String, String> aliases = new HashMap<>(); for (Map.Entry<String, Set<String>> entry : aliasCollisions.entrySet()) { String alias = entry.getKey(); Set<String> classNames = entry.getValue(); if (classNames.size() == 1) { aliases.put(alias, classNames.stream().findAny().get()); } else { log.debug("Ignoring ambiguous alias '{}' since it refers to multiple distinct plugins {}", alias, classNames); } } return aliases; }
[*] target: assertEquals(expectedAliases, actualAliases)
[-] pred: org. junit. Assert. assertEquals ( expectedAliases, actualAliases )
************************************
************************************
[+] input: testReplaceVariables_EmptyVariables_ReturnTemplate() { String template = "fake template"; String actual = MessageTemplateProcessor.replaceVariables(template, Locale.getDefault(), new HashMap<>()); Assert."<AssertPlaceHolder>"; }
replaceVariables(final String template, Locale locale, final Map<String, String> variables) { if (StringUtils.isEmpty(template)) { return ""; } if (CollectionUtils.isEmpty(variables)) { return template; } Map<String, String> copiedVariables = new HashMap<>(variables); if (copiedVariables.containsKey("taskType")) { String taskTypeI18nKey = String.format("${com.oceanbase.odc.TaskType.%s}", copiedVariables.get("taskType")); copiedVariables.put("taskType", taskTypeI18nKey); } if (copiedVariables.containsKey("taskStatus")) { String taskStatusI18nKey = String.format("${com.oceanbase.odc.event.TASK.%s.name}", copiedVariables.get("taskStatus")); copiedVariables.put("taskStatus", taskStatusI18nKey); } StringSubstitutor sub = new StringSubstitutor(copiedVariables) .setDisableSubstitutionInValues(true) .setVariableResolver(key -> copiedVariables.getOrDefault(key, "")); String message = sub.replace(template); message = getLocalMessage(locale, message); return message; }
[*] target: assertEquals(template, actual)
[-] pred: org. junit. Assert. assertEquals ( template, actual )
************************************
************************************
[+] input: generate_hashPartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) partitions 12 (" + "partition a.b@c (" + "subpartition a.b pctfree=13," + "subpartition b pctused 14)," + "partition d id 14) noCompress")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); SubHashPartitionElement se1 = new SubHashPartitionElement("b"); se1.setSchema("a"); PartitionOptions o1 = new PartitionOptions(); o1.setPctFree(13); se1.setPartitionOptions(o1); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setPctUsed(14); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o4 = new PartitionOptions(); o4.setId(14); e2.setPartitionOptions(o4); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2), null, 12); PartitionOptions o3 = new PartitionOptions(); o3.setNoCompress(true); expect.setPartitionOptions(o3); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { SchemaMergeOperator operator = new SchemaMergeOperator(exportOutput, "SYS", DialectType.OB_ORACLE); File dest = new File("datatransfer/temp-export/schema.sql"); operator.mergeSchemaFiles(dest, null);  Assert."<AssertPlaceHolder>"; }
mergeSchemaFiles(File dest, Predicate<String> predicate) throws IOException { if (dest.exists()) { FileUtils.forceDelete(dest); } try (FileWriter fileWriter = new FileWriter(dest, true); BufferedWriter writer = new BufferedWriter(fileWriter)) { for (ObjectType type : PROCESS_ORDER) { if (!objectMap.containsKey(type)) { continue; } if (type.equals(ObjectType.TABLE)) { new TableProcessor(schemaName, dialectType).process(objectMap.get(type)); }  for (SchemaFileIdentifier identifier : objectMap.get(type)) { if (predicate == null || predicate.test(identifier.getTarget().getFileName())) { doMerge(identifier, writer); } } } } catch (IOException ex) { FileUtils.deleteQuietly(dest); throw ex; } }
[*] target: assertTrue(dest.exists())
[-] pred: org. junit. Assert. assertTrue ( dest. exists ( ) )
************************************
************************************
[+] input: test_Operate_String() { boolean contains = EventParseUtil.validate("Hello world!", "equals", "Hello world!"); Assert."<AssertPlaceHolder>"; }
validate(Object root, String operation, Object value) { if (root.getClass().isArray()) { String json = JsonUtils.toJson(root); root = JsonUtils.fromJsonList(json, String.class); } String assertStr = "'" + root.toString() + "'." + operation + "('" + value.toString() + "')"; Object result = PARSER.parseExpression(assertStr).getValue(); if (Objects.isNull(result)) { throw new UnexpectedException(String.format("Validate condition failed, assertStr=%s", assertStr)); } return (boolean) result; }
[*] target: assertTrue(contains)
[-] pred: org. junit. Assert. assertTrue ( contains )
************************************
************************************
[+] input: generate_dropIndex_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop key abc")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropIndexName("abc"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_timestampLTZWithoutPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp with local time zone")); DataType actual = factory.generate();  DataType expect = new TimestampType(null, false, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: bytesToLongOffsetTest1() { long l1 = 1600650710304L; int width1 = 64 - Long.numberOfLeadingZeros(l1); long l2 = -16L; int width2 = 64 - Long.numberOfLeadingZeros(l2); byte[] bs = new byte[1000]; BytesUtils.longToBytes(l1, bs, 0, width1); long res_val1_1 = BytesUtils.bytesToLong(bs, 0, width1); BytesUtils.longToBytes(l2, bs, width1, width2); long res_val1_2 = BytesUtils.bytesToLong(bs, 0, width1); Assert."<AssertPlaceHolder>"; }
bytesToLong(byte[] result, int pos, int width) { long ret = 0; int cnt = pos & 0x07; int index = pos >> 3; while (width > 0) { int m = width + cnt >= 8 ? 8 - cnt : width; width -= m; ret = ret << m; byte y = (byte) (result[index] & (0xff >> cnt)); y = (byte) ((y & 0xff) >>> (8 - cnt - m)); ret = ret | (y & 0xff); cnt += m; if (cnt == 8) { cnt = 0; index++; } } return ret; }
[*] target: assertEquals(res_val1_1, res_val1_2)
[-] pred: org. junit. Assert. assertEquals ( res_val1_1, res_val1_2 )
************************************
************************************
[+] input: testGetUserTenantForAns() { String expect = "test"; System.setProperty("ans.namespace", expect); String actual = TenantUtil.getUserTenantForAns(); Assert."<AssertPlaceHolder>"; }
getUserTenantForAns() { String tmp = USER_TENANT;  if (StringUtils.isBlank(USER_TENANT)) { tmp = NacosClientProperties.PROTOTYPE.getProperty(SystemPropertyKeyConst.ANS_NAMESPACE); } return tmp; }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testSelectInstances() { ServiceInfo serviceInfo = new ServiceInfo(); serviceInfo.setGroupName("groupName"); serviceInfo.setName("serviceName"); serviceInfo.setChecksum("checkSum"); serviceInfo.setAllIPs(false); ServiceInfo cluster = ServiceUtil.selectInstances(serviceInfo, "cluster"); "<AssertPlaceHolder>"; }
selectInstances(ServiceInfo serviceInfo, String cluster) { return selectInstances(serviceInfo, cluster, false, false); }
[*] target: assertNotNull(cluster)
[-] pred: org. junit. Assert. assertNotNull ( cluster )
************************************
************************************
[+] input: testAggregateSmallInput() { final StreamsBuilder builder = new StreamsBuilder(); final String topic = "topic";  final WindowBytesStoreSupplier storeSupplier = setupWindowBytesStoreSupplier(1); final Materialized<String, String, WindowStore<Bytes, byte[]>> materialized = setupMaterialized(emitFinal ? Materialized.as("store-name") : Materialized.as(storeSupplier));  final KTable<Windowed<String>, String> table = builder .stream(topic, Consumed.with(Serdes.String(), Serdes.String())) .groupByKey(Grouped.with(Serdes.String(), Serdes.String())) .windowedBy(SlidingWindows.ofTimeDifferenceAndGrace(ofMillis(10), ofMillis(5))) .emitStrategy(emitStrategy) .aggregate(MockInitializer.STRING_INIT, MockAggregator.TOSTRING_ADDER, materialized); final MockApiProcessorSupplier<Windowed<String>, String, Void, Void> supplier = new MockApiProcessorSupplier<>(); table.toStream().process(supplier); try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) { final TestInputTopic<String, String> inputTopic = driver.createInputTopic(topic, new StringSerializer(), new StringSerializer()); inputTopic.pipeInput("A", "1", 10L); inputTopic.pipeInput("A", "2", 10L); inputTopic.pipeInput("A", "3", 14L); inputTopic.pipeInput("A", "4", 15L); inputTopic.pipeInput("A", "5", 20L); inputTopic.pipeInput("A", "6", 22L); inputTopic.pipeInput("A", "7", 30L); }  final Map<Long, Set<ValueAndTimestamp<String>>> actual = gatherOutput(supplier); final Map<Long, Set<ValueAndTimestamp<String>>> expected = new HashMap<>();  if (emitFinal) { expected.put(0L, mkSet( ValueAndTimestamp.make("0+1+2", 10L) )); expected.put(4L, mkSet( ValueAndTimestamp.make("0+1+2+3", 14L) )); expected.put(5L, mkSet( ValueAndTimestamp.make("0+1+2+3+4", 15L) )); expected.put(10L, mkSet( ValueAndTimestamp.make("0+1+2+3+4+5", 20L) )); expected.put(11L, mkSet( ValueAndTimestamp.make("0+3+4+5", 20L) )); expected.put(12L, mkSet( ValueAndTimestamp.make("0+3+4+5+6", 22L) )); } else { expected.put(0L, mkSet( ValueAndTimestamp.make("0+1", 10L), ValueAndTimestamp.make("0+1+2", 10L) )); expected.put(4L, mkSet( ValueAndTimestamp.make("0+1+2+3", 14L) )); expected.put(5L, mkSet( ValueAndTimestamp.make("0+1+2+3+4", 15L) )); expected.put(10L, mkSet( ValueAndTimestamp.make("0+1+2+3+4+5", 20L) )); expected.put(11L, mkSet( ValueAndTimestamp.make("0+3", 14L), ValueAndTimestamp.make("0+3+4", 15L), ValueAndTimestamp.make("0+3+4+5", 20L) )); expected.put(12L, mkSet( ValueAndTimestamp.make("0+3+4+5+6", 22L) )); expected.put(15L, mkSet( ValueAndTimestamp.make("0+4", 15L), ValueAndTimestamp.make("0+4+5", 20L), ValueAndTimestamp.make("0+4+5+6", 22L) )); expected.put(16L, mkSet( ValueAndTimestamp.make("0+5", 20L), ValueAndTimestamp.make("0+5+6", 22L) )); expected.put(20L, mkSet( ValueAndTimestamp.make("0+5+6+7", 30L) )); expected.put(21L, mkSet( ValueAndTimestamp.make("0+6", 22L), ValueAndTimestamp.make("0+6+7", 30L) )); expected.put(23L, mkSet( ValueAndTimestamp.make("0+7", 30L) )); }  "<AssertPlaceHolder>"; }
process(final Record<KIn, VIn> record) { if (record.key() == null || record.value() == null) { if (context().recordMetadata().isPresent()) { final RecordMetadata recordMetadata = context().recordMetadata().get(); log.warn( "Skipping record due to null key or value. " + "topic=[{}] partition=[{}] offset=[{}]", recordMetadata.topic(), recordMetadata.partition(), recordMetadata.offset() ); } else { log.warn( "Skipping record due to null key or value. Topic, partition, and offset not known." ); } droppedRecordsSensor.record(); return; }  updateObservedStreamTime(record.timestamp()); final long windowCloseTime = observedStreamTime - windows.gracePeriodMs();  final long windowStart = record.timestamp(); final long windowEnd = record.timestamp() + windows.timeDifferenceMs(); if (windowEnd < windowCloseTime) { final String window = "[" + windowStart + "," + windowEnd + "]"; logSkippedRecordForExpiredWindow(log, record.timestamp(), windowCloseTime, window); return; }  if (record.timestamp() < windows.timeDifferenceMs()) { processEarly(record, windowCloseTime); return; }  if (reverseIteratorPossible == null) { try { try (final WindowStoreIterator<ValueAndTimestamp<VAgg>> iterator = windowStore.backwardFetch(record.key(), 0L, 0L)) { reverseIteratorPossible = true; log.debug("Sliding Windows aggregate using a reverse iterator"); } } catch (final UnsupportedOperationException e)  { reverseIteratorPossible = false; log.debug("Sliding Windows aggregate using a forward iterator"); } }  if (reverseIteratorPossible) { processReverse(record, windowCloseTime); } else { processInOrder(record, windowCloseTime); }  maybeForwardFinalResult(record, windowCloseTime); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testPeek_NoChannel_MessageThrown() { messageRepository.save(getMessageEntity());  when(channelRepository.findById(anyLong())) .thenReturn(Optional.empty()); List<Message> messages = queue.peek(1, MessageSendingStatus.CREATED);  Assert."<AssertPlaceHolder>"; }
size() { return messageRepository.findAll().size(); }
[*] target: assertEquals(0, messages.size())
[-] pred: org. junit. Assert. assertEquals ( 0, messages. size ( ) )
************************************
************************************
[+] input: testChoose() { Plip p = new Plip(1.2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  //You can create new empties with new Empty(); //Despite what the spec says, you cannot test for Cloruses nearby yet. //Sorry!  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  "<AssertPlaceHolder>"; }
chooseAction(Map<Direction, Occupant> neighbors) { return new Action(Action.ActionType.STAY); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test_fail() { output.authorizerPresent(); output.failAuthorization(); task.onSuccess(output);  channel.runPendingTasks();  final AuthorizeWillResultEvent resultEvent = eventsCollector.pollEvent(); "<AssertPlaceHolder>"; assertEquals(AckReasonCode.NOT_AUTHORIZED, resultEvent.getResult().getAckReasonCode()); assertEquals( "Not allowed to connect with Will Publish for unauthorized topic 'topic' with QoS '2' and retain 'false'", resultEvent.getResult().getReasonString()); }
onSuccess(@Nullable final PublishAuthorizerOutputImpl output) { if (output == null) { //this does not happen return; }  DisconnectReasonCode disconnectReasonCode = null; AckReasonCode reasonCode = null; String reasonString = null;  switch (output.getAuthorizationState()) { case DISCONNECT: disconnectReasonCode = output.getDisconnectReasonCode(); reasonCode = output.getAckReasonCode() != null ? output.getAckReasonCode() : AckReasonCode.NOT_AUTHORIZED; reasonString = output.getReasonString() != null ? output.getReasonString() : getReasonString(connect); break; case FAIL: reasonCode = output.getAckReasonCode() != null ? output.getAckReasonCode() : AckReasonCode.NOT_AUTHORIZED; reasonString = output.getReasonString() != null ? output.getReasonString() : getReasonString(connect); break; case UNDECIDED: if (!output.isAuthorizerPresent()) { //providers never returned an authorizer, same as continue break; } reasonCode = AckReasonCode.NOT_AUTHORIZED; reasonString = getReasonString(connect); break; case SUCCESS: reasonCode = AckReasonCode.SUCCESS; break; case CONTINUE: break; default: //no state left throw new IllegalStateException("Unknown type"); }  final PublishAuthorizerResult result = new PublishAuthorizerResult(reasonCode, reasonString, output.isAuthorizerPresent(), disconnectReasonCode); ctx.pipeline().fireUserEventTriggered(new PluginAuthorizerServiceImpl.AuthorizeWillResultEvent(connect, result)); }
[*] target: assertNotNull(resultEvent)
[-] pred: org. junit. Assert. assertNotNull ( resultEvent )
************************************
************************************
[+] input: testRelativize_equalPaths() { String base = toOSPathString("file:/home/eclipse/runtime-New_configuration/project_1"); String other = toOSPathString("file:/home/eclipse/runtime-New_configuration/project_1"); String expected = "";  String actual = FileUtils.relativizeNativePath(base, other); "<AssertPlaceHolder>"; }
relativizeNativePath(String base, String other) { return FS.DETECTED.relativize(base, other); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_castAsNumber_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as numeric(3,2))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); NumberType type = new NumberType("numeric", new BigDecimal(3), new BigDecimal(2)); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testIsBucketExist_ReturnFalse() { boolean exists = bucketOperation.isBucketExist("whatever"); verify(bucketRepository, times(1)).findByName(anyString()); "<AssertPlaceHolder>"; }
isBucketExist(String name) { validateName(name); return bucketRepository.findByName(name).isPresent(); }
[*] target: assertFalse(exists)
[-] pred: org. junit. Assert. assertFalse ( exists )
************************************
************************************
[+] input: testBuilderHeader() { Header header = NamingHttpUtil.builderHeader(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(header.getValue(HttpHeaderConsts.CLIENT_VERSION_HEADER), VersionUtils.version); Assert.assertEquals(header.getValue(HttpHeaderConsts.USER_AGENT_HEADER), VersionUtils.getFullClientVersion()); Assert.assertEquals(header.getValue(HttpHeaderConsts.ACCEPT_ENCODING), "gzip,deflate,sdch"); Assert.assertEquals(header.getValue(HttpHeaderConsts.CONNECTION), "Keep-Alive"); Assert.assertNotNull(header.getValue(HttpHeaderConsts.REQUEST_ID)); Assert.assertEquals(header.getValue(HttpHeaderConsts.REQUEST_MODULE), "Naming"); }
builderHeader() { Header header = Header.newInstance(); header.addParam(HttpHeaderConsts.CLIENT_VERSION_HEADER, VersionUtils.version); header.addParam(HttpHeaderConsts.USER_AGENT_HEADER, VersionUtils.getFullClientVersion()); header.addParam(HttpHeaderConsts.ACCEPT_ENCODING, "gzip,deflate,sdch"); header.addParam(HttpHeaderConsts.CONNECTION, "Keep-Alive"); header.addParam(HttpHeaderConsts.REQUEST_ID, UuidUtils.generateUuid()); header.addParam(HttpHeaderConsts.REQUEST_MODULE, "Naming"); return header; }
[*] target: assertNotNull(header)
[-] pred: org. junit. Assert. assertNotNull ( header )
************************************
************************************
[+] input: generate_groupingSetsGroupbyClause_generateExprGroupBySucceed() { Groupby_clauseContext context = getGroupByClauseContext("select 1 from dual group by GROUPING SETS(col, ROLLUP(col), CUBE(col1))"); StatementFactory<GroupBy> factory = new OracleGroupByFactory(context.groupby_element_list().groupby_element(0)); GroupBy actual = factory.generate();   GroupBy g1 = new GeneralGroupBy(new RelationReference("col", null)); ExpressionParam p1 = new ExpressionParam(new RelationReference("col", null)); GroupBy g2 = new GeneralGroupBy(new FunctionCall("ROLLUP", Collections.singletonList(p1))); ExpressionParam p2 = new ExpressionParam(new RelationReference("col1", null)); GroupBy g3 = new GeneralGroupBy(new FunctionCall("CUBE", Collections.singletonList(p2))); GroupBy expect = new GroupingSetsGroupBy(Arrays.asList(g1, g2, g3)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.groupbyElementContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_listPartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by list columns (a,b) (" + "partition a.b values in (default) (" + "subpartition a.b values in (2) Engine=InnoDB," + "subpartition b values in ('maxvalue'))," + "partition d values in (3) id 14)")); Partition actual = factory.generate();  ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); SubListPartitionElement se1 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("2"))); se1.setSchema("a"); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); se1.setPartitionOptions(o); SubListPartitionElement se2 = new SubListPartitionElement("b", Collections.singletonList(new ConstExpression("'maxvalue'"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); ListPartition expect = new ListPartition(cols, Arrays.asList(e1, e2), null, null, true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_indexBtree_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index idx_name using btree (col, col1) global with parser 'aaaa'")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setGlobal(true); indexOptions.setWithParser("'aaaa'"); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: sign_generateJwtToken_succeed() { Map<String, Object> map = new HashMap<>(); map.put("userId", 123); map.put("username", "testUser"); String token = jwtService.sign(map); Assert."<AssertPlaceHolder>"; }
sign(Map<String, Object> map) { try { Date date = new Date(System.currentTimeMillis() + jwtProperties.getExpireTimeMills()); Algorithm algorithm = Algorithm.HMAC256(jwtProperties.getTokenSecret()); Map<String, Object> header = new HashMap<>(2); header.put("typ", "jwt"); JWTCreator.Builder builder = JWT.create() .withHeader(header) .withIssuedAt(new Date()) .withExpiresAt(date); map.entrySet().forEach(entry -> { if (entry.getValue() instanceof Integer) { builder.withClaim(entry.getKey(), (Integer) entry.getValue()); } else if (entry.getValue() instanceof Long) { builder.withClaim(entry.getKey(), (Long) entry.getValue()); } else if (entry.getValue() instanceof Boolean) { builder.withClaim(entry.getKey(), (Boolean) entry.getValue()); } else if (entry.getValue() instanceof String) { builder.withClaim(entry.getKey(), String.valueOf(entry.getValue())); } else if (entry.getValue() instanceof Double) { builder.withClaim(entry.getKey(), (Double) entry.getValue()); } else if (entry.getValue() instanceof Date) { builder.withClaim(entry.getKey(), (Date) entry.getValue()); } }); return builder.sign(algorithm); } catch (Exception e) { return null; } }
[*] target: assertNotNull(token)
[-] pred: org. junit. Assert. assertNotNull ( token )
************************************
************************************
[+] input: Exception { write(new File(db.getDirectory().getParent(), "test.txt"), "test"); File folder = new File(db.getDirectory().getParent(), "folder"); FileUtils.mkdir(folder); write(new File(folder, "folder.txt"), "folder"); try (Git git = new Git(db); ByteArrayOutputStream os = new ByteArrayOutputStream(); DiffFormatter dfmt = new DiffFormatter(new BufferedOutputStream(os))) { git.add().addFilepattern(".").call(); RevCommit commit = git.commit().setMessage("Initial commit").call(); write(new File(folder, "folder.txt"), "folder change");  dfmt.setRepository(db); dfmt.setPathFilter(PathFilter.create("folder")); dfmt.format(null, commit.getTree().getId()); dfmt.flush();  String actual = os.toString("UTF-8"); String expected = "diff --git a/folder/folder.txt b/folder/folder.txt\n" + "new file mode 100644\n" + "index 0000000..0119635\n" + "--- /dev/null\n" + "+++ b/folder/folder.txt\n" + "@@ -0,0 +1 @@\n" + "+folder\n" + "\\ No newline at end of file\n";  "<AssertPlaceHolder>"; } }
flush() throws IOException { out.flush(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_convertAsBinary_generateFunctionCallSucceed() { ExprContext context = getExprContext("convert('abc', binary(12))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); p.addOption(new GeneralDataType("binary", Collections.singletonList("12"))); params.add(p); FunctionCall expect = new FunctionCall("convert", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_deleteXml_generateSucceed() { Xml_functionContext context = getXmlExprContext("deletexml(1,2,3)"); OracleExpressionFactory factory = new OracleExpressionFactory(); Expression actual = factory.visit(context);  FunctionCall expect = new FunctionCall("deletexml", Arrays.asList( new ExpressionParam(new ConstExpression("1")), new ExpressionParam(new ConstExpression("2")), new ExpressionParam(new ConstExpression("3")))); Assert."<AssertPlaceHolder>"; }
visit(ParseTree parseTree) { if (parseTree == null) { return null; } return super.visit(parseTree); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_rangePartitionWithSubPartitionOptions_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) subpartition by range (c) subpartition template (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue)(" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue)," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "range"); subPartitionOption.setTemplates(Arrays.asList(se1, se2)); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { Object expected = new Object(); when(catalogServiceV2.getServiceDetail(Constants.DEFAULT_NAMESPACE_ID, TEST_GROUP_NAME, TEST_SERVICE_NAME)) .thenReturn(expected); Object actual = catalogController.serviceDetail(Constants.DEFAULT_NAMESPACE_ID, TEST_GROUP_NAME + Constants.SERVICE_INFO_SPLITER + TEST_SERVICE_NAME); "<AssertPlaceHolder>"; }
serviceDetail(@RequestParam(defaultValue = Constants.DEFAULT_NAMESPACE_ID) String namespaceId, String serviceName) throws NacosException { String serviceNameWithoutGroup = NamingUtils.getServiceName(serviceName); String groupName = NamingUtils.getGroupName(serviceName); return judgeCatalogService().getServiceDetail(namespaceId, groupName, serviceNameWithoutGroup); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test_exists_notExist() { Boolean exist = service.exists("notExists"); Assert."<AssertPlaceHolder>"; }
exists(@NotBlank String name) { MaskingAlgorithmEntity entity = new MaskingAlgorithmEntity(); entity.setName(name); entity.setOrganizationId(authenticationFacade.currentOrganizationId()); return algorithmRepository.exists(Example.of(entity)); }
[*] target: assertFalse(exist)
[-] pred: org. junit. Assert. assertFalse ( exist )
************************************
************************************
[+] input: test_get_tls_no_cert() { clientConnection.setAuthCipherSuite("cipher"); clientConnection.setAuthProtocol("TLSv1.2");  final ClientTlsInformation clientTlsInformation = ExtensionInformationUtil.getTlsInformationFromChannel(channel); "<AssertPlaceHolder>"; assertEquals("cipher", clientTlsInformation.getCipherSuite()); assertEquals("TLSv1.2", clientTlsInformation.getProtocol()); assertTrue(clientTlsInformation.getHostname().isEmpty()); assertTrue(clientTlsInformation.getClientCertificate().isEmpty()); }
getTlsInformationFromChannel(final @NotNull Channel channel) {  Preconditions.checkNotNull(channel, "channel must never be null");  final ClientConnection clientConnection = channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get(); try { final String cipher = clientConnection.getAuthCipherSuite(); final String protocol = clientConnection.getAuthProtocol(); final String sniHostname = clientConnection.getAuthSniHostname();  final SslClientCertificate sslClientCertificate = clientConnection.getAuthCertificate();  if (cipher == null || protocol == null) { return null; }  if (sslClientCertificate == null) { return new ClientTlsInformationImpl(null, null, cipher, protocol, sniHostname);  } else { final X509Certificate certificate = (X509Certificate) sslClientCertificate.certificate(); final X509Certificate[] certificateChain = (X509Certificate[]) sslClientCertificate.certificateChain();  return new ClientTlsInformationImpl(certificate, certificateChain, cipher, protocol, sniHostname); }  } catch (final Exception e) { log.debug("Tls information creation failed: ", e); }  return null; }
[*] target: assertNotNull(clientTlsInformation)
[-] pred: org. junit. Assert. assertNotNull ( clientTlsInformation )
************************************
************************************
[+] input: testGetValuesWithPrefixNull() { List<String> result = tree.getValuesWithPrefix(null); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, result.size())
[-] pred: org. junit. Assert. assertEquals ( 0, result. size ( ) )
************************************
************************************
[+] input: generate_createUniqueIndex_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create unique index chz.abc on piaoyue.tb (col, col1)")); CreateIndex actual = factory.generate();  RelationFactor relation = new RelationFactor("abc"); relation.setSchema("chz"); RelationFactor on = new RelationFactor("tb"); on.setSchema("piaoyue"); CreateIndex expect = new CreateIndex(relation, on, Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setUnique(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_withColumnGroup_customGroup_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(g1(id))"); OracleCreateTableFactory factory = new OracleCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); List<String> columnNames = Collections.singletonList("id"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement("g1", columnNames))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_createIndexUsingBtree_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create unique index abc using btree on tb (col, col1) using hash")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setUnique(true); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingBtree(true); indexOptions.setUsingHash(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_listaggwithingroup_generateSucceed() { Bit_exprContext context = getBitExprContext( "listagg(1,2,3) within group (order by col desc) over (partition by (1,2) order by col desc rows between current row and 123 PRECEDING)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("1"))); params.add(new ExpressionParam(new ConstExpression("2"))); params.add(new ExpressionParam(new ConstExpression("3"))); FunctionCall expect = new FunctionCall("listagg", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); expect.setWithinGroup(orderBy); WindowOffset begin = new WindowOffset(WindowOffsetType.CURRENT_ROW); WindowOffset end = new WindowOffset(WindowOffsetType.PRECEDING); end.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.ROWS, begin, end); window.setBody(body); expect.setWindow(window); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testReceiveConfigInfoEmpty() { final Deque<Properties> q2 = new ArrayDeque<Properties>(); PropertiesListener a = new PropertiesListener() { @Override public void innerReceive(Properties properties) { q2.offer(properties); } }; a.receiveConfigInfo(""); final Properties actual = q2.poll(); Assert."<AssertPlaceHolder>"; }
receiveConfigInfo(String configInfo) { if (StringUtils.isEmpty(configInfo)) { return; }  Properties properties = new Properties(); try { properties.load(new StringReader(configInfo)); innerReceive(properties); } catch (IOException e) { LOGGER.error("load properties error：" + configInfo, e); }  }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: generate_castAsDatetime_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as datetime(3))"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); GeneralDataType type = new GeneralDataType("datetime", Collections.singletonList("3")); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: get_getById_getSucceed() { UserInfo expect = TestRandom.nextObject(UserInfo.class); userDAO.insert(expect); expect = userDAO.detail(expect.getEmail()); UserInfo actual = userDAO.get(expect.getId()); expect.setGmtCreated(null); expect.setGmtModified(null); expect.setEnabled(true); actual.setEnabled(true); Assert."<AssertPlaceHolder>"; }
get(long id);
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: test_findByUpdateTimeBefore_return1() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.PRIVATE); repository.save(connection); List<ConnectionEntity> entities = repository.findByUpdateTimeBefore(new Date(new Date().getTime() + 5 * 1000L)); Assert."<AssertPlaceHolder>"; }
findByUpdateTimeBefore(Date updateTime);  List<ConnectionEntity> findByUpdateTimeBeforeAndTemp(Date updateTime, Boolean temp);  List<ConnectionEntity> findByOrganizationIdAndNameIn(Long organizationId, Collection<String> names);  Optional<ConnectionEntity> findByVisibleScopeAndOwnerIdAndName(ConnectionVisibleScope visibleScope, Long ownerId, String name);  Optional<ConnectionEntity> findByOrganizationIdAndName(Long organizationId, String name);  List<ConnectionEntity> findByOrganizationId(Long organizationId);  List<ConnectionEntity> findByOrganizationIdIn(Collection<Long> organizationIds);  List<ConnectionEntity> findByProjectId(Long projectId);  @Transactional @Query(value = "select distinct(c_c.*) from `connect_connection` as c_c inner join `connect_database` as c_d " + "on c_c.id = c_d.connection_id where c_d.project_id = :projectId", nativeQuery = true) List<ConnectionEntity> findByDatabaseProjectId(@Param("projectId") Long projectId);  @Transactional @Query(value = "select `id` from `connect_connection` where `host`=:host", nativeQuery = true) @Modifying Set<Long> findIdsByHost(@Param("host") String host);  List<ConnectionEntity> findByIdIn(Collection<Long> ids);  List<ConnectionEntity> findByVisibleScopeAndOrganizationId(ConnectionVisibleScope visibleScope, Long organizationId);  List<ConnectionEntity> findByVisibleScopeAndCreatorId(ConnectionVisibleScope visibleScope, Long creatorId);  List<ConnectionEntity> findByVisibleScope(ConnectionVisibleScope visibleScope);  List<ConnectionEntity> findByOrganizationIdAndEnvironmentId(Long organizationId, Long environmentId);  @Transactional int deleteByVisibleScopeAndOwnerId(ConnectionVisibleScope visibleScope, Long ownerId);  @Query("SELECT e.id FROM #{#entityName}
[*] target: assertEquals(1, entities.size())
[-] pred: org. junit. Assert. assertEquals ( 1, entities. size ( ) )
************************************
************************************
[+] input: generate_updateAssignmentWithColumnList_generateSucceed() { Update_stmtContext context = getUpdateContext("UPDATE tab1 SET (col1,col2) = (SELECT tab2.col1 from tab2 where tab2.col2='abcd');"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  NameReference nameReference = new NameReference(null, "tab1", null); RelationReference relationReference = new RelationReference("tab2", new RelationReference("col1", null)); Projection p = new Projection(relationReference, null); NameReference from = new NameReference(null, "tab2", null); SelectBody body = new SelectBody(Collections.singletonList(p), Collections.singletonList(from)); Expression e1 = new RelationReference("tab2", new RelationReference("col2", null)); Expression e2 = new ConstExpression("'abcd'"); CompoundExpression where = new CompoundExpression(e1, e2, Operator.EQ); body.setWhere(where); Update expect = new Update(Arrays.asList(nameReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col1"), new ColumnReference(null, null, "col2")), body, false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { // Generate a PQ for random vectors var vectors = createRandomVectors(512, 64); var ravv = new ListRandomAccessVectorValues(vectors, 64); var bq = new BinaryQuantization(ravv.dimension());  // Compress the vectors var compressed = bq.encodeAll(ravv); var cv = new BQVectors(bq, compressed); assertEquals(64 * Float.BYTES, cv.getOriginalSize()); assertEquals(8, cv.getCompressedSize());  // Write compressed vectors File cvFile = File.createTempFile("bqtest", ".cv"); try (var out = new DataOutputStream(new FileOutputStream(cvFile))) { cv.write(out); } // Read compressed vectors try (var in = new SimpleMappedReader(cvFile.getAbsolutePath())) { var cv2 = BQVectors.load(in, 0); "<AssertPlaceHolder>"; } }
write(DataOutput out) throws IOException { write(out, OnDiskGraphIndex.CURRENT_VERSION); }
[*] target: assertEquals(cv, cv2)
[-] pred: org. junit. Assert. assertEquals ( cv, cv2 )
************************************
************************************
[+] input: generate_rangePartitionWithSubPartitionOptionsIndividual_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by range(a) subpartition by range (c) (" + "partition a.b values less than (-2, maxvalue) (" + "subpartition a.b values less than (+3)," + "subpartition b values less than maxvalue)," + "partition d values less than (+3) id 14)")); Partition actual = factory.generate();  RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "range"); RangePartition expect = new RangePartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_functionNameExprAsListNoAlias_generateFunctionCallSucceed() { ExprContext context = getExprContext("function_name(tab.col)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col"))); FunctionCall expect = new FunctionCall("function_name", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: queryByUserIdAndName_queryByUserIdAndName_querySucceed() { Snippet snippet = TestRandom.nextObject(Snippet.class); snippetsDAO.insert(snippet); Snippet query = new Snippet(); query.setUserId(snippet.getUserId()); query.setPrefix(snippet.getPrefix()); Snippet actual = snippetsDAO.queryByUserIdAndName(query); snippet.setModifyTime(null); snippet.setCreateTime(null); actual.setModifyTime(null); actual.setCreateTime(null); Assert."<AssertPlaceHolder>"; }
queryByUserIdAndName(Snippet snippet);
[*] target: assertEquals(snippet, actual)
[-] pred: org. junit. Assert. assertEquals ( snippet, actual )
************************************
************************************
[+] input: testAddAggrConfigInfoOfEqualContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and equal with current content param. String existContent = "content1234"; Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenReturn(existContent); //mock insert success Mockito.when(databaseOperate.update(any(List.class))).thenReturn(true);  boolean result = embededConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
addAggrConfigInfo(final String dataId, final String group, String tenant, final String datumId, String appName, final String content) { String appNameTmp = StringUtils.isBlank(appName) ? StringUtils.EMPTY : appName; String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; String contentTmp = StringUtils.isBlank(content) ? StringUtils.EMPTY : content; final Timestamp now = new Timestamp(System.currentTimeMillis());  ConfigInfoAggrMapper configInfoAggrMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_AGGR); final String select = configInfoAggrMapper.select(Collections.singletonList("content"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id")); final String insert = configInfoAggrMapper.insert( Arrays.asList("data_id", "group_id", "tenant_id", "datum_id", "app_name", "content", "gmt_modified")); final String update = configInfoAggrMapper.update(Arrays.asList("content", "gmt_modified"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id"));  String dbContent = databaseOperate.queryOne(select, new Object[] {dataId, group, tenantTmp, datumId}, String.class);  if (Objects.isNull(dbContent)) { final Object[] args = new Object[] {dataId, group, tenantTmp, datumId, appNameTmp, contentTmp, now}; EmbeddedStorageContextHolder.addSqlContext(insert, args); } else if (!dbContent.equals(content)) { final Object[] args = new Object[] {contentTmp, now, dataId, group, tenantTmp, datumId}; EmbeddedStorageContextHolder.addSqlContext(update, args); }  try { boolean result = databaseOperate.update(EmbeddedStorageContextHolder.getCurrentSqlContext()); if (!result) { throw new NacosConfigException("[Merge] Configuration release failed"); } return true; } finally { EmbeddedStorageContextHolder.cleanAllContext(); } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: test_getInstanceIfPresent_not_present() { clientConnection.setConnectionAttributes(null);  final ConnectionAttributes returnConnectionAttributes = ConnectionAttributes.getInstanceIfPresent(channel);  "<AssertPlaceHolder>"; }
getInstanceIfPresent(@NotNull final Channel channel) { Preconditions.checkNotNull(channel, "Channel for connection attributes must not be null.");  return channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get().getConnectionAttributes(); }
[*] target: assertNull(returnConnectionAttributes)
[-] pred: org. junit. Assert. assertNull ( returnConnectionAttributes )
************************************
************************************
[+] input: generate_groupConcat_generateFunctionCallSucceed() { ExprContext context = getExprContext("GROUP_CONCAT(distinct tab.col, col order by col desc SEPARATOR ',')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ColumnReference(null, "tab", "col")));  FunctionParam p = new ExpressionParam(new ColumnReference(null, null, "col")); params.add(p); GroupConcat expect = new GroupConcat(params); expect.addOption(new ConstExpression("distinct")); SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(sortKey)); expect.addOption(orderBy); expect.addOption(new ConstExpression("SEPARATOR ','")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_cur_time_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("CURRENT_TIME(123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("CURRENT_TIME", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testRepeatConstraint() { Map<String, Object> context = getRepeatTestContext(); boolean rst = RuleRunner.getInstance() .check( context, Lists.newArrayList( "repeat_constraint(e.nodes, 'pre', 'cur', 'cur.logId == pre.logId && cur.age >= A.age && cur.gender == B.gender', " + "context_capturer(['A.age', 'B.gender'], [A.age, B.gender]))"), ""); Assert."<AssertPlaceHolder>"; }
getInstance() { if (null != instance) { return instance; } synchronized (RuleRunner.class) { if (null == instance) { RuleRunner runner = new RuleRunner(); runner.init(); instance = runner; } } return instance; }
[*] target: assertTrue(rst)
[-] pred: org. junit. Assert. assertTrue ( rst )
************************************
************************************
[+] input: testToTargetState() { assertEquals(TargetState.STARTED, CreateConnectorRequest.InitialState.RUNNING.toTargetState()); assertEquals(TargetState.PAUSED, CreateConnectorRequest.InitialState.PAUSED.toTargetState()); assertEquals(TargetState.STOPPED, CreateConnectorRequest.InitialState.STOPPED.toTargetState());  CreateConnectorRequest createConnectorRequest = new CreateConnectorRequest("test-name", Collections.emptyMap(), null); "<AssertPlaceHolder>"; }
initialTargetState() { if (initialState != null) { return initialState.toTargetState(); } else { return null; } }
[*] target: assertNull(createConnectorRequest.initialTargetState())
[-] pred: org. junit. Assert. assertNull ( createConnectorRequest. initialTargetState() )
************************************
************************************
[+] input: implies_DifferentResourceId_impliesFalse() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("2", "ODC_PROJECT"), "DBA"); Assert."<AssertPlaceHolder>"; }
implies(Permission permission) { if (!(permission instanceof ResourceRoleBasedPermission)) { return false; } return this.resourceId.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceId()) && this.resourceType.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceType()) && !Collections.disjoint(((ResourceRoleBasedPermission) permission).getResourceRoles(), this.resourceRoles); }
[*] target: assertFalse(permission.implies(permission1))
[-] pred: org. junit. Assert. assertFalse ( permission. implies( permission1 ) )
************************************
************************************
[+] input: generate_generatedColumnDefAsExprConstraint_generateSuccees() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "tb.col varchar2(64) generated always as (tb.col+1) virtual constraint abc not null rely")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar2", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); RelationReference r1 = new RelationReference("tb", new RelationReference("col", null)); Expression e = new CompoundExpression(r1, new ConstExpression("1"), Operator.ADD); GenerateOption option = new GenerateOption(e); option.setType(Type.VIRTUAL); option.setGenerateOption("always"); ColumnAttributes attributes = new ColumnAttributes(); ConstraintState state = new ConstraintState(); state.setRely(true); InLineConstraint attribute = new InLineConstraint("abc", state); attribute.setNullable(false); attributes.setConstraints(Collections.singletonList(attribute)); expect.setColumnAttributes(attributes); expect.setGenerateOption(option); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { when(executionDAO.getWorkflow(any(), anyBoolean())).thenReturn(new WorkflowModel()); Workflow workflow = executionDAOFacade.getWorkflow("workflowId", true); "<AssertPlaceHolder>"; verify(indexDAO, never()).get(any(), any()); }
getWorkflow(String workflowId, boolean includeTasks) { return getWorkflowModelFromDataStore(workflowId, includeTasks).toWorkflow(); }
[*] target: assertNotNull(workflow)
[-] pred: org. junit. Assert. assertNotNull ( workflow )
************************************
************************************
[+] input: parserAnonymousBlock_callProcedure_4_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_6, 0); Map<String, AnonymousBlockProcedureCall> procedureCallMap = result.getProcedureCallMap(); AnonymousBlockProcedureCall procedureCall = procedureCallMap.get("TEST_CASE_CURSOR"); int actual = procedureCall.getCallLine(); int expect = 5; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldFindTask() { TaskSummary taskSummary = TestUtils.loadTaskSnapshot(objectMapper, "task_summary"); indexDAO.indexTask(taskSummary);  List<TaskSummary> tasks = tryFindResults(() -> searchTaskSummary(taskSummary)); "<AssertPlaceHolder>"; assertEquals(taskSummary, tasks.get(0)); }
indexTask(TaskSummary task) { try { long startTime = Instant.now().toEpochMilli(); String id = task.getTaskId(); byte[] doc = objectMapper.writeValueAsBytes(task); String docType = StringUtils.isBlank(docTypeOverride) ? TASK_DOC_TYPE : docTypeOverride;  UpdateRequest req = new UpdateRequest(taskIndexName, docType, id); req.doc(doc, XContentType.JSON); req.upsert(doc, XContentType.JSON); indexObject(req, TASK_DOC_TYPE); long endTime = Instant.now().toEpochMilli(); LOGGER.debug( "Time taken {} for  indexing task:{} in workflow: {}", endTime - startTime, task.getTaskId(), task.getWorkflowId()); Monitors.recordESIndexTime("index_task", TASK_DOC_TYPE, endTime - startTime); Monitors.recordWorkerQueueSize( "indexQueue", ((ThreadPoolExecutor) executorService).getQueue().size()); } catch (Exception e) { LOGGER.error("Failed to index task: {}", task.getTaskId(), e); } }
[*] target: assertEquals(1, tasks.size())
[-] pred: org. junit. Assert. assertEquals ( 1, tasks. size ( ) )
************************************
************************************
[+] input: generate_distinctBitExprWithoutWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext("count(distinct 56) over (partition by (1,2) order by col desc)"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("56"))); FunctionCall expect = new FunctionCall("count", params); WindowSpec window = new WindowSpec(); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new RelationReference("col", null), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); expect.setWindow(window); expect.addOption(new ConstExpression("distinct")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { ServerReloadRequest request = new ServerReloadRequest(); request.setReloadCount(10); request.setReloadServer("1.1.1.1"); request.setRequestId("1"); String json = mapper.writeValueAsString(request); System.out.println(json); Assert."<AssertPlaceHolder>"; Assert.assertTrue(json.contains(""reloadCount":10")); Assert.assertTrue(json.contains(""reloadServer":"1.1.1.1"")); Assert.assertTrue(json.contains(""module":"internal"")); Assert.assertTrue(json.contains(""requestId":"1"")); }
setReloadServer(String reloadServer) { this.reloadServer = reloadServer; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: IOException { ConnectionSession session = new TestConnectionSession( sessionid, new ByteArrayInputStream("abcd".getBytes())); Mockito.when(sessionService.nullSafeGet(sessionid)).thenReturn(session); CrossLinkedVirtualTable table = new CrossLinkedVirtualTable("tableId"); long rowId = 1; int colId = 1; BinaryContentMetaData metaData = new BinaryContentMetaData("filePath", 0, 0); VirtualElement elt = new CommonVirtualElement("tableId", rowId, colId, "test_type", "test_name", metaData); table.put(elt); ConnectionSessionUtil.setQueryCache(session, table); BinaryContent actual = consoleService.getBinaryContent(sessionid, "tableId", rowId, colId, 2L, 1, ValueEncodeType.TXT); BinaryContent expect = new BinaryContent("c".getBytes(), 4, ValueEncodeType.TXT); Assert."<AssertPlaceHolder>"; }
getBinaryContent(@NotNull String sessionId, @NotNull String sqlId, @NotNull Long rowNum, @NotNull Integer colNum, @NotNull Long skip, @NotNull Integer len, @NotNull ValueEncodeType format) throws IOException { InputStream inputStream; try { inputStream = readBinaryData(sessionId, sqlId, rowNum, colNum); } catch (IOException exception) { log.warn("Failed to read binary data", exception); throw new InternalServerError("Failed to read binary data"); } catch (NullPointerException npe) { log.warn("Failed to read binary data", npe); return BinaryContent.ofNull(format); } int size = inputStream.available(); Validate.isTrue(len >= 0, "Length can not be negative"); Validate.inclusiveBetween(0, size, skip, "Skip index is out of range"); byte[] buffer = new byte[len]; try { inputStream.skip(skip); int length = Math.max(inputStream.read(buffer), 0); buffer = Arrays.copyOfRange(buffer, 0, length); log.info("Successfully read data from input stream, length={}", BinarySizeUnit.B.of(length)); } catch (IOException e) { log.warn("Failed to read data from input stream, length={}", BinarySizeUnit.B.of(len), e); } return new BinaryContent(buffer, size, format); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_changes() { final WillPublishPacketImpl packet = new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L); final ModifiableWillPublishImpl modifiablePacket = new ModifiableWillPublishImpl(packet, configurationService);  modifiablePacket.setTopic("modifiedTopic"); modifiablePacket.setQos(Qos.EXACTLY_ONCE); modifiablePacket.setPayload(ByteBuffer.wrap("modifiedPayload".getBytes())); modifiablePacket.setRetain(true); modifiablePacket.setMessageExpiryInterval(30); modifiablePacket.setPayloadFormatIndicator(PayloadFormatIndicator.UNSPECIFIED); modifiablePacket.setContentType("contentType"); modifiablePacket.setResponseTopic("responseTopic"); modifiablePacket.setCorrelationData(ByteBuffer.wrap("correlationData".getBytes())); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); modifiablePacket.setWillDelay(10); final WillPublishPacketImpl copy = modifiablePacket.copy();  final WillPublishPacketImpl expectedPacket = new WillPublishPacketImpl( "modifiedTopic", Qos.AT_LEAST_ONCE, ByteBuffer.wrap("modifiedPayload".getBytes()), true, 30, PayloadFormatIndicator.UNSPECIFIED, "contentType", "responseTopic", ByteBuffer.wrap("correlationData".getBytes()), UserPropertiesImpl.of(ImmutableList.of(new MqttUserProperty("testName", "testValue"))), 10, 1234L); "<AssertPlaceHolder>"; }
copy() { return new WillPublishPacketImpl(topic, qos, payload, retain, messageExpiryInterval, payloadFormatIndicator, contentType, responseTopic, correlationData, userProperties.copy(), willDelay, timestamp); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred: org. junit. Assert. assertEquals ( expectedPacket, copy )
************************************
************************************
[+] input: shouldCountWorkflows() { int counts = 1100; for (int i = 0; i < counts; i++) { WorkflowSummary workflowSummary = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); indexDAO.indexWorkflow(workflowSummary); }  // wait for workflow to be indexed long result = tryGetCount(() -> getWorkflowCount("template_workflow", "RUNNING"), counts); "<AssertPlaceHolder>"; }
getWorkflowCount(String query, String freeText) { try { return getObjectCounts(query, freeText, WORKFLOW_DOC_TYPE); } catch (Exception e) { throw new NonTransientException(e.getMessage(), e); } }
[*] target: assertEquals(counts, result)
[-] pred: org. junit. Assert. assertEquals ( counts, result )
************************************
************************************
[+] input: generate_existsColumnListWaitIntNum_generateForUpdateSucceed() { For_updateContext context = getForUpdateContext("select 1 from dual for update of tab.col1,tab.col2 wait 12"); StatementFactory<ForUpdate> factory = new OracleForUpdateFactory(context); ForUpdate actual = factory.generate();  ColumnReference c1 = new ColumnReference(null, "tab", "col1"); ColumnReference c2 = new ColumnReference(null, "tab", "col2"); ForUpdate expect = new ForUpdate(Arrays.asList(c1, c2), WaitOption.WAIT, BigDecimal.valueOf(12)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.forUpdateContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_readonly_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) read only"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setReadOnly(true); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_indexWithColumnGroup_allColumns_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext( "index idx_name (col) with column group(all columns)"));  OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Collections.singletonList(s1)); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_modifyRangePartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify partition by range(a,b) subpartition by range (c) (" + "partition a.b@c values less than (2, maxvalue) tablespace tbs1 compress for oltp (" + "subpartition a.b values less than (+3) storage(next 12 initial 15 minextents 16 maxextents 17)," + "subpartition b values less than (maxvalue) tablespace tbs)," + "partition d values less than (+3) id 14 nocompress)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList(new ConstExpression("2"), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setStorage(Arrays.asList("next 12", "initial 15", "minextents 16", "maxextents 17")); se1.setPartitionOptions(sop1); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setTableSpace("tbs"); se2.setPartitionOptions(sop2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "range"); expect.setModifyPartition(new RangePartition(cols, Arrays.asList(e1, e2), subPartitionOption, null, false)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_rangePartitionWithSubPartitions_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by range(a,b) (" + "partition a.b@c values less than (-2, maxvalue) tablespace tbs1 compress for oltp (" + "subpartition a.b values less than (+3) INITRANS 12," + "subpartition b values less than (maxvalue) MAXTRANS 13)," + "partition d values less than (+3) id 14 nocompress)")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); SubRangePartitionElement se1 = new SubRangePartitionElement("b", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); se1.setSchema("a"); PartitionOptions sop1 = new PartitionOptions(); sop1.setIniTrans(12); se1.setPartitionOptions(sop1); SubRangePartitionElement se2 = new SubRangePartitionElement("b", Collections.singletonList(new ConstExpression("maxvalue"))); PartitionOptions sop2 = new PartitionOptions(); sop2.setMaxTrans(13); se2.setPartitionOptions(sop2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); RangePartitionElement e2 = new RangePartitionElement("d", Collections.singletonList(new CompoundExpression(new ConstExpression("3"), null, Operator.ADD))); PartitionOptions options1 = new PartitionOptions(); options1.setNoCompress(true); options1.setId(14); e2.setPartitionOptions(options1); RangePartition expect = new RangePartition(cols, Arrays.asList(e1, e2), null, null, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: IOException { File tempFile = File.createTempFile("test", null, new File(".")); tempFile.deleteOnExit();  boolean exists = PreConditions.validExists(tempFile);  Assert."<AssertPlaceHolder>"; }
validExists(File file) { notNull(file, "file"); if (file.exists()) { return true; } throw new NotFoundException(ErrorCodes.NotFound, new Object[] {ResourceType.ODC_FILE.getLocalizedMessage(), "fileName", file.getName()}, String.format("File not found by %s=%s", "fileName", file.getName())); }
[*] target: assertTrue(exists)
[-] pred: org. junit. Assert. assertTrue ( exists )
************************************
************************************
[+] input: equalsTest() { SessionCredentials sessionCredentials=new SessionCredentials("RocketMQ","12345678"); sessionCredentials.setSecurityToken("abcd"); SessionCredentials other=new SessionCredentials("RocketMQ","12345678","abcd"); Assert."<AssertPlaceHolder>"; }
equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false;  SessionCredentials other = (SessionCredentials) obj; if (accessKey == null) { if (other.accessKey != null) return false; } else if (!accessKey.equals(other.accessKey)) return false;  if (secretKey == null) { if (other.secretKey != null) return false; } else if (!secretKey.equals(other.secretKey)) return false;  if (signature == null) { if (other.signature != null) return false; } else if (!signature.equals(other.signature)) return false;  return true; }
[*] target: assertTrue(sessionCredentials.equals(other))
[-] pred: org. junit. Assert. assertTrue ( sessionCredentials. equals ( other ) )
************************************
************************************
[+] input: testRegister() { context.setAllowContainerOverriding(true); beanMethodContainerRegistrar.register(service, Service.class);  // mappedMethod Container<?> mappedMethod = context.getContainer("mappedMethod"); Assert."<AssertPlaceHolder>"; Assert.assertEquals("mappedMethod", mappedMethod.getNamespace());  // onoToOneMethod Container<?> onoToOneMethod = context.getContainer("onoToOneMethod"); Assert.assertNotNull(onoToOneMethod); Assert.assertEquals("onoToOneMethod", onoToOneMethod.getNamespace());  // oneToManyMethod Container<?> oneToManyMethod = context.getContainer("oneToManyMethod"); Assert.assertTrue(oneToManyMethod instanceof CacheableContainer); Assert.assertEquals("oneToManyMethod", oneToManyMethod.getNamespace()); }
register(Object target, Class<?> targetType) { register(target, targetType, null); }
[*] target: assertNotNull(mappedMethod)
[-] pred: org. junit. Assert. assertNotNull ( mappedMethod )
************************************
************************************
[+] input: getIntentValue_getCameraPermissionIndex_returnCameraPermissionMessage() { Intent mockIntent = new Intent(ApplicationProvider.getApplicationContext(), GrantPermissionActivity.class); mockIntent.putExtra("permission", "grantCamera");  GrantPermissionActivity grantPermissionActivityResume = Robolectric.buildActivity(GrantPermissionActivity.class, mockIntent).create().start().resume().get(); String description = grantPermissionActivityResume.getDescriptionTextViewValue(); String actual = "Change permissions in your device’s \napp settings. Give GameFace access to \nCamera.";  "<AssertPlaceHolder>"; }
getDescriptionTextViewValue() { TextView descriptionTextView = findViewById(R.id.description); return descriptionTextView.getText().toString(); }
[*] target: assertEquals(actual, description)
[-] pred: org. junit. Assert. assertEquals ( actual, description )
************************************
************************************
[+] input: JsonProcessingException { ServerNamingAbility expected = new ServerNamingAbility(); expected.setSupportJraft(true); String serializeJson = jacksonMapper.writeValueAsString(expected); ServerNamingAbility actual = jacksonMapper.readValue(serializeJson, ServerNamingAbility.class); assertEquals(expected, actual); actual = new ServerNamingAbility(); assertNotEquals(expected, actual); actual.setSupportJraft(true); "<AssertPlaceHolder>"; }
setSupportJraft(boolean supportJraft) { this.supportJraft = supportJraft; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetInstance() { AuthPluginManager instance = AuthPluginManager.getInstance();  Assert."<AssertPlaceHolder>"; }
getInstance() { return INSTANCE; }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
************************************
[+] input: IOException { Map<String, String> configMap = new HashMap<>(baseServerProps());  final String logger = "a.b.c.s.W"; final String loggingLevel = "INFO"; final long lastModified = 789052637671L;  doReturn(KAFKA_CLUSTER_ID).when(herder).kafkaClusterId(); doReturn(plugins).when(herder).plugins(); expectEmptyRestExtensions(); doReturn(Collections.emptyList()).when(herder).setWorkerLoggerLevel(logger, loggingLevel); doReturn(Collections.singletonMap(logger, new LoggerLevel(loggingLevel, lastModified))).when(herder).allLoggerLevels();  server = new ConnectRestServer(null, restClient, configMap); server.initializeServer(); server.initializeResources(herder);  ObjectMapper mapper = new ObjectMapper();  URI serverUrl = server.advertisedUrl();  executePut(serverUrl, "/admin/loggers/" + logger, "{"level": "" + loggingLevel + ""}");  String responseStr = executeGet(serverUrl, "/admin/loggers");  Map<String, Object> expectedLogger = new HashMap<>(); expectedLogger.put("level", loggingLevel); expectedLogger.put("last_modified", lastModified); Map<String, Map<String, Object>> expectedLoggers = Collections.singletonMap(logger, expectedLogger); Map<String, Map<String, Object>> actualLoggers = mapper.readValue(responseStr, new TypeReference<Map<String, Map<String, Object>>>() { }); "<AssertPlaceHolder>"; }
initializeResources(Herder herder) { this.herder = herder; super.initializeResources(); }
[*] target: assertEquals(expectedLoggers, actualLoggers)
[-] pred: org. junit. Assert. assertEquals ( expectedLoggers, actualLoggers )
************************************
************************************
[+] input: generate_alterIndexparallel_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter index abc parallel=13")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexParallel("abc", 13); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { write(new File(db.getWorkTree(), "test.txt"), "0\n1\n2\n3\n4\n5\n6\n7\n8\n9"); try (Git git = new Git(db)) { git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); write(new File(db.getWorkTree(), "test.txt"), "0\n1\n2\n3\n4a\n5\n6\n7\n8\n9");  OutputStream out = new ByteArrayOutputStream(); git.diff().setOutputStream(out).setContextLines(1).call();  String actual = out.toString(); String expected = "diff --git a/test.txt b/test.txt\n" + "index f55b5c9..c5ec8fd 100644\n" + "--- a/test.txt\n" + "+++ b/test.txt\n" + "@@ -4,3 +4,3 @@\n" + " 3\n" + "-4\n" + "+4a\n" + " 5\n"; "<AssertPlaceHolder>"; } }
call() throws GitAPIException { try (DiffFormatter diffFmt = getDiffFormatter()) { diffFmt.setRepository(repo); diffFmt.setProgressMonitor(monitor); if (cached) { if (oldTree == null) { ObjectId head = repo.resolve(HEAD + "^{tree}"); //$NON-NLS-1$ if (head == null) throw new NoHeadException(JGitText.get().cannotReadTree); CanonicalTreeParser p = new CanonicalTreeParser(); try (ObjectReader reader = repo.newObjectReader()) { p.reset(reader, head); } oldTree = p; } newTree = new DirCacheIterator(repo.readDirCache()); } else { if (oldTree == null) { oldTree = new DirCacheIterator(repo.readDirCache()); } if (newTree == null) { newTree = new FileTreeIterator(repo); } }  diffFmt.setPathFilter(pathFilter);  List<DiffEntry> result = diffFmt.scan(oldTree, newTree); if (showNameAndStatusOnly || showNameOnly) { return result; } if (contextLines >= 0) { diffFmt.setContext(contextLines); } if (destinationPrefix != null) { diffFmt.setNewPrefix(destinationPrefix); } if (sourcePrefix != null) { diffFmt.setOldPrefix(sourcePrefix); } diffFmt.format(result); diffFmt.flush(); return result; } catch (IOException e) { throw new JGitInternalException(e.getMessage(), e); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: findIdsByVisibleScopeAndOrganizationId() { ConnectionEntity connection = createEntity(ConnectionVisibleScope.ORGANIZATION); repository.save(connection);  Set<Long> ids = repository.findIdsByVisibleScopeAndOrganizationId( ConnectionVisibleScope.ORGANIZATION, ORGANIZATION_ID);  HashSet<Long> expected = new HashSet<>(); expected.add(connection.getId()); Assert."<AssertPlaceHolder>"; }
findIdsByVisibleScopeAndOrganizationId(@Param("visibleScope") ConnectionVisibleScope visibleScope, @Param("organizationId") Long organizationId);  @Query("SELECT e.id FROM #{#entityName}
[*] target: assertEquals(expected, ids)
[-] pred: org. junit. Assert. assertEquals ( expected, ids )
************************************
************************************
[+] input: generate_reorganizePartitionIntoRange_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("REORGANIZE partition a,b into (" + "partition a.b values less than (-2, maxvalue) engine=InnoDB," + "partition d values less than (func(1,2)) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement("d", Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e3.setPartitionOptions(o1); expect.reorganizePartition(Arrays.asList("a", "b"), Arrays.asList(e1, e3)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testParseEncoding_Accept_Latin_One_AsISO8859_1() { Charset result = RawParseUtils.parseEncoding(Constants .encodeASCII("encoding latin-1\n")); "<AssertPlaceHolder>"; assertEquals("ISO-8859-1", result.name()); }
parseEncoding(byte[] b) { String enc = parseEncodingName(b); if (enc == null) { return UTF_8; }  String name = enc.trim(); try { return Charset.forName(name); } catch (IllegalCharsetNameException | UnsupportedCharsetException badName) { Charset aliased = charsetForAlias(name); if (aliased != null) { return aliased; } throw badName; } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: generate_alterCheckEnforced_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter Check abcd enforced")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); ConstraintState state = new ConstraintState(); state.setEnforced(true); expect.modifyConstraint("abcd", state); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: detail_detailByEmail_detailSucceed() { UserInfo expect = TestRandom.nextObject(UserInfo.class); userDAO.insert(expect); UserInfo actual = userDAO.detail(expect.getEmail()); expect.setId(actual.getId()); expect.setGmtCreated(null); expect.setGmtModified(null); expect.setEnabled(true); actual.setEnabled(true); Assert."<AssertPlaceHolder>"; }
detail(String email);
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testExecutionException() { KafkaProducerManager manager = new KafkaProducerManager( Duration.ofMillis(150), Duration.ofMillis(500), 10, Duration.ofMillis(120000)); KafkaPublishTask.Input input = getInput(); Producer producer = manager.getProducer(input); "<AssertPlaceHolder>"; }
getProducer(KafkaPublishTask.Input input) { Properties configProperties = getProducerProperties(input); return getFromCache(configProperties, () -> new KafkaProducer(configProperties)); }
[*] target: assertNotNull(producer)
[-] pred: org. junit. Assert. assertNotNull ( producer )
************************************
************************************
[+] input: generate_alterColumnDropDefault_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter column a.b drop default")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); AlterColumnBehavior behavior = new AlterColumnBehavior(); expect.alterColumnBehavior(new ColumnReference(null, "a", "b"), behavior); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_columnDefsrId_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory(getTableElementContext("tb.col GEOMETRYCOLLECTION srid 12")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new GeneralDataType("GEOMETRYCOLLECTION", null); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); attributes.setSrid(12); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_indexColumnDescLen_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index (col(13) desc, col1) with rowid PARALLEL=12")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setDirection(SortDirection.DESC); s1.setLength(13); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setWithRowId(true); indexOptions.setParallel(12); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_changes() { final PubrelPacketImpl packet = new PubrelPacketImpl( 1, PubrelReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubrelPacketImpl modifiablePacket = new ModifiablePubrelPacketImpl(packet, configurationService);  modifiablePacket.setReasonString("reason"); modifiablePacket.getUserProperties().addUserProperty("testName", "testValue"); final PubrelPacketImpl copy = modifiablePacket.copy();  final PubrelPacketImpl expectedPacket = new PubrelPacketImpl( 1, PubrelReasonCode.SUCCESS, "reason", UserPropertiesImpl.of(ImmutableList.of(MqttUserProperty.of("testName", "testValue")))); "<AssertPlaceHolder>"; }
copy() { return new PubrelPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(expectedPacket, copy)
[-] pred: org. junit. Assert. assertEquals ( expectedPacket, copy )
************************************
************************************
[+] input: Exception { ConnectResetRequest request = new ConnectResetRequest(); request.setServerIp("127.0.0.1"); request.setServerPort("8888"); request.setRequestId("1"); request.setConnectionId("11111_127.0.0.1_8888"); String json = mapper.writeValueAsString(request); Assert."<AssertPlaceHolder>"; Assert.assertTrue(json.contains(""serverIp":"127.0.0.1"")); Assert.assertTrue(json.contains(""serverPort":"8888"")); Assert.assertTrue(json.contains(""module":"internal"")); Assert.assertTrue(json.contains(""requestId":"1"")); Assert.assertTrue(json.contains(""connectionId":"11111_127.0.0.1_8888"")); }
setConnectionId(String connectionId) { this.connectionId = connectionId; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: Exception { File directory = createTempDirectory("testInitRepository"); InitCommand command = new InitCommand(); command.setDirectory(directory); command.setInitialBranch("main"); command.setInitialBranch(""); try (Git git = command.call()) { Repository r = git.getRepository(); "<AssertPlaceHolder>"; assertEquals("refs/heads/master", r.getFullBranch()); } }
call() throws GitAPIException { try { RepositoryBuilder builder = new RepositoryBuilder(); if (bare) builder.setBare(); if (fs != null) { builder.setFS(fs); } builder.readEnvironment(); if (gitDir != null) builder.setGitDir(gitDir); else gitDir = builder.getGitDir(); if (directory != null) { if (bare) builder.setGitDir(directory); else { builder.setWorkTree(directory); if (gitDir == null) builder.setGitDir(new File(directory, Constants.DOT_GIT)); } } else if (builder.getGitDir() == null) { String dStr = SystemReader.getInstance() .getProperty("user.dir"); //$NON-NLS-1$ if (dStr == null) dStr = "."; //$NON-NLS-1$ File d = new File(dStr); if (!bare) d = new File(d, Constants.DOT_GIT); builder.setGitDir(d); } else { // directory was not set but gitDir was set if (!bare) { String dStr = SystemReader.getInstance().getProperty( "user.dir"); //$NON-NLS-1$ if (dStr == null) dStr = "."; //$NON-NLS-1$ builder.setWorkTree(new File(dStr)); } } builder.setInitialBranch(StringUtils.isEmptyOrNull(initialBranch) ? SystemReader.getInstance().getUserConfig().getString( ConfigConstants.CONFIG_INIT_SECTION, null, ConfigConstants.CONFIG_KEY_DEFAULT_BRANCH) : initialBranch); Repository repository = builder.build(); if (!repository.getObjectDatabase().exists()) repository.create(bare); return new Git(repository, true); } catch (IOException | ConfigInvalidException e) { throw new JGitInternalException(e.getMessage(), e); } }
[*] target: assertNotNull(r)
[-] pred: org. junit. Assert. assertNotNull ( r )
************************************
************************************
[+] input: generate_hashPartition_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory( getPartitionContext("partition by hash(a)")); Partition actual = factory.generate(); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), null, null, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_sysdate_generateFunctionCallSucceed() { ExprContext context = getExprContext("sysdate(123)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("123"))); FunctionCall expect = new FunctionCall("sysdate", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testStringBlankAndThenExecuteFail() { String word = "   "; final String expect = "call"; String actual = TemplateUtils.stringBlankAndThenExecute(word, () -> expect); Assert."<AssertPlaceHolder>"; }
stringBlankAndThenExecute(String source, Callable<String> callable) {  if (StringUtils.isBlank(source)) {  try { return callable.call(); } catch (Exception e) { LogUtils.NAMING_LOGGER.error("string empty and then execute cause an exception.", e); } }  return source == null ? null : source.trim(); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testName() { String name = "test"; DefaultGrpcClientConfig.Builder builder = DefaultGrpcClientConfig.newBuilder(); builder.setName(name); DefaultGrpcClientConfig config = (DefaultGrpcClientConfig) builder.build(); "<AssertPlaceHolder>"; }
name() { return this.name; }
[*] target: assertEquals(name, config.name())
[-] pred: org. junit. Assert. assertEquals ( name, config. name() )
************************************
************************************
[+] input: generate_hashPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by hash(a) partitions 12 (" + "partition a.b," + "partition d id 14)")); Partition actual = factory.generate();  HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), null, 12); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_keyPartitionWithSubPartNum_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by key () subpartition by key(c) subpartitions 123")); Partition actual = factory.generate();  SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "key"); subPartitionOption.setSubPartitionNum(123); KeyPartition expect = new KeyPartition(null, null, subPartitionOption, null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: createMethodInvokerContainerCreator() { Crane4jGlobalConfiguration configuration = SimpleCrane4jGlobalConfiguration.create(); MethodInvokerContainerCreator containerCreator = ConfigurationUtil.createMethodInvokerContainerCreator(configuration); Assert."<AssertPlaceHolder>"; }
createMethodInvokerContainerCreator(Crane4jGlobalConfiguration configuration) { return new MethodInvokerContainerCreator(configuration.getPropertyOperator(), configuration.getConverterManager()); }
[*] target: assertNotNull(containerCreator)
[-] pred: org. junit. Assert. assertNotNull ( containerCreator )
************************************
************************************
[+] input: testIsOnTrue() { StsConfig.getInstance().setSecurityCredentials("abc"); boolean stsOn = StsConfig.getInstance().isStsOn(); Assert."<AssertPlaceHolder>"; }
isStsOn() { return StringUtils.isNotEmpty(getSecurityCredentials()) || StringUtils.isNotEmpty(getSecurityCredentialsUrl()); }
[*] target: assertTrue(stsOn)
[-] pred: org. junit. Assert. assertTrue ( stsOn )
************************************
************************************
[+] input: generate_alterColumn_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter column a.b set default 12")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); AlterColumnBehavior behavior = new AlterColumnBehavior(); behavior.setDefaultValue(new ConstExpression("12")); expect.alterColumnBehavior(new ColumnReference(null, "a", "b"), behavior); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldReturnSessionStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlySessionStore<String, String>> stores = provider.stores("s-store", QueryableStoreTypes.sessionStore()); "<AssertPlaceHolder>"; for (final ReadOnlySessionStore<String, String> store : stores) { assertThat(store, instanceOf(ReadOnlySessionStore.class)); } }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { final StateStore store = globalStateStores.get(storeName); if (store == null || !queryableStoreType.accepts(store)) { return Collections.emptyList(); } if (!store.isOpen()) { throw new InvalidStateStoreException("the state store, " + storeName + ", is not open."); } if (store instanceof TimestampedKeyValueStore && queryableStoreType instanceof QueryableStoreTypes.KeyValueStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyKeyValueStoreFacade((TimestampedKeyValueStore<Object, Object>) store)); } else if (store instanceof TimestampedWindowStore && queryableStoreType instanceof QueryableStoreTypes.WindowStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyWindowStoreFacade((TimestampedWindowStore<Object, Object>) store)); } return (List<T>) Collections.singletonList(store); }
[*] target: assertEquals(1, stores.size())
[-] pred: org. junit. Assert. assertEquals ( 1, stores. size ( ) )
************************************
************************************
[+] input: testEquals_falseWhenCounterDifferent() { DataVersion dataVersion = new DataVersion(); DataVersion other = new DataVersion(); other.setCounter(new AtomicLong(1L)); other.setTimestamp(dataVersion.getTimestamp()); Assert."<AssertPlaceHolder>"; }
equals(final Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  final DataVersion that = (DataVersion) o;  if (timestamp != that.timestamp) { return false; }  if (counter != null && that.counter != null) { return counter.longValue() == that.counter.longValue(); }  return (null == counter) && (null == that.counter); }
[*] target: assertFalse(dataVersion.equals(other))
[-] pred: org. junit. Assert. assertFalse ( dataVersion. equals ( other ) )
************************************
************************************
[+] input: generate_predicateNotLike_generateSucceed() { ExprContext context = getExprContext("tab.col not like 'abc' 'bcd'"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  Expression left = new ColumnReference(null, "tab", "col"); CollectionExpression right = new CollectionExpression(); right.addExpression(new ConstExpression("'abc'")); right.addExpression(new ConstExpression("'bcd'")); Expression expect = new CompoundExpression(left, right, Operator.NOT_LIKE); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetLocalMessage_NullLocale_ReturnTemplate() { String template = "fake template"; String message = MessageTemplateProcessor.getLocalMessage(null, template); Assert."<AssertPlaceHolder>"; }
getLocalMessage(Locale locale, String message) { if (Objects.nonNull(locale)) { StringSubstitutor i18n = LOCALE2SUBSTITUTOR.computeIfAbsent(locale, l -> new StringSubstitutor(I18n.getAllMessages(l))); message = i18n.replace(message); } return message; }
[*] target: assertEquals(template, message)
[-] pred: org. junit. Assert. assertEquals ( template, message )
************************************
************************************
[+] input: Exception { WorkflowSummary oldWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); oldWorkflow.setStatus(WorkflowStatus.RUNNING); oldWorkflow.setUpdateTime(getFormattedTime(new DateTime().minusHours(2).toDate()));  WorkflowSummary recentWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); recentWorkflow.setStatus(WorkflowStatus.RUNNING); recentWorkflow.setUpdateTime(getFormattedTime(new DateTime().minusHours(1).toDate()));  WorkflowSummary tooRecentWorkflow = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); tooRecentWorkflow.setStatus(WorkflowStatus.RUNNING); tooRecentWorkflow.setUpdateTime(getFormattedTime(new DateTime().toDate()));  indexDAO.indexWorkflow(oldWorkflow); indexDAO.indexWorkflow(recentWorkflow); indexDAO.indexWorkflow(tooRecentWorkflow);  Thread.sleep(1000);  List<String> ids = indexDAO.searchRecentRunningWorkflows(2, 1);  "<AssertPlaceHolder>"; assertEquals(recentWorkflow.getWorkflowId(), ids.get(0)); }
searchRecentRunningWorkflows( int lastModifiedHoursAgoFrom, int lastModifiedHoursAgoTo) { DateTime dateTime = new DateTime(); QueryBuilder q = QueryBuilders.boolQuery() .must( QueryBuilders.rangeQuery("updateTime") .gt(dateTime.minusHours(lastModifiedHoursAgoFrom))) .must( QueryBuilders.rangeQuery("updateTime") .lt(dateTime.minusHours(lastModifiedHoursAgoTo))) .must(QueryBuilders.termQuery("status", "RUNNING"));  SearchResult<String> workflowIds; try { workflowIds = searchObjectIds( workflowIndexName, q, 0, 5000, Collections.singletonList("updateTime:ASC")); } catch (IOException e) { logger.error("Unable to communicate with ES to find recent running workflows", e); return Collections.emptyList(); }  return workflowIds.getResults(); }
[*] target: assertEquals(1, ids.size())
[-] pred: org. junit. Assert. assertEquals ( 1, ids. size ( ) )
************************************
************************************
[+] input: generate_columnDefOrigDefaultExpr_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) orig_default current_timestamp(1)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); FunctionCall expr = new FunctionCall("current_timestamp", Collections.singletonList(new ExpressionParam(new ConstExpression("1")))); attributes.setOrigDefault(expr); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: parserAnonymousBlock_callFunction_2_Succeed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_5, 0); Map<String, AnonymousBlockFunctionCall> functionCallMap = result.getFunctionCallMap(); AnonymousBlockFunctionCall functionCall = functionCallMap.get("INOUT_PARAM"); int actual = functionCall.getCallLine(); int expect = 5; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_indexBtree_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "index idx_name using btree (col, col1) visible data_table_id 14 index_table_id=15 max_used_part_id=16")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setVisible(true); indexOptions.setUsingBtree(true); indexOptions.setDataTableId(14); indexOptions.setIndexTableId(15); indexOptions.setMaxUsedPartId(16); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_countAllStar_generateFunctionCallSucceed() { ExprContext context = getExprContext("count(all *)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("*"))); FunctionCall expect = new FunctionCall("count", params); expect.addOption(new ConstExpression("all")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_physicalAttrs_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) pctfree=12,pctused 13,initrans 14, maxtrans 15, storage(next 14 initial 16), tablespace abc"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setPctFree(12); tableOptions.setPctUsed(13); tableOptions.setIniTrans(14); tableOptions.setMaxTrans(15); tableOptions.setStorage(Arrays.asList("next 14", "initial 16")); tableOptions.setTableSpace("abc"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: fromJsonMap_json_null_expect_null() { Map<A, A> aMap = JsonUtils.fromJsonMap(null, A.class, A.class);  Assert."<AssertPlaceHolder>"; }
fromJsonMap(String json, Class<K> keyType, Class<V> valueType) { if (json == null) { return null; } try { MapType mapType = OBJECT_MAPPER.getTypeFactory().constructMapType(HashMap.class, keyType, valueType); return OBJECT_MAPPER.readValue(json, mapType); } catch (JsonProcessingException e) { return null; } }
[*] target: assertNull(aMap)
[-] pred: org. junit. Assert. assertNull ( aMap )
************************************
************************************
[+] input: implies_DifferentResourceType_impliesFalse() { ResourceRoleBasedPermission permission = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_DATABASE"), "DBA"); ResourceRoleBasedPermission permission1 = new ResourceRoleBasedPermission(new DefaultSecurityResource("1", "ODC_PROJECT"), "DBA"); Assert."<AssertPlaceHolder>"; }
implies(Permission permission) { if (!(permission instanceof ResourceRoleBasedPermission)) { return false; } return this.resourceId.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceId()) && this.resourceType.equalsIgnoreCase(((ResourceRoleBasedPermission) permission).getResourceType()) && !Collections.disjoint(((ResourceRoleBasedPermission) permission).getResourceRoles(), this.resourceRoles); }
[*] target: assertFalse(permission.implies(permission1))
[-] pred: org. junit. Assert. assertFalse ( permission. implies( permission1 ) )
************************************
************************************
[+] input: InterruptedException { final EmbeddedChannel channel = new EmbeddedChannel(); final ClientConnection clientConnection = new ClientConnection(channel, null); clientConnection.setProtocolVersion(ProtocolVersion.MQTTv5); channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).set(clientConnection); when(connectionPersistence.get("client")).thenReturn(clientConnection); when(localPersistence.getSession(eq("client"), anyBoolean(), anyBoolean())).thenReturn(new ClientSession(true, 0)); final ListenableFuture<Boolean> future = clientSessionPersistence.forceDisconnectClient("client", true, ClientSessionPersistenceImpl.DisconnectSource.EXTENSION); channel.disconnect(); final Boolean result = future.get(); "<AssertPlaceHolder>"; verify(pendingWillMessages).cancelWillIfPending("client"); verify(mqttServerDisconnector).disconnect(any(Channel.class), anyString(), anyString(), eq(Mqtt5DisconnectReasonCode.ADMINISTRATIVE_ACTION), any()); }
forceDisconnectClient( final @NotNull String clientId, final boolean preventLwtMessage, final @NotNull DisconnectSource source) { return forceDisconnectClient(clientId, preventLwtMessage, source, null, null); }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: generate_columnProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new RelationReference("col", null), null); Assert."<AssertPlaceHolder>"; }
generate() { return visitProjection(projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testAddAggrConfigInfoOfEqualContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and equal with current content param. String existContent = "content1234"; when(jdbcTemplate.queryForObject(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenReturn(existContent);  boolean result = externalConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
addAggrConfigInfo(final String dataId, final String group, String tenant, final String datumId, String appName, final String content) { String appNameTmp = StringUtils.isBlank(appName) ? StringUtils.EMPTY : appName; String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; final Timestamp now = new Timestamp(System.currentTimeMillis()); ConfigInfoAggrMapper configInfoAggrMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_AGGR); String select = configInfoAggrMapper.select(Collections.singletonList("content"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id")); String insert = configInfoAggrMapper.insert( Arrays.asList("data_id", "group_id", "tenant_id", "datum_id", "app_name", "content", "gmt_modified")); String update = configInfoAggrMapper.update(Arrays.asList("content", "gmt_modified"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id"));  try { try { String dbContent = jt.queryForObject(select, new Object[] {dataId, group, tenantTmp, datumId}, String.class);  if (dbContent != null && dbContent.equals(content)) { return true; } else { return jt.update(update, content, now, dataId, group, tenantTmp, datumId) > 0; } } catch (EmptyResultDataAccessException ex) { // no data, insert return jt.update(insert, dataId, group, tenantTmp, datumId, appNameTmp, content, now) > 0; } } catch (DataAccessException e) { LogUtil.FATAL_LOG.error("[db-error] " + e, e); throw e; } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: generate_accessFunctionWithAssign_generateFunctionCallSucceed() { Bit_exprContext context = getBitExprContext("function(p => (not a <= b) and (c != d))"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  Expression left = new CompoundExpression( new CompoundExpression(new RelationReference("a", null), new RelationReference("b", null), Operator.LE), null, Operator.NOT); Expression right = new CompoundExpression(new RelationReference("c", null), new RelationReference("d", null), Operator.NE); ParamWithAssign param1 = new ParamWithAssign("p", new CompoundExpression(left, right, Operator.AND)); FunctionCall expect = new FunctionCall("function", Collections.singletonList(param1)); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: MalformedURLException { AmazonS3 s3 = mock(AmazonS3Client.class); Mockito.when(s3.generatePresignedUrl(any())).thenReturn(new URL("http://test.sql")); AmazonCloudClient alibabaCloudClient = new AmazonCloudClient(s3, null, "test", "test"); URL url = alibabaCloudClient.generatePresignedUrl("test", "test", new Date()); Assert."<AssertPlaceHolder>"; }
generatePresignedUrl(String bucketName, String key, Date expiration) throws CloudException { Verify.notBlank(key, "key"); return callAmazonMethod("Generate presigned URL", () -> { GeneratePresignedUrlRequest request = new GeneratePresignedUrlRequest(bucketName, key); request.setBucketName(bucketName); request.setExpiration(expiration); request.setKey(key); ResponseHeaderOverrides responseHeaderOverrides = new ResponseHeaderOverrides(); responseHeaderOverrides.setContentDisposition( String.format("attachment;filename=%s", new String(CloudObjectStorageUtil.getOriginalFileName(key).getBytes(), StandardCharsets.ISO_8859_1))); request.setResponseHeaders(responseHeaderOverrides); return s3.generatePresignedUrl(request); }); }
[*] target: assertNotNull(url)
[-] pred: org. junit. Assert. assertNotNull ( url )
************************************
************************************
[+] input: generate_alterIndexNoParallel_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("alter index abc noParallel")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.alterIndexNoParallel("abc"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldOptimizeEmptyActiveTasks() { final RackAwareTaskAssignor assignor = new RackAwareTaskAssignor( getClusterForAllTopics(), getTaskTopicPartitionMapForAllTasks(), mkMap(), getTopologyGroupTaskMap(), getProcessRacksForAllProcess(), mockInternalTopicManager, getRackAwareEnabledConfig(), time );  final ClientState clientState1 = new ClientState(emptySet(), emptySet(), emptyMap(), EMPTY_CLIENT_TAGS, 1);  clientState1.assignActiveTasks(mkSet(TASK_0_1, TASK_1_1));  final SortedMap<UUID, ClientState> clientStateMap = new TreeMap<>(mkMap( mkEntry(UUID_1, clientState1) )); final SortedSet<TaskId> taskIds = mkSortedSet();  assertTrue(assignor.canEnableRackAwareAssignor()); final long originalCost = assignor.activeTasksCost(taskIds, clientStateMap, trafficCost, nonOverlapCost); assertEquals(0, originalCost);  final long cost = assignor.optimizeActiveTasks(taskIds, clientStateMap, trafficCost, nonOverlapCost); "<AssertPlaceHolder>";  assertEquals(mkSet(TASK_0_1, TASK_1_1), clientState1.activeTasks()); }
optimizeActiveTasks(final SortedSet<TaskId> activeTasks, final SortedMap<UUID, ClientState> clientStates, final int trafficCost, final int nonOverlapCost) { if (activeTasks.isEmpty()) { return 0; }  log.info("Assignment before active task optimization is {}\n with cost {}", clientStates, activeTasksCost(activeTasks, clientStates, trafficCost, nonOverlapCost));  final long startTime = time.milliseconds(); final List<UUID> clientList = new ArrayList<>(clientStates.keySet()); final List<TaskId> taskIdList = new ArrayList<>(activeTasks); final Map<TaskId, UUID> taskClientMap = new HashMap<>(); final Map<UUID, Integer> originalAssignedTaskNumber = new HashMap<>(); final RackAwareGraphConstructor<ClientState> graphConstructor = RackAwareGraphConstructorFactory.create(assignmentConfigs, tasksForTopicGroup); final Graph<Integer> graph = graphConstructor.constructTaskGraph( clientList, taskIdList, clientStates, taskClientMap, originalAssignedTaskNumber, ClientState::hasActiveTask, this::getCost, trafficCost, nonOverlapCost, false, false );  graph.solveMinCostFlow(); final long cost = graph.totalCost();  graphConstructor.assignTaskFromMinCostFlow(graph, clientList, taskIdList, clientStates, originalAssignedTaskNumber, taskClientMap, ClientState::assignActive, ClientState::unassignActive, ClientState::hasActiveTask);  final long duration = time.milliseconds() - startTime; log.info("Assignment after {} milliseconds for active task optimization is {}\n with cost {}", duration, clientStates, cost); return cost; }
[*] target: assertEquals(0, cost)
[-] pred: org. junit. Assert. assertEquals ( 0, cost )
************************************
************************************
[+] input: copy_noChanges() { final PubrelPacketImpl packet = new PubrelPacketImpl( 1, PubrelReasonCode.SUCCESS, null, UserPropertiesImpl.of(ImmutableList.of())); final ModifiablePubrelPacketImpl modifiablePacket = new ModifiablePubrelPacketImpl(packet, configurationService);  final PubrelPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new PubrelPacketImpl(packetIdentifier, reasonCode, reasonString, userProperties.copy()); }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
************************************
[+] input: testInitNamespaceFromPropNamespaceWithoutCloudParsing() { System.setProperty(SystemPropertyKeyConst.ANS_NAMESPACE, "ans"); System.setProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, "false"); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); String expect = "ns1"; properties.setProperty(PropertyKeyConst.NAMESPACE, expect); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
initNamespaceForNaming(NacosClientProperties properties) { String tmpNamespace = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) {  tmpNamespace = TenantUtil.getUserTenantForAns(); LogUtils.NAMING_LOGGER.info("initializer namespace from ans.namespace attribute : {}", tmpNamespace);  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from ALIBABA_ALIWARE_NAMESPACE attribute :" + namespace); return namespace; }); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getPropertyFrom(SourceType.JVM, PropertyKeyConst.NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from namespace attribute :" + namespace); return namespace; });  if (StringUtils.isEmpty(tmpNamespace)) { tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> UtilAndComs.DEFAULT_NAMESPACE_ID); return tmpNamespace; }
[*] target: assertEquals(expect, ns)
[-] pred: org. junit. Assert. assertEquals ( expect, ns )
************************************
************************************
[+] input: verifyingTopicCleanupPolicyShouldReturnFalseWhenBrokerVersionIsUnsupported() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithUnsupportedVersion(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig, String topicPurpose) { Set<String> cleanupPolicies = topicCleanupPolicy(topic); if (cleanupPolicies.isEmpty()) { log.info("Unable to use admin client to verify the cleanup policy of '{}' " + "topic is '{}', either because the broker is an older " + "version or because the Kafka principal used for Connect " + "internal topics does not have the required permission to " + "describe topic configurations.", topic, TopicConfig.CLEANUP_POLICY_COMPACT); return false; } Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT); if (!cleanupPolicies.equals(expectedPolicies)) { String expectedPolicyStr = String.join(",", expectedPolicies); String cleanupPolicyStr = String.join(",", cleanupPolicies); String msg = String.format("Topic '%s' supplied via the '%s' property is required " + "to have '%s=%s' to guarantee consistency and durability of " + "%s, but found the topic currently has '%s=%s'. Continuing would likely " + "result in eventually losing %s and problems restarting this Connect " + "cluster in the future. Change the '%s' property in the " + "Connect worker configurations to use a topic with '%s=%s'.", topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr, topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr); throw new ConfigException(msg); } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: getWeekday_Tuesday_2() { // 周二 DateTime233 of = DateTime233.of("2023-01-10 09:00:00", "yyyy-MM-dd HH:mm:ss"); int weekDay = of.getWeekDay(); "<AssertPlaceHolder>"; }
getWeekDay() { return DateTime233.weekDay(this.zonedTimeMs); }
[*] target: assertEquals(2, weekDay)
[-] pred: org. junit. Assert. assertEquals ( 2, weekDay )
************************************
************************************
[+] input: generate_indexHash_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("index idx_name using hash (col, col1) reverse parallel=12")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingHash(true); indexOptions.setParallel(12); indexOptions.setReverse(true); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: parserAnonymousBlock_callFunctionSucceed() { ParserCallPLByAnonymousBlockResult result = AnonymousBlockParser.parserCallPLAnonymousBlockResult(TEST_DDL_1, 0); Map<String, AnonymousBlockFunctionCall> functionCallMap = result.getFunctionCallMap(); AnonymousBlockFunctionCall functionCall = functionCallMap.get("FUN"); int actual = functionCall.getCallLine(); int expect = 7; Assert."<AssertPlaceHolder>"; }
parserCallPLAnonymousBlockResult(final String pl, long timeoutMillis) { CharStream input = CharStreams.fromString(pl); CaseChangingCharStream caseChangingCharStream = new CaseChangingCharStream(input, true); PlSqlLexer lexer = new PlSqlLexer(caseChangingCharStream); lexer.removeErrorListeners(); lexer.addErrorListener(new FastFailErrorListener()); CommonTokenStream tokens; if (timeoutMillis <= 0) { tokens = new CommonTokenStream(lexer); } else { tokens = new TimeoutTokenStream(lexer, timeoutMillis); } PlSqlParser parser = new PlSqlParser(tokens); parser.removeErrorListeners(); parser.addErrorListener(new FastFailErrorListener()); parser.setErrorHandler(new FastFailErrorStrategy()); ParseTree tree = parser.sql_script(); OBOracleCallPLByAnonymousBlockListener listener = new OBOracleCallPLByAnonymousBlockListener(); ParseTreeWalker walker = new ParseTreeWalker(); walker.walk(listener, tree); return new ParserCallPLByAnonymousBlockResult(listener); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_timestampWithPrescision_generateSucceed() { StatementFactory<DataType> factory = new OracleDataTypeFactory(getDataTypeContext("timestamp(12)")); DataType actual = factory.generate();  DataType expect = new TimestampType(new BigDecimal("12"), false, false); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_utc_timestamp_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("UTC_TIMESTAMP(12)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); FunctionCall expect = new FunctionCall("UTC_TIMESTAMP", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testVersionHintWithBucketNameAsLocation() { Table mockTable = mock(Table.class); when(mockTable.location()).thenReturn("s3://bucket1"); String reportedVersionHintLocation = ReachableFileUtil.versionHintLocation(mockTable); String expectedVersionHintLocation = "s3://bucket1/metadata/" + Util.VERSION_HINT_FILENAME; Assert."<AssertPlaceHolder>"; }
versionHintLocation(Table table) { // only Hadoop tables have a hint file and such tables have a fixed metadata layout Path metadataPath = new Path(table.location() + "/" + METADATA_FOLDER_NAME); Path versionHintPath = new Path(metadataPath + "/" + Util.VERSION_HINT_FILENAME); return versionHintPath.toString(); }
[*] target: assertEquals(expectedVersionHintLocation, reportedVersionHintLocation)
[-] pred: org. junit. Assert. assertEquals ( expectedVersionHintLocation, reportedVersionHintLocation )
************************************
************************************
[+] input: ParseException { String dateStr = "2007.02.21"; Date exp = SystemReader.getInstance().getSimpleDateFormat("yyyy.MM.dd") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
************************************
[+] input: generate_updateAssignmentUseDefault_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=DEFAULT, col2=1"); StatementFactory<Update> factory = new OracleUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col")), null, true), new UpdateAssign(Arrays.asList(new ColumnReference(null, null, "col2")), new ConstExpression("1"), false))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_addRangePartitionElts_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext( "add partition (partition a.b values less than (-2, maxvalue) engine=InnoDB," + "partition d values less than (func(1,2)) id 14)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); RangePartitionElement e1 = new RangePartitionElement("b", Arrays.asList( new CompoundExpression(new ConstExpression("2"), null, Operator.SUB), new ConstExpression("maxvalue"))); PartitionOptions o = new PartitionOptions(); o.setEngine("InnoDB"); e1.setPartitionOptions(o); e1.setSchema("a"); FunctionParam p1 = new ExpressionParam(new ConstExpression("1")); FunctionParam p2 = new ExpressionParam(new ConstExpression("2")); RangePartitionElement e3 = new RangePartitionElement("d", Collections.singletonList(new FunctionCall("func", Arrays.asList(p1, p2)))); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e3.setPartitionOptions(o1);  expect.setAddPartitionElements(Arrays.asList(e1, e3)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_temporaryTable_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create temporary table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setTemporary(true); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_uniqueGroupConcatExprListWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "GROUP_CONCAT(unique 5,6 order by col1 asc SEPARATOR 'mmm') over (name_ob partition by (1,2) order by col desc rows between " + "current row and 123 PRECEDING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); FunctionParam pppp = new ExpressionParam(new ConstExpression("6")); params.add(pppp); GroupConcat expect = new GroupConcat(params); expect.addOption(new ConstExpression("unique")); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset begin = new WindowOffset(WindowOffsetType.CURRENT_ROW); WindowOffset end = new WindowOffset(WindowOffsetType.PRECEDING); end.setInterval(new ConstExpression("123")); WindowBody body = new WindowBody(WindowType.ROWS, begin, end); window.setBody(body); expect.setWindow(window); SortKey s0 = new SortKey(new ColumnReference(null, null, "col1"), SortDirection.ASC); expect.addOption(new OrderBy(Collections.singletonList(s0))); expect.addOption(new ConstExpression("SEPARATOR 'mmm'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: isRedirectUrlValid_HostNotMatch_InValid() { MockHttpServletRequest request = new MockHttpServletRequest("GET", "http://localhost:8989");  boolean redirectUrlValid = WebRequestUtils.isRedirectUrlValid(request, "http://another:8989/hello");  Assert."<AssertPlaceHolder>"; }
isRedirectUrlValid(HttpServletRequest request, String redirectUrl) { if (StringUtils.isBlank(redirectUrl)) { return false; } String requestHost = getRequestUriComponents(request).getHost(); String redirectHost = UriComponentsBuilder.fromUriString(redirectUrl).build().getHost(); return StringUtils.equals(requestHost, redirectHost) || StringUtils.isEmpty(redirectHost); }
[*] target: assertFalse(redirectUrlValid)
[-] pred: org. junit. Assert. assertFalse ( redirectUrlValid )
************************************
************************************
[+] input: NacosException { final String dataId = "1failover"; final String group = "2"; final String tenant = "";  MockedStatic<LocalConfigInfoProcessor> localConfigInfoProcessorMockedStatic = Mockito.mockStatic( LocalConfigInfoProcessor.class); try { String contentFailOver = "failOverContent" + System.currentTimeMillis(); localConfigInfoProcessorMockedStatic.when( () -> LocalConfigInfoProcessor.getFailover(any(), eq(dataId), eq(group), eq(tenant))) .thenReturn(contentFailOver); final int timeout = 3000;  final String config = nacosConfigService.getConfig(dataId, group, timeout); Assert."<AssertPlaceHolder>"; } finally { localConfigInfoProcessorMockedStatic.close(); } }
getConfig(String dataId, String group, long timeoutMs) throws NacosException { return getConfigInner(namespace, dataId, group, timeoutMs); }
[*] target: assertEquals(contentFailOver, config)
[-] pred: org. junit. Assert. assertEquals ( contentFailOver, config )
************************************
************************************
[+] input: generate_uniqueIndexAutoPartition_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext( "unique index idx_name (col asc id 16, col1) partition by range columns(a,b) partition size 'auto' PARTITIONS AUTO")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); s1.setId(16); s1.setDirection(SortDirection.ASC); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); RangePartition p = new RangePartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")), null, null, null, true); p.setAuto(true); p.setPartitionSize(new ConstExpression("'auto'")); state.setPartition(p); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setUniqueKey(true); expect.setIndexName("idx_name"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_generalOrderByMultiSortKeys_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select col from tab order by chz.tab.col,tab3.col1 desc ;"); StatementFactory<OrderBy> factory = new MySQLOrderByFactory(context); OrderBy actual = factory.generate();  SortKey s1 = new SortKey(new ColumnReference("chz", "tab", "col"), null); SortKey s2 = new SortKey(new ColumnReference(null, "tab3", "col1"), SortDirection.DESC); OrderBy expect = new OrderBy(Arrays.asList(s1, s2)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: Exception { commitGraph = CommitGraphLoader .open(JGitTestUtil.getTestResourceFile("commit-graph.v1")); "<AssertPlaceHolder>"; assertEquals(10, commitGraph.getCommitCnt()); verifyGraphObjectIndex();  assertCommitData("85b0176af27fa1640868f061f224d01e0b295f59", new int[] { 5, 6 }, 1670570408L, 3, 0); assertCommitData("d4f7c00aab3f0160168c9e5991abb6194a4e0d9e", new int[] {}, 1670569901L, 1, 1); assertCommitData("4d03aaf9c20c97d6ccdc05cb7f146b1deb6c01d5", new int[] { 5 }, 1670570119L, 3, 2); assertCommitData("a2f409b753880bf83b18bfb433dd340a6185e8be", new int[] { 7 }, 1670569935L, 3, 3); assertCommitData("431343847343979bbe31127ed905a24fed9a636c", new int[] { 3, 2, 8 }, 1670570644L, 4, 4); assertCommitData("c3f745ad8928ef56b5dbf33740fc8ede6b598290", new int[] { 1 }, 1670570106L, 2, 5); assertCommitData("95b12422c8ea4371e54cd58925eeed9d960ff1f0", new int[] { 1 }, 1670570163L, 2, 6); assertCommitData("de0ea882503cdd9c984c0a43238014569a123cac", new int[] { 1 }, 1670569921L, 2, 7); assertCommitData("102c9d6481559b1a113eb66bf55085903de6fb00", new int[] { 6 }, 1670570616L, 3, 8); assertCommitData("b5de2a84867f8ffc6321649dabf8c0680661ec03", new int[] { 7, 5 }, 1670570364L, 3, 9); }
open(File graphFile) throws FileNotFoundException, CommitGraphFormatException, IOException { try (SilentFileInputStream fd = new SilentFileInputStream(graphFile)) { try { return read(fd); } catch (CommitGraphFormatException fe) { throw fe; } catch (IOException ioe) { throw new IOException(MessageFormat.format( JGitText.get().unreadableCommitGraph, graphFile.getAbsolutePath()), ioe); } } }
[*] target: assertNotNull(commitGraph)
[-] pred: org. junit. Assert. assertNotNull ( commitGraph )
************************************
************************************
[+] input: test_end_batch_compile() { batchCompileId = startBatchCompile(); boolean success = plService.endBatchCompile(batchCompileId); Assert."<AssertPlaceHolder>"; batchCompileId = null; }
endBatchCompile(String id) { Pair<BatchCompileTaskCallable, Future<BatchCompileResp>> taskIdentity = nullSafeGet(id); endTaskCache.put(id, taskIdentity); runningTaskMap.remove(id); return taskIdentity.right.cancel(true); }
[*] target: assertTrue(success)
[-] pred: org. junit. Assert. assertTrue ( success )
************************************
************************************
[+] input: testIsLocalFileAbsent_ReturnTrue() { ObjectMetadata ossMeta = new ObjectMetadata(); ossMeta.setBucketName(BUCKET); ossMeta.setObjectId("some-file"); boolean isLocalAbsent = localFileOperator.isLocalFileAbsent(ossMeta); "<AssertPlaceHolder>"; }
isLocalFileAbsent(ObjectMetadata objectMetadata) { String bucketName = objectMetadata.getBucketName(); String objectId = objectMetadata.getObjectId(); File file = getOrCreateLocalFile(bucketName, ObjectStorageUtils.concatObjectId(objectId, objectMetadata.getExtension())); if (!file.exists()) { log.warn("Local File not exists, bucketName={}, objectId={}", bucketName, objectId); return true; } long fileSize = file.length(); if (fileSize != objectMetadata.getTotalLength()) { log.warn("File size not match, objectId={}", objectMetadata.getObjectId()); return true; } String sha1; try { sha1 = HashUtils.sha1(file); } catch (IOException e) { throw new UnexpectedException("get file sha1 failed"); } if (!StringUtils.equalsIgnoreCase(sha1, objectMetadata.getSha1())) { log.warn("sha1 not match, should refresh from database, fileName={}", objectMetadata.getObjectName()); return true; } return false; }
[*] target: assertTrue(isLocalAbsent)
[-] pred: org. junit. Assert. assertTrue ( isLocalAbsent )
************************************
************************************
[+] input: testAddAggrConfigInfoOfAddNewContent() { String dataId = "dataId111"; String group = "group"; String tenant = "tenant"; String datumId = "datumId"; String appName = "appname1234"; String content = "content1234";  //mock query datumId and return null. Mockito.when(databaseOperate.queryOne(anyString(), eq(new Object[] {dataId, group, tenant, datumId}), eq(String.class))).thenReturn(null); //mock insert success Mockito.when(databaseOperate.update(any(List.class))).thenReturn(true);  //execute boolean result = embededConfigInfoAggrPersistService.addAggrConfigInfo(dataId, group, tenant, datumId, appName, content); Assert."<AssertPlaceHolder>"; }
addAggrConfigInfo(final String dataId, final String group, String tenant, final String datumId, String appName, final String content) { String appNameTmp = StringUtils.isBlank(appName) ? StringUtils.EMPTY : appName; String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; String contentTmp = StringUtils.isBlank(content) ? StringUtils.EMPTY : content; final Timestamp now = new Timestamp(System.currentTimeMillis());  ConfigInfoAggrMapper configInfoAggrMapper = mapperManager.findMapper(dataSourceService.getDataSourceType(), TableConstant.CONFIG_INFO_AGGR); final String select = configInfoAggrMapper.select(Collections.singletonList("content"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id")); final String insert = configInfoAggrMapper.insert( Arrays.asList("data_id", "group_id", "tenant_id", "datum_id", "app_name", "content", "gmt_modified")); final String update = configInfoAggrMapper.update(Arrays.asList("content", "gmt_modified"), Arrays.asList("data_id", "group_id", "tenant_id", "datum_id"));  String dbContent = databaseOperate.queryOne(select, new Object[] {dataId, group, tenantTmp, datumId}, String.class);  if (Objects.isNull(dbContent)) { final Object[] args = new Object[] {dataId, group, tenantTmp, datumId, appNameTmp, contentTmp, now}; EmbeddedStorageContextHolder.addSqlContext(insert, args); } else if (!dbContent.equals(content)) { final Object[] args = new Object[] {contentTmp, now, dataId, group, tenantTmp, datumId}; EmbeddedStorageContextHolder.addSqlContext(update, args); }  try { boolean result = databaseOperate.update(EmbeddedStorageContextHolder.getCurrentSqlContext()); if (!result) { throw new NacosConfigException("[Merge] Configuration release failed"); } return true; } finally { EmbeddedStorageContextHolder.cleanAllContext(); } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: ParseException { String dateStr = "02/21/2007"; Date exp = SystemReader.getInstance().getSimpleDateFormat("MM/dd/yyyy") .parse(dateStr); Date parse = GitDateParser.parse(dateStr, null, SystemReader .getInstance().getLocale()); Assert."<AssertPlaceHolder>"; }
parse(String dateStr, Calendar now, Locale locale) throws ParseException { dateStr = dateStr.trim(); Date ret;  if ("never".equalsIgnoreCase(dateStr)) //$NON-NLS-1$ return NEVER; ret = parse_relative(dateStr, now); if (ret != null) return ret; for (ParseableSimpleDateFormat f : ParseableSimpleDateFormat.values()) { try { return parse_simple(dateStr, f, locale); } catch (ParseException e) { // simply proceed with the next parser } } ParseableSimpleDateFormat[] values = ParseableSimpleDateFormat.values(); StringBuilder allFormats = new StringBuilder(""") //$NON-NLS-1$ .append(values[0].formatStr); for (int i = 1; i < values.length; i++) allFormats.append("", "").append(values[i].formatStr); //$NON-NLS-1$ allFormats.append("""); //$NON-NLS-1$ throw new ParseException(MessageFormat.format( JGitText.get().cannotParseDate, dateStr, allFormats.toString()), 0); }
[*] target: assertEquals(exp, parse)
[-] pred: org. junit. Assert. assertEquals ( exp, parse )
************************************
************************************
[+] input: testGetExpiredMetadataInfos() { Set<ExpiredMetadataInfo> expiredMetadataInfos = namingMetadataManager.getExpiredMetadataInfos();  Assert."<AssertPlaceHolder>"; }
getExpiredMetadataInfos() { return expiredMetadataInfos; }
[*] target: assertNotNull(expiredMetadataInfos)
[-] pred: org. junit. Assert. assertNotNull ( expiredMetadataInfos )
************************************
************************************
[+] input: generate_castAsChar_generateFunctionCallSucceed() { ExprContext context = getExprContext("cast('abc' as character(15) binary)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'abc'")); CharacterType type = new CharacterType("character", new BigDecimal(15)); type.setBinary(true); p.addOption(type); params.add(p); FunctionCall expect = new FunctionCall("cast", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testErrorThroughRpc() { final AtomicReference<Response> reference = new AtomicReference<>();  RpcContext context = new RpcContext() { @Override public void sendResponse(Object responseObj) { reference.set((Response) responseObj); }  @Override public Connection getConnection() { return null; }  @Override public String getRemoteAddress() { return null; } }; AbstractProcessor processor = new NacosWriteRequestProcessor(server, SerializeFactory.getDefault()); processor.execute(server, context, WriteRequest.newBuilder().build(), new JRaftServer.RaftGroupTuple());  Response response = reference.get(); Assert."<AssertPlaceHolder>";  Assert.assertEquals("Error message transmission", response.getErrMsg()); Assert.assertFalse(response.getSuccess()); }
execute(JRaftServer server, final RpcContext asyncCtx, final Message message, final JRaftServer.RaftGroupTuple tuple) { FailoverClosure closure = new FailoverClosure() {  Response data;  Throwable ex;  @Override public void setResponse(Response data) { this.data = data; }  @Override public void setThrowable(Throwable throwable) { this.ex = throwable; }  @Override public void run(Status status) { if (Objects.nonNull(ex)) { Loggers.RAFT.error("execute has error : ", ex); asyncCtx.sendResponse(Response.newBuilder().setErrMsg(ex.toString()).setSuccess(false).build()); } else { asyncCtx.sendResponse(data); } } };  server.applyOperation(tuple.getNode(), message, closure); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: getConverter() { HutoolConverterManager hutoolConverterManager = new HutoolConverterManager(); // force cast object to collection hutoolConverterManager.getConverter(Object.class, Collection.class); @SuppressWarnings("rawtypes") BiFunction<Object, Collection, Collection> converter = hutoolConverterManager .getConverter(Object.class, Collection.class); Assert."<AssertPlaceHolder>";  Object obj = new Object(); Assert.assertEquals(CollectionUtils.newCollection(ArrayList::new, obj), converter.apply(obj, null)); Assert.assertEquals(converter.apply(Collections.singleton(obj), null), converter.apply(Collections.singleton(obj), null)); }
getConverter(Class<T> targetType, Class<R> resultType) { return (source, defaultValue) -> { if (resultType.isInstance(source)) { return (R)source; } return Convert.convert(resultType, source, defaultValue); }; }
[*] target: assertNotNull(converter)
[-] pred: org. junit. Assert. assertNotNull ( converter )
************************************
************************************
[+] input: Exception { Callable callable = mock(Callable.class); when(callable.call()).thenThrow(new RuntimeException("test")); String actual = TemplateUtils.stringBlankAndThenExecute(null, callable); "<AssertPlaceHolder>"; }
stringBlankAndThenExecute(String source, Callable<String> callable) {  if (StringUtils.isBlank(source)) {  try { return callable.call(); } catch (Exception e) { LogUtils.NAMING_LOGGER.error("string empty and then execute cause an exception.", e); } }  return source == null ? null : source.trim(); }
[*] target: assertNull(actual)
[-] pred: org. junit. Assert. assertNull ( actual )
************************************
************************************
[+] input: testJoin() { MapperManager.join(new AbstractMapper() { @Override public String getTableName() { return "test"; }  @Override public String getDataSource() { return DataSourceConstant.MYSQL; } }); MapperManager instance = MapperManager.instance(false); Mapper mapper = instance.findMapper(DataSourceConstant.MYSQL, "test"); Assert."<AssertPlaceHolder>"; }
findMapper(String dataSource, String tableName) { if (LOGGER.isDebugEnabled()) { LOGGER.debug("[MapperManager] findMapper dataSource: {}, tableName: {}", dataSource, tableName); } if (StringUtils.isBlank(dataSource) || StringUtils.isBlank(tableName)) { throw new NacosRuntimeException(FIND_DATASOURCE_ERROR_CODE, "dataSource or tableName is null"); } Map<String, Mapper> tableMapper = MAPPER_SPI_MAP.get(dataSource); if (Objects.isNull(tableMapper)) { throw new NacosRuntimeException(FIND_DATASOURCE_ERROR_CODE, "[MapperManager] Failed to find the datasource,dataSource:" + dataSource); } Mapper mapper = tableMapper.get(tableName); if (Objects.isNull(mapper)) { throw new NacosRuntimeException(FIND_TABLE_ERROR_CODE, "[MapperManager] Failed to find the table ,tableName:" + tableName); } if (dataSourceLogEnable) { return MapperProxy.createSingleProxy(mapper); } return (R) mapper; }
[*] target: assertNotNull(mapper)
[-] pred: org. junit. Assert. assertNotNull ( mapper )
************************************
************************************
[+] input: generate_generalOrderByDesc_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select col from tab order by col desc;"); StatementFactory<OrderBy> factory = new MySQLOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy expect = new OrderBy(Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: test_get_tls_with_sni() {  clientConnection.setAuthCipherSuite("cipher"); clientConnection.setAuthProtocol("TLSv1.2"); clientConnection.setAuthSniHostname("test.hostname.domain");  final ClientTlsInformation clientTlsInformation = ExtensionInformationUtil.getTlsInformationFromChannel(channel); "<AssertPlaceHolder>"; assertEquals("cipher", clientTlsInformation.getCipherSuite()); assertEquals("TLSv1.2", clientTlsInformation.getProtocol()); assertTrue(clientTlsInformation.getHostname().isPresent()); assertEquals("test.hostname.domain", clientTlsInformation.getHostname().get()); assertEquals("TLSv1.2", clientTlsInformation.getProtocol()); assertTrue(clientTlsInformation.getClientCertificate().isEmpty()); }
getTlsInformationFromChannel(final @NotNull Channel channel) {  Preconditions.checkNotNull(channel, "channel must never be null");  final ClientConnection clientConnection = channel.attr(ClientConnection.CHANNEL_ATTRIBUTE_NAME).get(); try { final String cipher = clientConnection.getAuthCipherSuite(); final String protocol = clientConnection.getAuthProtocol(); final String sniHostname = clientConnection.getAuthSniHostname();  final SslClientCertificate sslClientCertificate = clientConnection.getAuthCertificate();  if (cipher == null || protocol == null) { return null; }  if (sslClientCertificate == null) { return new ClientTlsInformationImpl(null, null, cipher, protocol, sniHostname);  } else { final X509Certificate certificate = (X509Certificate) sslClientCertificate.certificate(); final X509Certificate[] certificateChain = (X509Certificate[]) sslClientCertificate.certificateChain();  return new ClientTlsInformationImpl(certificate, certificateChain, cipher, protocol, sniHostname); }  } catch (final Exception e) { log.debug("Tls information creation failed: ", e); }  return null; }
[*] target: assertNotNull(clientTlsInformation)
[-] pred: org. junit. Assert. assertNotNull ( clientTlsInformation )
************************************
************************************
[+] input: generate_orderSiblingsBy_generateOrderBySucceed() { Order_byContext context = getOrderByContext("select 1 from dual order siblings by col desc"); StatementFactory<OrderBy> factory = new OracleOrderByFactory(context); OrderBy actual = factory.generate();  SortKey sortKey = new SortKey(new RelationReference("col", null), SortDirection.DESC, null); OrderBy expect = new OrderBy(true, Collections.singletonList(sortKey)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.orderByContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testWebUtilWithIntMaxValue() { SecuritySession session = Mockito.mock(SecuritySession.class); Mockito.when(session.getId()).thenReturn("abcde"); Mockito.when(session.getTimeoutMillis()).thenReturn(Integer.MAX_VALUE * 1000L + 100000); Cookie cookie = WebUtil.generateSecurityCookie(session); Assert."<AssertPlaceHolder>"; Assert.assertEquals(cookie.getValue(), session.getId()); Assert.assertEquals(cookie.getMaxAge(), Integer.MAX_VALUE); Assert.assertTrue(cookie.isHttpOnly()); Assert.assertEquals(cookie.getPath(), "/"); }
generateSecurityCookie(@NonNull SecuritySession session) { Cookie cookie = new Cookie(SecurityConstants.CUSTOM_COOKIE_NAME, (String) session.getId()); cookie.setHttpOnly(true); long maxAgeSeconds = TimeUnit.SECONDS.convert(session.getTimeoutMillis(), TimeUnit.MILLISECONDS); if (maxAgeSeconds > Integer.MAX_VALUE) { cookie.setMaxAge(Integer.MAX_VALUE); } else { cookie.setMaxAge((int) maxAgeSeconds); } cookie.setPath("/"); return cookie; }
[*] target: assertNotNull(cookie)
[-] pred: org. junit. Assert. assertNotNull ( cookie )
************************************
************************************
[+] input: generate_externalCreateTable_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create external table abcd (id varchar(64))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setExternal(true); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testEmpty() { final RawText r = new RawText(new byte[0]); "<AssertPlaceHolder>"; }
size() { // The line map is always 2 entries larger than the number of lines in // the file. Index 0 is padded out/unused. The last index is the total // length of the buffer, and acts as a sentinel. // return lines.size() - 2; }
[*] target: assertEquals(0, r.size())
[-] pred: org. junit. Assert. assertEquals ( 0, r. size() )
************************************
************************************
[+] input: testIsOnFalse() { boolean stsOn = StsConfig.getInstance().isStsOn(); Assert."<AssertPlaceHolder>"; }
isStsOn() { return StringUtils.isNotEmpty(getSecurityCredentials()) || StringUtils.isNotEmpty(getSecurityCredentialsUrl()); }
[*] target: assertFalse(stsOn)
[-] pred: org. junit. Assert. assertFalse ( stsOn )
************************************
************************************
[+] input: attempt_MaxTwoSecondTrue_ReturnTrue() { FailedLoginAttemptLimiter limiter = new FailedLoginAttemptLimiter(2, 1000L);  limiter.attempt(() -> false); Boolean result = limiter.attempt(() -> true);  Assert."<AssertPlaceHolder>"; }
attempt(Supplier<Boolean> attemptResultSupplier) { long currentTimeMillis = System.currentTimeMillis(); if (isLocked && (currentTimeMillis > lastLockedMills + lockTimeoutMillis || lockTimeoutMillis <= 0)) { isLocked = false; failedAttempt = 0; } if (isLocked) { long remainSeconds = (lastLockedMills + lockTimeoutMillis - currentTimeMillis) / 1000L; throw new AttemptLoginOverLimitException((double) maxFailedAttempt, remainSeconds, String.format("failed attempt over limit, failedAttempt=%d, limit=%d, remainSeconds=%d", failedAttempt, maxFailedAttempt, remainSeconds)); } Boolean result = null; try { result = attemptResultSupplier.get(); return result; } finally { if (result == null || !result) { log.info("attempt failed, currentFailedAttempt={}", failedAttempt); failedAttempt++; if (failedAttempt >= maxFailedAttempt) { isLocked = true; lastLockedMills = currentTimeMillis; } } } }
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { QueryServiceResponse res = new QueryServiceResponse(); ServiceInfo info = new ServiceInfo(GROUP_NAME + "@@" + SERVICE_NAME + "@@" + CLUSTERS); res.setServiceInfo(info); when(this.rpcClient.request(any())).thenReturn(res); ServiceInfo actual = client.queryInstancesOfService(SERVICE_NAME, GROUP_NAME, CLUSTERS, false); Assert."<AssertPlaceHolder>"; }
queryInstancesOfService(String serviceName, String groupName, String clusters, boolean healthyOnly) throws NacosException { ServiceQueryRequest request = new ServiceQueryRequest(namespaceId, serviceName, groupName); request.setCluster(clusters); request.setHealthyOnly(healthyOnly); QueryServiceResponse response = requestToServer(request, QueryServiceResponse.class); return response.getServiceInfo(); }
[*] target: assertEquals(info, actual)
[-] pred: org. junit. Assert. assertEquals ( info, actual )
************************************
************************************
[+] input: shouldDeleteKeyNoPropagateV1() { final MockProcessorContext<String, SubscriptionResponseWrapper<String>> context = new MockProcessorContext<>(); processor.init(context);  final SubscriptionWrapper<String> newValue = new SubscriptionWrapper<>( new long[]{1L}, Instruction.DELETE_KEY_NO_PROPAGATE, "pk1", SubscriptionWrapper.VERSION_1, 12); final Record<CombinedKey<String, String>, Change<ValueAndTimestamp<SubscriptionWrapper<String>>>> record = new Record<>(new CombinedKey<>("fk1", "pk1"), new Change<>(ValueAndTimestamp.make(newValue, 1L), null), 1L ); processor.process(record); final List<CapturedForward<? extends String, ? extends SubscriptionResponseWrapper<String>>> forwarded = context.forwarded(); Assert."<AssertPlaceHolder>"; }
process(final Record<CombinedKey<KO, K>, Change<ValueAndTimestamp<SubscriptionWrapper<K>>>> record) { Objects.requireNonNull(record.key(), "This processor should never see a null key."); Objects.requireNonNull(record.value(), "This processor should never see a null value."); final ValueAndTimestamp<SubscriptionWrapper<K>> valueAndTimestamp = record.value().newValue; Objects.requireNonNull(valueAndTimestamp, "This processor should never see a null newValue."); final SubscriptionWrapper<K> value = valueAndTimestamp.value();  if (value.getVersion() > SubscriptionWrapper.CURRENT_VERSION) { //Guard against modifications to SubscriptionWrapper. Need to ensure that there is compatibility //with previous versions to enable rolling upgrades. Must develop a strategy for upgrading //from older SubscriptionWrapper versions to newer versions. throw new UnsupportedVersionException("SubscriptionWrapper is of an incompatible version."); }  final ValueAndTimestamp<VO> foreignValueAndTime = record.key().getForeignKey() == null ? null : foreignValues.get(record.key().getForeignKey());  final long resultTimestamp = foreignValueAndTime == null ? valueAndTimestamp.timestamp() : Math.max(valueAndTimestamp.timestamp(), foreignValueAndTime.timestamp());  switch (value.getInstruction()) { case DELETE_KEY_AND_PROPAGATE: context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<VO>( value.getHash(), null, value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); break; case PROPAGATE_NULL_IF_NO_FK_VAL_AVAILABLE: //This one needs to go through regardless of LEFT or INNER join, since the extracted FK was //changed and there is no match for it. We must propagate the (key, null) to ensure that the //downstream consumers are alerted to this fact. final VO valueToSend = foreignValueAndTime == null ? null : foreignValueAndTime.value();  context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<>( value.getHash(), valueToSend, value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); break; case PROPAGATE_ONLY_IF_FK_VAL_AVAILABLE: if (foreignValueAndTime != null) { context().forward( record.withKey(record.key().getPrimaryKey()) .withValue(new SubscriptionResponseWrapper<>( value.getHash(), foreignValueAndTime.value(), value.getPrimaryPartition() )) .withTimestamp(resultTimestamp) ); } break; case DELETE_KEY_NO_PROPAGATE: break; default: throw new IllegalStateException("Unhandled instruction: " + value.getInstruction()); } }
[*] target: assertEquals(0, forwarded.size())
[-] pred: org. junit. Assert. assertEquals ( 0, forwarded. size ( ) )
************************************
************************************
[+] input: test_findByExpireTimeBefore() { long currentTime = System.currentTimeMillis(); PermissionEntity entity = createPermissionEntity("query", "ODC_DATABASE:1", new Date(currentTime - 90 * 1000L)); createPermissionEntity("change", "ODC_DATABASE:2", new Date(currentTime - 30 * 1000L)); createPermissionEntity("change", "ODC_DATABASE:3", TimeUtils.getMySQLMaxDatetime()); Assert.assertEquals(3, permissionRepository.findAllNoCareExpireTime().size()); List<PermissionEntity> entities = permissionRepository.findByExpireTimeBefore(new Date(currentTime - 60 * 1000L)); Assert."<AssertPlaceHolder>"; Assert.assertEquals(entity.getId(), entities.get(0).getId()); }
findByExpireTimeBefore(@Param("expireTime") Date expireTime);  @Modifying @Transactional @Query(value = "delete from iam_permission p where p.id in (:ids)", nativeQuery = true) int deleteByIds(@Param("ids") Collection<Long> ids);  @Modifying @Transactional @Query(value = "delete from iam_permission p where 1=1", nativeQuery = true) void deleteAll();  default List<PermissionEntity> batchCreate(List<PermissionEntity> entities) { String sql = InsertSqlTemplateBuilder.from("iam_permission") .field(PermissionEntity_.action) .field(PermissionEntity_.resourceIdentifier) .field(PermissionEntity_.type) .field(PermissionEntity_.creatorId) .field(PermissionEntity_.organizationId) .field("is_builtin") .field(PermissionEntity_.expireTime) .field(PermissionEntity_.authorizationType) .field(PermissionEntity_.ticketId) .field(PermissionEntity_.resourceType) .field(PermissionEntity_.resourceId) .build(); List<Function<PermissionEntity, Object>> getter = valueGetterBuilder() .add(PermissionEntity::getAction) .add(PermissionEntity::getResourceIdentifier) .add((PermissionEntity e) -> e.getType().name()) .add(PermissionEntity::getCreatorId) .add(PermissionEntity::getOrganizationId) .add(PermissionEntity::getBuiltIn) .add(PermissionEntity::getExpireTime) .add((PermissionEntity e) -> e.getAuthorizationType().name()) .add(PermissionEntity::getTicketId) .add((PermissionEntity e) -> e.getResourceType().name()) .add(PermissionEntity::getResourceId) .build();  return batchCreate(entities, sql, getter, PermissionEntity::setId); }
[*] target: assertEquals(1, entities.size())
[-] pred: org. junit. Assert. assertEquals ( 1, entities. size ( ) )
************************************
************************************
[+] input: update_updateSnippet_updateSucceed() { Snippet snippet = TestRandom.nextObject(Snippet.class); snippetsDAO.insert(snippet); snippet.setBody("new body"); snippet.setDescription("new desp"); snippet.setPrefix("new prefix"); snippet.setType("new type"); snippetsDAO.update(snippet); Snippet actual = snippetsDAO.get(snippet.getId()); snippet.setModifyTime(null); snippet.setCreateTime(null); actual.setModifyTime(null); actual.setCreateTime(null); Assert."<AssertPlaceHolder>"; }
get(long id);
[*] target: assertEquals(snippet, actual)
[-] pred: org. junit. Assert. assertEquals ( snippet, actual )
************************************
************************************
[+] input: generate_breadthFirstSearch_generateWithTableSucceed() { Common_table_exprContext context = getTableExprContext( "WITH relation_name (col1, col2) as (select * from dual) search breadth first by col2 desc, col3 asc set varname select 2 from dual"); StatementFactory<WithTable> factory = new OracleWithTableFactory(context); WithTable actual = factory.generate();  WithTable expect = new WithTable("relation_name", getDefaultSelect()); expect.setAliasList(Arrays.asList("col1", "col2")); expect.setSearchMode(SearchMode.BREADTH_FIRST); SortKey s1 = new SortKey(new RelationReference("col2", null), SortDirection.DESC, null); SortKey s2 = new SortKey(new RelationReference("col3", null), SortDirection.ASC, null); expect.setSearchSortKeyList(Arrays.asList(s1, s2)); expect.setSearchValueSet(new SetValue("varname", null, null)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.commonTableExprContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_dropConstraint_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("drop constraint abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropConstraintNames(Collections.singletonList("abcd")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: nullNetaddressStrategyTest() { boolean isMatch = RemoteAddressStrategyFactory.NULL_NET_ADDRESS_STRATEGY.match(new PlainAccessResource()); Assert."<AssertPlaceHolder>"; }
match(PlainAccessResource plainAccessResource);
[*] target: assertTrue(isMatch)
[-] pred: org. junit. Assert. assertTrue ( isMatch )
************************************
************************************
[+] input: generate_convertAsUnsignedInteger_generateFunctionCallSucceed() { ExprContext context = getExprContext("convert('123', unsigned integer)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'123'")); p.addOption(new GeneralDataType("unsigned integer", Collections.emptyList())); params.add(p); FunctionCall expect = new FunctionCall("convert", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_indexPrimaryKeyWithConstraintName_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext("constraint pk_name primary key (col, col1) using index")); OutOfLineConstraint actual = (OutOfLineConstraint) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); state.setUsingIndexFlag(true); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setConstraintName("pk_name"); expect.setPrimaryKey(true); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: implies_resourcePermissionWithDiffResourceId1_impliesFalse() { ResourcePermission permission = new ResourcePermission(new DefaultSecurityResource("12", "conn"), ResourcePermission.CREATE | ResourcePermission.DELETE); ResourcePermission permission1 = new ResourcePermission(new DefaultSecurityResource("112", "conn"), ResourcePermission.CREATE); Assert."<AssertPlaceHolder>"; }
implies(Permission p) { if (!(p instanceof ResourcePermission)) { return false; } ResourcePermission that = (ResourcePermission) p; // we get the effective mask. i.e., the "and" of this and that. // They must be equal to that.mask for implies to return true. return ((this.mask & that.mask) == that.mask) && impliesIgnoreMask(that); }
[*] target: assertFalse(permission.implies(permission1))
[-] pred: org. junit. Assert. assertFalse ( permission. implies( permission1 ) )
************************************
************************************
[+] input: generate_splitListPartition_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("split partition b into (" + "partition a.b@c values (default) tablespace tbs1 compress for oltp," + "partition d values (3) id 14 nocompress)")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); PartitionSplitActions actions = new PartitionSplitActions(); ListPartitionElement e1 = new ListPartitionElement("b", Collections.singletonList(new ConstExpression("default"))); e1.setSchema("a"); e1.setUserVariable("@c"); PartitionOptions options2 = new PartitionOptions(); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e1.setPartitionOptions(options2); ListPartitionElement e2 = new ListPartitionElement("d", Collections.singletonList(new ConstExpression("3"))); PartitionOptions options1 = new PartitionOptions(); options1.setId(14); options1.setNoCompress(true); e2.setPartitionOptions(options1); actions.setIntos(Arrays.asList(e1, e2)); expect.splitPartition(new RelationFactor("b"), actions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: IOException { String path = "test/payload";  Map<String, Object> payload = new HashMap<>(); payload.put("key1", "value1"); payload.put("key2", 200); byte[] payloadBytes = objectMapper.writeValueAsString(payload).getBytes(); when(externalPayloadStorage.download(path)) .thenReturn(new ByteArrayInputStream(payloadBytes));  Map<String, Object> result = externalPayloadStorageUtils.downloadPayload(path); "<AssertPlaceHolder>"; assertEquals(payload, result); }
downloadPayload(String path) { try (InputStream inputStream = externalPayloadStorage.download(path)) { return objectMapper.readValue( IOUtils.toString(inputStream, StandardCharsets.UTF_8), Map.class); } catch (TransientException te) { throw te; } catch (Exception e) { LOGGER.error("Unable to download payload from external storage path: {}", path, e); throw new NonTransientException( "Unable to download payload from external storage path: " + path, e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { // Generate a PQ for random 2D vectors var vectors = createRandomVectors(512, 2); var ravv = new ListRandomAccessVectorValues(vectors, 2); var pq = ProductQuantization.compute(ravv, 1, 256, false);  // Compress the vectors var compressed = pq.encodeAll(ravv); var cv = new PQVectors(pq, compressed); assertEquals(2 * Float.BYTES, cv.getOriginalSize()); assertEquals(1, cv.getCompressedSize());  // Write compressed vectors File cvFile = File.createTempFile("pqtest", ".cv"); try (var out = new DataOutputStream(new FileOutputStream(cvFile))) { cv.write(out); } // Read compressed vectors try (var in = new SimpleMappedReader(cvFile.getAbsolutePath())) { var cv2 = PQVectors.load(in, 0); "<AssertPlaceHolder>"; } }
write(DataOutput out) throws IOException { write(out, OnDiskGraphIndex.CURRENT_VERSION); }
[*] target: assertEquals(cv, cv2)
[-] pred: org. junit. Assert. assertEquals ( cv, cv2 )
************************************
************************************
[+] input: NacosException { String dataId = "1"; String group = "2"; String content = "123"; String namespace = ""; String casMd5 = "96147704e3cb8be8597d55d75d244a02"; String type = ConfigType.PROPERTIES.getType();  Mockito.when(mockWoker.publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type)) .thenReturn(true);  final boolean b = nacosConfigService.publishConfigCas(dataId, group, content, casMd5, type); Assert."<AssertPlaceHolder>";  Mockito.verify(mockWoker, Mockito.times(1)) .publishConfig(dataId, group, namespace, null, null, null, content, "", casMd5, type); }
publishConfigCas(String dataId, String group, String content, String casMd5, String type) throws NacosException { return publishConfigInner(namespace, dataId, group, null, null, null, content, type, casMd5); }
[*] target: assertTrue(b)
[-] pred: org. junit. Assert. assertTrue ( b )
************************************
************************************
[+] input: shouldCountWorkflows() { int counts = 1100; for (int i = 0; i < counts; i++) { WorkflowSummary workflowSummary = TestUtils.loadWorkflowSnapshot(objectMapper, "workflow_summary"); indexDAO.indexWorkflow(workflowSummary); }  // wait for workflow to be indexed long result = tryGetCount(() -> getWorkflowCount("template_workflow", "RUNNING"), counts); "<AssertPlaceHolder>"; }
getWorkflowCount(String query, String freeText) { try { return getObjectCounts(query, freeText, WORKFLOW_DOC_TYPE); } catch (Exception e) { throw new TransientException(e.getMessage(), e); } }
[*] target: assertEquals(counts, result)
[-] pred: org. junit. Assert. assertEquals ( counts, result )
************************************
************************************
[+] input: testRegisterOperatorProxyMethodFactory() { Crane4jTemplate.OpsForProxy ops = crane4jTemplate.opsForProxy(); AtomicBoolean processed = new AtomicBoolean(false); Assert.assertSame( ops, ops.registerOperatorProxyMethodFactory(new OperatorProxyMethodFactory() { @Override public int getSort() { return -1; } @Override public @Nullable MethodInvoker get( BeanOperations beanOperations, Method method, BeanOperationExecutor beanOperationExecutor) { processed.set(true); return null; } }) ); ops.createOperatorProxy(TestOperatorProxy.class); Assert."<AssertPlaceHolder>"; }
createOperatorProxy(@NonNull Class<T> operator) { return operatorProxyFactory.get(operator); }
[*] target: assertTrue(processed.get())
[-] pred: org. junit. Assert. assertTrue ( processed. get ( ) )
************************************
************************************
[+] input: testInitNamespaceFromJvmNamespaceWithoutCloudParsing() { System.setProperty(SystemPropertyKeyConst.ANS_NAMESPACE, "ans"); String expect = "jvm_namespace"; System.setProperty(PropertyKeyConst.NAMESPACE, expect); final NacosClientProperties properties = NacosClientProperties.PROTOTYPE.derive(); properties.setProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, "false"); String ns = InitUtils.initNamespaceForNaming(properties); Assert."<AssertPlaceHolder>"; }
initNamespaceForNaming(NacosClientProperties properties) { String tmpNamespace = null;  String isUseCloudNamespaceParsing = properties.getProperty(PropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, properties.getProperty(SystemPropertyKeyConst.IS_USE_CLOUD_NAMESPACE_PARSING, String.valueOf(Constants.DEFAULT_USE_CLOUD_NAMESPACE_PARSING)));  if (Boolean.parseBoolean(isUseCloudNamespaceParsing)) {  tmpNamespace = TenantUtil.getUserTenantForAns(); LogUtils.NAMING_LOGGER.info("initializer namespace from ans.namespace attribute : {}", tmpNamespace);  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getProperty(PropertyKeyConst.SystemEnv.ALIBABA_ALIWARE_NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from ALIBABA_ALIWARE_NAMESPACE attribute :" + namespace); return namespace; }); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> { String namespace = properties.getPropertyFrom(SourceType.JVM, PropertyKeyConst.NAMESPACE); LogUtils.NAMING_LOGGER.info("initializer namespace from namespace attribute :" + namespace); return namespace; });  if (StringUtils.isEmpty(tmpNamespace)) { tmpNamespace = properties.getProperty(PropertyKeyConst.NAMESPACE); }  tmpNamespace = TemplateUtils.stringEmptyAndThenExecute(tmpNamespace, () -> UtilAndComs.DEFAULT_NAMESPACE_ID); return tmpNamespace; }
[*] target: assertEquals(expect, ns)
[-] pred: org. junit. Assert. assertEquals ( expect, ns )
************************************
************************************
[+] input: getConfigMeta_KeyExists_NotNull() { ConfigurationMeta configMeta = userConfigMetaService.getConfigMeta("odc.sqlexecute.default.mysqlAutoCommitMode"); Assert."<AssertPlaceHolder>"; }
getConfigMeta(String key) { ConfigurationMeta configurationMeta = keyToConfigMetaMap.get(key); if (configurationMeta == null) { throw new IllegalArgumentException("Invalid configuration key: " + key); } return configurationMeta; }
[*] target: assertNotNull(configMeta)
[-] pred: org. junit. Assert. assertNotNull ( configMeta )
************************************
************************************
[+] input: generate_tableMode_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) table_mode='abcd',parallel 12, noparallel"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); tableOptions.setTableMode("'abcd'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_hashPartitionWithPartitionElts_succeed() { StatementFactory<Partition> factory = new OraclePartitionFactory(getPartitionContext( "partition by hash(a,b) partitions 12 (" + "partition a.b@c," + "partition d id 14," + "partition id 15 tablespace tbs, " + "partition id 16 nocompress," + "partition id 17 tablespace tbs1 compress for oltp)")); Partition actual = factory.generate();  List<Expression> cols = Arrays.asList(new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")); HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); e1.setUserVariable("@c"); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); HashPartitionElement e3 = new HashPartitionElement(null); PartitionOptions options = new PartitionOptions(); options.setId(15); options.setTableSpace("tbs"); e3.setPartitionOptions(options); HashPartitionElement e4 = new HashPartitionElement(null); PartitionOptions options1 = new PartitionOptions(); options1.setId(16); options1.setNoCompress(true); e4.setPartitionOptions(options1); HashPartitionElement e5 = new HashPartitionElement(null); PartitionOptions options2 = new PartitionOptions(); options2.setId(17); options2.setCompress("for oltp"); options2.setTableSpace("tbs1"); e5.setPartitionOptions(options2); HashPartition expect = new HashPartition(cols, Arrays.asList(e1, e2, e3, e4, e5), null, 12); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_hashPartitionWithSubPartitionOptionsQuantity_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getPartitionContext( "partition by hash(a) subpartition by hash(c) subpartitions 165 partitions 12 (" + "partition a.b (" + "subpartition a," + "subpartition b engine=InnoDB)," + "partition d id 14)")); Partition actual = factory.generate();  HashPartitionElement e1 = new HashPartitionElement("b"); e1.setSchema("a"); SubHashPartitionElement se1 = new SubHashPartitionElement("a"); SubHashPartitionElement se2 = new SubHashPartitionElement("b"); PartitionOptions o2 = new PartitionOptions(); o2.setEngine("InnoDB"); se2.setPartitionOptions(o2); e1.setSubPartitionElements(Arrays.asList(se1, se2)); HashPartitionElement e2 = new HashPartitionElement("d"); PartitionOptions o1 = new PartitionOptions(); o1.setId(14); e2.setPartitionOptions(o1); SubPartitionOption subPartitionOption = new SubPartitionOption( Collections.singletonList(new ColumnReference(null, null, "c")), "hash"); subPartitionOption.setSubPartitionNum(165); HashPartition expect = new HashPartition(Collections.singletonList( new ColumnReference(null, null, "a")), Arrays.asList(e1, e2), subPartitionOption, 12); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_createIndex_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_tableMode_succeed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) table_mode='abcd',parallel 12, noparallel"); StatementFactory<CreateTable> factory = new MySQLCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); tableOptions.setParallel(12); tableOptions.setNoParallel(true); tableOptions.setTableMode("'abcd'"); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldInstantiateAndConfigureExplicitlySetHeaderConverterWithCurrentClassLoader() { assertNotNull(props.get(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG)); HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNotNull(headerConverter); assertInstanceOf(TestHeaderConverter.class, headerConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config"));  headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertInstanceOf(TestHeaderConverter.class, headerConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config")); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { Class<? extends HeaderConverter> klass = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) klass = pluginClassFromConfig(config, classPropertyName, HeaderConverter.class, scanResult.headerConverters()); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(scanResult.headerConverters()) ); } } if (klass == null) { throw new ConnectException("Unable to initialize the HeaderConverter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration keys:{}{}", System.lineSeparator(), converterConfig.keySet());  HeaderConverter plugin; try (LoaderSwap loaderSwap = withClassLoader(klass.getClassLoader())) { plugin = newPlugin(klass); plugin.configure(converterConfig); } return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: generate_uniqueListaggExprListWithWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext( "LISTAGG(unique 5,6 order by col1 asc SEPARATOR 'mmm') over (name_ob partition by (1,2) order by col desc rows between " + "current row and interval 123 day FOLLOWING)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); FunctionParam ppp = new ExpressionParam(new ConstExpression("6")); params.add(ppp); FunctionCall expect = new FunctionCall("LISTAGG", params); expect.addOption(new ConstExpression("unique")); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); WindowOffset begin = new WindowOffset(WindowOffsetType.CURRENT_ROW); WindowOffset end = new WindowOffset(WindowOffsetType.FOLLOWING); end.setInterval(new IntervalExpression(new ConstExpression("123"), "day")); WindowBody body = new WindowBody(WindowType.ROWS, begin, end); window.setBody(body); expect.setWindow(window); SortKey s0 = new SortKey(new ColumnReference(null, null, "col1"), SortDirection.ASC); expect.addOption(new OrderBy(Collections.singletonList(s0))); expect.addOption(new ConstExpression("SEPARATOR 'mmm'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testFindMapper() { testJoin(); MapperManager instance = MapperManager.instance(false); Mapper mapper = instance.findMapper(DataSourceConstant.MYSQL, "test"); Assert."<AssertPlaceHolder>"; }
findMapper(String dataSource, String tableName) { if (LOGGER.isDebugEnabled()) { LOGGER.debug("[MapperManager] findMapper dataSource: {}, tableName: {}", dataSource, tableName); } if (StringUtils.isBlank(dataSource) || StringUtils.isBlank(tableName)) { throw new NacosRuntimeException(FIND_DATASOURCE_ERROR_CODE, "dataSource or tableName is null"); } Map<String, Mapper> tableMapper = MAPPER_SPI_MAP.get(dataSource); if (Objects.isNull(tableMapper)) { throw new NacosRuntimeException(FIND_DATASOURCE_ERROR_CODE, "[MapperManager] Failed to find the datasource,dataSource:" + dataSource); } Mapper mapper = tableMapper.get(tableName); if (Objects.isNull(mapper)) { throw new NacosRuntimeException(FIND_TABLE_ERROR_CODE, "[MapperManager] Failed to find the table ,tableName:" + tableName); } if (dataSourceLogEnable) { return MapperProxy.createSingleProxy(mapper); } return (R) mapper; }
[*] target: assertNotNull(mapper)
[-] pred: org. junit. Assert. assertNotNull ( mapper )
************************************
************************************
[+] input: generate_updateWithWhereClause_generateSucceed() { Update_stmtContext context = getUpdateContext("update tab set col=1 where col=100"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, null, "col")), new ConstExpression("1"), false))); ColumnReference left = new ColumnReference(null, null, "col"); ConstExpression right = new ConstExpression("100"); expect.setWhere(new CompoundExpression(left, right, Operator.EQ)); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_convertUsingUtf8_generateFunctionCallSucceed() { ExprContext context = getExprContext("convert('123' using utf8)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionParam p = new ExpressionParam(new ConstExpression("'123'")); p.addOption(new ConstExpression("utf8")); params.add(p); FunctionCall expect = new FunctionCall("convert", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: InterruptedException { // make sure the first no delay refresh thread finished. TimeUnit.MILLISECONDS.sleep(500); FailoverSwitch mockFailoverSwitch = new FailoverSwitch(true); when(failoverDataSource.getSwitch()).thenReturn(mockFailoverSwitch); Map<String, FailoverData> map = new HashMap<>(); ServiceInfo serviceInfo = new ServiceInfo("a@@b"); map.put("a@@b", NamingFailoverData.newNamingFailoverData(serviceInfo)); when(failoverDataSource.getFailoverData()).thenReturn(map); when(holder.isChangedServiceInfo(any(), any())).thenReturn(true); // waiting refresh thread work TimeUnit.MILLISECONDS.sleep(5500); ServiceInfo actual = failoverReactor.getService("a@@b"); "<AssertPlaceHolder>"; }
getService(String key) { ServiceInfo serviceInfo = serviceMap.get(key);  if (serviceInfo == null) { serviceInfo = new ServiceInfo(); serviceInfo.setName(key); }  return serviceInfo; }
[*] target: assertEquals(serviceInfo, actual)
[-] pred: org. junit. Assert. assertEquals ( serviceInfo, actual )
************************************
************************************
[+] input: testGetByteN() { byte src = 120; byte dest = 0; for (int i = 0; i < 64; i++) { int a = BytesUtils.getByteN(src, i); dest = BytesUtils.setByteN(dest, i, a); } "<AssertPlaceHolder>"; }
setByteN(byte data, int offset, int value) { offset %= 8; if (value == 1) { return (byte) ((0xff & data) | (1 << (7 - offset))); } else { return (byte) ((0xff & data) & ~(1 << (7 - offset))); } }
[*] target: assertEquals(src, dest)
[-] pred: org. junit. Assert. assertEquals ( src, dest )
************************************
************************************
[+] input: Exception { setTempEnvVars(Map.of("VALUE1", "value$1", "VALUE2", "2", "VALUE3", "value-_/!"\'3!§%&/()=?`*,;.:[]|{}"));  final String testString = "<test1><test2 id="VALUE1"><test3>${ENV:VALUE1}</test3><test4>${ENV:VALUE2}</test4><test5>${ENV:VALUE3}</test5></test2></test1>";  final String result = EnvVarUtil.replaceEnvironmentVariablePlaceholders(testString);  final String expected = "<test1><test2 id="VALUE1"><test3>value$1</test3><test4>2</test4><test5>value-_/!"\'3!§%&/()=?`*,;.:[]|{}</test5></test2></test1>";  "<AssertPlaceHolder>"; }
replaceEnvironmentVariablePlaceholders(final @NotNull String text) {  final StringBuffer resultString = new StringBuffer();  final Matcher matcher = Pattern.compile(ENV_VAR_PATTERN) .matcher(text);  while (matcher.find()) {  if (matcher.groupCount() < 1) { //this should never happen as we declared 1 groups in the ENV_VAR_PATTERN log.warn("Found unexpected environment variable placeholder in config.xml"); matcher.appendReplacement(resultString, ""); continue; }  final String varName = matcher.group(1);  final String replacement = getValue(varName);  if (replacement == null) { log.error("Environment Variable {} for HiveMQ config.xml is not set.", varName); throw new UnrecoverableException(false); }  //sets replacement for this match matcher.appendReplacement(resultString, escapeReplacement(replacement));  }  //adds everything except the replacements to the string buffer matcher.appendTail(resultString);  return resultString.toString(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: Exception { //given NacosRestTemplate nacosRestTemplate = mock(NacosRestTemplate.class); HttpRestResult<Object> result = new HttpRestResult<>(); result.setData("{"accessToken":"ttttttttttttttttt","tokenTtl":1000}"); result.setCode(200); when(nacosRestTemplate.postForm(any(), (Header) any(), any(), any(), any())).thenReturn(result); Properties properties = new Properties(); properties.setProperty(PropertyKeyConst.USERNAME, "aaa"); properties.setProperty(PropertyKeyConst.PASSWORD, "123456"); List<String> serverList = new ArrayList<>(); serverList.add("localhost");  NacosClientAuthServiceImpl nacosClientAuthService = new NacosClientAuthServiceImpl(); nacosClientAuthService.setServerList(serverList); nacosClientAuthService.setNacosRestTemplate(nacosRestTemplate); //when nacosClientAuthService.login(properties); //then boolean ret = nacosClientAuthService.login(properties); Assert."<AssertPlaceHolder>";  }
login(Properties properties) { try { if ((System.currentTimeMillis() - lastRefreshTime) < TimeUnit.SECONDS .toMillis(tokenTtl - tokenRefreshWindow)) { return true; }  if (StringUtils.isBlank(properties.getProperty(PropertyKeyConst.USERNAME))) { lastRefreshTime = System.currentTimeMillis(); return true; }  for (String server : this.serverList) { HttpLoginProcessor httpLoginProcessor = new HttpLoginProcessor(nacosRestTemplate); properties.setProperty(NacosAuthLoginConstant.SERVER, server); LoginIdentityContext identityContext = httpLoginProcessor.getResponse(properties); if (identityContext != null) { if (identityContext.getAllKey().contains(NacosAuthLoginConstant.ACCESSTOKEN)) { tokenTtl = Long.parseLong(identityContext.getParameter(NacosAuthLoginConstant.TOKENTTL)); tokenRefreshWindow = tokenTtl / 10; lastRefreshTime = System.currentTimeMillis();  loginIdentityContext = new LoginIdentityContext(); loginIdentityContext.setParameter(NacosAuthLoginConstant.ACCESSTOKEN, identityContext.getParameter(NacosAuthLoginConstant.ACCESSTOKEN)); } return true; } } } catch (Throwable throwable) { SECURITY_LOGGER.warn("[SecurityProxy] login failed, error: ", throwable); return false; } return false; }
[*] target: assertTrue(ret)
[-] pred: org. junit. Assert. assertTrue ( ret )
************************************
************************************
[+] input: generate_distinctExprListWithoutWinBody_generateSucceed() { Bit_exprContext context = getBitExprContext("count(distinct 5,6) over (name_ob partition by (1,2) order by col desc)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("5"))); params.add(new ExpressionParam(new ConstExpression("6"))); FunctionCall expect = new FunctionCall("count", params); WindowSpec window = new WindowSpec(); window.setName("name_ob"); CollectionExpression p = new CollectionExpression(); p.addExpression(new ConstExpression("1")); p.addExpression(new ConstExpression("2")); window.setPartitionBy(Collections.singletonList(p)); SortKey s = new SortKey(new ColumnReference(null, null, "col"), SortDirection.DESC); OrderBy orderBy = new OrderBy(Collections.singletonList(s)); window.setOrderBy(orderBy); expect.setWindow(window); expect.addOption(new ConstExpression("distinct")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_columnProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select col from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new ColumnReference(null, null, "col"), null); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_sys_interval_func_check_generateFunctionCallSucceed() { ExprContext context = getExprContext("CHECK(12)"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("12"))); FunctionCall expect = new FunctionCall("CHECK", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: convert_xmlToJson() { String xml = "<bookstore><book><author>odc</author><price>99.99</price><title>oceanbase</title></book></bookstore>"; String excepted = "{"bookstore":{"book":{"author":"odc","price":99.99,"title":"oceanbase"}}}"; String json = JsonUtils.xmlToJson(xml); Assert."<AssertPlaceHolder>"; }
xmlToJson(String xml) { if (StringUtils.isBlank(xml)) { return xml; } try { return XML.toJSONObject(xml).toString(); } catch (Exception e) { log.error("failed to convert json to xml string, reason:{}", e.getMessage()); return null; } }
[*] target: assertEquals(excepted, json)
[-] pred: org. junit. Assert. assertEquals ( excepted, json )
************************************
************************************
[+] input: generate_modifyPKWithOptions_succeed() { StatementFactory<AlterTableAction> factory = new OracleAlterTableActionFactory( getActionContext("modify primary key(id) global")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); List<SortColumn> columns = Collections.singletonList(new SortColumn(new ColumnReference(null, null, "id"))); ConstraintState state = new ConstraintState(); IndexOptions options = new IndexOptions(); options.setGlobal(true); state.setIndexOptions(options); OutOfLineConstraint pk = new OutOfLineConstraint(state, columns); pk.setPrimaryKey(true); expect.setModifyPrimaryKey(pk); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_commitOption_generateSucceed() { Create_table_stmtContext context = getCreateTableContext("create table abcd (id varchar(64)) on commit delete rows"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); expect.setCommitOption("delete"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_xmlParse_generateSucceed() { ExprContext context = getExprContext("xmlparse(document 'aaa')"); StatementFactory<Expression> factory = new OracleExpressionFactory(context); Expression actual = factory.generate();  FunctionCall expect = new FunctionCall("xmlparse", Collections.singletonList(new ExpressionParam(new ConstExpression("'aaa'")))); expect.addOption(new ConstExpression("document")); Assert."<AssertPlaceHolder>"; }
generate() { return this.parserRuleContext == null ? null : visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_indexHash_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("index idx_name using hash (col, col1) local block_size=30")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); OutOfLineIndex expect = new OutOfLineIndex("idx_name", Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingHash(true); indexOptions.setGlobal(false); indexOptions.setBlockSize(30); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_withColumnGroup_allColumns_succeed() { Create_table_stmtContext ctx = getCreateTableContext( "create table column_group_tbl (id varchar(64)) with column group(all columns)"); MySQLCreateTableFactory factory = new MySQLCreateTableFactory(ctx); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("column_group_tbl"); expect.setColumnGroupElements(Collections.singletonList(new ColumnGroupElement(true, false))); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_createIndexWithColumnGroup_allColumns_eachColumn_succeed() { StatementFactory<CreateIndex> factory = new MySQLCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(all columns, each column)")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new ColumnReference(null, null, "col")), new SortColumn(new ColumnReference(null, null, "col1")))); expect.setColumnGroupElements( Arrays.asList(new ColumnGroupElement(true, false), new ColumnGroupElement(false, true))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testCollidingPrunedAlias() { SortedSet<PluginDesc<Converter>> converters = new TreeSet<>(); converters.add(new PluginDesc<>(CollidingConverter.class, null, PluginType.CONVERTER, CollidingConverter.class.getClassLoader())); SortedSet<PluginDesc<HeaderConverter>> headerConverters = new TreeSet<>(); headerConverters.add(new PluginDesc<>(CollidingHeaderConverter.class, null, PluginType.HEADER_CONVERTER, CollidingHeaderConverter.class.getClassLoader())); PluginScanResult result = new PluginScanResult( Collections.emptySortedSet(), Collections.emptySortedSet(), converters, headerConverters, Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet(), Collections.emptySortedSet() ); Map<String, String> actualAliases = PluginUtils.computeAliases(result); Map<String, String> expectedAliases = new HashMap<>(); expectedAliases.put("CollidingConverter", CollidingConverter.class.getName()); expectedAliases.put("CollidingHeaderConverter", CollidingHeaderConverter.class.getName()); "<AssertPlaceHolder>"; }
computeAliases(PluginScanResult scanResult) { Map<String, Set<String>> aliasCollisions = new HashMap<>(); scanResult.forEach(pluginDesc -> { aliasCollisions.computeIfAbsent(simpleName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); aliasCollisions.computeIfAbsent(prunedName(pluginDesc), ignored -> new HashSet<>()).add(pluginDesc.className()); }); Map<String, String> aliases = new HashMap<>(); for (Map.Entry<String, Set<String>> entry : aliasCollisions.entrySet()) { String alias = entry.getKey(); Set<String> classNames = entry.getValue(); if (classNames.size() == 1) { aliases.put(alias, classNames.stream().findAny().get()); } else { log.debug("Ignoring ambiguous alias '{}' since it refers to multiple distinct plugins {}", alias, classNames); } } return aliases; }
[*] target: assertEquals(expectedAliases, actualAliases)
[-] pred: org. junit. Assert. assertEquals ( expectedAliases, actualAliases )
************************************
************************************
[+] input: isODPSharding_ODP_SHARDING_OB_ORACLE_ReturnTrue() { boolean isODPSharding = ConnectType.ODP_SHARDING_OB_ORACLE.isODPSharding(); Assert."<AssertPlaceHolder>"; }
isODPSharding() { return this == ODP_SHARDING_OB_MYSQL || this == ODP_SHARDING_OB_ORACLE; }
[*] target: assertTrue(isODPSharding)
[-] pred: org. junit. Assert. assertTrue ( isODPSharding )
************************************
************************************
[+] input: getDatabase_Success() { DBDatabase database = accessor.getDatabase(getOracleSchema()); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(database.getId()); Assert.assertNotNull(database.getCharset()); Assert.assertNotNull(database.getCollation()); Assert.assertEquals(getOracleSchema(), database.getName()); }
getDatabase(String schemaName) { DBDatabase database = new DBDatabase(); String sql = this.sqlMapper.getSql(Statements.GET_DATABASE); jdbcOperations.query(sql, new Object[] {schemaName}, rs -> { database.setId(rs.getString(2)); database.setName(rs.getString(1)); }); try { sql = "select value from v$nls_parameters where PARAMETER = 'NLS_CHARACTERSET'"; jdbcOperations.query(sql, rs -> { database.setCharset(rs.getString(1)); }); sql = "SELECT value from v$nls_parameters where parameter = 'NLS_SORT'"; jdbcOperations.query(sql, rs -> { database.setCollation(rs.getString(1)); }); } catch (Exception e) { log.warn("Failed to get oracle charset and collation, error message:{}", e.getMessage()); sql = "select value from v_$nls_parameters where PARAMETER = 'NLS_CHARACTERSET'"; jdbcOperations.query(sql, rs -> { database.setCharset(rs.getString(1)); }); sql = "SELECT value from v_$nls_parameters where parameter = 'NLS_SORT'"; jdbcOperations.query(sql, rs -> { database.setCollation(rs.getString(1)); }); } return database; }
[*] target: assertNotNull(database)
[-] pred: org. junit. Assert. assertNotNull ( database )
************************************
************************************
[+] input: generate_withColumnGroup_customGroup_succeed() { StatementFactory<CreateIndex> factory = new OracleCreateIndexFactory( getCreateIdxContext("create index abc on tb (col, col1) with column group(g1(col), g2(col, col1))")); CreateIndex actual = factory.generate();  CreateIndex expect = new CreateIndex(new RelationFactor("abc"), new RelationFactor("tb"), Arrays.asList( new SortColumn(new RelationReference("col", null)), new SortColumn(new RelationReference("col1", null)))); List<ColumnGroupElement> columnGroupElements = Arrays.asList( new ColumnGroupElement("g1", Collections.singletonList("col")), new ColumnGroupElement("g2", Arrays.asList("col", "col1"))); expect.setColumnGroupElements(columnGroupElements); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createIndexStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_cur_date_func_generateFunctionCallSucceed() { ExprContext context = getExprContext("CURRENT_DATE()"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); FunctionCall expect = new FunctionCall("CURRENT_DATE", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: testGetData() { ServiceInfo serviceInfo = serviceStorage.getData(SERVICE);  Assert."<AssertPlaceHolder>"; }
getData(Service service) { return serviceDataIndexes.containsKey(service) ? serviceDataIndexes.get(service) : getPushData(service); }
[*] target: assertNotNull(serviceInfo)
[-] pred: org. junit. Assert. assertNotNull ( serviceInfo )
************************************
************************************
[+] input: generate_updateWithOrderByAndLimit_generateSucceed() { Update_stmtContext context = getUpdateContext( "update tab set tab.col=1 order by chz.tab.col limit 4"); StatementFactory<Update> factory = new MySQLUpdateFactory(context); Update actual = factory.generate();  FromReference tableReference = new NameReference(null, "tab", null); Update expect = new Update(Arrays.asList(tableReference), Arrays.asList(new UpdateAssign( Arrays.asList(new ColumnReference(null, "tab", "col")), new ConstExpression("1"), false))); SortKey s1 = new SortKey(new ColumnReference("chz", "tab", "col"), null); expect.setLimit(new Limit(new ConstExpression("4"))); expect.setOrderBy(new OrderBy(Arrays.asList(s1))); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.updateStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: shouldNotReturnKeyValueStoreAsTimestampedStore() { final GlobalStateStoreProvider provider = new GlobalStateStoreProvider(stores); final List<ReadOnlyKeyValueStore<String, ValueAndTimestamp<String>>> stores = provider.stores("kv-store", QueryableStoreTypes.timestampedKeyValueStore()); "<AssertPlaceHolder>"; }
stores(final String storeName, final QueryableStoreType<T> queryableStoreType) { final StateStore store = globalStateStores.get(storeName); if (store == null || !queryableStoreType.accepts(store)) { return Collections.emptyList(); } if (!store.isOpen()) { throw new InvalidStateStoreException("the state store, " + storeName + ", is not open."); } if (store instanceof TimestampedKeyValueStore && queryableStoreType instanceof QueryableStoreTypes.KeyValueStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyKeyValueStoreFacade((TimestampedKeyValueStore<Object, Object>) store)); } else if (store instanceof TimestampedWindowStore && queryableStoreType instanceof QueryableStoreTypes.WindowStoreType) { return (List<T>) Collections.singletonList(new ReadOnlyWindowStoreFacade((TimestampedWindowStore<Object, Object>) store)); } return (List<T>) Collections.singletonList(store); }
[*] target: assertEquals(0, stores.size())
[-] pred: org. junit. Assert. assertEquals ( 0, stores. size ( ) )
************************************
************************************
[+] input: generate_indexPrimaryKey_succeed() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("primary key `aaaa` using hash (col, col1) comment 'abcd'")); TableElement actual = factory.generate();  SortColumn s1 = new SortColumn(new ColumnReference(null, null, "col")); SortColumn s2 = new SortColumn(new ColumnReference(null, null, "col1")); ConstraintState state = new ConstraintState(); IndexOptions indexOptions = new IndexOptions(); indexOptions.setUsingHash(true); indexOptions.setComment("'abcd'"); state.setIndexOptions(indexOptions); OutOfLineConstraint expect = new OutOfLineConstraint(state, Arrays.asList(s1, s2)); expect.setPrimaryKey(true); expect.setIndexName("`aaaa`"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_formatTableOp_succeed() { Create_table_stmtContext context = getCreateTableContext( "create table abcd (id varchar(64)) format=(ENCODING='aaaa',LINE_DELIMITER=123,SKIP_HEADER=12,EMPTY_FIELD_AS_NULL=true,NULL_IF_EXETERNAL=(1,2,3))"); StatementFactory<CreateTable> factory = new OracleCreateTableFactory(context); CreateTable actual = factory.generate();  CreateTable expect = new CreateTable("abcd"); DataType dataType = new CharacterType("varchar", new BigDecimal("64")); expect.setTableElements( Collections.singletonList(new ColumnDefinition(new ColumnReference(null, null, "id"), dataType))); TableOptions tableOptions = new TableOptions(); Map<String, Expression> map = new HashMap<>(); map.put("ENCODING", new ConstExpression("'aaaa'")); map.put("EMPTY_FIELD_AS_NULL", new BoolValue(true)); map.put("SKIP_HEADER", new ConstExpression("12")); CollectionExpression es = new CollectionExpression(); es.addExpression(new ConstExpression("1")); es.addExpression(new ConstExpression("2")); es.addExpression(new ConstExpression("3")); map.put("NULL_IF_EXETERNAL", es); map.put("LINE_DELIMITER", new ConstExpression("123")); tableOptions.setFormat(map); expect.setTableOptions(tableOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.createTableStmtContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: verifyingTopicCleanupPolicyShouldReturnFalseWhenClusterAuthorizationError() { final NewTopic newTopic = TopicAdmin.defineTopic("myTopic").partitions(1).compacted().build(); Cluster cluster = createCluster(1); try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) { env.kafkaClient().prepareResponse(describeConfigsResponseWithClusterAuthorizationException(newTopic)); TopicAdmin admin = new TopicAdmin(env.adminClient()); boolean result = admin.verifyTopicCleanupPolicyOnlyCompact("myTopic", "worker.topic", "purpose"); "<AssertPlaceHolder>"; } }
verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig, String topicPurpose) { Set<String> cleanupPolicies = topicCleanupPolicy(topic); if (cleanupPolicies.isEmpty()) { log.info("Unable to use admin client to verify the cleanup policy of '{}' " + "topic is '{}', either because the broker is an older " + "version or because the Kafka principal used for Connect " + "internal topics does not have the required permission to " + "describe topic configurations.", topic, TopicConfig.CLEANUP_POLICY_COMPACT); return false; } Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT); if (!cleanupPolicies.equals(expectedPolicies)) { String expectedPolicyStr = String.join(",", expectedPolicies); String cleanupPolicyStr = String.join(",", cleanupPolicies); String msg = String.format("Topic '%s' supplied via the '%s' property is required " + "to have '%s=%s' to guarantee consistency and durability of " + "%s, but found the topic currently has '%s=%s'. Continuing would likely " + "result in eventually losing %s and problems restarting this Connect " + "cluster in the future. Change the '%s' property in the " + "Connect worker configurations to use a topic with '%s=%s'.", topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr, topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr); throw new ConfigException(msg); } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testListDeserialize() { Schema schema = new Schema(optional(1, "list_type", Types.ListType.ofOptional(2, Types.LongType.get())));  StructObjectInspector inspector = ObjectInspectorFactory.getStandardStructObjectInspector( Arrays.asList("list_type"), Arrays.asList( ObjectInspectorFactory.getStandardListObjectInspector( PrimitiveObjectInspectorFactory.writableLongObjectInspector)));  Deserializer deserializer = new Deserializer.Builder() .schema(schema) .writerInspector((StructObjectInspector) IcebergObjectInspector.create(schema)) .sourceInspector(inspector) .build();  Record expected = GenericRecord.create(schema); expected.set(0, Collections.singletonList(1L));  Object[] data = new Object[] {new Object[] {new LongWritable(1L)}}; Record actual = deserializer.deserialize(data);  Assert."<AssertPlaceHolder>"; }
deserialize(Object data) { return (Record) fieldDeserializer.value(data); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: getResource_whenClazzIsNull_thenResourceIsNull() { final URL resource = ManifestUtils.getResource(null, "path"); "<AssertPlaceHolder>"; }
getResource(final Class clazz, final String resourcePath) {  try {  if (clazz == null || resourcePath == null) { return null; }  final ClassLoader cl = clazz.getClassLoader(); final Enumeration<URL> resources = cl.getResources(resourcePath); final List<URL> urls = new ArrayList<>(); // There could be multiple jar file (windows service for example) while (resources.hasMoreElements()) { urls.add(resources.nextElement()); } if (urls.isEmpty()) { // There is no Resource return null; } URL url = null; if (urls.size() == 1) { // There is only one jar file url = urls.get(0); } else { for (final URL currentUrl : urls) { if (currentUrl.getPath().contains("hivemq.jar")) { // If there are multiple jar files, we pick the one that contains the substring "hivemq.jar" url = currentUrl; break; } } if (url == null) { // If non of the urls contains the substring "hivemq.jar" we return the first one url = urls.get(0); } }  return url; } catch (final IOException e) { log.warn("Could not read resource " + resourcePath); log.debug("Original exception: ", e); return null; } }
[*] target: assertNull(resource)
[-] pred: org. junit. Assert. assertNull ( resource )
************************************
************************************
[+] input: generate_dropConstraint_succeed() { StatementFactory<AlterTableAction> factory = new MySQLAlterTableActionFactory( getActionContext("drop constraint abcd")); AlterTableAction actual = factory.generate();  AlterTableAction expect = new AlterTableAction(); expect.setDropConstraintNames(Collections.singletonList("abcd")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_columnDefOnUpdate_generateSuccees() { StatementFactory<TableElement> factory = new MySQLTableElementFactory( getTableElementContext("tb.col varchar(64) on update current_timestamp(1)")); ColumnDefinition actual = (ColumnDefinition) factory.generate();  DataType dataType = new CharacterType("varchar", new BigDecimal("64")); ColumnDefinition expect = new ColumnDefinition(new ColumnReference(null, "tb", "col"), dataType); ColumnAttributes attributes = new ColumnAttributes(); FunctionCall expr = new FunctionCall("current_timestamp", Collections.singletonList(new ExpressionParam(new ConstExpression("1")))); attributes.setOnUpdate(expr); expect.setColumnAttributes(attributes); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: copy_noChanges() { final WillPublishPacketImpl packet = new WillPublishPacketImpl( "topic", Qos.AT_LEAST_ONCE, ByteBuffer.wrap("payload".getBytes()), false, 60, null, null, null, null, UserPropertiesImpl.of(ImmutableList.of()), 0, 1234L); final ModifiableWillPublishImpl modifiablePacket = new ModifiableWillPublishImpl(packet, configurationService);  final PublishPacketImpl copy = modifiablePacket.copy();  "<AssertPlaceHolder>"; }
copy() { return new WillPublishPacketImpl(topic, qos, payload, retain, messageExpiryInterval, payloadFormatIndicator, contentType, responseTopic, correlationData, userProperties.copy(), willDelay, timestamp); }
[*] target: assertEquals(packet, copy)
[-] pred: org. junit. Assert. assertEquals ( packet, copy )
************************************
************************************
[+] input: Exception { q = new FIFORevQueue(AbstractRevQueue.EMPTY_QUEUE); "<AssertPlaceHolder>"; }
next() { final Block b = head; if (b == null) return null;  final RevCommit c = b.pop(); if (b.isEmpty()) { head = b.next; if (head == null) tail = null; free.freeBlock(b); } return c; }
[*] target: assertNull(q.next())
[-] pred: org. junit. Assert. assertNull ( q. next() )
************************************
************************************
[+] input: validNotSqlInjection_NotInjection_ReturnTrue() { boolean isNotInjection = PreConditions.validNotSqlInjection("oms_cluster", "cluster"); Assert."<AssertPlaceHolder>"; }
validNotSqlInjection(String param, String paramName) { if (StringUtils.isEmpty(param)) { return true; } String message = String.format("%s may contain invalid characters", paramName); if (SqlInjectionDetector.isSqlInjection(param)) { throw new BadArgumentException(ErrorCodes.BadArgument, new Object[] {message}, message); } return true; }
[*] target: assertTrue(isNotInjection)
[-] pred: org. junit. Assert. assertTrue ( isNotInjection )
************************************
************************************
[+] input: generate_autoPartition_succeed() { StatementFactory<Partition> factory = new MySQLPartitionFactory(getAutoPartitionContext( "partition by range columns(a,b) partition size 'auto' PARTITIONS AUTO")); Partition actual = factory.generate();  RangePartition expect = new RangePartition(Arrays.asList( new ColumnReference(null, null, "a"), new ColumnReference(null, null, "b")), null, null, null, true); expect.setAuto(true); expect.setPartitionSize(new ConstExpression("'auto'")); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_columnProjectionWithAsLabel_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select chz.tab.col as label from tab"); StatementFactory<Projection> factory = new MySQLProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(new ColumnReference("chz", "tab", "col"), "label"); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_starProjection_generateProjectionSucceed() { ProjectionContext context = getProjectionContext("select * from dual"); StatementFactory<Projection> factory = new OracleProjectionFactory(context); Projection actual = factory.generate();  Projection expect = new Projection(); Assert."<AssertPlaceHolder>"; }
generate() { return visitProjection(projectionContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: generate_indexColumnAscNullsLast_succeed() { StatementFactory<TableElement> factory = new OracleTableElementFactory( getTableElementContext( "index (col asc nulls last id 15, col1) initrans 13 maxtrans 14 storage(next 10 initial 13)")); OutOfLineIndex actual = (OutOfLineIndex) factory.generate();  SortColumn s1 = new SortColumn(new RelationReference("col", null)); s1.setId(15); s1.setDirection(SortDirection.ASC); s1.setNullPosition(SortNullPosition.LAST); SortColumn s2 = new SortColumn(new RelationReference("col1", null)); OutOfLineIndex expect = new OutOfLineIndex(null, Arrays.asList(s1, s2)); IndexOptions indexOptions = new IndexOptions(); indexOptions.setIniTrans(13); indexOptions.setMaxTrans(14); indexOptions.setStorage(Arrays.asList("next 10", "initial 13")); expect.setIndexOptions(indexOptions); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************
[+] input: buildRequest_ReturnNotNull() { HttpUriRequest request = accountClient.buildRequest(TOKEN); Assert."<AssertPlaceHolder>"; }
buildRequest(String token) { HttpProperties httpProperties = httpProperties(); QueryProperties queryProperties = queryProperties(); RequestConfig requestConfig = RequestConfig.custom() .setConnectionRequestTimeout(httpProperties.getConnectTimeoutSeconds() * 1000) .setConnectTimeout(httpProperties.getConnectTimeoutSeconds() * 1000) .setSocketTimeout(httpProperties.getReadTimeoutSeconds() * 1000).build();  Map<String, String> variables = buildVariables(token); Template template = new Template(variables);  // init request, url/headers/body support template variables RequestBuilder requestBuilder = RequestBuilder.create(queryProperties.getRequestMethod()) .setConfig(requestConfig);  // set request url String processedRequestUrl = template.process(queryProperties.getRequestUrl()); requestBuilder.setUri(processedRequestUrl);  // set request headers List<String> requestHeaders = queryProperties.getRequestHeaders(); if (CollectionUtils.isNotEmpty(requestHeaders)) { for (String header : requestHeaders) { String[] split = header.split("="); Verify.verify(split.length > 1, "Invalid header format, header=" + header); String name = split[0]; String value = split[1]; Verify.notBlank(name, "header.name"); Verify.notBlank(value, "header.value"); String processedHeaderValue = template.process(value); requestBuilder.addHeader(name, processedHeaderValue); } }  // set request body String requestBodyTemplate = queryProperties.getRequestBody(); if (StringUtils.isNotEmpty(requestBodyTemplate)) { String plainRequestBody = template.process(requestBodyTemplate); String encryptedRequestBody = encryptRequest(plainRequestBody); log.debug("Build request, plainRequestBody={}, encryptedRequestBody={}", plainRequestBody, encryptedRequestBody); HttpEntity httpEntity = EntityBuilder.create() .setText(encryptedRequestBody) .build(); requestBuilder.setEntity(httpEntity); } return requestBuilder.build(); }
[*] target: assertNotNull(request)
[-] pred: org. junit. Assert. assertNotNull ( request )
************************************
************************************
[+] input: shouldMatchPositionAfterPut() { bytesStore.init((StateStoreContext) context, bytesStore);  final String keyA = "a"; final String keyB = "b"; final String keyC = "c";  context.setRecordContext(new ProcessorRecordContext(0, 1, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyA, windows[0])), serializeValue(10)); context.setRecordContext(new ProcessorRecordContext(0, 2, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyA, windows[1])), serializeValue(50)); context.setRecordContext(new ProcessorRecordContext(0, 3, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyB, windows[2])), serializeValue(100)); context.setRecordContext(new ProcessorRecordContext(0, 4, 0, "", new RecordHeaders())); bytesStore.put(serializeKey(new Windowed<>(keyC, windows[3])), serializeValue(200));  final Position expected = Position.fromMap(mkMap(mkEntry("", mkMap(mkEntry(0, 4L))))); final Position actual = bytesStore.getPosition(); "<AssertPlaceHolder>"; }
getPosition() { return position; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: generate_timestampDiff_generateFunctionCallSucceed() { ExprContext context = getExprContext("TIMESTAMPDIFF(DAY, tab,'12')"); StatementFactory<Expression> factory = new MySQLExpressionFactory(context); Expression actual = factory.generate();  List<FunctionParam> params = new ArrayList<>(); params.add(new ExpressionParam(new ConstExpression("DAY"))); params.add(new ExpressionParam(new ColumnReference(null, null, "tab"))); params.add(new ExpressionParam(new ConstExpression("'12'"))); FunctionCall expect = new FunctionCall("TIMESTAMPDIFF", params); Assert."<AssertPlaceHolder>"; }
generate() { return visit(this.parserRuleContext); }
[*] target: assertEquals(expect, actual)
[-] pred: org. junit. Assert. assertEquals ( expect, actual )
************************************
************************************

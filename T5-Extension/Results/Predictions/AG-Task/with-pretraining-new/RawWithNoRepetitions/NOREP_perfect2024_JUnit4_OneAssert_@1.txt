[+] input: Exception { Controlador controlador = new Controlador(); ArrayList<Character> elements = new ArrayList<>(); elements.add('1'); elements.add('2'); elements.add('+'); elements.add('4'); elements.add('*'); elements.add('3'); elements.add('+');  int result = controlador.solve(elements); "<AssertPlaceHolder>"; }
solve(ArrayList<Character> elements) throws Exception { return 0; }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 0, result )
************************************
************************************
[+] input: test34() { List<SolarTime> solarTimes = new EightChar("庚子", "戊子", "己卯", "庚午").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1901年1月1日 12:00:00"); expected.add("1960年12月17日 12:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test2() { LegalHoliday d = LegalHoliday.fromYmd(2010, 1, 1); Assert."<AssertPlaceHolder>"; }
fromYmd(int year, int month, int day) { Matcher matcher = Pattern.compile(String.format("%04d%02d%02d[0-1][0-8][\\+|-]\\d{2}", year, month, day)).matcher(DATA); return !matcher.find() ? null : new LegalHoliday(year, month, day, matcher.group()); }
[*] target: assertNotNull(d)
[-] pred: org. junit. Assert. assertNotNull ( d )
************************************
************************************
[+] input: test37() { List<SolarTime> solarTimes = new EightChar("甲辰", "丙寅", "己亥", "戊辰").getSolarTimes(1800, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1964年2月20日 08:00:00"); expected.add("2024年2月5日 08:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test41() { List<SolarTime> solarTimes = new EightChar("乙未", "己卯", "丁丑", "甲辰").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1955年3月17日 08:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test33() { List<SolarTime> solarTimes = new EightChar("己卯", "辛未", "甲戌", "壬申").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1939年8月5日 16:00:00"); expected.add("1999年7月21日 16:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test36() { List<SolarTime> solarTimes = new EightChar("癸卯", "甲寅", "甲寅", "甲子").getSolarTimes(1800, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1843年2月9日 00:00:00"); expected.add("2023年2月25日 00:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test38() { List<SolarTime> solarTimes = new EightChar("己亥", "丁丑", "壬寅", "戊申").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1900年1月29日 16:00:00"); expected.add("1960年1月15日 16:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test1() { LegalHoliday d = LegalHoliday.fromYmd(2010, 1, 1); Assert."<AssertPlaceHolder>"; }
fromYmd(int year, int month, int day) { Matcher matcher = Pattern.compile(String.format("%04d%02d%02d[0-1][0-8][\\+|-]\\d{2}", year, month, day)).matcher(DATA); return !matcher.find() ? null : new LegalHoliday(year, month, day, matcher.group()); }
[*] target: assertNotNull(d)
[-] pred: org. junit. Assert. assertNotNull ( d )
************************************
************************************
[+] input: test31() { List<SolarTime> solarTimes = new EightChar("丙辰", "丁酉", "丙子", "甲午").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1916年10月6日 12:00:00"); expected.add("1976年9月21日 12:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test32() { List<SolarTime> solarTimes = new EightChar("壬寅", "庚戌", "己未", "乙亥").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("2022年11月2日 22:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test35() { List<SolarTime> solarTimes = new EightChar("庚子", "癸未", "乙丑", "丁亥").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1960年8月5日 22:00:00"); expected.add("2020年7月21日 22:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test39() { List<SolarTime> solarTimes = new EightChar("己亥", "丙子", "癸酉", "庚申").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1959年12月17日 16:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test40() { List<SolarTime> solarTimes = new EightChar("丁丑", "癸卯", "癸丑", "辛酉").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1937年3月27日 18:00:00"); expected.add("1997年3月12日 18:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************

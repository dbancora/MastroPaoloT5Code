[+] input: testAdd() { Controlador controlador = new Controlador(); int result = controlador.add(2, 3); "<AssertPlaceHolder>"; }
add(int n1, int n2) { int n5 = n1 + n2; return n5; }
[*] target: assertEquals(5, result)
[-] pred: org. junit. Assert. assertEquals ( 5, result )
************************************
************************************
[+] input: testSubstraction() { Controlador controlador = new Controlador(); int result = controlador.substraction(5, 3); "<AssertPlaceHolder>"; }
substraction(int n1, int n2) { int n5 = n1 - n2; return n5; }
[*] target: assertEquals(2, result)
[-] pred: org. junit. Assert. assertEquals ( 2, result )
************************************
************************************
[+] input: testMultiplication() { Controlador controlador = new Controlador(); int result = controlador.multiplication(2, 3); "<AssertPlaceHolder>"; }
multiplication(int n1, int n2) { int n5 = n1 * n2; return n5; }
[*] target: assertEquals(6, result)
[-] pred: org. junit. Assert. assertEquals ( 6, result )
************************************
************************************
[+] input: Exception { Controlador controlador = new Controlador(); int result = controlador.division(6, 3); "<AssertPlaceHolder>"; }
division(int n1, int n2) throws Exception { int n5 = n1 / n2; return n5; }
[*] target: assertEquals(2, result)
[-] pred: org. junit. Assert. assertEquals ( 2, result )
************************************
************************************
[+] input: Exception { Controlador controlador = new Controlador(); int result = controlador.residue(7, 3); "<AssertPlaceHolder>"; }
residue(int n1, int n2) throws Exception { return 0; }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 0, result )
************************************
************************************
[+] input: Exception { Controlador controlador = new Controlador(); ArrayList<Character> elements = new ArrayList<>(); elements.add('1'); elements.add('2'); elements.add('+'); elements.add('4'); elements.add('*'); elements.add('3'); elements.add('+');  int result = controlador.solve(elements); "<AssertPlaceHolder>"; }
solve(ArrayList<Character> elements) throws Exception { return 0; }
[*] target: assertEquals(0, result)
[-] pred: org. junit. Assert. assertEquals ( 0, result )
************************************
************************************
[+] input: testInsertAndRemove() { // Crear un comparador de prioridades Comparator<Integer> comparator = new ComparadorNumeros<>();  // Crear un heap utilizando el árbol binario iterativo HeapUsingIterativeBinaryTree<Integer, String> heap = new HeapUsingIterativeBinaryTree<>(comparator);  // Prueba Insert y remove con elementos heap.Insert(10, "A"); heap.Insert(20, "B"); heap.Insert(15, "C");  assertEquals(3, heap.count());  assertEquals("A", heap.remove()); assertEquals(2, heap.count());  assertEquals("C", heap.remove()); assertEquals(1, heap.count());  assertEquals("B", heap.remove()); "<AssertPlaceHolder>"; }
count() { return _count; }
[*] target: assertEquals(0, heap.count())
[-] pred: org. junit. Assert. assertEquals ( 0, heap. count() )
************************************
************************************
[+] input: test_adjustInstant_ReturnsSameInstant_WeekendModeDisabled() { SharedPreferences preferences = Mockito.mock(SharedPreferences.class); WeekendMode weekendMode = new WeekendMode(preferences); Instant instant = Instant.now();  Mockito.when(preferences.getBoolean(eq(WeekendModePreferencesFragment.WEEKEND_MODE), anyBoolean())).thenReturn(false);  Instant adjustedInstant = weekendMode.adjustInstant(instant);  "<AssertPlaceHolder>"; }
adjustInstant(Instant instant) { if (isWeekendModeEnabled()) { int weekendTime = preferences.getInt(WeekendModePreferencesFragment.WEEKEND_TIME, 540); Set<String> weekendDays = preferences.getStringSet(WeekendModePreferencesFragment.WEEKEND_DAYS, new ArraySet<>()); ZonedDateTime localDateTime = instant.atZone(ZoneId.systemDefault()); DayOfWeek dayOfWeek = localDateTime.getDayOfWeek(); int minutes = localDateTime.getMinute() + localDateTime.getHour() * 60; int deltaMinutes = weekendTime - minutes; if (weekendDays.contains(String.valueOf(dayOfWeek.getValue())) && deltaMinutes > 0) { instant = instant.plusSeconds(deltaMinutes * 60L); } } return instant; }
[*] target: assertEquals(instant, adjustedInstant)
[-] pred: org. junit. Assert. assertEquals ( instant, adjustedInstant )
************************************
************************************
[+] input: indexZero() { nonEmptyQueue.setIndex(0); assertEquals(0, nonEmptyQueue.getIndex());  doReturn(true).when(emptyQueue).isComplete(); emptyQueue.setIndex(0); assertEquals(0, emptyQueue.getIndex());  doReturn(false).when(emptyQueue).isComplete(); emptyQueue.setIndex(0); "<AssertPlaceHolder>"; }
getIndex() { return queueIndex.get(); }
[*] target: assertEquals(0, emptyQueue.getIndex())
[-] pred: org. junit. Assert. assertEquals ( 0, emptyQueue. getIndex() )
************************************
************************************
[+] input: test31() { List<SolarTime> solarTimes = new EightChar("丙辰", "丁酉", "丙子", "甲午").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1916年10月6日 12:00:00"); expected.add("1976年9月21日 12:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test32() { List<SolarTime> solarTimes = new EightChar("壬寅", "庚戌", "己未", "乙亥").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("2022年11月2日 22:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test33() { List<SolarTime> solarTimes = new EightChar("己卯", "辛未", "甲戌", "壬申").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1939年8月5日 16:00:00"); expected.add("1999年7月21日 16:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test34() { List<SolarTime> solarTimes = new EightChar("庚子", "戊子", "己卯", "庚午").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1901年1月1日 12:00:00"); expected.add("1960年12月17日 12:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test35() { List<SolarTime> solarTimes = new EightChar("庚子", "癸未", "乙丑", "丁亥").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1960年8月5日 22:00:00"); expected.add("2020年7月21日 22:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test36() { List<SolarTime> solarTimes = new EightChar("癸卯", "甲寅", "甲寅", "甲子").getSolarTimes(1800, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1843年2月9日 00:00:00"); expected.add("2023年2月25日 00:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test37() { List<SolarTime> solarTimes = new EightChar("甲辰", "丙寅", "己亥", "戊辰").getSolarTimes(1800, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1964年2月20日 08:00:00"); expected.add("2024年2月5日 08:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test38() { List<SolarTime> solarTimes = new EightChar("己亥", "丁丑", "壬寅", "戊申").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1900年1月29日 16:00:00"); expected.add("1960年1月15日 16:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test39() { List<SolarTime> solarTimes = new EightChar("己亥", "丙子", "癸酉", "庚申").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1959年12月17日 16:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test40() { List<SolarTime> solarTimes = new EightChar("丁丑", "癸卯", "癸丑", "辛酉").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1937年3月27日 18:00:00"); expected.add("1997年3月12日 18:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test41() { List<SolarTime> solarTimes = new EightChar("乙未", "己卯", "丁丑", "甲辰").getSolarTimes(1900, 2024); List<String> actual = new ArrayList<>(); for (SolarTime solarTime : solarTimes) { actual.add(solarTime.toString()); }  List<String> expected = new ArrayList<>(); expected.add("1955年3月17日 08:00:00"); Assert."<AssertPlaceHolder>"; }
getSolarTimes(int startYear, int endYear) { List<SolarTime> l = new ArrayList<>(); // 月地支距寅月的偏移值 int m = month.getEarthBranch().next(-2).getIndex(); // 月天干要一致 if (!HeavenStem.fromIndex((year.getHeavenStem().getIndex() + 1) * 2 + m).equals(month.getHeavenStem())) { return l; } // 1年的立春是辛酉，序号57 int y = year.next(-57).getIndex() + 1; // 节令偏移值 m *= 2; // 时辰地支转时刻，子时按零点算 int h = hour.getEarthBranch().getIndex() * 2; int baseYear = startYear - 1; while (y <= endYear) { if (y >= baseYear) { // 立春为寅月的开始 SolarTerm term = SolarTerm.fromIndex(y, 3); // 节令推移，年干支和月干支就都匹配上了 if (m > 0) { term = term.next(m); } SolarTime solarTime = term.getJulianDay().getSolarTime(); if (solarTime.getYear() >= startYear) { int mi = 0; int s = 0; // 日干支和节令干支的偏移值 SolarDay solarDay = solarTime.getSolarDay(); int d = day.next(-solarDay.getLunarDay().getSixtyCycle().getIndex()).getIndex(); if (d > 0) { // 从节令推移天数 solarDay = solarDay.next(d); } else if (h == solarTime.getHour()) { // 如果正好是节令当天，且小时和节令的小时数相等的极端情况，把分钟和秒钟带上 mi = solarTime.getMinute(); s = solarTime.getSecond(); } SolarTime time = SolarTime.fromYmdHms(solarDay.getYear(), solarDay.getMonth(), solarDay.getDay(), h, mi, s); // 验证一下 if (time.getLunarHour().getEightChar().equals(this)) { l.add(time); } } } y += 60; } return l; }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: test1() { LegalHoliday d = LegalHoliday.fromYmd(2010, 1, 1); Assert."<AssertPlaceHolder>"; }
fromYmd(int year, int month, int day) { Matcher matcher = Pattern.compile(String.format("%04d%02d%02d[0-1][0-8][\\+|-]\\d{2}", year, month, day)).matcher(DATA); return !matcher.find() ? null : new LegalHoliday(year, month, day, matcher.group()); }
[*] target: assertNotNull(d)
[-] pred: org. junit. Assert. assertNotNull ( d )
************************************
************************************
[+] input: test2() { LegalHoliday d = LegalHoliday.fromYmd(2010, 1, 1); Assert."<AssertPlaceHolder>"; }
fromYmd(int year, int month, int day) { Matcher matcher = Pattern.compile(String.format("%04d%02d%02d[0-1][0-8][\\+|-]\\d{2}", year, month, day)).matcher(DATA); return !matcher.find() ? null : new LegalHoliday(year, month, day, matcher.group()); }
[*] target: assertNotNull(d)
[-] pred: org. junit. Assert. assertNotNull ( d )
************************************
************************************
[+] input: test6() { SolarFestival f = SolarDay.fromYmd(1939, 5, 4).getFestival(); Assert."<AssertPlaceHolder>"; }
fromYmd(int year, int month, int day) { Matcher matcher = Pattern.compile(String.format("@\\d{2}0%02d%02d\\d+", month, day)).matcher(DATA); if (!matcher.find()) { return null; } String data = matcher.group(); int startYear = Integer.parseInt(data.substring(8), 10); return year < startYear ? null : new SolarFestival(FestivalType.DAY, SolarDay.fromYmd(year, month, day), startYear, data); }
[*] target: assertNull(f)
[-] pred: org. junit. Assert. assertNull ( f )
************************************
************************************
[+] input: select() { // 请求参数 Map<String, Object> requestParams = new HashMap<>(); requestParams.put("methodName", "apple"); // 服务列表 ServiceMetaInfo serviceMetaInfo1 = new ServiceMetaInfo(); serviceMetaInfo1.setServiceName("myService"); serviceMetaInfo1.setServiceVersion("1.0"); serviceMetaInfo1.setServiceHost("localhost"); serviceMetaInfo1.setServicePort(1234); ServiceMetaInfo serviceMetaInfo2 = new ServiceMetaInfo(); serviceMetaInfo2.setServiceName("myService"); serviceMetaInfo2.setServiceVersion("1.0"); serviceMetaInfo2.setServiceHost("yupi.icu"); serviceMetaInfo2.setServicePort(80); List<ServiceMetaInfo> serviceMetaInfoList = Arrays.asList(serviceMetaInfo1, serviceMetaInfo2); // 连续调用 3 次 ServiceMetaInfo serviceMetaInfo = loadBalancer.select(requestParams, serviceMetaInfoList); System.out.println(serviceMetaInfo); Assert.assertNotNull(serviceMetaInfo); serviceMetaInfo = loadBalancer.select(requestParams, serviceMetaInfoList); System.out.println(serviceMetaInfo); Assert.assertNotNull(serviceMetaInfo); serviceMetaInfo = loadBalancer.select(requestParams, serviceMetaInfoList); System.out.println(serviceMetaInfo); Assert."<AssertPlaceHolder>"; }
select(Map<String, Object> requestParams, List<ServiceMetaInfo> serviceMetaInfoList);
[*] target: assertNotNull(serviceMetaInfo)
[-] pred: org. junit. Assert. assertNotNull ( serviceMetaInfo )
************************************
************************************
[+] input: serviceDiscovery() { ServiceMetaInfo serviceMetaInfo = new ServiceMetaInfo(); serviceMetaInfo.setServiceName("myService"); serviceMetaInfo.setServiceVersion("1.0"); String serviceKey = serviceMetaInfo.getServiceKey(); List<ServiceMetaInfo> serviceMetaInfoList = registry.serviceDiscovery(serviceKey); Assert."<AssertPlaceHolder>"; }
serviceDiscovery(String serviceKey);
[*] target: assertNotNull(serviceMetaInfoList)
[-] pred: org. junit. Assert. assertNotNull ( serviceMetaInfoList )
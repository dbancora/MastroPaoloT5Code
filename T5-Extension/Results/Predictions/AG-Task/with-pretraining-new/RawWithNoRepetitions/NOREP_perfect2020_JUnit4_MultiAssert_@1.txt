[+] input: testSetOnJoinResetMoney() { s.setOnJoinResetMoney(false); assertFalse(s.isOnJoinResetMoney()); s.setOnJoinResetMoney(true); "<AssertPlaceHolder>"; }
isOnJoinResetMoney() { return onJoinResetMoney; }
[*] target: assertTrue(s.isOnJoinResetMoney())
[-] pred: org. junit. Assert. assertTrue ( s. isOnJoinResetMoney() )
************************************
************************************
[+] input: testSetOnLeaveResetXP() { assertFalse(s.isOnLeaveResetXP()); s.setOnLeaveResetXP(true); "<AssertPlaceHolder>"; }
isOnLeaveResetXP() { return onLeaveResetXP; }
[*] target: assertTrue(s.isOnLeaveResetXP())
[-] pred: org. junit. Assert. assertTrue ( s. isOnLeaveResetXP() )
************************************
************************************
[+] input: NoSuchAlgorithmException { //        AESPair keyPair = AES256.generateKeyPairOld(); //        SecretKey key = keyPair.getKey(); //        byte[] IV = keyPair.getIV(); //        byte[] sk = AES256.serializeSecretKey(key); // //        List<byte[]> listofbytes = new ArrayList<>(); //        listofbytes.add(sk); //        listofbytes.add(IV); // //        byte[] shareBetweenUsers = ByteHelper.concat(listofbytes); //        assertEquals(shareBetweenUsers.length, 32+16); //        assertTrue(Arrays.equals(Arrays.copyOfRange(shareBetweenUsers, 0, 32), sk)); //        assertTrue(Arrays.equals(Arrays.copyOfRange(shareBetweenUsers, 32, shareBetweenUsers.length), IV)); // //        SecretKey reconstructedKey = AES256.deserializeSecretKey(sk); //        boolean r = (key.equals(reconstructedKey)); // //        "<AssertPlaceHolder>"; }
deserializeSecretKey (byte[] sk) { return new SecretKeySpec(sk, 0, sk.length, Constant.AES); }
[*] target: assertTrue(r)
[-] pred: org. junit. Assert. assertTrue ( r )
************************************
************************************
[+] input: Exception { String message = "1";  KeyPair kp2048 = RSA.generateKeyPair(); PublicKey pk = kp2048.getPublic(); PrivateKey sk = kp2048.getPrivate();  byte[] sign = RSA.signAsBytes(message, sk); assertEquals(sign.length, 256);  boolean valid = RSA.verifyAsBytes(message, sign, pk); "<AssertPlaceHolder>"; }
verifyAsBytes(String plainText, byte[] signatureBytes, PublicKey publicKey) throws Exception { java.security.Signature publicSignature = java.security.Signature.getInstance("SHA256withRSA"); publicSignature.initVerify(publicKey); publicSignature.update(plainText.getBytes(UTF_8));  return publicSignature.verify(signatureBytes); }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: Exception { String message = "1"; KeyPair kp4096 = RSA.generateKeyPair(4096); PublicKey pk = kp4096.getPublic(); PrivateKey sk = kp4096.getPrivate();  byte[] sign = RSA.signAsBytes(message, sk); assertEquals(sign.length, 512);  boolean valid = RSA.verifyAsBytes(message, sign, pk); "<AssertPlaceHolder>"; }
verifyAsBytes(String plainText, byte[] signatureBytes, PublicKey publicKey) throws Exception { java.security.Signature publicSignature = java.security.Signature.getInstance("SHA256withRSA"); publicSignature.initVerify(publicKey); publicSignature.update(plainText.getBytes(UTF_8));  return publicSignature.verify(signatureBytes); }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: NoSuchAlgorithmException { String message = "1"; byte[] messageHash = SHA256.hash(message);  String actualHashHex = "6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b"; byte[] actualHash = ByteHelper.hexStringToByteArray(actualHashHex);  boolean valid = Arrays.equals(messageHash, actualHash); "<AssertPlaceHolder>";  assertEquals(messageHash.length, 32); }
hexStringToByteArray(String hexString){ byte[] bytes = new byte[hexString.length() / 2];  for(int i = 0; i < hexString.length(); i += 2){ String sub = hexString.substring(i, i + 2); Integer intVal = Integer.parseInt(sub, 16); bytes[i / 2] = intVal.byteValue(); String hex = "".format("0x%x", bytes[i / 2]); } return bytes; }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: IOException { //        final List<String> expectedApkFiles = Arrays.asList("base.apk", //                "split_config.en.apk", //                "split_config.hdpi.apk"); //        Collections.sort(expectedApkFiles); //        Path xmlFile = Paths.get(new File(backupLocation, PACKAGE_NAME_APK_SPLITS + ".xml")); //        SBConverter sbConvert = new SBConverter(xmlFile); //        sbConvert.convert(); //        Path newBackupLocation = Prefs.Storage.getAppManagerDirectory().findFile(PACKAGE_NAME_APK_SPLITS).findFile("0_SB"); //        // Verify source //        List<String> actualApkFiles = TarUtilsTest.getFileNamesGZip(Collections.singletonList( //                newBackupLocation.findFile("source.tar.gz.0"))); //        Collections.sort(actualApkFiles); //        "<AssertPlaceHolder>"; //        assertFalse(newBackupLocation.hasFile("data0.tar.gz.0")); //        assertFalse(newBackupLocation.hasFile("data1.tar.gz.0")); //    }
convert() throws BackupException { // Source metadata mSourceMetadata = new MetadataManager.Metadata(); generateMetadata(); // Destination metadata mDestMetadata = new MetadataManager.Metadata(mSourceMetadata); MetadataManager metadataManager = MetadataManager.getNewInstance(); metadataManager.setMetadata(mDestMetadata); // Simulate a backup creation // If the package has another backup named SB, another backup will be created BackupFiles backupFiles; BackupFiles.BackupFile[] backupFileList; try { backupFiles = new BackupFiles(mPackageName, mUserId, new String[]{"SB"}); backupFileList = backupFiles.getBackupPaths(true); } catch (IOException e) { throw new BackupException("Could not get backup files.", e); } for (BackupFiles.BackupFile backupFile : backupFileList) { // We're iterating over a singleton list boolean backupSuccess = false; try { mTempBackupPath = backupFile.getBackupPath(); mCrypto = ConvertUtils.setupCrypto(mDestMetadata); mDestMetadata.backupName = backupFile.backupName; try { mChecksum = backupFile.getChecksum(CryptoUtils.MODE_NO_ENCRYPTION); } catch (IOException e) { throw new BackupException("Failed to create checksum file.", e); } // Backup icon backupIcon(); if (mDestMetadata.flags.backupApkFiles()) { backupApkFile(); } if (mDestMetadata.flags.backupData()) { backupData(); } // Write modified metadata metadataManager.setMetadata(mDestMetadata); try { metadataManager.writeMetadata(backupFile); } catch (IOException e) { throw new BackupException("Failed to write metadata."); } // Store checksum for metadata try { mChecksum.add(MetadataManager.META_FILE, DigestUtils.getHexDigest(mDestMetadata.checksumAlgo, backupFile.getMetadataFile())); } catch (IOException e) { throw new BackupException("Failed to generate checksum for meta.json", e); } mChecksum.close(); // Encrypt checksum try { Path checksumFile = backupFile.getChecksumFile(CryptoUtils.MODE_NO_ENCRYPTION); encrypt(new Path[]{checksumFile}); } catch (IOException e) { throw new BackupException("Failed to encrypt checksums.txt"); } // Replace current backup try { backupFile.commit(); } catch (IOException e) { throw new BackupException("Could not finalise backup.", e); } backupSuccess = true; } catch (BackupException e) { throw e; } catch (Throwable th) { throw new BackupException("Unknown error occurred.", th); } finally { if (!backupSuccess) { backupFile.cleanup(); } if (mCrypto != null) { mCrypto.close(); } mCachedApk.requireParent().delete(); if (backupSuccess) { BackupUtils.putBackupToDbAndBroadcast(ContextUtils.getContext(), mDestMetadata); } } return; } }
[*] target: assertEquals(expectedApkFiles, actualApkFiles)
[-] pred: org. junit. Assert. assertEquals ( expectedApkFiles, actualApkFiles )
************************************
************************************
[+] input: IOException { try (SplitInputStream splitInputStream = new SplitInputStream(fileList)) { // For 1 KB long expectedSkipBytes = 10024; long actualSkipBytes = splitInputStream.skip(expectedSkipBytes); assertEquals(expectedSkipBytes, actualSkipBytes); // For 1 MB expectedSkipBytes = 1024 * 1024; actualSkipBytes = splitInputStream.skip(expectedSkipBytes); assertEquals(expectedSkipBytes, actualSkipBytes); // For 2 MB expectedSkipBytes = 1024 * 1024 * 2; actualSkipBytes = splitInputStream.skip(expectedSkipBytes); "<AssertPlaceHolder>"; } }
skip(long n) throws IOException { if (n <= 0) return 0; return Math.max(read0(null, 0, (int) n), 0); }
[*] target: assertEquals(expectedSkipBytes, actualSkipBytes)
[-] pred: org. junit. Assert. assertEquals ( expectedSkipBytes, actualSkipBytes )
************************************
************************************
[+] input: should_throw_exception_if_directive_class_not_a_wiring1() { directivePostProcessor.postProcessBeforeInitialization(new CorrectDirective(), "a"); Map<String, SchemaDirectiveWiring> map = (Map<String, SchemaDirectiveWiring>) ReflectionTestUtils.getField(RuntimeWiringRegistry.class, "NAME_AND_DIRECTIVE_WIRING"); "<AssertPlaceHolder>"; assertEquals(1, map.size()); assertTrue(map.containsKey("b")); }
postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { Class<?> targetClass = AopProxyUtils.ultimateTargetClass(bean); if (targetClass.isAnnotationPresent(Directive.class)) { Directive directive = targetClass.getAnnotation(Directive.class); if (bean instanceof SchemaDirectiveWiring) { RuntimeWiringRegistry.registerDirective(directive.value(), (SchemaDirectiveWiring) bean); } else { throw new BeanInitializationException("directive bean must implements SchemaDirectiveWiring! bean:" + beanName); } } return bean; }
[*] target: assertNotNull(map)
[-] pred: org. junit. Assert. assertNotNull ( map )
************************************
************************************
[+] input: testHappyPath() { // to make this a unit test, we need to mock out the computations that would ordinarily involve collaborators // such as Bazel Query, filesystem scanning, and file parsing TestBazelQueryProjectStructureStrategy strategy = new TestBazelQueryProjectStructureStrategy(); addSourcePathForTest(strategy, "source/main/java"); addSourcePathForTest(strategy, "source/test/java"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/main/resources"); addTestResourcePathForTest(strategy, "projects/libs/apple/source/test/resources");  addSimQueryResult(strategy, "source/main/java/com/salesforce/apple/api/Apple.java"); addSimQueryResult(strategy, "source/main/java/com/salesforce/apple/api/ApplePie.java"); addSimQueryResult(strategy, "source/main/resources/fruit/kinds.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/pies.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/cakes.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/sauces.properties"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/AppleTest.java"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/ApplePieTest.java"); addSimQueryResult(strategy, "source/test/resources/test.properties");  // run the test String relPath = FSPathHelper.osSeps("projects/libs/apple"); InMemoryPackageLocation packageLocation = new InMemoryPackageLocation(relPath); ProjectStructure structure = null; try { structure = strategy.doStructureAnalysis(bazelWorkspace, packageLocation, nullCommandRunner); } catch (Exception anyE) { anyE.printStackTrace(); }  // validate "<AssertPlaceHolder>"; assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/main/java"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/main/resources"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/source/test/java"); assertContains(structure.testResourceDirFSPaths, "projects/libs/apple/source/test/resources"); }
doStructureAnalysis(BazelWorkspace bazelWorkspace, BazelPackageLocation packageNode, BazelWorkspaceCommandRunner commandRunner) {  File workspaceRootDir = bazelWorkspace.getBazelWorkspaceRootDirectory(); String packageRelPath = packageNode.getBazelPackageFSRelativePath(); File packageDir = new File(workspaceRootDir, packageRelPath); // TODO move this to the PackageLocation api  String labelPath = packageRelPath.replaceAll(FSPathHelper.WINDOWS_BACKSLASH_REGEX, "/"); BazelLabel packageLabel = new BazelLabel(labelPath, BazelLabel.BAZEL_WILDCARD_ALLTARGETS_STAR);  // execute the expensive query, this will take a few seconds to run at least Collection<String> queryResults = runBazelQueryForSourceFiles(workspaceRootDir, packageLabel, commandRunner);  ProjectStructure structure = processQueryResults(packageRelPath, packageDir, packageLabel, queryResults);  return structure; }
[*] target: assertNotNull(structure)
[-] pred: org. junit. Assert. assertNotNull ( structure )
************************************
************************************
[+] input: testMultipleSourceDirs() { // to make this a unit test, we need to mock out the computations that would ordinarily involve collaborators // such as Bazel Query, filesystem scanning, and file parsing TestBazelQueryProjectStructureStrategy strategy = new TestBazelQueryProjectStructureStrategy(); addSourcePathForTest(strategy, "source/dev/java"); addSourcePathForTest(strategy, "source/dev2/java"); addSourcePathForTest(strategy, "source/test/java"); addSourcePathForTest(strategy, "src/test/java"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/dev/resources/fruit"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/dev2/resources"); addTestResourcePathForTest(strategy, "projects/libs/apple/source/test/resources");  addSimQueryResult(strategy, "source/dev/java/com/salesforce/apple/api/Apple.java"); addSimQueryResult(strategy, "source/dev2/java/com/salesforce/apple/api/ApplePie.java"); addSimQueryResult(strategy, "source/dev/resources/fruit/kinds.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/pies.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/cakes.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/sauces.properties"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/AppleTest.java"); addSimQueryResult(strategy, "src/test/java/com/salesforce/apple/api/ApplePieTest.java"); addSimQueryResult(strategy, "source/test/resources/test.properties");  // run the test String relPath = FSPathHelper.osSeps("projects/libs/apple"); InMemoryPackageLocation packageLocation = new InMemoryPackageLocation(relPath); ProjectStructure structure = strategy.doStructureAnalysis(bazelWorkspace, packageLocation, nullCommandRunner);  // validate "<AssertPlaceHolder>"; assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/dev/java"); assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/dev2/java"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/dev/resources/fruit"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/dev2/resources"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/source/test/java"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/src/test/java"); assertContains(structure.testResourceDirFSPaths, "projects/libs/apple/source/test/resources"); }
doStructureAnalysis(BazelWorkspace bazelWorkspace, BazelPackageLocation packageNode, BazelWorkspaceCommandRunner commandRunner) {  File workspaceRootDir = bazelWorkspace.getBazelWorkspaceRootDirectory(); String packageRelPath = packageNode.getBazelPackageFSRelativePath(); File packageDir = new File(workspaceRootDir, packageRelPath); // TODO move this to the PackageLocation api  String labelPath = packageRelPath.replaceAll(FSPathHelper.WINDOWS_BACKSLASH_REGEX, "/"); BazelLabel packageLabel = new BazelLabel(labelPath, BazelLabel.BAZEL_WILDCARD_ALLTARGETS_STAR);  // execute the expensive query, this will take a few seconds to run at least Collection<String> queryResults = runBazelQueryForSourceFiles(workspaceRootDir, packageLabel, commandRunner);  ProjectStructure structure = processQueryResults(packageRelPath, packageDir, packageLabel, queryResults);  return structure; }
[*] target: assertNotNull(structure)
[-] pred: org. junit. Assert. assertNotNull ( structure )
************************************
************************************
[+] input: testPlot() { double[] nums = new double[]{2710, 2755, 2850, 2880, 2880, 2890, 2920, 2940, 2950, 3050, 3130, 3325}; BoxPlot plot = BoxPlotUtil.plot(nums); TestCase."<AssertPlaceHolder>"; TestCase.assertEquals(3202.5D, plot.getMaxRegion()); TestCase.assertEquals(3000.0D, plot.getQ3()); TestCase.assertEquals(2905.0, plot.getMedian()); TestCase.assertEquals(2865.0, plot.getQ1()); TestCase.assertEquals(2662.5D, plot.getMinRegion()); }
plot(double[] data) { List<Double> collect = Arrays.stream(data).boxed().sorted().collect(Collectors.toList()); data = collect.stream().mapToDouble(i -> i).toArray(); if (data.length <= 2) { return null; }  double max; double q3; double median; double q1; double min; double iqr; if (data.length % 2 == 0) { median = (data[(data.length) / 2 - 1] + data[(data.length) / 2]) / 2; q1 = (data[(data.length) / 4 - 1] + data[(data.length) / 4]) / 2; q3 = (data[((data.length) * 3) / 4 - 1] + data[((data.length) * 3) / 4]) / 2; } else { median = data[(data.length) / 2]; q1 = data[(data.length) / 4]; q3 = data[(data.length * 3) / 4]; } max = data[data.length - 1]; min = data[0]; iqr = q3 - q1;  double maxRegion = q3 + 1.5 * iqr; double minRegion = q1 - 1.5 * iqr;  BoxPlot box = new BoxPlot(); box.setMaxRegion(maxRegion); box.setMax(max); box.setQ3(q3); box.setMedian(median); box.setQ1(q1); box.setMin(min); box.setMinRegion(minRegion); box.setIqr(iqr); return box; }
[*] target: assertNotNull(plot)
[-] pred: org. junit. Assert. assertNotNull ( plot )
************************************
************************************
[+] input: Exception { Collection<MessageId> messagesToAck = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToAck(txn, contactId, 123); will(returnValue(messagesToAck)); oneOf(database).lowerAckFlag(txn, contactId, messagesToAck); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Ack a = db.generateAck(transaction, contactId, 123); "<AssertPlaceHolder>"; assertEquals(messagesToAck, a.getMessageIds()); }); }
generateAck(Transaction transaction, ContactId c, int maxMessages) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToAck(txn, c, maxMessages); if (ids.isEmpty()) return null; db.lowerAckFlag(txn, c, ids); return new Ack(ids); }
[*] target: assertNotNull(a)
[-] pred: org. junit. Assert. assertNotNull ( a )
************************************
************************************
[+] input: Exception { MessageId messageId1 = new MessageId(getRandomId()); Collection<MessageId> ids = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToOffer(txn, contactId, 123, maxLatency); will(returnValue(ids)); oneOf(database).updateRetransmissionData(txn, contactId, messageId, maxLatency); oneOf(database).updateRetransmissionData(txn, contactId, messageId1, maxLatency); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Offer o = db.generateOffer(transaction, contactId, 123, maxLatency); "<AssertPlaceHolder>"; assertEquals(ids, o.getMessageIds()); }); }
generateOffer(Transaction transaction, ContactId c, int maxMessages, long maxLatency) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToOffer(txn, c, maxMessages, maxLatency); if (ids.isEmpty()) return null; for (MessageId m : ids) db.updateRetransmissionData(txn, c, m, maxLatency); return new Offer(ids); }
[*] target: assertNotNull(o)
[-] pred: org. junit. Assert. assertNotNull ( o )
************************************
************************************
[+] input: Exception { MessageId messageId1 = new MessageId(getRandomId()); Collection<MessageId> ids = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToRequest(txn, contactId, 123); will(returnValue(ids)); oneOf(database).removeOfferedMessages(txn, contactId, ids); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Request r = db.generateRequest(transaction, contactId, 123); "<AssertPlaceHolder>"; assertEquals(ids, r.getMessageIds()); }); }
generateRequest(Transaction transaction, ContactId c, int maxMessages) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToRequest(txn, c, maxMessages); if (ids.isEmpty()) return null; db.removeOfferedMessages(txn, c, ids); return new Request(ids); }
[*] target: assertNotNull(r)
[-] pred: org. junit. Assert. assertNotNull ( r )
************************************
************************************
[+] input: Exception { Transaction txn = new Transaction(null, true);  context.checking(new Expectations() {{ oneOf(settingsManager).getSettings(txn, SETTINGS_NAMESPACE); will(returnValue(pairedSettings)); }});  MailboxProperties properties = manager.getOwnMailboxProperties(txn); "<AssertPlaceHolder>"; assertEquals(onion, properties.getOnion()); assertEquals(token, properties.getAuthToken()); assertEquals(serverSupports, properties.getServerSupports()); assertTrue(properties.isOwner()); }
getOwnMailboxProperties(Transaction txn) throws DbException { Settings s = settingsManager.getSettings(txn, SETTINGS_NAMESPACE); String onion = s.get(SETTINGS_KEY_ONION); String token = s.get(SETTINGS_KEY_TOKEN); if (isNullOrEmpty(onion) || isNullOrEmpty(token)) return null; List<MailboxVersion> serverSupports = parseServerSupports(s); try { MailboxAuthToken tokenId = MailboxAuthToken.fromString(token); return new MailboxProperties(onion, tokenId, serverSupports); } catch (InvalidMailboxIdException e) { throw new DbException(e); } }
[*] target: assertNotNull(properties)
[-] pred: org. junit. Assert. assertNotNull ( properties )
************************************
************************************
[+] input: canCalculateAdditiveDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Doe"); p2.setHobbies("Swimming", "Skiing", "Cinema", "Reading"); p2.setPets("Cat", "Dog", "Fish"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); indices.add(petsIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertTrue(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(hobbiesIndex, petsIndex), diff.getChangedIndices()); assertEquals(Sets.newHashSet("Cinema", "Reading"), diff.getAdditions(hobbiesIndex)); assertEquals(Sets.newHashSet("Cat", "Dog", "Fish"), diff.getAdditions(petsIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateSubtractiveDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing", "Cinema", "Reading"); p1.setPets("Cat", "Dog", "Fish"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Doe"); p2.setHobbies("Swimming", "Skiing"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); indices.add(petsIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertTrue(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(hobbiesIndex, petsIndex), diff.getChangedIndices()); assertEquals(Sets.newHashSet("Cinema", "Reading"), diff.getRemovals(hobbiesIndex)); assertEquals(Sets.newHashSet("Cat", "Dog", "Fish"), diff.getRemovals(petsIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateEntryAdditionDiff() { Person johnDoe = createJohnDoe(); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex favoriteColorIndex = new DummyIndex(PersonIndexer.favoriteColor(), "favoriteColor"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(favoriteColorIndex); indices.add(hobbiesIndex); indices.add(petsIndex);  // simulate the addition of John Doe IndexValueDiff diff = IndexingUtils.calculateDiff(indices, null, johnDoe); "<AssertPlaceHolder>"; assertTrue(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); assertTrue(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(firstNameIndex, lastNameIndex, hobbiesIndex), diff.getChangedIndices());  assertEquals(Sets.newHashSet("John"), diff.getAdditions(firstNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(firstNameIndex));  assertEquals(Sets.newHashSet("Doe"), diff.getAdditions(lastNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(lastNameIndex));  assertEquals(Sets.newHashSet("Swimming", "Skiing"), diff.getAdditions(hobbiesIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(hobbiesIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateEntryRemovalDiff() { Person johnDoe = createJohnDoe(); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex favoriteColorIndex = new DummyIndex(PersonIndexer.favoriteColor(), "favoriteColor"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(favoriteColorIndex); indices.add(hobbiesIndex); indices.add(petsIndex); // simulate the deletion of John Doe IndexValueDiff diff = IndexingUtils.calculateDiff(indices, johnDoe, null); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertTrue(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertTrue(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(firstNameIndex, lastNameIndex, hobbiesIndex), diff.getChangedIndices());  assertEquals(Collections.emptySet(), diff.getAdditions(firstNameIndex)); assertEquals(Sets.newHashSet("John"), diff.getRemovals(firstNameIndex));  assertEquals(Collections.emptySet(), diff.getAdditions(lastNameIndex)); assertEquals(Sets.newHashSet("Doe"), diff.getRemovals(lastNameIndex));  assertEquals(Collections.emptySet(), diff.getAdditions(hobbiesIndex)); assertEquals(Sets.newHashSet("Swimming", "Skiing"), diff.getRemovals(hobbiesIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateMixedDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Smith"); p2.setHobbies("Skiing", "Cinema"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertTrue(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Collections.emptySet(), diff.getAdditions(firstNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(firstNameIndex)); assertFalse(diff.isIndexChanged(firstNameIndex)); assertEquals(Collections.singleton("Smith"), diff.getAdditions(lastNameIndex)); assertEquals(Collections.singleton("Doe"), diff.getRemovals(lastNameIndex)); assertTrue(diff.isIndexChanged(lastNameIndex)); assertEquals(Collections.singleton("Cinema"), diff.getAdditions(hobbiesIndex)); assertEquals(Collections.singleton("Swimming"), diff.getRemovals(hobbiesIndex)); assertTrue(diff.isIndexChanged(hobbiesIndex)); assertEquals(Sets.newHashSet(lastNameIndex, hobbiesIndex), diff.getChangedIndices()); assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCreateEmptyDiff() { MutableIndexValueDiff diff = new MutableIndexValueDiff(null, null); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmptyAddition() { MutableIndexValueDiff diff = new MutableIndexValueDiff(null, new Object()); assertNotNull(diff); "<AssertPlaceHolder>"; assertTrue(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmptyRemoval() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), null); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertTrue(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmtpyUpdate() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), new Object()); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: emptyPeriodIsSingleton() { Period empty1 = Period.empty(); Period empty2 = Period.empty(); "<AssertPlaceHolder>"; assertNotNull(empty2); assertTrue(empty1 == empty2); }
empty() { return PeriodImpl.empty(); }
[*] target: assertNotNull(empty1)
[-] pred: org. junit. Assert. assertNotNull ( empty1 )
************************************
************************************
[+] input: canCreateInMemoryDatabaseEasily() { // without additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().inMemoryGraph().build()) { assertNotNull(graph); } // with additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().inMemoryGraph(config -> config.assumeCachedValuesAreImmutable(true)).build()) { "<AssertPlaceHolder>"; } }
create();
[*] target: assertNotNull(graph)
[-] pred: org. junit. Assert. assertNotNull ( graph )
************************************
************************************
[+] input: Exception { File directory = Files.createTempDirectory("chronodb-test").toFile(); try { // without additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().exodusGraph(directory.getAbsolutePath()).build()) { assertNotNull(graph); } // with additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().exodusGraph(directory.getAbsolutePath(), config -> config.assumeCachedValuesAreImmutable(true)).build()) { "<AssertPlaceHolder>"; } } finally { FileUtils.deleteDirectory(directory); } }
create();
[*] target: assertNotNull(graph)
[-] pred: org. junit. Assert. assertNotNull ( graph )
************************************
************************************
[+] input: canGeneratePerson() { Person person = PersonGenerator.generateRandomPerson(); "<AssertPlaceHolder>"; assertNotNull(person.getFirstName()); assertNotNull(person.getLastName()); assertTrue(person.getFirstName().length() > 0); assertTrue(person.getLastName().length() > 0); }
generateRandomPerson() { Person person = new Person(); person.setFirstName(TestUtils.getRandomEntryOf(FIRST_NAMES)); person.setLastName(TestUtils.getRandomEntryOf(LAST_NAMES)); person.setFavoriteColor(TestUtils.getRandomEntryOf(COLORS)); int numberOfHobbies = TestUtils.randomBetween(0, 3); int numberOfPets = TestUtils.randomBetween(0, 2); person.getHobbies().addAll(TestUtils.getRandomUniqueEntriesOf(HOBBIES, numberOfHobbies)); person.getPets().addAll(TestUtils.getRandomUniqueEntriesOf(PETS, numberOfPets)); return person; }
[*] target: assertNotNull(person)
[-] pred: org. junit. Assert. assertNotNull ( person )
************************************
************************************
[+] input: equals_SameColors_Symmetric() { int first = Color.pack(1, 2, 3, 4); int second = Color.pack(1, 2, 3, 4); "<AssertPlaceHolder>"; assertEquals(second, first); }
pack(int red, int green, int blue, int alpha) { checkComponent(red); checkComponent(green); checkComponent(blue); checkComponent(alpha); return (alpha << ALPHA_OFFSET) | (red << RED_OFFSET) | (green << GREEN_OFFSET) | (blue << BLUE_OFFSET); }
[*] target: assertEquals(first, second)
[-] pred: org. junit. Assert. assertEquals ( first, second )
************************************
************************************
[+] input: equals_SameColors_Transitive() { int first = Color.pack(1, 2, 3, 4); int second = Color.pack(1, 2, 3, 4); int third = Color.pack(1, 2, 3, 4); "<AssertPlaceHolder>"; assertEquals(second, third); assertEquals(first, third); }
pack(int red, int green, int blue, int alpha) { checkComponent(red); checkComponent(green); checkComponent(blue); checkComponent(alpha); return (alpha << ALPHA_OFFSET) | (red << RED_OFFSET) | (green << GREEN_OFFSET) | (blue << BLUE_OFFSET); }
[*] target: assertEquals(first, second)
[-] pred: org. junit. Assert. assertEquals ( first, second )
************************************
************************************
[+] input: construct_EmptyWidthArea_ConstructedCorrectly() { Area rect = new Area(0, 0, 0, 10); assertFalse(rect.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, rect.size())
[-] pred: org. junit. Assert. assertEquals ( 0, rect. size ( ) )
************************************
************************************
[+] input: construct_EmptyHeightArea_ConstructedCorrectly() { Area rect = new Area(0, 0, 10, 0); assertFalse(rect.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, rect.size())
[-] pred: org. junit. Assert. assertEquals ( 0, rect. size ( ) )
************************************
************************************
[+] input: list_SomeMatchAllFiltersClient_MatchingFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; assertTrue(resources.contains(ResourceLocation.parse("textures/hello.png"))); assertTrue(resources.contains(ResourceLocation.parse("textures/block/sea/rock/gravel.png"))); }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(2, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 2, resources. size ( ) )
************************************
************************************
[+] input: list_EmptyPathStart_NoExceptionIfOriginalAccepts() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; assertTrue(resources.contains(ResourceLocation.parse("textures/hello.png"))); assertTrue(resources.contains(ResourceLocation.parse("textures/block/sea/rock/gravel.png"))); }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(2, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 2, resources. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPack_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorNotPresent_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorBelow_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ), Set.of( "textures/bat_efgh.png" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorInSame_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta", "textures/bat_efgh.png" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorAbove_PackNotFound() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_efgh.png" ), Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  assertFalse( resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ).isPresent() );  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackSameAsFloor_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_abcd.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_InvalidMetadataDuringRead_LoadsValidTextures() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat.png", "textures/bat.png.moremcmeta", "textures/creeper.png", "textures/zombie.png", "textures/creeper.png.moremcmeta", "textures/zombie.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { if (metadataLocation.getPath().contains("creeper")) { throw new InvalidMetadataException("Dummy exception"); }  return MOCK_READER.parse(metadataLocation, metadataStream, resourceRepository); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures"); "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size() )
************************************
************************************
[+] input: load_SilencedInvalidMetadataDuringRead_LoadsValidTextures() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat.png", "textures/bat.png.moremcmeta", "textures/creeper.png", "textures/zombie.png", "textures/creeper.png.moremcmeta", "textures/zombie.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { if (metadataLocation.getPath().contains("creeper")) { throw new InvalidMetadataException("Dummy exception", new Exception(), true); }  return MOCK_READER.parse(metadataLocation, metadataStream, resourceRepository); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures"); "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size() )
************************************
************************************
[+] input: load_DiffFormatMetadataInPackWithTexture_Conflict() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/zombie.png.other"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/creeper.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: load_DiffFormatMetadataInPackAboveTexture_Conflict() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/creeper.png.other"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: testChoose() { Clorus p = new Clorus(2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Plip()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  assertEquals(expected, actual);  p = new Clorus(2); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Plip()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.ATTACK, Direction.TOP);  assertEquals(expected, actual);  p = new Clorus(1); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.REPLICATE, Direction.RIGHT);  assertEquals(expected, actual);  p = new Clorus(0.5); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.MOVE, Direction.RIGHT);  "<AssertPlaceHolder>"; }
chooseAction(Map<Direction, Occupant> neighbors) { List<Direction> empties = getNeighborsOfType(neighbors, "empty"); List<Direction> plip = getNeighborsOfType(neighbors, "plip");  if (empties.size() == 0) { return new Action(Action.ActionType.STAY); } else if (!plip.isEmpty()) { Direction moveDir = HugLifeUtils.randomEntry(plip); return new Action(Action.ActionType.ATTACK, moveDir); } else if (energy >= 1) { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.REPLICATE, moveDir); } else { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.MOVE, moveDir); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: Exception { final Future<Socket> f = executor.submit(new Callable<Socket>() { public Socket call() throws Exception { return serverSocket.accept(); } }); assertBlocks(f); connect().getOutputStream().write(123); final Socket socket = f.get(); "<AssertPlaceHolder>"; assertEquals(123, socket.getInputStream().read()); }
connect() throws Exception { synchronized (lock) { final MockSocketConnection c = new MockSocketConnection(); connection = c.getSocketA(); lock.notifyAll(); while (connection != null) { lock.wait(); } return c.getSocketB(); } }
[*] target: assertNotNull(socket)
[-] pred: org. junit. Assert. assertNotNull ( socket )
************************************
************************************
[+] input: IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ZipOutputStream zipout = new ZipOutputStream(buffer); zipout.putNextEntry(new ZipEntry("META-INF/MANIFEST.MF")); zipout.putNextEntry(new ZipEntry("META-INF/ALIAS.SF")); zipout.finish(); ByteArrayOutputStream out = new ByteArrayOutputStream();  int count = instrumenter.instrumentAll( new ByteArrayInputStream(buffer.toByteArray()), out, "Test");  "<AssertPlaceHolder>"; ZipInputStream zipin = new ZipInputStream(new ByteArrayInputStream( out.toByteArray())); assertEquals("META-INF/MANIFEST.MF", zipin.getNextEntry().getName()); assertNull(zipin.getNextEntry()); }
instrumentAll(final InputStream input, final OutputStream output, final String name) throws IOException { final ContentTypeDetector detector; try { detector = new ContentTypeDetector(input); } catch (final IOException e) { throw instrumentError(name, e); } switch (detector.getType()) { case ContentTypeDetector.CLASSFILE: instrument(detector.getInputStream(), output, name); return 1; case ContentTypeDetector.ZIPFILE: return instrumentZip(detector.getInputStream(), output, name); case ContentTypeDetector.GZFILE: return instrumentGzip(detector.getInputStream(), output, name); case ContentTypeDetector.PACK200FILE: return instrumentPack200(detector.getInputStream(), output, name); default: copy(detector.getInputStream(), output, name); return 0; } }
[*] target: assertEquals(0, count)
[-] pred: org. junit. Assert. assertEquals ( 0, count )
************************************
************************************
[+] input: IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ZipOutputStream zipout = new ZipOutputStream(buffer); zipout.putNextEntry(new ZipEntry("META-INF/ALIAS.SF")); zipout.finish(); ByteArrayOutputStream out = new ByteArrayOutputStream();  instrumenter.setRemoveSignatures(false); int count = instrumenter.instrumentAll( new ByteArrayInputStream(buffer.toByteArray()), out, "Test");  "<AssertPlaceHolder>"; ZipInputStream zipin = new ZipInputStream(new ByteArrayInputStream( out.toByteArray())); assertEquals("META-INF/ALIAS.SF", zipin.getNextEntry().getName()); assertNull(zipin.getNextEntry()); }
instrumentAll(final InputStream input, final OutputStream output, final String name) throws IOException { final ContentTypeDetector detector; try { detector = new ContentTypeDetector(input); } catch (final IOException e) { throw instrumentError(name, e); } switch (detector.getType()) { case ContentTypeDetector.CLASSFILE: instrument(detector.getInputStream(), output, name); return 1; case ContentTypeDetector.ZIPFILE: return instrumentZip(detector.getInputStream(), output, name); case ContentTypeDetector.GZFILE: return instrumentGzip(detector.getInputStream(), output, name); case ContentTypeDetector.PACK200FILE: return instrumentPack200(detector.getInputStream(), output, name); default: copy(detector.getInputStream(), output, name); return 0; } }
[*] target: assertEquals(0, count)
[-] pred: org. junit. Assert. assertEquals ( 0, count )
************************************
************************************
[+] input: testFoo() { String targetClassName = Foo.class.getCanonicalName(); GetStaticGraph graph = GetStaticGraphGenerator .generate(targetClassName);  Set<String> expectedClasses = new HashSet<String>(Arrays.asList( Foo.class.getCanonicalName(), Bar1.class.getCanonicalName(), Bar2.class.getCanonicalName(), Bar3.class.getCanonicalName(), Bar4.class.getCanonicalName(), Bar5.class.getCanonicalName(), Bar6.class.getCanonicalName(), Bar7.class.getCanonicalName(), BarBar1.class.getCanonicalName()));  Set<String> allClasses = new HashSet<String>(); allClasses.addAll(graph.getSourceClasses()); allClasses.addAll(graph.getTargetClasses());  assertEquals(expectedClasses, allClasses);  Map<String, Set<String>> expectedStaticFields = new HashMap<String, Set<String>>(); expectedStaticFields.put(Bar2.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar2"))); expectedStaticFields.put(Bar6.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar6"))); expectedStaticFields.put(Bar7.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar7")));  Map<String, Set<String>> staticFields = graph.getStaticFields(); "<AssertPlaceHolder>"; }
getStaticFields() { Map<String, Set<String>> staticFields = new LinkedHashMap<String, Set<String>>(); for (StaticFieldReadEntry read : this.staticFieldReads) { String className = read.getTargetClass().replace('/', '.'); if (!staticFields.containsKey(className)) { staticFields.put(className, new LinkedHashSet<String>()); } staticFields.get(className).add(read.getTargetField()); } return staticFields; }
[*] target: assertEquals(expectedStaticFields, staticFields)
[-] pred: org. junit. Assert. assertEquals ( expectedStaticFields, staticFields )
************************************
************************************
[+] input: ClassNotFoundException { Properties.DSE_SOLVER = Properties.SolverType.EVOSUITE_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: ClassNotFoundException { String cvc4_path = System.getenv("cvc4_path"); if (cvc4_path != null) { Properties.CVC4_PATH = cvc4_path; } Assume.assumeTrue(Properties.CVC4_PATH!=null); Properties.DSE_SOLVER = Properties.SolverType.CVC4_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: testInitializeClasses() {   EvoClassLoader loader = new EvoClassLoader(); String className = "com.examples.with.different.packagename.classhandling.TimeA"; //no mocking RuntimeSettings.deactivateAllMocking(); boolean problem = ClassStateSupport.initializeClasses(loader, className); Assert.assertFalse(problem);  //with mocking RuntimeSettings.mockJVMNonDeterminism = true; className = "com.examples.with.different.packagename.classhandling.TimeB"; problem = ClassStateSupport.initializeClasses(loader,className); Assert."<AssertPlaceHolder>"; }
initializeClasses(ClassLoader classLoader, String... classNames) {  boolean problem = false;  List<Class<?>> classes = loadClasses(classLoader, classNames); if(classes.size() != classNames.length) { problem = true; }  initialiseExternalTools(classLoader, classes);  if(RuntimeSettings.isUsingAnyMocking()) {  for (Class<?> clazz : classes) {  if(clazz.isInterface()) { /* FIXME: once we ll start to support Java 8, in which interfaces can have code, we ll need to instrument them as well */ continue; }  if (!InstrumentedClass.class.isAssignableFrom(clazz)) { String msg = "Class " + clazz.getName() + " was not instrumented by EvoSuite. " + "This could happen if you are running JUnit tests in a way that is not handled by EvoSuite, in " + "which some classes are loaded be reflection before the tests are run. Consult the EvoSuite documentation " + "for possible workarounds for this issue."; logger.error(msg); problem = true; //throw new IllegalStateException(msg); // throwing an exception might be a bit too extreme } } }  return problem;  //retransformIfNeeded(classes); // cannot do it, as retransformation does not really work :( }
[*] target: assertFalse(problem)
[-] pred: org. junit. Assert. assertFalse ( problem )
************************************
************************************
[+] input: testGetCurrentDirectory() {  JFileChooser chooser = new MockJFileChooser(); File dir = chooser.getCurrentDirectory();  Assert."<AssertPlaceHolder>"; Assert.assertTrue(dir instanceof MockFile); }
getCurrentDirectory() { return currentDirectory; }
[*] target: assertTrue(dir.exists())
[-] pred: org. junit. Assert. assertTrue ( dir. exists ( ) )
************************************
************************************
[+] input: Exception { qifParserTest.should_parse_multiple_accounts(); doImport();  List<Account> accounts = db.getAllAccountsList(); "<AssertPlaceHolder>";  Account a = accounts.get(0); assertEquals("My Bank Account", a.title); assertEquals(AccountType.BANK.name(), a.type);  List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id); assertEquals(2, transactions.size());  TransactionInfo t = transactions.get(0); assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime); assertEquals(-2000, t.fromAmount);  t = transactions.get(1); assertEquals(DateTime.date(2011, 1, 2).atMidnight().asLong(), t.dateTime); assertEquals(5400, t.fromAmount);  a = accounts.get(1); assertEquals("My Cash Account", a.title); assertEquals(AccountType.CASH.name(), a.type);  transactions = db.getTransactionsForAccount(a.id); assertEquals(3, transactions.size());  t = transactions.get(0); assertEquals(DateTime.date(2011, 2, 8).atMidnight().asLong(), t.dateTime); assertEquals(1000, t.fromAmount);  t = transactions.get(1); assertEquals(DateTime.date(2011, 2, 7).atMidnight().asLong(), t.dateTime); assertEquals(-2345, t.fromAmount);  t = transactions.get(2); assertEquals(DateTime.date(2011, 1, 1).atMidnight().asLong(), t.dateTime); assertEquals(-6780, t.fromAmount); }
doImport() throws IOException { long t0 = System.currentTimeMillis(); QifBufferedReader r = new QifBufferedReader(new BufferedReader(new InputStreamReader(new FileInputStream(options.filename), "UTF-8"))); QifParser parser = new QifParser(r, options.dateFormat); parser.parse(); long t1 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Parsing done in "+ TimeUnit.MILLISECONDS.toSeconds(t1-t0)+"s"); doImport(parser); long t2 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Importing done in "+ TimeUnit.MILLISECONDS.toSeconds(t2-t1)+"s"); }
[*] target: assertEquals(2, accounts.size())
[-] pred: org. junit. Assert. assertEquals ( 2, accounts. size ( ) )
************************************
************************************
[+] input: testClear() { GitHubDataCache<String> cache = new GitHubDataCache<>();  String data = "data to be cached"; GitHubProject project = new GitHubProject(new GitHubOrganization(data), data); cache.put(project, data); assertEquals(1, cache.size()); String cached = cache.get(project).orElseThrow(RuntimeException::new); assertEquals(data, cached);  // fill out the cache for (int i = 1, cacheSize = cache.size(); cacheSize < cache.maxSize(); cacheSize++, i++) { project = new GitHubProject(String.format("org%d", i), String.format("project%d", i)); data = String.format("data%d", i); cache.put(project, data); }  assertEquals(cache.size(), cache.maxSize());  cache.clear(); "<AssertPlaceHolder>"; }
size() { return entries.size(); }
[*] target: assertEquals(0, cache.size())
[-] pred: org. junit. Assert. assertEquals ( 0, cache. size ( ) )
************************************
************************************
[+] input: testOssSecurityRatingIsImmutable() { Rating rating = RatingRepository.INSTANCE.rating(OssSecurityRating.class); "<AssertPlaceHolder>"; ImmutabilityChecker checker = new ImmutabilityChecker(); rating.accept(checker); assertTrue(checker.allImmutable()); }
rating(Class<T> clazz) { Objects.requireNonNull(clazz, "You just gave me a null instead of class!");  Rating rating = ratings.get(clazz); if (rating == null) { throw new IllegalArgumentException( String.format("Oh no! Could not find %s", clazz.getCanonicalName())); }  return clazz.cast(rating); }
[*] target: assertNotNull(rating)
[-] pred: org. junit. Assert. assertNotNull ( rating )
************************************
************************************
[+] input: testValue() { EnumFeature<TestEnum> feature = new EnumFeature<>(TestEnum.class, "test"); EnumValue<TestEnum> value = feature.value(TestEnum.A); "<AssertPlaceHolder>"; assertSame(feature, value.feature()); assertSame(TestEnum.A, value.get()); }
value(T object) { return new EnumValue<>(this, object); }
[*] target: assertNotNull(value)
[-] pred: org. junit. Assert. assertNotNull ( value )
************************************
************************************
[+] input: testEqualsAndHashCode() { GitHubOrganization firstOrg = new GitHubOrganization("first"); GitHubOrganization theSameOrg = new GitHubOrganization("first"); assertTrue(firstOrg.equals(theSameOrg) && theSameOrg.equals(firstOrg)); "<AssertPlaceHolder>";  GitHubOrganization anotherOrg = new GitHubOrganization("another"); assertNotEquals(anotherOrg, firstOrg); }
hashCode() { return Objects.hash(super.hashCode(), name); }
[*] target: assertEquals(firstOrg.hashCode(), theSameOrg.hashCode())
[-] pred: org. junit. Assert. assertEquals ( firstOrg. hashCode ( ), theSameOrg. hashCode ( ) )
************************************
************************************
[+] input: IOException { ArtifactVersion version = new ArtifactVersion("2.0.2", LocalDateTime.now()); ArtifactVersion clone = Json.read(Json.toBytes(version), ArtifactVersion.class); assertTrue(version.equals(clone) && clone.equals(version)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(version, releaseDate); }
[*] target: assertEquals(version.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( version. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { ArtifactVersion version = new ArtifactVersion("MIGHTY-1.2", LocalDateTime.now()); ArtifactVersion clone = Yaml.read(Yaml.toBytes(version), ArtifactVersion.class); assertTrue(version.equals(clone) && clone.equals(version)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(version, releaseDate); }
[*] target: assertEquals(version.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( version. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { PackageManagersFeature feature = new PackageManagersFeature("test"); PackageManagersValue value = new PackageManagersValue( feature, new PackageManagers(PackageManager.MAVEN, PackageManager.OTHER)); PackageManagersValue clone = Json.read(Json.toBytes(value), PackageManagersValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), packageManagers); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { SecurityReview review = new SecurityReview(TEST_REVIEW_DATE, 0.0); SecurityReview clone = Yaml.read(Json.toBytes(review), SecurityReview.class); assertTrue(review.equals(clone) && clone.equals(review)); assertEquals(review.hashCode(), clone.hashCode());  review = new SecurityReview(TEST_REVIEW_DATE, null); clone = Yaml.read(Json.toBytes(review), SecurityReview.class); assertTrue(review.equals(clone) && clone.equals(review)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(date, changes); }
[*] target: assertEquals(review.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( review. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { StringFeature feature = new StringFeature("test"); StringValue value = new StringValue(feature, "2.3.3"); StringValue clone = Json.read(Json.toBytes(value), StringValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), content); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: testWithCustomTemplate() {  // Needed to ensure that decimal points are exactly as expected below... Locale.setDefault(new Locale("en", "US"));  RatingValue ratingValue = RATING.calculate(TEST_VALUES); GitHubProject project = new GitHubProject("org", "test"); project.set(ratingValue);  String template = "%RATING_LABEL%|%SCORE_VALUE%|%MAX_SCORE%|%CONFIDENCE_LABEL%" + "|%CONFIDENCE_VALUE%|%MAX_CONFIDENCE%|%MAIN_SCORE_NAME%" + "|%MAIN_SCORE_DESCRIPTION%|%MAIN_SCORE_EXPLANATION%";  OssSecurityRatingMarkdownFormatter formatter = new OssSecurityRatingMarkdownFormatter(new OssSecurityGithubAdvisor(), template); String text = formatter.print(project);  "<AssertPlaceHolder>"; assertEquals("BAD|3.4|10.0|Max|10.0|10.0|security score for open-source projects||", text); }
print(Subject subject) { if (!subject.ratingValue().isPresent()) { return StringUtils.EMPTY; }  MarkdownElement advice = markdownAdviceFor(subject); RatingValue ratingValue = subject.ratingValue().get(); ScoreValue scoreValue = ratingValue.scoreValue();  return template .replaceAll("%MAX_SCORE%", formatted(Score.MAX)) .replaceAll("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%SCORE_VALUE%", formatted(scoreValue.get())) .replace("%RATING_LABEL%", ratingValue.label().name()) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%MAIN_SCORE_NAME%", scoreValue.score().name().toLowerCase()) .replace("%MAIN_SCORE_VALUE_DETAILS%", highLevelDescriptionOf(scoreValue).make()) .replace("%MAIN_SCORE_DESCRIPTION%", scoreValue.score().description()) .replace("%MAIN_SCORE_EXPLANATION%", explanationOf(scoreValue).make()) .replace("%SUB_SCORE_DETAILS%", descriptionOfSubScoresIn(scoreValue).make()) .replace("%ADVICE%", advice.make()) .replace("%INFO_ABOUT_VULNERABILITIES%", infoAboutVulnerabilitiesIn(scoreValue).make()); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: testEmptyPathSequence() { PathSequence pathSequence = new PathSequence(pathSequenceList); assertTrue(pathSequence.pathSequence.isEmpty()); "<AssertPlaceHolder>"; }
size() { return this.pathSequence.size(); }
[*] target: assertEquals(0, pathSequence.size())
[-] pred: org. junit. Assert. assertEquals ( 0, pathSequence. size ( ) )
************************************
************************************
[+] input: binaryExpressionTest() { // Create the mock data. Map<String, Object> argMaps = createBinaryFilterArgMap("firstName", "contains", "ABC");  // Invoke method under test. FilterExpressionParser expressionParser = new FilterExpressionParser(); Expression expression = expressionParser.parseFilterExpression(argMaps);  // Verify assertions. Assert."<AssertPlaceHolder>"; Assert.assertEquals("(firstName contains ABC)", expression.infix()); }
parseFilterExpression(Map filterArgs) { return createExpressionTree(filterArgs); }
[*] target: assertNotNull(expression)
[-] pred: org. junit. Assert. assertNotNull ( expression )
************************************
************************************
[+] input: compoundExpressionTest() { // Create the mock data. Map<String, Object> argMaps = createCompoundFilterArgMap();  // Invoke method under test. FilterExpressionParser expressionParser = new FilterExpressionParser(); Expression expression = expressionParser.parseFilterExpression(argMaps);  // Verify assertions. Assert."<AssertPlaceHolder>"; Assert.assertEquals("((firstName contains ABC) or (lastName equals XYZ))", expression.infix()); }
parseFilterExpression(Map filterArgs) { return createExpressionTree(filterArgs); }
[*] target: assertNotNull(expression)
[-] pred: org. junit. Assert. assertNotNull ( expression )
************************************
************************************
[+] input: IOException { String webpathStr = "projects/foo/location/earth/datasets/bar/dicomStores/" + "fee/dicomWeb/studies/abc/series/xyz/instances/123";  WebPathParser parser = new WebPathParser(); WebPathParser.DicomWebPath dicomWebPath = parser.parseDicomWebpath(webpathStr);  Assert."<AssertPlaceHolder>"; Assert.assertEquals("foo", dicomWebPath.project); Assert.assertEquals("earth", dicomWebPath.location); Assert.assertEquals("bar", dicomWebPath.dataset); Assert.assertEquals("fee", dicomWebPath.storeId); Assert.assertEquals("abc", dicomWebPath.studyId); Assert.assertEquals("xyz", dicomWebPath.seriesId); Assert.assertEquals("123", dicomWebPath.instanceId); Assert.assertEquals( "projects/foo/location/earth/datasets/bar/dicomStores/fee", dicomWebPath.dicomStorePath); }
parseDicomWebpath(String unparsedWebpath) throws IOException { String[] webPathSplit = unparsedWebpath.split("/dicomWeb/");  if (webPathSplit.length != 2) { throw new IOException("Invalid DICOM web path"); }  DicomWebPath dicomWebPath = new DicomWebPath();  dicomWebPath.dicomStorePath = webPathSplit[0]; String[] storePathElements = dicomWebPath.dicomStorePath.split("/");  if (storePathElements.length < 8) { throw new IOException("Invalid DICOM web path"); } dicomWebPath.project = storePathElements[1]; dicomWebPath.location = storePathElements[3]; dicomWebPath.dataset = storePathElements[5]; dicomWebPath.storeId = storePathElements[7];  String[] searchParameters; searchParameters = webPathSplit[1].split("/"); if (searchParameters.length < 6) { throw new IOException("Invalid DICOM web path"); } dicomWebPath.studyId = searchParameters[1]; dicomWebPath.seriesId = searchParameters[3]; dicomWebPath.instanceId = searchParameters[5];  return dicomWebPath; }
[*] target: assertNotNull(dicomWebPath)
[-] pred: org. junit. Assert. assertNotNull ( dicomWebPath )
************************************
************************************
[+] input: testMatch_iPhoneX_F() { final Data raw = Data.fromHexEncodedString("02011A020A0C0BFF4C001006071EA3DD89E014FF4C0001000000000000000000002000000000000000000000000000000000000000000000000000000000"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; assertEquals("1006071EA3DD89E0", messages.get(0).hexEncodedString()); assertEquals("0100000000000000000000200000000000", messages.get(1).hexEncodedString()); }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertEquals(2, messages.size())
[-] pred: org. junit. Assert. assertEquals ( 2, messages. size ( ) )
************************************
************************************
[+] input: testDeserializeNestedList() { Schema schema = new Schema(required(1, "map_type", Types.MapType .ofRequired(18, 19, Types.StringType.get(), Types.ListType.ofRequired(17, Types.LongType.get())))); Map<String, List> expected = ImmutableMap.of("foo", Arrays.asList(1000L, 2000L, 3000L)); List<Map> data = new ArrayList<>(); data.add(expected);  Record record = TestHelpers.createCustomRecord(schema, data); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> deserialized = (List<Object>) serDe.deserialize(writable); Map result = (Map) deserialized.get(0);  "<AssertPlaceHolder>"; assertTrue(result.containsKey("foo")); assertTrue(result.containsValue(Arrays.asList(1000L, 2000L, 3000L))); }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testRemoteConnectionIDWithNull() { Channel channel = null; ConnectionId connectionId = TransportUtil.remoteConnectionId(channel); Assert.assertNull(connectionId);  Channel channel2 = new EmbeddedChannel(); channel2.close(); ConnectionId connectionId2 = TransportUtil.remoteConnectionId(channel2); Assert."<AssertPlaceHolder>"; }
remoteConnectionId(Channel channel) { if (channel == null || channel.remoteAddress() == null) { return null; } InetSocketAddress address = (InetSocketAddress) channel.remoteAddress(); return ConnectionId.parseConnectionId(address.getHostName(), address.getPort()); }
[*] target: assertNull(connectionId2)
[-] pred: org. junit. Assert. assertNull ( connectionId2 )
************************************
************************************
[+] input: IOException { NettyTransportClient client = (NettyTransportClient) this.oneClient(); client.startSession();  Mockito.doThrow(new RuntimeException("test exception")).when(serverHandler) .handle(Mockito.any(), Mockito.anyInt(), Mockito.any());  ByteBuffer buffer = ByteBuffer.wrap(StringEncodeUtil.encode("test data")); boolean send = client.send(MessageType.MSG, 1, buffer); Assert."<AssertPlaceHolder>";  Whitebox.setInternalState(client, "timeoutFinishSession", 1000L);  Assert.assertThrows(TransportException.class, client::finishSession, e -> { Assert.assertContains("finish-response", e.getMessage()); });  Mockito.verify(serverHandler, Mockito.timeout(10_000L).times(1)) .exceptionCaught(Mockito.any(), Mockito.any()); }
send(MessageType messageType, int partition, ByteBuffer buffer) throws TransportException { if (!this.checkSendAvailable()) { return false; } this.session.sendAsync(messageType, partition, buffer); return true; }
[*] target: assertTrue(send)
[-] pred: org. junit. Assert. assertTrue ( send )
************************************
************************************
[+] input: testSubmitJob() { Map<String, String> params = new HashMap<>(); params.put(KubeSpecOptions.WORKER_INSTANCES.name(), "10"); String jobId = this.driver.submitJob("PageRank", params); HugeGraphComputerJob computerJob = this.operation.withName(KubeUtil.crName(jobId)).get(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(computerJob.getSpec().getAlgorithmName(), "PageRank"); Assert.assertEquals(computerJob.getSpec().getJobId(), jobId); }
submitJob(String algorithmName, Map<String, String> params) { HugeGraphComputerJob computerJob = new HugeGraphComputerJob(); String jobId = KubeUtil.genJobId(algorithmName); String crName = KubeUtil.crName(jobId);  ObjectMeta meta = new ObjectMetaBuilder().withNamespace(this.namespace) .withName(crName) .build(); computerJob.setMetadata(meta);  ComputerJobSpec spec = this.computerJobSpec(this.defaultSpec, params);  Map<String, String> computerConf = this.computerConf(this.defaultConf, params); this.checkComputerConf(computerConf, spec);  spec.withAlgorithmName(algorithmName) .withJobId(jobId) .withComputerConf(computerConf);  if (this.enableInternalAlgorithm && this.internalAlgorithms.contains(algorithmName)) { spec.withImage(this.internalAlgorithmImageUrl); } else if (StringUtils.isNotBlank(spec.getRemoteJarUri())) { spec.withImage(this.frameworkImageUrl); } else { String imageUrl = this.buildImageUrl(algorithmName); String jarFileDir = this.conf.get(KubeDriverOptions.JAR_FILE_DIR); String jarFile = this.buildJarFile(jarFileDir, algorithmName); spec.withImage(imageUrl) .withJarFile(jarFile); }  computerJob.setSpec(spec);  this.operation.createOrReplace(computerJob); return jobId; }
[*] target: assertNotNull(computerJob)
[-] pred: org. junit. Assert. assertNotNull ( computerJob )
************************************
************************************
[+] input: IOException { JsonRowDataSerializationSchema.Builder serBuilder = JsonRowDataSerializationSchema.builder(rowType); JsonRowDataSerializationSchema serializationSchema = serBuilder.setCharset(CHARSET.defaultValue()) .setTimestampFormat(ISO_8601) .build(); byte[] serialize = serializationSchema.serialize(testRowData);  ObjectMapper objectMapper = new ObjectMapper(); JsonNode expectedNode = objectMapper.readTree(testJson); JsonNode actualNode = objectMapper.readTree(new String(serialize)); "<AssertPlaceHolder>"; assertFalse(serializationSchema.skipCurrentRecord(testRowData)); }
build() { return new JsonRowDataSerializationSchema( rowType, timestampFormat, mapNullKeyMode, mapNullKeyLiteral, charset, objectMapper, ignoreErrors); }
[*] target: assertEquals(expectedNode, actualNode)
[-] pred: org. junit. Assert. assertEquals ( expectedNode, actualNode )
************************************
************************************
[+] input: Exception { TubeClientConfig clientConfig = mock(TubeClientConfig.class); PowerMockito.mockStatic(AddressUtils.class); PowerMockito.when(AddressUtils.getLocalAddress()).thenReturn("127.0.0.1");  when(clientConfig.getMasterInfo()).thenReturn(new MasterInfo("127.0.0.1:18080")); ConsumerConfig config = new ConsumerConfig("127.0.0.1:18080", "test"); ClientFactory clientFactory = new NettyClientFactory(); TubeBaseSessionFactory factory = new TubeBaseSessionFactory(clientFactory, clientConfig); SimplePushMessageConsumer consumer = new SimplePushMessageConsumer(factory, config); MessageFetchManager fetchManager = new MessageFetchManager(config, consumer);  Assert.assertFalse(fetchManager.isShutdown()); fetchManager.startFetchWorkers(); fetchManager.stopFetchWorkers(true); Assert."<AssertPlaceHolder>"; }
isShutdown() { return this.managerStatus.get() == 0; }
[*] target: assertTrue(fetchManager.isShutdown())
[-] pred: org. junit. Assert. assertTrue ( fetchManager. isShutdown() )
************************************
************************************
[+] input: keyPairWithPasswd() { try { SM2Util instance = new SM2Util(); KeyPair keyPair = instance.generatekeyPair(); String privateKeyPem = SM2Util.pemFrom(keyPair.getPrivate(), passwd); Files.write(Paths.get(encryptedprivFileName), privateKeyPem.getBytes()); PrivateKey key = SM2Util.loadPrivFromFile(encryptedprivFileName, passwd); Assert."<AssertPlaceHolder>"; Assert.assertEquals(keyEqualHint, keyPair.getPrivate(), key); } catch (Exception e) { e.printStackTrace(); Assert.fail(exceptionHappened); } }
loadPrivFromFile(String filename, String password) throws IOException, OperatorCreationException, PKCSException { return loadPriv(password, () -> { try { return new FileReader(filename); } catch (FileNotFoundException e) { throw new RuntimeException("Private key "" + filename + "" not found", e); } }); }
[*] target: assertNotNull(key)
[-] pred: org. junit. Assert. assertNotNull ( key )
************************************
************************************
[+] input: Exception { Map<String, Object> javagm = this.configMap.get("javagm"); Object testdata = javagm.get("testdata");  String cert = (String) ((Map<String, Object>) testdata).get("cert"); Assert.assertNotNull(cert);  X509Certificate certificate = SM2Util.loadX509CertificateFromString(cert); Assert."<AssertPlaceHolder>"; Assert.assertEquals("SM3WITHSM2", certificate.getSigAlgName()); }
loadX509CertificateFromString(String cert) throws IOException, CertificateException, NoSuchProviderException { try (InputStream in = new ByteArrayInputStream(cert.getBytes())) { CertificateFactory cf = CertificateFactory.getInstance("X.509", BouncyCastleProvider.PROVIDER_NAME); return (X509Certificate) cf.generateCertificate(in); } }
[*] target: assertNotNull(certificate)
[-] pred: org. junit. Assert. assertNotNull ( certificate )
************************************
************************************
[+] input: Exception { Topic expectedResponse = Topic.newBuilder() .setName(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartitionConfig(Topic.PartitionConfig.newBuilder().build()) .setRetentionConfig(Topic.RetentionConfig.newBuilder().build()) .setReservationConfig(Topic.ReservationConfig.newBuilder().build()) .build(); mockAdminService.addResponse(expectedResponse);  Topic topic = Topic.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Topic actualResponse = client.updateTopic(topic, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateTopicRequest actualRequest = ((UpdateTopicRequest) actualRequests.get(0));  Assert.assertEquals(topic, actualRequest.getTopic()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateTopic(Topic topic, FieldMask updateMask) { UpdateTopicRequest request = UpdateTopicRequest.newBuilder().setTopic(topic).setUpdateMask(updateMask).build(); return updateTopic(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { Subscription expectedResponse = Subscription.newBuilder() .setName(SubscriptionName.of("[PROJECT]", "[LOCATION]", "[SUBSCRIPTION]").toString()) .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setDeliveryConfig(Subscription.DeliveryConfig.newBuilder().build()) .setExportConfig(ExportConfig.newBuilder().build()) .build(); mockAdminService.addResponse(expectedResponse);  Subscription subscription = Subscription.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Subscription actualResponse = client.updateSubscription(subscription, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateSubscriptionRequest actualRequest = ((UpdateSubscriptionRequest) actualRequests.get(0));  Assert.assertEquals(subscription, actualRequest.getSubscription()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateSubscription(Subscription subscription, FieldMask updateMask) { UpdateSubscriptionRequest request = UpdateSubscriptionRequest.newBuilder() .setSubscription(subscription) .setUpdateMask(updateMask) .build(); return updateSubscription(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { SeekSubscriptionResponse expectedResponse = SeekSubscriptionResponse.newBuilder().build(); Operation resultOperation = Operation.newBuilder() .setName("seekSubscriptionTest") .setDone(true) .setResponse(Any.pack(expectedResponse)) .build(); mockAdminService.addResponse(resultOperation);  SeekSubscriptionRequest request = SeekSubscriptionRequest.newBuilder() .setName(SubscriptionName.of("[PROJECT]", "[LOCATION]", "[SUBSCRIPTION]").toString()) .build();  SeekSubscriptionResponse actualResponse = client.seekSubscriptionAsync(request).get(); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); SeekSubscriptionRequest actualRequest = ((SeekSubscriptionRequest) actualRequests.get(0));  Assert.assertEquals(request.getName(), actualRequest.getName()); Assert.assertEquals(request.getNamedTarget(), actualRequest.getNamedTarget()); Assert.assertEquals(request.getTimeTarget(), actualRequest.getTimeTarget()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
seekSubscriptionAsync( SeekSubscriptionRequest request) { return seekSubscriptionOperationCallable().futureCall(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { Reservation expectedResponse = Reservation.newBuilder() .setName(ReservationName.of("[PROJECT]", "[LOCATION]", "[RESERVATION]").toString()) .setThroughputCapacity(-1174790353) .build(); mockAdminService.addResponse(expectedResponse);  Reservation reservation = Reservation.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Reservation actualResponse = client.updateReservation(reservation, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateReservationRequest actualRequest = ((UpdateReservationRequest) actualRequests.get(0));  Assert.assertEquals(reservation, actualRequest.getReservation()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateReservation(Reservation reservation, FieldMask updateMask) { UpdateReservationRequest request = UpdateReservationRequest.newBuilder() .setReservation(reservation) .setUpdateMask(updateMask) .build(); return updateReservation(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { CommitCursorResponse expectedResponse = CommitCursorResponse.newBuilder().build(); mockCursorService.addResponse(expectedResponse);  CommitCursorRequest request = CommitCursorRequest.newBuilder() .setSubscription("subscription341203229") .setPartition(-1799810326) .setCursor(Cursor.newBuilder().build()) .build();  CommitCursorResponse actualResponse = client.commitCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockCursorService.getRequests(); Assert.assertEquals(1, actualRequests.size()); CommitCursorRequest actualRequest = ((CommitCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getSubscription(), actualRequest.getSubscription()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getCursor(), actualRequest.getCursor()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
commitCursor(CommitCursorRequest request) { return commitCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeMessageStatsResponse expectedResponse = ComputeMessageStatsResponse.newBuilder() .setMessageCount(-1229303081) .setMessageBytes(-1229929933) .setMinimumPublishTime(Timestamp.newBuilder().build()) .setMinimumEventTime(Timestamp.newBuilder().build()) .build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeMessageStatsRequest request = ComputeMessageStatsRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .setStartCursor(Cursor.newBuilder().build()) .setEndCursor(Cursor.newBuilder().build()) .build();  ComputeMessageStatsResponse actualResponse = client.computeMessageStats(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeMessageStatsRequest actualRequest = ((ComputeMessageStatsRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getStartCursor(), actualRequest.getStartCursor()); Assert.assertEquals(request.getEndCursor(), actualRequest.getEndCursor()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeMessageStats(ComputeMessageStatsRequest request) { return computeMessageStatsCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeHeadCursorResponse expectedResponse = ComputeHeadCursorResponse.newBuilder().setHeadCursor(Cursor.newBuilder().build()).build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeHeadCursorRequest request = ComputeHeadCursorRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .build();  ComputeHeadCursorResponse actualResponse = client.computeHeadCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeHeadCursorRequest actualRequest = ((ComputeHeadCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeHeadCursor(ComputeHeadCursorRequest request) { return computeHeadCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeTimeCursorResponse expectedResponse = ComputeTimeCursorResponse.newBuilder().setCursor(Cursor.newBuilder().build()).build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeTimeCursorRequest request = ComputeTimeCursorRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .setTarget(TimeTarget.newBuilder().build()) .build();  ComputeTimeCursorResponse actualResponse = client.computeTimeCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeTimeCursorRequest actualRequest = ((ComputeTimeCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getTarget(), actualRequest.getTarget()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeTimeCursor(ComputeTimeCursorRequest request) { return computeTimeCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: print_json_diffInputNotNullZeroNotNullZeroNotNullOutputNotNull() {  // Arrange final LogBuffer buffer = new LogBuffer(); final long len = 0L; final String columnName = ","; final int columnIndex = 0; final String charsetName = "1a 2b 3c";  // Act final StringBuilder actual = JsonDiffConversion.print_json_diff(buffer, len, columnName, columnIndex, charsetName);  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertEquals(",", actual.toString()); }
print_json_diff(LogBuffer buffer, long len, String columnName, int columnIndex, String charsetName) { int position = buffer.position(); List<String> operation_names = new ArrayList<String>(); while (buffer.hasRemaining()) { int operation_int = buffer.getUint8(); if (operation_int >= JSON_DIFF_OPERATION_COUNT) { throw new IllegalArgumentException("reading operation type (invalid operation code)"); }  // skip path long path_length = buffer.getPackedLong(); if (path_length > len) { throw new IllegalArgumentException("skipping path"); }  // compute operation name byte[] lastP = buffer.getData(buffer.position() + (int) path_length - 1, 1); String operation_name = json_diff_operation_name(operation_int, lastP[0]); operation_names.add(operation_name);  buffer.forward((int) path_length); // skip value if (operation_int != DIFF_OPERATION_REMOVE) { long value_length = buffer.getPackedLong(); if (value_length > len) { throw new IllegalArgumentException("skipping path"); }  buffer.forward((int) value_length); } }  // Print function names in reverse order. StringBuilder builder = new StringBuilder(); for (int i = operation_names.size() - 1; i >= 0; i--) { if (i == 0 || operation_names.get(i - 1) != operation_names.get(i)) { builder.append(operation_names.get(i)).append("("); } }  // Print column id if (columnName != null) { builder.append(columnName); } else { builder.append("@").append(columnIndex); }  // In case this vector is empty (a no-op), make an early return // after printing only the column name if (operation_names.size() == 0) { return builder; }  // Print comma between column name and next function argument builder.append(", "); // Print paths and values. buffer.position(position); int diff_i = 0; while (buffer.hasRemaining()) { // Read operation int operation_int = buffer.getUint8();  // Read path length long path_length = buffer.getPackedLong(); // Print path builder.append(''').append(buffer.getFixString((int) path_length)).append(''');  if (operation_int != DIFF_OPERATION_REMOVE) { // Print comma between path and value builder.append(", "); // Read value length long value_length = buffer.getPackedLong();  Json_Value jsonValue = JsonConversion.parse_value(buffer.getUint8(), buffer, value_length - 1, charsetName); buffer.forward((int) value_length - 1); // Read value if (jsonValue.m_type == Json_enum_type.ERROR) { throw new IllegalArgumentException("parsing json value"); } StringBuilder jsonBuilder = new StringBuilder(); jsonValue.toJsonString(jsonBuilder, charsetName); builder.append(jsonBuilder); }  // Print closing parenthesis if (!buffer.hasRemaining() || operation_names.get(diff_i + 1) != operation_names.get(diff_i)) { builder.append(")"); }  if (buffer.hasRemaining()) { builder.append(", "); } diff_i++; }  return builder; }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: testRemove() { map.put(1, "a"); map.put(2, "b"); Assert.assertEquals("a", map.get(1));  Assert.assertEquals("a", map.remove(1)); Assert.assertEquals(1, map.size()); Assert.assertEquals("b", map.remove(2)); Assert.assertNull(map.remove(2)); Assert."<AssertPlaceHolder>"; }
isEmpty() { return lowestNode() != null; }
[*] target: assertTrue(map.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( map. isEmpty() )
************************************
************************************
[+] input: UnknownHostException { // Try connecting connectionStates.connecting(nodeId1, time.milliseconds(), "localhost", ClientDnsLookup.DEFAULT);  time.sleep(100);  connectionStates.authenticationFailed(nodeId1, time.milliseconds(), new AuthenticationException("No path to CA for certificate!")); time.sleep(1000); assertEquals(connectionStates.connectionState(nodeId1), ConnectionState.AUTHENTICATION_FAILED); assertTrue(connectionStates.authenticationException(nodeId1) instanceof AuthenticationException); assertFalse(connectionStates.hasReadyNodes(time.milliseconds())); assertFalse(connectionStates.canConnect(nodeId1, time.milliseconds()));  time.sleep(connectionStates.connectionDelay(nodeId1, time.milliseconds()) + 1);  assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds())); connectionStates.ready(nodeId1); "<AssertPlaceHolder>"; }
authenticationException(String id) { NodeConnectionState state = nodeState.get(id); return state != null ? state.authenticationException : null; }
[*] target: assertNull(connectionStates.authenticationException(nodeId1))
[-] pred: org. junit. Assert. assertNull ( connectionStates. authenticationException(nodeId1) )
************************************
************************************
[+] input: testBasicCompletion() { RequestFuture<String> future = new RequestFuture<>(); String value = "foo"; future.complete(value); assertTrue(future.isDone()); "<AssertPlaceHolder>"; }
value() { if (!succeeded()) throw new IllegalStateException("Attempt to retrieve value from future which hasn't successfully completed"); return (T) result.get(); }
[*] target: assertEquals(value, future.value())
[-] pred: org. junit. Assert. assertEquals ( value, future. value() )
************************************
************************************
[+] input: testChecksumNullForMagicV2() { ProducerBatch batch = new ProducerBatch(new TopicPartition("topic", 1), memoryRecordsBuilder, now); FutureRecordMetadata future = batch.tryAppend(now, null, new byte[10], Record.EMPTY_HEADERS, null, now); "<AssertPlaceHolder>"; assertNull(future.checksumOrNull()); }
tryAppend(long timestamp, byte[] key, byte[] value, Header[] headers, Callback callback, long now) { if (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) { return null; } else { Long checksum = this.recordsBuilder.append(timestamp, key, value, headers); this.maxRecordSize = Math.max(this.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(), recordsBuilder.compressionType(), key, value, headers)); this.lastAppendTime = now; FutureRecordMetadata future = new FutureRecordMetadata(this.produceFuture, this.recordCount, timestamp, checksum, key == null ? -1 : key.length, value == null ? -1 : value.length, Time.SYSTEM); // we have to keep every future returned to the users in case the batch needs to be // split to several new batches and resent. thunks.add(new Thunk(callback, future)); this.recordCount++; return future; } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testAppendedChecksumMagicV0AndV1() { for (byte magic : Arrays.asList(MAGIC_VALUE_V0, MAGIC_VALUE_V1)) { MemoryRecordsBuilder builder = MemoryRecords.builder(ByteBuffer.allocate(128), magic, CompressionType.NONE, TimestampType.CREATE_TIME, 0L); ProducerBatch batch = new ProducerBatch(new TopicPartition("topic", 1), builder, now); byte[] key = "hi".getBytes(); byte[] value = "there".getBytes();  FutureRecordMetadata future = batch.tryAppend(now, key, value, Record.EMPTY_HEADERS, null, now); "<AssertPlaceHolder>"; byte attributes = LegacyRecord.computeAttributes(magic, CompressionType.NONE, TimestampType.CREATE_TIME); long expectedChecksum = LegacyRecord.computeChecksum(magic, attributes, now, key, value); assertEquals(expectedChecksum, future.checksumOrNull().longValue()); } }
tryAppend(long timestamp, byte[] key, byte[] value, Header[] headers, Callback callback, long now) { if (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) { return null; } else { Long checksum = this.recordsBuilder.append(timestamp, key, value, headers); this.maxRecordSize = Math.max(this.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(), recordsBuilder.compressionType(), key, value, headers)); this.lastAppendTime = now; FutureRecordMetadata future = new FutureRecordMetadata(this.produceFuture, this.recordCount, timestamp, checksum, key == null ? -1 : key.length, value == null ? -1 : value.length, Time.SYSTEM); // we have to keep every future returned to the users in case the batch needs to be // split to several new batches and resent. thunks.add(new Thunk(callback, future)); this.recordCount++; return future; } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: Exception { File trustStoreFile = File.createTempFile("truststore", ".jks"); Map<String, Object> serverSslConfig = TestSslUtils.createSslConfig(false, true, Mode.SERVER, trustStoreFile, "server"); SslFactory sslFactory = new SslFactory(Mode.SERVER); sslFactory.configure(serverSslConfig); //host and port are hints SSLEngine engine = sslFactory.createSslEngine("localhost", 0); "<AssertPlaceHolder>"; String[] expectedProtocols = {"TLSv1.2"}; assertArrayEquals(expectedProtocols, engine.getEnabledProtocols()); assertEquals(false, engine.getUseClientMode()); }
createSslEngine(String peerHost, int peerPort) { return createSslEngine(sslContext, peerHost, peerPort); }
[*] target: assertNotNull(engine)
[-] pred: org. junit. Assert. assertNotNull ( engine )
************************************
************************************
[+] input: testTimeoutOverflow() { Timer timer = time.timer(Long.MAX_VALUE); assertEquals(Long.MAX_VALUE - timer.currentTimeMs(), timer.remainingMs()); "<AssertPlaceHolder>"; }
elapsedMs() { return currentTimeMs - startMs; }
[*] target: assertEquals(0, timer.elapsedMs())
[-] pred: org. junit. Assert. assertEquals ( 0, timer. elapsedMs() )
************************************
************************************
[+] input: shouldInstantiateAndConfigureExplicitlySetHeaderConverterWithCurrentClassLoader() { assertNotNull(props.get(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG)); HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNotNull(headerConverter); assertTrue(headerConverter instanceof TestHeaderConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config"));  headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertTrue(headerConverter instanceof TestHeaderConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config")); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { HeaderConverter plugin = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) plugin = getInstance(config, classPropertyName, HeaderConverter.class); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); Class<? extends HeaderConverter> klass; try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(delegatingLoader.headerConverters()) ); } plugin = newPlugin(klass); } if (plugin == null) { throw new ConnectException("Unable to instantiate the Converter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration:{}{}", System.lineSeparator(), converterConfig); plugin.configure(converterConfig); return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: shouldInstantiateAndConfigureConnectRestExtension() { props.put(WorkerConfig.REST_EXTENSION_CLASSES_CONFIG, TestConnectRestExtension.class.getName()); createConfig();  List<ConnectRestExtension> connectRestExtensions = plugins.newPlugins(config.getList(WorkerConfig.REST_EXTENSION_CLASSES_CONFIG), config, ConnectRestExtension.class); "<AssertPlaceHolder>"; assertEquals("One Rest Extension expected", 1, connectRestExtensions.size()); assertNotNull(connectRestExtensions.get(0)); assertTrue("Should be instance of TestConnectRestExtension", connectRestExtensions.get(0) instanceof TestConnectRestExtension); assertNotNull(((TestConnectRestExtension) connectRestExtensions.get(0)).configs); assertEquals(config.originals(), ((TestConnectRestExtension) connectRestExtensions.get(0)).configs); }
newPlugins(List<String> klassNames, AbstractConfig config, Class<T> pluginKlass) { List<T> plugins = new ArrayList<>(); if (klassNames != null) { for (String klassName : klassNames) { plugins.add(newPlugin(klassName, config, pluginKlass)); } } return plugins; }
[*] target: assertNotNull(connectRestExtensions)
[-] pred: org. junit. Assert. assertNotNull ( connectRestExtensions )
************************************
************************************
[+] input: shouldInstantiateAndConfigureDefaultHeaderConverter() { props.remove(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG); createConfig();  // Because it's not explicitly set on the supplied configuration, the logic to use the current classloader for the connector // will exit immediately, and so this method always returns null HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNull(headerConverter); // But we should always find it (or the worker's default) when using the plugins classloader ... headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertTrue(headerConverter instanceof SimpleHeaderConverter); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { HeaderConverter plugin = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) plugin = getInstance(config, classPropertyName, HeaderConverter.class); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); Class<? extends HeaderConverter> klass; try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(delegatingLoader.headerConverters()) ); } plugin = newPlugin(klass); } if (plugin == null) { throw new ConnectException("Unable to instantiate the Converter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration:{}{}", System.lineSeparator(), converterConfig); plugin.configure(converterConfig); return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: shouldCreateTaskStateDirectory() { final TaskId taskId = new TaskId(0, 0); final File taskDirectory = directory.directoryForTask(taskId); "<AssertPlaceHolder>"; assertTrue(taskDirectory.isDirectory()); }
directoryForTask(final TaskId taskId) { final File taskDir = new File(stateDir, taskId.toString()); if (createStateDirectory && !taskDir.exists() && !taskDir.mkdir()) { throw new ProcessorStateException( String.format("task directory [%s] doesn't exist and couldn't be created", taskDir.getPath())); } return taskDir; }
[*] target: assertTrue(taskDirectory.exists())
[-] pred: org. junit. Assert. assertTrue ( taskDirectory. exists ( ) )
************************************
************************************
[+] input: shouldCreateWriteBatches() { final String key = "a"; final Collection<KeyValue<byte[], byte[]>> records = new ArrayList<>(); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[0])).get(), serializeValue(50L))); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[3])).get(), serializeValue(100L))); final Map<KeyValueSegment, WriteBatch> writeBatchMap = bytesStore.getWriteBatches(records); "<AssertPlaceHolder>"; for (final WriteBatch batch : writeBatchMap.values()) { assertEquals(1, batch.count()); } }
getWriteBatches(final Collection<KeyValue<byte[], byte[]>> records) { // advance stream time to the max timestamp in the batch for (final KeyValue<byte[], byte[]> record : records) { final long timestamp = keySchema.segmentTimestamp(Bytes.wrap(record.key)); observedStreamTime = Math.max(observedStreamTime, timestamp); }  final Map<KeyValueSegment, WriteBatch> writeBatchMap = new HashMap<>(); for (final KeyValue<byte[], byte[]> record : records) { final long timestamp = keySchema.segmentTimestamp(Bytes.wrap(record.key)); final long segmentId = segments.segmentId(timestamp); final KeyValueSegment segment = segments.getOrCreateSegmentIfLive(segmentId, context, observedStreamTime); if (segment != null) { // This handles the case that state store is moved to a new client and does not // have the local RocksDB instance for the segment. In this case, toggleDBForBulkLoading // will only close the database and open it again with bulk loading enabled. if (!bulkLoadSegments.contains(segment)) { segment.toggleDbForBulkLoading(true); // If the store does not exist yet, the getOrCreateSegmentIfLive will call openDB that // makes the open flag for the newly created store. // if the store does exist already, then toggleDbForBulkLoading will make sure that // the store is already open here. bulkLoadSegments = new HashSet<>(segments.allSegments()); } try { final WriteBatch batch = writeBatchMap.computeIfAbsent(segment, s -> new WriteBatch()); if (record.value == null) { batch.delete(record.key); } else { batch.put(record.key, record.value); } } catch (final RocksDBException e) { throw new ProcessorStateException("Error restoring batch to store " + this.name, e); } } } return writeBatchMap; }
[*] target: assertEquals(2, writeBatchMap.size())
[-] pred: org. junit. Assert. assertEquals ( 2, writeBatchMap. size ( ) )
************************************
************************************
[+] input: testGetTaskRunDetail() { TaskRun taskRun = prepareData(); TaskRunVO existedRun = taskRunService.getTaskRunDetail(taskRun.getId()).get(); "<AssertPlaceHolder>"; assertNotNull(existedRun.getTask()); }
getTaskRunDetail(Long taskRunId) { Optional<TaskRun> taskRun = taskRunDao.fetchTaskRunById(taskRunId); return taskRun.map(this::convertToVO); }
[*] target: assertNotNull(existedRun)
[-] pred: org. junit. Assert. assertNotNull ( existedRun )
************************************
************************************
[+] input: SemanticException { SubstringDomain assume1 = domainB.assume(YSubstringOfX, null, null, null); SubstringDomain assume2 = domainB.assume(XEndsWithY, null, null, null); SubstringDomain assume3 = domainB.assume(XStartsWithY, null, null, null);  "<AssertPlaceHolder>"; assertEquals(assume1, assume3); assertTrue(assume1.getState(x).contains(y)); assertTrue(assume1.getState(x).contains(w)); assertTrue(assume1.getState(x).contains(z)); assertTrue(assume1.getState(y).contains(z)); }
assume( ValueExpression expression, ProgramPoint src, ProgramPoint dest, SemanticOracle oracle) throws SemanticException {  /* * Assume only binary expressions */ if (expression instanceof BinaryExpression) {  BinaryExpression binaryExpression = (BinaryExpression) expression; BinaryOperator binaryOperator = binaryExpression.getOperator();  SymbolicExpression left = binaryExpression.getLeft(); SymbolicExpression right = binaryExpression.getRight();  /* * The string type is unique and can be retrieved from the type * system. */ Type strType; if (src != null) // Correct: get the string type from the program // point strType = src.getProgram().getTypes().getStringType(); else // Used in tests where src is null, get the string type from // the expression strType = left.getStaticType();  if (binaryOperator instanceof StringContains || binaryOperator instanceof StringStartsWith || binaryOperator instanceof StringEndsWith) {  /* * Evaluate only if the left operand is an identidier */  if (!(left instanceof Identifier)) return this;  if (!(right instanceof ValueExpression)) throw new SemanticException("instanceof right");  Set<SymbolicExpression> extracted = extrPlus((ValueExpression) right, src, oracle, strType); SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.add(extracted, (Identifier) left); result = result.closure(); return result.clear();  } else if (binaryOperator instanceof StringEquals) {  // case both operands are identifiers if ((left instanceof Identifier) && (right instanceof Identifier)) { SubstringDomain result = mk(lattice, mkNewFunction(function, false)); result = result.add(left, (Identifier) right); result = result.add(right, (Identifier) left); result = result.closure(); return result.clear(); } // case where only one is an identifier else if ((left instanceof Identifier) || (right instanceof Identifier)) { if (right instanceof Identifier) { // make left the identifier SymbolicExpression temp = left; left = right; right = temp; }  if (!(right instanceof ValueExpression)) throw new SemanticException("instanceof right != ValueExpression.class");  Set<SymbolicExpression> add = extrPlus((ValueExpression) right, src, oracle, strType);  SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.add(add, (Identifier) left); result = result.closure(); return result.clear();  } } else if (binaryOperator instanceof LogicalOr || binaryOperator instanceof LogicalAnd) {  if (!(left instanceof ValueExpression) || !(right instanceof ValueExpression)) throw new SemanticException( "!(left instanceof ValueExpression) || !(right instanceof ValueExpression)");  ValueExpression rightValueExpression = (ValueExpression) right; ValueExpression leftValueExpression = (ValueExpression) left; SubstringDomain leftDomain = assume(leftValueExpression, src, dest, oracle); SubstringDomain rightDomain = assume(rightValueExpression, src, dest, oracle);  if (binaryOperator instanceof LogicalOr) { return leftDomain.lub(rightDomain).clear(); } else { return leftDomain.glb(rightDomain).clear(); } }  }  return this; }
[*] target: assertEquals(assume1, assume2)
[-] pred: org. junit. Assert. assertEquals ( assume1, assume2 )
************************************
************************************
[+] input: testFetchingExecutorForValidCommand() { final CommandExecutor commandExecutor = factory.getCommandExecutor(new Command("leave 1")); "<AssertPlaceHolder>"; assertTrue(commandExecutor instanceof LeaveCommandExecutor); }
getCommandExecutor(final Command command) { final CommandExecutor commandExecutor = commands.get(command.getCommandName()); if (commandExecutor == null) { throw new InvalidCommandException(); } return commandExecutor; }
[*] target: assertNotNull(commandExecutor)
[-] pred: org. junit. Assert. assertNotNull ( commandExecutor )
************************************
************************************
[+] input: InterruptedException { Path file = Paths.get(getTestLog("utf8.log"));  byte[] data = Files.readAllBytes(file);  int nonLatinCharOffset = -1; for (int i = 0; i < data.length; i++) { if (data[i] < 0) { assert data[i + 1] < 0; nonLatinCharOffset = i; break; } }  assert nonLatinCharOffset >= 0;  Log log = getLogService().openLog(file, new SimpleLogFormat(StandardCharsets.UTF_8));  Pair<String, Integer> pair = log.loadContent(0, nonLatinCharOffset + 1).get();  int dataLen = pair.getSecond();  "<AssertPlaceHolder>"; assertEquals(new String(Arrays.copyOf(data, dataLen), StandardCharsets.UTF_8), pair.getFirst()); }
loadContent(long offset, int length) { CompletableFuture<Pair<String, Integer>> res = new CompletableFuture<>();  executor.submit(() -> { try { if (!accessManager.isFileVisible(file)) { res.completeExceptionally(new SecurityException(accessManager.errorMessage(file))); return; }  if (length > ParserConfig.MAX_LINE_LENGTH) throw new IllegalStateException();  try (RandomAccessFile input = new RandomAccessFile(file.toFile(), "r")) { input.seek(offset);  byte[] data = new byte[length]; input.readFully(data);  res.complete(Utils.decode(data, encoding)); } } catch (Throwable e) { res.completeExceptionally(e); } });  return res; }
[*] target: assertEquals(nonLatinCharOffset, dataLen)
[-] pred: org. junit. Assert. assertEquals ( nonLatinCharOffset, dataLen )
************************************
************************************
[+] input: testEquals() { RoleDTO roleDTO = new RoleDTO(1L, "USER"); RoleDTO roleDTO2 = new RoleDTO(1L, "USER");  assertTrue(roleDTO.equals(roleDTO)); assertFalse(roleDTO.equals("WRONG")); "<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) return true; if (!(o instanceof RoleDTO)) return false; return id != null && id.equals(((RoleDTO) o).getId()); }
[*] target: assertTrue(roleDTO.equals(roleDTO2))
[-] pred: org. junit. Assert. assertTrue ( roleDTO. equals ( roleDTO2 ) )
************************************
************************************
[+] input: given_existing_user_when_getUserById_returnUser() { Long userId = 1L;  User user = getUserTestData(userId, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findById(userId)).willReturn(Optional.of(user));  User userRet = userService.getUserById(userId);  "<AssertPlaceHolder>"; assertEquals(userId, userRet.getId()); assertEquals("andrea", userRet.getUsername()); assertEquals("Andrea", userRet.getName()); assertEquals("Giassi", userRet.getSurname()); assertEquals("andrea.test@gmail.com", userRet.getContact().getEmail()); assertEquals("+3531122334455", userRet.getContact().getPhone()); }
getUserById(Long id) { if (id == null) { throw new InvalidUserIdentifierException("User Id cannot be null"); } Optional<User> userOpt = userRepository.findById(id); if (userOpt.isPresent()) { return userOpt.get(); } throw new UserNotFoundException(String.format("User not found for Id = %s", id)); }
[*] target: assertNotNull(userRet)
[-] pred: org. junit. Assert. assertNotNull ( userRet )
************************************
************************************
[+] input: given_existing_username_when_getUserByUsername_return_user() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findByUsername("andrea")).willReturn(userDataForTest);  User user = userService.getUserByUsername("andrea");  "<AssertPlaceHolder>"; assertEquals(Long.valueOf(1L), user.getId()); assertEquals("andrea", user.getUsername()); assertEquals("Andrea", user.getName()); assertEquals("Giassi", user.getSurname()); assertEquals("andrea.test@gmail.com", user.getContact().getEmail()); assertEquals("+3531122334455", user.getContact().getPhone()); }
getUserByUsername(String username) { if (username == null) { throw new InvalidUsernameException("username cannot be null"); } return userRepository.findByUsername(username); }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_existing_email_when_getUserByEmail_return_user() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findByEmail("andrea.test@gmail.com")).willReturn(userDataForTest);  User user = userService.getUserByEmail("andrea.test@gmail.com");  "<AssertPlaceHolder>"; assertEquals(Long.valueOf(1L), user.getId()); assertEquals("andrea", user.getUsername()); assertEquals("Andrea", user.getName()); assertEquals("Giassi", user.getSurname()); assertEquals("andrea.test@gmail.com", user.getContact().getEmail()); assertEquals("+3531122334455", user.getContact().getPhone()); }
getUserByEmail(String email) { if (email == null) { throw new InvalidEmailException("email cannot be null"); } return userRepository.findByEmail(email); }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_validUserAndRoleIds_when_addRole_returnUser() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findById(1L)).willReturn(Optional.of(userDataForTest));  Role roleAdmin = new Role(Role.ADMINISTRATOR, "Administrator");  given(roleRepository.findById(2L)).willReturn(Optional.of(roleAdmin));  User user = userService.addRole(1L, 2L);  "<AssertPlaceHolder>";  // check the new added role Set<Role> roleSet = user.getRoles();  assertNotNull(roleSet); assertEquals(2, roleSet.size()); assertTrue(roleSet.contains(roleAdmin)); }
addRole(Long id, Long roleId) { // check user Optional<User> userOpt = userRepository.findById(id); if (!userOpt.isPresent()) { throw new UserNotFoundException(String.format("User not found with Id = %s", id)); } User user = userOpt.get();  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); }  Role role = roleOpt.get();  user.getRoles().add(role); user.setUpdatedDt(LocalDateTime.now());  userRepository.save(user); log.info(String.format("Added role %s on user id = %s", role.getRole(), user.getId()));  return user; }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_validUserAndRoleIds_when_removeRole_returnUser() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  Role roleAdmin = new Role(Role.ADMINISTRATOR, "Administrator"); userDataForTest.getRoles().add(roleAdmin);  given(userRepository.findById(1L)).willReturn(Optional.of(userDataForTest)); given(roleRepository.findById(2L)).willReturn(Optional.of(roleAdmin));  User user = userService.removeRole(1L, 2L);  "<AssertPlaceHolder>";  // check the remove role Set<Role> roleSet = user.getRoles();  assertNotNull(roleSet); assertEquals(1, roleSet.size()); assertTrue(!roleSet.contains(roleAdmin)); }
removeRole(Long id, Long roleId) { // check user Optional<User> userOpt = userRepository.findById(id); if (!userOpt.isPresent()) { throw new UserNotFoundException(String.format("User not found with Id = %s", id)); } User user = userOpt.get();  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); }  Role role = roleOpt.get();  user.getRoles().remove(role); user.setUpdatedDt(LocalDateTime.now());  userRepository.save(user); log.info(String.format("Removed role %s on user id = %s", role.getRole(), user.getId()));  return user; }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: Exception { ComponentName cn = new ComponentName(getContext(), TEST_ACTIVITY); initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), false  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: Exception { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = new ComponentName(mContext.getPackageName(), "placeholder-do"); WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), true  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: backupAccountToKeyStoreTest() { //Create password accounts Chain chain = new Chain(); chain.setConfig(new ConfigBean(chainId, assetId)); List<Account> accountList = accountService.createAccount(chain, 1, password); String address = accountList.get(0).getAddress().getBase58(); //Test not specifying backup path String pathDir = ""; //Backup accountkeystore  backup account keyStore String path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); assertNotNull(path);  //Test specified nonwindowsBackup path pathDir = "test1/back/up"; //Backup accountkeystore  backup account keyStore path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); assertNotNull(path);  //Test specifiedwindowsBackup path pathDir = "D:\\workspace\\github\\nuls_2.0\\test2\\back\\up"; //Create an unencrypted account for test accountList = accountService.createAccount(chain, 1, null); address = accountList.get(0).getAddress().getBase58(); //Backup accountkeystore  backup account keyStore path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); "<AssertPlaceHolder>";  }
backupAccountToKeyStore(String path, int chainId, String address, String password);
[*] target: assertNotNull(path)
[-] pred: org. junit. Assert. assertNotNull ( path )
************************************
************************************
[+] input: Exception { // create account Alias alias = AliasStorageServiceTest.createAlias(); boolean result = aliasService.aliasTxCommit(chainId,alias); "<AssertPlaceHolder>"; Account account = accountService.getAccount(chainId, AddressTool.getStringAddressByBytes(alias.getAddress())); assertNotNull(account); assertEquals(account.getAlias(),alias.getAlias()); }
aliasTxCommit(int chainId, Alias alias) throws NulsException;
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { Alias alias1 = createAlias(); boolean result = aliasStorageService.saveAlias(chainId,alias1); assertTrue(result); Alias alias2 = createAlias(); result = aliasStorageService.saveAlias(chainId,alias2); "<AssertPlaceHolder>"; }
saveAlias(int chainId, Alias alias);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: NulsException { ProtocolVersion version1 = new ProtocolVersion(); version1.setVersion((byte) 1); version1.setEffectiveRatio((byte) 85); version1.setContinuousIntervalCount((short) 260); String hex = HexUtil.encode(version1.serialize()); ProtocolVersion version2 = new ProtocolVersion(); version2.parse(new NulsByteBuffer(HexUtil.decode(hex))); assertEquals(version1.getVersion(), version2.getVersion()); assertEquals(version1.getEffectiveRatio(), version2.getEffectiveRatio()); "<AssertPlaceHolder>"; assertEquals(version1, version2); }
getContinuousIntervalCount() { return continuousIntervalCount; }
[*] target: assertEquals(version1.getContinuousIntervalCount(), version2.getContinuousIntervalCount())
[-] pred: org. junit. Assert. assertEquals ( version1. getContinuousIntervalCount ( ), version2. getContinuousIntervalCount ( ) )
************************************
************************************
[+] input: dumpSites() { final Context context = ServiceLocator.getInstance().getAppContext();  for (final Site.Type type : Site.Type.values()) { final List<Site> sites = type.getSites(); Log.d(TAG, "\n------------------------------------------\n\n" + type);  for (final Site site : sites) { final EngineId engineId = site.getEngineId(); final SearchEngineConfig config = engineId.getConfig(); assertNotNull(config); final SearchEngine searchEngine = engineId.createSearchEngine(context); "<AssertPlaceHolder>";  Log.d(TAG, "\n" + config + "\n\n" + site + "\n\n" + searchEngine); } } }
createSearchEngine(@NonNull final Context context) { try { final Constructor<? extends SearchEngine> c = clazz.getConstructor(Context.class, SearchEngineConfig.class); return c.newInstance(context.getApplicationContext(), config);  } catch (@NonNull final NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) { throw new IllegalStateException( clazz + " must implement SearchEngine(Context, SearchEngineConfig)", e); } }
[*] target: assertNotNull(searchEngine)
[-] pred: org. junit. Assert. assertNotNull ( searchEngine )
************************************
************************************
[+] input: shouldReturnObjectsByClassAndPattern() { Point point1 = new Point("Point-00001"); pool.addObject(point1); Point point2 = new Point("Point-00002"); pool.addObject(point2); Path path1 = new Path("Point-00003", point1.getReference(), point2.getReference()); pool.addObject(path1);  Set<Point> points = pool.getObjects(Point.class, Pattern.compile("Point.*"));  assertEquals(2, points.size()); assertTrue(points.contains(point1)); "<AssertPlaceHolder>"; }
contains(String objectName) { requireNonNull(objectName, "objectName");  return objectsByName.containsKey(objectName); }
[*] target: assertTrue(points.contains(point2))
[-] pred: org. junit. Assert. assertTrue ( points. contains ( point2 ) )
************************************
************************************
[+] input: shouldReturnObjectsByClass() { Point point1 = new Point("Point-00001"); pool.addObject(point1); Point point2 = new Point("Point-00002"); pool.addObject(point2); Path path1 = new Path("Path-00001", point1.getReference(), point2.getReference()); pool.addObject(path1);  Set<Point> points = pool.getObjects(Point.class);  assertEquals(2, points.size()); assertTrue(points.contains(point1)); "<AssertPlaceHolder>"; }
contains(String objectName) { requireNonNull(objectName, "objectName");  return objectsByName.containsKey(objectName); }
[*] target: assertTrue(points.contains(point2))
[-] pred: org. junit. Assert. assertTrue ( points. contains ( point2 ) )
************************************
************************************
[+] input: findExistingRechargePosition() { Point currentVehiclePoint = new Point("Current vehicle point") .withType(Point.Type.HALT_POSITION); Vehicle vehicle = new Vehicle("Some vehicle") .withRechargeOperation("Do some recharging") .withCurrentPosition(currentVehiclePoint.getReference());  Point locationAccessPoint = new Point("Location access point") .withType(Point.Type.HALT_POSITION);  LocationType rechargeLocType = new LocationType("Recharge location type") .withAllowedOperations(Collections.singletonList(vehicle.getRechargeOperation())); Location location = new Location("Recharge location", rechargeLocType.getReference());  Location.Link link = new Location.Link(location.getReference(), locationAccessPoint.getReference()); location = location.withAttachedLinks(new HashSet<>(Arrays.asList(link)));  locationAccessPoint = locationAccessPoint.withAttachedLinks(new HashSet<>(Arrays.asList(link)));  when(plantModelService.fetchObjects(Location.class)) .thenReturn(Collections.singleton(location)); when(plantModelService.fetchObject(LocationType.class, rechargeLocType.getReference())) .thenReturn(rechargeLocType); when(plantModelService.fetchObject(Point.class, currentVehiclePoint.getReference())) .thenReturn(currentVehiclePoint); when(plantModelService.fetchObject(Point.class, locationAccessPoint.getReference())) .thenReturn(locationAccessPoint);  rechargePosSupplier.initialize();  List<Destination> result = rechargePosSupplier.findRechargeSequence(vehicle); "<AssertPlaceHolder>"; assertThat(result, is(not(empty()))); }
findRechargeSequence(Vehicle vehicle) { requireNonNull(vehicle, "vehicle");  if (vehicle.getCurrentPosition() == null) { return new ArrayList<>(); }  Map<Location, Set<Point>> rechargeLocations = findLocationsForOperation(vehicle.getRechargeOperation(), vehicle, router.getTargetedPoints());  String assignedRechargeLocationName = vehicle.getProperty(PROPKEY_ASSIGNED_RECHARGE_LOCATION); if (assignedRechargeLocationName != null) { Location location = pickLocationWithName(assignedRechargeLocationName, rechargeLocations.keySet()); if (location == null) { return new ArrayList<>(); } // XXX Strictly, we should check whether there is a viable route to the location. return Arrays.asList(createDestination(location, vehicle.getRechargeOperation())); }  String preferredRechargeLocationName = vehicle.getProperty(PROPKEY_PREFERRED_RECHARGE_LOCATION); if (assignedRechargeLocationName != null) { Location location = pickLocationWithName(preferredRechargeLocationName, rechargeLocations.keySet()); if (location != null) { // XXX Strictly, we should check whether there is a viable route to the location. return Arrays.asList(createDestination(location, vehicle.getRechargeOperation())); } }  Location bestLocation = findCheapestLocation(rechargeLocations, vehicle); if (bestLocation != null) { return Arrays.asList(createDestination(bestLocation, vehicle.getRechargeOperation())); }  return new ArrayList<>(); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: returnGraphPathStepsForExistingRoute() { List<Step> steps = pointRouter.getRouteSteps(pointA, pointC); "<AssertPlaceHolder>"; assertThat(steps, is(not(empty()))); }
getRouteSteps(Point srcPoint, Point destPoint) { requireNonNull(srcPoint, "srcPoint"); requireNonNull(destPoint, "destPoint");  long timeBefore = System.currentTimeMillis(); if (Objects.equals(srcPoint.getName(), destPoint.getName())) { return new ArrayList<>(); }  GraphPath<String, ModelEdge> graphPath = algo.getPath(srcPoint.getName(), destPoint.getName()); if (graphPath == null) { return null; }  List<Route.Step> result = translateToSteps(graphPath);  LOG.debug("Looking up route from {} to {} took {} milliseconds.", srcPoint.getName(), destPoint.getName(), System.currentTimeMillis() - timeBefore);  return result; }
[*] target: assertNotNull(steps)
[-] pred: org. junit. Assert. assertNotNull ( steps )
************************************
************************************
[+] input: testMapConstantLabelWithBooleanValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(booleanKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.BOOL).build(); assertEquals(expectedLabel, actualLabel);  LabelDescriptor actualLabel2 = MetricTranslator.mapAttribute(booleanKey("label1"), CUSTOM_PREFIX); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel2)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel2 )
************************************
************************************
[+] input: testGetById() { try (SqlSession sqlSession = getSqlSession()) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.getById(1L); Assert."<AssertPlaceHolder>"; Assert.assertEquals("张无忌", user.getUsername()); Assert.assertEquals("男", user.getSex()); Assert.assertEquals("明教", user.getAddress().get(0)); Assert.assertEquals("教主", user.getAddress().get(1)); } }
getById(Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: testFindTransportWithSelectionHiPriority() { byte[] dummyMessage = new byte[0];  TransportInfo dummyTransport = TransportInfo.of("DUMMY", StaticTransportMetadata.empty()); TransportInfo udpTransport = TransportInfo.of(UDPConstants.NAME, StaticTransportMetadata.empty());  List<TransportInfo> transports = ImmutableList.of(dummyTransport, udpTransport);  Peer peer1 = mock(Peer.class); doAnswer(invocation -> transports.stream()).when(peer1).supportedTransports(); doAnswer( invocation -> "DUMMY".equals(invocation.getArgument(0)) || UDPConstants.NAME.equals(invocation.getArgument(0)) ).when(peer1).supportsTransport(any()); @SuppressWarnings("resource") Transport found = transportManager.findTransport(peer1, dummyMessage); "<AssertPlaceHolder>"; assertEquals("DUMMY", found.name()); }
findTransport(Peer peer, byte[] bytes) { if (peer != null) { // Could probably do something a bit more efficient here with caching and such // once the list of transports supported gets reasonably long.  // Check in priority order for first capable matching transport return this.transports.stream() .filter(t -> peer.supportsTransport(t.name())) .filter(t -> t.canHandle(bytes)) .findFirst() .orElse(this.defaultTransport); } return this.defaultTransport; }
[*] target: assertNotNull(found)
[-] pred: org. junit. Assert. assertNotNull ( found )
************************************
************************************
[+] input: createNoRowsTest() { ExampleTable table = new ColumnarExampleTable(Arrays.asList(ExampleTestTools.attributeInt()));  assertEquals(1, table.getAttributeCount()); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(0, table.size())
[-] pred: org. junit. Assert. assertEquals ( 0, table. size() )
************************************
************************************
[+] input: createNoRowsTwoAttributesRemoveTest() { ExampleTable table = new ColumnarExampleTable( Arrays.asList(ExampleTestTools.attributeInt(), ExampleTestTools.attributeReal())); table.removeAttribute(1);  assertEquals(1, table.getAttributeCount()); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(0, table.size())
[-] pred: org. junit. Assert. assertEquals ( 0, table. size() )
************************************
************************************
[+] input: InvocationTargetException { Field f = RestrictionBypass.getDeclaredField(this.getClass(), "testField1"); "<AssertPlaceHolder>"; assertSame(f.get(this), testField1); }
getDeclaredField(Class obj, String name) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) { return NativeReflectionBypass.getDeclaredField(obj, name); } else { Method getDeclaredField = Class.class.getMethod("getDeclaredField", String.class); return (Field) getDeclaredField.invoke(obj, name); } }
[*] target: assertNotNull(f)
[-] pred: org. junit. Assert. assertNotNull ( f )
************************************
************************************
[+] input: InvocationTargetException { Field f = RestrictionBypass.getDeclaredField(this.getClass(), "testField2"); "<AssertPlaceHolder>"; assertSame(f.get(this), testField2); }
getDeclaredField(Class obj, String name) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) { return NativeReflectionBypass.getDeclaredField(obj, name); } else { Method getDeclaredField = Class.class.getMethod("getDeclaredField", String.class); return (Field) getDeclaredField.invoke(obj, name); } }
[*] target: assertNotNull(f)
[-] pred: org. junit. Assert. assertNotNull ( f )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = userService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserError() { mockServerReturnObject(USER_MIKE, 0, ERROR_CODE); User user = userService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserAsync() { mockServerReturnObject(USER_MIKE); CompletableFuture<User> userCompletableFuture = userService.getUserAsync(Long100); "<AssertPlaceHolder>"; User user; try { user = userCompletableFuture.get(); } catch (Exception e) { throw new IllegalStateException("userCompletableFuture get error"); } assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserAsync(@Query("id") Long id);
[*] target: assertNotNull(userCompletableFuture)
[-] pred: org. junit. Assert. assertNotNull ( userCompletableFuture )
************************************
************************************
[+] input: getUserReturnResponse() { mockServerReturnObject(USER_MIKE); Response<User> userReturnResponse = userService.getUserReturnResponse(Long100); "<AssertPlaceHolder>"; assertEquals(SUCCESS_CODE, userReturnResponse.code()); User user = userReturnResponse.body(); assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserReturnResponse(@Query("id") Long id);
[*] target: assertNotNull(userReturnResponse)
[-] pred: org. junit. Assert. assertNotNull ( userReturnResponse )
************************************
************************************
[+] input: getUserReturnCall() { mockServerReturnObject(USER_MIKE); Call<User> userReturnCall = userService.getUserReturnCall(Long100); "<AssertPlaceHolder>"; try { Response<User> userResponse = userReturnCall.execute(); assertEquals(SUCCESS_CODE, userResponse.code()); User user = userResponse.body(); assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); } catch (IOException e) { throw new IllegalStateException("userReturnCall execute error"); } }
getUserReturnCall(@Query("id") Long id);
[*] target: assertNotNull(userReturnCall)
[-] pred: org. junit. Assert. assertNotNull ( userReturnCall )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = chooserOkHttpUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = logUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = metaAnnotationUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: distribution() {  SLD.Distribution<Object> actual = SLD.extractDistributions(graph)[0];  SLD.Distribution<Object> expected = new DistributionBuilder(""). access("ws://localhost:4567/access/colours", false) .format(Format.STRING) .license(License.CC) .protocol(Protocol.WebSocket) .security(Security.SSL) .publisher(SLD.extractPublisher(g)) .buildSource(g);   //        expected.describe().stream().forEach(triple -> { //            assertTrue(actual.describe().contains(triple)); //        }); // //        actual.describe().stream().forEach(triple -> { //            assertTrue(expected.describe().contains(triple)); // //        });   SLD.WebDataStream<Object> expectedWebStream = expected.getWebStream(); SLD.WebDataStream<Object> actualWebStream = actual.getWebStream();  "<AssertPlaceHolder>"; }
getWebStream(); }   public interface WebStream<E> extends Describable, Named {  SLD.Publisher publisher();  WebDataStream<E> serve();  }
[*] target: assertEquals(expectedWebStream, actualWebStream)
[-] pred: org. junit. Assert. assertEquals ( expectedWebStream, actualWebStream )
************************************
************************************
[+] input: testWildcards() { CrontabEntry wildcardMinuteEntry = CrontabEntry.parse("* 1 1 1 *"); assertEquals("*", wildcardMinuteEntry.getMinuteAsString()); assertTrue(wildcardMinuteEntry.hasWildcardMinute()); assertFalse(wildcardMinuteEntry.hasWildcardHour()); assertFalse(wildcardMinuteEntry.hasWildcardDayOfMonth()); assertFalse(wildcardMinuteEntry.hasWildcardMonth()); assertTrue(wildcardMinuteEntry.hasWildcardDayOfWeek());  CrontabEntry wildcardHourEntry = CrontabEntry.parse("1 * 1 1 *"); assertEquals("*", wildcardHourEntry.getHourAsString()); assertFalse(wildcardHourEntry.hasWildcardMinute()); assertTrue(wildcardHourEntry.hasWildcardHour()); assertFalse(wildcardHourEntry.hasWildcardDayOfMonth()); assertFalse(wildcardHourEntry.hasWildcardMonth()); assertTrue(wildcardHourEntry.hasWildcardDayOfWeek());  CrontabEntry wildcardDayOfMonth = CrontabEntry.parse("1 1 * 1 *"); assertEquals("*", wildcardDayOfMonth.getDayOfMonthAsString()); assertFalse(wildcardDayOfMonth.hasWildcardMinute()); assertFalse(wildcardDayOfMonth.hasWildcardHour()); assertTrue(wildcardDayOfMonth.hasWildcardDayOfMonth()); assertFalse(wildcardDayOfMonth.hasWildcardMonth()); assertTrue(wildcardDayOfMonth.hasWildcardDayOfWeek());  CrontabEntry wildcardMonth = CrontabEntry.parse("1 1 1 * *"); assertEquals("*", wildcardMonth.getMonthAsString()); assertFalse(wildcardMonth.hasWildcardMinute()); assertFalse(wildcardMonth.hasWildcardHour()); assertFalse(wildcardMonth.hasWildcardDayOfMonth()); assertTrue(wildcardMonth.hasWildcardMonth()); assertTrue(wildcardMonth.hasWildcardDayOfWeek());  CrontabEntry wildcardDayOfWeek = CrontabEntry.parse("1 1 1 1 *"); assertEquals("*", wildcardDayOfWeek.getDayOfWeekAsString()); assertFalse(wildcardDayOfWeek.hasWildcardMinute()); assertFalse(wildcardDayOfWeek.hasWildcardHour()); assertFalse(wildcardDayOfWeek.hasWildcardDayOfMonth()); assertFalse(wildcardDayOfWeek.hasWildcardMonth()); "<AssertPlaceHolder>"; }
hasWildcardDayOfWeek() { return getDayOfWeek().encloses(DAY_OF_WEEK); }
[*] target: assertTrue(wildcardDayOfWeek.hasWildcardDayOfWeek())
[-] pred: org. junit. Assert. assertTrue ( wildcardDayOfWeek. hasWildcardDayOfWeek ( ) )
************************************
************************************
[+] input: builderShouldSetValues() { User user = new User("ziltoid"); AuthenticationInfo authInfo = helper.createAuthenticationInfo("unit-test", user);  "<AssertPlaceHolder>"; assertEquals("ziltoid", authInfo.getPrincipals().getPrimaryPrincipal()); assertThat(authInfo.getPrincipals().getRealmNames(), hasItem("unit-test")); assertEquals(user, authInfo.getPrincipals().oneByType(User.class)); }
createAuthenticationInfo(String realm, User user) { SimplePrincipalCollection collection = new SimplePrincipalCollection();  collection.add(user.getId(), realm); collection.add(user, realm);  return new SimpleAuthenticationInfo(collection, user.getPassword()); }
[*] target: assertNotNull(authInfo)
[-] pred: org. junit. Assert. assertNotNull ( authInfo )
************************************
************************************
[+] input: IOException { // without default branch, the repository head should be used FileObject root = createCommand().getBrowserResult(new BrowseCommandRequest()).getFile(); assertNotNull(root);  Collection<FileObject> foList = root.getChildren(); "<AssertPlaceHolder>"; assertFalse(foList.isEmpty());  assertThat(foList) .extracting("name") .containsExactly("c", "a.txt", "b.txt", "f.txt"); }
getChildren() { if (!sorted) { sort(children, entry -> entry.type != TreeType.FILE, TreeEntry::getNameString); sorted = true; } return children; }
[*] target: assertNotNull(foList)
[-] pred: org. junit. Assert. assertNotNull ( foList )
************************************
************************************
[+] input: IOException { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(2, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); line = result.getLine(1); assertEquals(2, line.getLineNumber()); assertEquals("2baab8e80280ef05a9aa76c49c76feca2872afb7", line.getRevision()); checkDate(line.getWhen()); assertEquals("line for blame", line.getCode()); assertEquals("added new line for blame", line.getDescription()); assertEquals("Zaphod Beeblebrox", line.getAuthor().getName()); assertEquals("zaphod.beeblebrox@hitchhiker.com", line.getAuthor().getMail()); }
getBlameResult(BlameCommandRequest request) throws IOException { if (logger.isDebugEnabled()) { logger.debug("get blame result for {}", request); }  AnnotateCommand cmd = AnnotateCommand.on(open());  cmd.rev(HgUtil.getRevision(request.getRevision()));  List<BlameLine> blameLines = Lists.newArrayList(); List<AnnotateLine> lines = cmd.execute(request.getPath()); int counter = 0;  for (AnnotateLine line : lines) { blameLines.add(convert(line, ++counter)); }  return new BlameResult(blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt"); request.setRevision("a9bacaf1b7fa0cebfca71fed4e59ed69a6319427");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(1, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); }
getBlameResult(BlameCommandRequest request) throws IOException { if (logger.isDebugEnabled()) { logger.debug("get blame result for {}", request); }  AnnotateCommand cmd = AnnotateCommand.on(open());  cmd.rev(HgUtil.getRevision(request.getRevision()));  List<BlameLine> blameLines = Lists.newArrayList(); List<AnnotateLine> lines = cmd.execute(request.getPath()); int counter = 0;  for (AnnotateLine line : lines) { blameLines.add(convert(line, ++counter)); }  return new BlameResult(blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BrowseCommandRequest request = new BrowseCommandRequest();  request.setPath("c");  BrowserResult result = new HgBrowseCommand(cmdContext).getBrowserResult(request);  "<AssertPlaceHolder>";  FileObject c = result.getFile(); assertEquals("c", c.getName()); Collection<FileObject> foList = c.getChildren();  assertThat(foList) .extracting("name") .containsExactly("d.txt", "e.txt");  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(2, foList.size());  FileObject d = null; FileObject e = null;  for (FileObject f : foList) { if ("d.txt".equals(f.getName())) { d = f; } else if ("e.txt".equals(f.getName())) { e = f; } }  assertNotNull(d); assertFalse(d.isDirectory()); assertEquals("d.txt", d.getName()); assertEquals("c/d.txt", d.getPath()); assertEquals("added file d and e in folder c", d.getDescription().get()); assertTrue(d.getLength().getAsLong() > 0); checkDate(d.getCommitDate().getAsLong()); assertNotNull(e); assertFalse(e.isDirectory()); assertEquals("e.txt", e.getName()); assertEquals("c/e.txt", e.getPath()); assertEquals("added file d and e in folder c", e.getDescription().get()); assertTrue(e.getLength().getAsLong() > 0); checkDate(e.getCommitDate().getAsLong()); }
getBrowserResult(BrowseCommandRequest request) throws IOException { HgFileviewCommand cmd = HgFileviewCommand.on(open());  String revision = MoreObjects.firstNonNull(request.getRevision(), "tip"); Changeset c = LogCommand.on(getContext().open()).rev(revision).limit(1).single();  if (c != null) { cmd.rev(c.getNode()); }  if (!Strings.isNullOrEmpty(request.getPath())) { cmd.path(request.getPath()); }  if (request.isDisableLastCommit()) { cmd.disableLastCommit(); }  if (request.isRecursive()) { cmd.recursive(); }  if (request.isDisableSubRepositoryDetection()) { cmd.disableSubRepositoryDetection(); }  cmd.setLimit(request.getLimit()); cmd.setOffset(request.getOffset());  FileObject file = cmd.execute() .orElseThrow(() -> notFound(entity("File", request.getPath()).in("Revision", revision).in(getRepository()))); return new BrowserResult(c == null? "tip": c.getNode(), revision, file); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BrowseCommandRequest request = new BrowseCommandRequest();  request.setRecursive(true);  BrowserResult result = new HgBrowseCommand(cmdContext).getBrowserResult(request);  "<AssertPlaceHolder>";  FileObject root = result.getFile(); Collection<FileObject> foList = root.getChildren();  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(4, foList.size());  FileObject c = getFileObject(foList, "c"); assertTrue(c.isDirectory()); assertEquals(2, c.getChildren().size()); }
getBrowserResult(BrowseCommandRequest request) throws IOException { HgFileviewCommand cmd = HgFileviewCommand.on(open());  String revision = MoreObjects.firstNonNull(request.getRevision(), "tip"); Changeset c = LogCommand.on(getContext().open()).rev(revision).limit(1).single();  if (c != null) { cmd.rev(c.getNode()); }  if (!Strings.isNullOrEmpty(request.getPath())) { cmd.path(request.getPath()); }  if (request.isDisableLastCommit()) { cmd.disableLastCommit(); }  if (request.isRecursive()) { cmd.recursive(); }  if (request.isDisableSubRepositoryDetection()) { cmd.disableSubRepositoryDetection(); }  cmd.setLimit(request.getLimit()); cmd.setOffset(request.getOffset());  FileObject file = cmd.execute() .orElseThrow(() -> notFound(entity("File", request.getPath()).in("Revision", revision).in(getRepository()))); return new BrowserResult(c == null? "tip": c.getNode(), revision, file); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { HgLogCommand command = createCommand(); String revision = "a9bacaf1b7fa0cebfca71fed4e59ed69a6319427"; Changeset c = command.getChangeset(revision, null);  "<AssertPlaceHolder>"; assertEquals(revision, c.getId()); assertEquals("added a and b files", c.getDescription()); checkDate(c.getDate()); assertEquals("Douglas Adams", c.getAuthor().getName()); assertEquals("douglas.adams@hitchhiker.com", c.getAuthor().getMail()); assertEquals("added a and b files", c.getDescription()); ModificationsCommand modificationsCommand = new HgModificationsCommand(cmdContext); Modifications modifications = modificationsCommand.getModifications(revision);  assertNotNull(modifications); assertTrue("modified list should be empty", modifications.getModified().isEmpty()); assertTrue("removed list should be empty", modifications.getRemoved().isEmpty()); assertFalse("added list should not be empty", modifications.getAdded().isEmpty()); assertEquals(2, modifications.getAdded().size()); assertThat(modifications.getAdded()) .extracting("path") .containsExactly("a.txt", "b.txt"); }
getChangeset(String id, LogCommandRequest request) { org.javahg.Repository repository = open(); HgLogChangesetCommand cmd = on(repository);  return cmd.rev(id).single(); }
[*] target: assertNotNull(c)
[-] pred: org. junit. Assert. assertNotNull ( c )
************************************
************************************
[+] input: testGetBlameResultWithRevision() { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt"); request.setRevision("3");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(1, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); }
getBlameResult(BlameCommandRequest request) { String path = request.getPath(); String revision = request.getRevision(); List<BlameLine> blameLines = Lists.newArrayList(); SVNRevision endRevision = null;  if (Util.isNotEmpty(revision)) { endRevision = SVNRevision.create(Long.parseLong(revision)); } else { endRevision = SVNRevision.HEAD; }  try { SVNURL svnurl = SVNURL.fromFile(new File(context.getDirectory(), path)); SVNRepository svnRepository = SVNRepositoryFactory.create(context.createUrl()); ISVNAuthenticationManager svnManager = svnRepository.getAuthenticationManager(); SVNLogClient svnLogClient = new SVNLogClient(svnManager, null);  svnLogClient.doAnnotate(svnurl, SVNRevision.UNDEFINED, SVNRevision.create(1l), endRevision, new SvnBlameHandler(svnRepository, path, blameLines)); } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not create blame result", ex); }  return new BlameResult(blameLines.size(), blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testBrowse() { BrowserResult result = createCommand().getBrowserResult(new BrowseCommandRequest());  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("c", "a.txt");  Iterator<FileObject> iterator = foList.iterator(); FileObject c = iterator.next(); FileObject a = iterator.next();  assertFalse(a.isDirectory()); assertEquals("a.txt", a.getName()); assertEquals("a.txt", a.getPath()); assertEquals("added line for blame test", a.getDescription().get()); assertTrue(a.getLength().getAsLong() > 0); checkDate(a.getCommitDate().getAsLong()); assertTrue(c.isDirectory()); assertEquals("c", c.getName()); assertEquals("c", c.getPath()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testBrowseSubDirectory() { BrowseCommandRequest request = new BrowseCommandRequest();  request.setPath("c");  BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("d.txt", "e.txt");  Iterator<FileObject> iterator = foList.iterator(); FileObject d = iterator.next(); FileObject e = iterator.next();  assertNotNull(d); assertFalse(d.isDirectory()); assertEquals("d.txt", d.getName()); assertEquals("c/d.txt", d.getPath()); assertEquals("added d and e in folder c", d.getDescription().get()); assertTrue(d.getLength().getAsLong() > 0); checkDate(d.getCommitDate().getAsLong()); assertNotNull(e); assertFalse(e.isDirectory()); assertEquals("e.txt", e.getName()); assertEquals("c/e.txt", e.getPath()); assertEquals("added d and e in folder c", e.getDescription().get()); assertTrue(e.getLength().getAsLong() > 0); checkDate(e.getCommitDate().getAsLong()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testRecursive() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setRecursive(true); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(2, foList.size());  FileObject c = getFileObject(foList, "c"); assertEquals("c", c.getName()); assertTrue(c.isDirectory()); assertEquals(2, c.getChildren().size()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testLimit() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setLimit(1); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("c", "a.txt"); assertThat(result.getFile().isTruncated()).isTrue(); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testOffset() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setOffset(1); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).isEmpty(); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testGetCommit() { Changeset c = createCommand().getChangeset("3", null);  "<AssertPlaceHolder>"; assertEquals("3", c.getId()); assertEquals("remove b and modified a", c.getDescription()); checkDate(c.getDate()); assertEquals("perfect", c.getAuthor().getName()); assertNull("douglas.adams@hitchhiker.com", c.getAuthor().getMail()); SvnModificationsCommand modificationsCommand = new SvnModificationsCommand(createContext()); Modifications modifications = modificationsCommand.getModifications("3");  assertNotNull(modifications); assertEquals(1, modifications.getModified().size()); assertEquals(1, modifications.getRemoved().size()); assertTrue("added list should be empty", modifications.getAdded().isEmpty()); assertEquals("a.txt", modifications.getModified().get(0).getPath()); assertEquals("b.txt", modifications.getRemoved().get(0).getPath()); }
getChangeset(String revision, LogCommandRequest request) { Changeset changeset = null;  if (LOG.isDebugEnabled()) { LOG.debug("fetch changeset {}", revision); }  try { long revisioNumber = parseRevision(revision, repository); Preconditions.checkArgument(revisioNumber > 0, "revision must be greater than zero: %d", revisioNumber); SVNRepository repo = open(); Collection<SVNLogEntry> entries = repo.log(null, null, revisioNumber, revisioNumber, true, true);  if (Util.isNotEmpty(entries)) { changeset = SvnUtil.createChangeset(entries.iterator().next()); } } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not open repository", ex); }  return changeset; }
[*] target: assertNotNull(c)
[-] pred: org. junit. Assert. assertNotNull ( c )
************************************
************************************
[+] input: cleaningCounterVeryOld() { alertCounter.update(new AlertContext(1, new Object[]{"secret", 1})); alertCounter.clean(1002); Assert.assertNull(alertCounter.getOldest()); Assert.assertEquals(0, alertCounter.getSize()); Assert."<AssertPlaceHolder>"; }
isEmpty() { return alertContextHeap.isEmpty(); }
[*] target: assertTrue(alertCounter.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( alertCounter. isEmpty() )
************************************
************************************
[+] input: IOException { when(zooKeeperConnector.getData()).thenReturn(Collections.singletonList(rulesForCorrelation)); AlertingEngineBolt.prepare(null, null, collector);  AlertingEngineBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof AlertMessages); Assert.assertTrue(values.get(1) instanceof ExceptionMessages);  AlertMessages alerts = (AlertMessages)values.get(0); Assert.assertEquals(1, alerts.size()); Assert.assertTrue(alerts.get(0).isCorrelationAlert()); Assert.assertFalse(alerts.get(0).isVisibleAlert());  Assert.assertEquals("siembol_alert_generic_v1", alerts.get(0).getFullRuleName()); Assert.assertTrue(alerts.get(0).getCorrelationKey().isPresent()); Assert.assertEquals("1", alerts.get(0).getCorrelationKey().get()); Assert.assertEquals(100, alerts.get(0).getMaxDayMatches()); Assert.assertEquals(30, alerts.get(0).getMaxHourMatches());  Map<String, Object> parsed = JSON_READER.readValue(alerts.get(0).getAlertJson()); Assert.assertEquals("siembol_alert_generic_v1", parsed.get(AlertingFields.FULL_RULE_NAME.getAlertingName())); Assert.assertEquals(100, parsed.get(AlertingFields.MAX_PER_DAY_FIELD.getAlertingName())); Assert.assertEquals(30, parsed.get(AlertingFields.MAX_PER_HOUR_FIELD.getAlertingName())); Assert.assertEquals("secret", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("secret", parsed.get("sensor")); Assert.assertEquals(1, parsed.get("dummy_field_int")); Assert.assertEquals(false, parsed.get("dummy_field_boolean")); verify(collector, times(1)).ack(eq(tuple)); }
execute(Tuple tuple) { AlertingEngine currentEngine = AlertingEngine.get(); String event = tuple.getStringByField(TupleFieldNames.EVENT.toString()); AlertingResult ret = currentEngine.evaluate(event);  if (ret.getStatusCode() == AlertingResult.StatusCode.OK && ret.getAttributes().getEvaluationResult() == EvaluationResult.NO_MATCH && ret.getAttributes().getExceptionEvents() == null) { LOG.debug(ACK_NO_MATCH_LOG, event); collector.ack(tuple); return; }  AlertMessages matches = new AlertMessages(); ExceptionMessages exceptions = new ExceptionMessages();  if (ret.getStatusCode() != AlertingResult.StatusCode.OK) { exceptions.add(String.format(EXCEPTION_MSG_FORMAT, ret.getAttributes().getException(), event)); }  if (ret.getAttributes().getExceptionEvents() != null) { ret.getAttributes().getExceptionEvents() .forEach( x -> { try { exceptions.add(JSON_WRITER.writeValueAsString(x)); } catch (JsonProcessingException e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  if (ret.getAttributes().getOutputEvents() != null) { ret.getAttributes().getOutputEvents() .forEach( x -> { try { matches.add(new AlertMessage(currentEngine.getAlertingEngineType(), x, JSON_WRITER.writeValueAsString(x))); } catch (Exception e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  collector.emit(tuple, new Values(matches, exceptions)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: IOException { String enriched = EnrichmentEvaluatorLibrary.mergeEnrichments(simpleEvent, enrichments, Optional.of("enrichment_timestamp")); Assert."<AssertPlaceHolder>"; Map<String, Object> map = JSON_MAP_READER.readValue(enriched); Assert.assertEquals(6, map.size()); Assert.assertEquals(1, map.get("timestamp")); Assert.assertEquals(true, map.get("dummy_bool")); Assert.assertEquals("test", map.get("dummy_str")); Assert.assertEquals("b", map.get("a")); Assert.assertEquals("d", map.get("c")); Assert.assertTrue(map.get("enrichment_timestamp") instanceof Number); }
mergeEnrichments(String event, List<Pair<String, String>> enrichments, Optional<String> timestampField) throws IOException { ObjectNode node = (ObjectNode)OBJECT_MAPPER.readTree(event); enrichments.forEach(x -> node.put(x.getKey(), x.getValue())); if (timestampField.isPresent()) { node.put(timestampField.get(), System.currentTimeMillis()); } return node.toString(); }
[*] target: assertNotNull(enriched)
[-] pred: org. junit. Assert. assertNotNull ( enriched )
************************************
************************************
[+] input: Exception { parsingAttributes.setApplicationParserSpecification(simpleSingleApplicationParser.replace( ""parse_metadata" : false", ""parse_metadata" : true" )); parsingApplicationBolt = new ParsingApplicationBolt(attributes, parsingAttributes, zooKeeperConnectorFactory, metricsTestRegistrarFactory); parsingApplicationBolt.prepare(null, null, collector);  when(tuple.getStringByField(eq(ParsingApplicationTuples.METADATA.toString()))).thenReturn("INVALID"); parsingApplicationBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0); Assert.assertEquals(1, messages.size()); Assert.assertEquals("error", messages.get(0).getTopic());  Map<String, Object> parsed = JSON_READER.readValue(messages.get(0).getMessage()); Assert.assertEquals("RAW_LOG", parsed.get("raw_message")); Assert.assertEquals("error", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("parser_error", parsed.get("error_type"));  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counters = (SiembolMetricsCounters)values.get(1); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_APP_ERROR_MESSAGES.getMetricName())); }
execute(Tuple tuple) { ParsingApplicationParser currentParser = parsingApplicationParser.get();  String source = tuple.getStringByField(ParsingApplicationTuples.SOURCE.toString()); String metadata = tuple.getStringByField(ParsingApplicationTuples.METADATA.toString()); Object logObj = tuple.getValueByField(ParsingApplicationTuples.LOG.toString()); if (!(logObj instanceof byte[])) { throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLE); }  byte[] log = (byte[]) logObj; ArrayList<ParsingApplicationResult> results = currentParser.parse(source, metadata, log);  var kafkaWriterMessages = new KafkaWriterMessages(); var counters = new SiembolMetricsCounters(); for (var result : results) { if (result.getResultFlags().contains(ParsingApplicationResult.ResultFlag.FILTERED)) { metricsRegistrar.registerCounter( SiembolMetrics.PARSING_SOURCE_TYPE_FILTERED_MESSAGES.getMetricName(result.getSourceType())) .increment(); metricsRegistrar.registerCounter(SiembolMetrics.PARSING_APP_FILTERED_MESSAGES.getMetricName()) .increment(); } else { result.getMessages().forEach(x -> { kafkaWriterMessages.add(new KafkaWriterMessage(result.getTopic(), x)); addCounters(counters, result.getResultFlags(), result.getSourceType()); }); } }  if (!kafkaWriterMessages.isEmpty()) { collector.emit(tuple, new Values(kafkaWriterMessages, counters)); }  collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ActivityInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>";   }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  DeploymentInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testUpdate() { dao.insert(entity);  entity.setProcessDefinitionContent("abc_content");  dao.update( entity);  DeploymentInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>";   Assert.assertTrue("abc_content".equals(result.getProcessDefinitionContent())); }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ExecutionInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testUpdate() { dao.insert(entity);  entity.setActive(true);  dao.update(entity);  ExecutionInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; Assert.assertTrue(entity.isActive());  }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ProcessInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  // 返回删除行数,去掉findAll 接口 dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert.assertNull(result);  result = dao.findOneForUpdate(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOneForUpdate(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testFindOne() { dao.insert(entity);  TaskInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.getClaimTime()); Assert.assertEquals("comment",result.getComment()); Assert.assertEquals("extension",result.getExtension()); }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  TaskInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testQuery() { dao.insert(entity); TaskInstanceQueryParam param = new TaskInstanceQueryParam(); param.setExtension("extension1"); List<TaskInstanceEntity> result = dao.findTaskList(param);  Assert.assertNotNull(result); Assert.assertTrue(result.size() == 0);  param = new TaskInstanceQueryParam(); param.setExtension("extension"); param.setTitle("title"); param.setTag("tag"); param.setComment("comment"); param.setPriority(333); param.setClaimUserId("assign_id");  result = dao.findTaskList(param);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(result.size() == 1); Assert.assertTrue(  result.get(0).getExtension().equals("extension")); }
findTaskList(TaskInstanceQueryParam taskInstanceQueryParam);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: createCustomMusicList() { final String name = "TestMusicList";  MusicList musicList = mMusicStore.createCustomMusicList(name);  assertEquals(name, musicList.getName());  boolean exception = false; try { mMusicStore.createCustomMusicList(MusicStore.MUSIC_LIST_FAVORITE); } catch (IllegalArgumentException e) { exception = true; }  "<AssertPlaceHolder>"; }
createCustomMusicList(@NonNull String name) throws IllegalArgumentException { Preconditions.checkNotNull(name); Preconditions.checkArgument(!name.isEmpty(), "name must not empty"); checkThread();  if (isBuiltInName(name)) { throw new IllegalArgumentException("Illegal music list name, conflicts with built-in name."); }  name = trimName(name);  if (isMusicListExists(name)) { MusicList musicList = getCustomMusicList(name); assert musicList != null; return musicList; }  mAllCustomMusicListName.add(name); MusicListEntity entity = new MusicListEntity(0, name, 0, MusicList.SortOrder.BY_ADD_TIME, new byte[0]); mMusicListEntityBox.put(entity); return new MusicList(entity); }
[*] target: assertTrue(exception)
[-] pred: org. junit. Assert. assertTrue ( exception )
************************************
************************************
[+] input: testNormalizeValidPhoneNumber() { { String inputPhoneNumber = "+1 650-555-1234"; String expectedNormalizedPhoneNumber = "+16505551234"; String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); assertEquals(expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber); } { String inputPhoneNumber = "+640223334444"; String expectedNormalizedPhoneNumber = "+64223334444"; String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); "<AssertPlaceHolder>"; } }
normalizeIfPhoneNumber(String phoneNumber) { if (phoneNumber == null) { return null; }  PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();  try { // Attempt to parse the phone number with default region code "ZZ" (unknown // region) Phonenumber.PhoneNumber parsedPhoneNumber = phoneNumberUtil.parse(phoneNumber.trim(), "ZZ");  // Format the parsed phone number according to E.164 standard phoneNumber = phoneNumberUtil.format(parsedPhoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164); } catch (NumberParseException e) { // Parsing failed, use the original trimmed phone number phoneNumber = phoneNumber.trim(); }  return phoneNumber; }
[*] target: assertEquals(expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber)
[-] pred: org. junit. Assert. assertEquals ( expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // format for Firebase SCrypt hashes stored in supertokens. // $f_scrypt$passwordHash$salt$m=memory$r=rounds$s=saltSeparator  String passwordHash = "passwordHash"; String salt = "salt"; int memory = 14; int rounds = 8; String saltSeparator = "Bw==";  // when password hash is in the regular format { String validPasswordHash = "$" + ParsedFirebaseSCryptResponse.FIREBASE_SCRYPT_PREFIX + "$" + passwordHash + "$" + salt + "$" + "m=" + memory + "$" + "r=" + rounds + "$" + "s=" + saltSeparator;  ParsedFirebaseSCryptResponse response = ParsedFirebaseSCryptResponse.fromHashString(validPasswordHash); assertNotNull(response);  assertEquals(passwordHash, response.passwordHash); assertEquals(salt, response.salt); assertEquals(memory, response.memCost); assertEquals(saltSeparator, response.saltSeparator); }  // with memory, rounds and saltSeparator switched around { String validPasswordHash = "$" + ParsedFirebaseSCryptResponse.FIREBASE_SCRYPT_PREFIX + "$" + passwordHash + "$" + salt + "$" + "s=" + saltSeparator + "$" + "m=" + memory + "$" + "r=" + rounds;  ParsedFirebaseSCryptResponse response = ParsedFirebaseSCryptResponse.fromHashString(validPasswordHash); "<AssertPlaceHolder>";  assertEquals(passwordHash, response.passwordHash); assertEquals(salt, response.salt); assertEquals(memory, response.memCost); assertEquals(saltSeparator, response.saltSeparator); }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
fromHashString(String hash) { try { String[] separatedPasswordHash = hash.split(FIREBASE_SCRYPT_SEPARATOR);  // check that stored password hash contains 7 fields and after splitting, the first field is empty and the // second field has the firebase scrypt prefix if (!(separatedPasswordHash.length == 7 && separatedPasswordHash[0].equals("") && separatedPasswordHash[1].equals(FIREBASE_SCRYPT_PREFIX))) { return null; }  String passwordHash = separatedPasswordHash[2]; String salt = separatedPasswordHash[3]; String saltSeparator = null; Integer memCost = null; Integer rounds = null;  for (int i = 4; i < separatedPasswordHash.length; i++) { if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_MEM_COST_SEPARATOR)) { memCost = Integer.parseInt(separatedPasswordHash[i].split(FIREBASE_SCRYPT_MEM_COST_SEPARATOR)[1]); continue; } if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_ROUNDS_SEPARATOR)) { rounds = Integer.parseInt(separatedPasswordHash[i].split(FIREBASE_SCRYPT_ROUNDS_SEPARATOR)[1]); continue; } if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_SALT_SEPARATOR)) { saltSeparator = separatedPasswordHash[i].split(FIREBASE_SCRYPT_SALT_SEPARATOR)[1]; } }  if (passwordHash == null || salt == null || saltSeparator == null || memCost == null || rounds == null) { return null; } return new ParsedFirebaseSCryptResponse(passwordHash, salt, saltSeparator, rounds, memCost); } catch (Throwable e) { return null; } }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: IOException { String[] args = {"../"};  Utils.setValueInConfig("access_token_validity", "-1"); TestingProcessManager.TestingProcess process = TestingProcessManager.start(args, false); FeatureFlagTestContent.getInstance(process.getProcess()) .setKeyValue(FeatureFlagTestContent.ENABLED_FEATURES, new EE_FEATURES[]{EE_FEATURES.MULTI_TENANCY}); process.startProcess();  ProcessState.EventAndException e = process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.INIT_FAILURE); "<AssertPlaceHolder>"; assertEquals(e.exception.getCause().getMessage(), "'access_token_validity' must be between 1 and 86400000 seconds inclusive. The config file can be " + "found here: " + getConfigFileLocation(process.getProcess()));  assertNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.LOADING_ALL_TENANT_CONFIG, 1000));  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getInstance(Start start) { return (Config) start.getResourceDistributor() .getResource(RESOURCE_KEY); }
[*] target: assertNotNull(e)
[-] pred: org. junit. Assert. assertNotNull ( e )
************************************
************************************
[+] input: Exception { { TestInput input = new TestInput("value"); io.supertokens.utils.Utils.PubPriKey rsa = io.supertokens.utils.Utils.generateNewPubPriKey(); String token = JWT.createAndSignLegacyAccessToken(new Gson().toJsonTree(input), rsa.privateKey, AccessToken.VERSION.V1); TestInput output = new Gson().fromJson( JWT.verifyJWTAndGetPayload(JWT.preParseJWTInfo(token), rsa.publicKey).payload, TestInput.class); assertEquals(input, output); }  { TestInput input = new TestInput("value"); io.supertokens.utils.Utils.PubPriKey rsa = io.supertokens.utils.Utils.generateNewPubPriKey(); String token = JWT.createAndSignLegacyAccessToken(new Gson().toJsonTree(input), rsa.privateKey, AccessToken.VERSION.V2); TestInput output = new Gson().fromJson( JWT.verifyJWTAndGetPayload(JWT.preParseJWTInfo(token), rsa.publicKey).payload, TestInput.class); "<AssertPlaceHolder>"; } }
preParseJWTInfo(String jwt) throws JWTException { initHeader(); String[] splittedInput = jwt.split("\\."); if (splittedInput.length != 3) { throw new JWTException("Invalid JWT"); }  if (splittedInput[0].equals(JWT.HEADERv1)) { return new JWTPreParseInfo(splittedInput, AccessToken.VERSION.V1, null); }  if (splittedInput[0].equals(JWT.HEADERv2)) { return new JWTPreParseInfo(splittedInput, AccessToken.VERSION.V2, null); }  JsonObject parsedHeader = new JsonParser().parse(Utils.convertFromBase64(splittedInput[0])).getAsJsonObject();  if (parsedHeader.get("typ") == null) { throw new JWTException("JWT header missing - typ"); } JsonPrimitive typ = parsedHeader.get("typ").getAsJsonPrimitive(); if (!typ.isString() || !typ.getAsString().equals("JWT")) { throw new JWTException("JWT header mismatch - typ"); }  if (parsedHeader.get("alg") == null) { throw new JWTException("JWT header missing - alg"); } JsonPrimitive alg = parsedHeader.get("alg").getAsJsonPrimitive(); if (!alg.isString() || !alg.getAsString().equals("RS256")) { throw new JWTException("JWT header mismatch - alg"); }  JsonElement versionElement = parsedHeader.get("version"); // We default to using the latest access token version here for JWTs not created by the session recipe String versionString = AccessToken.getVersionStringFromAccessTokenVersion(AccessToken.getLatestVersion());  if (versionElement != null) { JsonPrimitive version = versionElement.getAsJsonPrimitive(); if (!version.isString() || version.getAsString().equals("1") || version.getAsString().equals("2")) { throw new JWTException("JWT header mismatch - version"); }  versionString = version.getAsString(); }  JsonPrimitive kid = parsedHeader.get("kid").getAsJsonPrimitive(); if (parsedHeader.get("kid") == null) { throw new JWTException("JWT header missing - kid"); } if (!kid.isString()) { throw new JWTException("JWT header mismatch - kid"); } return new JWTPreParseInfo(splittedInput, AccessToken.getVersionFromString(versionString), kid.getAsString()); }
[*] target: assertEquals(input, output)
[-] pred: org. junit. Assert. assertEquals ( input, output )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create a user AuthRecipeUserInfo userInfo = EmailPassword.signUp(process.main, "test@example.com", "testPassword");  String externalUserId = "external-test";  UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), externalUserId, null, false);  { // duplicate exception with both supertokensUserId and externalUserId Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), externalUserId, null, false); } catch (Exception e) { error = e; }  assertNotNull(error); assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertTrue(usersIdMappingExistsError.doesExternalUserIdExist); assertTrue(usersIdMappingExistsError.doesSuperTokensUserIdExist); }  { // duplicate exception with superTokensUserId Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), "newExternalId", null, false); } catch (Exception e) { error = e; }  assertNotNull(error); assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertFalse(usersIdMappingExistsError.doesExternalUserIdExist); assertTrue(usersIdMappingExistsError.doesSuperTokensUserIdExist);  }  { // duplicate exception with externalUserId  AuthRecipeUserInfo newUser = EmailPassword.signUp(process.main, "test2@example.com", "testPass123"); Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, newUser.getSupertokensUserId(), externalUserId, null, false); } catch (Exception e) { error = e; }  "<AssertPlaceHolder>"; assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertTrue(usersIdMappingExistsError.doesExternalUserIdExist); assertFalse(usersIdMappingExistsError.doesSuperTokensUserIdExist);  }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  ArrayList<String> nonAuthRecipesWhichDontNeedUserIdMapping = new ArrayList<>( List.of("io.supertokens.pluginInterface.jwt.JWTRecipeStorage", ActiveUsersStorage.class.getName())); Reflections reflections = new Reflections("io.supertokens.pluginInterface"); Set<Class<? extends NonAuthRecipeStorage>> classes = reflections.getSubTypesOf(NonAuthRecipeStorage.class); List<String> names = classes.stream().map(Class::getCanonicalName).collect(Collectors.toList()); List<String> classNames = new ArrayList<>(); for (String name : names) { if (!name.contains("SQLStorage")) { classNames.add(name); } } String externalId = "externalId"; for (String className : classNames) { // Create a User AuthRecipeUserInfo user = EmailPassword.signUp(process.main, "test@example.com", "testPass123");  // create a mapping with the user UserIdMapping.createUserIdMapping(process.main, user.getSupertokensUserId(), externalId, null, false);  // create entry in nonAuth table with externalId StorageLayer.getStorage(process.main) .addInfoToNonAuthRecipesBasedOnUserId(TenantIdentifier.BASE_TENANT, className, externalId);  // try to delete UserIdMapping String errorMessage = null; try { UserIdMapping.deleteUserIdMapping(process.main, user.getSupertokensUserId(), UserIdType.SUPERTOKENS, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } if (!nonAuthRecipesWhichDontNeedUserIdMapping.contains(className)) { "<AssertPlaceHolder>"; assertTrue(errorMessage.contains("UserId is already in use")); } // delete user data AuthRecipe.deleteUser(process.main, user.getSupertokensUserId()); }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
deleteUserIdMapping(Main main, String userId, UserIdType userIdType, boolean force) throws StorageQueryException, ServletException { Storage storage = StorageLayer.getStorage(main); return deleteUserIdMapping( new AppIdentifier(null, null), storage, userId, userIdType, force); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create an EmailPassword User AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123"); // create a mapping for the EmailPassword User UserIdMapping.createUserIdMapping(process.main, user_1.getSupertokensUserId(), "externalId", null, false);  // create some metadata for the user JsonObject data = new JsonObject(); data.addProperty("test", "testData"); UserMetadata.updateUserMetadata(process.main, "externalId", data);  // Create another User AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@example.com", "testPass123");  // try and map user_2 to user_1s superTokensUserId String errorMessage = null; try { UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } "<AssertPlaceHolder>"; assertEquals("Cannot create a userId mapping where the externalId is also a SuperTokens userID", errorMessage);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create user 1 AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123");  // create user 2 AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@example.com", "testPass123");  // create a mapping between User_1 and User_2 with force UserIdMapping.createUserIdMapping(process.main, user_1.getSupertokensUserId(), user_2.getSupertokensUserId(), null, true);  // try and create a mapping between User_2 and User_1 without force String errorMessage = null; try { UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } "<AssertPlaceHolder>"; assertEquals("Cannot create a userId mapping where the externalId is also a SuperTokens userID", errorMessage);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  String userId = "userId"; JsonObject metadata = UserMetadata.getUserMetadata(process.getProcess(), userId);  "<AssertPlaceHolder>"; assertEquals(metadata.entrySet().size(), 0);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserMetadata(Main main, @Nonnull String userId) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserMetadata(new AppIdentifier(null, null), storage, userId); }
[*] target: assertNotNull(metadata)
[-] pred: org. junit. Assert. assertNotNull ( metadata )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  String userId = "userId"; JsonObject update = new JsonObject(); update.addProperty("test", "123"); update.add("testNull", JsonNull.INSTANCE); JsonObject updateResult = UserMetadata.updateUserMetadata(process.getProcess(), userId, update);  JsonObject newMetadata = UserMetadata.getUserMetadata(process.getProcess(), userId);  "<AssertPlaceHolder>"; assertEquals(1, updateResult.entrySet().size()); assertEquals("123", updateResult.get("test").getAsString()); assert (!updateResult.has("testNull"));  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserMetadata(Main main, @Nonnull String userId) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserMetadata(new AppIdentifier(null, null), storage, userId); }
[*] target: assertEquals(updateResult, newMetadata)
[-] pred: org. junit. Assert. assertEquals ( updateResult, newMetadata )
************************************
************************************
[+] input: givenMqttPropertiesWithResponseTopicAndCorrelationData_whenGetMqttPropsProtoBuilder_thenGetExpectedResult() { MqttProperties properties = new MqttProperties(); properties.add(new MqttProperties.BinaryProperty(BrokerConstants.CORRELATION_DATA_PROP_ID, "test".getBytes(StandardCharsets.UTF_8))); properties.add(new MqttProperties.StringProperty(BrokerConstants.RESPONSE_TOPIC_PROP_ID, "test/"));  QueueProtos.MqttPropertiesProto.Builder mqttPropsProtoBuilder = ProtoConverter.getMqttPropsProtoBuilder(properties);  "<AssertPlaceHolder>"; QueueProtos.MqttPropertiesProto proto = mqttPropsProtoBuilder.build(); assertEquals("test/", proto.getResponseTopic()); assertEquals("test", proto.getCorrelationData().toString(StandardCharsets.UTF_8)); }
getMqttPropsProtoBuilder(MqttProperties properties) { Integer payloadFormatIndicator = getPayloadFormatIndicatorFromMqttProperties(properties); String contentType = getContentTypeFromMqttProperties(properties); String responseTopic = MqttPropertiesUtil.getResponseTopicValue(properties); byte[] correlationData = MqttPropertiesUtil.getCorrelationDataValue(properties); if (payloadFormatIndicator != null || contentType != null || responseTopic != null || correlationData != null) { QueueProtos.MqttPropertiesProto.Builder mqttPropertiesBuilder = QueueProtos.MqttPropertiesProto.newBuilder(); if (payloadFormatIndicator != null) { mqttPropertiesBuilder.setPayloadFormatIndicator(payloadFormatIndicator); } if (contentType != null) { mqttPropertiesBuilder.setContentType(contentType); } if (responseTopic != null) { mqttPropertiesBuilder.setResponseTopic(responseTopic); } if (correlationData != null) { mqttPropertiesBuilder.setCorrelationData(ByteString.copyFrom(correlationData)); } return mqttPropertiesBuilder; } return null; }
[*] target: assertNotNull(mqttPropsProtoBuilder)
[-] pred: org. junit. Assert. assertNotNull ( mqttPropsProtoBuilder )
************************************
************************************
[+] input: testDevicePersistedMsgsBucketConfiguration() { DevicePersistedMsgsRateLimitsConfiguration config = new DevicePersistedMsgsRateLimitsConfiguration(); config.setEnabled(true); config.setConfig("100:60,200:120");  BucketConfiguration bucketConfig = config.devicePersistedMsgsBucketConfiguration();  "<AssertPlaceHolder>"; assertEquals(2, bucketConfig.getBandwidths().length);  Bandwidth bw1 = bucketConfig.getBandwidths()[0]; assertEquals(100, bw1.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(60), bw1.getRefillPeriodNanos());  Bandwidth bw2 = bucketConfig.getBandwidths()[1]; assertEquals(200, bw2.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(120), bw2.getRefillPeriodNanos()); }
devicePersistedMsgsBucketConfiguration() { return getBucketConfiguration(); }
[*] target: assertNotNull(bucketConfig)
[-] pred: org. junit. Assert. assertNotNull ( bucketConfig )
************************************
************************************
[+] input: testTotalMsgsBucketConfiguration() { TotalMsgsRateLimitsConfiguration config = new TotalMsgsRateLimitsConfiguration(); config.setEnabled(true); config.setConfig("100:60,200:120");  BucketConfiguration bucketConfig = config.totalMsgsBucketConfiguration();  "<AssertPlaceHolder>"; assertEquals(2, bucketConfig.getBandwidths().length);  Bandwidth bw1 = bucketConfig.getBandwidths()[0]; assertEquals(100, bw1.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(60), bw1.getRefillPeriodNanos());  Bandwidth bw2 = bucketConfig.getBandwidths()[1]; assertEquals(200, bw2.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(120), bw2.getRefillPeriodNanos()); }
totalMsgsBucketConfiguration() { return getBucketConfiguration(); }
[*] target: assertNotNull(bucketConfig)
[-] pred: org. junit. Assert. assertNotNull ( bucketConfig )
************************************
************************************
[+] input: testCleanUpBySize() { int maxPersistedMessages = 10;  deviceMsgCleanUpDao.cleanUpBySize(maxPersistedMessages);  List<DevicePublishMsgEntity> remainingMessages = deviceMsgRepository.findAll(); Assert."<AssertPlaceHolder>";  for (int i = 0; i < maxPersistedMessages; i++) { Assert.assertEquals(i + 10, remainingMessages.get(i).getSerialNumber().intValue()); } }
cleanUpBySize(int maxPersistedMessages) { if (maxPersistedMessages <= 0) { log.error("Only positive numbers are allowed."); return; } log.trace("Cleaning up device publish messages to match max size {}.", maxPersistedMessages);  Page<DeviceSessionCtxEntity> deviceSessionCtxEntities; int pageCounter = 0; do { deviceSessionCtxEntities = deviceSessionCtxRepository.findAll(PageRequest.of(pageCounter++, sessionCtxPageSize)); for (DeviceSessionCtxEntity deviceSessionCtxEntity : deviceSessionCtxEntities) { String clientId = deviceSessionCtxEntity.getClientId(); DevicePublishMsgEntity earliestPersistedMsg = deviceMsgRepository.findEntityByClientIdAfterOffset(clientId, maxPersistedMessages - 1); if (earliestPersistedMsg == null) { log.trace("[{}] No messages to clean up.", clientId); } else { log.trace("[{}] Clearing messages with serial number less than {}.", clientId, earliestPersistedMsg.getSerialNumber()); int removed = deviceMsgRepository.removeAllByClientIdAndSerialNumberLessThan(clientId, earliestPersistedMsg.getSerialNumber()); log.debug("[{}] Removed {} messages.", clientId, removed); } } } while (!deviceSessionCtxEntities.isLast());  }
[*] target: assertEquals(maxPersistedMessages, remainingMessages.size())
[-] pred: org. junit. Assert. assertEquals ( maxPersistedMessages, remainingMessages. size ( ) )
************************************
************************************
[+] input: testFindUserById() { User user = userService.findUserByEmail("sysadmin@thingsboard.org"); Assert.assertNotNull(user); User foundUser = userService.findUserById(user.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(user, foundUser); }
findUserById(UUID userId);
[*] target: assertNotNull(foundUser)
[-] pred: org. junit. Assert. assertNotNull ( foundUser )
************************************
************************************
[+] input: testFindUserCredentials() { User user = userService.findUserByEmail("sysadmin@thingsboard.org"); Assert.assertNotNull(user); UserCredentials userCredentials = userService.findUserCredentialsByUserId(user.getId()); Assert."<AssertPlaceHolder>"; }
findUserCredentialsByUserId(UUID userId);
[*] target: assertNotNull(userCredentials)
[-] pred: org. junit. Assert. assertNotNull ( userCredentials )
************************************
************************************
[+] input: Exception { String base64QrCodeContent = "BTkCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkIjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABNJzYWx0eXJ0Yy5leGFtcGxlLm9yZw==";  QRCodeParser service = new QRCodeParserImpl(); QRCodeParser.Result result = service.parse(Base64.decode(base64QrCodeContent)); "<AssertPlaceHolder>"; assertEquals("saltyrtc.example.org", result.saltyRtcHost); assertEquals(1234, result.saltyRtcPort); assertEquals(true, result.isPermanent); assertTrue(Arrays.equals(result.authToken, new byte[]{ 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35 })); assertTrue(Arrays.equals(result.key, new byte[]{ 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66 }));  //no server key assertNull(result.serverKey); }
parse(@Nullable byte[] payload) throws InvalidQrCodeException {  if(payload == null) { throw new InvalidQrCodeException("invalid payload string"); }  int fixedLength = PROTOCOL_VERSION_LENGTH + OPTIONS_LENGTH + KEY_LENGTH + AUTH_TOKEN_LENGTH + SERVER_KEY_LENGTH + SALTY_RTC_PORT_LENGTH ;  if(payload.length < fixedLength+1) { throw new InvalidQrCodeException("invalid payload length"); }  try { ByteArrayInputStream bis = new ByteArrayInputStream(payload);  byte[] protocolVersionBytes = new byte[PROTOCOL_VERSION_LENGTH]; bis.read(protocolVersionBytes);  int protocolVersion = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(protocolVersionBytes).getShort());  byte[] options = new byte[OPTIONS_LENGTH]; bis.read(options);  boolean isSelfHosted = (options[0] & 0x01) != 0; boolean isPermanent = (options[0] & 0x02) != 0;  byte[] key = new byte[KEY_LENGTH]; bis.read(key);  byte[] authToken = new byte[AUTH_TOKEN_LENGTH]; bis.read(authToken);  // Note: Server public key may consist of only 0 bytes if not defined in Threema Web byte[] serverKey = null; byte[] serverKeyTemporary = new byte[SERVER_KEY_LENGTH]; bis.read(serverKeyTemporary); for (byte b : serverKeyTemporary) { if (b != 0) { serverKey = serverKeyTemporary; break; } }  byte[] portBytes = new byte[SALTY_RTC_PORT_LENGTH]; bis.read(portBytes); int port = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(portBytes).getShort());  String host = new String(payload, fixedLength, payload.length - fixedLength);  return new Result( protocolVersion, isSelfHosted, isPermanent, key, authToken, serverKey, port, host); } catch (IOException x) { throw new InvalidQrCodeException("Invalid Threema Web QR code contents"); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testUnsignedLongToBigInteger() { final BigInteger bigInteger = new BigInteger("18446744073709551610"); final long unsignedLong = bigInteger.longValue(); Assert.assertTrue(unsignedLong < 0); final BigInteger bigInteger2 = UnsignedHelper.unsignedLongToBigInteger(unsignedLong); Assert."<AssertPlaceHolder>"; }
unsignedLongToBigInteger(long val) { if (val >= 0L) { return BigInteger.valueOf(val); } else { int upper = (int) (val >>> 32); int lower = (int) val; return (BigInteger.valueOf(Integer.toUnsignedLong(upper))).shiftLeft(32). add(BigInteger.valueOf(Integer.toUnsignedLong(lower))); } }
[*] target: assertEquals(bigInteger, bigInteger2)
[-] pred: org. junit. Assert. assertEquals ( bigInteger, bigInteger2 )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"support":"the-support-url"}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertEquals("the-support-url", result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject .put("username", "u") .put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"logo":{"dark": "the-dark-logo"}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertEquals("the-dark-logo", result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"logo":{"light": "the-light-logo"}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertEquals("the-light-logo", result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn( new PostJsonResult( "{"contacts":[" + "{"id":"id1","pk":"AQ=="}," + "{"id":"id2","pk":"Aq==","first":"id2-firstname"}," + "{"id":"id3","pk":"Aw==","last":"id3-lastname"}," + "{"id":"id4","pk":"BA==","first": "id4-firstname", "last":"id4-lastname"}" + "]}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(4, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size());  // Verify contacts Assert.assertEquals("id1", result.workContacts.get(0).threemaId); Assert.assertArrayEquals(new byte[]{0x01}, result.workContacts.get(0).publicKey); Assert.assertNull(result.workContacts.get(0).firstName); Assert.assertNull(result.workContacts.get(0).lastName);  Assert.assertEquals("id2", result.workContacts.get(1).threemaId); Assert.assertArrayEquals(new byte[]{0x02}, result.workContacts.get(1).publicKey); Assert.assertEquals("id2-firstname", result.workContacts.get(1).firstName); Assert.assertNull(result.workContacts.get(1).lastName);  Assert.assertEquals("id3", result.workContacts.get(2).threemaId); Assert.assertArrayEquals(new byte[]{0x03}, result.workContacts.get(2).publicKey); Assert.assertNull(result.workContacts.get(2).firstName); Assert.assertEquals("id3-lastname", result.workContacts.get(2).lastName);  Assert.assertEquals("id4", result.workContacts.get(3).threemaId); Assert.assertArrayEquals(new byte[]{0x04}, result.workContacts.get(3).publicKey); Assert.assertEquals("id4-firstname", result.workContacts.get(3).firstName); Assert.assertEquals("id4-lastname", result.workContacts.get(3).lastName); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"mdm":{" + ""override": true," + ""params":{" + ""param-string": "string-param"," + ""param-bool": true," + ""param-int": 123" + "}}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertTrue(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(3, result.mdm.parameters.size());  Assert.assertTrue(result.mdm.parameters.containsKey("param-string")); Assert.assertEquals("string-param", result.mdm.parameters.get("param-string")); Assert.assertTrue(result.mdm.parameters.containsKey("param-bool")); Assert.assertEquals(true, result.mdm.parameters.get("param-bool")); Assert.assertTrue(result.mdm.parameters.containsKey("param-int")); Assert.assertEquals(123, result.mdm.parameters.get("param-int")); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  when(connector.fetchIdentity(eq("ERIC4911"))).thenCallRealMethod(); when(connector.doGet(eq("https://server.url/identity/ERIC4911"))) .thenReturn("{" + ""identity": "ERIC4911"," + ""publicKey": "aGVsbG8="," + ""featureLevel": 3," + ""featureMask": 15," + ""state": 1," + ""type": 2" + "}"); APIConnector.FetchIdentityResult result = connector.fetchIdentity("ERIC4911"); Assert."<AssertPlaceHolder>"; Assert.assertEquals("ERIC4911", result.identity); Assert.assertEquals(15, result.featureMask); Assert.assertEquals(1, result.state); Assert.assertEquals(2, result.type); }
fetchIdentity(String identity) throws ThreemaException, NetworkException, HttpConnectionException { try { String responseStr = doGet(getServerUrl() + "identity/" + identity); JSONObject jsonResponse = new JSONObject(responseStr);  FetchIdentityResult result = new FetchIdentityResult(); result.publicKey = Base64.decode(jsonResponse.getString("publicKey")); result.featureLevel = jsonResponse.optInt("featureLevel"); result.featureMask = jsonResponse.optInt("featureMask"); result.identity = jsonResponse.getString("identity"); result.state = jsonResponse.optInt("state"); result.type = jsonResponse.optInt("type"); return result; } catch (JSONException | IOException e) { throw new NetworkException(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock(); final IdentityStoreInterface identityStore = getIdentityStoreInterfaceMock();  when(identityStore.getIdentity()).thenReturn("FOOBAR12"); when(identityStore.calcSharedSecret(any())).thenReturn(new byte[32]); System.out.println(identityStore.getIdentity()); when(connector.obtainTurnServers(eq(identityStore), eq("voip"))).thenCallRealMethod(); when(connector.postJson(eq("https://server.url/identity/turn_cred"), ArgumentMatchers.any())) .thenReturn("{" + ""token": "/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="," + ""tokenRespKeyPub": "dummy"" + "}") .thenReturn("{" + ""success": true," + ""turnUrls": ["turn:foo", "turn:bar"]," + ""turnUrlsDualStack": ["turn:ds-foo", "turn:ds-bar"]," + ""turnUsername": "s00perturnuser"," + ""turnPassword": "t0psecret"," + ""expiration": 86400" + "}");  APIConnector.TurnServerInfo result = connector.obtainTurnServers(identityStore, "voip"); Assert."<AssertPlaceHolder>"; Assert.assertArrayEquals(new String[] {"turn:foo", "turn:bar"}, result.turnUrls); Assert.assertArrayEquals(new String[] {"turn:ds-foo", "turn:ds-bar"}, result.turnUrlsDualStack); Assert.assertEquals("s00perturnuser", result.turnUsername); Assert.assertEquals("t0psecret", result.turnPassword);  Date expectedExpirationDate = new Date(new Date().getTime() + 86400*1000); Assert.assertTrue(Math.abs(expectedExpirationDate.getTime() - result.expirationDate.getTime()) < 10000); }
obtainTurnServers(IdentityStoreInterface identityStore, String type) throws Exception { if (identityStore == null || identityStore.getIdentity() == null || identityStore.getIdentity().isEmpty()) { return null; }  String url = getServerUrl() + "identity/turn_cred";  // Phase 1: send identity and type JSONObject request = new JSONObject(); request.put("identity", identityStore.getIdentity()); request.put("type", type);  logger.debug("Obtain TURN servers phase 1: sending to server: {}", request); JSONObject p1Result = new JSONObject(this.postJson(url, request)); logger.debug("Obtain TURN servers phase 1: response from server: {}", p1Result);  makeTokenResponse(p1Result, request, identityStore);  // Phase 2: send token response logger.debug("Obtain TURN servers phase 2: sending to server: {}", request); JSONObject p2Result = new JSONObject(this.postJson(url, request)); logger.debug("Obtain TURN servers phase 2: response from server: {}", p2Result);  if (!p2Result.getBoolean("success")) { throw new ThreemaException(p2Result.getString("error")); }  String[] turnUrls = jsonArrayToStringArray(p2Result.getJSONArray("turnUrls")); String[] turnUrlsDualStack = jsonArrayToStringArray(p2Result.getJSONArray("turnUrlsDualStack")); String turnUsername = p2Result.getString("turnUsername"); String turnPassword = p2Result.getString("turnPassword"); int expiration = p2Result.getInt("expiration"); Date expirationDate = new Date(new Date().getTime() + expiration * 1000L);  return new TurnServerInfo(turnUrls, turnUrlsDualStack, turnUsername, turnPassword, expirationDate); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"org":{" + ""name": "monkeybusiness"" + "}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertEquals("monkeybusiness", result.organization.name);  }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertNull(result.organization.name);  }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{" + "directory:{" + "enabled: true," + "cat: {" + ""c1": "Category 1"," + ""c2": "Category 2"," + ""c3": "Category 3"" + "}}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertNull(result.organization.name); Assert.assertTrue(result.directory.enabled); Assert.assertNotNull(result.directory.categories); Assert.assertEquals(3, result.directory.categories.size());  boolean c1 = false; boolean c2 = false; boolean c3 = false;  for(WorkDirectoryCategory c: result.directory.categories) { switch (c.id) { case "c1": Assert.assertFalse("c1 already found", c1); c1 = true; Assert.assertEquals("Category 1", c.name); break; case "c2": Assert.assertFalse("c1 already found", c2); c2 = true; Assert.assertEquals("Category 2", c.name); break; case "c3": Assert.assertFalse("c1 already found", c3); c3 = true; Assert.assertEquals("Category 3", c.name); break; default: Assert.fail("Invalid category " + c.id); } } }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); final IdentityStoreInterface identityStore = getIdentityStoreInterfaceMock(); when(identityStore.getIdentity()).thenReturn("IDENTITY"); JSONObject requiredObject = new JSONObject(); requiredObject .put("username", "u") .put("password", "eric") .put("identity", "IDENTITY") .put("query", "Query String") .put("categories", (new JSONArray()).put("c100")) .put("sort", (new JSONObject()) .put("asc", true) .put("by", "firstName")) .put("page", 1);  when(connector.fetchWorkDirectory(any(), any(), any(), any())).thenCallRealMethod(); when(connector.postJson( eq("https://api-work.threema.ch/directory"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn( "{\n" + "   "contacts": [\n" + "      {\n" + "         "id": "ECHOECHO",\n" + "         "pk": "base64",\n" + "         "first": "Hans",\n" + "         "last": "Nötig",\n" + "         "csi": "CSI_NR",\n" + "         "org": { "name": "Name der Firma/Organisation" },\n" + "         "cat": [\n" + "            "catId1",\n" + "            "catId2"\n" + "         ]\n" + "      }\n" + "   ],\n" + "   "paging": {\n" + "      "size": 10,\n" + "      "total": 8923,\n" + "      "next": 2,\n" + "      "prev": 0\n" + "   }\n" + "}" );  WorkDirectoryFilter filter = new WorkDirectoryFilter(); filter.addCategory(new WorkDirectoryCategory("c100", "Category 100")); filter.query("Query String"); filter.page(1); WorkDirectory result = connector.fetchWorkDirectory("u", "eric", identityStore, filter);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, result.workContacts.size()); Assert.assertEquals("ECHOECHO", result.workContacts.get(0).threemaId); Assert.assertEquals("Hans", result.workContacts.get(0).firstName); Assert.assertEquals("Nötig", result.workContacts.get(0).lastName); Assert.assertEquals("CSI_NR", result.workContacts.get(0).csi); Assert.assertEquals("Name der Firma/Organisation", result.workContacts.get(0).organization.name); Assert.assertEquals(2, result.workContacts.get(0).categoryIds.size()); Assert.assertEquals("catId1", result.workContacts.get(0).categoryIds.get(0)); Assert.assertEquals("catId2", result.workContacts.get(0).categoryIds.get(1)); Assert.assertEquals(10, result.pageSize); Assert.assertEquals(8923, result.totalRecord); Assert.assertEquals(2, result.nextFilter.getPage()); Assert.assertEquals(filter.getQuery(), result.nextFilter.getQuery()); Assert.assertEquals(filter.getCategories(), result.nextFilter.getCategories()); Assert.assertEquals(0, result.previousFilter.getPage()); Assert.assertEquals(filter.getQuery(), result.previousFilter.getQuery()); Assert.assertEquals(filter.getCategories(), result.previousFilter.getCategories()); }
fetchWorkDirectory( @NonNull String username, @NonNull String password, @NonNull IdentityStoreInterface identityStore, @NonNull WorkDirectoryFilter filter ) throws Exception { JSONObject request = new JSONObject(); request.put("username", username); request.put("password", password); request.put("identity", identityStore.getIdentity()); request.put("query", filter.getQuery());  // Filter category if (filter.getCategories() != null && filter.getCategories().size() > 0) { JSONArray jsonCategories = new JSONArray(); for (WorkDirectoryCategory category: filter.getCategories()) { jsonCategories.put(category.id); } request.put("categories", jsonCategories); }  // Sorting JSONObject jsonSort = new JSONObject();  jsonSort.put("asc", filter.isSortAscending()); //noinspection SwitchStatementWithTooFewBranches switch (filter.getSortBy()) { case WorkDirectoryFilter.SORT_BY_LAST_NAME: jsonSort.put("by", "lastName"); break; default: jsonSort.put("by", "firstName"); break; }  request.put("sort", jsonSort);  // Paging request.put("page", filter.getPage());  String data = this.postJson(getWorkServerUrl() + "directory", request);  // Verify request if (data == null || data.length() == 0) { return null; }  JSONObject jsonResponse = new JSONObject(data);  if (jsonResponse.has("contacts") && !jsonResponse.isNull("contacts")) {  // Verify content JSONArray contacts = jsonResponse.getJSONArray("contacts");  int total = contacts.length(); int pageSize = total; WorkDirectoryFilter filterNext = null; WorkDirectoryFilter filterPrevious = null;  if (jsonResponse.has("paging") && !jsonResponse.isNull("paging")) { JSONObject paging = jsonResponse.getJSONObject("paging");  pageSize = paging.optInt("size", pageSize); total = paging.optInt("total", total); if (paging.has("next")) { // Next filter filterNext = filter.copy() .page(jsonResponse.optInt("next", filter.getPage() + 1)); } if (paging.has("prev")) { // Next filter filterPrevious = filter.copy() .page(jsonResponse.optInt("prev", filter.getPage() - 1)); } }  WorkDirectory workDirectory = new WorkDirectory( total, pageSize, filter, filterNext, filterPrevious );  for (int n = 0; n < contacts.length(); n++) { JSONObject contact = contacts.getJSONObject(n);  //validate fields if (contact.has("id") && contact.has("pk")) { WorkDirectoryContact directoryContact = new WorkDirectoryContact( contact.getString("id"), Base64.decode(contact.getString("pk")), contact.has("first") ? (contact.isNull("first") ? null : contact.optString("first")) : null, contact.has("last") ? (contact.isNull("last") ? null : contact.optString("last")) : null, contact.has("csi") ? (contact.isNull("csi") ? null : contact.optString("csi")) : null );  if (!contact.isNull("org")) { JSONObject jsonResponseOrganization = contact.optJSONObject("org");  if (jsonResponseOrganization != null && !jsonResponseOrganization.isNull("name")) { directoryContact.organization.name = jsonResponseOrganization.optString("name"); } }  JSONArray categoryArray = contact.optJSONArray("cat"); if (categoryArray != null) { for (int cN = 0; cN < categoryArray.length(); cN++) { directoryContact.categoryIds.add(categoryArray.getString(cN)); } }  workDirectory.workContacts.add(directoryContact); } }  return workDirectory; }  // Invalid request return null;  }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: DecodingException { SMLReader smlReader = new SMLReader(); SMLSignature signature = smlReader.parsePayloadData(EncodingType.BASE64.decode(SML_DATA_FULL_NEW)); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(signature.getProvidedSignature()); Assert.assertEquals(2918, signature.getMeterPositionAsLong()); Assert.assertEquals("09 01 45 4D 48 00 00 7A C6 62", Utils.toFormattedHex(signature.getServerId())); Assert.assertEquals(65, new BigInteger(Utils.reverseByteOrder(signature.getPagination())).intValue()); Assert.assertEquals(340285, new BigInteger(Utils.reverseByteOrder(signature.getSecondsIndex())).intValue()); Assert.assertEquals(10, new BigInteger(signature.getBytesLog()).intValue()); Assert.assertEquals(8, new BigInteger(new byte[]{signature.getStatus()}).intValue());  LocalDateTime dateTime = LocalDateTime.of(2018, Month.AUGUST, 28, 18, 57, 37); OffsetDateTime offsetDateTime = OffsetDateTime.of(dateTime, ZoneOffset.of("+02:00")); Assert.assertEquals(offsetDateTime, signature.getTimestampAsDate());   }
parsePayloadData(byte[] smlData) throws ValidationException { try { final SMLSignature smlSignature = parseRawSMLBytes(smlData); if (smlSignature == null) { throw new SMLValidationException("Could not read sml data incomplete data", "error.sml.incomplete"); } // will throw an sml validation exception if check fails smlSignature.isDataComplete();  if (smlSignature.getUnit() != 30) { throw new SMLValidationException("Invalid unit present in sml data", "error.sml.invalid.unit"); } return smlSignature; } catch (final IOException e) { throw new SMLValidationException("Could not read sml data, invalid format", e); }  }
[*] target: assertNotNull(signature)
[-] pred: org. junit. Assert. assertNotNull ( signature )
************************************
************************************
[+] input: DecodingException { SMLReader smlReader = new SMLReader(); SMLSignature signature = smlReader.parsePayloadData(EncodingType.BASE64.decode(SML_DATA_TECHNAGON)); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(signature.getProvidedSignature()); Assert.assertEquals(46201, signature.getMeterPositionAsLong()); Assert.assertEquals("09 01 45 4D 48 00 00 7F 92 03", Utils.toFormattedHex(signature.getServerId())); Assert.assertEquals(14, new BigInteger(Utils.reverseByteOrder(signature.getPagination())).intValue()); Assert.assertEquals(83696, new BigInteger(Utils.reverseByteOrder(signature.getSecondsIndex())).intValue()); Assert.assertEquals(59, new BigInteger(signature.getBytesLog()).intValue()); Assert.assertEquals(8, new BigInteger(new byte[]{signature.getStatus()}).intValue());  LocalDateTime dateTime = LocalDateTime.of(2017, Month.NOVEMBER, 23, 15, 13, 07); OffsetDateTime offsetDateTime = OffsetDateTime.of(dateTime, ZoneOffset.of("+00:00")); Assert.assertEquals(offsetDateTime, signature.getTimestampAsDate());   }
parsePayloadData(byte[] smlData) throws ValidationException { try { final SMLSignature smlSignature = parseRawSMLBytes(smlData); if (smlSignature == null) { throw new SMLValidationException("Could not read sml data incomplete data", "error.sml.incomplete"); } // will throw an sml validation exception if check fails smlSignature.isDataComplete();  if (smlSignature.getUnit() != 30) { throw new SMLValidationException("Invalid unit present in sml data", "error.sml.invalid.unit"); } return smlSignature; } catch (final IOException e) { throw new SMLValidationException("Could not read sml data, invalid format", e); }  }
[*] target: assertNotNull(signature)
[-] pred: org. junit. Assert. assertNotNull ( signature )
************************************
************************************
[+] input: checkOutgoingAccess() { FlowElement exclusiveGateway= EntityBuilder.buildExclusiveGateway(); FlowElement outgoningSequence = EntityBuilder.buildSequenceFlow2(); FlowElement outgoningSequence1 = EntityBuilder.buildSequenceFlow3(); Map<String, FlowElement> map = new HashMap<>(); map.put(exclusiveGateway.getKey(), exclusiveGateway); map.put(outgoningSequence.getKey(), outgoningSequence); map.put(outgoningSequence1.getKey(), outgoningSequence1); boolean access = false; try { exclusiveGatewayValidator.checkOutgoing(map, exclusiveGateway); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { List<String> outgoing = flowElement.getOutgoing();  if (CollectionUtils.isEmpty(outgoing)) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_LACK_OUTGOING); }  List<String> outgoingList = flowElement.getOutgoing(); int defaultConditionCount = 0;  for (String outgoingKey : outgoingList) { FlowElement outgoingSequenceFlow = FlowModelUtil.getFlowElement(flowElementMap, outgoingKey);  String condition = FlowModelUtil.getConditionFromSequenceFlow(outgoingSequenceFlow); boolean isDefaultCondition = FlowModelUtil.isDefaultCondition(outgoingSequenceFlow);  if (StringUtils.isBlank(condition) && !isDefaultCondition) { throwElementValidatorException(flowElement, ErrorEnum.EMPTY_SEQUENCE_OUTGOING); } if (isDefaultCondition) { defaultConditionCount++; } }  if (defaultConditionCount > 1) { throwElementValidatorException(flowElement, ErrorEnum.TOO_MANY_DEFAULT_SEQUENCE); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: validateElementKeyNotUnique() { List<FlowElement> flowElementsList = EntityBuilder.buildFlowElementList(); SequenceFlow sequenceFlow1 = new SequenceFlow(); sequenceFlow1.setKey("sequenceFlow1"); sequenceFlow1.setType(FlowElementType.SEQUENCE_FLOW); List<String> sfIncomings = new ArrayList<>(); sfIncomings.add("startEvent1"); sequenceFlow1.setIncoming(sfIncomings); List<String> sfOutgoings = new ArrayList<>(); sfOutgoings.add("userTask1"); sequenceFlow1.setOutgoing(sfOutgoings); flowElementsList.add(sequenceFlow1); FlowModel flowModel = new FlowModel(); flowModel.setFlowElementList(flowElementsList); boolean access = false; try { flowModelValidator.validate(flowModel); access = true; Assert."<AssertPlaceHolder>"; } catch (ProcessException e) { LOGGER.error("", e); Assert.assertFalse(access); } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
validate(FlowModel flowModel) throws ProcessException, DefinitionException { this.validate(flowModel, null); }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: validateAccess() { String modelStr = EntityBuilder.buildModelStringAccess(); boolean access = false; try { modelValidator.validate(modelStr); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } catch (ProcessException e) { LOGGER.error("", e); Assert.assertTrue(access); }   }
validate(String flowModelStr) throws DefinitionException, ProcessException { this.validate(flowModelStr, null); }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: checkIncomingAccess() { FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkIncoming(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkIncoming(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkIncoming(flowElementMap, flowElement);  List<String> incomingList = flowElement.getIncoming(); if (incomingList.size() >1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_INCOMING); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: checkOutgoingAccess() {  FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkOutgoing(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkOutgoing(flowElementMap, flowElement);  List<String> outgoingList = flowElement.getOutgoing(); if (outgoingList.size() > 1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_OUTGOING); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: regexPreprocessorTest() { RegexPreprocessor rpp = new RegexPreprocessor("^.*(fakebook\\.com.*)/$", "$1"); String test = "https://www.fakebook.com/personOne/"; String res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "www.fakebook.com/personOne/"; res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "fakebook.com/personOne/"; res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "personOne/"; res = "personOne/"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "insertedWithoutAppliedRegex"; res = "insertedWithoutAppliedRegex"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = ""; res = ""; Assert."<AssertPlaceHolder>"; }
applyProcessor(String value) { return value.replaceAll(match, replace); }
[*] target: assertEquals(res, rpp.applyProcessor(test))
[-] pred: org. junit. Assert. assertEquals ( res, rpp. applyProcessor( test ) )
************************************
************************************
[+] input: testPolymorphicDifference2() { VariableSet pDiff2 = VariableSet.polymorphicDifference2(fA, fB);  // everything in pDiff2 must be in A assertTrue(fA.containsAll(pDiff2));  // the normal difference is a subset of the second polymorphic difference // (it removes everything a normal difference would + possibly some more) // we want to take a look everything that gets only removed by the // second polymorphic difference  VariableSet diff = VariableSet.difference(fA, fB); VariableSet pDiffExcl = VariableSet.difference(diff, pDiff2);  // for each element in pDiffExcl the following must hold: // - element of A // - not element of B // - B has a variable with that name // - one of its types must be a subtype of the current elements type for (String name : pDiffExcl.getNames()) { for (Type type : pDiffExcl.getTypes(name)) { assertTrue(fA.contains(name, type)); assertFalse(fB.contains(name, type)); assertTrue(fB.contains(name)); boolean containsSubType = false; for (Type otherType : fB.getTypes(name)) { if (otherType.conformsTo(type)) { containsSubType = true; break; } } "<AssertPlaceHolder>"; } } }
getTypes(String name) { return fEntries.get(name); }
[*] target: assertTrue(containsSubType)
[-] pred: org. junit. Assert. assertTrue ( containsSubType )
************************************
************************************
[+] input: Exception { byte[] bytes = new byte[64]; bytes[0] = 15; Node nearNode = new Node(bytes, "127.0.0.19", 18888, 18888); bytes[0] = 70; Node farNode = new Node(bytes, "127.0.0.20", 18888, 18888); nodeTable.addNode(nearNode); nodeTable.addNode(farNode); for (int i = 0; i < KademliaOptions.BUCKET_SIZE - 1; i++) { //To control totally 17 nodes, however closest's capacity is 16 nodeTable.addNode(new Node(ids.get(i), ips[i], 18888, 18888)); TimeUnit.MILLISECONDS.sleep(10); } Assert.assertTrue(nodeTable.getBucketsCount() > 1); //3 buckets, nearnode's distance is 252, far's is 255, others' are 253 List<Node> closest = nodeTable.getClosestNodes(homeNode.getId()); Assert."<AssertPlaceHolder>"; //the farest node should be excluded }
contains(Node n) { NodeEntry e = new NodeEntry(node.getId(), n); for (NodeBucket b : buckets) { if (b.getNodes().contains(e)) { return true; } } return false; }
[*] target: assertTrue(closest.contains(nearNode))
[-] pred: org. junit. Assert. assertTrue ( closest. contains ( nearNode ) )
************************************
************************************
[+] input: JSONException { OpenWeatherMapSource source = new OpenWeatherMapSource(context); Location location = new SimpleLocation("lat=54.96&lon=73.38", true); JSONObject json = source.queryCurrentWeather(location); "<AssertPlaceHolder>"; assertEquals("Omsk", json.getString("name")); }
queryCurrentWeather(Location location) throws WeatherException { String url = getWeatherUrl(location); return queryJSON(url); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: JSONException { OpenWeatherMapSource source = new OpenWeatherMapSource(context); Location location = new SimpleLocation("q=omsk", false); JSONObject json = source.queryCurrentWeather(location); "<AssertPlaceHolder>"; assertEquals("Omsk", json.getString("name")); }
queryCurrentWeather(Location location) throws WeatherException { String url = getWeatherUrl(location); return queryJSON(url); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: WeatherException { JSONTokener parser = new JSONTokener("{ "cod": "404"}"); OpenWeatherMapWeather weather = new OpenWeatherMapWeather(context, (JSONObject)parser.nextValue()); //        assertNotNull(weather); //        "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertTrue(weather.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( weather. isEmpty() )
************************************
************************************
[+] input: testNotNullLocation() { OpenWeatherMapWeather weather = new OpenWeatherMapWeather(context); assertNotNull(weather.getLocation()); "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertTrue(weather.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( weather. isEmpty() )
************************************
************************************
[+] input: Exception { OpenWeatherMapWeather weather = WeatherUtils.createIncompleteOpenWeather(context); assertNotNull(weather); "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertFalse(weather.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( weather. isEmpty() )
************************************
************************************
[+] input: Exception { OpenWeatherMapWeather weather = WeatherUtils.createIncompleteOpenWeather(context); Location location = weather.getLocation(); assertNotNull(location); "<AssertPlaceHolder>"; assertEquals("Omsk", location.getText()); // geo coordinates are taken from the response assertTrue(location.isGeo()); assertEquals("lat=55.0&lon=73.4", location.getQuery()); }
isEmpty() { return this.empty; }
[*] target: assertFalse(location.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( location. isEmpty() )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); RootAssociation association = (RootAssociation) panel.getAssociation(); assertSame(panel, association.getJavaInfo()); assertTrue(association.canDelete()); // try to remove() "<AssertPlaceHolder>"; assertSame(association, panel.getAssociation()); }
remove() throws Exception { return false; }
[*] target: assertFalse(association.remove())
[-] pred: org. junit. Assert. assertFalse ( association. remove ( ) )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "class Test extends JPanel {", "  Test() {", "    addKeyListener(new KeyAdapter() {", "      public void keyReleased(KeyEvent e) {", "      }", "    });", "  }", "}"); DesignPageSite.Helper.setSite(panel, DesignPageSite.EMPTY); // prepare properties Property keyPressedProperty = getEventsListenerMethod(panel, "key", "pressed"); Property keyReleasedProperty = getEventsListenerMethod(panel, "key", "released"); assertNull(getPropertyText(keyPressedProperty)); assertEquals("line 8", getPropertyText(keyReleasedProperty)); // prepare context menu IMenuManager manager; { manager = getDesignerMenuManager(); panel.getBroadcastObject().addContextMenu(null, panel, manager); } // check action for existing "keyReleased" event { IAction keyReleasedAction = findChildAction(manager, "keyReleased -> line 8"); "<AssertPlaceHolder>"; assertSame( EventsPropertyUtils.LISTENER_METHOD_IMAGE_DESCRIPTOR, keyReleasedAction.getImageDescriptor()); // run, no change expected String expectedSource = m_lastEditor.getSource(); keyReleasedAction.run(); assertEditor(expectedSource, m_lastEditor); } // add new handler using action { IMenuManager manager2 = findChildMenuManager(manager, "Add event handler"); manager2 = findChildMenuManager(manager2, "key"); assertSame(EventsPropertyUtils.EXISTING_CLASS_IMAGE, ((MenuManagerEx) manager2).getImage()); // IAction keyPressedAction = findChildAction(manager2, "keyPressed"); assertNotNull(keyPressedAction); // run, new handler should be added keyPressedAction.run(); assertEditor( "class Test extends JPanel {", "  Test() {", "    addKeyListener(new KeyAdapter() {", "      public void keyReleased(KeyEvent e) {", "      }", "      @Override", "      public void keyPressed(KeyEvent e) {", "      }", "    });", "  }", "}"); } // check for images { IMenuManager manager2 = findChildMenuManager(manager, "Add event handler"); assertSame( EventsPropertyUtils.LISTENER_INTERFACE_IMAGE, ((MenuManagerEx) findChildMenuManager(manager2, "ancestor")).getImage()); } }
addContextMenu(List<? extends ObjectInfo> objects, ObjectInfo object, IMenuManager manager) throws Exception { if (object == m_javaInfo) { contributeActions(manager, ModelMessages.EventsProperty_menuManagerName); } }
[*] target: assertNotNull(keyReleasedAction)
[-] pred: org. junit. Assert. assertNotNull ( keyReleasedAction )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); final GenericProperty enabledProperty = (GenericProperty) panel.getPropertyByTitle("enabled"); final AtomicBoolean wasFired = new AtomicBoolean(); // add listener panel.addBroadcastListener(new JavaEventListener() { @Override public void propertyValueWasSet(GenericPropertyImpl property) throws Exception { if (property == enabledProperty) { wasFired.set(true); } } }); // set value for "enabled" to "false" wasFired.set(false); enabledProperty.setValue(false); assertTrue(wasFired.get()); assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); // set value for "enabled" to "true" wasFired.set(false); enabledProperty.setValue(true); "<AssertPlaceHolder>"; assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); // set value for "enabled" to "false" wasFired.set(false); enabledProperty.setExpression("false", Property.UNKNOWN_VALUE); assertTrue(wasFired.get()); assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); }
setValue(Object value) throws Exception;  //////////////////////////////////////////////////////////////////////////// // // Editor // //////////////////////////////////////////////////////////////////////////// /** * @return the {@link PropertyEditor}
[*] target: assertTrue(wasFired.get())
[-] pred: org. junit. Assert. assertTrue ( wasFired. get ( ) )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyPanel.java", getTestSource( "// filler filler filler filler filler", "// filler filler filler filler filler", "public class MyPanel extends JPanel {", "  public int foo;", "}")); waitForAutoBuild(); // parse // parse ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("foo"); FieldAccessor accessor = (FieldAccessor) getGenericPropertyAccessors(property).get(0); // check that IAccessibleExpressionAccessor is available // note, that we don't check it, I just don't know how to do this more easy than perform full check // but we expect that it should be from IAccessibleExpressionAccessor.Utils.forField() IAccessibleExpressionAccessor accessibleAccessor = accessor.getAdapter(IAccessibleExpressionAccessor.class); "<AssertPlaceHolder>"; assertNotNull(ReflectionUtils.getFieldByName(accessibleAccessor.getClass(), "val$field")); }
getAdapter(Class<T> adapter) { if (adapter == IAccessibleExpressionAccessor.class) { return adapter.cast(m_accessibleAccessor); } if (adapter == IExposableExpressionAccessor.class) { return adapter.cast(m_exposableAccessor); } if (adapter == PropertyTooltipProvider.class) { return adapter.cast(m_tooltipProvider); } // other return super.getAdapter(adapter); }
[*] target: assertNotNull(accessibleAccessor)
[-] pred: org. junit. Assert. assertNotNull ( accessibleAccessor )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("enabled"); SetterAccessor accessor = (SetterAccessor) getGenericPropertyAccessors(property).get(0); // check Method getter = accessor.getGetter(); "<AssertPlaceHolder>"; assertEquals("isEnabled", getter.getName()); }
getGetter() { return m_getter; }
[*] target: assertNotNull(getter)
[-] pred: org. junit. Assert. assertNotNull ( getter )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("enabled"); SetterAccessor accessor = (SetterAccessor) getGenericPropertyAccessors(property).get(0); // check that IAccessibleExpressionAccessor is available // note, that we don't check it, I just don't know how to do this more easy than perform full check // but we expect that it should be from IAccessibleExpressionAccessor.Utils.forMethod() IAccessibleExpressionAccessor accessibleAccessor = accessor.getAdapter(IAccessibleExpressionAccessor.class); "<AssertPlaceHolder>"; assertNotNull(ReflectionUtils.getFieldByName(accessibleAccessor.getClass(), "val$method")); }
getAdapter(Class<T> adapter) { if (adapter == IAccessibleExpressionAccessor.class) { return adapter.cast(m_accessibleAccessor); } if (adapter == IExposableExpressionAccessor.class) { return adapter.cast(m_exposableAccessor); } if (adapter == PropertyTooltipProvider.class) { return adapter.cast(m_tooltipProvider); } // other return super.getAdapter(adapter); }
[*] target: assertNotNull(accessibleAccessor)
[-] pred: org. junit. Assert. assertNotNull ( accessibleAccessor )
************************************
************************************
[+] input: Exception { IFile file = getFileSrc("test/messages.properties"); // prepare file in UTF-8 with Russian characters String key = "key"; String value = "" + (char) 0x410 + (char) 0x411 + (char) 0x412; String newValue = "" + (char) 0x430 + (char) 0x431 + (char) 0x432; { String content = key + "=" + value; setFileContent(file, content.getBytes("UTF-8")); file.setCharset("UTF-8", null); } // use BundleInfo, session #1 // check for initial value { BundleInfo bundle = BundleInfo.createBundle( StandardPropertiesAccessor.INSTANCE, "test.messages", LocaleInfo.DEFAULT, new IFile[]{file}); assertNotNull(bundle); assertEquals(value, bundle.getValue(key)); // set new value bundle.setValue(key, newValue); bundle.save(""); assertEquals("UTF-8", file.getCharset()); } // use BundleInfo, session #2 // check for new value { BundleInfo bundle = BundleInfo.createBundle( StandardPropertiesAccessor.INSTANCE, "test.messages", LocaleInfo.DEFAULT, new IFile[]{file}); assertNotNull(bundle); "<AssertPlaceHolder>"; } }
getValue(String key) throws Exception { return getProperties().get(key); }
[*] target: assertEquals(newValue, bundle.getValue(key))
[-] pred: org. junit. Assert. assertEquals ( newValue, bundle. getValue( key ) )
************************************
************************************
[+] input: Exception { CategoryInfo category = new CategoryInfo(); assertFalse(category.isOpen()); category.setOpen(true); "<AssertPlaceHolder>"; }
isOpen() { return m_open; }
[*] target: assertTrue(category.isOpen())
[-] pred: org. junit. Assert. assertTrue ( category. isOpen() )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyAbstractButton.java", getTestSource( "// filler filler filler filler filler", "// filler filler filler filler filler", "public abstract class MyAbstractButton extends JButton {", "}")); setFileContentSrc( "test/MyAbstractButton.wbp-component.xml", getSourceDQ( "<?xml version='1.0' encoding='UTF-8'?>", "<component xmlns='http://www.eclipse.org/wb/WBPComponent'>", "  <creation>", "    <source><![CDATA[new test.MyAbstractButton(){}]]></source>", "    <tag name='createAnonymous' value='true'/>", "  </creation>", "</component>")); waitForAutoBuild(); // prepare palette addPaletteExtension(new String[]{ "<category id='category_1' name='category 1'>", "  <component class='test.MyAbstractButton'/>", "</category>"}); PaletteInfo palette = loadPalette(); // prepare component final CategoryInfo category = palette.getCategory("category_1"); final ComponentEntryInfo componentEntry = (ComponentEntryInfo) category.getEntries().get(0); // set palette site IPaletteSite.Helper.setSite(m_lastParseInfo, new IPaletteSite.Empty() { @Override public Shell getShell() { return DesignerPlugin.getShell(); } }); // do initialize assertTrue(componentEntry.initialize(null, m_lastParseInfo)); // create tool CreationTool creationTool = (CreationTool) componentEntry.createTool(); "<AssertPlaceHolder>"; }
createTool() throws Exception { if (!ensureDescriptions()) { return null; } if (ReflectionUtils.isAbstract(m_class) && !m_creation.hasTrueTag("createAnonymous")) { Shell parentShell = IPaletteSite.Helper.getSite(m_rootJavaInfo).getShell(); UiUtils.openError( parentShell, Messages.ComponentEntryInfo_abstractTitle, Messages.ComponentEntryInfo_abstractMessage); return null; } // prepare generics final Map<String, String> genericArguments = getTypeArguments(); if (genericArguments == null) { return null; } // prepare factory ICreationFactory factory = new ICreationFactory() { private JavaInfo m_javaInfo;  @Override public void activate() throws Exception { CreationSupport creationSupport = new ConstructorCreationSupport(m_creationId, true); m_javaInfo = JavaInfoUtils.createJavaInfo(m_editor, m_description, creationSupport); m_javaInfo.putTemplateArguments(genericArguments); m_javaInfo = JavaInfoUtils.getWrapped(m_javaInfo); m_javaInfo.putArbitraryValue(JavaInfo.FLAG_MANUAL_COMPONENT, Boolean.TRUE); }  @Override public Object getNewObject() { return m_javaInfo; } }; // return tool ensureLibraries(); return new CreationTool(factory); }
[*] target: assertNotNull(creationTool)
[-] pred: org. junit. Assert. assertNotNull ( creationTool )
************************************
************************************
[+] input: Exception { // prepare objects List<Object> objects; { objects = new ArrayList<>(); objects.add("123"); objects.add(555); } // prepare selection provider ISelectionProvider selectionProvider; { final ISelection selection = new StructuredSelection(objects); selectionProvider = new ISelectionProvider() { @Override public ISelection getSelection() { return selection; }  @Override public void setSelection(ISelection _selection) { }  @Override public void removeSelectionChangedListener(ISelectionChangedListener listener) { }  @Override public void addSelectionChangedListener(ISelectionChangedListener listener) { } }; } // get iterable Iterable<Object> iterable = GenericsUtils.iterableSelection(selectionProvider); // iterate { // prepare iterator Iterator<Object> iterator = iterable.iterator(); // first element assertTrue(iterator.hasNext()); assertSame(objects.get(0), iterator.next()); // second element assertTrue(iterator.hasNext()); assertSame(objects.get(1), iterator.next()); // not more elements "<AssertPlaceHolder>"; } }
hasNext() { return iterator.hasNext(); }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext() )
************************************
************************************
[+] input: Exception { Map<String, String> options = ProjectUtils.getOptions(m_testProject.getJavaProject()); "<AssertPlaceHolder>"; // check one option assertEquals("error", options.get("org.eclipse.jdt.core.incompleteClasspath")); }
getOptions(IJavaProject project) { return project.getOptions(true); }
[*] target: assertNotNull(options)
[-] pred: org. junit. Assert. assertNotNull ( options )
************************************
************************************
[+] input: Exception { Class<?> SWTClass = m_lastLoader.loadClass("org.eclipse.swt.SWT"); ColorInfo info = ColorSupport.createInfo(ReflectionUtils.getFieldByName(SWTClass, "COLOR_RED")); // check create "<AssertPlaceHolder>"; // check color name assertEquals("COLOR_RED", info.m_name); // check special data assertEquals("org.eclipse.swt.SWT.COLOR_RED", info.getData()); // check RGB assertNotNull(info.m_rgb); assertEquals(255, info.m_rgb.red); assertEquals(0, info.m_rgb.green); assertEquals(0, info.m_rgb.blue); }
createInfo(String name, Object color) throws Exception { return new ColorInfo(name, getRed(color), getGreen(color), getBlue(color)); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: Exception { Object shell = ContainerSupport.createShell(); Image rcpImage = ImageDescriptor.createFromFile(Object.class, "/javax/swing/plaf/basic/icons/JavaCup16.png") .createImage(); try { assertNull(ReflectionUtils.invokeMethod(shell, "getImage()")); // ContainerSupport.setShellImage(shell, rcpImage); // check newly set image { Object image = ReflectionUtils.invokeMethod(shell, "getImage()"); // exists... "<AssertPlaceHolder>"; // ..and has same size { Object bounds = ReflectionUtils.invokeMethod(image, "getBounds()"); assertEquals(rcpImage.getBounds().width, ReflectionUtils.getFieldInt(bounds, "width")); assertEquals(rcpImage.getBounds().height, ReflectionUtils.getFieldInt(bounds, "height")); } } } finally { rcpImage.dispose(); ControlSupport.dispose(shell); } }
setShellImage(Object shell, Image swtImage) throws Exception { Object image = SWT_TO_TOOLKIT_IMAGES.get(swtImage); if (image == null) { image = ToolkitSupport.createToolkitImage(swtImage); SWT_TO_TOOLKIT_IMAGES.put(swtImage, image); } ReflectionUtils.invokeMethod(shell, "setImage(org.eclipse.swt.graphics.Image)", image); }
[*] target: assertNotNull(image)
[-] pred: org. junit. Assert. assertNotNull ( image )
************************************
************************************
[+] input: Exception { disposeLastModel(); CompositeInfo shellInfo = (CompositeInfo) parseSource( "test", "Test2.java", getTestSource( "public class Test2 extends Shell {", "  public Test2() {", "    setLayout(new RowLayout());", "    Button button = new Button(this, SWT.NONE);", "    button.setLayoutData(new RowData(100, 50));", "  }", "}")); shellInfo.refresh(); ControlInfo buttonInfo = shellInfo.getChildrenControls().get(0); Object button = buttonInfo.getObject(); // call getLayoutData() Object layoutData = ControlSupport.getLayoutData(button); "<AssertPlaceHolder>"; assertEquals("org.eclipse.swt.layout.RowData", layoutData.getClass().getName()); }
getLayoutData(Object control) { return ReflectionUtils.invokeMethodEx(control, "getLayoutData()"); }
[*] target: assertNotNull(layoutData)
[-] pred: org. junit. Assert. assertNotNull ( layoutData )
************************************
************************************
[+] input: Exception { final WebRequest request = new WebRequest(new URL("http://localhost/test")); request.setHttpMethod(HttpMethod.POST); request.setEncodingType(FormEncodingType.MULTIPART);  final List<NameValuePair> requestParams = new ArrayList<>(); requestParams.add(new NameValuePair("test", null)); requestParams.add(new KeyDataPair("file", null, null, null, StandardCharsets.UTF_8)); request.setRequestParameters(requestParams);  final List<NameValuePair> expectedResults = new ArrayList<>(); expectedResults.add(new NameValuePair("test", "")); // the constructor of the KeyDataPair already creates normalized object // where the value is set to empty string if the passed file is null. expectedResults.add(new KeyDataPair("file", null, null, null, StandardCharsets.UTF_8));  final List<NameValuePair> normalizedParams = request.getParameters(); "<AssertPlaceHolder>";  // check that the value of the KeyDataPair is really normalized to empty string assertEquals("", normalizedParams.get(1).getValue()); }
getParameters() { // developer note: // this has to be in sync with // org.htmlunit.HttpWebConnection.makeHttpMethod(WebRequest, HttpClientBuilder)  if (HttpMethod.POST != getHttpMethod() && HttpMethod.PUT != getHttpMethod() && HttpMethod.PATCH != getHttpMethod()) {  if (!getRequestParameters().isEmpty()) { return normalize(getRequestParameters()); }  return normalize(HttpClientConverter.parseUrlQuery(getUrl().getQuery(), getCharset()));  }  if (getEncodingType() == FormEncodingType.URL_ENCODED && HttpMethod.POST == getHttpMethod()) { if (getRequestBody() == null) { return normalize(getRequestParameters()); }  return normalize(HttpClientConverter.parseUrlQuery(getRequestBody(), getCharset())); }  if (getEncodingType() == FormEncodingType.TEXT_PLAIN  && HttpMethod.POST == getHttpMethod()) { if (getRequestBody() == null) { return normalize(getRequestParameters()); }  return Collections.emptyList(); }  if (FormEncodingType.MULTIPART == getEncodingType()) { return normalize(getRequestParameters()); }  // for instance a PUT or PATCH request return Collections.emptyList(); }
[*] target: assertEquals(expectedResults, normalizedParams)
[-] pred: org. junit. Assert. assertEquals ( expectedResults, normalizedParams )
************************************
************************************
[+] input: containsKey_True_content_based() { // same hash and different content final OrderedFastHashMap<MockKey<String>, String> m = new OrderedFastHashMap<>(); final MockKey<String> mockKey1 = new MockKey<>(10, "akey1"); m.put(mockKey1, "any1"); m.put(new MockKey<>(10, "akey2"), "any2"); m.put(new MockKey<>(10, "akey3"), "any3"); m.put(new MockKey<>(10, "akey4"), "any4"); "<AssertPlaceHolder>"; assertTrue(m.containsKey(new MockKey<>(10, "akey1"))); }
containsKey(final Object key) { return get(key) != null; }
[*] target: assertTrue(m.containsKey(mockKey1))
[-] pred: org. junit. Assert. assertTrue ( m. containsKey ( mockKey1 ) )
************************************
************************************
[+] input: idleBeat() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.idleBeat(new IdleBeatParam(jobId));  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(500, retval.getCode()); Assert.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(IdleBeatParam idleBeatParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: kill() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.kill(new KillParam(jobId));  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(200, retval.getCode()); Assert.assertNull(retval.getMsg()); }
kill(KillParam killParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: testClear() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); map.put("key1", "value1"); map.put("key2", "value2"); map.clear(); assertTrue(map.isEmpty()); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size ( ) )
************************************
************************************
[+] input: testPutIfAbsent() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); assertNull(map.putIfAbsent("key1", "value1")); assertEquals("value1", map.get("key1")); assertEquals("value1", map.putIfAbsent("key1", "value2")); assertEquals("value1", map.get("key1")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, map.size())
[-] pred: org. junit. Assert. assertEquals ( 1, map. size() )
************************************
************************************
[+] input: testRemove() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); map.put("key1", "value1"); assertEquals("value1", map.remove("key1")); assertNull(map.remove("key1")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size ( ) )
************************************
************************************
[+] input: testSyncMintNFT() { Provider provider = wallet.getProvider(); Token token = defaultToken(); EthSignature ethSignature = new EthSignature(SignatureType.EthereumSignature, "0xac4f8b1ad65ea143dd2a940c72dd778ba3e07ee766355ed237a89a0b7e925fe76ead0a04e23db1cc1593399ee69faeb31b2e7e0c6fbec70d5061d6fbc431d64a1b"); when(provider.getTokens()).thenReturn(new Tokens(Collections.singletonMap(token.getAddress(), token))); when(provider.submitTx(defaultZkSyncTransaction_MintNFT(), ethSignature, false)).thenReturn("success:hash"); String response = wallet.syncMintNFT( "0x19aa2ed8712072e918632259780e587698ef58df", "0x0000000000000000000000000000000000000000000000000000000000000123", defaultTransactionFee(1000000), 12 ); "<AssertPlaceHolder>"; assertEquals(response, "success:hash"); }
syncMintNFT(String recipient, String contentHash, TransactionFee fee, Integer nonce) { final Integer nonceToUse = nonce == null ? getNonce() : nonce;  final SignedTransaction<MintNFT> signedMintNFT = buildSignedMintNFTTx(recipient, contentHash, fee.getFeeToken(), fee.getFee(), nonceToUse);  return submitSignedTransaction(signedMintNFT.getTransaction(), signedMintNFT.getEthereumSignature()); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************

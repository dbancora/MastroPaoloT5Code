[+] input: 공부미션을_생성한다() { // given MissionCreateRequest missionCreateRequest = new MissionCreateRequest( "testMissionName", "testMissionContent", MissionCategory.STUDY, MissionVisibility.ALL, MissionPeriod.TWO_WEEKS, LocalTime.of(21, 0));  // when MissionCreateResponse mission = missionService.createMission(missionCreateRequest);  // then "<AssertPlaceHolder>"; assertEquals("testMissionName", mission.name()); assertEquals("testMissionContent", mission.content()); assertEquals(MissionCategory.STUDY, mission.category()); assertEquals(MissionVisibility.ALL, mission.visibility()); }
createMission(MissionCreateRequest missionCreateRequest) { Mission mission = createMissionEntity(missionCreateRequest); Mission saveMission = missionRepository.save(mission); return MissionCreateResponse.from(saveMission); }
[*] target: assertNotNull(mission)
[-] pred: org. junit. Assert. assertNotNull ( mission )
************************************
************************************
[+] input: testGenerateTokenPair() { // Given String userId = "sampleUserId";  // When TokenPair tokenPair = jwtTokenGenerator.generateTokenPair(userId);  // Then "<AssertPlaceHolder>"; assertNotNull(tokenPair.accessToken()); assertNotNull(tokenPair.refreshToken()); }
generateTokenPair(String userId) { String accessToken = generateAccessToken(userId); String refreshToken = generateRefreshToken(userId); return new TokenPair(accessToken, refreshToken); }
[*] target: assertNotNull(tokenPair)
[-] pred: org. junit. Assert. assertNotNull ( tokenPair )
************************************
************************************
[+] input: testCreateRuleDetailsError() { boolean exceptionThrown = false; try { ruleDocumentation.createRuleDetails(-1); } catch (IllegalArgumentException e) { exceptionThrown = true; } assertTrue(exceptionThrown);  exceptionThrown = false; try { ruleDocumentation.createRuleDetails(rules.length); } catch (IllegalArgumentException e) { exceptionThrown = true; } "<AssertPlaceHolder>"; }
createRuleDetails(int ruleIndex) { if (ruleIndex < 0 || ruleIndex >= rules.length) throw new IllegalArgumentException();  final String NAV_PREVIOUS_RULE = "<-- previous rule"; final String NAV_OVERVIEW = "overview"; final String NAV_NEXT_RULE = "next rule -->"; final String NAV_SEPARATOR = " | ";  MarkdownBuilder mb = MarkdownBuilder.create();  Rule rule = rules[ruleIndex];  // navigation to "<-- previous rule | overview | next rule -->" mb.startNewParagraph(); if (ruleIndex > 0) { mb.appendLink(NAV_PREVIOUS_RULE, getRuleDocumentationFileName(ruleIndex - 1)); } else { mb.appendText(NAV_PREVIOUS_RULE); } mb.appendText(NAV_SEPARATOR); mb.appendLink(NAV_OVERVIEW, "../" + RULES_FILE); mb.appendText(NAV_SEPARATOR); if (ruleIndex + 1 < rules.length) { mb.appendLink(NAV_NEXT_RULE, getRuleDocumentationFileName(ruleIndex + 1)); } else { mb.appendText(NAV_NEXT_RULE); }  // rule name, description, references, options, example code rule.toDocumentation(mb);  // links to Rule implementation and tests mb.startNewHeading("Related code", 2); mb.startNewBullet(1); mb.appendLink("Rule implementation", getRuleImplementationLink(rule)); mb.startNewBullet(1); mb.appendLink("Tests", getRuleTestClassLink(rule));  mb.finishBuild(); return mb.toString();  }
[*] target: assertTrue(exceptionThrown)
[-] pred: org. junit. Assert. assertTrue ( exceptionThrown )
************************************
************************************
[+] input: JsonProcessingException { doCallRealMethod().when(context).setStreamingRequest(anyBoolean()); when(context.isStreamingRequest()).thenCallRealMethod();  Throwable error = fn.apply((ObjectNode) ProxyUtil.MAPPER.readTree("{"stream": false}"));  "<AssertPlaceHolder>"; assertFalse(context.isStreamingRequest()); }
apply(ObjectNode tree) { JsonNode stream = tree.get("stream"); boolean result = stream != null && stream.asBoolean(false); context.setStreamingRequest(result); return null; }
[*] target: assertNull(error)
[-] pred: org. junit. Assert. assertNull ( error )
************************************
************************************
[+] input: JsonProcessingException { doCallRealMethod().when(context).setStreamingRequest(anyBoolean()); when(context.isStreamingRequest()).thenCallRealMethod();  Throwable error = fn.apply((ObjectNode) ProxyUtil.MAPPER.readTree("{}"));  "<AssertPlaceHolder>"; assertFalse(context.isStreamingRequest()); }
apply(ObjectNode tree) { JsonNode stream = tree.get("stream"); boolean result = stream != null && stream.asBoolean(false); context.setStreamingRequest(result); return null; }
[*] target: assertNull(error)
[-] pred: org. junit. Assert. assertNull ( error )
************************************
************************************
[+] input: JsonProcessingException { Model model = new Model(); Map<String, Object> defaults = Map.of("key1", true, "key2", 123, "key3", 0.45, "key4", "str"); model.setDefaults(defaults); when(context.getDeployment()).thenReturn(model); Mockito.doCallRealMethod().when(context).setRequestBody(any(Buffer.class)); when(context.getRequestBody()).thenCallRealMethod(); Throwable error = fn.apply((ObjectNode) ProxyUtil.MAPPER.readTree("{}")); "<AssertPlaceHolder>"; String json = context.getRequestBody().toString(StandardCharsets.UTF_8); ObjectNode result = (ObjectNode) ProxyUtil.MAPPER.readTree(json); assertNotNull(result); assertEquals(123, result.get("key2").asInt()); assertEquals(0.45, result.get("key3").asDouble()); assertEquals("str", result.get("key4").asText()); assertTrue(result.get("key1").asBoolean()); }
apply(ObjectNode tree) { try { if (applyDefaults(context, tree)) { context.setRequestBody(Buffer.buffer(ProxyUtil.MAPPER.writeValueAsBytes(tree))); } return null; } catch (Throwable e) { context.respond(HttpStatus.BAD_REQUEST); log.warn("Can't apply default parameters to deployment {}. Trace: {}. Span: {}. Error: {}", context.getDeployment().getName(), context.getTraceId(), context.getSpanId(), e.getMessage()); return e; } }
[*] target: assertNull(error)
[-] pred: org. junit. Assert. assertNull ( error )
************************************
************************************
[+] input: testLimit_ApiKeyLimitNotFound() { Key key = new Key(); key.setRole("role"); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(new Config(), request, apiKeyData, null, "trace-id", "span-id"); proxyContext.setDeployment(new Model());  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.FORBIDDEN, result.result().status()); }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testLimit_ApiKeyLimitNotFoundWithNullRole() { Key key = new Key(); key.setKey("key"); key.setProject("project"); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(new Config(), request, apiKeyData, null, "trace-id", "span-id"); proxyContext.setDeployment(new Model());  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.FORBIDDEN, result.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testLimit_ApiKeyLimitNegative() { Key key = new Key(); key.setRole("role"); key.setKey("key"); Config config = new Config(); Role role = new Role(); Limit limit = new Limit(); limit.setDay(-1); role.setLimits(Map.of("model", limit)); config.setRoles(Map.of("role", role)); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, null, "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.FORBIDDEN, result.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testLimit_ApiKeySuccess_KeyNotFound() { Key key = new Key(); key.setRole("role"); key.setKey("key"); key.setProject("api-key"); Config config = new Config(); Role role = new Role(); Limit limit = new Limit(); role.setLimits(Map.of("model", limit)); config.setRoles(Map.of("role", role)); ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setOriginalKey(key); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, null, "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  when(vertx.executeBlocking(any(Callable.class), eq(false))).thenAnswer(invocation -> { Callable<?> callable = invocation.getArgument(0); return Future.succeededFuture(callable.call()); });  Future<RateLimitResult> result = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(result.result()); assertEquals(HttpStatus.OK, result.result().status()); }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testLimit_User_LimitFound() { Config config = new Config();  Role role1 = new Role(); Limit limit = new Limit(); limit.setDay(10000); limit.setMinute(100); role1.setLimits(Map.of("model", limit));  Role role2 = new Role(); limit = new Limit(); limit.setDay(20000); limit.setMinute(200); role2.setLimits(Map.of("model", limit));  config.getRoles().put("role1", role1); config.getRoles().put("role2", role2);  ApiKeyData apiKeyData = new ApiKeyData(); apiKeyData.setPerRequestKey("per-request-key"); apiKeyData.setExtractedClaims(new ExtractedClaims("sub", List.of("role1", "role2"), "user-hash", Map.of())); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, null, "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  when(vertx.executeBlocking(any(Callable.class), eq(false))).thenAnswer(invocation -> { Callable<?> callable = invocation.getArgument(0); return Future.succeededFuture(callable.call()); });  TokenUsage tokenUsage = new TokenUsage(); tokenUsage.setTotalTokens(150); proxyContext.setTokenUsage(tokenUsage);  Future<Void> increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  Future<RateLimitResult> checkLimitFuture = rateLimiter.limit(proxyContext);  assertNotNull(checkLimitFuture); assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.OK, checkLimitFuture.result().status());  increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  checkLimitFuture = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.TOO_MANY_REQUESTS, checkLimitFuture.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(checkLimitFuture)
[-] pred: org. junit. Assert. assertNotNull ( checkLimitFuture )
************************************
************************************
[+] input: testLimit_User_RequestLimit() { Config config = new Config();  Role role1 = new Role(); Limit limit = new Limit(); limit.setRequestDay(10); limit.setRequestHour(1); role1.setLimits(Map.of("model", limit));  Role role2 = new Role(); limit = new Limit(); limit.setRequestDay(20); limit.setRequestHour(1); role2.setLimits(Map.of("model", limit));  config.getRoles().put("role1", role1); config.getRoles().put("role2", role2);  ApiKeyData apiKeyData = new ApiKeyData(); ProxyContext proxyContext = new ProxyContext(config, request, apiKeyData, new ExtractedClaims("sub", List.of("role1", "role2"), "user-hash", Map.of()), "trace-id", "span-id"); Model model = new Model(); model.setName("model"); proxyContext.setDeployment(model);  when(vertx.executeBlocking(any(Callable.class), eq(false))).thenAnswer(invocation -> { Callable<?> callable = invocation.getArgument(0); return Future.succeededFuture(callable.call()); });  TokenUsage tokenUsage = new TokenUsage(); tokenUsage.setTotalTokens(150); proxyContext.setTokenUsage(tokenUsage);  Future<Void> increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  Future<RateLimitResult> checkLimitFuture = rateLimiter.limit(proxyContext);  assertNotNull(checkLimitFuture); assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.OK, checkLimitFuture.result().status());  increaseLimitFuture = rateLimiter.increase(proxyContext); assertNotNull(increaseLimitFuture); assertNull(increaseLimitFuture.cause());  checkLimitFuture = rateLimiter.limit(proxyContext);  "<AssertPlaceHolder>"; assertNotNull(checkLimitFuture.result()); assertEquals(HttpStatus.TOO_MANY_REQUESTS, checkLimitFuture.result().status());  }
limit(ProxyContext context) { try { // skip checking limits if redis is not available if (resourceService == null) { return Future.succeededFuture(RateLimitResult.SUCCESS); } Key key = context.getKey(); String deploymentName = context.getDeployment().getName(); Limit limit; if (key == null) { limit = getLimitByUser(context, deploymentName); } else { limit = getLimitByApiKey(context, deploymentName); }  if (limit == null || !limit.isPositive()) { if (limit == null) { log.warn("Limit is not found for deployment: {}", deploymentName); } else { log.warn("Limit must be positive for deployment: {}", deploymentName); } return Future.succeededFuture(new RateLimitResult(HttpStatus.FORBIDDEN, "Access denied")); }  return vertx.executeBlocking(() -> checkLimit(context, limit), false); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(checkLimitFuture)
[-] pred: org. junit. Assert. assertNotNull ( checkLimitFuture )
************************************
************************************
[+] input: testExtractClaims_02() { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); Future<ExtractedClaims> future = validator.extractClaims("bad-auth-header"); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.failed()); assertNotNull(res.cause()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testExtractClaims_03() { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); Future<ExtractedClaims> future = validator.extractClaims("bearer bad-token"); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.failed()); assertNotNull(res.cause()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: NoSuchAlgorithmException { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); IdentityProvider provider1 = mock(IdentityProvider.class); when(provider1.match(any(DecodedJWT.class))).thenReturn(false); IdentityProvider provider2 = mock(IdentityProvider.class); when(provider2.match(any(DecodedJWT.class))).thenReturn(false); List<IdentityProvider> providerList = List.of(provider1, provider2); validator.setProviders(providerList); KeyPair keyPair = generateRsa256Pair(); Algorithm algorithm = Algorithm.RSA256((RSAPublicKey) keyPair.getPublic(), (RSAPrivateKey) keyPair.getPrivate()); String token = JWT.create().withClaim("iss", "unknown-issuer").sign(algorithm); Future<ExtractedClaims> future = validator.extractClaims(getBearerHeaderValue(token)); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.failed()); assertNotNull(res.cause()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: NoSuchAlgorithmException { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); IdentityProvider provider1 = mock(IdentityProvider.class); when(provider1.match(any(DecodedJWT.class))).thenReturn(false); IdentityProvider provider2 = mock(IdentityProvider.class); when(provider2.match(any(DecodedJWT.class))).thenReturn(true); when(provider2.extractClaimsFromJwt(any(DecodedJWT.class))).thenReturn(Future.succeededFuture(new ExtractedClaims("sub", Collections.emptyList(), "hash", Map.of()))); List<IdentityProvider> providerList = List.of(provider1, provider2); validator.setProviders(providerList); KeyPair keyPair = generateRsa256Pair(); Algorithm algorithm = Algorithm.RSA256((RSAPublicKey) keyPair.getPublic(), (RSAPrivateKey) keyPair.getPrivate()); String token = JWT.create().withClaim("iss", "issuer2").sign(algorithm); Future<ExtractedClaims> future = validator.extractClaims(getBearerHeaderValue(token)); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.succeeded()); ExtractedClaims claims = res.result(); assertNotNull(claims); assertEquals("sub", claims.sub()); assertEquals(Collections.emptyList(), claims.userRoles()); assertEquals("hash", claims.userHash()); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: NoSuchAlgorithmException { AccessTokenValidator validator = new AccessTokenValidator(idpConfig, vertx, client); IdentityProvider provider = mock(IdentityProvider.class); when(provider.hasUserinfoUrl()).thenReturn(false); when(provider.extractClaimsFromJwt(any(DecodedJWT.class))).thenReturn(Future.succeededFuture(new ExtractedClaims("sub", Collections.emptyList(), "hash", Map.of()))); List<IdentityProvider> providerList = List.of(provider); validator.setProviders(providerList); KeyPair keyPair = generateRsa256Pair(); Algorithm algorithm = Algorithm.RSA256((RSAPublicKey) keyPair.getPublic(), (RSAPrivateKey) keyPair.getPrivate()); String token = JWT.create().withClaim("iss", "issuer").sign(algorithm); Future<ExtractedClaims> future = validator.extractClaims(getBearerHeaderValue(token)); "<AssertPlaceHolder>"; future.onComplete(res -> { assertTrue(res.succeeded()); ExtractedClaims claims = res.result(); assertNotNull(claims); assertEquals("sub", claims.sub()); assertEquals(Collections.emptyList(), claims.userRoles()); assertEquals("hash", claims.userHash()); verify(provider, never()).match(any(DecodedJWT.class)); }); }
extractClaims(String authHeader) { String accessToken = null; try { if (authHeader == null) { return Future.succeededFuture(); } accessToken = Objects.requireNonNull(extractTokenFromHeader(authHeader), "Can't extract access token from header"); if (providers.size() == 1) { IdentityProvider provider =  providers.get(0); return extractClaims(accessToken, provider); } DecodedJWT jwt = IdentityProvider.decodeJwtToken(accessToken); return extractClaimsFromJwt(jwt); } catch (JWTDecodeException e) { // access token is not JWT. let's try to extract claims from user info return extractClaimsFromUserInfo(accessToken); } catch (Throwable e) { return Future.failedFuture(e); } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testTieredLoadBalancer() { List<Upstream> upstreams = List.of( new Upstream("endpoint1", null, 1, 0), new Upstream("endpoint2", null, 9, 1) ); TieredBalancer balancer = new TieredBalancer("model1", upstreams);  // verify all requests go to the highest tier for (int j = 0; j < 50; j++) { UpstreamState upstream = balancer.next(); "<AssertPlaceHolder>"; assertEquals("endpoint1", upstream.getUpstream().getEndpoint()); } }
next();
[*] target: assertNotNull(upstream)
[-] pred: org. junit. Assert. assertNotNull ( upstream )
************************************
************************************
[+] input: testUpstreamRefresh() { Config config = new Config(); Map<String, Model> models = new HashMap<>(); config.setModels(models);  Model model = new Model(); model.setName("model1"); model.setUpstreams(List.of( new Upstream("endpoint1", null, 1, 1), new Upstream("endpoint2", null, 1, 1) ));  models.put("model1", model); UpstreamRouteProvider upstreamRouteProvider = new UpstreamRouteProvider(); upstreamRouteProvider.onUpdate(config);  UpstreamRoute route = upstreamRouteProvider.get(new DeploymentUpstreamProvider(model)); Upstream upstream;  // fail 2 upstreams for (int i = 0; i < 2; i++) { upstream = route.get(); assertNotNull(upstream); route.fail(HttpStatus.TOO_MANY_REQUESTS, 100); route.next(); }  upstream = route.get(); "<AssertPlaceHolder>";  Model model1 = new Model(); model1.setName("model1"); model1.setUpstreams(List.of( new Upstream("endpoint2", null, 1, 1), new Upstream("endpoint1", null, 1, 1) ));  models.put("model1", model1); upstreamRouteProvider.onUpdate(config);  // upstreams remains the same, state must not be invalidated route = upstreamRouteProvider.get(new DeploymentUpstreamProvider(model1));  upstream = route.get(); assertNull(upstream);  Model model2 = new Model(); model2.setName("model1"); model2.setUpstreams(List.of( new Upstream("endpoint2", null, 5, 1), new Upstream("endpoint1", null, 1, 1) ));  models.put("model1", model2); upstreamRouteProvider.onUpdate(config);  // upstreams updated, current state must be evicted route = upstreamRouteProvider.get(new DeploymentUpstreamProvider(model2));  upstream = route.get(); assertNotNull(upstream); assertEquals("endpoint2", upstream.getEndpoint()); }
next();
[*] target: assertNull(upstream)
[-] pred: org. junit. Assert. assertNull ( upstream )
************************************
************************************
[+] input: testReplaceAtString() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE); ((ArrayNode) expected.get(ONE)).set(1, REPLACEMENT_STRING);  final JsonNode actual = JsonPaths.replaceAtString(JSON_NODE, LIST_ONE_QUERY, REPLACEMENT_STRING); "<AssertPlaceHolder>"; }); }
replaceAtString(final JsonNode json, final String jsonPath, final String replacement) { return replaceAtJsonNode(json, jsonPath, Jsons.jsonNode(replacement)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testReplaceAtStringEmptyReturnNoOp() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE);  final JsonNode actual = JsonPaths.replaceAtString(JSON_NODE, EMPTY_RETURN_QUERY, REPLACEMENT_STRING); "<AssertPlaceHolder>"; }); }
replaceAtString(final JsonNode json, final String jsonPath, final String replacement) { return replaceAtJsonNode(json, jsonPath, Jsons.jsonNode(replacement)); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testReplaceAtJsonNodeLoud() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE); ((ArrayNode) expected.get(ONE)).set(1, REPLACEMENT_JSON);  final JsonNode actual = JsonPaths.replaceAtJsonNodeLoud(JSON_NODE, LIST_ONE_QUERY, REPLACEMENT_JSON); "<AssertPlaceHolder>"; }); }
replaceAtJsonNodeLoud(final JsonNode json, final String jsonPath, final JsonNode replacement) { assertIsJsonPath(jsonPath); return JsonPath.parse(Jsons.clone(json)).set(jsonPath, replacement).json(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testReplaceAtJsonNodeLoudMultipleReplace() { assertOriginalObjectNotModified(JSON_NODE, () -> { final JsonNode expected = Jsons.clone(JSON_NODE); ((ArrayNode) expected.get(ONE)).set(0, REPLACEMENT_JSON); ((ArrayNode) expected.get(ONE)).set(1, REPLACEMENT_JSON); ((ArrayNode) expected.get(ONE)).set(2, REPLACEMENT_JSON);  final JsonNode actual = JsonPaths.replaceAtJsonNodeLoud(JSON_NODE, LIST_ALL_QUERY, REPLACEMENT_JSON); "<AssertPlaceHolder>"; }); }
replaceAtJsonNodeLoud(final JsonNode json, final String jsonPath, final JsonNode replacement) { assertIsJsonPath(jsonPath); return JsonPath.parse(Jsons.clone(json)).set(jsonPath, replacement).json(); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGetCurrentUser() { // set up a mock request context, details don't matter, just needed to make the // @RequestScope work on the CommunityCurrentUserService ServerRequestContext.with(HttpRequest.GET("/"), () -> { try { final User expectedUser = new User().withUserId(UserPersistence.DEFAULT_USER_ID); when(userPersistence.getDefaultUser()).thenReturn(Optional.ofNullable(expectedUser));  // First call - should fetch default user from userPersistence final User user1 = currentUserService.getCurrentUser(); Assertions.assertEquals(expectedUser, user1);  // Second call - should use cached user final User user2 = currentUserService.getCurrentUser(); Assertions."<AssertPlaceHolder>";  // Verify that getDefaultUser is called only once verify(userPersistence, times(1)).getDefaultUser(); } catch (final IOException e) { fail(e); } }); }
getCurrentUser() { if (this.retrievedDefaultUser == null) { try { this.retrievedDefaultUser = userPersistence.getDefaultUser().orElseThrow(); log.debug("Setting current user for request to retrieved default user: {}", retrievedDefaultUser); } catch (final Exception e) { throw new RuntimeException("Could not get the current user due to an internal error.", e); } } return this.retrievedDefaultUser; }
[*] target: assertEquals(expectedUser, user2)
[-] pred: org. junit. Assert. assertEquals ( expectedUser, user2 )
************************************
************************************
[+] input: testGetCurrentUser() { // set up a mock request context, details don't matter, just needed to make the // @RequestScope work on the SecurityAwareCurrentUserService ServerRequestContext.with(HttpRequest.GET("/"), () -> { try { final String authUserId = "testUser"; final User expectedUser = new User().withAuthUserId(authUserId);  when(securityService.username()).thenReturn(Optional.of(authUserId)); when(userPersistence.getUserByAuthId(authUserId)).thenReturn(Optional.of(expectedUser));  // First call - should fetch from userPersistence final User user1 = currentUserService.getCurrentUser(); Assertions.assertEquals(expectedUser, user1);  // Second call - should use cached user final User user2 = currentUserService.getCurrentUser(); Assertions."<AssertPlaceHolder>";  // Verify that getUserByAuthId is called only once verify(userPersistence, times(1)).getUserByAuthId(authUserId); } catch (final IOException e) { fail(e); } }); }
getCurrentUser() { if (this.retrievedCurrentUser == null) { try { final String authUserId = securityService.username().orElseThrow(); this.retrievedCurrentUser = userPersistence.getUserByAuthId(authUserId).orElseThrow(); log.debug("Setting current user for request to: {}", retrievedCurrentUser); } catch (final Exception e) { throw new AuthException("Could not get the current Airbyte user due to an internal error.", e); } } return this.retrievedCurrentUser; }
[*] target: assertEquals(expectedUser, user2)
[-] pred: org. junit. Assert. assertEquals ( expectedUser, user2 )
************************************
************************************
[+] input: testExecute() { final Supplier<String> supplier = mock(Supplier.class); when(supplier.get()).thenReturn("hello");  final TemporalResponse<String> response = temporalClient.execute(JOB_RUN_CONFIG, supplier);  "<AssertPlaceHolder>"; assertTrue(response.getOutput().isPresent()); assertEquals("hello", response.getOutput().get()); assertTrue(response.getMetadata().isSucceeded()); assertEquals(logPath, response.getMetadata().getLogPath()); }
execute(final JobRunConfig jobRunConfig, final Supplier<T> executor) { final Path jobRoot = TemporalUtils.getJobRoot(workspaceRoot, jobRunConfig.getJobId(), jobRunConfig.getAttemptId()); final Path logPath = TemporalUtils.getLogPath(jobRoot);  T operationOutput = null; RuntimeException exception = null;  try { operationOutput = executor.get(); } catch (final RuntimeException e) { exception = e; }  boolean succeeded = exception == null; if (succeeded && operationOutput instanceof ConnectorJobOutput) { succeeded = getConnectorJobSucceeded((ConnectorJobOutput) operationOutput); }  final JobMetadata metadata = new JobMetadata(succeeded, logPath); return new TemporalResponse<>(operationOutput, metadata); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testExecuteWithException() { final Supplier<String> supplier = mock(Supplier.class); when(supplier.get()).thenThrow(IllegalStateException.class);  final TemporalResponse<String> response = temporalClient.execute(JOB_RUN_CONFIG, supplier);  "<AssertPlaceHolder>"; assertFalse(response.getOutput().isPresent()); assertFalse(response.getMetadata().isSucceeded()); assertEquals(logPath, response.getMetadata().getLogPath()); }
execute(final JobRunConfig jobRunConfig, final Supplier<T> executor) { final Path jobRoot = TemporalUtils.getJobRoot(workspaceRoot, jobRunConfig.getJobId(), jobRunConfig.getAttemptId()); final Path logPath = TemporalUtils.getLogPath(jobRoot);  T operationOutput = null; RuntimeException exception = null;  try { operationOutput = executor.get(); } catch (final RuntimeException e) { exception = e; }  boolean succeeded = exception == null; if (succeeded && operationOutput instanceof ConnectorJobOutput) { succeeded = getConnectorJobSucceeded((ConnectorJobOutput) operationOutput); }  final JobMetadata metadata = new JobMetadata(succeeded, logPath); return new TemporalResponse<>(operationOutput, metadata); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: Exception { destination.accept(STATE_MESSAGE2); destination.accept(STATE_MESSAGE1); destination.notifyEndOfInput();  assertFalse(destination.isFinished()); assertEquals(STATE_MESSAGE2, destination.attemptRead().get()); assertEquals(STATE_MESSAGE1, destination.attemptRead().get()); "<AssertPlaceHolder>"; }
isFinished() { return isFinished && messages.isEmpty(); }
[*] target: assertTrue(destination.isFinished())
[-] pred: org. junit. Assert. assertTrue ( destination. isFinished() )
************************************
************************************
[+] input: testCreateConfigsDatabaseAvailabilityCheck() { final var dslContext = mock(DSLContext.class); final var timeoutMs = 500L; final var check = DatabaseCheckFactory.createConfigsDatabaseAvailabilityCheck(dslContext, timeoutMs);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(ConfigsDatabaseAvailabilityCheck.class, check.getClass()); Assertions.assertEquals(timeoutMs, check.getTimeoutMs()); Assertions.assertTrue(check.getDslContext().isPresent()); Assertions.assertEquals(dslContext, check.getDslContext().get()); }
createConfigsDatabaseAvailabilityCheck(final DSLContext dslContext, final long timeoutMs) { return new ConfigsDatabaseAvailabilityCheck(dslContext, timeoutMs); }
[*] target: assertNotNull(check)
[-] pred: org. junit. Assert. assertNotNull ( check )
************************************
************************************
[+] input: testCreateJobsDatabaseAvailabilityCheck() { final var dslContext = mock(DSLContext.class); final var timeoutMs = 500L; final var check = DatabaseCheckFactory.createJobsDatabaseAvailabilityCheck(dslContext, timeoutMs);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(JobsDatabaseAvailabilityCheck.class, check.getClass()); Assertions.assertEquals(timeoutMs, check.getTimeoutMs()); Assertions.assertTrue(check.getDslContext().isPresent()); Assertions.assertEquals(dslContext, check.getDslContext().get()); }
createJobsDatabaseAvailabilityCheck(final DSLContext dslContext, final long timeoutMs) { return new JobsDatabaseAvailabilityCheck(dslContext, timeoutMs); }
[*] target: assertNotNull(check)
[-] pred: org. junit. Assert. assertNotNull ( check )
************************************
************************************
[+] input: testMigrationBlankDatabase() { final DSLContext ctx = getDslContext();  // this test is specifically ensuring that lack of a workspace record does not cause an error // while creating the default user and organization. assertEquals(0, ctx.fetchCount(DSL.table("workspace")));  V0_50_19_001__CreateDefaultOrganizationAndUser.createDefaultUserAndOrganization(ctx);  // verify that a User record was written to the database final var userRecord = ctx.selectFrom(DSL.table(USER_TABLE)) .where(DSL.field("id").eq(EXPECTED_DEFAULT_USER_ID)) .fetchOne(); "<AssertPlaceHolder>"; assertEquals("", userRecord.get(DSL.field("email", String.class))); assertEquals("Default User", userRecord.get(DSL.field("name", String.class))); assertNull(userRecord.get(DSL.field("default_workspace_id", UUID.class)));  // verify that an Organization record was written to the database final var organizationRecord = ctx.selectFrom(DSL.table("organization")) .where(DSL.field("id").eq(EXPECTED_DEFAULT_ORGANIZATION_ID)) .fetchOne(); assertNotNull(organizationRecord); assertEquals("", organizationRecord.get(DSL.field("email", String.class))); assertEquals("Default Organization", organizationRecord.get(DSL.field("name", String.class))); assertEquals(EXPECTED_DEFAULT_USER_ID, organizationRecord.get(DSL.field("user_id", UUID.class)));  // verify that a permission record was written to add the User to the Organization final var userPermissionRecord = ctx.selectFrom(DSL.table("permission")) .where(DSL.field("user_id").eq(EXPECTED_DEFAULT_USER_ID)) .fetch() .get(0); assertNotNull(userPermissionRecord); assertEquals(EXPECTED_DEFAULT_ORGANIZATION_ID, userPermissionRecord.get(DSL.field("organization_id", SQLDataType.UUID))); }
createDefaultUserAndOrganization(final DSLContext ctx) { // return early if a default user or default organization already exist. // this shouldn't happen in practice, but if this migration somehow gets run // multiple times or an instance is for some reason already using the // all-zero UUID, we don't want to overwrite any existing records. if (ctx.fetchExists(select() .from(DSL.table(USER_TABLE)) .where(ID_COLUMN.eq(DEFAULT_USER_ID)))) { LOGGER.info("Default user already exists. Skipping this migration."); return; }  if (ctx.fetchExists(select() .from(DSL.table(ORGANIZATION_TABLE)) .where(ID_COLUMN.eq(DEFAULT_ORGANIZATION_ID)))) { LOGGER.info("Default organization already exists. Skipping this migration."); return; }  final Optional<UUID> workspaceIdOptional = getDefaultWorkspaceIdOptional(ctx); final String email = workspaceIdOptional.flatMap(workspaceId -> getWorkspaceEmailOptional(ctx, workspaceId)).orElse(DEFAULT_EMAIL); final UUID defaultWorkspaceId = workspaceIdOptional.orElse(null);  // insert the default User record ctx.insertInto(DSL.table(USER_TABLE)) .columns(ID_COLUMN, EMAIL_COLUMN, NAME_COLUMN, AUTH_USER_ID_COLUMN, DEFAULT_WORKSPACE_ID_COLUMN, STATUS_COLUMN, AUTH_PROVIDER_COLUMN) .values(DEFAULT_USER_ID, email, DEFAULT_USER_NAME, DEFAULT_USER_ID.toString(), defaultWorkspaceId, DEFAULT_USER_STATUS, DEFAULT_AUTH_PROVIDER) .execute();  ctx.insertInto(DSL.table(ORGANIZATION_TABLE)) .columns(ID_COLUMN, EMAIL_COLUMN, NAME_COLUMN, USER_ID_COLUMN) .values(DEFAULT_ORGANIZATION_ID, email, DEFAULT_ORGANIZATION_NAME, DEFAULT_USER_ID) .execute();  // update the default workspace to point to the default organization if (workspaceIdOptional.isPresent()) { LOGGER.info("Updating default workspace with ID {} to belong to default organization with ID {}", workspaceIdOptional.get(), DEFAULT_ORGANIZATION_ID); ctx.update(DSL.table(WORKSPACE_TABLE)) .set(ORGANIZATION_ID_COLUMN, DEFAULT_ORGANIZATION_ID) .where(ID_COLUMN.eq(workspaceIdOptional.get())) .execute(); } else { LOGGER.info("No default workspace found. Skipping update of default workspace to point to default organization."); }  // grant the default user admin permissions on the default organization LOGGER.info("Granting ORGANIZATION_ADMIN permission to default user with ID {} on default organization with ID {}", DEFAULT_USER_ID, DEFAULT_ORGANIZATION_ID); ctx.insertInto(DSL.table(PERMISSION_TABLE)) .columns(ID_COLUMN, USER_ID_COLUMN, ORGANIZATION_ID_COLUMN, PERMISSION_TYPE_COLUMN) .values(UUID.randomUUID(), DEFAULT_USER_ID, DEFAULT_ORGANIZATION_ID, PermissionType.ORGANIZATION_ADMIN) .execute(); }
[*] target: assertNotNull(userRecord)
[-] pred: org. junit. Assert. assertNotNull ( userRecord )
************************************
************************************
[+] input: test() { final DSLContext dslContext = getDslContext(); final boolean tableExists = generationTableExists(dslContext);  assertFalse(tableExists);  V0_55_1_002__AddGenerationTable.createGenerationTable(dslContext);  final boolean tableExistsPostMigration = generationTableExists(dslContext);  "<AssertPlaceHolder>";  final Set<String> index = dslContext.select() .from(table("pg_indexes")) .where(field("tablename").eq(STREAM_GENERATION_TABLE_NAME)) .fetch() .stream() .map(c -> c.getValue("indexdef", String.class)) .collect(Collectors.toSet()); assertEquals(3, index.size()); assertTrue(index.contains("CREATE UNIQUE INDEX stream_generation_pkey ON public.stream_generation USING btree (id)")); assertTrue(index.contains( "CREATE INDEX stream_generation_connection_id_stream_name_generation_id_idx " + "ON public.stream_generation USING btree (connection_id, stream_name, generation_id DESC)")); assertTrue(index.contains( "CREATE INDEX stream_generation_connection_id_stream_name_stream_namespac_idx ON public.stream_generation " + "USING btree (connection_id, stream_name, stream_namespace, generation_id DESC)")); }
createGenerationTable(final DSLContext ctx) { final Field<UUID> id = DSL.field("id", SQLDataType.UUID.nullable(false)); final Field<UUID> connectionId = DSL.field("connection_id", SQLDataType.UUID.nullable(false)); final Field<String> streamName = DSL.field("stream_name", SQLDataType.VARCHAR.nullable(false)); final Field<String> streamNamespace = DSL.field("stream_namespace", SQLDataType.VARCHAR.nullable(true)); final Field<Long> generationId = DSL.field("generation_id", SQLDataType.BIGINT.nullable(false)); final Field<Long> startJobId = DSL.field("start_job_id", SQLDataType.BIGINT.nullable(false)); final Field<OffsetDateTime> createdAt = DSL.field("created_at", SQLDataType.TIMESTAMPWITHTIMEZONE.nullable(false).defaultValue(currentOffsetDateTime())); final Field<OffsetDateTime> updatedAt = DSL.field("updated_at", SQLDataType.TIMESTAMPWITHTIMEZONE.nullable(false).defaultValue(currentOffsetDateTime()));  ctx.createTable(STREAM_GENERATION_TABLE_NAME) .columns(id, connectionId, streamName, streamNamespace, generationId, startJobId, createdAt, updatedAt) .constraints( primaryKey(id), foreignKey(connectionId).references("connection", "id").onDeleteCascade()) .execute();  final String indexCreationQuery = String.format("CREATE INDEX ON %s USING btree (%s, %s, %s DESC)", STREAM_GENERATION_TABLE_NAME, connectionId.getName(), streamName.getName(), generationId.getName()); final String indexCreationQuery2 = String.format("CREATE INDEX ON %s USING btree (%s, %s, %s, %s DESC)", STREAM_GENERATION_TABLE_NAME, connectionId.getName(), streamName.getName(), streamNamespace.getName(), generationId.getName()); ctx.execute(indexCreationQuery); ctx.execute(indexCreationQuery2); }
[*] target: assertTrue(tableExistsPostMigration)
[-] pred: org. junit. Assert. assertTrue ( tableExistsPostMigration )
************************************
************************************
[+] input: IllegalAccessException { final ActivityOptions activityOptions = ActivityOptions.newBuilder() .setHeartbeatTimeout(Duration.ofSeconds(30)) .setStartToCloseTimeout(Duration.ofSeconds(120)) .setRetryOptions(RetryOptions.newBuilder() .setMaximumAttempts(5) .setInitialInterval(Duration.ofSeconds(30)) .setMaximumInterval(Duration.ofSeconds(600)) .build()) .build();  final BeanIdentifier activityOptionsBeanIdentifier = mock(BeanIdentifier.class); final BeanRegistration activityOptionsBeanRegistration = mock(BeanRegistration.class); when(activityOptionsBeanIdentifier.getName()).thenReturn("activityOptions"); when(activityOptionsBeanRegistration.getIdentifier()).thenReturn(activityOptionsBeanIdentifier); when(activityOptionsBeanRegistration.getBean()).thenReturn(activityOptions);  final TemporalProxyHelper temporalProxyHelper = new TemporalProxyHelper(List.of(activityOptionsBeanRegistration)); temporalProxyHelper.setActivityStubGenerator((c, a) -> mock(c));  final Class<ValidTestWorkflowImpl> proxy = temporalProxyHelper.proxyWorkflowClass(ValidTestWorkflowImpl.class);  "<AssertPlaceHolder>";  final ValidTestWorkflowImpl proxyImplementation = proxy.getDeclaredConstructor().newInstance(); proxyImplementation.run(); Assertions.assertTrue(proxyImplementation.isHasRun()); }
proxyWorkflowClass(final Class<T> workflowImplClass) { log.debug("Creating a Temporal proxy for worker class '{}' with interface '{}'...", workflowImplClass.getName(), workflowImplClass.getInterfaces()[0]); return (Class<T>) WORKFLOW_PROXY_CACHE.findOrInsert(workflowImplClass.getClassLoader(), workflowImplClass, () -> { final Set<Method> workflowMethods = findAnnotatedMethods(workflowImplClass, WorkflowMethod.class); final Set<Method> signalMethods = findAnnotatedMethods(workflowImplClass, SignalMethod.class); final Set<Method> queryMethods = findAnnotatedMethods(workflowImplClass, QueryMethod.class);  final Set<Method> proxiedMethods = new HashSet<>(); proxiedMethods.add((Method) workflowMethods.toArray()[0]); proxiedMethods.addAll(signalMethods.stream().collect(Collectors.toList())); proxiedMethods.addAll(queryMethods.stream().collect(Collectors.toList()));  final Class<T> type = (Class<T>) new ByteBuddy() .subclass(workflowImplClass) .name(workflowImplClass.getSimpleName() + "Proxy") .implement(workflowImplClass.getInterfaces()[0]) .method(ElementMatchers.anyOf(proxiedMethods.toArray(new Method[] {}))) .intercept( MethodDelegation.to(generateInterceptor(workflowImplClass, availableActivityOptions))) .make() .load(workflowImplClass.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER) .getLoaded();  log.debug("Temporal workflow proxy '{}' created for worker class '{}' with interface '{}'.", type.getName(), workflowImplClass.getName(), workflowImplClass.getInterfaces()[0]); return type; }); }
[*] target: assertNotNull(proxy)
[-] pred: org. junit. Assert. assertNotNull ( proxy )
************************************
************************************
[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: ConfigNotFoundException { setupStandardDefinitionMock(createAdvancedAuth() .withPredicateKey(null) .withPredicateValue(null)); final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: ConfigNotFoundException { setupStandardDefinitionMock(createAdvancedAuth() .withPredicateKey(List.of(CREDENTIALS, AUTH_TYPE)) .withPredicateValue("")); final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: ConfigNotFoundException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); when(actorDefinitionVersionHelper.getSourceVersion(any(), eq(workspaceId), eq(sourceId))).thenReturn(testSourceVersion.withSpec(null)); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final ObjectNode expectedConfig = ((ObjectNode) Jsons.clone(config)); for (final String key : oauthParameters.keySet()) { expectedConfig.set(key, Jsons.jsonNode(oauthParameters.get(key))); } "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: IOException { final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateOAuthParameters(); when(configRepository.getSourceOAuthParameterOptional(any(), any())).thenReturn(Optional.of( new SourceOAuthParameter() .withOauthParameterId(UUID.randomUUID()) .withSourceDefinitionId(sourceDefinitionId) .withWorkspaceId(workspaceId) .withConfiguration(Jsons.jsonNode(oauthParameters)))); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) oauthParameters.get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: IOException { // Until https://github.com/airbytehq/airbyte/issues/7624 is solved, we need to handle nested oauth // parameters final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateNestedOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = Jsons.jsonNode(Map.of( EXISTING_FIELD_NAME, EXISTING_FIELD_VALUE, CREDENTIALS, Map.of( API_SECRET, SECRET_TWO, AUTH_TYPE, OAUTH, API_CLIENT, ((Map<String, String>) oauthParameters.get(CREDENTIALS)).get(API_CLIENT)))); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: IOException { // Until https://github.com/airbytehq/airbyte/issues/7624 is solved, we need to handle nested oauth // parameters final JsonNode config = generateJsonConfig(); final UUID workspaceId = UUID.randomUUID(); final UUID sourceId = UUID.randomUUID(); final Map<String, Object> oauthParameters = generateNestedOAuthParameters(); setupOAuthParamMocks(oauthParameters); final JsonNode actualConfig = oAuthConfigSupplier.injectSourceOAuthParameters(sourceDefinitionId, sourceId, workspaceId, Jsons.clone(config)); final JsonNode expectedConfig = getExpectedNode((String) ((Map<String, Object>) oauthParameters.get(CREDENTIALS)).get(API_CLIENT)); "<AssertPlaceHolder>"; assertTracking(workspaceId); }
injectSourceOAuthParameters(final UUID sourceDefinitionId, final UUID sourceId, final UUID workspaceId, final JsonNode sourceConnectorConfig) throws IOException { try { final StandardSourceDefinition sourceDefinition = configRepository.getStandardSourceDefinition(sourceDefinitionId); final ActorDefinitionVersion sourceVersion = actorDefinitionVersionHelper.getSourceVersion(sourceDefinition, workspaceId, sourceId); configRepository.getSourceOAuthParameterOptional(workspaceId, sourceDefinitionId) .ifPresent(sourceOAuthParameter -> { if (injectOAuthParameters(sourceDefinition.getName(), sourceVersion.getSpec(), sourceOAuthParameter.getConfiguration(), sourceConnectorConfig)) { final Map<String, Object> metadata = TrackingMetadata.generateSourceDefinitionMetadata(sourceDefinition, sourceVersion); Exceptions.swallow(() -> trackingClient.track(workspaceId, "OAuth Injection - Backend", metadata)); } }); return sourceConnectorConfig; } catch (final JsonValidationException | ConfigNotFoundException e) { throw new IOException(e); } }
[*] target: assertEquals(expectedConfig, actualConfig)
[-] pred: org. junit. Assert. assertEquals ( expectedConfig, actualConfig )
************************************
************************************
[+] input: testCreatingFromATestContainer() { final DataSource dataSource = Databases.createDataSource(container); "<AssertPlaceHolder>"; assertEquals(HikariDataSource.class, dataSource.getClass()); assertEquals(10, ((HikariDataSource) dataSource).getHikariConfigMXBean().getMaximumPoolSize()); }
createDataSource(final JdbcDatabaseContainer container) { return DataSourceFactory.create(container.getUsername(), container.getPassword(), container.getDriverClassName(), container.getJdbcUrl()); }
[*] target: assertNotNull(dataSource)
[-] pred: org. junit. Assert. assertNotNull ( dataSource )
************************************
************************************
[+] input: testGetNestServiceByIdExistingServiceId() { SpecificationConfig.ServiceConfig result = specificationConfig.getNestServiceById("1"); "<AssertPlaceHolder>"; assertEquals("1", result.getId()); assertEquals("Service 1", result.getName()); }
getNestServiceById(String serviceId) { if (StringUtils.isEmpty(serviceId)) { return serviceConfigs.get(0); } else { Optional<ServiceConfig> serviceConfig = serviceConfigs.stream().filter(service -> service.getId().equals(serviceId)).findFirst(); return serviceConfig.orElse(serviceConfigs.get(0)); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testGetNestServiceByIdNonExistingServiceId() { SpecificationConfig.ServiceConfig result = specificationConfig.getNestServiceById("3"); "<AssertPlaceHolder>"; assertEquals("1", result.getId()); assertEquals("Service 1", result.getName()); }
getNestServiceById(String serviceId) { if (StringUtils.isEmpty(serviceId)) { return serviceConfigs.get(0); } else { Optional<ServiceConfig> serviceConfig = serviceConfigs.stream().filter(service -> service.getId().equals(serviceId)).findFirst(); return serviceConfig.orElse(serviceConfigs.get(0)); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: isOrderInConsumingReturnsFalse() { Long currentLocalDateTimeMillis = 123456789L; when(order.getBillingStartDateMillis()).thenReturn(null); when(order.getBillingEndDateMillis()).thenReturn(null);  Boolean result = orderOtsHelper.isOrderInConsuming(order, currentLocalDateTimeMillis);  assertTrue(result);  when(order.getBillingStartDateMillis()).thenReturn(123456L); when(order.getBillingEndDateMillis()).thenReturn(1234567L);  result = orderOtsHelper.isOrderInConsuming(order, currentLocalDateTimeMillis);  "<AssertPlaceHolder>"; }
isOrderInConsuming(OrderDTO orderDTO, Long currentLocalDateTimeMillis) { if (orderDTO == null || orderDTO.getBillingStartDateMillis() == null || orderDTO.getBillingEndDateMillis() == null) { return Boolean.TRUE; } return currentLocalDateTimeMillis >= orderDTO.getBillingStartDateMillis() && currentLocalDateTimeMillis < orderDTO.getBillingEndDateMillis(); }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testContainerOpenAndCloseListener() { // Open listener AtomicBoolean openFlag = new AtomicBoolean(false); container.addOnOpenListener(viewer -> { openFlag.set(true); }); container.onOpen(null); assertTrue(openFlag.get());  // Close listener AtomicBoolean closeFlag = new AtomicBoolean(false); container.addOnCloseListener(viewer -> { closeFlag.set(true); }); container.onClose(null); "<AssertPlaceHolder>"; }
onClose(ContainerViewer viewer);  void addOnOpenListener(Consumer<ContainerViewer> listener);  void removeOnOpenListener(Consumer<ContainerViewer> listener);  void addOnCloseListener(Consumer<ContainerViewer> listener);  void removeOnCloseListener(Consumer<ContainerViewer> listener);  void addOnSlotChangeListener(int slot, Consumer<ItemStack> listener);  void removeOnSlotChangeListener(int slot, Consumer<ItemStack> listener);  default ContainerSlotType getSlotType(int slot) { return getContainerType().getSlotType(slot); }
[*] target: assertTrue(closeFlag.get())
[-] pred: org. junit. Assert. assertTrue ( closeFlag. get ( ) )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/getNotificationHistoryResponse.json", request -> { Assertions.assertEquals("POST", request.method()); Assertions.assertEquals("/inApps/v1/notifications/history", request.url().encodedPath()); Assertions.assertEquals("a036bc0e-52b8-4bee-82fc-8c24cb6715d6", request.url().queryParameter("paginationToken")); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(expectedMediaType, body.contentType()); Buffer buffer = new Buffer(); try { body.writeTo(buffer); } catch (IOException e) { throw new RuntimeException(e); } Map<String, Object> root; try { root = new ObjectMapper().readValue(buffer.readUtf8(), Map.class); } catch (JsonProcessingException e) { throw new RuntimeException(e); } Assertions.assertEquals(1698148900000L, ((Number) root.get("startDate")).longValue()); Assertions.assertEquals(1698148950000L, ((Number) root.get("endDate")).longValue()); Assertions.assertEquals("SUBSCRIBED", root.get("notificationType")); Assertions.assertEquals("INITIAL_BUY", root.get("notificationSubtype")); Assertions.assertEquals("999733843", root.get("transactionId")); Assertions.assertTrue((Boolean) root.get("onlyFailures")); });  NotificationHistoryRequest notificationHistoryRequest = new NotificationHistoryRequest() .startDate(1698148900000L) .endDate(1698148950000L) .notificationType(NotificationTypeV2.SUBSCRIBED) .notificationSubtype(Subtype.INITIAL_BUY) .transactionId("999733843") .onlyFailures(true);  NotificationHistoryResponse notificationHistoryResponse = client.getNotificationHistory("a036bc0e-52b8-4bee-82fc-8c24cb6715d6", notificationHistoryRequest);  Assertions.assertNotNull(notificationHistoryResponse); Assertions.assertEquals("57715481-805a-4283-8499-1c19b5d6b20a", notificationHistoryResponse.getPaginationToken()); Assertions.assertTrue(notificationHistoryResponse.getHasMore()); List<NotificationHistoryResponseItem> expectedNotificationHistory = List.of( new NotificationHistoryResponseItem() .sendAttempts(List.of( new SendAttemptItem() .attemptDate(1698148900000L) .sendAttemptResult(SendAttemptResult.NO_RESPONSE), new SendAttemptItem() .attemptDate(1698148950000L) .sendAttemptResult(SendAttemptResult.SUCCESS) )) .signedPayload("signed_payload_one"), new NotificationHistoryResponseItem() .sendAttempts(List.of( new SendAttemptItem() .attemptDate(1698148800000L) .sendAttemptResult(SendAttemptResult.CIRCULAR_REDIRECT) )) .signedPayload("signed_payload_two") ); Assertions.assertEquals(expectedNotificationHistory, notificationHistoryResponse.getNotificationHistory()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred: org. junit. Assert. assertNotNull ( body )
************************************
************************************
[+] input: IOException { AppStoreServerAPIClient client = getClientWithBody("models/requestTestNotificationResponse.json", request -> { Assertions.assertEquals("POST", request.method()); Assertions.assertEquals("/inApps/v1/notifications/test", request.url().encodedPath()); RequestBody body = request.body(); Assertions."<AssertPlaceHolder>"; Assertions.assertNull(body.contentType()); try { Assertions.assertEquals(0, body.contentLength()); } catch (IOException e) { throw new RuntimeException(e); } });  SendTestNotificationResponse sendTestNotificationResponse = client.requestTestNotification();  Assertions.assertNotNull(sendTestNotificationResponse); Assertions.assertEquals("ce3af791-365e-4c60-841b-1674b43c1609", sendTestNotificationResponse.getTestNotificationToken()); }
body() { ResponseBody responseBody = response.body(); return responseBody != null ? responseBody.charStream() : null; }
[*] target: assertNotNull(body)
[-] pred: org. junit. Assert. assertNotNull ( body )
************************************
************************************
[+] input: Exception { try (InputStream key = this.getClass().getClassLoader().getResourceAsStream("certs/testSigningKey.p8")) { Assertions.assertNotNull(key); var tokenGenerator = new BearerTokenAuthenticator(new String(key.readAllBytes()), "keyId", "issuerId", "bundleId"); String token = tokenGenerator.generateToken(); Assertions."<AssertPlaceHolder>"; } }
generateToken() { return JWT.create() .withAudience(APP_STORE_CONNECT_AUDIENCE) .withExpiresAt(Instant.now().plus(ChronoUnit.MINUTES.getDuration().multipliedBy(5))) .withIssuer(issuerId) .withKeyId(keyId) .withPayload(Map.of(BUNDLE_ID_KEY, bundleId)) .sign(Algorithm.ECDSA256(signingKey)); }
[*] target: assertNotNull(token)
[-] pred: org. junit. Assert. assertNotNull ( token )
************************************
************************************
[+] input: IOException { try (SqlSession session = getSessionFactory().openSession()) { S3StreamSetObjectMapper mapper = session.getMapper(S3StreamSetObjectMapper.class);  S3StreamSetObject walObject = new S3StreamSetObject(); walObject.setNodeId(1); walObject.setObjectSize(128L); walObject.setObjectId(2L); walObject.setSequenceId(3L); walObject.setBaseDataTimestamp(new Date()); walObject.setCommittedTimestamp(new Date()); walObject.setCreatedTimestamp(new Date()); SubStreams subStreams = SubStreams.newBuilder() .putSubStreams(1, SubStream.newBuilder().setStreamId(1).setStartOffset(0).setEndOffset(10).build()) .putSubStreams(2, SubStream.newBuilder().setStreamId(2).setStartOffset(0).setEndOffset(10).build()) .putSubStreams(3, SubStream.newBuilder().setStreamId(3).setStartOffset(0).setEndOffset(10).build()) .build(); walObject.setSubStreams(JsonFormat.printer().print(subStreams)); int rowsAffected = mapper.create(walObject); Assertions."<AssertPlaceHolder>";  Assertions.assertTrue(mapper.streamExclusive(1, 1)); Assertions.assertTrue(mapper.streamExclusive(1, 2)); Assertions.assertTrue(mapper.streamExclusive(1, 3));  Assertions.assertFalse(mapper.streamExclusive(2, 1)); Assertions.assertFalse(mapper.streamExclusive(2, 2)); Assertions.assertFalse(mapper.streamExclusive(2, 3)); } }
setSubStreams(String subStreams) { this.subStreams = subStreams; }
[*] target: assertEquals(1, rowsAffected)
[-] pred: org. junit. Assert. assertEquals ( 1, rowsAffected )
************************************
************************************
[+] input: queryRoute() { QueryRouteRequest request = QueryRouteRequest.newBuilder() .setTopic(Resource.newBuilder().setName("topic").build()) .build();  CompletableFuture<QueryRouteResponse> future = routeActivity.queryRoute(ProxyContextExt.create(), request); "<AssertPlaceHolder>"; assertTrue(future.isDone()); assertFalse(future.isCompletedExceptionally());  QueryRouteResponse response = future.join(); assertEquals(Code.OK, response.getStatus().getCode()); assertEquals(1, response.getMessageQueuesList().size());  MessageQueue queue = response.getMessageQueuesList().get(0); assertEquals(2, queue.getId());  Broker broker = queue.getBroker(); assertEquals("1_2", broker.getName()); assertEquals(1, broker.getEndpoints().getAddressesCount());  apache.rocketmq.v2.Address addresses = broker.getEndpoints().getAddresses(0); assertEquals("broker", addresses.getHost()); assertEquals(10911, addresses.getPort()); }
queryRoute(ProxyContext ctx, QueryRouteRequest request) { return super.queryRoute(ctx, request).thenApply(response -> { QueryRouteResponse.Builder newBuilder = QueryRouteResponse.newBuilder(response); List<MessageQueue> mqList = newBuilder.getMessageQueuesList(); for (int i = 0; i < mqList.size(); i++) { MessageQueue messageQueue = mqList.get(i); VirtualQueue virtualQueue = new VirtualQueue(messageQueue.getBroker().getName());  MessageQueue newQueue = MessageQueue.newBuilder(messageQueue).setId(virtualQueue.physicalQueueId()).build(); newBuilder.setMessageQueues(i, newQueue); } return newBuilder.build(); }); }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: queryAssignment() { QueryAssignmentRequest request = QueryAssignmentRequest.newBuilder() .setTopic(Resource.newBuilder().setName("topic").build()) .setGroup(Resource.newBuilder().setName("group").build()) .build();  CompletableFuture<QueryAssignmentResponse> future = routeActivity.queryAssignment(ProxyContextExt.create(), request); "<AssertPlaceHolder>"; assertTrue(future.isDone()); assertFalse(future.isCompletedExceptionally());  QueryAssignmentResponse response = future.join(); assertEquals(Code.OK, response.getStatus().getCode()); assertEquals(1, response.getAssignmentsList().size());  MessageQueue queue = response.getAssignmentsList().get(0).getMessageQueue(); assertEquals(2, queue.getId());  Broker broker = queue.getBroker(); assertEquals("1_2", broker.getName()); assertEquals(1, broker.getEndpoints().getAddressesCount());  apache.rocketmq.v2.Address addresses = broker.getEndpoints().getAddresses(0); assertEquals("broker", addresses.getHost()); assertEquals(10911, addresses.getPort());  }
queryAssignment(ProxyContext ctx, QueryAssignmentRequest request) { return super.queryAssignment(ctx, request).thenApply(response -> { QueryAssignmentResponse.Builder newBuilder = QueryAssignmentResponse.newBuilder(response); List<Assignment> assignmentsList = newBuilder.getAssignmentsList(); for (int i = 0; i < assignmentsList.size(); i++) { Assignment assignment = assignmentsList.get(i); MessageQueue messageQueue = assignment.getMessageQueue(); VirtualQueue virtualQueue = new VirtualQueue(messageQueue.getBroker().getName());  MessageQueue newQueue = MessageQueue.newBuilder(messageQueue).setId(virtualQueue.physicalQueueId()).build(); Assignment newAssignment = Assignment.newBuilder(assignment).setMessageQueue(newQueue).build(); newBuilder.setAssignments(i, newAssignment); } return newBuilder.build(); }); }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testStaticMemberRoundRobinAssignmentPersistent() { // Have 3 static members instance1, instance2, instance3 to be persistent // across generations. Their assignment shall be the same. String consumer1 = "consumer1"; String instance1 = "instance1"; String consumer2 = "consumer2"; String instance2 = "instance2"; String consumer3 = "consumer3"; String instance3 = "instance3";  List<MemberInfo> staticMemberInfos = new ArrayList<>(); staticMemberInfos.add(new MemberInfo(consumer1, Optional.of(instance1))); staticMemberInfos.add(new MemberInfo(consumer2, Optional.of(instance2))); staticMemberInfos.add(new MemberInfo(consumer3, Optional.of(instance3)));  // Consumer 4 is a dynamic member. String consumer4 = "consumer4";  Map<String, Integer> partitionsPerTopic = setupPartitionsPerTopicWithTwoTopics(3, 3);  Map<String, Subscription> consumers = new HashMap<>(); for (MemberInfo m : staticMemberInfos) { Subscription subscription = new Subscription(topics(topic1, topic2), null); subscription.setGroupInstanceId(m.groupInstanceId); consumers.put(m.memberId, subscription); } consumers.put(consumer4, new Subscription(topics(topic1, topic2)));  Map<String, List<TopicPartition>> expectedAssignment = new HashMap<>(); expectedAssignment.put(consumer1, partitions(tp(topic1, 0), tp(topic2, 1))); expectedAssignment.put(consumer2, partitions(tp(topic1, 1), tp(topic2, 2))); expectedAssignment.put(consumer3, partitions(tp(topic1, 2))); expectedAssignment.put(consumer4, partitions(tp(topic2, 0)));  Map<String, List<TopicPartition>> assignment = assignor.assign(partitionsPerTopic, consumers); assertEquals(expectedAssignment, assignment);  // Replace dynamic member 4 with a new dynamic member 5. consumers.remove(consumer4); String consumer5 = "consumer5"; consumers.put(consumer5, new Subscription(topics(topic1, topic2)));  expectedAssignment.remove(consumer4); expectedAssignment.put(consumer5, partitions(tp(topic2, 0))); assignment = assignor.assign(partitionsPerTopic, consumers); "<AssertPlaceHolder>"; }
assign(Map<String, Integer> partitionsPerTopic, Map<String, Subscription> subscriptions) { Map<String, List<TopicPartition>> assignment = new HashMap<>(); List<MemberInfo> memberInfoList = new ArrayList<>(); for (Map.Entry<String, Subscription> memberSubscription : subscriptions.entrySet()) { assignment.put(memberSubscription.getKey(), new ArrayList<>()); memberInfoList.add(new MemberInfo(memberSubscription.getKey(), memberSubscription.getValue().groupInstanceId())); }  CircularIterator<MemberInfo> assigner = new CircularIterator<>(Utils.sorted(memberInfoList));  for (TopicPartition partition : allPartitionsSorted(partitionsPerTopic, subscriptions)) { final String topic = partition.topic(); while (!subscriptions.get(assigner.peek().memberId).topics().contains(topic)) assigner.next(); assignment.get(assigner.next().memberId).add(partition); } return assignment; }
[*] target: assertEquals(expectedAssignment, assignment)
[-] pred: org. junit. Assert. assertEquals ( expectedAssignment, assignment )
************************************
************************************
[+] input: testOnJoinPrepareWithOffsetCommitShouldKeepJoinAfterNonRetryableException() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.empty(), false)) { int generationId = 42; String memberId = "consumer-42";  Timer pollTimer = time.timer(100L); client.prepareResponse(offsetCommitResponse(singletonMap(t1p, Errors.UNKNOWN_MEMBER_ID))); boolean res = coordinator.onJoinPrepare(pollTimer, generationId, memberId); "<AssertPlaceHolder>";  assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
onJoinPrepare(Timer timer, int generation, String memberId) { log.debug("Executing onJoinPrepare with generation {} and memberId {}", generation, memberId); if (joinPrepareTimer == null) { // We should complete onJoinPrepare before rebalanceTimeoutMs, // and continue to join group to avoid member got kicked out from group joinPrepareTimer = time.timer(rebalanceConfig.rebalanceTimeoutMs); } else { joinPrepareTimer.update(); }  // async commit offsets prior to rebalance if auto-commit enabled // and there is no in-flight offset commit request if (autoCommitEnabled && autoCommitOffsetRequestFuture == null) { maybeMarkPartitionsPendingRevocation(); autoCommitOffsetRequestFuture = maybeAutoCommitOffsetsAsync(); }  // wait for commit offset response before timer expired if (autoCommitOffsetRequestFuture != null) { Timer pollTimer = timer.remainingMs() < joinPrepareTimer.remainingMs() ? timer : joinPrepareTimer; client.poll(autoCommitOffsetRequestFuture, pollTimer); joinPrepareTimer.update();  // Keep retrying/waiting the offset commit when: // 1. offset commit haven't done (and joinPrepareTimer not expired) // 2. failed with retriable exception (and joinPrepareTimer not expired) // Otherwise, continue to revoke partitions, ex: // 1. if joinPrepareTimer has expired // 2. if offset commit failed with non-retriable exception // 3. if offset commit success boolean onJoinPrepareAsyncCommitCompleted = true; if (joinPrepareTimer.isExpired()) { log.error("Asynchronous auto-commit of offsets failed: joinPrepare timeout. Will continue to join group"); } else if (!autoCommitOffsetRequestFuture.isDone()) { onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && autoCommitOffsetRequestFuture.isRetriable()) { log.debug("Asynchronous auto-commit of offsets failed with retryable error: {}. Will retry it.", autoCommitOffsetRequestFuture.exception().getMessage()); onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && !autoCommitOffsetRequestFuture.isRetriable()) { log.error("Asynchronous auto-commit of offsets failed: {}. Will continue to join group.", autoCommitOffsetRequestFuture.exception().getMessage()); } if (autoCommitOffsetRequestFuture.isDone()) { autoCommitOffsetRequestFuture = null; } if (!onJoinPrepareAsyncCommitCompleted) { pollTimer.sleep(Math.min(pollTimer.remainingMs(), rebalanceConfig.retryBackoffMs)); timer.update(); return false; } }  // the generation / member-id can possibly be reset by the heartbeat thread // upon getting errors or heartbeat timeouts; in this case whatever is previously // owned partitions would be lost, we should trigger the callback and cleanup the assignment; // otherwise we can proceed normally and revoke the partitions depending on the protocol, // and in that case we should only change the assignment AFTER the revoke callback is triggered // so that users can still access the previously owned partitions to commit offsets etc. Exception exception = null; final SortedSet<TopicPartition> revokedPartitions = new TreeSet<>(COMPARATOR); if (generation == Generation.NO_GENERATION.generationId || memberId.equals(Generation.NO_GENERATION.memberId)) { revokedPartitions.addAll(subscriptions.assignedPartitions());  if (!revokedPartitions.isEmpty()) { log.info("Giving away all assigned partitions as lost since generation/memberID has been reset," + "indicating that consumer is in old state or no longer part of the group"); exception = rebalanceListenerInvoker.invokePartitionsLost(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet()); } } else { switch (protocol) { case EAGER: // revoke all partitions revokedPartitions.addAll(subscriptions.assignedPartitions()); exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet());  break;  case COOPERATIVE: // only revoke those partitions that are not in the subscription anymore. Set<TopicPartition> ownedPartitions = new HashSet<>(subscriptions.assignedPartitions()); revokedPartitions.addAll(ownedPartitions.stream() .filter(tp -> !subscriptions.subscription().contains(tp.topic())) .collect(Collectors.toSet()));  if (!revokedPartitions.isEmpty()) { exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  ownedPartitions.removeAll(revokedPartitions); subscriptions.assignFromSubscribed(ownedPartitions); }  break; } }  isLeader = false; subscriptions.resetGroupSubscription(); joinPrepareTimer = null; autoCommitOffsetRequestFuture = null; timer.update();  if (exception != null) { throw new KafkaException("User rebalance callback throws an error", exception); } return true; }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: testOnJoinPrepareWithOffsetCommitShouldKeepJoinAfterRebalanceTimeout() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.empty(), false)) { int generationId = 42; String memberId = "consumer-42";  Timer pollTimer = time.timer(0L); boolean res = coordinator.onJoinPrepare(pollTimer, generationId, memberId); assertFalse(res);  pollTimer = time.timer(100L); time.sleep(rebalanceTimeoutMs); client.respond(offsetCommitResponse(singletonMap(t1p, Errors.UNKNOWN_TOPIC_OR_PARTITION))); res = coordinator.onJoinPrepare(pollTimer, generationId, memberId); "<AssertPlaceHolder>";  assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
onJoinPrepare(Timer timer, int generation, String memberId) { log.debug("Executing onJoinPrepare with generation {} and memberId {}", generation, memberId); if (joinPrepareTimer == null) { // We should complete onJoinPrepare before rebalanceTimeoutMs, // and continue to join group to avoid member got kicked out from group joinPrepareTimer = time.timer(rebalanceConfig.rebalanceTimeoutMs); } else { joinPrepareTimer.update(); }  // async commit offsets prior to rebalance if auto-commit enabled // and there is no in-flight offset commit request if (autoCommitEnabled && autoCommitOffsetRequestFuture == null) { maybeMarkPartitionsPendingRevocation(); autoCommitOffsetRequestFuture = maybeAutoCommitOffsetsAsync(); }  // wait for commit offset response before timer expired if (autoCommitOffsetRequestFuture != null) { Timer pollTimer = timer.remainingMs() < joinPrepareTimer.remainingMs() ? timer : joinPrepareTimer; client.poll(autoCommitOffsetRequestFuture, pollTimer); joinPrepareTimer.update();  // Keep retrying/waiting the offset commit when: // 1. offset commit haven't done (and joinPrepareTimer not expired) // 2. failed with retriable exception (and joinPrepareTimer not expired) // Otherwise, continue to revoke partitions, ex: // 1. if joinPrepareTimer has expired // 2. if offset commit failed with non-retriable exception // 3. if offset commit success boolean onJoinPrepareAsyncCommitCompleted = true; if (joinPrepareTimer.isExpired()) { log.error("Asynchronous auto-commit of offsets failed: joinPrepare timeout. Will continue to join group"); } else if (!autoCommitOffsetRequestFuture.isDone()) { onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && autoCommitOffsetRequestFuture.isRetriable()) { log.debug("Asynchronous auto-commit of offsets failed with retryable error: {}. Will retry it.", autoCommitOffsetRequestFuture.exception().getMessage()); onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && !autoCommitOffsetRequestFuture.isRetriable()) { log.error("Asynchronous auto-commit of offsets failed: {}. Will continue to join group.", autoCommitOffsetRequestFuture.exception().getMessage()); } if (autoCommitOffsetRequestFuture.isDone()) { autoCommitOffsetRequestFuture = null; } if (!onJoinPrepareAsyncCommitCompleted) { pollTimer.sleep(Math.min(pollTimer.remainingMs(), rebalanceConfig.retryBackoffMs)); timer.update(); return false; } }  // the generation / member-id can possibly be reset by the heartbeat thread // upon getting errors or heartbeat timeouts; in this case whatever is previously // owned partitions would be lost, we should trigger the callback and cleanup the assignment; // otherwise we can proceed normally and revoke the partitions depending on the protocol, // and in that case we should only change the assignment AFTER the revoke callback is triggered // so that users can still access the previously owned partitions to commit offsets etc. Exception exception = null; final SortedSet<TopicPartition> revokedPartitions = new TreeSet<>(COMPARATOR); if (generation == Generation.NO_GENERATION.generationId || memberId.equals(Generation.NO_GENERATION.memberId)) { revokedPartitions.addAll(subscriptions.assignedPartitions());  if (!revokedPartitions.isEmpty()) { log.info("Giving away all assigned partitions as lost since generation/memberID has been reset," + "indicating that consumer is in old state or no longer part of the group"); exception = rebalanceListenerInvoker.invokePartitionsLost(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet()); } } else { switch (protocol) { case EAGER: // revoke all partitions revokedPartitions.addAll(subscriptions.assignedPartitions()); exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet());  break;  case COOPERATIVE: // only revoke those partitions that are not in the subscription anymore. Set<TopicPartition> ownedPartitions = new HashSet<>(subscriptions.assignedPartitions()); revokedPartitions.addAll(ownedPartitions.stream() .filter(tp -> !subscriptions.subscription().contains(tp.topic())) .collect(Collectors.toSet()));  if (!revokedPartitions.isEmpty()) { exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  ownedPartitions.removeAll(revokedPartitions); subscriptions.assignFromSubscribed(ownedPartitions); }  break; } }  isLeader = false; subscriptions.resetGroupSubscription(); joinPrepareTimer = null; autoCommitOffsetRequestFuture = null; timer.update();  if (exception != null) { throw new KafkaException("User rebalance callback throws an error", exception); } return true; }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: testJoinPrepareWithDisableAutoCommit() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, false, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);  int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId);  "<AssertPlaceHolder>"; assertTrue(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
onJoinPrepare(Timer timer, int generation, String memberId) { log.debug("Executing onJoinPrepare with generation {} and memberId {}", generation, memberId); if (joinPrepareTimer == null) { // We should complete onJoinPrepare before rebalanceTimeoutMs, // and continue to join group to avoid member got kicked out from group joinPrepareTimer = time.timer(rebalanceConfig.rebalanceTimeoutMs); } else { joinPrepareTimer.update(); }  // async commit offsets prior to rebalance if auto-commit enabled // and there is no in-flight offset commit request if (autoCommitEnabled && autoCommitOffsetRequestFuture == null) { maybeMarkPartitionsPendingRevocation(); autoCommitOffsetRequestFuture = maybeAutoCommitOffsetsAsync(); }  // wait for commit offset response before timer expired if (autoCommitOffsetRequestFuture != null) { Timer pollTimer = timer.remainingMs() < joinPrepareTimer.remainingMs() ? timer : joinPrepareTimer; client.poll(autoCommitOffsetRequestFuture, pollTimer); joinPrepareTimer.update();  // Keep retrying/waiting the offset commit when: // 1. offset commit haven't done (and joinPrepareTimer not expired) // 2. failed with retriable exception (and joinPrepareTimer not expired) // Otherwise, continue to revoke partitions, ex: // 1. if joinPrepareTimer has expired // 2. if offset commit failed with non-retriable exception // 3. if offset commit success boolean onJoinPrepareAsyncCommitCompleted = true; if (joinPrepareTimer.isExpired()) { log.error("Asynchronous auto-commit of offsets failed: joinPrepare timeout. Will continue to join group"); } else if (!autoCommitOffsetRequestFuture.isDone()) { onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && autoCommitOffsetRequestFuture.isRetriable()) { log.debug("Asynchronous auto-commit of offsets failed with retryable error: {}. Will retry it.", autoCommitOffsetRequestFuture.exception().getMessage()); onJoinPrepareAsyncCommitCompleted = false; } else if (autoCommitOffsetRequestFuture.failed() && !autoCommitOffsetRequestFuture.isRetriable()) { log.error("Asynchronous auto-commit of offsets failed: {}. Will continue to join group.", autoCommitOffsetRequestFuture.exception().getMessage()); } if (autoCommitOffsetRequestFuture.isDone()) { autoCommitOffsetRequestFuture = null; } if (!onJoinPrepareAsyncCommitCompleted) { pollTimer.sleep(Math.min(pollTimer.remainingMs(), rebalanceConfig.retryBackoffMs)); timer.update(); return false; } }  // the generation / member-id can possibly be reset by the heartbeat thread // upon getting errors or heartbeat timeouts; in this case whatever is previously // owned partitions would be lost, we should trigger the callback and cleanup the assignment; // otherwise we can proceed normally and revoke the partitions depending on the protocol, // and in that case we should only change the assignment AFTER the revoke callback is triggered // so that users can still access the previously owned partitions to commit offsets etc. Exception exception = null; final SortedSet<TopicPartition> revokedPartitions = new TreeSet<>(COMPARATOR); if (generation == Generation.NO_GENERATION.generationId || memberId.equals(Generation.NO_GENERATION.memberId)) { revokedPartitions.addAll(subscriptions.assignedPartitions());  if (!revokedPartitions.isEmpty()) { log.info("Giving away all assigned partitions as lost since generation/memberID has been reset," + "indicating that consumer is in old state or no longer part of the group"); exception = rebalanceListenerInvoker.invokePartitionsLost(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet()); } } else { switch (protocol) { case EAGER: // revoke all partitions revokedPartitions.addAll(subscriptions.assignedPartitions()); exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  subscriptions.assignFromSubscribed(Collections.emptySet());  break;  case COOPERATIVE: // only revoke those partitions that are not in the subscription anymore. Set<TopicPartition> ownedPartitions = new HashSet<>(subscriptions.assignedPartitions()); revokedPartitions.addAll(ownedPartitions.stream() .filter(tp -> !subscriptions.subscription().contains(tp.topic())) .collect(Collectors.toSet()));  if (!revokedPartitions.isEmpty()) { exception = rebalanceListenerInvoker.invokePartitionsRevoked(revokedPartitions);  ownedPartitions.removeAll(revokedPartitions); subscriptions.assignFromSubscribed(ownedPartitions); }  break; } }  isLeader = false; subscriptions.resetGroupSubscription(); joinPrepareTimer = null; autoCommitOffsetRequestFuture = null; timer.update();  if (exception != null) { throw new KafkaException("User rebalance callback throws an error", exception); } return true; }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: testJoinPrepareAndCommitCompleted() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE); int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId); coordinator.invokeCompletedOffsetCommitCallbacks();  "<AssertPlaceHolder>"; assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: testJoinPrepareAndCommitWithCoordinatorNotAvailable() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.COORDINATOR_NOT_AVAILABLE);  int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId); coordinator.invokeCompletedOffsetCommitCallbacks();  "<AssertPlaceHolder>"; assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertTrue(coordinator.coordinatorUnknown()); } }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertFalse(res)
[-] pred: org. junit. Assert. assertFalse ( res )
************************************
************************************
[+] input: testJoinPrepareAndCommitWithUnknownMemberId() { try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, true, Optional.of("group-id"), true)) { coordinator.ensureActiveGroup();  prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.UNKNOWN_MEMBER_ID);  int generationId = 42; String memberId = "consumer-42";  boolean res = coordinator.onJoinPrepare(time.timer(0L), generationId, memberId); coordinator.invokeCompletedOffsetCommitCallbacks();  "<AssertPlaceHolder>"; assertFalse(client.hasPendingResponses()); assertFalse(client.hasInFlightRequests()); assertFalse(coordinator.coordinatorUnknown()); } }
invokeCompletedOffsetCommitCallbacks() { if (asyncCommitFenced.get()) { throw new FencedInstanceIdException("Get fenced exception for group.instance.id " + rebalanceConfig.groupInstanceId.orElse("unset_instance_id") + ", current member.id is " + memberId()); } while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) { break; } completion.invoke(); } }
[*] target: assertTrue(res)
[-] pred: org. junit. Assert. assertTrue ( res )
************************************
************************************
[+] input: testCloseClearsData() { // We don't use the try-with-resources approach because we want to have access to the FetchBuffer after // the try block so that we can run our asserts on the object. FetchBuffer fetchBuffer = null;  try { fetchBuffer = new FetchBuffer(logContext); assertNull(fetchBuffer.nextInLineFetch()); assertTrue(fetchBuffer.isEmpty());  fetchBuffer.add(completedFetch(topicAPartition0)); assertFalse(fetchBuffer.isEmpty());  fetchBuffer.setNextInLineFetch(completedFetch(topicAPartition0)); assertNotNull(fetchBuffer.nextInLineFetch()); } finally { if (fetchBuffer != null) fetchBuffer.close(); }  assertNull(fetchBuffer.nextInLineFetch()); "<AssertPlaceHolder>"; }
isEmpty() { try { lock.lock(); return completedFetches.isEmpty(); } finally { lock.unlock(); } }
[*] target: assertTrue(fetchBuffer.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( fetchBuffer. isEmpty ( ) )
************************************
************************************
[+] input: testBasicCompletion() { RequestFuture<String> future = new RequestFuture<>(); String value = "foo"; future.complete(value); assertTrue(future.isDone()); "<AssertPlaceHolder>"; }
value() { if (!succeeded()) throw new IllegalStateException("Attempt to retrieve value from future which hasn't successfully completed"); return (T) result.get(); }
[*] target: assertEquals(value, future.value())
[-] pred: org. junit. Assert. assertEquals ( value, future. value() )
************************************
************************************
[+] input: Exception { final SimpleExampleMessageData message = new SimpleExampleMessageData(); message.setMyStruct(new SimpleExampleMessageData.MyStruct().setStructId(25).setArrayInStruct( Collections.singletonList(new SimpleExampleMessageData.StructArray().setArrayFieldId(20)) )); message.setMyTaggedStruct(new SimpleExampleMessageData.TaggedStruct().setStructId("abc"));  message.setProcessId(Uuid.randomUuid()); message.setMyNullableString("notNull"); message.setMyInt16((short) 3); message.setMyString("test string"); SimpleExampleMessageData duplicate = message.duplicate(); "<AssertPlaceHolder>"; assertEquals(message, duplicate); duplicate.setMyTaggedIntArray(Collections.singletonList(123)); assertNotEquals(duplicate, message); assertNotEquals(message, duplicate);  testAllMessageRoundTripsFromVersion((short) 2, message); }
duplicate();
[*] target: assertEquals(duplicate, message)
[-] pred: org. junit. Assert. assertEquals ( duplicate, message )
************************************
************************************
[+] input: testErrorCountsNoTopLevelError() { for (short version : LEADER_AND_ISR.allVersions()) { LeaderAndIsrResponse response; if (version < 5) { List<LeaderAndIsrPartitionError> partitions = createPartitions("foo", asList(Errors.NONE, Errors.CLUSTER_AUTHORIZATION_FAILED)); response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData() .setErrorCode(Errors.NONE.code()) .setPartitionErrors(partitions), version); } else { Uuid id = Uuid.randomUuid(); LeaderAndIsrTopicErrorCollection topics = createTopic(id, asList(Errors.NONE, Errors.CLUSTER_AUTHORIZATION_FAILED)); response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData() .setErrorCode(Errors.NONE.code()) .setTopics(topics), version); } Map<Errors, Integer> errorCounts = response.errorCounts(); "<AssertPlaceHolder>"; assertEquals(2, errorCounts.get(Errors.NONE).intValue()); assertEquals(1, errorCounts.get(Errors.CLUSTER_AUTHORIZATION_FAILED).intValue()); } }
errorCounts() { Errors error = error(); if (error != Errors.NONE) { // Minor optimization since the top-level error applies to all partitions if (version < 5) return Collections.singletonMap(error, data.partitionErrors().size() + 1); return Collections.singletonMap(error, data.topics().stream().mapToInt(t -> t.partitionErrors().size()).sum() + 1); } Map<Errors, Integer> errors; if (version < 5) errors = errorCounts(data.partitionErrors().stream().map(l -> Errors.forCode(l.errorCode()))); else errors = errorCounts(data.topics().stream().flatMap(t -> t.partitionErrors().stream()).map(l -> Errors.forCode(l.errorCode()))); updateErrorCounts(errors, Errors.NONE); return errors; }
[*] target: assertEquals(2, errorCounts.size())
[-] pred: org. junit. Assert. assertEquals ( 2, errorCounts. size ( ) )
************************************
************************************
[+] input: testShouldThrottle() { for (short version : ApiKeys.OFFSET_FETCH.allVersions()) { if (version < 8) { OffsetFetchResponse response = new OffsetFetchResponse(throttleTimeMs, Errors.NONE, partitionDataMap); if (version >= 4) { assertTrue(response.shouldClientThrottle(version)); } else { assertFalse(response.shouldClientThrottle(version)); } } else { OffsetFetchResponse response = new OffsetFetchResponse( throttleTimeMs, Collections.singletonMap(groupOne, Errors.NOT_COORDINATOR), Collections.singletonMap(groupOne, partitionDataMap)); "<AssertPlaceHolder>"; } } }
shouldClientThrottle(short version) { return version >= 4; }
[*] target: assertTrue(response.shouldClientThrottle(version))
[-] pred: org. junit. Assert. assertTrue ( response. shouldClientThrottle( version ) )
************************************
************************************
[+] input: testRequestHeaderV1() { short apiVersion = 1; RequestHeader header = new RequestHeader(ApiKeys.FIND_COORDINATOR, apiVersion, "", 10); assertEquals(1, header.headerVersion());  ByteBuffer buffer = RequestTestUtils.serializeRequestHeader(header); assertEquals(10, buffer.remaining()); RequestHeader deserialized = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { short apiKey = -1; try { // We derive the header version from the request api version, so we read that first. // The request api version is part of `RequestHeaderData`, so we reset the buffer position after the read. int bufferStartPositionForHeader = buffer.position(); apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); short headerVersion = ApiKeys.forId(apiKey).requestHeaderVersion(apiVersion); buffer.position(bufferStartPositionForHeader); final RequestHeaderData headerData = new RequestHeaderData(new ByteBufferAccessor(buffer), headerVersion); // Due to a quirk in the protocol, client ID is marked as nullable. // However, we treat a null client ID as equivalent to an empty client ID. if (headerData.clientId() == null) { headerData.setClientId(""); } final RequestHeader header = new RequestHeader(headerData, headerVersion); // Size of header is calculated by the shift in the position of buffer's start position during parsing. // Prior to parsing, the buffer's start position points to header data and after the parsing operation // the buffer's start position points to api message. For more information on how the buffer is // constructed, see RequestUtils#serialize() header.size = Math.max(buffer.position() - bufferStartPositionForHeader, 0); return header; } catch (UnsupportedVersionException e) { throw new InvalidRequestException("Unknown API key " + apiKey, e); } catch (Throwable ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + apiKey, ex); } }
[*] target: assertEquals(header, deserialized)
[-] pred: org. junit. Assert. assertEquals ( header, deserialized )
************************************
************************************
[+] input: testRequestHeaderV2() { short apiVersion = 2; RequestHeader header = new RequestHeader(ApiKeys.CREATE_DELEGATION_TOKEN, apiVersion, "", 10); assertEquals(2, header.headerVersion());  ByteBuffer buffer = RequestTestUtils.serializeRequestHeader(header); assertEquals(11, buffer.remaining()); RequestHeader deserialized = RequestHeader.parse(buffer); "<AssertPlaceHolder>"; }
parse(ByteBuffer buffer) { short apiKey = -1; try { // We derive the header version from the request api version, so we read that first. // The request api version is part of `RequestHeaderData`, so we reset the buffer position after the read. int bufferStartPositionForHeader = buffer.position(); apiKey = buffer.getShort(); short apiVersion = buffer.getShort(); short headerVersion = ApiKeys.forId(apiKey).requestHeaderVersion(apiVersion); buffer.position(bufferStartPositionForHeader); final RequestHeaderData headerData = new RequestHeaderData(new ByteBufferAccessor(buffer), headerVersion); // Due to a quirk in the protocol, client ID is marked as nullable. // However, we treat a null client ID as equivalent to an empty client ID. if (headerData.clientId() == null) { headerData.setClientId(""); } final RequestHeader header = new RequestHeader(headerData, headerVersion); // Size of header is calculated by the shift in the position of buffer's start position during parsing. // Prior to parsing, the buffer's start position points to header data and after the parsing operation // the buffer's start position points to api message. For more information on how the buffer is // constructed, see RequestUtils#serialize() header.size = Math.max(buffer.position() - bufferStartPositionForHeader, 0); return header; } catch (UnsupportedVersionException e) { throw new InvalidRequestException("Unknown API key " + apiKey, e); } catch (Throwable ex) { throw new InvalidRequestException("Error parsing request header. Our best guess of the apiKey is: " + apiKey, ex); } }
[*] target: assertEquals(header, deserialized)
[-] pred: org. junit. Assert. assertEquals ( header, deserialized )
************************************
************************************
[+] input: testCollectFilter() { metrics.addMetric(metricName, (config, now) -> 100.0);  testEmitter.reconfigurePredicate(k -> !k.key().name().endsWith(".count")); collector.collect(testEmitter); List<SinglePointMetric> result = testEmitter.emittedMetrics();  // Should get exactly 1 Kafka measurables because we excluded the count measurable "<AssertPlaceHolder>";  Metric counter = result.get(0).builder().build();  assertTrue(counter.hasGauge()); assertEquals(100L, counter.getGauge().getDataPoints(0).getAsDouble(), 0.0); }
collect(MetricsEmitter metricsEmitter) { for (Map.Entry<MetricKey, KafkaMetric> entry : ledger.getMetrics()) { MetricKey metricKey = entry.getKey(); KafkaMetric metric = entry.getValue();  try { collectMetric(metricsEmitter, metricKey, metric); } catch (Exception e) { // catch and log to continue processing remaining metrics log.error("Error processing Kafka metric {}", metricKey, e); } } }
[*] target: assertEquals(1, result.size())
[-] pred: org. junit. Assert. assertEquals ( 1, result. size ( ) )
************************************
************************************
[+] input: testSnapshot() { SnapshottableSamples sequence = new SnapshottableSamples(512); for (int i = 0; i < 1000; i++) { sequence.append(i); } for (int i = 0; i < 100; i++) { sequence.snapshot(); } Snapshot snapshot = sequence.snapshot(); Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(snapshot.getPrev()); Assertions.assertNull(snapshot.getPrev().getPrev()); }
snapshot() { if (this.prev != null) { this.prev.setPrev(null); } Snapshot snapshot = new Snapshot(prev, values); this.prev = snapshot; return snapshot; }
[*] target: assertNotNull(snapshot)
[-] pred: org. junit. Assert. assertNotNull ( snapshot )
************************************
************************************
[+] input: testValueCanBeNull() { ApiMessageAndVersion key = new ApiMessageAndVersion(new ConsumerGroupMetadataKey(), (short) 0); CoordinatorRecord record = new CoordinatorRecord(key, null); assertEquals(key, record.key()); "<AssertPlaceHolder>"; }
value() { return this.value; }
[*] target: assertNull(record.value())
[-] pred: org. junit. Assert. assertNull ( record. value() )
************************************
************************************
[+] input: testConsumerGroupDescribeBeforeAndAfterCommittingOffset() { String consumerGroupId = "consumerGroupId"; int epoch = 10; String memberId1 = "memberId1"; String memberId2 = "memberId2"; String topicName = "topicName"; Uuid topicId = Uuid.randomUuid(); MetadataImage metadataImage = new MetadataImageBuilder() .addTopic(topicId, topicName, 3) .build();  MockPartitionAssignor assignor = new MockPartitionAssignor("range"); GroupMetadataManagerTestContext context = new GroupMetadataManagerTestContext.Builder() .withConsumerGroupAssignors(Collections.singletonList(assignor)) .withMetadataImage(metadataImage) .build();  ConsumerGroupMember.Builder memberBuilder1 = new ConsumerGroupMember.Builder(memberId1) .setSubscribedTopicNames(Collections.singletonList(topicName)); context.replay(CoordinatorRecordHelpers.newMemberSubscriptionRecord(consumerGroupId, memberBuilder1.build())); context.replay(CoordinatorRecordHelpers.newGroupEpochRecord(consumerGroupId, epoch + 1));  Map<Uuid, Set<Integer>> assignmentMap = new HashMap<>(); assignmentMap.put(topicId, Collections.emptySet());  ConsumerGroupMember.Builder memberBuilder2 = new ConsumerGroupMember.Builder(memberId2); context.replay(CoordinatorRecordHelpers.newMemberSubscriptionRecord(consumerGroupId, memberBuilder2.build())); context.replay(CoordinatorRecordHelpers.newTargetAssignmentRecord(consumerGroupId, memberId2, assignmentMap)); context.replay(CoordinatorRecordHelpers.newCurrentAssignmentRecord(consumerGroupId, memberBuilder2.build())); context.replay(CoordinatorRecordHelpers.newGroupEpochRecord(consumerGroupId, epoch + 2));  List<ConsumerGroupDescribeResponseData.DescribedGroup> actual = context.groupMetadataManager.consumerGroupDescribe(Collections.singletonList(consumerGroupId), context.lastCommittedOffset); ConsumerGroupDescribeResponseData.DescribedGroup describedGroup = new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupId(consumerGroupId) .setErrorCode(Errors.GROUP_ID_NOT_FOUND.code()); List<ConsumerGroupDescribeResponseData.DescribedGroup> expected = Collections.singletonList( describedGroup ); assertEquals(expected, actual);  // Commit the offset and test again context.commit();  actual = context.groupMetadataManager.consumerGroupDescribe(Collections.singletonList(consumerGroupId), context.lastCommittedOffset); describedGroup = new ConsumerGroupDescribeResponseData.DescribedGroup() .setGroupId(consumerGroupId) .setMembers(Arrays.asList( memberBuilder1.build().asConsumerGroupDescribeMember(new Assignment(Collections.emptyMap()), metadataImage.topics()), memberBuilder2.build().asConsumerGroupDescribeMember(new Assignment(assignmentMap), metadataImage.topics()) )) .setGroupState(ConsumerGroup.ConsumerGroupState.ASSIGNING.toString()) .setAssignorName("range") .setGroupEpoch(epoch + 2); expected = Collections.singletonList( describedGroup ); "<AssertPlaceHolder>"; }
build() { if (logContext == null) logContext = new LogContext(); if (snapshotRegistry == null) snapshotRegistry = new SnapshotRegistry(logContext); if (metadataImage == null) metadataImage = MetadataImage.EMPTY; if (time == null) time = Time.SYSTEM;  if (timer == null) throw new IllegalArgumentException("Timer must be set."); if (consumerGroupAssignors == null || consumerGroupAssignors.isEmpty()) throw new IllegalArgumentException("Assignors must be set before building."); if (metrics == null) throw new IllegalArgumentException("GroupCoordinatorMetricsShard must be set.");  return new GroupMetadataManager( snapshotRegistry, logContext, time, timer, metrics, consumerGroupAssignors, metadataImage, consumerGroupMaxSize, consumerGroupSessionTimeoutMs, consumerGroupHeartbeatIntervalMs, consumerGroupMetadataRefreshIntervalMs, classicGroupMaxSize, classicGroupInitialRebalanceDelayMs, classicGroupNewMemberJoinTimeoutMs, classicGroupMinSessionTimeoutMs, classicGroupMaxSessionTimeoutMs, consumerGroupMigrationPolicy ); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testNode1Child() { MetadataNode child = NODE.child("2"); "<AssertPlaceHolder>"; assertEquals("ControllerRegistration(id=2, " + "incarnationId=adGo6sTPS0uJshjvdTUmqQ, " + "zkMigrationReady=false, " + "listeners=[], " + "supportedFeatures={metadata.version: 1-4})", child.stringify()); }
child(String name) { try { Integer brokerId = Integer.valueOf(name); ControllerRegistration registration = image.controllers().get(brokerId); if (registration == null) return null; return new MetadataLeafNode(registration.toString()); } catch (NumberFormatException e) { return null; } }
[*] target: assertNotNull(child)
[-] pred: org. junit. Assert. assertNotNull ( child )
************************************
************************************
[+] input: Exception { List<String> producerProps = Collections.singletonList("client.id=producer-1");  Properties prop = ProducerPerformance.readProps(producerProps, null, "1234", true);  "<AssertPlaceHolder>"; assertEquals("producer-1", prop.getProperty("client.id")); }
readProps(List<String> producerProps, String producerConfig, String transactionalId, boolean transactionsEnabled) throws IOException { Properties props = new Properties(); if (producerConfig != null) { props.putAll(Utils.loadProps(producerConfig)); } if (producerProps != null) for (String prop : producerProps) { String[] pieces = prop.split("="); if (pieces.length != 2) throw new IllegalArgumentException("Invalid property: " + prop); props.put(pieces[0], pieces[1]); }  props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); if (transactionsEnabled) props.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, transactionalId); if (props.getProperty(ProducerConfig.CLIENT_ID_CONFIG) == null) { props.put(ProducerConfig.CLIENT_ID_CONFIG, "perf-producer-client"); } return props; }
[*] target: assertNotNull(prop)
[-] pred: org. junit. Assert. assertNotNull ( prop )
************************************
************************************
[+] input: Exception { List<String> producerProps = Collections.singletonList("acks=1");  Properties prop = ProducerPerformance.readProps(producerProps, null, "1234", true);  "<AssertPlaceHolder>"; assertEquals("perf-producer-client", prop.getProperty("client.id")); }
readProps(List<String> producerProps, String producerConfig, String transactionalId, boolean transactionsEnabled) throws IOException { Properties props = new Properties(); if (producerConfig != null) { props.putAll(Utils.loadProps(producerConfig)); } if (producerProps != null) for (String prop : producerProps) { String[] pieces = prop.split("="); if (pieces.length != 2) throw new IllegalArgumentException("Invalid property: " + prop); props.put(pieces[0], pieces[1]); }  props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.ByteArraySerializer"); if (transactionsEnabled) props.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, transactionalId); if (props.getProperty(ProducerConfig.CLIENT_ID_CONFIG) == null) { props.put(ProducerConfig.CLIENT_ID_CONFIG, "perf-producer-client"); } return props; }
[*] target: assertNotNull(prop)
[-] pred: org. junit. Assert. assertNotNull ( prop )
************************************
************************************
[+] input: givenValidUserClaims_whenTokensGenerated_thenReturnAysToken() { // Given AysUser mockUser = new AysUserBuilder() .withValidValues() .build(); Claims mockUserClaims = mockUser.getClaims();  // When Mockito.when(tokenConfiguration.getIssuer()).thenReturn(MOCK_ISSUER); Mockito.when(tokenConfiguration.getAccessTokenExpireMinute()).thenReturn(MOCK_ACCESS_TOKEN_EXPIRE_MINUTE); Mockito.when(tokenConfiguration.getRefreshTokenExpireDay()).thenReturn(MOCK_REFRESH_TOKEN_EXPIRE_DAY); Mockito.when(tokenConfiguration.getPrivateKey()).thenReturn(MOCK_PRIVATE_KEY);  // Then AysToken aysToken = tokenService.generate(mockUserClaims);  Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(aysToken.getAccessToken()); Assertions.assertNotNull(aysToken.getAccessTokenExpiresAt()); Assertions.assertNotNull(aysToken.getRefreshToken());  // Verify Mockito.verify(tokenConfiguration, Mockito.times(1)).getIssuer(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getAccessTokenExpireMinute(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getRefreshTokenExpireDay(); Mockito.verify(tokenConfiguration, Mockito.times(1)).getPrivateKey(); Mockito.verify(tokenConfiguration, Mockito.times(0)).getPublicKey(); Mockito.verifyNoMoreInteractions(tokenConfiguration); }
generate(final Claims claims) {  final long currentTimeMillis = System.currentTimeMillis();  final JwtBuilder tokenBuilder = this.initializeTokenBuilder(currentTimeMillis);  final Date accessTokenExpiresAt = DateUtils.addMinutes( new Date(currentTimeMillis), tokenConfiguration.getAccessTokenExpireMinute() ); final String accessToken = tokenBuilder .id(AysRandomUtil.generateUUID()) .expiration(accessTokenExpiresAt) .claims(claims) .compact();  final Date refreshTokenExpiresAt = DateUtils.addDays( new Date(currentTimeMillis), tokenConfiguration.getRefreshTokenExpireDay() ); final String refreshToken = tokenBuilder .id(AysRandomUtil.generateUUID()) .expiration(refreshTokenExpiresAt) .claim(AysTokenClaims.USER_ID.getValue(), claims.get(AysTokenClaims.USER_ID.getValue())) .compact();  return AysToken.builder() .accessToken(accessToken) .accessTokenExpiresAt(accessTokenExpiresAt.toInstant().getEpochSecond()) .refreshToken(refreshToken) .build(); }
[*] target: assertNotNull(aysToken)
[-] pred: org. junit. Assert. assertNotNull ( aysToken )
************************************
************************************
[+] input: testGetCompileTransitiveDependenciesJettyFullGroupExclusion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14)) .exclude("org.eclipse.jetty", "*")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(3, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14 org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.slf4j:slf4j-api:2.0.5""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: testGetCompileTransitiveDependenciesJettyFullArtifactExclusion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14)) .exclude("*", "jetty-http") .exclude("*", "slf4j-api")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(4, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14 org.eclipse.jetty.toolchain:jetty-jakarta-servlet-api:5.0.2 org.eclipse.jetty:jetty-io:11.0.14 org.eclipse.jetty:jetty-util:11.0.14""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: testGetCompileTransitiveDependenciesJettyFullExclusion() { var resolver = new DependencyResolver(VersionResolution.dummy(), ArtifactRetriever.instance(), List.of(MAVEN_CENTRAL, SONATYPE_SNAPSHOTS), new Dependency("org.eclipse.jetty", "jetty-server", new VersionNumber(11, 0, 14)) .exclude("*", "*")); var dependencies = resolver.getAllDependencies(compile); "<AssertPlaceHolder>"; assertEquals(1, dependencies.size()); assertEquals(""" org.eclipse.jetty:jetty-server:11.0.14""", StringUtils.join(dependencies, "\n")); }
getAllDependencies(Scope... scopes) { var result = new DependencySet(); var overridden = resolution_.overrideDependency(dependency_); result.add(overridden);  var dependency_queue = new ArrayList<PomDependency>();  var parent = overridden; var next_dependencies = getMavenPom(parent).getDependencies(scopes);  while (parent != null && next_dependencies != null) { // remove any next dependencies that are already queued dependency_queue.forEach(next_dependencies::remove); // remove any next dependencies that match the current exclusion context final var exclusion_context = parent; next_dependencies.removeIf(it -> matchesExclusions(exclusion_context, it)); // add all next dependencies to the queue dependency_queue.addAll(next_dependencies);  // unless we find a next set of dependencies to add, stop resolving parent = null; next_dependencies = null;  // iterate through the dependency queue until we find one that isn't // part of the results yet while (!dependency_queue.isEmpty()) { var candidate = dependency_queue.remove(0); var dependency = resolution_.overrideDependency(candidate.convertToDependency()); if (!result.contains(dependency)) { result.add(dependency);  // we found a dependency that was added to the result, get its // dependencies so that they can be added to the queue after // filtering parent = dependency; next_dependencies = new DependencyResolver(resolution_, retriever_, repositories_, dependency).getMavenPom(parent).getDependencies(scopes); break; } } } return result; }
[*] target: assertNotNull(dependencies)
[-] pred: org. junit. Assert. assertNotNull ( dependencies )
************************************
************************************
[+] input: testInstantiation() { var builder = new MetadataBuilder(); assertNull(builder.info()); "<AssertPlaceHolder>"; }
updated() { return timestamp_; }
[*] target: assertNull(builder.updated())
[-] pred: org. junit. Assert. assertNull ( builder. updated() )
************************************
************************************
[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }));  final ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred: org. junit. Assert. assertNotNull ( frame )
************************************
************************************
[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }));  ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); frame = port.getNextFrame(); assertNotNull(frame); assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred: org. junit. Assert. assertNotNull ( frame )
************************************
************************************
[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }));  ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); frame = port.getNextFrame(); assertNotNull(frame); assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred: org. junit. Assert. assertNotNull ( frame )
************************************
************************************
[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLOODVV")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }));  ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A }, frame.array()); frame = port.getNextFrame(); assertNotNull(frame); assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x0C, 0x0D, 0x02, 0x00, 0x00, (byte) 0xAA, (byte) 0xFF, 0x00, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred: org. junit. Assert. assertNotNull ( frame )
************************************
************************************
[+] input: IOException { final JSerialCommPort port = new JSerialCommPort("", 9600, 8, 1, SerialPort.NO_PARITY, new byte[] { (byte) 0xA5 }, FrameDefinition.create("SACLL(-2)D")); port.serialEvent(new SerialPortEvent(getPort(), SerialPort.LISTENING_EVENT_DATA_RECEIVED, new byte[] { 0x01, 0x02, 0x03, Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x00, 0x13, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x11, 0x00, 0x01, 0x02 }));  final ByteBuffer frame = port.getNextFrame(); "<AssertPlaceHolder>"; assertArrayEquals(new byte[] { Integer.valueOf(0xA5).byteValue(), 0x01, 0x02, 0x00, 0x13, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x11, 0x00 }, frame.array()); }
create(final String definition) throws IllegalArgumentException { final ArrayList<FrameDefinitionPart> parts = new ArrayList<>(); FrameDefinitionPart current = null; boolean bracketOpen = false; String adjustment = "";  for (int i = 0; i < definition.length(); i++) { // check for adjustments in brackets if (bracketOpen && definition.charAt(i) != ')') { adjustment += definition.charAt(i); } else if (definition.charAt(i) == '(') { bracketOpen = true; } else if (definition.charAt(i) == ')') { bracketOpen = false; current.setValueAdjustment(Integer.parseInt(adjustment)); adjustment = ""; } else {  // resolve the frame definition character to the type final FrameDefinitionPartType type = FrameDefinitionPartType.valueOf(definition.charAt(i));  // check if the frame definition character could be resolved if (type == null) { // if not throw an exception throw new IllegalArgumentException("Illegal frame definition character: " + definition.charAt(i)); }  // if it's the same type if (current != null && current.getType().equals(type)) { // increment the number of bytes for that part current.setByteCount(current.getByteCount() + 1); } else { // otherwise its the first or different type current = new FrameDefinitionPart(type, 1); parts.add(current); } } }  return new FrameDefinition(parts); }
[*] target: assertNotNull(frame)
[-] pred: org. junit. Assert. assertNotNull ( frame )
************************************
************************************
[+] input: givenLoginRequest_WhenCustomerRole_ReturnSuccess() {  // given LoginRequest request = LoginRequest.builder() .email("customer@bookdelivery.com") .password("customer_password") .build();  User mockUser = User.builder() .email(request.getEmail()) .fullName("Test User") .username("testuser") .password("hashedPassword") .role(Role.ROLE_CUSTOMER) .build();  Authentication mockAuthentication = new UsernamePasswordAuthenticationToken( request.getEmail(), request.getPassword());  // when when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class))) .thenReturn(mockAuthentication); when(jwtUtils.generateJwtToken(mockAuthentication)).thenReturn("mockedToken"); when(userRepository.findByEmail(request.getEmail())).thenReturn(Optional.of(mockUser)); when(refreshTokenService.createRefreshToken(any(User.class))) .thenReturn("actualRefreshToken");  // then JWTResponse jwtResponse = authService.login(request);  "<AssertPlaceHolder>"; assertEquals(request.getEmail(), jwtResponse.getEmail()); assertEquals("mockedToken", jwtResponse.getToken()); assertEquals("actualRefreshToken", jwtResponse.getRefreshToken());  }
login(LoginRequest request) {  UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword());  Authentication auth = authenticationManager.authenticate(authToken); SecurityContextHolder.getContext().setAuthentication(auth); String jwtToken = jwtUtils.generateJwtToken(auth);  User user = userRepository.findByEmail(request.getEmail()).orElseThrow(UserNotFoundException::new);  return JWTResponse.builder() .email(request.getEmail()) .token(jwtToken) .refreshToken(refreshTokenService.createRefreshToken(user)) .build(); }
[*] target: assertNotNull(jwtResponse)
[-] pred: org. junit. Assert. assertNotNull ( jwtResponse )
************************************
************************************
[+] input: givenLoginRequest_WhenWhenAdminRole_ReturnSuccess() {  // given LoginRequest request = LoginRequest.builder() .email("admin@bookdelivery.com") .password("admin_password") .build();  User mockUser = User.builder() .email(request.getEmail()) .fullName("Test User") .username("testuser") .password("hashedPassword") .role(Role.ROLE_CUSTOMER) .build();  Authentication mockAuthentication = new UsernamePasswordAuthenticationToken( request.getEmail(), request.getPassword());  // when when(authenticationManager.authenticate(any(UsernamePasswordAuthenticationToken.class))) .thenReturn(mockAuthentication); when(jwtUtils.generateJwtToken(mockAuthentication)).thenReturn("mockedToken"); when(userRepository.findByEmail(request.getEmail())).thenReturn(Optional.of(mockUser)); when(refreshTokenService.createRefreshToken(any(User.class))) .thenReturn("actualRefreshToken");  // then JWTResponse jwtResponse = authService.login(request);  "<AssertPlaceHolder>"; assertEquals(request.getEmail(), jwtResponse.getEmail()); assertEquals("mockedToken", jwtResponse.getToken()); assertEquals("actualRefreshToken", jwtResponse.getRefreshToken());  }
login(LoginRequest request) {  UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword());  Authentication auth = authenticationManager.authenticate(authToken); SecurityContextHolder.getContext().setAuthentication(auth); String jwtToken = jwtUtils.generateJwtToken(auth);  User user = userRepository.findByEmail(request.getEmail()).orElseThrow(UserNotFoundException::new);  return JWTResponse.builder() .email(request.getEmail()) .token(jwtToken) .refreshToken(refreshTokenService.createRefreshToken(user)) .build(); }
[*] target: assertNotNull(jwtResponse)
[-] pred: org. junit. Assert. assertNotNull ( jwtResponse )
************************************
************************************
[+] input: testWorkSpaceIDUsage() { AzureCliCredentialsProvider provider = getAzureCliCredentialsProvider(mockTokenSource()); DatabricksConfig config = new DatabricksConfig() .setHost(".azuredatabricks.net") .setCredentialsProvider(provider) .setAzureWorkspaceResourceId(WORKSPACE_RESOURCE_ID); ArgumentCaptor<List<String>> argument = ArgumentCaptor.forClass(List.class);  HeaderFactory header = provider.configure(config);  String token = header.headers().get("Authorization"); assertEquals(token, TOKEN_TYPE + " " + TOKEN); Mockito.verify(provider, times(2)).getToken(any(), argument.capture());  List<String> value = argument.getValue(); value = value.subList(value.size() - 2, value.size()); List<String> expected = Arrays.asList("--subscription", SUBSCRIPTION); "<AssertPlaceHolder>"; }
getToken(DatabricksConfig config, List<String> cmd) { CliTokenSource token = new CliTokenSource(cmd, "tokenType", "accessToken", "expiresOn", config.getEnv()); token.getToken(); // We need this to check if the CLI is installed and to validate the config. return token; }
[*] target: assertEquals(expected, value)
[-] pred: org. junit. Assert. assertEquals ( expected, value )
************************************
************************************
[+] input: buildUndoSQL() { String sql = executor.buildUndoSQL().toLowerCase(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("insert")); Assertions.assertTrue(sql.contains("id")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } Row row = beforeImageRows.get(0); List<Field> fields = new ArrayList<>(row.nonPrimaryKeys()); fields.addAll(getOrderedPkList(beforeImage,row,JdbcConstants.MYSQL));  // delete sql undo log before image all field come from table meta, need add escape. // see BaseTransactionalExecutor#buildTableRecords String insertColumns = fields.stream() .map(field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.MYSQL)) .collect(Collectors.joining(", ")); String insertValues = fields.stream().map(field -> "?") .collect(Collectors.joining(", "));  return String.format(INSERT_SQL_TEMPLATE, sqlUndoLog.getTableName(), insertColumns, insertValues); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: buildUndoSQL() { String sql = executor.buildUndoSQL().toLowerCase(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("delete")); Assertions.assertTrue(sql.contains("id")); }
buildUndoSQL() { TableRecords afterImage = sqlUndoLog.getAfterImage(); List<Row> afterImageRows = afterImage.getRows(); if (CollectionUtils.isEmpty(afterImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } return generateDeleteSql(afterImageRows,afterImage); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: buildUndoSQL() { String sql = executor.buildUndoSQL().toLowerCase(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("update")); Assertions.assertTrue(sql.contains("id")); Assertions.assertTrue(sql.contains("age")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); // TODO } Row row = beforeImageRows.get(0);  List<Field> nonPkFields = row.nonPrimaryKeys(); // update sql undo log before image all field come from table meta. need add escape. // see BaseTransactionalExecutor#buildTableRecords String updateColumns = nonPkFields.stream().map( field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.MYSQL) + " = ?").collect( Collectors.joining(", "));  List<String> pkNameList = getOrderedPkList(beforeImage, row, JdbcConstants.MYSQL).stream().map(e -> e.getName()) .collect(Collectors.toList()); String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList, JdbcConstants.MYSQL);  return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(), updateColumns, whereSql); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: buildUndoSQL() { OracleUndoDeleteExecutor executor = upperCase();  String sql = executor.buildUndoSQL(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("INSERT")); Assertions.assertTrue(sql.contains("ID")); Assertions.assertTrue(sql.contains("TABLE_NAME")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } Row row = beforeImageRows.get(0); List<Field> fields = new ArrayList<>(row.nonPrimaryKeys()); fields.addAll(getOrderedPkList(beforeImage,row,JdbcConstants.ORACLE));  // delete sql undo log before image all field come from table meta, need add escape. // see BaseTransactionalExecutor#buildTableRecords String insertColumns = fields.stream() .map(field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.ORACLE)) .collect(Collectors.joining(", ")); String insertValues = fields.stream().map(field -> "?") .collect(Collectors.joining(", "));  return String.format(INSERT_SQL_TEMPLATE, sqlUndoLog.getTableName(), insertColumns, insertValues); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: buildUndoSQL() { OracleUndoInsertExecutor executor = upperCase(); String sql = executor.buildUndoSQL(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("DELETE")); Assertions.assertTrue(sql.contains("ID")); Assertions.assertTrue(sql.contains("TABLE_NAME")); }
buildUndoSQL() { TableRecords afterImage = sqlUndoLog.getAfterImage(); List<Row> afterImageRows = afterImage.getRows(); if (CollectionUtils.isEmpty(afterImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); } return generateDeleteSql(afterImageRows,afterImage); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: buildUndoSQLByUpperCase() { OracleUndoUpdateExecutor executor = upperCaseSQL();  String sql = executor.buildUndoSQL(); Assertions."<AssertPlaceHolder>"; Assertions.assertTrue(sql.contains("UPDATE")); Assertions.assertTrue(sql.contains("ID")); Assertions.assertTrue(sql.contains("AGE")); Assertions.assertTrue(sql.contains("TABLE_NAME")); }
buildUndoSQL() { TableRecords beforeImage = sqlUndoLog.getBeforeImage(); List<Row> beforeImageRows = beforeImage.getRows(); if (CollectionUtils.isEmpty(beforeImageRows)) { throw new ShouldNeverHappenException("Invalid UNDO LOG"); // TODO } Row row = beforeImageRows.get(0);  List<Field> nonPkFields = row.nonPrimaryKeys(); // update sql undo log before image all field come from table meta. need add escape. // see BaseTransactionalExecutor#buildTableRecords String updateColumns = nonPkFields.stream().map( field -> ColumnUtils.addEscape(field.getName(), JdbcConstants.ORACLE) + " = ?").collect( Collectors.joining(", "));  List<String> pkNameList = getOrderedPkList(beforeImage, row, JdbcConstants.ORACLE).stream().map( e -> e.getName()).collect(Collectors.toList()); String whereSql = SqlGenerateUtils.buildWhereConditionByPKs(pkNameList, JdbcConstants.ORACLE);  return String.format(UPDATE_SQL_TEMPLATE, sqlUndoLog.getTableName(), updateColumns, whereSql); }
[*] target: assertNotNull(sql)
[-] pred: org. junit. Assert. assertNotNull ( sql )
************************************
************************************
[+] input: idleBeat() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 15;  // Act final ReturnT<String> retval = executorBiz.idleBeat(new IdleBeatParam(jobId));  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(500, retval.getCode()); Assertions.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(IdleBeatParam idleBeatParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: kill() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.kill(new KillParam(jobId));  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(200, retval.getCode()); Assertions.assertNull(retval.getMsg()); }
kill(KillParam killParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: shouldOpen() { var batchSize = 33; Loader loader = new TestLoader(600, batchSize, 33); MetaData metaData = loader.open();  int numberItems = metaData.getNumberItems(); int lastBatchSize = numberItems % batchSize; int numberBatches = metaData.getNumberBatches();  for (int i = 0; i < numberBatches; i++) { BatchData batchData = loader.readBatch(); "<AssertPlaceHolder>";  int itemsRead = metaData.getItemsRead();  int inputSize = metaData.getInputSize(); int expectedSize = metaData.getNumberOfClasses();  Matrix input = new Matrix(inputSize, itemsRead, batchData.getInputBatch()); Matrix expected = new Matrix(expectedSize, itemsRead, batchData.getExpectedBatch());  System.out.println(input.sum()); assertTrue(input.sum() != 0.0);  assertTrue(expected.sum() == itemsRead);  if (i == numberBatches - 1) { assertEquals(itemsRead, lastBatchSize); } else { assertEquals(itemsRead, batchSize); } } }
readBatch();  default void reset() {}
[*] target: assertNotNull(batchData)
[-] pred: org. junit. Assert. assertNotNull ( batchData )
************************************
************************************
[+] input: testCreateProduct() { when(brandRepository.findById(any())).thenReturn(Optional.of(brand1)); when(productRepository.save(any(Product.class))).thenReturn(product1);    // mock the repository call to return the product we have created  ProductRequest productRequest = new ProductRequest(product1.getName(), "Description", "Image", product1.getPrice(), "Category", brand1.getName(), "", 10); ResponseEntity<ProductResponse> response = productService.createProduct(productRequest, 1L);  "<AssertPlaceHolder>"; assertEquals(product1.getName(), response.getBody().name()); assertEquals(product1.getPrice(), response.getBody().price()); assertEquals(product1.getStock(), response.getBody().stock()); assertEquals(product1.getBrand().getName(), response.getBody().brandName()); }
createProduct(ProductRequest productRequest, Long storeId) { // create brand if not found Brand brand = brandRepository.findByName(productRequest.brandName()) .orElseGet(() -> { Brand newBrand = Brand.builder() .name(productRequest.brandName()) .image(productRequest.brandImage().getBytes()) .build();  brandRepository.save(newBrand);  return newBrand; });  Product product = Product.builder() .storeId(storeId) .name(productRequest.name()) .description(productRequest.description()) .image(productRequest.image().getBytes()) .price(productRequest.price()) .category(productRequest.category()) .brand(brandRepository.findById(brand.getId()) .orElseThrow(() -> new RuntimeException("Brand not found"))) .stock(productRequest.stock()) .created(Instant.now()) .build();  productRepository.save(product);  return new ResponseEntity<>(mapProductToResponse(product), HttpStatus.CREATED); }
[*] target: assertEquals(HttpStatus.CREATED, response.getStatusCode())
[-] pred: org. junit. Assert. assertEquals ( HttpStatus.CREATED, response. getStatusCode ( ) )
************************************
************************************
[+] input: buildEntityType() { EntityType<Entity> type = EntityType.Builder.createNothing(MobCategory.MISC) .alwaysUpdateVelocity(true) .build();  "<AssertPlaceHolder>"; assertTrue(type.trackDeltas()); }
build() { throw new AssertionError("Implemented in Mixin"); }
[*] target: assertNotNull(type)
[-] pred: org. junit. Assert. assertNotNull ( type )
************************************
************************************
[+] input: buildLivingEntityType() { EntityType<LivingEntity> type = FabricEntityType.Builder.createLiving((t, w) -> null, MobCategory.MISC, living -> living .defaultAttributes(FabricEntityTypeTest::createAttributes) ).build();  "<AssertPlaceHolder>"; assertNotNull(DefaultAttributes.getSupplier(type)); }
build() { throw new AssertionError("Implemented in Mixin"); }
[*] target: assertNotNull(type)
[-] pred: org. junit. Assert. assertNotNull ( type )
************************************
************************************
[+] input: parseJsonToChainSpec() { String pathToPolkadotTestJSON = "./src/test/resources/short_polkadot.json"; try { ChainSpec chainSpec = ChainSpec.newFromJSON(pathToPolkadotTestJSON); String actualName = chainSpec.getName(); String expectedName = "Polkadot"; "<AssertPlaceHolder>";  String actualId = chainSpec.getId(); String expectedId = "polkadot"; assertEquals(expectedId, actualId);  ChainType actualChainType = chainSpec.getChainType(); ChainType expectedChainType = ChainType.LIVE; assertEquals(expectedChainType, actualChainType);  String actualProtocolId = chainSpec.getProtocolId(); String expectedProtocolId = "dot"; assertEquals(expectedProtocolId, actualProtocolId);  String[] actualForkBlocks = chainSpec.getForkBlocks(); assertNull(actualForkBlocks);  String[] actualBadBlocks = chainSpec.getBadBlocks(); assertNull(actualBadBlocks);  String actualConsensusEngine = chainSpec.getConsensusEngine(); assertNull(actualConsensusEngine);  String[] actualBootNodes = chainSpec.getBootNodes(); String[] expectedBootNodes = new String[]{ "/dns/polkadot-connect-0.parity.io/tcp/443/wss/p2p/12D3KooWEPmjoRpDSUuiTjvyNDd8fejZ9eNWH5bE965nyBMDrB4o", "/dns/cc1-1.parity.tech/tcp/30333/p2p/12D3KooWFN2mhgpkJsDBuNuE5427AcDrsib8EoqGMZmkxWwx3Md4"}; assertArrayEquals(expectedBootNodes, actualBootNodes);  TelemetryEndpoint[] actualTelemetryEndpoints = chainSpec.getTelemetryEndpoints(); TelemetryEndpoint[] expectedTelemetryEndpoints = new TelemetryEndpoint[] { new TelemetryEndpoint("wss://telemetry.polkadot.io/submit/", 0) }; assertArrayEquals(expectedTelemetryEndpoints, actualTelemetryEndpoints);  Map<ByteString, ByteString> actualTopValue = chainSpec.getGenesis().getTop(); Map<String, String> expectedRawTopValue = new LinkedHashMap(); expectedRawTopValue.put("0x9c5d795d0297be56027a4b2464e3339763e6d3c1fb15805edfd024172ea4817d9e40ca7bd1fd588ca534ee6b96a65ca8a53ec232dda838cc3cd2bd1887904906", "0x11bc2c7ea454e083cea1186239abc83733200e78"); expectedRawTopValue.put("0x9c5d795d0297be56027a4b2464e333979c5d795d0297be56027a4b2464e33397eb0718ce75762eeba4570943d5b2de2afb9085b6", "0x000e760ff72301000000000000000000");  Function<String, ByteString> parser = hex -> ByteString.fromHex(StringUtils.remove0xPrefix(hex));  Map<ByteString, ByteString> expectedTopValue = expectedRawTopValue.entrySet().stream().collect(Collectors.toMap( e -> parser.apply(e.getKey()), e -> parser.apply(e.getValue()) ));  assertEquals(expectedTopValue, actualTopValue);  Map<String, PropertyValue> actualProperties = chainSpec.getProperties();  ObjectMapper mapper = new ObjectMapper(); Map<String, JsonNode> expectedProperties = new LinkedHashMap<>(); expectedProperties.put("ss58Format", mapper.valueToTree(0)); expectedProperties.put("tokenDecimals", mapper.valueToTree(10)); expectedProperties.put("tokenSymbol", mapper.valueToTree("DOT"));  assertEquals(expectedProperties, actualProperties); } catch (IOException e) { log.log(Level.SEVERE, "Error loading chain spec from json", e); fail(); } }
newFromJSON(String pathToChainSpecJSON) throws IOException { final boolean failOnUnknownProperties = false; ObjectMapper objectMapper = new ObjectMapper() .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, failOnUnknownProperties); var file = new File(pathToChainSpecJSON);  return objectMapper.readValue(file, ChainSpec.class); }
[*] target: assertEquals(expectedName, actualName)
[-] pred: org. junit. Assert. assertEquals ( expectedName, actualName )
************************************
************************************
[+] input: testBlockTreeAddBlock() { Pair<BlockTree, List<Hash256>> result = createFlatTree(1); BlockTree bt = result.getValue0(); List<Hash256> hashes = result.getValue1();  BlockHeader header = createHeader(hashes.get(1), 2); Hash256 hash = header.getHash(); bt.addBlock(header, Instant.ofEpochSecond(0));  BlockNode blockNode = bt.getNode(hash); BlockNode leafBlockNode = bt.getLeaves().load(blockNode.getHash());  "<AssertPlaceHolder>";  Hash256 oldHash = getHash("01"); leafBlockNode = bt.getLeaves().load(oldHash); assertNull(leafBlockNode); }
getNode(final Hash256 hash) { if (Objects.equals(root.getHash(), hash)) { return root; }  for (BlockNode leaf : leaves.nodes()) { if (Objects.equals(leaf.getHash(), hash)) { return leaf; } }  for (BlockNode child : root.getChildren()) { BlockNode n = child.getNode(hash); if (n != null) { return n; } }  return null; }
[*] target: assertNotNull(leafBlockNode)
[-] pred: org. junit. Assert. assertNotNull ( leafBlockNode )
************************************
************************************
[+] input: loadPrivateKey() { Ed25519PrivateKey ed25519PrivateKey = Ed25519Utils.loadPrivateKey(PRIVATE_KEY_BYTE); PeerId peerId = PeerId.fromPubKey(ed25519PrivateKey.publicKey());  "<AssertPlaceHolder>"; assertNotNull(ed25519PrivateKey.publicKey()); assertNotNull(peerId); assertEquals(PEER_ID, peerId.toBase58()); }
loadPrivateKey(final byte[] keyData) { final Ed25519PrivateKeyParameters parameters = new Ed25519PrivateKeyParameters(keyData);  return new Ed25519PrivateKey(parameters); }
[*] target: assertNotNull(ed25519PrivateKey)
[-] pred: org. junit. Assert. assertNotNull ( ed25519PrivateKey )
************************************
************************************
[+] input: testFindNearest() { KDTreeNearestNeighbor<String, Object> nearestNeighbor = this.kdTree.findNearest( new Builder() .latitude(25.2028848) .longitude(55.289930) .build(), 2);  Assertions."<AssertPlaceHolder>"; Assertions.assertEquals(1.1603729958857059, nearestNeighbor.getDistance()); Assertions.assertEquals("6", nearestNeighbor.getKdTreeObject().getId()); }
findNearest(Point point, double distance) { // Initialize the object to store the nearest neighbor and its distance. KDTreeNearestNeighbor<T, O> nearestNeighbor = new KDTreeNearestNeighbor<>(); // Call the recursive helper method with the root node, point, distance, and closestPoints list findNearest(this.root, point, distance, 0, nearestNeighbor); // Return the list of the closest points return nearestNeighbor; }
[*] target: assertNotNull(nearestNeighbor)
[-] pred: org. junit. Assert. assertNotNull ( nearestNeighbor )
************************************
************************************
[+] input: testFindNearest_whenExistingPointIsProvided_returnsZeroDistance() { KDTreeNearestNeighbor<String, Object> nearestNeighbor = this.kdTree.findNearest( new Builder() .latitude(25.2012544) .longitude(55.2569389) .build(), 2);  Assertions."<AssertPlaceHolder>"; Assertions.assertNotNull(nearestNeighbor.getDistance()); Assertions.assertEquals(0.0, nearestNeighbor.getDistance()); Assertions.assertNotNull(nearestNeighbor.getKdTreeObject()); Assertions.assertEquals("7", nearestNeighbor.getKdTreeObject().getId()); }
findNearest(Point point, double distance) { // Initialize the object to store the nearest neighbor and its distance. KDTreeNearestNeighbor<T, O> nearestNeighbor = new KDTreeNearestNeighbor<>(); // Call the recursive helper method with the root node, point, distance, and closestPoints list findNearest(this.root, point, distance, 0, nearestNeighbor); // Return the list of the closest points return nearestNeighbor; }
[*] target: assertNotNull(nearestNeighbor)
[-] pred: org. junit. Assert. assertNotNull ( nearestNeighbor )
************************************
************************************
[+] input: testDropPartition() { Partition testDrop = Partitions.identity( "p3", new String[][] {{"col1"}}, new Literal[] {Literals.stringLiteral("v2")}, Maps.newHashMap()); partitionOperationDispatcher.addPartition(TABLE_IDENT, testDrop); Assertions.assertTrue( partitionOperationDispatcher.partitionExists(TABLE_IDENT, testDrop.name()));  Assertions.assertTrue( partitionOperationDispatcher.partitionExists(TABLE_IDENT, testDrop.name()));  boolean dropped = partitionOperationDispatcher.dropPartition(TABLE_IDENT, testDrop.name()); Assertions."<AssertPlaceHolder>"; Assertions.assertFalse( partitionOperationDispatcher.partitionExists(TABLE_IDENT, testDrop.name())); }
dropPartition(NameIdentifier tableIdent, String partitionName) { return doWithTable( tableIdent, p -> p.dropPartition(partitionName), NoSuchPartitionException.class); }
[*] target: assertTrue(dropped)
[-] pred: org. junit. Assert. assertTrue ( dropped )
************************************
************************************
[+] input: IOException { BaseMetalake metalake = createBaseMakeLake(RandomIdGenerator.INSTANCE.nextId(), metalakeName, auditInfo); backend.insert(metalake, false);  TagMetaService tagMetaService = TagMetaService.getInstance(); TagEntity tagEntity1 = TagEntity.builder() .withId(RandomIdGenerator.INSTANCE.nextId()) .withName("tag1") .withNamespace(TagManager.ofTagNamespace(metalakeName)) .withComment("comment") .withProperties(props) .withAuditInfo(auditInfo) .build(); tagMetaService.insertTag(tagEntity1, false);  boolean deleted = tagMetaService.deleteTag(TagManager.ofTagIdent(metalakeName, "tag1")); Assertions."<AssertPlaceHolder>";  deleted = tagMetaService.deleteTag(TagManager.ofTagIdent(metalakeName, "tag1")); Assertions.assertFalse(deleted);  Exception excep = Assertions.assertThrows( NoSuchEntityException.class, () -> tagMetaService.getTagByIdentifier(TagManager.ofTagIdent(metalakeName, "tag1"))); Assertions.assertEquals("No such tag entity: tag1", excep.getMessage()); }
insertTag(TagEntity tagEntity, boolean overwritten) throws IOException { Namespace ns = tagEntity.namespace(); String metalakeName = ns.level(0);  try { Long metalakeId = MetalakeMetaService.getInstance().getMetalakeIdByName(metalakeName);  TagPO.Builder builder = TagPO.builder().withMetalakeId(metalakeId); TagPO tagPO = POConverters.initializeTagPOWithVersion(tagEntity, builder);  SessionUtils.doWithCommit( TagMetaMapper.class, mapper -> { if (overwritten) { mapper.insertTagMetaOnDuplicateKeyUpdate(tagPO); } else { mapper.insertTagMeta(tagPO); } }); } catch (RuntimeException e) { ExceptionUtils.checkSQLException(e, Entity.EntityType.TAG, tagEntity.toString()); throw e; } }
[*] target: assertTrue(deleted)
[-] pred: org. junit. Assert. assertTrue ( deleted )
************************************
************************************
[+] input: testIntToByte() { int v = 258; byte[] b = ByteUtils.intToByte(v); Assertions.assertArrayEquals(new byte[] {0x00, 0x00, 0x01, 0x02}, b); int v2 = ByteUtils.byteToInt(b); Assertions."<AssertPlaceHolder>"; }
byteToInt(byte[] bytes) { ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES); buffer.order(ByteOrder.BIG_ENDIAN); buffer.put(bytes); buffer.flip(); return buffer.getInt(); }
[*] target: assertEquals(v, v2)
[-] pred: org. junit. Assert. assertEquals ( v, v2 )
************************************
************************************
[+] input: testLongToByte() { long v = 259; byte[] b = ByteUtils.longToByte(v); Assertions.assertArrayEquals(new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03}, b); long v2 = ByteUtils.byteToLong(b); Assertions."<AssertPlaceHolder>"; }
byteToLong(byte[] bytes) { ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES); buffer.order(ByteOrder.BIG_ENDIAN); buffer.put(bytes); buffer.flip(); return buffer.getLong(); }
[*] target: assertEquals(v, v2)
[-] pred: org. junit. Assert. assertEquals ( v, v2 )
************************************
************************************
[+] input: increaseProtocolAdapterMetric_whenAlreadyExists_thenIncrementAndRegister() { protocolAdapterMetrics.increaseProtocolAdapterMetric("test");  final Counter counter = metricRegistry.getCounters().get(PROTOCOL_ADAPTER_PREFIX + "test.current"); "<AssertPlaceHolder>"; assertEquals(1L, counter.getCount()); }
increaseProtocolAdapterMetric(final @NotNull String protocolType) { metricRegistry.counter(PROTOCOL_ADAPTER_PREFIX + protocolType + ".current").inc(); currentAdapters.incrementAndGet(); }
[*] target: assertNotNull(counter)
[-] pred: org. junit. Assert. assertNotNull ( counter )
************************************
************************************
[+] input: testIdTrackingWithFieldRemoval() { // create initial schema with 2 fields and assign IDs Schema initial = Schema.createRecord( "test1", null, "hudi", false, Arrays.asList( new Schema.Field("field1", Schema.create(Schema.Type.STRING)), new Schema.Field("field2", Schema.create(Schema.Type.STRING)))); Schema initialWithIdTracking = idTracker.addIdTracking(initial, Option.empty(), false); // remove the second field Schema withFieldRemoved = Schema.createRecord( "test2", null, "hudi", false, Collections.singletonList( new Schema.Field("field1", Schema.create(Schema.Type.STRING)))); Schema withFieldRemovedAndIdTracking = idTracker.addIdTracking(withFieldRemoved, Option.of(initialWithIdTracking), false); IdTracking actualWithFieldRemoved = idTracker.getIdTracking(withFieldRemovedAndIdTracking).get(); IdTracking expectedWithFieldRemoved = new IdTracking(Collections.singletonList(new IdMapping("field1", 1)), 2); assertEquals(expectedWithFieldRemoved, actualWithFieldRemoved); // Adding a new field should be tracked with ID 3 Schema withFieldAdded = Schema.createRecord( "test2", null, "hudi", false, Arrays.asList( new Schema.Field("field1", Schema.create(Schema.Type.STRING)), new Schema.Field("field3", Schema.create(Schema.Type.STRING)))); Schema withFieldAddedAndIdTracking = idTracker.addIdTracking(withFieldAdded, Option.of(withFieldRemovedAndIdTracking), false); IdTracking actualWithFieldAdded = idTracker.getIdTracking(withFieldAddedAndIdTracking).get(); IdTracking expectedWithFieldAdded = new IdTracking(Arrays.asList(new IdMapping("field1", 1), new IdMapping("field3", 3)), 3); "<AssertPlaceHolder>"; }
getIdTracking(Schema schema) { try { Object propValue = schema.getObjectProp(ID_TRACKING); if (propValue == null) { return Option.empty(); } return Option.of( ID_TRACKING_READER.readValue((JsonNode) OBJECT_MAPPER.valueToTree(propValue))); } catch (IOException ex) { throw new UncheckedIOException(ex); } }
[*] target: assertEquals(expectedWithFieldAdded, actualWithFieldAdded)
[-] pred: org. junit. Assert. assertEquals ( expectedWithFieldAdded, actualWithFieldAdded )
************************************
************************************
[+] input: login() { LoginRequest request = new LoginRequest(); request.setUsername("admin"); request.setPassword("123456"); request.setIsQuick(true); LoginTokenDto tokenDto = userService.login(request); "<AssertPlaceHolder>"; assertNotNull(tokenDto.getAccessToken()); }
login(LoginRequest request) { User user = lambdaQuery().eq(User::getUsername, request.getUsername()).one(); if (user == null) { throw new BizException(BizResponseCode.ERR_10002); } // 预览环境下可快速登录，不用验证码 if (Boolean.TRUE.equals(request.getIsQuick()) && Boolean.TRUE.equals(previewProperties.getPreview())) { return login(request, user); } if (StrUtil.isBlank(request.getCaptchaKey()) || !captchaService.verify(request.getCaptchaKey(), request.getCaptcha())) { throw new BizException(BizResponseCode.ERR_10003); } return login(request, user); }
[*] target: assertNotNull(tokenDto)
[-] pred: org. junit. Assert. assertNotNull ( tokenDto )
************************************
************************************
[+] input: givenServerHttpRequestAndServerHttpResponseAndWebSocketHandlerAndMapAttributes_whenBeforeHandshake_thenTokenNull() { // Given when(request.getURI()).thenReturn(URI.create("/websocket/"));  // When Map<String, Object> attributes = new HashMap<>(); boolean result = webSocketInterceptor.beforeHandshake(request, response, wsHandler, attributes);  // Then "<AssertPlaceHolder>"; assertTrue(attributes.isEmpty()); verify(jwtTokenProvider, never()).validateToken(anyString()); }
beforeHandshake(@NonNull ServerHttpRequest request, @NonNull ServerHttpResponse response, @NonNull WebSocketHandler wsHandler, @NonNull Map<String, Object> attributes) { log.debug("Received an incoming websocket channel request"); String token = getTokenFromPath(request.getURI().getPath()); if (token == null || !jwtTokenProvider.validateToken(token, false)) { log.error("Invalid token or token not present in WebSocket request"); return false; } return true; }
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: testCreateUser() { UserManagementService.UserDTO userDTO = new UserManagementService.UserDTO(); userDTO.setFirstName("John"); userDTO.setLastName("Doe"); userDTO.setEmail("john.doe@example.com");  UserManagementService.User user = UserManagementService.createUser(userDTO); "<AssertPlaceHolder>"; assertEquals("John", user.getFirstName()); }
createUser(UserDTO userDTO){ Function<UserDTO, UserDTO> pipeline = UserManagementService:: validateUser; return pipeline .andThen(UserManagementService:: createUserFromDto) .andThen(user -> Repository.save(user)) .apply(userDTO); }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: decodeJsonString() { final String encodedString = niceJson("hello `b `n `b `u1234 "); final String result = CharArrayUtils.decodeJsonString(encodedString.toCharArray(), 0, encodedString.length());  final int expectedCount = encodedString.length() - 3 - 5; "<AssertPlaceHolder>"; assertEquals("hello \b \n \b \u1234 ", result); }
decodeJsonString(char[] chars, int startIndex, int endIndex) { int length = endIndex - startIndex; char[] builder = new char[calculateLengthAfterEncoding(chars, startIndex, endIndex, length)]; char c; int index = startIndex; int idx = 0;  while (true) { c = chars[index]; if (c == '\' && index < (endIndex - 1)) { index++; c = chars[index]; if (c != 'u') { builder[idx] = controlMap[c]; idx++; } else {  if (index + 4 < endIndex) { char unicode = getUnicode(chars, index); builder[idx] = unicode; index += 4; idx++; } }  } else { builder[idx] = c; idx++; } if (index >= (endIndex - 1)) { break; } index++; } return new String(builder);  }
[*] target: assertEquals(expectedCount, result.length())
[-] pred: org. junit. Assert. assertEquals ( expectedCount, result. length ( ) )
************************************
************************************
[+] input: testEquals() { IndexPathNode indexPathNode = new IndexPathNode(token, charSource); IndexPathNode indexPathNode2 = new IndexPathNode(token, charSource); assertEquals(indexPathNode, indexPathNode2); "<AssertPlaceHolder>"; }
hashCode() { if (hashCodeSet) { return hashCode; } hashCode = CharSequenceUtils.hashCode(this); hashCodeSet = true; return hashCode; }
[*] target: assertEquals(indexPathNode.hashCode(), indexPathNode2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( indexPathNode. hashCode(), indexPathNode2. hashCode() )
************************************
************************************
[+] input: shouldGetHostsForStore() { when(streamsMetadata.stateStoreNames()) .thenReturn(Set.of("store"));  when(streamsMetadata.hostInfo()) .thenReturn(new HostInfo("host1", 1234));  when(streamsMetadata.topicPartitions()) .thenReturn(Set.of(new TopicPartition("topic", 0)));  when(interactiveQueriesService.getStreamsMetadataForStore("store")) .thenReturn(List.of(streamsMetadata));  List<com.michelin.kstreamplify.store.StreamsMetadata> response = interactiveQueriesController.getStreamsMetadataForStore("store").getBody();  "<AssertPlaceHolder>"; assertEquals(streamsMetadata.stateStoreNames(), response.get(0).getStateStoreNames()); assertEquals(streamsMetadata.hostInfo().host(), response.get(0).getHostInfo().host()); assertEquals(streamsMetadata.hostInfo().port(), response.get(0).getHostInfo().port()); assertTrue(response.get(0).getTopicPartitions().contains("topic-0")); }
getStreamsMetadataForStore(@PathVariable("store") final String store) { return ResponseEntity .ok() .contentType(MediaType.APPLICATION_JSON) .body(interactiveQueriesService.getStreamsMetadataForStore(store) .stream() .map(streamsMetadata -> new StreamsMetadata( streamsMetadata.stateStoreNames(), streamsMetadata.hostInfo(), streamsMetadata.topicPartitions())) .toList() ); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: shouldGetByKey() { when(interactiveQueriesService.getByKey("store", "key")) .thenReturn(new StateStoreRecord("key1", "value1", 1L));  StateStoreRecord response = interactiveQueriesController .getByKey("store", "key").getBody();  "<AssertPlaceHolder>"; assertEquals("key1", response.getKey()); assertEquals("value1", response.getValue()); assertEquals(1L, response.getTimestamp()); }
getByKey(@PathVariable("store") String store, @PathVariable("key") String key) { return ResponseEntity .ok() .contentType(MediaType.APPLICATION_JSON) .body(interactiveQueriesService.getByKey(store, key)); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testFindVariablesWithSingleVariable() { String input = "Hello, {name}!"; List<String> variables = findVariables(input);  "<AssertPlaceHolder>"; assertEquals("name", variables.get(0)); }
findVariables(String input) { List<String> variables = new ArrayList<>(); Matcher matcher = PATTERN.matcher(input); while (matcher.find()) { variables.add(matcher.group(1)); } return variables; }
[*] target: assertEquals(1, variables.size())
[-] pred: org. junit. Assert. assertEquals ( 1, variables. size ( ) )
************************************
************************************
[+] input: testDescribeIndex() { IndexDescription indexDescription = client.describeIndex(INDEX_NAME); "<AssertPlaceHolder>"; assertNotNull(indexDescription.getDatabase()); assertNotNull(indexDescription.getStatus());  // Assert database information Database database = indexDescription.getDatabase(); assertAll( () -> assertEquals(INDEX_NAME, database.getName()), () -> assertEquals(COSINE, database.getMetric()), () -> assertEquals(3, database.getDimension()), () -> assertEquals(1, database.getReplicas()), () -> assertEquals(1, database.getShards()), () -> assertEquals(1, database.getPods()), () -> assertEquals("p1.x1", database.getPodType()));  // Assert status information Status status = indexDescription.getStatus(); assertAll( () -> assertNotNull(status), () -> assertTrue(status.getWaiting().isEmpty()), () -> assertTrue(status.getCrashed().isEmpty()), () -> { String host = String.format("%s-%s.svc.%s.pinecone.io", INDEX_NAME, "b43e233", System.getenv("PINECONE_ENV")); assertEquals(host, status.getHost()); }, () -> assertEquals(433, status.getPort()), () -> assertEquals("Ready", status.getState()), () -> assertTrue(status.isReady())); }
describeIndex(String name) { return indexService.describeIndex(name).blockingGet(); }
[*] target: assertNotNull(indexDescription)
[-] pred: org. junit. Assert. assertNotNull ( indexDescription )
************************************
************************************
[+] input: remove() { assertEquals(3, m.size()); m.remove(66); assertEquals(3, m.size()); m.remove(3); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(2, m.size())
[-] pred: org. junit. Assert. assertEquals ( 2, m. size() )
************************************
************************************
[+] input: idleBeat() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.idleBeat(new IdleBeatParam(jobId));  // Assert result Assertions."<AssertPlaceHolder>"; Assertions.assertNull(((ReturnT<String>) retval).getContent()); Assertions.assertEquals(500, retval.getCode()); Assertions.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(IdleBeatParam idleBeatParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: iteratorInOrder() { var map = new MutableHashedLinkedMap<String, Integer>(); map.put("first", 1); map.put("second", 2); map.put("third", 3);  var itr = map.iterator();  assertEquals("first", itr.next().getKey()); assertEquals("second", itr.next().getKey()); assertEquals("third", itr.next().getKey()); "<AssertPlaceHolder>"; }
hasNext() { return current != null; }
[*] target: assertFalse(itr.hasNext())
[-] pred: org. junit. Assert. assertFalse ( itr. hasNext() )
************************************
************************************
[+] input: countTokens_fullRequest() { var content = new Content( List.of(new TextPart("What is the airspeed velocity of an unladen swallow?")), "user"); var request = new CountTokensRequest( List.of(content), new GenerateContentRequest("models/gemini-1.5-flash-001", List.of(content), List.of(), null, null, null, null, null)); GeminiCountResponse response = service.countTokens(GeminiService.GEMINI_PRO, request); "<AssertPlaceHolder>"; System.out.println(response); assertThat(response.totalTokens()).isEqualTo(13); }
countTokens(String model, CountTokensRequest request) { return geminiInterface.countTokens(model, request); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: complete() { Message message = new Message(Role.USER, "Who is the most renowed French football player?"); String model = MistralService.MISTRAL_SMALL_LATEST; ChatResponse response = service.complete(model, List.of(message)); "<AssertPlaceHolder>"; System.out.println(response); assertEquals("mistral-small-latest", response.model()); System.out.println(response.choices().getFirst().message().content()); }
complete(String model, List<Message> messages) { ChatRequest request = new ChatRequest(model, messages, 0.7);  return restClient.post() .uri("/v1/chat/completions") .header("Authorization", "Bearer " + apiKey) .header("Content-Type", "application/json") .header("Accept", "application/json") .body(request) .retrieve() .body(ChatResponse.class); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: Exception { JsonNode collection = Json.toJson(""" { "name": "example_collection", "vectors": { "size": 300, "distance": "Cosine" } } """);  JsonNode json = Json.toJson(collection.toString()); "<AssertPlaceHolder>";  assertEquals("example_collection", json.get("name").asText()); JsonNode vectorConfig = json.get("vectors"); assertEquals(300, vectorConfig.get("size").asInt()); assertEquals("Cosine", vectorConfig.get("distance").asText()); }
toJson(String content) throws JsonProcessingException { JsonNode json = mapper.readTree(content); if (json == null) { return null; } return json; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: Exception { var out = Objects.requireNonNull(System.out); int count = 20; CountDownLatch latch = new CountDownLatch(count); ListLogOutput output = new ListLogOutput(); output.setConsumer((event, body) -> { latch.countDown(); }); var gum = RainbowGum.builder().route(b -> { b.appender("console", a -> { a.output(LogOutput.ofStandardOut()); a.encoder(LogFormatter.builder().message().newline().encoder()); }); /* * This has to be the second one so that it happens after the console output. */ b.appender("list", a -> { a.output(output); a.encoder(LogFormatter.builder().message().newline().encoder()); }); b.publisher(PublisherFactory.ofAsync(100)); }).build(); try (var g = gum.start()) { for (int i = 0; i < count; i++) { TestEventBuilder.of().to(gum).event().message("" + i).log(); } latch.await(); out.println("done"); var responses = g.config().publisherRegistry().status(); String actual = """ [Response[type=interface io.jstach.rainbowgum.LogPublisher, name=default, status=QueueStatus[count=0, max=100, level=INFO]]] """ .trim(); String expected = responses.toString(); "<AssertPlaceHolder>"; } List<String> lines = output.events().stream().map(e -> e.getValue().trim()).toList(); int i = 0; for (var line : lines) { String actual = line; String expected = "" + i; assertEquals(expected, actual); i++; }  }
status() throws Exception { return new Status.QueueStatus(queue.size(), bufferSize); }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testGenerateIBAN() { // When String iban = AccountService.generateIBAN();  // Then "<AssertPlaceHolder>"; assertTrue(iban.matches("[A-Z]{2}\\d{2}-\\d{4}-\\d{4}-\\d{4}-\\d{4}")); }
generateIBAN() { String[] countryCodes = Locale.getISOCountries(); int index = random.nextInt(countryCodes.length); String countryCode = countryCodes[index]; String accountNumber = String.format("%02d-%04d-%04d-%04d-%04d", random.nextInt(100), random.nextInt(10000), random.nextInt(10000), random.nextInt(10000), random.nextInt(10000)); return countryCode + accountNumber; }
[*] target: assertNotNull(iban)
[-] pred: org. junit. Assert. assertNotNull ( iban )
************************************
************************************
[+] input: makeOneAuthCycle() { StartTransactionResponse response = this.rpApi.startAuthentication(CLIENT_IP);  Assertions.assertNotNull(response); Assertions.assertNotNull(response.getOrderRef()); Assertions.assertNotNull(response.getAutoStartToken()); Assertions.assertNotNull(response.getQrStartToken()); Assertions.assertNotNull(response.getQrStartSecret());  // Collect CollectResponse collectResponse = this.rpApi.collect(response.getOrderRef()); Assertions.assertNotNull(collectResponse);  Assertions.assertNotNull(collectResponse.getOrderRef()); Assertions.assertEquals(response.getOrderRef(), collectResponse.getOrderRef());  Assertions.assertNotNull(collectResponse.getStatus()); Assertions.assertEquals("pending", collectResponse.getStatus()); Assertions.assertNotNull(collectResponse.getHintCode()); Assertions.assertEquals("outstandingTransaction", collectResponse.getHintCode());  // Cancel boolean cancelResponse = this.rpApi.cancel(response.getOrderRef()); Assertions."<AssertPlaceHolder>"; }
cancel(String orderRef) { try { CancelRequest request = new CancelRequest(orderRef); ObjectMapper mapper = new ObjectMapper(); String jsonRequest = mapper.writeValueAsString(request);  long startTime = System.currentTimeMillis(); String result = this.post("cancel", jsonRequest); long elapsedTime = System.currentTimeMillis() - startTime; if (result == null) { this.logger.warn("Query to cancel transaction " + "failed after {} ms.", elapsedTime); return false; }  this.logger.info("Received json string from BankID RP after {} ms.", elapsedTime); return result.trim().equals("{}"); } catch (Exception e) { this.logger.warn("IOException while starting authentication: {}", e.getMessage()); return false; } }
[*] target: assertTrue(cancelResponse)
[-] pred: org. junit. Assert. assertTrue ( cancelResponse )
************************************
************************************
[+] input: makeOneSignCycle() { StartSignatureRequest request = new StartSignatureRequest(CLIENT_IP, new Base64String(this.visibleData)); StartTransactionResponse response = this.rpApi.startSignature(request);  Assertions.assertNotNull(response); Assertions.assertNotNull(response.getOrderRef()); Assertions.assertNotNull(response.getAutoStartToken()); Assertions.assertNotNull(response.getQrStartToken()); Assertions.assertNotNull(response.getQrStartSecret());  // Collect CollectResponse collectResponse = this.rpApi.collect(response.getOrderRef()); Assertions.assertNotNull(collectResponse);  Assertions.assertNotNull(collectResponse.getOrderRef()); Assertions.assertEquals(response.getOrderRef(), collectResponse.getOrderRef());  Assertions.assertNotNull(collectResponse.getStatus()); Assertions.assertEquals("pending", collectResponse.getStatus()); Assertions.assertNotNull(collectResponse.getHintCode()); Assertions.assertEquals("outstandingTransaction", collectResponse.getHintCode());  // Cancel boolean cancelResponse = this.rpApi.cancel(response.getOrderRef()); Assertions."<AssertPlaceHolder>"; }
cancel(String orderRef) { try { CancelRequest request = new CancelRequest(orderRef); ObjectMapper mapper = new ObjectMapper(); String jsonRequest = mapper.writeValueAsString(request);  long startTime = System.currentTimeMillis(); String result = this.post("cancel", jsonRequest); long elapsedTime = System.currentTimeMillis() - startTime; if (result == null) { this.logger.warn("Query to cancel transaction " + "failed after {} ms.", elapsedTime); return false; }  this.logger.info("Received json string from BankID RP after {} ms.", elapsedTime); return result.trim().equals("{}"); } catch (Exception e) { this.logger.warn("IOException while starting authentication: {}", e.getMessage()); return false; } }
[*] target: assertTrue(cancelResponse)
[-] pred: org. junit. Assert. assertTrue ( cancelResponse )
************************************
************************************
[+] input: testRender() { Map<String, Object> model = createTestMap(); model.put("key3", 100);  // Create a simple template with placeholders for keys in the generative String template = "This is a {key1}, it is {key2}, and it costs {key3}"; PromptTemplate promptTemplate = new PromptTemplate(template, model);  // The expected result after rendering the template with the generative String expected = "This is a value1, it is true, and it costs 100"; String result = promptTemplate.render();  // Check that the rendered string matches the expected result assertEquals(expected, result);  model.put("key3", 200); expected = "This is a value1, it is true, and it costs 200"; result = promptTemplate.render(model); "<AssertPlaceHolder>"; }
render(Map<String, Object> model) { validate(model); for (Entry<String, Object> entry : model.entrySet()) { if (this.st.getAttribute(entry.getKey()) != null) { this.st.remove(entry.getKey()); } if (entry.getValue() instanceof Resource) { this.st.add(entry.getKey(), renderResource((Resource) entry.getValue())); } else { this.st.add(entry.getKey(), entry.getValue()); }  } return this.st.render(); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testGetValidTokenWhenTokenExists() { User user = new User(); user.setEmail("E1"); PasswordResetRequest request = new PasswordResetRequest(); request.setEmail("E1"); request.setToken("T1");  PasswordResetToken token = service.createTokenWithUser(user); //doReturn(Optional.of(token)).when(repository).findByToken("T1"); doReturn(token).when(repository).findByToken("T1"); PasswordResetToken validToken = service.getValidToken(request);  "<AssertPlaceHolder>"; assertEquals(user, validToken.getUser()); verify(repository, times(1)).findByToken("T1"); }
getValidToken(PasswordResetRequest request) { String tokenID = request.getToken(); PasswordResetToken token = repository.findByToken(tokenID); if (ObjectUtils.isEmpty(token)) { throw new ResourceNotFoundException("Password Reset Token", "Token Id", tokenID); }  matchEmail(token, request.getEmail()); verifyExpiration(token); return token; }
[*] target: assertEquals(token, validToken)
[-] pred: org. junit. Assert. assertEquals ( token, validToken )
************************************
************************************
[+] input: Exception { // prepare String path = "user/" + userId + "/" + file.getName(); assertTrue(path.endsWith("mp4")); minioService.uploadObject(file, minioConfiguration.getStoreBucket(), path); // test videoService.download("minio.bucket.store://" + path, "download/" + videoId); File src = new File("download/" + videoId); src.deleteOnExit(); "<AssertPlaceHolder>"; }
download(String path, String outputName) throws Exception;
[*] target: assertTrue(src.exists())
[-] pred: org. junit. Assert. assertTrue ( src. exists ( ) )
************************************
************************************
[+] input: testExceptionToModelView() { // Create a mock Model Model model = new org.springframework.ui.ExtendedModelMap();  // Create a test exception Exception ex = new Exception("Test Exception");  // Call the method under test ModelAndView modelAndView = ErrorUtils.exceptionToModelView(model, ex);  // Verify the result "<AssertPlaceHolder>"; assertEquals("Test Exception", modelAndView.getModel().get("errorMessage")); assertNotNull(modelAndView.getModel().get("stackTrace")); }
exceptionToModelView(Model model, Exception ex) { StringWriter sw = new StringWriter(); ex.printStackTrace(new PrintWriter(sw)); String stackTrace = sw.toString();  ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("errorMessage", ex.getMessage()); modelAndView.addObject("stackTrace", stackTrace); return modelAndView; }
[*] target: assertNotNull(modelAndView)
[-] pred: org. junit. Assert. assertNotNull ( modelAndView )
************************************
************************************
[+] input: getAllCatalogs() { Iterable<CatalogEntity> catalogEntities = catalogService.getAllCatalogs();  "<AssertPlaceHolder>";  catalogEntities.forEach(v -> { assertTrue(v.getProductId().startsWith("CATALOG-")); }); }
getAllCatalogs() { return catalogRepository.findAll(); }
[*] target: assertNotNull(catalogEntities)
[-] pred: org. junit. Assert. assertNotNull ( catalogEntities )
************************************
************************************
[+] input: IOException { var result = subject.load(audio, pathToAudioFile);  // Assert successful loading "<AssertPlaceHolder>"; assertEquals(audio.getId(), result.getId()); assertEquals(audio.getWaveformKey(), result.getWaveformKey()); assertEquals(pathToAudioFile, result.pathToAudioFile()); assertEquals(2, result.format().getChannels()); assertEquals(48000, result.format().getSampleRate()); assertEquals(32, result.format().getSampleSizeInBits()); assertEquals(8, result.format().getFrameSize()); assertEquals(48000, result.format().getFrameRate()); assertFalse(result.format().isBigEndian()); assertEquals(17364, result.data().length); assertEquals(2, result.data()[0].length); assertFalse(result.isDifferent(audio));  // Assert isDifferent() method when id and waveform key are changed var audio_differentIdAndWaveformKey = new InstrumentAudio(); audio_differentIdAndWaveformKey.setId(UUID.randomUUID()); audio_differentIdAndWaveformKey.setWaveformKey("test-audio2.wav"); assertTrue(result.isDifferent(audio_differentIdAndWaveformKey));  // Assert isDifferent() method when only waveform key is changed var audio_differentWaveformKey = new InstrumentAudio(); audio_differentWaveformKey.setId(audio.getId()); audio_differentWaveformKey.setWaveformKey("test-audio2.wav"); assertTrue(result.isDifferent(audio_differentWaveformKey)); }
load(InstrumentAudio audio, String path) throws IOException, UnsupportedAudioFileException { AudioFormat format = AudioSystem.getAudioFileFormat(new File(path)).getFormat(); return load(audio, path, format); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************

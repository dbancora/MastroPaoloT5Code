[+] input: noFailingOutput() { String source = IntStream.range(0, 1000).mapToObj(String::valueOf).collect(joining()); int nOutputs = 10; ChannelByteSplitter splitter = ChannelByteSplitter.create(nOutputs); ByteBuf value = wrapUtf8(source); splitter.withInput(ChannelSuppliers.ofValue(value) .transformWith(ChannelTransformers.chunkBytes(MemSize.of(5), MemSize.of(10)))); List<String> results = new ArrayList<>(); for (int i = 0; i < nOutputs; i++) { splitter.addOutput().set(ChannelConsumers.ofSupplier(supplier -> supplier.toCollector(ByteBufs.collector()) .then(buf -> { results.add(buf.asString(UTF_8)); return Promise.complete(); }))); } await(splitter.getProcessCompletion());  "<AssertPlaceHolder>"; for (String result : results) { assertEquals(source, result); } }
addOutput() { int index = outputs.size(); outputs.add(null); return output -> { checkInReactorThread(this); outputs.set(index, output); tryStart(); }; }
[*] target: assertEquals(nOutputs, results.size())
[-] pred: org. junit. Assert. assertEquals ( nOutputs, results. size ( ) )
************************************
************************************
[+] input: transformsToByteBufferInReadMode() { ByteBuf buf = createEmptyByteBufOfSize(8); buf.tail(5); buf.head(2);  ByteBuffer buffer = buf.toReadByteBuffer();  assertEquals(2, buffer.position()); "<AssertPlaceHolder>"; }
limit() { return array.length; }
[*] target: assertEquals(5, buffer.limit())
[-] pred: org. junit. Assert. assertEquals ( 5, buffer. limit() )
************************************
************************************
[+] input: testWithError() { List<DataItemMasterDetail> list = new ArrayList<>();  StreamSupplier<DataItemMaster> source1 = StreamSuppliers.ofValues( new DataItemMaster(10, 10, "masterA"), new DataItemMaster(20, 10, "masterB"), new DataItemMaster(25, 15, "masterB+"), new DataItemMaster(30, 20, "masterC"), new DataItemMaster(40, 20, "masterD"));  StreamSupplier<DataItemDetail> source2 = StreamSuppliers.ofValues( new DataItemDetail(10, "detailX"), new DataItemDetail(20, "detailY"));  StreamLeftJoin<Integer, DataItemMaster, DataItemDetail, DataItemMasterDetail> streamLeftJoin = StreamLeftJoin.create(Integer::compareTo, input -> input.detailId, input -> input.id, new ValueLeftJoiner<>() { @Override public DataItemMasterDetail doInnerJoin(Integer key, DataItemMaster left, DataItemDetail right) { return new DataItemMasterDetail(left.id, left.detailId, left.master, right.detail); }  @Override public DataItemMasterDetail doOuterJoin(Integer key, DataItemMaster left) { return new DataItemMasterDetail(left.id, left.detailId, left.master, null); } } );  ExpectedException exception = new ExpectedException("Test Exception"); StreamConsumer<DataItemMasterDetail> consumer = ToListStreamConsumer.create(list) .transformWith(decorate(promise -> promise.then(item -> Promise.ofException(exception))));  Exception e = awaitException( source1.streamTo(streamLeftJoin.getLeft()), source2.streamTo(streamLeftJoin.getRight()), streamLeftJoin.getOutput().streamTo(consumer) );  "<AssertPlaceHolder>"; assertEquals(1, list.size()); assertClosedWithError(source1); assertClosedWithError(source2); }
getOutput() { return output; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: testSupplierWithError() { ExpectedException exception = new ExpectedException("Test Exception"); StreamSupplier<DataItemMaster> source1 = StreamSuppliers.concat( StreamSuppliers.ofValue(new DataItemMaster(10, 10, "masterA")), StreamSuppliers.closingWithError(exception), StreamSuppliers.ofValue(new DataItemMaster(20, 10, "masterB")), StreamSuppliers.ofValue(new DataItemMaster(25, 15, "masterB+")), StreamSuppliers.ofValue(new DataItemMaster(30, 20, "masterC")), StreamSuppliers.ofValue(new DataItemMaster(40, 20, "masterD")) );  StreamSupplier<DataItemDetail> source2 = StreamSuppliers.concat( StreamSuppliers.ofValue(new DataItemDetail(10, "detailX")), StreamSuppliers.ofValue(new DataItemDetail(20, "detailY")), StreamSuppliers.closingWithError(exception) );  StreamLeftJoin<Integer, DataItemMaster, DataItemDetail, DataItemMasterDetail> streamLeftJoin = StreamLeftJoin.create(Integer::compareTo, input -> input.detailId, input -> input.id, new ValueLeftJoiner<>() { @Override public DataItemMasterDetail doInnerJoin(Integer key, DataItemMaster left, DataItemDetail right) { return new DataItemMasterDetail(left.id, left.detailId, left.master, right.detail); }  @Override public DataItemMasterDetail doOuterJoin(Integer key, DataItemMaster left) { return new DataItemMasterDetail(left.id, left.detailId, left.master, null); } } );  List<DataItemMasterDetail> list = new ArrayList<>(); StreamConsumer<DataItemMasterDetail> consumer = ToListStreamConsumer.create(list);  Exception e = awaitException( source1.streamTo(streamLeftJoin.getLeft()), source2.streamTo(streamLeftJoin.getRight()), streamLeftJoin.getOutput().streamTo(consumer.transformWith(oneByOne())) );  "<AssertPlaceHolder>"; assertEquals(0, list.size()); assertClosedWithError(source1); assertClosedWithError(source2); }
getOutput() { return output; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: testSupplierDisconnectWithError() { StreamSupplier<KeyValue1> source1 = StreamSuppliers.ofValues(new KeyValue1(1, 10.0), new KeyValue1(3, 30.0));  Exception exception = new Exception("Test Exception"); StreamSupplier<KeyValue2> source2 = StreamSuppliers.closingWithError(exception);  StreamSupplier<KeyValue3> source3 = StreamSuppliers.ofValues(new KeyValue3(2, 10.0, 20.0), new KeyValue3(3, 10.0, 20.0));  StreamReducer<Integer, KeyValueResult, KeyValueResult> streamReducer = StreamReducer.<Integer, KeyValueResult, KeyValueResult>builder() .withBufferSize(1) .build();  ToListStreamConsumer<KeyValueResult> consumer = ToListStreamConsumer.create();  Exception e = awaitException( source1.streamTo(streamReducer.newInput(input -> input.key, KeyValue1.REDUCER)), source2.streamTo(streamReducer.newInput(input -> input.key, KeyValue2.REDUCER)), source3.streamTo(streamReducer.newInput(input -> input.key, KeyValue3.REDUCER)),  streamReducer.getOutput().streamTo(consumer) );  "<AssertPlaceHolder>"; assertEquals(0, consumer.getList().size()); assertClosedWithError(consumer); assertClosedWithError(source1); assertClosedWithError(source2); assertClosedWithError(source3); }
getOutput() { return output; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: optionalDependency() { String expected = "string"; Injector injector = Injector.of( ModuleBuilder.create() .bind(String.class).to(() -> expected) .bindOptionalDependency(String.class) .build());  OptionalDependency<String> optional = injector.getOptionalDependency(String.class);  assertTrue(optional.isPresent());  String string = optional.get();  "<AssertPlaceHolder>"; }
get() { if (value == null) { throw new NoSuchElementException(); } return value; }
[*] target: assertEquals(expected, string)
[-] pred: org. junit. Assert. assertEquals ( expected, string )
************************************
************************************
[+] input: testRepeat() { Exception exception = new Exception(); Exception e = awaitException(repeat(() -> { if (counter.get() == 5) { return Promise.ofException(exception); } counter.incrementAndGet(); return Promise.of(true); })); System.out.println(counter); "<AssertPlaceHolder>"; assertEquals(5, counter.get()); }
repeat(AsyncSupplier<Boolean> supplier) { SettablePromise<Void> cb = new SettablePromise<>(); repeatImpl(supplier, cb); return cb; }
[*] target: assertSame(exception, e)
[-] pred: org. junit. Assert. assertSame ( exception, e )
************************************
************************************
[+] input: testAddAndRemove() {  DynamicArray<Long> list = new DynamicArray<>(0);  for (int i = 0; i < 55; i++) list.add(44L); for (int i = 0; i < 55; i++) list.remove(44L); assertTrue(list.isEmpty());  for (int i = 0; i < 55; i++) list.add(44L); for (int i = 0; i < 55; i++) list.removeAt(0); assertTrue(list.isEmpty());  for (int i = 0; i < 155; i++) list.add(44L); for (int i = 0; i < 155; i++) list.remove(44L); assertTrue(list.isEmpty());  for (int i = 0; i < 155; i++) list.add(44L); for (int i = 0; i < 155; i++) list.removeAt(0); "<AssertPlaceHolder>"; }
isEmpty() { // YOUR CODE HERE return false; }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: testAddSetRemove() {  DynamicArray<Long> list = new DynamicArray<>(0);  for (int i = 0; i < 55; i++) list.add(44L); for (int i = 0; i < 55; i++) list.set(i, 33L); for (int i = 0; i < 55; i++) list.remove(33L); assertTrue(list.isEmpty());  for (int i = 0; i < 55; i++) list.add(44L); for (int i = 0; i < 55; i++) list.set(i, 33L); for (int i = 0; i < 55; i++) list.removeAt(0); assertTrue(list.isEmpty());  for (int i = 0; i < 155; i++) list.add(44L); for (int i = 0; i < 155; i++) list.set(i, 33L); for (int i = 0; i < 155; i++) list.remove(33L); assertTrue(list.isEmpty());  for (int i = 0; i < 155; i++) list.add(44L); for (int i = 0; i < 155; i++) list.removeAt(0); "<AssertPlaceHolder>"; }
isEmpty() { // YOUR CODE HERE return false; }
[*] target: assertTrue(list.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( list. isEmpty() )
************************************
************************************
[+] input: testClear() {  BinaryHeap<String> q; String[] strs = {"aa", "bb", "cc", "dd", "ee"}; q = new BinaryHeap<>(strs); q.clear(); assertEquals(q.size(), 0); "<AssertPlaceHolder>"; }
isEmpty() { // TODO YOUR CODE HERE return false; }
[*] target: assertTrue(q.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( q. isEmpty() )
************************************
************************************
[+] input: testSetOnJoinResetMoney() { s.setOnJoinResetMoney(false); assertFalse(s.isOnJoinResetMoney()); s.setOnJoinResetMoney(true); "<AssertPlaceHolder>"; }
isOnJoinResetMoney() { return onJoinResetMoney; }
[*] target: assertTrue(s.isOnJoinResetMoney())
[-] pred: org. junit. Assert. assertTrue ( s. isOnJoinResetMoney() )
************************************
************************************
[+] input: testSetCreateIslandOnFirstLoginAbortOnLogout() { s.setCreateIslandOnFirstLoginAbortOnLogout(false); assertFalse(s.isCreateIslandOnFirstLoginAbortOnLogout()); s.setCreateIslandOnFirstLoginAbortOnLogout(true); "<AssertPlaceHolder>"; }
isCreateIslandOnFirstLoginAbortOnLogout() { return createIslandOnFirstLoginAbortOnLogout; }
[*] target: assertTrue(s.isCreateIslandOnFirstLoginAbortOnLogout())
[-] pred: org. junit. Assert. assertTrue ( s. isCreateIslandOnFirstLoginAbortOnLogout() )
************************************
************************************
[+] input: testSetOnLeaveResetXP() { assertFalse(s.isOnLeaveResetXP()); s.setOnLeaveResetXP(true); "<AssertPlaceHolder>"; }
isOnLeaveResetXP() { return onLeaveResetXP; }
[*] target: assertTrue(s.isOnLeaveResetXP())
[-] pred: org. junit. Assert. assertTrue ( s. isOnLeaveResetXP() )
************************************
************************************
[+] input: testSetPasteMissingIslands() { assertFalse(s.isPasteMissingIslands()); s.setPasteMissingIslands(true); "<AssertPlaceHolder>";   }
isPasteMissingIslands() { return pasteMissingIslands; }
[*] target: assertTrue(s.isPasteMissingIslands())
[-] pred: org. junit. Assert. assertTrue ( s. isPasteMissingIslands() )
************************************
************************************
[+] input: testSetTeleportPlayerToIslandUponIslandCreation() { assertTrue(s.isTeleportPlayerToIslandUponIslandCreation()); s.setTeleportPlayerToIslandUponIslandCreation(false); "<AssertPlaceHolder>"; }
isTeleportPlayerToIslandUponIslandCreation() { return teleportPlayerToIslandUponIslandCreation; }
[*] target: assertFalse(s.isTeleportPlayerToIslandUponIslandCreation())
[-] pred: org. junit. Assert. assertFalse ( s. isTeleportPlayerToIslandUponIslandCreation() )
************************************
************************************
[+] input: testSetUseHolograms() { assertTrue(s.isUseHolograms()); s.setUseHolograms(false); "<AssertPlaceHolder>"; }
isUseHolograms() { return useHolograms; }
[*] target: assertFalse(s.isUseHolograms())
[-] pred: org. junit. Assert. assertFalse ( s. isUseHolograms() )
************************************
************************************
[+] input: Exception { // Obtained by prepending the rsa-1024 certificate to the PKCS#7 SignedData certificates set // of v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-2048.apk META-INF/CERT.RSA. The certs // (in the order of appearance in the file) are thus: rsa-1024, rsa-2048. The package's // signing cert is rsa-2048. ApkVerifier.Result result = verify("v1-only-pkcs7-cert-bag-first-cert-not-used.apk"); assertVerified(result); List<X509Certificate> signingCerts = result.getSignerCertificates(); "<AssertPlaceHolder>"; assertEquals( "fb5dbd3c669af9fc236c6991e6387b7f11ff0590997f22d0f5c74ff40e04fca8", HexEncoding.encode(sha256(signingCerts.get(0).getEncoded()))); }
getSignerCertificates() { return mSignerCerts; }
[*] target: assertEquals(1, signingCerts.size())
[-] pred: org. junit. Assert. assertEquals ( 1, signingCerts. size ( ) )
************************************
************************************
[+] input: NoSuchAlgorithmException { //        AESPair keyPair = AES256.generateKeyPairOld(); //        SecretKey key = keyPair.getKey(); //        byte[] IV = keyPair.getIV(); //        byte[] sk = AES256.serializeSecretKey(key); // //        List<byte[]> listofbytes = new ArrayList<>(); //        listofbytes.add(sk); //        listofbytes.add(IV); // //        byte[] shareBetweenUsers = ByteHelper.concat(listofbytes); //        assertEquals(shareBetweenUsers.length, 32+16); //        assertTrue(Arrays.equals(Arrays.copyOfRange(shareBetweenUsers, 0, 32), sk)); //        assertTrue(Arrays.equals(Arrays.copyOfRange(shareBetweenUsers, 32, shareBetweenUsers.length), IV)); // //        SecretKey reconstructedKey = AES256.deserializeSecretKey(sk); //        boolean r = (key.equals(reconstructedKey)); // //        "<AssertPlaceHolder>"; }
deserializeSecretKey (byte[] sk) { return new SecretKeySpec(sk, 0, sk.length, Constant.AES); }
[*] target: assertTrue(r)
[-] pred: org. junit. Assert. assertTrue ( r )
************************************
************************************
[+] input: Exception { String message = "1";  KeyPair kp2048 = RSA.generateKeyPair(); PublicKey pk = kp2048.getPublic(); PrivateKey sk = kp2048.getPrivate();  byte[] sign = RSA.signAsBytes(message, sk); assertEquals(sign.length, 256);  boolean valid = RSA.verifyAsBytes(message, sign, pk); "<AssertPlaceHolder>"; }
verifyAsBytes(String plainText, byte[] signatureBytes, PublicKey publicKey) throws Exception { java.security.Signature publicSignature = java.security.Signature.getInstance("SHA256withRSA"); publicSignature.initVerify(publicKey); publicSignature.update(plainText.getBytes(UTF_8));  return publicSignature.verify(signatureBytes); }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: Exception { String message = "1"; KeyPair kp4096 = RSA.generateKeyPair(4096); PublicKey pk = kp4096.getPublic(); PrivateKey sk = kp4096.getPrivate();  byte[] sign = RSA.signAsBytes(message, sk); assertEquals(sign.length, 512);  boolean valid = RSA.verifyAsBytes(message, sign, pk); "<AssertPlaceHolder>"; }
verifyAsBytes(String plainText, byte[] signatureBytes, PublicKey publicKey) throws Exception { java.security.Signature publicSignature = java.security.Signature.getInstance("SHA256withRSA"); publicSignature.initVerify(publicKey); publicSignature.update(plainText.getBytes(UTF_8));  return publicSignature.verify(signatureBytes); }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: Exception { KeyPair alice = RSA.generateKeyPair(); KeyPair bob = RSA.generateKeyPair();  byte[] message = SHA256.hash("hello");  byte[] encryptedMessageFromAliceToBob = RSA.encrypt(message, bob.getPublic()); byte[] encryptedMessageFromBobToAlice = RSA.encrypt(message, alice.getPublic());  byte[] bobDecryptsAlicesMessage = RSA.decrypt(encryptedMessageFromAliceToBob, bob.getPrivate()); boolean bobCanReadAlicesMessage = Arrays.equals(bobDecryptsAlicesMessage, message);  System.out.println("Bob can read Alice's message : " + bobCanReadAlicesMessage); assertTrue(bobCanReadAlicesMessage);  byte[] aliceDecryptsBobsMessage = RSA.decrypt(encryptedMessageFromBobToAlice, alice.getPrivate()); boolean aliceCanReadBobsMessage = Arrays.equals(aliceDecryptsBobsMessage, message);  System.out.println("Alice can read Bob's message : " + aliceCanReadBobsMessage); "<AssertPlaceHolder>"; }
decrypt(byte[] encryptedData, PrivateKey privateKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException { Cipher cipher = Cipher.getInstance(Constant.RSA_CIPHER); cipher.init(Cipher.DECRYPT_MODE, privateKey); return cipher.doFinal(encryptedData); }
[*] target: assertTrue(aliceCanReadBobsMessage)
[-] pred: org. junit. Assert. assertTrue ( aliceCanReadBobsMessage )
************************************
************************************
[+] input: NoSuchAlgorithmException { String message = "1"; byte[] messageHash = SHA256.hash(message);  String actualHashHex = "6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b"; byte[] actualHash = ByteHelper.hexStringToByteArray(actualHashHex);  boolean valid = Arrays.equals(messageHash, actualHash); "<AssertPlaceHolder>";  assertEquals(messageHash.length, 32); }
hexStringToByteArray(String hexString){ byte[] bytes = new byte[hexString.length() / 2];  for(int i = 0; i < hexString.length(); i += 2){ String sub = hexString.substring(i, i + 2); Integer intVal = Integer.parseInt(sub, 16); bytes[i / 2] = intVal.byteValue(); String hex = "".format("0x%x", bytes[i / 2]); } return bytes; }
[*] target: assertTrue(valid)
[-] pred: org. junit. Assert. assertTrue ( valid )
************************************
************************************
[+] input: IOException { //        final List<String> expectedApkFiles = Arrays.asList("base.apk", //                "split_config.en.apk", //                "split_config.hdpi.apk"); //        Collections.sort(expectedApkFiles); //        Path xmlFile = Paths.get(new File(backupLocation, PACKAGE_NAME_APK_SPLITS + ".xml")); //        SBConverter sbConvert = new SBConverter(xmlFile); //        sbConvert.convert(); //        Path newBackupLocation = Prefs.Storage.getAppManagerDirectory().findFile(PACKAGE_NAME_APK_SPLITS).findFile("0_SB"); //        // Verify source //        List<String> actualApkFiles = TarUtilsTest.getFileNamesGZip(Collections.singletonList( //                newBackupLocation.findFile("source.tar.gz.0"))); //        Collections.sort(actualApkFiles); //        "<AssertPlaceHolder>"; //        assertFalse(newBackupLocation.hasFile("data0.tar.gz.0")); //        assertFalse(newBackupLocation.hasFile("data1.tar.gz.0")); //    }
convert() throws BackupException { // Source metadata mSourceMetadata = new MetadataManager.Metadata(); generateMetadata(); // Destination metadata mDestMetadata = new MetadataManager.Metadata(mSourceMetadata); MetadataManager metadataManager = MetadataManager.getNewInstance(); metadataManager.setMetadata(mDestMetadata); // Simulate a backup creation // If the package has another backup named SB, another backup will be created BackupFiles backupFiles; BackupFiles.BackupFile[] backupFileList; try { backupFiles = new BackupFiles(mPackageName, mUserId, new String[]{"SB"}); backupFileList = backupFiles.getBackupPaths(true); } catch (IOException e) { throw new BackupException("Could not get backup files.", e); } for (BackupFiles.BackupFile backupFile : backupFileList) { // We're iterating over a singleton list boolean backupSuccess = false; try { mTempBackupPath = backupFile.getBackupPath(); mCrypto = ConvertUtils.setupCrypto(mDestMetadata); mDestMetadata.backupName = backupFile.backupName; try { mChecksum = backupFile.getChecksum(CryptoUtils.MODE_NO_ENCRYPTION); } catch (IOException e) { throw new BackupException("Failed to create checksum file.", e); } // Backup icon backupIcon(); if (mDestMetadata.flags.backupApkFiles()) { backupApkFile(); } if (mDestMetadata.flags.backupData()) { backupData(); } // Write modified metadata metadataManager.setMetadata(mDestMetadata); try { metadataManager.writeMetadata(backupFile); } catch (IOException e) { throw new BackupException("Failed to write metadata."); } // Store checksum for metadata try { mChecksum.add(MetadataManager.META_FILE, DigestUtils.getHexDigest(mDestMetadata.checksumAlgo, backupFile.getMetadataFile())); } catch (IOException e) { throw new BackupException("Failed to generate checksum for meta.json", e); } mChecksum.close(); // Encrypt checksum try { Path checksumFile = backupFile.getChecksumFile(CryptoUtils.MODE_NO_ENCRYPTION); encrypt(new Path[]{checksumFile}); } catch (IOException e) { throw new BackupException("Failed to encrypt checksums.txt"); } // Replace current backup try { backupFile.commit(); } catch (IOException e) { throw new BackupException("Could not finalise backup.", e); } backupSuccess = true; } catch (BackupException e) { throw e; } catch (Throwable th) { throw new BackupException("Unknown error occurred.", th); } finally { if (!backupSuccess) { backupFile.cleanup(); } if (mCrypto != null) { mCrypto.close(); } mCachedApk.requireParent().delete(); if (backupSuccess) { BackupUtils.putBackupToDbAndBroadcast(ContextUtils.getContext(), mDestMetadata); } } return; } }
[*] target: assertEquals(expectedApkFiles, actualApkFiles)
[-] pred: org. junit. Assert. assertEquals ( expectedApkFiles, actualApkFiles )
************************************
************************************
[+] input: IOException { final List<String> internalStorage = Arrays.asList("code_cache/", "code_cache/com.android.opengl.shaders_cache", "shared_prefs/", "shared_prefs/ca.cmetcalfe.locationshare_preferences.xml", "shared_prefs/_has_set_default_values.xml"); Collections.sort(internalStorage); Path propFile = Paths.get(new File(backupLocation, PACKAGE_NAME_INT + "-20210529-164219.properties")); TBConverter tbConvert = new TBConverter(propFile); tbConvert.convert(); Path newBackupLocation = Prefs.Storage.getAppManagerDirectory().findFile(PACKAGE_NAME_INT).findFile("0_TB"); // Verify source List<String> files = TarUtilsTest.getFileNamesGZip(Collections.singletonList(newBackupLocation.findFile("data0.tar.gz.0"))); Collections.sort(files); "<AssertPlaceHolder>"; assertFalse(newBackupLocation.hasFile("source.tar.gz.0")); assertFalse(newBackupLocation.hasFile("data1.tar.gz.0")); }
convert() throws BackupException { if (mPackageName == null) { throw new BackupException("Could not read package name."); } // Source metadata mSourceMetadata = new MetadataManager.Metadata(); readPropFile(); // Destination metadata mDestMetadata = new MetadataManager.Metadata(mSourceMetadata); // Destination files will be encrypted by the default encryption method mDestMetadata.crypto = CryptoUtils.getMode(); // Destination APK will be renamed mDestMetadata.apkName = "base.apk"; // Destination compression type will be the default compression method mDestMetadata.tarType = Prefs.BackupRestore.getCompressionMethod(); MetadataManager metadataManager = MetadataManager.getNewInstance(); metadataManager.setMetadata(mDestMetadata); // Simulate a backup creation BackupFiles backupFiles; BackupFiles.BackupFile[] backupFileList; try { backupFiles = new BackupFiles(mPackageName, mUserId, new String[]{"TB"}); backupFileList = backupFiles.getBackupPaths(true); } catch (IOException e) { throw new BackupException("Could not get backup files", e); } for (BackupFiles.BackupFile backupFile : backupFileList) { // We're iterating over a singleton list boolean backupSuccess = false; try { mTempBackupPath = backupFile.getBackupPath(); mCrypto = ConvertUtils.setupCrypto(mDestMetadata); mDestMetadata.backupName = backupFile.backupName; try { mChecksum = backupFile.getChecksum(CryptoUtils.MODE_NO_ENCRYPTION); } catch (IOException e) { throw new BackupException("Failed to create checksum file.", e); } // Backup icon backupIcon(); if (mDestMetadata.flags.backupApkFiles()) { backupApkFile(); } if (mDestMetadata.flags.backupData()) { backupData(); } // Write modified metadata metadataManager.setMetadata(mDestMetadata); try { metadataManager.writeMetadata(backupFile); } catch (IOException e) { throw new BackupException("Failed to write metadata.", e); } // Store checksum for metadata try { mChecksum.add(MetadataManager.META_FILE, DigestUtils.getHexDigest(mDestMetadata.checksumAlgo, backupFile.getMetadataFile())); } catch (IOException e) { throw new BackupException("Failed to generate checksum for meta.json", e); } mChecksum.close(); // Encrypt checksum try { Path checksumFile = backupFile.getChecksumFile(CryptoUtils.MODE_NO_ENCRYPTION); encrypt(new Path[]{checksumFile}); } catch (IOException e) { throw new BackupException("Failed to encrypt checksums.txt"); } // Replace current backup: // There's hardly any chance of getting a false here but checks are done anyway. try { backupFile.commit(); } catch (Exception e) { throw new BackupException("Could not finalise backup.", e); } backupSuccess = true; } catch (BackupException e) { throw e; } catch (Throwable th) { throw new BackupException("Unknown error occurred.", th); } finally { if (!backupSuccess) { backupFile.cleanup(); } if (mCrypto != null) { mCrypto.close(); } if (backupSuccess) { BackupUtils.putBackupToDbAndBroadcast(ContextUtils.getContext(), mDestMetadata); } } return; } }
[*] target: assertEquals(internalStorage, files)
[-] pred: org. junit. Assert. assertEquals ( internalStorage, files )
************************************
************************************
[+] input: IOException { Path path = tmpPath.createNewFile("am_new_file", null); assertTrue(path.isFile()); assertThrows(IOException.class, () -> tmpPath.findOrCreateDirectory("am_new_file")); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(path.delete())
[-] pred: org. junit. Assert. assertTrue ( path. delete() )
************************************
************************************
[+] input: IOException { Path src = tmpPath.createNewFile("am_new_file", null); Path dst = tmpPath.createNewFile("moved_file", null); assertFalse(src.moveTo(dst, false)); assertTrue(tmpPath.hasFile("moved_file")); assertTrue(tmpPath.hasFile("am_new_file")); assertNotEquals(dst, src); assertTrue(src.delete()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(dst.delete())
[-] pred: org. junit. Assert. assertTrue ( dst. delete() )
************************************
************************************
[+] input: IOException { Path dst = tmpPath.createNewFile("am_new_file", null); Path child = tmpPath.createNewDirectory("am_new_dir"); child.createNewFile("some_file", null); assertFalse(child.moveTo(dst)); assertTrue(tmpPath.hasFile("am_new_file")); assertTrue(tmpPath.hasFile("am_new_dir")); assertTrue(child.delete()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(dst.delete())
[-] pred: org. junit. Assert. assertTrue ( dst. delete() )
************************************
************************************
[+] input: IOException { Path src = tmpPath.createNewFile("am_new_file", null); Path dst = tmpPath.createNewFile("copied_file", null); assertNotNull(src.copyTo(dst)); assertTrue(tmpPath.hasFile("am_new_file")); assertTrue(tmpPath.hasFile("copied_file")); assertNotEquals(dst, src); assertTrue(src.delete()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(dst.delete())
[-] pred: org. junit. Assert. assertTrue ( dst. delete() )
************************************
************************************
[+] input: IOException { Path src = tmpPath.createNewFile("am_new_file", null); Path dst = tmpPath.createNewFile("copied_file", null); assertNull(src.copyTo(dst, false)); assertTrue(tmpPath.hasFile("am_new_file")); assertTrue(tmpPath.hasFile("copied_file")); assertNotEquals(dst, src); assertTrue(src.delete()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(dst.delete())
[-] pred: org. junit. Assert. assertTrue ( dst. delete() )
************************************
************************************
[+] input: IOException { Path dst = tmpPath.createNewFile("am_new_file", null); Path child = tmpPath.createNewDirectory("am_new_dir"); child.createNewFile("some_file", null); assertNull(child.copyTo(dst)); assertTrue(tmpPath.hasFile("am_new_file")); assertTrue(tmpPath.hasFile("am_new_dir")); assertTrue(child.delete()); "<AssertPlaceHolder>"; }
delete() { if (isMountPoint()) { return false; } return documentFile.delete(); }
[*] target: assertTrue(dst.delete())
[-] pred: org. junit. Assert. assertTrue ( dst. delete() )
************************************
************************************
[+] input: IOException { try (SplitInputStream splitInputStream = new SplitInputStream(fileList)) { // For 1 KB long expectedSkipBytes = 10024; long actualSkipBytes = splitInputStream.skip(expectedSkipBytes); assertEquals(expectedSkipBytes, actualSkipBytes); // For 1 MB expectedSkipBytes = 1024 * 1024; actualSkipBytes = splitInputStream.skip(expectedSkipBytes); assertEquals(expectedSkipBytes, actualSkipBytes); // For 2 MB expectedSkipBytes = 1024 * 1024 * 2; actualSkipBytes = splitInputStream.skip(expectedSkipBytes); "<AssertPlaceHolder>"; } }
skip(long n) throws IOException { if (n <= 0) return 0; return Math.max(read0(null, 0, (int) n), 0); }
[*] target: assertEquals(expectedSkipBytes, actualSkipBytes)
[-] pred: org. junit. Assert. assertEquals ( expectedSkipBytes, actualSkipBytes )
************************************
************************************
[+] input: should_throw_exception_if_directive_class_not_a_wiring1() { directivePostProcessor.postProcessBeforeInitialization(new CorrectDirective(), "a"); Map<String, SchemaDirectiveWiring> map = (Map<String, SchemaDirectiveWiring>) ReflectionTestUtils.getField(RuntimeWiringRegistry.class, "NAME_AND_DIRECTIVE_WIRING"); "<AssertPlaceHolder>"; assertEquals(1, map.size()); assertTrue(map.containsKey("b")); }
postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { Class<?> targetClass = AopProxyUtils.ultimateTargetClass(bean); if (targetClass.isAnnotationPresent(Directive.class)) { Directive directive = targetClass.getAnnotation(Directive.class); if (bean instanceof SchemaDirectiveWiring) { RuntimeWiringRegistry.registerDirective(directive.value(), (SchemaDirectiveWiring) bean); } else { throw new BeanInitializationException("directive bean must implements SchemaDirectiveWiring! bean:" + beanName); } } return bean; }
[*] target: assertNotNull(map)
[-] pred: org. junit. Assert. assertNotNull ( map )
************************************
************************************
[+] input: Exception { AgentSink mockedSink = mock(AgentSink.class); PowerMockito.whenNew(AgentSink.class) .withAnyArguments() .then( invocation -> { Endpoint endpoint = invocation.getArgument(2); assertEquals(Endpoint.DEFAULT_TCP_ENDPOINT, endpoint); return mockedSink; });  AgentBasedEnvironment env = new AgentBasedEnvironmentTestImplementation(configuration); ISink sink = env.getSink();  "<AssertPlaceHolder>"; }
getSink() { if (sink == null) { if (config.shouldWriteToStdout()) { sink = new ConsoleSink(); } else { Endpoint endpoint; if (config.getAgentEndpoint().isPresent()) { endpoint = Endpoint.fromURL(config.getAgentEndpoint().get()); } else { log.info( "Endpoint is not defined. Using default: {}", Endpoint.DEFAULT_TCP_ENDPOINT); endpoint = Endpoint.DEFAULT_TCP_ENDPOINT; } sink = new AgentSink( getLogGroupName(), getLogStreamName(), endpoint, new SocketClientFactory(), config.getAsyncBufferSize(), () -> new FibonacciRetryStrategy( Constants.MIN_BACKOFF_MILLIS, Constants.MAX_BACKOFF_MILLIS, Constants.MAX_BACKOFF_JITTER)); } } return sink; }
[*] target: assertEquals(mockedSink, sink)
[-] pred: org. junit. Assert. assertEquals ( mockedSink, sink )
************************************
************************************
[+] input: Exception { String endpointUrl = "http://configured-endpoint:1234"; configuration.setAgentEndpoint(endpointUrl); AgentSink mockedSink = mock(AgentSink.class); PowerMockito.whenNew(AgentSink.class) .withAnyArguments() .then( invocation -> { Endpoint endpoint = invocation.getArgument(2); assertEquals(Endpoint.fromURL(endpointUrl), endpoint); return mockedSink; });  AgentBasedEnvironment env = new AgentBasedEnvironmentTestImplementation(configuration); ISink sink = env.getSink();  "<AssertPlaceHolder>"; }
getSink() { if (sink == null) { if (config.shouldWriteToStdout()) { sink = new ConsoleSink(); } else { Endpoint endpoint; if (config.getAgentEndpoint().isPresent()) { endpoint = Endpoint.fromURL(config.getAgentEndpoint().get()); } else { log.info( "Endpoint is not defined. Using default: {}", Endpoint.DEFAULT_TCP_ENDPOINT); endpoint = Endpoint.DEFAULT_TCP_ENDPOINT; } sink = new AgentSink( getLogGroupName(), getLogStreamName(), endpoint, new SocketClientFactory(), config.getAsyncBufferSize(), () -> new FibonacciRetryStrategy( Constants.MIN_BACKOFF_MILLIS, Constants.MAX_BACKOFF_MILLIS, Constants.MAX_BACKOFF_JITTER)); } } return sink; }
[*] target: assertEquals(mockedSink, sink)
[-] pred: org. junit. Assert. assertEquals ( mockedSink, sink )
************************************
************************************
[+] input: Exception { String rawEvent = summaryEvent; int index = 5; JSONObject jsonEvent = (JSONObject) new JSONParser().parse(rawEvent);  // ctor parses the event, otherwise throws, which is the primary validation here BEPTestSummaryEvent event = new BEPTestSummaryEvent(rawEvent, index, jsonEvent);  assertFalse(event.isError()); assertFalse(event.isLastMessage()); assertFalse(event.isProcessed()); assertEquals("testSummary", event.getEventType());  assertEquals("//foo:foo-test", event.getTestLabel()); assertEquals( "file:///private/var/tmp/_bazel_mbenioff/8fc74f66fda297c82a847368ee50d6a4/execroot/myrepo/bazel-out/darwin-fastbuild/testlogs/foo/foo-test/test.log", event.getTestLogs().get(0).getUri().toString());  assertEquals("PASSED", event.getTestStatus()); assertEquals(1622354133812L, event.getFirstStartTimeMillis()); assertEquals(1622354134270L, event.getLastStopTimeMillis()); assertEquals(458, event.getTotalRunDurationMillis()); "<AssertPlaceHolder>"; }
getTotalRunCount() { return totalRunCount; }
[*] target: assertEquals(1, event.getTotalRunCount())
[-] pred: org. junit. Assert. assertEquals ( 1, event. getTotalRunCount ( ) )
************************************
************************************
[+] input: testHappyPath() { // to make this a unit test, we need to mock out the computations that would ordinarily involve collaborators // such as Bazel Query, filesystem scanning, and file parsing TestBazelQueryProjectStructureStrategy strategy = new TestBazelQueryProjectStructureStrategy(); addSourcePathForTest(strategy, "source/main/java"); addSourcePathForTest(strategy, "source/test/java"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/main/resources"); addTestResourcePathForTest(strategy, "projects/libs/apple/source/test/resources");  addSimQueryResult(strategy, "source/main/java/com/salesforce/apple/api/Apple.java"); addSimQueryResult(strategy, "source/main/java/com/salesforce/apple/api/ApplePie.java"); addSimQueryResult(strategy, "source/main/resources/fruit/kinds.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/pies.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/cakes.properties"); addSimQueryResult(strategy, "source/main/resources/recipes/sauces.properties"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/AppleTest.java"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/ApplePieTest.java"); addSimQueryResult(strategy, "source/test/resources/test.properties");  // run the test String relPath = FSPathHelper.osSeps("projects/libs/apple"); InMemoryPackageLocation packageLocation = new InMemoryPackageLocation(relPath); ProjectStructure structure = null; try { structure = strategy.doStructureAnalysis(bazelWorkspace, packageLocation, nullCommandRunner); } catch (Exception anyE) { anyE.printStackTrace(); }  // validate "<AssertPlaceHolder>"; assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/main/java"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/main/resources"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/source/test/java"); assertContains(structure.testResourceDirFSPaths, "projects/libs/apple/source/test/resources"); }
doStructureAnalysis(BazelWorkspace bazelWorkspace, BazelPackageLocation packageNode, BazelWorkspaceCommandRunner commandRunner) {  File workspaceRootDir = bazelWorkspace.getBazelWorkspaceRootDirectory(); String packageRelPath = packageNode.getBazelPackageFSRelativePath(); File packageDir = new File(workspaceRootDir, packageRelPath); // TODO move this to the PackageLocation api  String labelPath = packageRelPath.replaceAll(FSPathHelper.WINDOWS_BACKSLASH_REGEX, "/"); BazelLabel packageLabel = new BazelLabel(labelPath, BazelLabel.BAZEL_WILDCARD_ALLTARGETS_STAR);  // execute the expensive query, this will take a few seconds to run at least Collection<String> queryResults = runBazelQueryForSourceFiles(workspaceRootDir, packageLabel, commandRunner);  ProjectStructure structure = processQueryResults(packageRelPath, packageDir, packageLabel, queryResults);  return structure; }
[*] target: assertNotNull(structure)
[-] pred: org. junit. Assert. assertNotNull ( structure )
************************************
************************************
[+] input: testMultipleSourceDirs() { // to make this a unit test, we need to mock out the computations that would ordinarily involve collaborators // such as Bazel Query, filesystem scanning, and file parsing TestBazelQueryProjectStructureStrategy strategy = new TestBazelQueryProjectStructureStrategy(); addSourcePathForTest(strategy, "source/dev/java"); addSourcePathForTest(strategy, "source/dev2/java"); addSourcePathForTest(strategy, "source/test/java"); addSourcePathForTest(strategy, "src/test/java"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/dev/resources/fruit"); addMainResourcePathForTest(strategy, "projects/libs/apple/source/dev2/resources"); addTestResourcePathForTest(strategy, "projects/libs/apple/source/test/resources");  addSimQueryResult(strategy, "source/dev/java/com/salesforce/apple/api/Apple.java"); addSimQueryResult(strategy, "source/dev2/java/com/salesforce/apple/api/ApplePie.java"); addSimQueryResult(strategy, "source/dev/resources/fruit/kinds.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/pies.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/cakes.properties"); addSimQueryResult(strategy, "source/dev2/resources/recipes/sauces.properties"); addSimQueryResult(strategy, "source/test/java/com/salesforce/apple/api/AppleTest.java"); addSimQueryResult(strategy, "src/test/java/com/salesforce/apple/api/ApplePieTest.java"); addSimQueryResult(strategy, "source/test/resources/test.properties");  // run the test String relPath = FSPathHelper.osSeps("projects/libs/apple"); InMemoryPackageLocation packageLocation = new InMemoryPackageLocation(relPath); ProjectStructure structure = strategy.doStructureAnalysis(bazelWorkspace, packageLocation, nullCommandRunner);  // validate "<AssertPlaceHolder>"; assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/dev/java"); assertContains(structure.mainSourceDirFSPaths, "projects/libs/apple/source/dev2/java"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/dev/resources/fruit"); assertContains(structure.mainResourceDirFSPaths, "projects/libs/apple/source/dev2/resources"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/source/test/java"); assertContains(structure.testSourceDirFSPaths, "projects/libs/apple/src/test/java"); assertContains(structure.testResourceDirFSPaths, "projects/libs/apple/source/test/resources"); }
doStructureAnalysis(BazelWorkspace bazelWorkspace, BazelPackageLocation packageNode, BazelWorkspaceCommandRunner commandRunner) {  File workspaceRootDir = bazelWorkspace.getBazelWorkspaceRootDirectory(); String packageRelPath = packageNode.getBazelPackageFSRelativePath(); File packageDir = new File(workspaceRootDir, packageRelPath); // TODO move this to the PackageLocation api  String labelPath = packageRelPath.replaceAll(FSPathHelper.WINDOWS_BACKSLASH_REGEX, "/"); BazelLabel packageLabel = new BazelLabel(labelPath, BazelLabel.BAZEL_WILDCARD_ALLTARGETS_STAR);  // execute the expensive query, this will take a few seconds to run at least Collection<String> queryResults = runBazelQueryForSourceFiles(workspaceRootDir, packageLabel, commandRunner);  ProjectStructure structure = processQueryResults(packageRelPath, packageDir, packageLabel, queryResults);  return structure; }
[*] target: assertNotNull(structure)
[-] pred: org. junit. Assert. assertNotNull ( structure )
************************************
************************************
[+] input: testPlot() { double[] nums = new double[]{2710, 2755, 2850, 2880, 2880, 2890, 2920, 2940, 2950, 3050, 3130, 3325}; BoxPlot plot = BoxPlotUtil.plot(nums); TestCase."<AssertPlaceHolder>"; TestCase.assertEquals(3202.5D, plot.getMaxRegion()); TestCase.assertEquals(3000.0D, plot.getQ3()); TestCase.assertEquals(2905.0, plot.getMedian()); TestCase.assertEquals(2865.0, plot.getQ1()); TestCase.assertEquals(2662.5D, plot.getMinRegion()); }
plot(double[] data) { List<Double> collect = Arrays.stream(data).boxed().sorted().collect(Collectors.toList()); data = collect.stream().mapToDouble(i -> i).toArray(); if (data.length <= 2) { return null; }  double max; double q3; double median; double q1; double min; double iqr; if (data.length % 2 == 0) { median = (data[(data.length) / 2 - 1] + data[(data.length) / 2]) / 2; q1 = (data[(data.length) / 4 - 1] + data[(data.length) / 4]) / 2; q3 = (data[((data.length) * 3) / 4 - 1] + data[((data.length) * 3) / 4]) / 2; } else { median = data[(data.length) / 2]; q1 = data[(data.length) / 4]; q3 = data[(data.length * 3) / 4]; } max = data[data.length - 1]; min = data[0]; iqr = q3 - q1;  double maxRegion = q3 + 1.5 * iqr; double minRegion = q1 - 1.5 * iqr;  BoxPlot box = new BoxPlot(); box.setMaxRegion(maxRegion); box.setMax(max); box.setQ3(q3); box.setMedian(median); box.setQ1(q1); box.setMin(min); box.setMinRegion(minRegion); box.setIqr(iqr); return box; }
[*] target: assertNotNull(plot)
[-] pred: org. junit. Assert. assertNotNull ( plot )
************************************
************************************
[+] input: Exception { context.checking(new Expectations() {{ oneOf(crypto).decryptWithPassword(encryptedKey, password, keyStrengthener); will(returnValue(key.getBytes())); oneOf(crypto).isEncryptedWithStrengthenedKey(encryptedKey); will(returnValue(true)); }});  storeDatabaseKey(keyFile, encryptedKeyHex); storeDatabaseKey(keyBackupFile, encryptedKeyHex);  assertEquals(encryptedKeyHex, loadDatabaseKey(keyFile)); assertEquals(encryptedKeyHex, loadDatabaseKey(keyBackupFile));  accountManager.signIn(password); assertTrue(accountManager.hasDatabaseKey()); SecretKey decrypted = accountManager.getDatabaseKey(); "<AssertPlaceHolder>"; assertArrayEquals(key.getBytes(), decrypted.getBytes());  assertEquals(encryptedKeyHex, loadDatabaseKey(keyFile)); assertEquals(encryptedKeyHex, loadDatabaseKey(keyBackupFile)); }
getDatabaseKey() { return databaseKey; }
[*] target: assertNotNull(decrypted)
[-] pred: org. junit. Assert. assertNotNull ( decrypted )
************************************
************************************
[+] input: Exception { Collection<MessageId> messagesToAck = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToAck(txn, contactId, 123); will(returnValue(messagesToAck)); oneOf(database).lowerAckFlag(txn, contactId, messagesToAck); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Ack a = db.generateAck(transaction, contactId, 123); "<AssertPlaceHolder>"; assertEquals(messagesToAck, a.getMessageIds()); }); }
generateAck(Transaction transaction, ContactId c, int maxMessages) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToAck(txn, c, maxMessages); if (ids.isEmpty()) return null; db.lowerAckFlag(txn, c, ids); return new Ack(ids); }
[*] target: assertNotNull(a)
[-] pred: org. junit. Assert. assertNotNull ( a )
************************************
************************************
[+] input: Exception { MessageId messageId1 = new MessageId(getRandomId()); Collection<MessageId> ids = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToOffer(txn, contactId, 123, maxLatency); will(returnValue(ids)); oneOf(database).updateRetransmissionData(txn, contactId, messageId, maxLatency); oneOf(database).updateRetransmissionData(txn, contactId, messageId1, maxLatency); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Offer o = db.generateOffer(transaction, contactId, 123, maxLatency); "<AssertPlaceHolder>"; assertEquals(ids, o.getMessageIds()); }); }
generateOffer(Transaction transaction, ContactId c, int maxMessages, long maxLatency) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToOffer(txn, c, maxMessages, maxLatency); if (ids.isEmpty()) return null; for (MessageId m : ids) db.updateRetransmissionData(txn, c, m, maxLatency); return new Offer(ids); }
[*] target: assertNotNull(o)
[-] pred: org. junit. Assert. assertNotNull ( o )
************************************
************************************
[+] input: Exception { MessageId messageId1 = new MessageId(getRandomId()); Collection<MessageId> ids = asList(messageId, messageId1); context.checking(new Expectations() {{ oneOf(database).startTransaction(); will(returnValue(txn)); oneOf(database).containsContact(txn, contactId); will(returnValue(true)); oneOf(database).getMessagesToRequest(txn, contactId, 123); will(returnValue(ids)); oneOf(database).removeOfferedMessages(txn, contactId, ids); oneOf(database).commitTransaction(txn); }}); DatabaseComponent db = createDatabaseComponent(database, eventBus, eventExecutor, shutdownManager);  db.transaction(false, transaction -> { Request r = db.generateRequest(transaction, contactId, 123); "<AssertPlaceHolder>"; assertEquals(ids, r.getMessageIds()); }); }
generateRequest(Transaction transaction, ContactId c, int maxMessages) throws DbException { if (transaction.isReadOnly()) throw new IllegalArgumentException(); T txn = unbox(transaction); if (!db.containsContact(txn, c)) throw new NoSuchContactException(); Collection<MessageId> ids = db.getMessagesToRequest(txn, c, maxMessages); if (ids.isEmpty()) return null; db.removeOfferedMessages(txn, c, ids); return new Request(ids); }
[*] target: assertNotNull(r)
[-] pred: org. junit. Assert. assertNotNull ( r )
************************************
************************************
[+] input: Exception { Transaction txn = new Transaction(null, true);  context.checking(new Expectations() {{ oneOf(settingsManager).getSettings(txn, SETTINGS_NAMESPACE); will(returnValue(pairedSettings)); }});  MailboxProperties properties = manager.getOwnMailboxProperties(txn); "<AssertPlaceHolder>"; assertEquals(onion, properties.getOnion()); assertEquals(token, properties.getAuthToken()); assertEquals(serverSupports, properties.getServerSupports()); assertTrue(properties.isOwner()); }
getOwnMailboxProperties(Transaction txn) throws DbException { Settings s = settingsManager.getSettings(txn, SETTINGS_NAMESPACE); String onion = s.get(SETTINGS_KEY_ONION); String token = s.get(SETTINGS_KEY_TOKEN); if (isNullOrEmpty(onion) || isNullOrEmpty(token)) return null; List<MailboxVersion> serverSupports = parseServerSupports(s); try { MailboxAuthToken tokenId = MailboxAuthToken.fromString(token); return new MailboxProperties(onion, tokenId, serverSupports); } catch (InvalidMailboxIdException e) { throw new DbException(e); } }
[*] target: assertNotNull(properties)
[-] pred: org. junit. Assert. assertNotNull ( properties )
************************************
************************************
[+] input: Exception { context.checking(new Expectations() {{ oneOf(clientHelper).getGroupMetadataAsDictionary(groupId); will(returnValue(dictionary)); }}); MessageId loadedId = messageTracker.loadStoredMessageId(groupId); "<AssertPlaceHolder>"; assertEquals(messageId, loadedId); }
loadStoredMessageId(GroupId g) throws DbException;  /** * Stores the message id for the respective group id. Exactly one message id * can be stored for any group id at any time, older values are overwritten. */ void storeMessageId(GroupId g, MessageId m) throws DbException;  /** * Marks a message as read or unread and updates the group count. * * @return True if the message was previously marked as read */ boolean setReadFlag(Transaction txn, GroupId g, MessageId m, boolean read) throws DbException;  /** * Resets the {@link GroupCount}
[*] target: assertNotNull(loadedId)
[-] pred: org. junit. Assert. assertNotNull ( loadedId )
************************************
************************************
[+] input: Exception { BdfDictionary query = BdfDictionary.of(new BdfEntry("q", "u")); Message message2 = getMessage(contactGroup.getId()); Collection<MessageId> results = asList(message.getId(), message2.getId()); long time1 = 1L, time2 = 2L; String groupName = getRandomString(MAX_GROUP_NAME_LENGTH); byte[] salt = getRandomBytes(GROUP_SALT_LENGTH); InviteMessage inviteMessage1 = new InviteMessage(message.getId(), contactGroup.getId(), privateGroup.getId(), time1, groupName, author, salt, null, getRandomBytes(5), NO_AUTO_DELETE_TIMER); InviteMessage inviteMessage2 = new InviteMessage(message2.getId(), contactGroup.getId(), privateGroup.getId(), time2, groupName, author, salt, null, getRandomBytes(5), NO_AUTO_DELETE_TIMER); PrivateGroup pg = new PrivateGroup(group, groupName, author, salt);  context.checking(new DbExpectations() {{ oneOf(messageParser).getInvitesAvailableToAnswerQuery(); will(returnValue(query)); oneOf(db).transactionWithResult(with(true), withDbCallable(txn)); oneOf(db).getContacts(txn); will(returnValue(singletonList(contact))); oneOf(contactGroupFactory).createContactGroup(CLIENT_ID, MAJOR_VERSION, contact); will(returnValue(contactGroup)); oneOf(clientHelper).getMessageIds(txn, contactGroup.getId(), query); will(returnValue(results)); // message 1 oneOf(messageParser).getInviteMessage(txn, message.getId()); will(returnValue(inviteMessage1)); oneOf(privateGroupFactory).createPrivateGroup(groupName, author, salt); will(returnValue(pg)); // message 2 oneOf(messageParser).getInviteMessage(txn, message2.getId()); will(returnValue(inviteMessage2)); oneOf(privateGroupFactory).createPrivateGroup(groupName, author, salt); will(returnValue(pg)); }});  Collection<GroupInvitationItem> items = groupInvitationManager.getInvitations(); "<AssertPlaceHolder>"; for (GroupInvitationItem i : items) { assertEquals(contact, i.getCreator()); assertEquals(author, i.getCreator().getAuthor()); assertEquals(privateGroup.getId(), i.getId()); assertEquals(groupName, i.getName()); } }
getInvitations() throws DbException { return db.transactionWithResult(true, this::getInvitations); }
[*] target: assertEquals(2, items.size())
[-] pred: org. junit. Assert. assertEquals ( 2, items. size ( ) )
************************************
************************************
[+] input: testGroupTasksByDate() { List<Task> tasks = new ArrayList<>(); ProjectStub projectStub = new ProjectStub(); ReminderSetting reminderSetting = new ReminderSetting(null, null, 1); Task t1 = TestHelpers.getTaskRepoModel(1L, "Michael_Zhou", "2020-03-03", null, "America/Los_Angeles", "t1", 0, projectStub, null, reminderSetting); Task t2 = TestHelpers.getTaskRepoModel(2L, "Michael_Zhou", "2020-03-04", null, "America/Los_Angeles", "t2", 0, projectStub, null, reminderSetting); Task t3 = TestHelpers.getTaskRepoModel(3L, "Michael_Zhou", "2020-03-05", null, "America/Los_Angeles", "t3", 0, projectStub, null, reminderSetting); Task t4 = TestHelpers.getTaskRepoModel(4L, "Michael_Zhou", "2020-03-06", null, "America/Los_Angeles", "t4", 0, projectStub, null, reminderSetting);  tasks.add(t1); tasks.add(t2); tasks.add(t3); tasks.add(t4);  Map<ZonedDateTime, List<Task>> map = ProjectItemsGrouper.groupTasksByDate(tasks, true, "America/Los_Angeles"); "<AssertPlaceHolder>"; for (Map.Entry<ZonedDateTime, List<Task>> entry : map.entrySet()) { List<Task> t = entry.getValue(); assertTrue(tasks.contains(t.get(0))); } }
groupTasksByDate(List<Task> tasks, boolean keepTaskWithNoDueDate, String timezone) { Map<ZonedDateTime, List<Task>> map = new HashMap<>(); for (Task task : tasks) { String dueDate = task.getDueDate(); String dueTime = task.getDueTime(); if (dueDate == null) { if (!keepTaskWithNoDueDate) { continue; } ZonedDateTime deadline = ZonedDateTimeHelper.getNow(task.getTimezone()); dueDate = deadline.format(ZonedDateTimeHelper.DATE_FORMATTER); dueTime = deadline.format(ZonedDateTimeHelper.TIME_FORMATTER); } ZonedDateTime zonedDateTime = ZonedDateTimeHelper .getDateInDifferentZone(dueDate, dueTime, task.getTimezone(), timezone); map.computeIfAbsent(zonedDateTime, x -> new ArrayList<>()).add(task); } return map; }
[*] target: assertEquals(4, map.size())
[-] pred: org. junit. Assert. assertEquals ( 4, map. size ( ) )
************************************
************************************
[+] input: compareEqual() { Tuple t1 = new Tuple("foo", 1d); Tuple t2 = new Tuple("foo", 1d);  assertEquals(0, t1.compareTo(t2)); assertEquals(0, t2.compareTo(t1)); assertTrue(t1.equals(t2)); // directly calling Tuple.equals() "<AssertPlaceHolder>"; // directly calling Tuple.equals() }
equals(Object obj) { if (obj == null) return false; if (obj == this) return true; if (!(obj instanceof Tuple)) return false;  Tuple other = (Tuple) obj; if (!Arrays.equals(element, other.element)) return false; return Objects.equals(score, other.score); }
[*] target: assertTrue(t2.equals(t1))
[-] pred: org. junit. Assert. assertTrue ( t2. equals ( t1 ) )
************************************
************************************
[+] input: compareNoMatch() { Tuple t1 = new Tuple("foo", 1d); Tuple t2 = new Tuple("bar", 2d);  assertEquals(-1, t1.compareTo(t2)); assertEquals(1, t2.compareTo(t1)); assertFalse(t1.equals(t2)); // directly calling Tuple.equals() "<AssertPlaceHolder>"; // directly calling Tuple.equals() }
equals(Object obj) { if (obj == null) return false; if (obj == this) return true; if (!(obj instanceof Tuple)) return false;  Tuple other = (Tuple) obj; if (!Arrays.equals(element, other.element)) return false; return Objects.equals(score, other.score); }
[*] target: assertFalse(t2.equals(t1))
[-] pred: org. junit. Assert. assertFalse ( t2. equals ( t1 ) )
************************************
************************************
[+] input: cacheGetOnNonExistingRowDoesntCrash() { ChronoDBCache cache = createCacheOfSize(1); String branch = ChronoDBConstants.MASTER_BRANCH_IDENTIFIER; CacheGetResult<Object> result = cache.get(branch, 1234, QualifiedKey.createInDefaultKeyspace("Fake")); "<AssertPlaceHolder>"; assertTrue(result.isMiss()); }
get(final String branch, final long timestamp, final QualifiedKey qualifiedKey) { checkNotNull(branch, "Precondition violation - argument 'branch' must not be NULL!"); checkArgument(timestamp >= 0, "Precondition violation - argument 'timestamp' must not be negative!"); checkNotNull(qualifiedKey, "Precondition violation - argument 'qualifiedKey' must not be NULL!"); this.lock.readLock().lock(); try { Map<QualifiedKey, MosaicRow> qKeyToRow = this.contents.get(branch); if (qKeyToRow == null) { this.statistics.registerMiss(); return CacheGetResult.miss(); // qKeyToRow = Maps.newConcurrentMap(); // this.contents.put(branch, qKeyToRow); } MosaicRow row = qKeyToRow.get(qualifiedKey); if (row == null) { this.statistics.registerMiss(); return CacheGetResult.miss(); } return row.get(timestamp); } finally { this.lock.readLock().unlock(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: canCalculateAdditiveDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Doe"); p2.setHobbies("Swimming", "Skiing", "Cinema", "Reading"); p2.setPets("Cat", "Dog", "Fish"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); indices.add(petsIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertTrue(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(hobbiesIndex, petsIndex), diff.getChangedIndices()); assertEquals(Sets.newHashSet("Cinema", "Reading"), diff.getAdditions(hobbiesIndex)); assertEquals(Sets.newHashSet("Cat", "Dog", "Fish"), diff.getAdditions(petsIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateSubtractiveDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing", "Cinema", "Reading"); p1.setPets("Cat", "Dog", "Fish"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Doe"); p2.setHobbies("Swimming", "Skiing"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); indices.add(petsIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertTrue(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(hobbiesIndex, petsIndex), diff.getChangedIndices()); assertEquals(Sets.newHashSet("Cinema", "Reading"), diff.getRemovals(hobbiesIndex)); assertEquals(Sets.newHashSet("Cat", "Dog", "Fish"), diff.getRemovals(petsIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateEntryAdditionDiff() { Person johnDoe = createJohnDoe(); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex favoriteColorIndex = new DummyIndex(PersonIndexer.favoriteColor(), "favoriteColor"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(favoriteColorIndex); indices.add(hobbiesIndex); indices.add(petsIndex);  // simulate the addition of John Doe IndexValueDiff diff = IndexingUtils.calculateDiff(indices, null, johnDoe); "<AssertPlaceHolder>"; assertTrue(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); assertTrue(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(firstNameIndex, lastNameIndex, hobbiesIndex), diff.getChangedIndices());  assertEquals(Sets.newHashSet("John"), diff.getAdditions(firstNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(firstNameIndex));  assertEquals(Sets.newHashSet("Doe"), diff.getAdditions(lastNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(lastNameIndex));  assertEquals(Sets.newHashSet("Swimming", "Skiing"), diff.getAdditions(hobbiesIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(hobbiesIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateEntryRemovalDiff() { Person johnDoe = createJohnDoe(); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex favoriteColorIndex = new DummyIndex(PersonIndexer.favoriteColor(), "favoriteColor"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); DummyIndex petsIndex = new DummyIndex(PersonIndexer.pets(), "pets"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(favoriteColorIndex); indices.add(hobbiesIndex); indices.add(petsIndex); // simulate the deletion of John Doe IndexValueDiff diff = IndexingUtils.calculateDiff(indices, johnDoe, null); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertTrue(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertTrue(diff.isSubtractive()); assertFalse(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Sets.newHashSet(firstNameIndex, lastNameIndex, hobbiesIndex), diff.getChangedIndices());  assertEquals(Collections.emptySet(), diff.getAdditions(firstNameIndex)); assertEquals(Sets.newHashSet("John"), diff.getRemovals(firstNameIndex));  assertEquals(Collections.emptySet(), diff.getAdditions(lastNameIndex)); assertEquals(Sets.newHashSet("Doe"), diff.getRemovals(lastNameIndex));  assertEquals(Collections.emptySet(), diff.getAdditions(hobbiesIndex)); assertEquals(Sets.newHashSet("Swimming", "Skiing"), diff.getRemovals(hobbiesIndex)); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCalculateMixedDiff() { Person p1 = new Person(); p1.setFirstName("John"); p1.setLastName("Doe"); p1.setHobbies("Swimming", "Skiing"); Person p2 = new Person(); p2.setFirstName("John"); p2.setLastName("Smith"); p2.setHobbies("Skiing", "Cinema"); Set<SecondaryIndex> indices = Sets.newHashSet(); DummyIndex firstNameIndex = new DummyIndex(PersonIndexer.firstName(), "firstName"); DummyIndex lastNameIndex = new DummyIndex(PersonIndexer.lastName(), "lastName"); DummyIndex hobbiesIndex = new DummyIndex(PersonIndexer.hobbies(), "hobbies"); indices.add(firstNameIndex); indices.add(lastNameIndex); indices.add(hobbiesIndex); IndexValueDiff diff = IndexingUtils.calculateDiff(indices, p1, p2); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); assertFalse(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertTrue(diff.isMixed()); assertFalse(diff.isEmpty()); assertEquals(Collections.emptySet(), diff.getAdditions(firstNameIndex)); assertEquals(Collections.emptySet(), diff.getRemovals(firstNameIndex)); assertFalse(diff.isIndexChanged(firstNameIndex)); assertEquals(Collections.singleton("Smith"), diff.getAdditions(lastNameIndex)); assertEquals(Collections.singleton("Doe"), diff.getRemovals(lastNameIndex)); assertTrue(diff.isIndexChanged(lastNameIndex)); assertEquals(Collections.singleton("Cinema"), diff.getAdditions(hobbiesIndex)); assertEquals(Collections.singleton("Swimming"), diff.getRemovals(hobbiesIndex)); assertTrue(diff.isIndexChanged(hobbiesIndex)); assertEquals(Sets.newHashSet(lastNameIndex, hobbiesIndex), diff.getChangedIndices()); assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); }
calculateDiff(final Set<SecondaryIndex> indices, final Object oldValue, final Object newValue) { checkNotNull(indices, "Precondition violation - argument 'indices' must not be NULL!"); MutableIndexValueDiff diff = new MutableIndexValueDiff(oldValue, newValue); if (indices.isEmpty() || oldValue == null && newValue == null) { // return the empty diff return diff; } // iterate over the known indices for (SecondaryIndex index : indices) { // prepare the sets of values for that index Set<Comparable<?>> oldValues = index.getIndexedValuesForObject(oldValue); Set<Comparable<?>> newValues = index.getIndexedValuesForObject(newValue); // calculate the set differences Set<Object> addedValues = Sets.newHashSet(); addedValues.addAll(newValues); addedValues.removeAll(oldValues); Set<Object> removedValues = Sets.newHashSet(); removedValues.addAll(oldValues); removedValues.removeAll(newValues); // update the diff for (Object addedValue : addedValues) { diff.add(index, addedValue); } diff.removeMultipleValues(index, removedValues); } return diff; }
[*] target: assertNotNull(diff)
[-] pred: org. junit. Assert. assertNotNull ( diff )
************************************
************************************
[+] input: canCreateEmptyDiff() { MutableIndexValueDiff diff = new MutableIndexValueDiff(null, null); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmptyAddition() { MutableIndexValueDiff diff = new MutableIndexValueDiff(null, new Object()); assertNotNull(diff); "<AssertPlaceHolder>"; assertTrue(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmptyRemoval() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), null); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertTrue(diff.isEntryRemoval()); assertFalse(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canCreateEmtpyUpdate() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), new Object()); assertNotNull(diff); "<AssertPlaceHolder>"; assertFalse(diff.isEntryAddition()); assertFalse(diff.isEntryRemoval()); assertTrue(diff.isEntryUpdate()); }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertTrue(diff.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( diff. isEmpty() )
************************************
************************************
[+] input: canDetectThatDiffisAdditive() { MutableIndexValueDiff diff = new MutableIndexValueDiff(new Object(), new Object()); DummyIndex testIndex = new DummyIndex(new FirstNameIndexer(), "test"); diff.add(testIndex, "Hello World"); diff.add(testIndex, "Foo Bar"); assertTrue(diff.isAdditive()); assertFalse(diff.isSubtractive()); assertFalse(diff.isMixed()); "<AssertPlaceHolder>"; }
isEmpty() { // both change sets are either NULL (never touched) or empty (touched and then cleared) if ((this.indexToAdditions == null || this.indexToAdditions.isEmpty()) && (this.indexToRemovals == null || this.indexToRemovals.isEmpty())) { return true; } else { return false; } }
[*] target: assertFalse(diff.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( diff. isEmpty() )
************************************
************************************
[+] input: createPointPeriodWorks() { Period point = Period.createPoint(100); assertNotNull(point); assertEquals(100, point.getLowerBound()); assertEquals(101, point.getUpperBound()); "<AssertPlaceHolder>"; }
isEmpty() { return this.getLowerBound() >= this.getUpperBound(); }
[*] target: assertFalse(point.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( point. isEmpty() )
************************************
************************************
[+] input: createEmptyPeriodWorks() { Period empty = Period.empty(); assertNotNull(empty); "<AssertPlaceHolder>"; }
isEmpty() { return this.getLowerBound() >= this.getUpperBound(); }
[*] target: assertTrue(empty.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( empty. isEmpty() )
************************************
************************************
[+] input: emptyPeriodIsSingleton() { Period empty1 = Period.empty(); Period empty2 = Period.empty(); "<AssertPlaceHolder>"; assertNotNull(empty2); assertTrue(empty1 == empty2); }
empty() { return PeriodImpl.empty(); }
[*] target: assertNotNull(empty1)
[-] pred: org. junit. Assert. assertNotNull ( empty1 )
************************************
************************************
[+] input: eternalPeriodIsSingleton() { Period eternal1 = Period.eternal(); Period eternal2 = Period.eternal(); "<AssertPlaceHolder>"; assertNotNull(eternal2); assertTrue(eternal1 == eternal2); }
eternal() { return PeriodImpl.eternal(); }
[*] target: assertNotNull(eternal1)
[-] pred: org. junit. Assert. assertNotNull ( eternal1 )
************************************
************************************
[+] input: canCreateInMemoryDatabaseEasily() { // without additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().inMemoryGraph().build()) { assertNotNull(graph); } // with additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().inMemoryGraph(config -> config.assumeCachedValuesAreImmutable(true)).build()) { "<AssertPlaceHolder>"; } }
create();
[*] target: assertNotNull(graph)
[-] pred: org. junit. Assert. assertNotNull ( graph )
************************************
************************************
[+] input: Exception { File directory = Files.createTempDirectory("chronodb-test").toFile(); try { // without additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().exodusGraph(directory.getAbsolutePath()).build()) { assertNotNull(graph); } // with additional configuration try (ChronoGraph graph = ChronoGraph.FACTORY.create().exodusGraph(directory.getAbsolutePath(), config -> config.assumeCachedValuesAreImmutable(true)).build()) { "<AssertPlaceHolder>"; } } finally { FileUtils.deleteDirectory(directory); } }
create();
[*] target: assertNotNull(graph)
[-] pred: org. junit. Assert. assertNotNull ( graph )
************************************
************************************
[+] input: canGeneratePerson() { Person person = PersonGenerator.generateRandomPerson(); "<AssertPlaceHolder>"; assertNotNull(person.getFirstName()); assertNotNull(person.getLastName()); assertTrue(person.getFirstName().length() > 0); assertTrue(person.getLastName().length() > 0); }
generateRandomPerson() { Person person = new Person(); person.setFirstName(TestUtils.getRandomEntryOf(FIRST_NAMES)); person.setLastName(TestUtils.getRandomEntryOf(LAST_NAMES)); person.setFavoriteColor(TestUtils.getRandomEntryOf(COLORS)); int numberOfHobbies = TestUtils.randomBetween(0, 3); int numberOfPets = TestUtils.randomBetween(0, 2); person.getHobbies().addAll(TestUtils.getRandomUniqueEntriesOf(HOBBIES, numberOfHobbies)); person.getPets().addAll(TestUtils.getRandomUniqueEntriesOf(PETS, numberOfPets)); return person; }
[*] target: assertNotNull(person)
[-] pred: org. junit. Assert. assertNotNull ( person )
************************************
************************************
[+] input: equals_SameColors_Symmetric() { int first = Color.pack(1, 2, 3, 4); int second = Color.pack(1, 2, 3, 4); "<AssertPlaceHolder>"; assertEquals(second, first); }
pack(int red, int green, int blue, int alpha) { checkComponent(red); checkComponent(green); checkComponent(blue); checkComponent(alpha); return (alpha << ALPHA_OFFSET) | (red << RED_OFFSET) | (green << GREEN_OFFSET) | (blue << BLUE_OFFSET); }
[*] target: assertEquals(first, second)
[-] pred: org. junit. Assert. assertEquals ( first, second )
************************************
************************************
[+] input: equals_SameColors_Transitive() { int first = Color.pack(1, 2, 3, 4); int second = Color.pack(1, 2, 3, 4); int third = Color.pack(1, 2, 3, 4); "<AssertPlaceHolder>"; assertEquals(second, third); assertEquals(first, third); }
pack(int red, int green, int blue, int alpha) { checkComponent(red); checkComponent(green); checkComponent(blue); checkComponent(alpha); return (alpha << ALPHA_OFFSET) | (red << RED_OFFSET) | (green << GREEN_OFFSET) | (blue << BLUE_OFFSET); }
[*] target: assertEquals(first, second)
[-] pred: org. junit. Assert. assertEquals ( first, second )
************************************
************************************
[+] input: construct_EmptyArea_ConstructedCorrectly() { Area rect = new Area(0, 0, 0, 0); assertFalse(rect.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, rect.size())
[-] pred: org. junit. Assert. assertEquals ( 0, rect. size ( ) )
************************************
************************************
[+] input: construct_EmptyWidthArea_ConstructedCorrectly() { Area rect = new Area(0, 0, 0, 10); assertFalse(rect.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, rect.size())
[-] pred: org. junit. Assert. assertEquals ( 0, rect. size ( ) )
************************************
************************************
[+] input: construct_EmptyHeightArea_ConstructedCorrectly() { Area rect = new Area(0, 0, 10, 0); assertFalse(rect.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, rect.size())
[-] pred: org. junit. Assert. assertEquals ( 0, rect. size ( ) )
************************************
************************************
[+] input: buildArea_NoPoints_Empty() { Area.Builder builder = new Area.Builder(); Area area = builder.build(); assertFalse(area.iterator().hasNext()); "<AssertPlaceHolder>"; }
size() { return SIZE; }
[*] target: assertEquals(0, area.size())
[-] pred: org. junit. Assert. assertEquals ( 0, area. size() )
************************************
************************************
[+] input: list_SomeMatchAllFiltersClient_MatchingFound() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "textures", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; assertTrue(resources.contains(ResourceLocation.parse("textures/hello.png"))); assertTrue(resources.contains(ResourceLocation.parse("textures/block/sea/rock/gravel.png"))); }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(2, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 2, resources. size ( ) )
************************************
************************************
[+] input: list_EmptyPathStart_NoExceptionIfOriginalAccepts() { PackResourcesAdapter adapter = makeAdapterWithResources();  Collection<ResourceLocation> resources = adapter.list(PackType.CLIENT_RESOURCES, "minecraft", "", (file) -> file.endsWith(".png"));  "<AssertPlaceHolder>"; assertTrue(resources.contains(ResourceLocation.parse("textures/hello.png"))); assertTrue(resources.contains(ResourceLocation.parse("textures/block/sea/rock/gravel.png"))); }
list(PackType resourceType, String namespace, String pathStart, Predicate<String> fileFilter) { requireNonNull(resourceType, "Resource type cannot be null"); requireNonNull(namespace, "Namespace cannot be null"); requireNonNull(pathStart, "Path start cannot be null"); requireNonNull(fileFilter, "File filter cannot be null");  if (RootResourcesAdapter.ROOT_NAMESPACE.equals(namespace)) { return ROOT_RESOURCES.list(resourceType, namespace, pathStart, fileFilter); }  Set<ResourceLocation> resources = new HashSet<>();  PackResources.ResourceOutput output = (location, resourceSupplier) -> { if (fileFilter.test(location.getPath())) { resources.add(location); } };  ORIGINAL.listResources(resourceType, namespace, pathStart, output);  return resources; }
[*] target: assertEquals(2, resources.size())
[-] pred: org. junit. Assert. assertEquals ( 2, resources. size ( ) )
************************************
************************************
[+] input: load_ResultsBasedOnSearch_MetadataAppliesToAllFoundTextures() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size() )
************************************
************************************
[+] input: load_SearchRetrievesPack_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorNotPresent_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorBelow_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ), Set.of( "textures/bat_efgh.png" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorInSame_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta", "textures/bat_efgh.png" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackFloorAbove_PackNotFound() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_efgh.png" ), Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  assertFalse( resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_efgh.png") ).isPresent() );  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_SearchRetrievesPackSameAsFloor_CorrectResourcesFoundInPacks() { OrderedResourceRepository repository = makeMockRepository( Set.of( "textures/bat_abcd.png", "textures/bat_abcd.png.moremcmeta", "textures/creeper_abcd.png", "zombie.png", "zombie.png.moremcmeta", "optifine/ghast_abcd.png", "optifine/ghast_abcd.png.moremcmeta" ) );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { Set<? extends ResourceLocation> locations = resourceRepository.list( (fileName) -> fileName.endsWith("_abcd.png") );  Optional<ResourceRepository.Pack> pack = resourceRepository.highestPackWith( ResourceLocation.parse("textures/bat_abcd.png"), ResourceLocation.parse("textures/bat_abcd.png") ); assertTrue(pack.isPresent()); assertTrue(pack.get().resource(ResourceLocation.parse("zombie.png")).isPresent()); assertFalse(pack.get().resource(ResourceLocation.parse("zombie2.png")).isPresent()); assertFalse(resourceRepository.highestPackWith(ResourceLocation.parse("dummy")).isPresent());  return locations.stream().collect(Collectors.toMap( Function.identity(), (location) -> new MockMetadataView(List.of(location.getPath())) )); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat_abcd.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/creeper_abcd.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size ( ) )
************************************
************************************
[+] input: load_InvalidMetadataDuringRead_LoadsValidTextures() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat.png", "textures/bat.png.moremcmeta", "textures/creeper.png", "textures/zombie.png", "textures/creeper.png.moremcmeta", "textures/zombie.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { if (metadataLocation.getPath().contains("creeper")) { throw new InvalidMetadataException("Dummy exception"); }  return MOCK_READER.parse(metadataLocation, metadataStream, resourceRepository); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures"); "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size() )
************************************
************************************
[+] input: load_SilencedInvalidMetadataDuringRead_LoadsValidTextures() { OrderedResourceRepository repository = makeMockRepository(Set.of( "textures/bat.png", "textures/bat.png.moremcmeta", "textures/creeper.png", "textures/zombie.png", "textures/creeper.png.moremcmeta", "textures/zombie.png.moremcmeta" ));  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, ImmutableMap.of(".moremcmeta", (metadataLocation, metadataStream, resourceRepository) -> { if (metadataLocation.getPath().contains("creeper")) { throw new InvalidMetadataException("Dummy exception", new Exception(), true); }  return MOCK_READER.parse(metadataLocation, metadataStream, resourceRepository); }), LOGGER );  Map<ResourceLocation, Integer> locations = loader.load(repository, "textures"); "<AssertPlaceHolder>"; assertTrue(locations.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(locations.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, locations.size())
[-] pred: org. junit. Assert. assertEquals ( 2, locations. size() )
************************************
************************************
[+] input: load_DiffFormatMetadataInPackWithTexture_Conflict() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/zombie.png.other"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/creeper.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: load_DiffFormatMetadataInPackAboveTexture_Conflict() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/creeper.png.other"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: load_SameFormatMetadataInPackAboveTexture_CombinerExceptionExcluded() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/creeper.png2.moremcmeta"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/zombie.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: load_SameFormatMetadataInPackWithTexture_CombinerExceptionExcluded() { OrderedResourceRepository repository = makeMockRepository( Set.of("textures/bat.png", "textures/bat.png.moremcmeta", "textures/zombie.png", "textures/zombie.png.moremcmeta", "textures/zombie.png2.moremcmeta"), Set.of("textures/creeper.png", "textures/creeper.png.moremcmeta") );  TextureLoader<Integer> loader = new TextureLoader<>( (texStream, metadata) -> 1, MOCK_READERS, LOGGER );  Map<ResourceLocation, Integer> results = loader.load(repository, "textures");  "<AssertPlaceHolder>"; assertTrue(results.containsKey(ResourceLocation.parse("textures/bat.png"))); assertTrue(results.containsKey(ResourceLocation.parse("textures/creeper.png"))); }
size() { return METADATA.size(); }
[*] target: assertEquals(2, results.size())
[-] pred: org. junit. Assert. assertEquals ( 2, results. size() )
************************************
************************************
[+] input: basic() { Exchange exchange = new Exchange(); assertEquals(0, exchange.size()); assertFalse(exchange.exists("non-key")); assertFalse(exchange.is("non-key")); assertNull(exchange.get("non-key", String.class)); assertNull(exchange.get("non-key", ExchangeTest.class)); // we can clear on an empty Exchange exchange.clear();  exchange.set("k1", new Date(12345678)); assertTrue(exchange.exists("k1")); assertFalse(exchange.exists("k2")); assertEquals(1, exchange.size()); assertNotNull(exchange.get("k1", Date.class));  try { exchange.get("k1", String.class); fail(); } catch (ClassCastException expected) {  }  // overwrite in place exchange.set("k1", "foo"); assertEquals(1, exchange.size()); assertEquals("foo", exchange.get("k1", String.class)); try { exchange.is("k1"); fail(); } catch (ClassCastException expected) {  }  // handy boolean method exchange.set("k2", true); assertTrue(exchange.is("k2")); assertFalse(exchange.is("k3"));  exchange.clear(); "<AssertPlaceHolder>"; }
size() { return holder.size(); }
[*] target: assertEquals(0, exchange.size())
[-] pred: org. junit. Assert. assertEquals ( 0, exchange. size ( ) )
************************************
************************************
[+] input: neverNPEafterExport() { DomainArtifacts instance = DomainArtifacts.getInstance(); instance.export();  "<AssertPlaceHolder>"; assertNotNull(instance.getSteps()); assertNotNull(instance.getDomains()); assertNotNull(instance.getExtensions()); }
export() { // domains this.domains = new ArrayList<>(InternalIndexer.domainDefMap.size()); domains.addAll(InternalIndexer.domainDefMap.values().stream().map(domainDef -> new Domain(domainDef.getCode(), domainDef.getName())).collect(Collectors.toList()));  // steps this.steps = new HashMap<>(); for (Map.Entry<String, Map<String, StepDef>> entry : InternalIndexer.domainStepDefMap.entrySet()) { final String activity = entry.getKey(); this.steps.put(activity, new ArrayList<>()); for (StepDef stepDef : entry.getValue().values()) { this.steps.get(activity).add(new Step(activity, stepDef.getCode(), stepDef.getName(), stepDef.getTags())); } }  // extensions this.extensions = new ArrayList<>(); // parse indexer pattern extensions for (Map.Entry<Class<? extends IDomainExtension>, List<PatternDef>> entry : InternalIndexer.sortedPatternMap.entrySet()) { final Extension extension = new Extension(entry.getKey()); for (PatternDef patternDef : entry.getValue()) { extension.getPatterns().add(new Pattern(patternDef.getCode(), patternDef.getName())); } for (PartnerDef partnerDef : InternalIndexer.partnerDefMap.values()) { if (partnerDef.getExtension(extension.ext) != null) { // 该前台实现了该扩展点 extension.getPartners().add(new Partner(partnerDef.getCode(), partnerDef.getName())); } }  this.extensions.add(extension); } // parse indexer partner extensions and merge with pattern extensions for (PartnerDef partnerDef : InternalIndexer.partnerDefMap.values()) { for (Class<? extends IDomainExtension> ext : partnerDef.getExtensionDefMap().keySet()) { Extension extensionsOfPattern = null; for (Extension extension : this.extensions) { if (extension.ext == ext) { extensionsOfPattern = extension; break; } }  if (extensionsOfPattern == null) { // this extension is implemented only by Partner final Extension extension = new Extension(ext); extension.getPartners().add(new Partner(partnerDef.getCode(), partnerDef.getName())); this.extensions.add(extension); } else { // this extension is implemented in both Partner and Pattern // do the merge final Partner partner = new Partner(partnerDef.getCode(), partnerDef.getName()); if (!extensionsOfPattern.getPartners().contains(partner)) { extensionsOfPattern.getPartners().add(partner); } } } } }
[*] target: assertNotNull(instance)
[-] pred: org. junit. Assert. assertNotNull ( instance )
************************************
************************************
[+] input: testChoose() { Clorus p = new Clorus(2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Plip()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  assertEquals(expected, actual);  p = new Clorus(2); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Plip()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.ATTACK, Direction.TOP);  assertEquals(expected, actual);  p = new Clorus(1); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.REPLICATE, Direction.RIGHT);  assertEquals(expected, actual);  p = new Clorus(0.5); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.MOVE, Direction.RIGHT);  "<AssertPlaceHolder>"; }
chooseAction(Map<Direction, Occupant> neighbors) { List<Direction> empties = getNeighborsOfType(neighbors, "empty"); List<Direction> plip = getNeighborsOfType(neighbors, "plip");  if (empties.size() == 0) { return new Action(Action.ActionType.STAY); } else if (!plip.isEmpty()) { Direction moveDir = HugLifeUtils.randomEntry(plip); return new Action(Action.ActionType.ATTACK, moveDir); } else if (energy >= 1) { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.REPLICATE, moveDir); } else { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.MOVE, moveDir); } }
[*] target: assertEquals(expected, actual)
[-] pred: org. junit. Assert. assertEquals ( expected, actual )
************************************
************************************
[+] input: testChoose() { Plip p = new Plip(1.2); HashMap<Direction, Occupant> surrounded = new HashMap<Direction, Occupant>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Impassible());  //You can create new empties with new Empty(); //Despite what the spec says, you cannot test for Cloruses nearby yet. //Sorry!  Action actual = p.chooseAction(surrounded); Action expected = new Action(Action.ActionType.STAY);  assertEquals(expected, actual);  p = new Plip(1.2); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Impassible()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); expected = new Action(Action.ActionType.REPLICATE, Direction.RIGHT);  assertEquals(expected, actual);  p = new Plip(0.8); surrounded = new HashMap<>(); surrounded.put(Direction.TOP, new Clorus()); surrounded.put(Direction.BOTTOM, new Impassible()); surrounded.put(Direction.LEFT, new Impassible()); surrounded.put(Direction.RIGHT, new Empty()); actual = p.chooseAction(surrounded); Action expected1 = new Action(Action.ActionType.REPLICATE, Direction.RIGHT); Action expected2 = new Action(Action.ActionType.STAY); boolean expectedB = expected1.equals(actual) || expected2.equals(actual); "<AssertPlaceHolder>";  }
chooseAction(Map<Direction, Occupant> neighbors) { List<Direction> empties = getNeighborsOfType(neighbors, "empty"); List<Direction> clorus = getNeighborsOfType(neighbors, "clorus");  if (empties.size() == 0) { return new Action(Action.ActionType.STAY); } else if (energy > 1) { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.REPLICATE, moveDir); } else if (!clorus.isEmpty() && HugLifeUtils.random() >= 0.5) { Direction moveDir = HugLifeUtils.randomEntry(empties); return new Action(Action.ActionType.MOVE, moveDir); } else { return new Action(Action.ActionType.STAY); } }
[*] target: assertTrue(expectedB)
[-] pred: org. junit. Assert. assertTrue ( expectedB )
************************************
************************************
[+] input: IOException {  final String script = ResourceUtil.getResourceFileAsString("module/transform/javascript/script.js");  final TransformConfig config = new TransformConfig(); config.setName("js1"); config.setModule("javascript"); config.setInputs(Arrays.asList("rowInput"));  final JsonArray mappings = new JsonArray(); final JsonObject mappingStateless1 = new JsonObject(); mappingStateless1.addProperty("function", "myFunc1"); mappingStateless1.addProperty("outputType", "float32"); mappingStateless1.addProperty("outputField", "outputFloatField"); mappings.add(mappingStateless1);  final JsonObject mappingStateless2 = new JsonObject(); mappingStateless2.addProperty("function", "myFunc2"); mappingStateless2.addProperty("outputType", "string"); mappingStateless2.addProperty("outputField", "outputStringField"); mappings.add(mappingStateless2);  final JsonObject parameters = new JsonObject(); parameters.addProperty("script", script); parameters.add("mappings", mappings);  final JsonArray groupFields = new JsonArray(); groupFields.add("user"); parameters.add("groupFields", groupFields); config.setParameters(parameters);  final List<Entity> entities = createEntities(); final Schema schema = createRows().get(0).getSchema();  final PCollection<Entity> inputEntities1 = pipeline .apply("CreateDummy1", Create.of(entities)) .apply("WithTimestamp", WithTimestamps.of((Entity r) -> Instant.ofEpochMilli(Timestamps.toMicros(r.getPropertiesOrThrow("timestamp").getTimestampValue())))); final FCollection<Entity> fCollection1 = FCollection.of("rowInput", inputEntities1, DataType.ENTITY, schema);  final Map<String, FCollection<?>> outputs1 = JavaScriptTransform.transform(Arrays.asList(fCollection1), config); final FCollection<Entity> outputJS1 = (FCollection<Entity>) outputs1.get("js1");   final PCollection<Entity> outputPJS1 = outputJS1.getCollection();  PAssert.that(outputPJS1).satisfies(results -> { final List<Entity> resultsList = Lists.newArrayList(results); resultsList.sort(Comparator.comparing(r -> r.getPropertiesOrThrow("timestamp").getTimestampValue().getSeconds()));  Assert."<AssertPlaceHolder>";  Entity row1 = resultsList.get(0); Assert.assertEquals(10D, row1.getPropertiesOrThrow("outputFloatField").getDoubleValue(), DELTA); Assert.assertEquals("Hellostring1", row1.getPropertiesOrThrow("outputStringField").getStringValue());  Entity row2 = resultsList.get(1); Assert.assertEquals(20D, row2.getPropertiesOrThrow("outputFloatField").getDoubleValue(), DELTA); Assert.assertEquals("Hellostring2", row2.getPropertiesOrThrow("outputStringField").getStringValue());  Entity row3 = resultsList.get(2); Assert.assertEquals(30D, row3.getPropertiesOrThrow("outputFloatField").getDoubleValue(), DELTA); Assert.assertEquals("Hellostring3", row3.getPropertiesOrThrow("outputStringField").getStringValue());  return null; });  pipeline.run(); }
transform(List<FCollection<?>> inputs, TransformConfig config) {  final JavaScriptTransformParameters parameters = new Gson().fromJson(config.getParameters(), JavaScriptTransformParameters.class); validateParameters(parameters); setDefaultParameters(parameters);  final Map<String, FCollection<?>> results = new HashMap<>(); for(final FCollection<?> input : inputs) { final String name = config.getName() + (config.getInputs().size() == 1 ? "" : "." + input.getName()); final String nameError = name + OUTPUT_SUFFIX_FAILURES; switch (input.getDataType()) { case AVRO: { final FCollection<GenericRecord> inputCollection = (FCollection<GenericRecord>) input; final Schema outputSchema = createOutputAvroSchema(input.getAvroSchema(), parameters.getMappings()); final Transform<GenericRecord,String,Schema> transform = new Transform<>( parameters, outputSchema.toString(), AvroSchemaUtil::convertSchema, RecordToMapConverter::convert, AvroSchemaUtil::getAsString, (Schema s, GenericRecord r, List<Mapping> mappings, Map<String, Object> values) -> { final GenericRecordBuilder builder = AvroSchemaUtil.copy(r, s); for(var mapping : mappings) { if(!values.containsKey(mapping.getOutputField())) { builder.set(mapping.getOutputField(), null); continue; } switch (mapping.getOutputType()) { case bool: case string: case int32: case int64: case float32: case float64: { builder.set(mapping.getOutputField(), values.get(mapping.getOutputField())); break; } case bytes: { final byte[] bytes = (byte[])values.get(mapping.getOutputField()); builder.set(mapping.getOutputField(), ByteBuffer.wrap(bytes)); break; } case time: { builder.set(mapping.getOutputField(), Long.valueOf(((LocalTime)values.get(mapping.getOutputField())).toNanoOfDay()/1000_000).intValue()); break; } case date: { builder.set(mapping.getOutputField(), Long.valueOf(((LocalDate)values.get(mapping.getOutputField())).toEpochDay()).intValue()); break; } case timestamp: { final Instant instant = (Instant)values.get(mapping.getOutputField()); builder.set(mapping.getOutputField(), instant.getEpochSecond() * 1000_1000 + instant.getNano() / 1000); break; } } } return builder.build(); }); final PCollectionTuple tuple = inputCollection.getCollection().apply(name, transform); final PCollection<GenericRecord> output = tuple.get(transform.tagMain).setCoder(AvroCoder.of(outputSchema)); final PCollection<GenericRecord> error  = tuple.get(transform.tagError).setCoder(AvroCoder.of(input.getAvroSchema())); results.put(name, FCollection.of(name, output, com.mercari.solution.module.DataType.AVRO, outputSchema)); results.put(nameError, FCollection.of(nameError, error, com.mercari.solution.module.DataType.AVRO, input.getAvroSchema())); break; } case ROW: { final FCollection<Row> inputCollection = (FCollection<Row>) input; final org.apache.beam.sdk.schemas.Schema outputSchema = createOutputRowSchema(input.getSchema(), parameters.getMappings()); final Transform<Row,org.apache.beam.sdk.schemas.Schema,org.apache.beam.sdk.schemas.Schema> transform = new Transform<>( parameters, outputSchema, s -> s, RowToMapConverter::convert, RowSchemaUtil::getAsString, (org.apache.beam.sdk.schemas.Schema s, Row r, List<Mapping> mappings, Map<String, Object> values) -> { var builder = RowSchemaUtil.toBuilder(s, r); for(var mapping : mappings) { if(!values.containsKey(mapping.getOutputField())) { builder.withFieldValue(mapping.getOutputField(), null); continue; } switch (mapping.getOutputType()) { case bool: case string: case bytes: case int32: case int64: case float32: case float64: case time: case date: { builder.withFieldValue(mapping.getOutputField(), values.get(mapping.getOutputField())); break; } case timestamp: { final Instant instant = (Instant)values.get(mapping.getOutputField()); builder.withFieldValue(mapping.getOutputField(), DateTimeUtil.toJodaInstant(instant)); break; } } } return builder.build(); }); final PCollectionTuple tuple = inputCollection.getCollection().apply(name, transform); final PCollection<Row> output = tuple.get(transform.tagMain).setCoder(RowCoder.of(outputSchema)); final PCollection<Row> error  = tuple.get(transform.tagError).setCoder(RowCoder.of(input.getSchema())); results.put(name, FCollection.of(name, output, com.mercari.solution.module.DataType.ROW, outputSchema)); results.put(nameError, FCollection.of(nameError, error, com.mercari.solution.module.DataType.ROW, input.getSchema())); break; } case STRUCT: { final FCollection<Struct> inputCollection = (FCollection<Struct>) input; final Type outputType = createOutputStructType(input.getSpannerType(), parameters.getMappings()); final Transform<Struct,Type,Type> transform = new Transform<>( parameters, outputType, s -> s, StructToMapConverter::convert, StructSchemaUtil::getAsString, (Type s, Struct r, List<Mapping> mappings, Map<String, Object> values) -> { var builder = StructSchemaUtil.toBuilder(s, r); for(var mapping : mappings) { final Object value = values.get(mapping.getOutputField()); switch (mapping.getOutputType()) { case bool: builder.set(mapping.getOutputField()).to((Boolean)value); break; case string: builder.set(mapping.getOutputField()).to((String)value); break; case bytes: { final byte[] bytes = (byte[])value; if(bytes == null) { builder.set(mapping.getOutputField()).to((ByteArray)null); } else { builder.set(mapping.getOutputField()).to(ByteArray.copyFrom(bytes)); } break; } case int32: builder.set(mapping.getOutputField()).to((Integer)value); break; case int64: builder.set(mapping.getOutputField()).to((Long)value); break; case float32: builder.set(mapping.getOutputField()).to((Float)value); break; case float64: builder.set(mapping.getOutputField()).to((Double)value); break; case time: { final LocalTime localTime = (LocalTime) value; if(localTime == null) { builder.set(mapping.getOutputField()).to((String) null); } else { builder.set(mapping.getOutputField()).to(localTime.toString()); } break; } case date: { final LocalDate localDate = (LocalDate) value; if(localDate == null) { builder.set(mapping.getOutputField()).to((Date)null); } else { builder.set(mapping.getOutputField()).to(Date .fromYearMonthDay(localDate.getYear(), localDate.getMonthValue(), localDate.getDayOfMonth())); } break; } case timestamp: { final Instant instant = (Instant)values.get(mapping.getOutputField()); if(instant == null) { builder.set(mapping.getOutputField()).to((Timestamp)null); } else { builder.set(mapping.getOutputField()).to(Timestamp .ofTimeSecondsAndNanos(instant.getEpochSecond(), instant.getNano())); } break; } } } return builder.build(); }); final PCollectionTuple tuple = inputCollection.getCollection().apply(name, transform); final PCollection<Struct> output = tuple.get(transform.tagMain).setCoder(inputCollection.getCollection().getCoder()); final PCollection<Struct> error  = tuple.get(transform.tagError).setCoder(inputCollection.getCollection().getCoder()); results.put(name, FCollection.of(name, output, com.mercari.solution.module.DataType.STRUCT, outputType)); results.put(nameError, FCollection.of(nameError, error, com.mercari.solution.module.DataType.STRUCT, input.getSpannerType())); break; } case ENTITY: { final FCollection<Entity> inputCollection = (FCollection<Entity>) input; final org.apache.beam.sdk.schemas.Schema outputSchema = createOutputRowSchema(input.getSchema(), parameters.getMappings()); final Transform<Entity,org.apache.beam.sdk.schemas.Schema,org.apache.beam.sdk.schemas.Schema> transform = new Transform<>( parameters, outputSchema, s -> s, EntityToMapConverter::convert, EntitySchemaUtil::getAsString, (org.apache.beam.sdk.schemas.Schema s, Entity r, List<Mapping> mappings, Map<String, Object> values) -> { var builder = EntitySchemaUtil.toBuilder(s, r); for(var mapping : mappings) { final Object value = values.getOrDefault(mapping.getOutputField(), null); if(value == null) { builder.putProperties(mapping.getOutputField(), Value.newBuilder().setNullValue(NullValue.NULL_VALUE).build()); continue; } switch (mapping.getOutputType()) { case bool: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setBooleanValue((Boolean) value).build()); break; case string: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setStringValue((String) value).build()); break; case bytes: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setBlobValue(ByteString.copyFrom((byte[]) value)).build()); break; case int32: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setIntegerValue((Integer) value).build()); break; case int64: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setIntegerValue((Long) value).build()); break; case float32: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setDoubleValue((Float) value).build()); break; case float64: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setDoubleValue((Double) value).build()); break; case time: case date: builder.putProperties(mapping.getOutputField(), Value.newBuilder().setStringValue(value.toString()).build()); break; case timestamp: { final Instant instant = (Instant) value; builder.putProperties(mapping.getOutputField(), Value.newBuilder() .setTimestampValue(com.google.protobuf.Timestamp.newBuilder() .setSeconds(instant.getEpochSecond()) .setNanos(instant.getNano()) .build()) .build()); break; } } } return builder.build(); }); final PCollectionTuple tuple = inputCollection.getCollection().apply(name, transform); final PCollection<Entity> output = tuple.get(transform.tagMain).setCoder(inputCollection.getCollection().getCoder()); final PCollection<Entity> error  = tuple.get(transform.tagError).setCoder(inputCollection.getCollection().getCoder()); results.put(name, FCollection.of(name, output, com.mercari.solution.module.DataType.ENTITY, outputSchema)); results.put(nameError, FCollection.of(nameError, error, com.mercari.solution.module.DataType.ENTITY, input.getSchema())); break; } default: { throw new IllegalStateException(""); } } }  return results; }
[*] target: assertEquals(3, resultsList.size())
[-] pred: org. junit. Assert. assertEquals ( 3, resultsList. size ( ) )
************************************
************************************
[+] input: Exception { final Future<Socket> f = executor.submit(new Callable<Socket>() { public Socket call() throws Exception { return serverSocket.accept(); } }); assertBlocks(f); connect().getOutputStream().write(123); final Socket socket = f.get(); "<AssertPlaceHolder>"; assertEquals(123, socket.getInputStream().read()); }
connect() throws Exception { synchronized (lock) { final MockSocketConnection c = new MockSocketConnection(); connection = c.getSocketA(); lock.notifyAll(); while (connection != null) { lock.wait(); } return c.getSocketB(); } }
[*] target: assertNotNull(socket)
[-] pred: org. junit. Assert. assertNotNull ( socket )
************************************
************************************
[+] input: IOException { locator.add(createFile("org/jacoco/example/Test.java", "AAA"));  "<AssertPlaceHolder>"; final Reader source = locator.getSourceFile("org/jacoco/example", "Test.java"); assertContent("AAA", source); }
isEmpty() { return empty; }
[*] target: assertFalse(locator.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( locator. isEmpty() )
************************************
************************************
[+] input: IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ZipOutputStream zipout = new ZipOutputStream(buffer); zipout.putNextEntry(new ZipEntry("META-INF/MANIFEST.MF")); zipout.putNextEntry(new ZipEntry("META-INF/ALIAS.SF")); zipout.finish(); ByteArrayOutputStream out = new ByteArrayOutputStream();  int count = instrumenter.instrumentAll( new ByteArrayInputStream(buffer.toByteArray()), out, "Test");  "<AssertPlaceHolder>"; ZipInputStream zipin = new ZipInputStream(new ByteArrayInputStream( out.toByteArray())); assertEquals("META-INF/MANIFEST.MF", zipin.getNextEntry().getName()); assertNull(zipin.getNextEntry()); }
instrumentAll(final InputStream input, final OutputStream output, final String name) throws IOException { final ContentTypeDetector detector; try { detector = new ContentTypeDetector(input); } catch (final IOException e) { throw instrumentError(name, e); } switch (detector.getType()) { case ContentTypeDetector.CLASSFILE: instrument(detector.getInputStream(), output, name); return 1; case ContentTypeDetector.ZIPFILE: return instrumentZip(detector.getInputStream(), output, name); case ContentTypeDetector.GZFILE: return instrumentGzip(detector.getInputStream(), output, name); case ContentTypeDetector.PACK200FILE: return instrumentPack200(detector.getInputStream(), output, name); default: copy(detector.getInputStream(), output, name); return 0; } }
[*] target: assertEquals(0, count)
[-] pred: org. junit. Assert. assertEquals ( 0, count )
************************************
************************************
[+] input: IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ZipOutputStream zipout = new ZipOutputStream(buffer); zipout.putNextEntry(new ZipEntry("META-INF/ALIAS.SF")); zipout.finish(); ByteArrayOutputStream out = new ByteArrayOutputStream();  instrumenter.setRemoveSignatures(false); int count = instrumenter.instrumentAll( new ByteArrayInputStream(buffer.toByteArray()), out, "Test");  "<AssertPlaceHolder>"; ZipInputStream zipin = new ZipInputStream(new ByteArrayInputStream( out.toByteArray())); assertEquals("META-INF/ALIAS.SF", zipin.getNextEntry().getName()); assertNull(zipin.getNextEntry()); }
instrumentAll(final InputStream input, final OutputStream output, final String name) throws IOException { final ContentTypeDetector detector; try { detector = new ContentTypeDetector(input); } catch (final IOException e) { throw instrumentError(name, e); } switch (detector.getType()) { case ContentTypeDetector.CLASSFILE: instrument(detector.getInputStream(), output, name); return 1; case ContentTypeDetector.ZIPFILE: return instrumentZip(detector.getInputStream(), output, name); case ContentTypeDetector.GZFILE: return instrumentGzip(detector.getInputStream(), output, name); case ContentTypeDetector.PACK200FILE: return instrumentPack200(detector.getInputStream(), output, name); default: copy(detector.getInputStream(), output, name); return 0; } }
[*] target: assertEquals(0, count)
[-] pred: org. junit. Assert. assertEquals ( 0, count )
************************************
************************************
[+] input: testIncrement1() { CounterImpl c = CounterImpl.getInstance(1, 1); c = c.increment(CounterImpl.getInstance(2, 1)); assertEquals(3, c.getMissedCount()); "<AssertPlaceHolder>"; }
getCoveredCount() { return covered; }
[*] target: assertEquals(2, c.getCoveredCount())
[-] pred: org. junit. Assert. assertEquals ( 2, c. getCoveredCount() )
************************************
************************************
[+] input: new_instance_should_have_no_coverage_and_no_branches() { assertEquals(CounterImpl.COUNTER_1_0, instruction.getInstructionCounter()); "<AssertPlaceHolder>"; }
getBranchCounter() { if (branches < 2) { return CounterImpl.COUNTER_0_0; } final int covered = coveredBranches.cardinality(); return CounterImpl.getInstance(branches - covered, covered); }
[*] target: assertEquals(CounterImpl.COUNTER_0_0, instruction.getBranchCounter())
[-] pred: org. junit. Assert. assertEquals ( CounterImpl.COUNTER_0_0, instruction. getBranchCounter() )
************************************
************************************
[+] input: testFieldInsn() { analyzer.successor = false; analyzer.visitFieldInsn(GETFIELD, "Foo", "name", "Ljava/lang/String;"); "<AssertPlaceHolder>"; assertFalse(analyzer.first); }
visitFieldInsn(final int opcode, final String owner, final String name, final String desc) { successor = true; first = false; }
[*] target: assertTrue(analyzer.successor)
[-] pred: org. junit. Assert. assertTrue ( analyzer.successor )
************************************
************************************
[+] input: activateUser() { User user = new User(); user.setActivationCode(USER_ACTIVATION_CODE);  when(userRepository.findByActivationCode(USER_ACTIVATION_CODE)).thenReturn(Optional.of(user)); when(userRepository.save(user)).thenReturn(user); String activated = authenticationService.activateUser(user.getActivationCode()); "<AssertPlaceHolder>"; assertNull(user.getActivationCode()); verify(userRepository, times(1)).save(user); }
activateUser(String code) { User user = userRepository.findByActivationCode(code) .orElseThrow(() -> new ApiRequestException(ACTIVATION_CODE_NOT_FOUND, HttpStatus.NOT_FOUND)); user.setActivationCode(null); user.setActive(true); userRepository.save(user); return "User successfully activated."; }
[*] target: assertNotNull(activated)
[-] pred: org. junit. Assert. assertNotNull ( activated )
************************************
************************************
[+] input: testSelectSingleCommuUserDetail() { // given CommunityUser communityUser = new CommunityUser(); testData(communityUser); // log.debug("communityUser = {}, {}", communityUser.getEmplyrId(), communityUser.getCmmntyId());  // when CommunityUser resultCommunityUser = egovCommuManageDAO.selectSingleCommuUserDetail(communityUser);  // then assertNotNull(resultCommunityUser);  // given CommunityUser communityNoUser = new CommunityUser(); communityNoUser.setCmmntyId(communityUser.getCmmntyId()); communityNoUser.setEmplyrId("00000000000"); // 존재하지 않는 사용자ID  // when resultCommunityUser = egovCommuManageDAO.selectSingleCommuUserDetail(communityNoUser);  // then "<AssertPlaceHolder>"; }
selectSingleCommuUserDetail(CommunityUser cmmntyUser) { return (CommunityUser) selectOne("CommuManage.selectSingleCommuUserDetail", cmmntyUser); }
[*] target: assertNull(resultCommunityUser)
[-] pred: org. junit. Assert. assertNull ( resultCommunityUser )
************************************
************************************
[+] input: Exception { EmpVO vo = makeVO();  // insert employerMapper.insertEmployer(vo);  // 검색조건으로 key 설정 EmpVO searchVO = new EmpVO(); searchVO.setEmpName("홍길");  // selectList List<EmpVO> resultList = employerMapper.selectEmployerList(searchVO);  // key 조건에 대한 결과는 한건일 것임 "<AssertPlaceHolder>"; assertTrue(resultList.size() > 0); assertEquals(1, resultList.size()); // assertTrue(resultList.get(0) instanceof DeptVO); checkResult(vo, resultList.get(0));  }
selectEmployerList(EmpVO vo);
[*] target: assertNotNull(resultList)
[-] pred: org. junit. Assert. assertNotNull ( resultList )
************************************
************************************
[+] input: testParse() { GalleryDetailUrlParser.Result result = GalleryDetailUrlParser.parse(url, strict); if (isNull) { "<AssertPlaceHolder>"; } else { assertEquals(gid, result.gid); assertEquals(token, result.token); } }
parse(String url, boolean strict) { if (url == null) { return null; }  Pattern pattern = strict ? URL_STRICT_PATTERN : URL_PATTERN; Matcher m = pattern.matcher(url); if (m.find()) { Result result = new Result(); result.gid = NumberUtils.parseLongSafely(m.group(1), -1L); result.token = m.group(2); if (result.gid < 0) { return null; } return result; } else { return null; } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testParse() { GalleryPageUrlParser.Result result = GalleryPageUrlParser.parse(url, strict); if (isNull) { "<AssertPlaceHolder>"; } else { assertEquals(gid, result.gid); assertEquals(pToken, result.pToken); assertEquals(page, result.page); } }
parse(String url, boolean strict) { if (url == null) { return null; }  Pattern pattern = strict ? URL_STRICT_PATTERN : URL_PATTERN; Matcher m = pattern.matcher(url); if (m.find()) { Result result = new Result(); result.gid = NumberUtils.parseLongSafely(m.group(2), -1L); result.pToken = m.group(1); result.page = NumberUtils.parseIntSafely(m.group(3), 0) - 1; if (result.gid < 0 || result.page < 0) { return null; } return result; } else { return null; } }
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testReset() {  final String defaultValue = Properties.TARGET_CLASS;  final String aString = "foo_foo_foo"; Assert.assertNotEquals(defaultValue, aString);  Properties.TARGET_CLASS = aString; Assert.assertEquals(aString,Properties.TARGET_CLASS);  Properties.getInstance().resetToDefaults(); Assert."<AssertPlaceHolder>"; }
resetToDefaults() { Properties.instance = new Properties(false, true); for (Field f : Properties.class.getFields()) { if (f.isAnnotationPresent(Parameter.class)) { if (defaultMap.containsKey(f)) { try { f.set(null, defaultMap.get(f)); } catch (Exception e) { logger.error("Failed to init property field " + f + " , " + e.getMessage(), e); } } } } }
[*] target: assertEquals(defaultValue,Properties.TARGET_CLASS)
[-] pred: org. junit. Assert. assertEquals ( defaultValue, Properties.TARGET_CLASS )
************************************
************************************
[+] input: IOException {  File dir = JUnitAnalyzer.createNewTmpDir(); Assert."<AssertPlaceHolder>"; Assert.assertTrue(dir.exists());  FileUtils.deleteDirectory(dir); Assert.assertFalse(dir.exists()); }
createNewTmpDir() { File dir = null; String dirName = FileUtils.getTempDirectoryPath() + File.separator + "EvoSuite_" + (dirCounter++) + "_" + +System.currentTimeMillis();  //first create a tmp folder dir = new File(dirName); if (!dir.mkdirs()) { logger.error("Cannot create tmp dir: " + dirName); return null; }  if (!dir.exists()) { logger.error("Weird behavior: we created folder, but Java cannot determine if it exists? Folder: " + dirName); return null; }  return dir; }
[*] target: assertNotNull(dir)
[-] pred: org. junit. Assert. assertNotNull ( dir )
************************************
************************************
[+] input: testFoo() { String targetClassName = Foo.class.getCanonicalName(); GetStaticGraph graph = GetStaticGraphGenerator .generate(targetClassName);  Set<String> expectedClasses = new HashSet<String>(Arrays.asList( Foo.class.getCanonicalName(), Bar1.class.getCanonicalName(), Bar2.class.getCanonicalName(), Bar3.class.getCanonicalName(), Bar4.class.getCanonicalName(), Bar5.class.getCanonicalName(), Bar6.class.getCanonicalName(), Bar7.class.getCanonicalName(), BarBar1.class.getCanonicalName()));  Set<String> allClasses = new HashSet<String>(); allClasses.addAll(graph.getSourceClasses()); allClasses.addAll(graph.getTargetClasses());  assertEquals(expectedClasses, allClasses);  Map<String, Set<String>> expectedStaticFields = new HashMap<String, Set<String>>(); expectedStaticFields.put(Bar2.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar2"))); expectedStaticFields.put(Bar6.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar6"))); expectedStaticFields.put(Bar7.class.getCanonicalName(), new HashSet<String>(Arrays.asList("fieldBar7")));  Map<String, Set<String>> staticFields = graph.getStaticFields(); "<AssertPlaceHolder>"; }
getStaticFields() { Map<String, Set<String>> staticFields = new LinkedHashMap<String, Set<String>>(); for (StaticFieldReadEntry read : this.staticFieldReads) { String className = read.getTargetClass().replace('/', '.'); if (!staticFields.containsKey(className)) { staticFields.put(className, new LinkedHashSet<String>()); } staticFields.get(className).add(read.getTargetField()); } return staticFields; }
[*] target: assertEquals(expectedStaticFields, staticFields)
[-] pred: org. junit. Assert. assertEquals ( expectedStaticFields, staticFields )
************************************
************************************
[+] input: ClassNotFoundException { Properties.DSE_SOLVER = Properties.SolverType.EVOSUITE_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: ClassNotFoundException { String cvc4_path = System.getenv("cvc4_path"); if (cvc4_path != null) { Properties.CVC4_PATH = cvc4_path; } Assume.assumeTrue(Properties.CVC4_PATH!=null); Properties.DSE_SOLVER = Properties.SolverType.CVC4_SOLVER; Properties.CRITERION = new Properties.Criterion[] { Criterion.BRANCH }; Properties.TARGET_CLASS = Foo.class.getName();  TestGenerationContext.getInstance().getClassLoaderForSUT().loadClass(Properties.TARGET_CLASS);  BranchCoverageSuiteFitness branchCoverageSuiteFitness = new BranchCoverageSuiteFitness(); TestSuiteChromosome suite = new TestSuiteChromosome(); suite.addFitness(branchCoverageSuiteFitness); branchCoverageSuiteFitness.getFitness(suite);  // no goals covered yet int coveredGoals0 = suite.getNumOfCoveredGoals(); int notCoveredGoals0 = suite.getNumOfNotCoveredGoals(); assertEquals(0, coveredGoals0); assertNotEquals(0, notCoveredGoals0);  DefaultTestCase testCase0 = buildTestCase0(); TestChromosome testChromosome0 = new TestChromosome(); testChromosome0.setTestCase(testCase0); suite.addTest(testChromosome0);  double fitnessBeforeLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsBeforeLocalSearch = suite.getNumOfCoveredGoals();  // some goal was covered assertTrue(coveredGoalsBeforeLocalSearch > 0);  DefaultTestCase duplicatedTestCase0 = buildTestCase0(); TestChromosome duplicatedTestChromosome0 = new TestChromosome(); duplicatedTestChromosome0.setTestCase(duplicatedTestCase0); suite.addTest(duplicatedTestChromosome0);  TestSuiteLocalSearchObjective localSearchObjective = TestSuiteLocalSearchObjective .buildNewTestSuiteLocalSearchObjective(Collections.singletonList(branchCoverageSuiteFitness), suite, 1);  DSETestCaseLocalSearch localSearch = new DSETestCaseLocalSearch(); boolean improved = localSearch.doSearch(duplicatedTestChromosome0, localSearchObjective); "<AssertPlaceHolder>";  double fitnessAfterLocalSearch = branchCoverageSuiteFitness.getFitness(suite); int coveredGoalsAfterLocalSearch = suite.getNumOfCoveredGoals();  assertTrue(fitnessAfterLocalSearch < fitnessBeforeLocalSearch); assertTrue(coveredGoalsAfterLocalSearch > coveredGoalsBeforeLocalSearch);  }
doSearch(TestChromosome test, LocalSearchObjective<TestChromosome> objective) { logger.info("Test before local search: " + test.getTestCase().toCode());  // gather covered branches true/false branch indexes  final Set<Branch> coveredBranches; if (suite != null) { coveredBranches = collectCoveredBranches(suite); } else { coveredBranches = getCoveredBranches(test); } final Set<Branch> uncoveredBranches = collectUncoveredBranches(coveredBranches);  if (uncoveredBranches.isEmpty()) { /* * As there are no branches uncovered (true or false branch missing) * in this suite, there is no point in continuing DSE. Therefore, we * should stop DSE (no DSE improvement) */ return false; }  if (!hasUncoveredBranch(test, uncoveredBranches)) { /* * As there are uncovered branches, but none is reached by this * test, the DSE is skipped and we return false (no DSE improvement) */ return false; }  Set<Integer> targetStatementIndexes = collectStatementIndexesWithSymbolicVariables(test, objective);  final boolean fitnessHasImproved; if (targetStatementIndexes.isEmpty()) { // Cannot apply DSE because there are no symbolic variables // Therefore, no improvement on objective. fitnessHasImproved = false; } else { logger.info("Yes, now applying the search at positions {}!", targetStatementIndexes); DSETestGenerator dseTestGenerator; if (suite != null) { dseTestGenerator = new DSETestGenerator(suite); } else { dseTestGenerator = new DSETestGenerator(); } final TestChromosome newTest = dseTestGenerator.generateNewTest(test, targetStatementIndexes, objective); if (newTest != null) { fitnessHasImproved = true; } else { fitnessHasImproved = false; } }  LocalSearchBudget.getInstance().countLocalSearchOnTest();  // Return true iff search was successful return fitnessHasImproved;  // TODO: Handle arrays in local search // TODO: mutating an int might have an effect on array lengths }
[*] target: assertTrue(improved)
[-] pred: org. junit. Assert. assertTrue ( improved )
************************************
************************************
[+] input: Exception {  ClassLoader loader = new EvoClassLoader(); RuntimeSettings.resetStaticState = true; ClassResetter.getInstance().setClassLoader(loader);  String cut = "com.examples.with.different.packagename.classhandling.FooEnum";  Class<?> klass = loader.loadClass(cut); Method m = klass.getDeclaredMethod("check");  boolean val = false;  val = (Boolean) m.invoke(null); Assert.assertTrue(val);  ClassResetter.getInstance().reset(cut);  //make sure that the reset does not create new enum instance values val = (Boolean) m.invoke(null); Assert."<AssertPlaceHolder>"; }
reset(String classNameWithDots) throws IllegalArgumentException, IllegalStateException{ if(classNameWithDots==null || classNameWithDots.isEmpty()){ throw new IllegalArgumentException("Empty class name in input"); }  if(loader == null){ throw new IllegalStateException("No specified loader"); }  Method m = getResetMethod(classNameWithDots); if(m == null) { return; }  boolean safe = Sandbox.isSafeToExecuteSUTCode();  assert !Sandbox.isSecurityManagerInitialized() || Sandbox.isOnAndExecutingSUTCode();  InstrumentingAgent.activate(); org.evosuite.runtime.Runtime.getInstance().resetRuntime(); boolean wasLoopCheckOn = LoopCounter.getInstance().isActivated();  try { if(!safe){ Sandbox.goingToExecuteUnsafeCodeOnSameThread(); } LoopCounter.getInstance().setActive(false); m.invoke(null, (Object[]) null); } catch (IllegalAccessException | IllegalArgumentException e) { logger.error(""+e,e); } catch (NoClassDefFoundError e){ AtMostOnceLogger.error(logger,e.toString()); } catch(InvocationTargetException e){  Throwable cause = e.getCause(); if(cause instanceof TooManyResourcesException || cause instanceof NoClassDefFoundError){ logWarn(classNameWithDots, e.toString() + ", caused by: "+cause.toString()); } else { StringWriter errors = new StringWriter(); cause.printStackTrace(new PrintWriter(errors)); logWarn(classNameWithDots, e.toString() + ", caused by: "+cause.toString()+"\n"+errors.toString()); // we are only interested in the stack trace of the cause } } finally { if(!safe){ Sandbox.doneWithExecutingUnsafeCodeOnSameThread(); } LoopCounter.getInstance().setActive(wasLoopCheckOn); }  InstrumentingAgent.deactivate(); }
[*] target: assertTrue(val)
[-] pred: org. junit. Assert. assertTrue ( val )
************************************
************************************
[+] input: testInitializeClasses() {   EvoClassLoader loader = new EvoClassLoader(); String className = "com.examples.with.different.packagename.classhandling.TimeA"; //no mocking RuntimeSettings.deactivateAllMocking(); boolean problem = ClassStateSupport.initializeClasses(loader, className); Assert.assertFalse(problem);  //with mocking RuntimeSettings.mockJVMNonDeterminism = true; className = "com.examples.with.different.packagename.classhandling.TimeB"; problem = ClassStateSupport.initializeClasses(loader,className); Assert."<AssertPlaceHolder>"; }
initializeClasses(ClassLoader classLoader, String... classNames) {  boolean problem = false;  List<Class<?>> classes = loadClasses(classLoader, classNames); if(classes.size() != classNames.length) { problem = true; }  initialiseExternalTools(classLoader, classes);  if(RuntimeSettings.isUsingAnyMocking()) {  for (Class<?> clazz : classes) {  if(clazz.isInterface()) { /* FIXME: once we ll start to support Java 8, in which interfaces can have code, we ll need to instrument them as well */ continue; }  if (!InstrumentedClass.class.isAssignableFrom(clazz)) { String msg = "Class " + clazz.getName() + " was not instrumented by EvoSuite. " + "This could happen if you are running JUnit tests in a way that is not handled by EvoSuite, in " + "which some classes are loaded be reflection before the tests are run. Consult the EvoSuite documentation " + "for possible workarounds for this issue."; logger.error(msg); problem = true; //throw new IllegalStateException(msg); // throwing an exception might be a bit too extreme } } }  return problem;  //retransformIfNeeded(classes); // cannot do it, as retransformation does not really work :( }
[*] target: assertFalse(problem)
[-] pred: org. junit. Assert. assertFalse ( problem )
************************************
************************************
[+] input: testGetCurrentDirectory() {  JFileChooser chooser = new MockJFileChooser(); File dir = chooser.getCurrentDirectory();  Assert."<AssertPlaceHolder>"; Assert.assertTrue(dir instanceof MockFile); }
getCurrentDirectory() { return currentDirectory; }
[*] target: assertTrue(dir.exists())
[-] pred: org. junit. Assert. assertTrue ( dir. exists ( ) )
************************************
************************************
[+] input: equalsHashcodeVerify() { TourRating rating1 = new TourRating(tour, 1, 1, "comment"); TourRating rating2 = new TourRating(tour, 1, 1, "comment");  assertEquals(rating1,rating2); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(id, tour, customerId, score, comment); }
[*] target: assertEquals(rating1.hashCode(), rating2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( rating1. hashCode ( ), rating2. hashCode ( ) )
************************************
************************************
[+] input: test21() { int[] cellPosition = CellReferenceUtil.getCellPosition("B3"); "<AssertPlaceHolder>"; assertEquals(1, cellPosition[1]); }
getCellPosition(String cellRef){ CellReference cellReference = new CellReference(cellRef); return new int[] { cellReference.getRow(), cellReference.getCol() }; }
[*] target: assertEquals(2, cellPosition[0])
[-] pred: org. junit. Assert. assertEquals ( 2, cellPosition [ 0 ] )
************************************
************************************
[+] input: removeElementFromSingleStack() { Stack stack = Stack.getStack(); stack.push('a'); try { assertEquals('a', stack.pop()); } catch (EmptyStackException e) { e.printStackTrace(); } "<AssertPlaceHolder>"; }
getSize() { return size; }
[*] target: assertEquals(0, stack.getSize())
[-] pred: org. junit. Assert. assertEquals ( 0, stack. getSize() )
************************************
************************************
[+] input: should_merge_existing_and_new_categories() { //given existing CategoryBuilder.createDefaultHierarchy(db);  //when cache.loadExistingCategories(db); Set<CategoryInfo> list = new HashSet<CategoryInfo>(); list.add(new CategoryInfo("A:A1", true)); list.add(new CategoryInfo("B", true)); list.add(new CategoryInfo("A:A1:AA2", true)); list.add(new CategoryInfo("A:A2:AB1", false)); list.add(new CategoryInfo("C", false)); list.add(new CategoryInfo("D:D1", true)); cache.insertCategories(db, list);  //then /** * A            1-12 * - A1         2-7 * -- AA1       3-4 * -- AA2       5-6 * - A2         8-11 * -- AB1       9-10 * B            13-14 * C            15-16 * D            17-20 * - D1         18-19 */ CategoryTree<Category> categories = db.getCategoriesTree(false); "<AssertPlaceHolder>"; assertEquals(4, categories.size());  Category noCategory = db.getCategoryWithParent(Category.NO_CATEGORY_ID); assertEquals(0, noCategory.left); assertEquals(21, noCategory.right);  }
insertCategories(DatabaseAdapter dbAdapter, Set<? extends CategoryInfo> categories) { for (CategoryInfo category : categories) { String name = extractCategoryName(category.name); insertCategory(name, category.isIncome); } if (freshStart) { categoryTree.sortByTitle(); } else { categoryTree.reIndex(); } SQLiteDatabase database = dbAdapter.db(); database.beginTransaction(); try { dbAdapter.insertCategoryTreeInTransaction(categoryTree); database.setTransactionSuccessful(); } finally { database.endTransaction(); } }
[*] target: assertNotNull(categories)
[-] pred: org. junit. Assert. assertNotNull ( categories )
************************************
************************************
[+] input: IOException { qifParserTest.should_parse_a_couple_of_empty_accounts(); doImport();  List<Account> accounts = db.getAllAccountsList(); sortAccountsById(accounts);  "<AssertPlaceHolder>"; assertEquals("My Cash Account", accounts.get(0).title); assertEquals(AccountType.CASH.name(), accounts.get(0).type); assertEquals("My Bank Account", accounts.get(1).title); assertEquals(AccountType.BANK.name(), accounts.get(1).type); }
doImport() throws IOException { long t0 = System.currentTimeMillis(); QifBufferedReader r = new QifBufferedReader(new BufferedReader(new InputStreamReader(new FileInputStream(options.filename), "UTF-8"))); QifParser parser = new QifParser(r, options.dateFormat); parser.parse(); long t1 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Parsing done in "+ TimeUnit.MILLISECONDS.toSeconds(t1-t0)+"s"); doImport(parser); long t2 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Importing done in "+ TimeUnit.MILLISECONDS.toSeconds(t2-t1)+"s"); }
[*] target: assertEquals(2, accounts.size())
[-] pred: org. junit. Assert. assertEquals ( 2, accounts. size ( ) )
************************************
************************************
[+] input: Exception { QifParser p = new QifParser(null, QifDateFormat.EU_FORMAT); //P1 // - cc1 // -- c1 // -- c2 // - cc2 //P2 // - x1 p.categories.add(new QifCategory("P1:cc1:c1", true)); p.categories.add(new QifCategory("P1:cc1", true)); p.categories.add(new QifCategory("P1:cc1:c2", true)); p.categories.add(new QifCategory("P2", false)); p.categories.add(new QifCategory("P2:x1", false)); p.categories.add(new QifCategory("P1", true)); p.categories.add(new QifCategory("P1:cc2", true));  //when doImport(p);  //then CategoryTree<Category> categories = db.getCategoriesTree(false); "<AssertPlaceHolder>"; assertEquals(2, categories.size());  Category c = categories.getAt(0); assertCategory("P1", true, c); assertEquals(2, c.children.size());  assertCategory("cc1", true, c.children.getAt(0)); assertEquals(2, c.children.getAt(0).children.size());  assertCategory("cc2", true, c.children.getAt(1)); assertFalse(c.children.getAt(1).hasChildren());  c = categories.getAt(1); assertCategory("P2", false, c); assertEquals(1, c.children.size());  assertCategory("x1", false, c.children.getAt(0)); }
doImport(QifParser parser) { long t0 = System.currentTimeMillis(); insertPayees(parser.payees); long t1 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Inserting payees done in " + TimeUnit.MILLISECONDS.toSeconds(t1 - t0) + "s"); insertProjects(parser.classes); long t2 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Inserting projects done in "+ TimeUnit.MILLISECONDS.toSeconds(t2-t1)+"s"); categoryCache.insertCategories(dbAdapter, parser.categories); long t3 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Inserting categories done in "+ TimeUnit.MILLISECONDS.toSeconds(t3-t2)+"s"); insertAccounts(parser.accounts); long t4 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Inserting accounts done in "+ TimeUnit.MILLISECONDS.toSeconds(t4-t3)+"s"); insertTransactions(parser.accounts); long t5 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Inserting transactions done in "+ TimeUnit.MILLISECONDS.toSeconds(t5-t4)+"s"); }
[*] target: assertNotNull(categories)
[-] pred: org. junit. Assert. assertNotNull ( categories )
************************************
************************************
[+] input: Exception { qifParserTest.should_parse_transfer_splits(); doImport();  List<Account> accounts = db.getAllAccountsList(); "<AssertPlaceHolder>";  Account a = accounts.get(0); assertEquals("My Bank Account", a.title); assertEquals(AccountType.BANK.name(), a.type);  List<TransactionInfo> transactions = db.getTransactionsForAccount(a.id); assertEquals(0, transactions.size());  a = accounts.get(1); assertEquals("My Cash Account", a.title); assertEquals(AccountType.CASH.name(), a.type);  transactions = db.getTransactionsForAccount(a.id); assertEquals(1, transactions.size());  TransactionInfo t = transactions.get(0); assertEquals(-210000, t.fromAmount);  List<TransactionInfo> splits = getSplitsForTransaction(t.id); assertEquals(2, splits.size());  TransactionInfo s = splits.get(0); assertEquals("A1", s.category.title); assertEquals(-110000, s.fromAmount); assertEquals("Note on first split", s.note);  s = splits.get(1); assertTrue(s.isTransfer()); assertEquals("My Bank Account", s.toAccount.title); assertEquals(-100000, s.fromAmount); assertEquals(100000, s.toAmount); }
doImport() throws IOException { long t0 = System.currentTimeMillis(); QifBufferedReader r = new QifBufferedReader(new BufferedReader(new InputStreamReader(new FileInputStream(options.filename), "UTF-8"))); QifParser parser = new QifParser(r, options.dateFormat); parser.parse(); long t1 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Parsing done in "+ TimeUnit.MILLISECONDS.toSeconds(t1-t0)+"s"); doImport(parser); long t2 = System.currentTimeMillis(); Log.i("Financier", "QIF Import: Importing done in "+ TimeUnit.MILLISECONDS.toSeconds(t2-t1)+"s"); }
[*] target: assertEquals(2, accounts.size())
[-] pred: org. junit. Assert. assertEquals ( 2, accounts. size ( ) )
************************************
************************************
[+] input: dimension2() { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l)); EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {  // first expected cluster new EuclideanIntegerPoint(new int[] { -15,  3 }), new EuclideanIntegerPoint(new int[] { -15,  4 }), new EuclideanIntegerPoint(new int[] { -15,  5 }), new EuclideanIntegerPoint(new int[] { -14,  3 }), new EuclideanIntegerPoint(new int[] { -14,  5 }), new EuclideanIntegerPoint(new int[] { -13,  3 }), new EuclideanIntegerPoint(new int[] { -13,  4 }), new EuclideanIntegerPoint(new int[] { -13,  5 }),  // second expected cluster new EuclideanIntegerPoint(new int[] { -1,  0 }), new EuclideanIntegerPoint(new int[] { -1, -1 }), new EuclideanIntegerPoint(new int[] {  0, -1 }), new EuclideanIntegerPoint(new int[] {  1, -1 }), new EuclideanIntegerPoint(new int[] {  1, -2 }),  // third expected cluster new EuclideanIntegerPoint(new int[] { 13,  3 }), new EuclideanIntegerPoint(new int[] { 13,  4 }), new EuclideanIntegerPoint(new int[] { 14,  4 }), new EuclideanIntegerPoint(new int[] { 14,  7 }), new EuclideanIntegerPoint(new int[] { 16,  5 }), new EuclideanIntegerPoint(new int[] { 16,  6 }), new EuclideanIntegerPoint(new int[] { 17,  4 }), new EuclideanIntegerPoint(new int[] { 17,  7 })  }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 3, 10);  "<AssertPlaceHolder>"; boolean cluster1Found = false; boolean cluster2Found = false; boolean cluster3Found = false; for (Cluster<EuclideanIntegerPoint> cluster : clusters) { int[] center = cluster.getCenter().getPoint(); if (center[0] < 0) { cluster1Found = true; assertEquals(8, cluster.getPoints().size()); assertEquals(-14, center[0]); assertEquals( 4, center[1]); } else if (center[1] < 0) { cluster2Found = true; assertEquals(5, cluster.getPoints().size()); assertEquals( 0, center[0]); assertEquals(-1, center[1]); } else { cluster3Found = true; assertEquals(8, cluster.getPoints().size()); assertEquals(15, center[0]); assertEquals(5, center[1]); } } assertTrue(cluster1Found); assertTrue(cluster2Found); assertTrue(cluster3Found);  }
cluster(final Collection<T> points, final int k, final int maxIterations) { // create the initial clusters List<Cluster<T>> clusters = chooseInitialCenters(points, k, random); assignPointsToClusters(clusters, points);  // iterate through updating the centers until we're done final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations; for (int count = 0; count < max; count++) { boolean clusteringChanged = false; List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>(); for (final Cluster<T> cluster : clusters) { final T newCenter = cluster.getCenter().centroidOf(cluster.getPoints()); if (!newCenter.equals(cluster.getCenter())) { clusteringChanged = true; } newClusters.add(new Cluster<T>(newCenter)); } if (!clusteringChanged) { return clusters; } assignPointsToClusters(newClusters, points); clusters = newClusters; } return clusters; }
[*] target: assertEquals(3, clusters.size())
[-] pred: org. junit. Assert. assertEquals ( 3, clusters. size ( ) )
************************************
************************************
[+] input: testExampleFL8Ochiai() { // Run only on target release >= 5 Assume.assumeTrue(getCompilerVersion() >= 5);  // Setup config FlacocoConfig config = new FlacocoConfig(); config.setWorkspace(workspaceDir.getRoot().getAbsolutePath()); config.setTestRunnerVerbose(true); config.setProjectPath("./examples/exampleFL8NotMaven/"); config.setSrcJavaDir(Collections.singletonList("./examples/exampleFL8NotMaven/java")); config.setSrcTestDir(Collections.singletonList("./examples/exampleFL8NotMaven/test")); config.setBinJavaDir(Collections.singletonList("./examples/exampleFL8NotMaven/bin/classes")); config.setBinTestDir(Collections.singletonList("./examples/exampleFL8NotMaven/bin/test-classes")); config.setSpectrumFormula(SpectrumFormula.OCHIAI);  SpectrumRunner runner = new SpectrumRunner(config);  FlacocoResult result = runner.run();  for (Map.Entry<Location, Suspiciousness> entry : result.getDefaultSuspiciousnessMap().entrySet()) { System.out.println(entry); }  Map<Location, Suspiciousness> susp = result.getDefaultSuspiciousnessMap(); "<AssertPlaceHolder>";  // Line executed only by the failing assertEquals(1.0, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 15)).getScore(), 0);  // Line executed by a mix of failing and passing assertEquals(0.70, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 14)).getScore(), 0.01); assertEquals(0.57, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 12)).getScore(), 0.01);  // Lines executed by all test assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 10)).getScore(), 0); assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 5)).getScore(), 0); assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 6)).getScore(), 0); }
run() { FlacocoResult result = new FlacocoResult();  // Warn if system memory is lower than 4GiB long memorySize = ((com.sun.management.OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean()) .getTotalPhysicalMemorySize(); if (memorySize < 4294967296L) { logger.warn("System memory is lower than 4GiB. " + "Caution when running spectrum-based fault localization on large projects, as coverage computation require more than the available memory"); }  CoverageMatrix coverageMatrix = computeCoverageMatrix(); result.setFailingTests(coverageMatrix.getFailingTestCases()); result.setExecutedTests(coverageMatrix.getTests().keySet());  SpectrumSuspiciousComputation ssc = new SpectrumSuspiciousComputation(config); Map<Location, Suspiciousness> defaultMapping = ssc.calculateSuspicious(coverageMatrix, this.config.getSpectrumFormula().getFormula()); result.setDefaultSuspiciousnessMap(defaultMapping);  if (config.isComputeSpoonResults()) { result = new SpoonConverter(config).convertResult(result); }  return result; }
[*] target: assertEquals(6, susp.size())
[-] pred: org. junit. Assert. assertEquals ( 6, susp. size ( ) )
************************************
************************************
[+] input: testExampleFL9Ochiai() { // Run only on target release >= 5 Assume.assumeTrue(getCompilerVersion() >= 5);  // Setup config FlacocoConfig config = new FlacocoConfig(); config.setWorkspace(workspaceDir.getRoot().getAbsolutePath()); config.setTestRunnerVerbose(true); config.setProjectPath("./examples/exampleFL9NotMavenMultiple/"); config.setSrcJavaDir(Arrays.asList("./examples/exampleFL9NotMavenMultiple/java")); config.setSrcTestDir(Arrays.asList("./examples/exampleFL9NotMavenMultiple/test2", "./examples/exampleFL9NotMavenMultiple/test1")); config.setBinJavaDir(Arrays.asList("./examples/exampleFL9NotMavenMultiple/bin/classes")); config.setBinTestDir(Arrays.asList("./examples/exampleFL9NotMavenMultiple/bin/test-classes2", "./examples/exampleFL9NotMavenMultiple/bin/test-classes1")); config.setSpectrumFormula(SpectrumFormula.OCHIAI);  SpectrumRunner runner = new SpectrumRunner(config);  FlacocoResult result = runner.run();  for (Map.Entry<Location, Suspiciousness> entry : result.getDefaultSuspiciousnessMap().entrySet()) { System.out.println(entry); }  Map<Location, Suspiciousness> susp = result.getDefaultSuspiciousnessMap(); "<AssertPlaceHolder>";  // Line executed only by the failing assertEquals(1.0, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 15)).getScore(), 0);  // Line executed by a mix of failing and passing assertEquals(0.70, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 14)).getScore(), 0.01); assertEquals(0.57, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 12)).getScore(), 0.01);  // Lines executed by all test assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 10)).getScore(), 0); assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 5)).getScore(), 0); assertEquals(0.5, susp.get(new Location("fr.spoonlabs.FLtest1.Calculator", 6)).getScore(), 0); }
run() { FlacocoResult result = new FlacocoResult();  // Warn if system memory is lower than 4GiB long memorySize = ((com.sun.management.OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean()) .getTotalPhysicalMemorySize(); if (memorySize < 4294967296L) { logger.warn("System memory is lower than 4GiB. " + "Caution when running spectrum-based fault localization on large projects, as coverage computation require more than the available memory"); }  CoverageMatrix coverageMatrix = computeCoverageMatrix(); result.setFailingTests(coverageMatrix.getFailingTestCases()); result.setExecutedTests(coverageMatrix.getTests().keySet());  SpectrumSuspiciousComputation ssc = new SpectrumSuspiciousComputation(config); Map<Location, Suspiciousness> defaultMapping = ssc.calculateSuspicious(coverageMatrix, this.config.getSpectrumFormula().getFormula()); result.setDefaultSuspiciousnessMap(defaultMapping);  if (config.isComputeSpoonResults()) { result = new SpoonConverter(config).convertResult(result); }  return result; }
[*] target: assertEquals(6, susp.size())
[-] pred: org. junit. Assert. assertEquals ( 6, susp. size ( ) )
************************************
************************************
[+] input: testClear() { GitHubDataCache<String> cache = new GitHubDataCache<>();  String data = "data to be cached"; GitHubProject project = new GitHubProject(new GitHubOrganization(data), data); cache.put(project, data); assertEquals(1, cache.size()); String cached = cache.get(project).orElseThrow(RuntimeException::new); assertEquals(data, cached);  // fill out the cache for (int i = 1, cacheSize = cache.size(); cacheSize < cache.maxSize(); cacheSize++, i++) { project = new GitHubProject(String.format("org%d", i), String.format("project%d", i)); data = String.format("data%d", i); cache.put(project, data); }  assertEquals(cache.size(), cache.maxSize());  cache.clear(); "<AssertPlaceHolder>"; }
size() { return entries.size(); }
[*] target: assertEquals(0, cache.size())
[-] pred: org. junit. Assert. assertEquals ( 0, cache. size ( ) )
************************************
************************************
[+] input: IOException { LgtmDataProvider provider = new LgtmDataProvider(fetcher); provider = spy(provider);  CloseableHttpClient httpClient = mock(CloseableHttpClient.class); when(provider.httpClient()).thenReturn(httpClient);  CloseableHttpResponse response = mock(CloseableHttpResponse.class); when(httpClient.execute(any())).thenReturn(response);  HttpEntity entity = mock(HttpEntity.class); when(response.getEntity()).thenReturn(entity);  GitHubProject project = new GitHubProject("org", "project");  GHCheckRun checkRun = mock(GHCheckRun.class); when(checkRun.getName()).thenReturn("LGTM analysis");  PagedIterator<GHCheckRun> checkRunPagedIterator = mock(PagedIterator.class); when(checkRunPagedIterator.hasNext()).thenReturn(true, false); when(checkRunPagedIterator.next()).thenReturn(checkRun);  PagedIterable<GHCheckRun> checkRunPagedIterable = mock(PagedIterable.class); when(checkRunPagedIterable.iterator()).thenReturn(checkRunPagedIterator);  GHCommit commit = mock(GHCommit.class); when(commit.getCheckRuns()).thenReturn(checkRunPagedIterable);  GHRepository repository = mock(GHRepository.class); when(fetcher.github().getRepository(anyString())).thenReturn(repository);  PagedIterator<GHCommit> commitPagedIterator = mock(PagedIterator.class); when(commitPagedIterator.hasNext()).thenReturn(true, false); when(commitPagedIterator.next()).thenReturn(commit);  PagedIterable<GHCommit> commitPagedIterable = mock(PagedIterable.class); when(commitPagedIterable.iterator()).thenReturn(commitPagedIterator);  when(repository.listCommits()).thenReturn(commitPagedIterable);  try (InputStream content = getClass().getResourceAsStream("LgtmProjectInfoReply.json")) { when(entity.getContent()).thenReturn(content);  ValueHashSet values = new ValueHashSet(); "<AssertPlaceHolder>";  provider.set(NoUserCallback.INSTANCE); provider.update(project, values);  assertEquals(2, values.size()); assertTrue(values.has(USES_LGTM_CHECKS)); assertTrue(values.of(USES_LGTM_CHECKS).isPresent()); assertFalse(values.of(USES_LGTM_CHECKS).get().isUnknown()); assertEquals(USES_LGTM_CHECKS.value(true), values.of(USES_LGTM_CHECKS).get());  assertTrue(values.has(WORST_LGTM_GRADE)); assertTrue(values.of(WORST_LGTM_GRADE).isPresent()); assertFalse(values.of(WORST_LGTM_GRADE).get().isUnknown()); assertEquals(WORST_LGTM_GRADE.value(LgtmGrade.C), values.of(WORST_LGTM_GRADE).get()); } }
httpClient() { return HttpClients.createDefault(); }
[*] target: assertEquals(0, values.size())
[-] pred: org. junit. Assert. assertEquals ( 0, values. size ( ) )
************************************
************************************
[+] input: IOException { LgtmDataProvider provider = new LgtmDataProvider(fetcher); provider = spy(provider);  CloseableHttpClient httpClient = mock(CloseableHttpClient.class); when(provider.httpClient()).thenReturn(httpClient);  CloseableHttpResponse response = mock(CloseableHttpResponse.class); when(httpClient.execute(any())).thenReturn(response);  HttpEntity entity = mock(HttpEntity.class); when(response.getEntity()).thenReturn(entity);  GitHubProject project = new GitHubProject("org", "project");  PagedIterator<GHCheckRun> checkRunPagedIterator = mock(PagedIterator.class); when(checkRunPagedIterator.hasNext()).thenReturn(false);  PagedIterable<GHCheckRun> checkRunPagedIterable = mock(PagedIterable.class); when(checkRunPagedIterable.iterator()).thenReturn(checkRunPagedIterator);  GHCommit commit = mock(GHCommit.class); when(commit.getCheckRuns()).thenReturn(checkRunPagedIterable);  GHRepository repository = mock(GHRepository.class); when(fetcher.github().getRepository(anyString())).thenReturn(repository);  PagedIterator<GHCommit> commitPagedIterator = mock(PagedIterator.class); when(commitPagedIterator.hasNext()).thenReturn(true, false); when(commitPagedIterator.next()).thenReturn(commit);  PagedIterable<GHCommit> commitPagedIterable = mock(PagedIterable.class); when(commitPagedIterable.iterator()).thenReturn(commitPagedIterator);  when(repository.listCommits()).thenReturn(commitPagedIterable);  try (InputStream content = getClass().getResourceAsStream("LgtmProjectDoesNotExistReply.json")) {  when(entity.getContent()).thenReturn(content);  ValueHashSet values = new ValueHashSet(); "<AssertPlaceHolder>";  provider.set(NoUserCallback.INSTANCE); provider.update(project, values);  assertEquals(2, values.size()); assertTrue(values.has(USES_LGTM_CHECKS)); assertTrue(values.of(USES_LGTM_CHECKS).isPresent()); assertFalse(values.of(USES_LGTM_CHECKS).get().isUnknown()); assertEquals(USES_LGTM_CHECKS.value(false), values.of(USES_LGTM_CHECKS).get());  assertTrue(values.has(WORST_LGTM_GRADE)); assertTrue(values.of(WORST_LGTM_GRADE).isPresent()); assertTrue(values.of(WORST_LGTM_GRADE).get().isUnknown()); } }
httpClient() { return HttpClients.createDefault(); }
[*] target: assertEquals(0, values.size())
[-] pred: org. junit. Assert. assertEquals ( 0, values. size ( ) )
************************************
************************************
[+] input: IOException { final SubjectValueCache cache = new SubjectValueCache();  Map<String, Long> languagesMap = new HashMap<>(); languagesMap.put("Java", 42L); languagesMap.put("Super language", 1001L);  final GHRepository repository = mock(GHRepository.class); when(repository.listLanguages()).thenReturn(languagesMap);  final GitHubDataFetcher fetcher = mock(GitHubDataFetcher.class); when(fetcher.repositoryFor(any())).thenReturn(repository);  ProgrammingLanguages programmingLanguagesProvider = new ProgrammingLanguages(fetcher); programmingLanguagesProvider.set(cache); programmingLanguagesProvider = spy(programmingLanguagesProvider);  PackageManagement provider = new PackageManagement(fetcher); provider.set(cache); provider = spy(provider); when(provider.languagesProvider()).thenReturn(programmingLanguagesProvider);  GitHubProject project = new GitHubProject("org", "test");  Languages languages = provider.languages(project); "<AssertPlaceHolder>"; assertEquals(2, languages.size()); assertTrue(languages.get().contains(JAVA)); assertTrue(languages.get().contains(OTHER)); }
languages(GitHubProject project) throws IOException { ValueSet values = new ValueHashSet(); languagesProvider().update(project, values);  Optional<Value<Languages>> something = values.of(LANGUAGES); if (!something.isPresent()) { return Languages.empty(); }  Value<Languages> value = something.get(); return value.get(); }
[*] target: assertNotNull(languages)
[-] pred: org. junit. Assert. assertNotNull ( languages )
************************************
************************************
[+] input: IOException {  UseReuseDataProvider provider = new UseReuseDataProvider(fetcher); provider.configure(IOUtils.toInputStream( "---\n" + "repositoryExceptions: https://github.com/org/test\n", "UTF-8")); ValueSet retrievedValues = provider.fetchValuesFor(PROJECT);  Value<Boolean> usesReuseValue = retrievedValues.of(USES_REUSE) .orElseThrow(() -> new Error( format("Could not find an expected feature: %s", USES_REUSE.name()))); "<AssertPlaceHolder>"; Value<Boolean> readmeHasReuseValue = retrievedValues.of(README_HAS_REUSE_INFO) .orElseThrow(() -> new Error( format("Could not find an expected feature: %s", README_HAS_REUSE_INFO.name()))); assertTrue(readmeHasReuseValue.get()); Value<Boolean> hasReuseLicensesValue = retrievedValues.of(HAS_REUSE_LICENSES) .orElseThrow(() -> new Error( format("Could not find an expected feature: %s", HAS_REUSE_LICENSES.name()))); assertTrue(hasReuseLicensesValue.get()); Value<Boolean> isRegisteredValue = retrievedValues.of(REGISTERED_IN_REUSE) .orElseThrow(() -> new Error( format("Could not find an expected feature: %s", REGISTERED_IN_REUSE.name()))); assertTrue(isRegisteredValue.get()); Value<Boolean> isCompliantValue = retrievedValues.of(IS_REUSE_COMPLIANT) .orElseThrow(() -> new Error( format("Could not find an expected feature: %s", IS_REUSE_COMPLIANT.name()))); assertTrue(isCompliantValue.get());  }
fetchValuesFor(GitHubProject project) throws IOException { logger.info("Figuring out how the project uses REUSE ...");  // Some repositories apply other copyright annotations and are well-known exceptions. // Those ones will reported as OK by this data provider. if (this.repositoryExceptionUrls.contains(project.toString())) { return ValueHashSet.from( USES_REUSE.value(true), README_HAS_REUSE_INFO.value(true), HAS_REUSE_LICENSES.value(true), REGISTERED_IN_REUSE.value(true), IS_REUSE_COMPLIANT.value(true)); }  ValueSet values = ValueHashSet.from( useReuse(project), readmeHasReuseInfo(project), hasReuseLicenses(project)); values.update(reuseInfo(project)); return values; }
[*] target: assertTrue(usesReuseValue.get())
[-] pred: org. junit. Assert. assertTrue ( usesReuseValue. get ( ) )
************************************
************************************
[+] input: testOssSecurityRatingIsImmutable() { Rating rating = RatingRepository.INSTANCE.rating(OssSecurityRating.class); "<AssertPlaceHolder>"; ImmutabilityChecker checker = new ImmutabilityChecker(); rating.accept(checker); assertTrue(checker.allImmutable()); }
rating(Class<T> clazz) { Objects.requireNonNull(clazz, "You just gave me a null instead of class!");  Rating rating = ratings.get(clazz); if (rating == null) { throw new IllegalArgumentException( String.format("Oh no! Could not find %s", clazz.getCanonicalName())); }  return clazz.cast(rating); }
[*] target: assertNotNull(rating)
[-] pred: org. junit. Assert. assertNotNull ( rating )
************************************
************************************
[+] input: testValue() { EnumFeature<TestEnum> feature = new EnumFeature<>(TestEnum.class, "test"); EnumValue<TestEnum> value = feature.value(TestEnum.A); "<AssertPlaceHolder>"; assertSame(feature, value.feature()); assertSame(TestEnum.A, value.get()); }
value(T object) { return new EnumValue<>(this, object); }
[*] target: assertNotNull(value)
[-] pred: org. junit. Assert. assertNotNull ( value )
************************************
************************************
[+] input: testParseValid() { EnumFeature<TestEnum> feature = new EnumFeature<>(TestEnum.class, "test"); EnumValue<TestEnum> value = feature.parse("A"); "<AssertPlaceHolder>"; assertSame(feature, value.feature()); assertSame(TestEnum.A, value.get()); }
parse(String string) { return value(Enum.valueOf(enumClass, string)); }
[*] target: assertNotNull(value)
[-] pred: org. junit. Assert. assertNotNull ( value )
************************************
************************************
[+] input: testParseInvalid() { EnumFeature<TestEnum> feature = new EnumFeature<>(TestEnum.class, "test"); EnumValue<TestEnum> value = feature.parse("D"); "<AssertPlaceHolder>"; assertSame(feature, value.feature()); assertSame(TestEnum.A, value.get()); }
parse(String string) { return value(Enum.valueOf(enumClass, string)); }
[*] target: assertNotNull(value)
[-] pred: org. junit. Assert. assertNotNull ( value )
************************************
************************************
[+] input: testEqualsAndHashCode() { EnumFeature<TestEnum> one = new EnumFeature<>(TestEnum.class, "test"); assertEquals(one, one);  EnumFeature<TestEnum> two = new EnumFeature<>(TestEnum.class, "test"); assertEquals(one, two); "<AssertPlaceHolder>";  EnumFeature<TestEnum> three = new EnumFeature<>(TestEnum.class, "another"); assertNotEquals(one, three);  EnumFeature<AnotherEnum> four = new EnumFeature<>(AnotherEnum.class, "name"); assertNotEquals(one, four); }
hashCode() { return Objects.hash(super.hashCode(), enumClass); }
[*] target: assertEquals(one.hashCode(), two.hashCode())
[-] pred: org. junit. Assert. assertEquals ( one. hashCode ( ), two. hashCode ( ) )
************************************
************************************
[+] input: IOException { Set<Value<?>> values = new HashSet<>(); values.add(new IntegerValue(ExampleFeatures.NUMBER_OF_COMMITS_LAST_MONTH_EXAMPLE, 1)); Interval expectedScore = DoubleInterval.init().from(4.0).to(6.4).closed().make(); StandardTestVector vector = new StandardTestVector( values, expectedScore, SecurityLabelExample.OKAY, "test");  byte[] bytes = Yaml.toBytes(vector); assertNotNull(bytes); assertTrue(bytes.length > 0); StandardTestVector clone = Yaml.read(bytes, StandardTestVector.class); assertEquals(vector, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), values); }
[*] target: assertEquals(vector.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( vector. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: testEqualsAndHashCode() { NotApplicableLabel one = new NotApplicableLabel(); NotApplicableLabel two = new NotApplicableLabel(); assertEquals(one, one); assertTrue(one.equals(two) && two.equals(one)); "<AssertPlaceHolder>"; }
hashCode() { return 42; }
[*] target: assertEquals(one.hashCode(), two.hashCode())
[-] pred: org. junit. Assert. assertEquals ( one. hashCode(), two. hashCode() )
************************************
************************************
[+] input: equalsAndHashCode() { Score one = new TestAverageCompositeScore(); Score two = new TestAverageCompositeScore(); assertEquals(one, two); "<AssertPlaceHolder>"; assertNotEquals(null, one); assertEquals(one, one); }
hashCode() { return Objects.hash(super.hashCode(), subScores); }
[*] target: assertEquals(one.hashCode(), two.hashCode())
[-] pred: org. junit. Assert. assertEquals ( one. hashCode(), two. hashCode() )
************************************
************************************
[+] input: testEqualsAndHashCode() { Score one = new WeightedScoreImpl(); Score two = new WeightedScoreImpl(); assertEquals(one, two); "<AssertPlaceHolder>"; assertNotEquals(null, one); assertEquals(one, one); }
hashCode() { return Objects.hash(super.hashCode(), subScores, weights); }
[*] target: assertEquals(one.hashCode(), two.hashCode())
[-] pred: org. junit. Assert. assertEquals ( one. hashCode(), two. hashCode() )
************************************
************************************
[+] input: testEqualsAndHashCode() { GitHubOrganization firstOrg = new GitHubOrganization("first"); GitHubOrganization theSameOrg = new GitHubOrganization("first"); assertTrue(firstOrg.equals(theSameOrg) && theSameOrg.equals(firstOrg)); "<AssertPlaceHolder>";  GitHubOrganization anotherOrg = new GitHubOrganization("another"); assertNotEquals(anotherOrg, firstOrg); }
hashCode() { return Objects.hash(super.hashCode(), name); }
[*] target: assertEquals(firstOrg.hashCode(), theSameOrg.hashCode())
[-] pred: org. junit. Assert. assertEquals ( firstOrg. hashCode ( ), theSameOrg. hashCode ( ) )
************************************
************************************
[+] input: IOException { GitHubOrganization org = new GitHubOrganization("test"); byte[] bytes = Json.toBytes(org); assertNotNull(bytes); assertTrue(bytes.length > 0); GitHubOrganization clone = Json.read(bytes, GitHubOrganization.class); assertNotNull(clone); assertEquals(org, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), name); }
[*] target: assertEquals(org.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( org. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { GitHubOrganization apache = new GitHubOrganization("apache"); GitHubProject project = new GitHubProject(apache, "nifi"); project.set( new RatingValue( new ScoreValue(ExampleScores.SECURITY_SCORE_EXAMPLE), SecurityLabelExample.OKAY)); byte[] bytes = Json.toBytes(project); assertNotNull(bytes); assertTrue(bytes.length > 0); GitHubProject clone = Json.read(bytes, GitHubProject.class); assertNotNull(clone); assertEquals(project, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), organization, name); }
[*] target: assertEquals(project.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( project. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { ArtifactVersions versions = new ArtifactVersions( new ArtifactVersion("1.0.0", LocalDateTime.now().minusDays(30)), new ArtifactVersion("1.1.0", LocalDateTime.now().minusDays(20))); ArtifactVersions clone = Json.read(Json.toBytes(versions), ArtifactVersions.class); assertTrue(versions.equals(clone) && clone.equals(versions)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(elements); }
[*] target: assertEquals(versions.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( versions. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { ArtifactVersions versions = new ArtifactVersions( new ArtifactVersion("something", LocalDateTime.now().minusDays(30)), new ArtifactVersion("something else", LocalDateTime.now().minusDays(20))); ArtifactVersions clone = Yaml.read(Yaml.toBytes(versions), ArtifactVersions.class); assertTrue(versions.equals(clone) && clone.equals(versions)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(elements); }
[*] target: assertEquals(versions.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( versions. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { ArtifactVersion version = new ArtifactVersion("2.0.2", LocalDateTime.now()); ArtifactVersion clone = Json.read(Json.toBytes(version), ArtifactVersion.class); assertTrue(version.equals(clone) && clone.equals(version)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(version, releaseDate); }
[*] target: assertEquals(version.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( version. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { ArtifactVersion version = new ArtifactVersion("MIGHTY-1.2", LocalDateTime.now()); ArtifactVersion clone = Yaml.read(Yaml.toBytes(version), ArtifactVersion.class); assertTrue(version.equals(clone) && clone.equals(version)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(version, releaseDate); }
[*] target: assertEquals(version.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( version. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { BooleanValue value = new BooleanValue(FEATURE, false); BooleanValue clone = Yaml.read(Yaml.toBytes(value), BooleanValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), flag); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { DateValue dateValue = new DateValue(new DateFeature("test"), new Date()); byte[] bytes = Json.toBytes(dateValue); assertNotNull(bytes); assertTrue(bytes.length > 0);  DateValue clone = Json.read(bytes, DateValue.class); assertNotNull(clone); assertEquals(dateValue, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), date); }
[*] target: assertEquals(dateValue.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( dateValue. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { DoubleValue value = new DoubleValue(new DoubleFeature("test"), 10.1); byte[] bytes = Json.toBytes(value); assertNotNull(bytes); assertTrue(bytes.length > 0);  DoubleValue clone = Json.read(bytes, DoubleValue.class); assertNotNull(clone); assertEquals(value, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), number); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { EnumFeature<TestEnum> feature = new EnumFeature<>(TestEnum.class, "feature"); EnumValue<TestEnum> a = feature.value(TestEnum.A); byte[] bytes = Json.toBytes(a); assertNotNull(bytes); assertTrue(bytes.length > 0);  Object clone = Json.read(bytes, EnumValue.class); assertNotNull(clone); assertEquals(a, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), value); }
[*] target: assertEquals(a.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( a. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { IntegerValue integerValue = new IntegerValue(new PositiveIntegerFeature("test"), 10); byte[] bytes = Json.toBytes(integerValue); assertNotNull(bytes); assertTrue(bytes.length > 0);  IntegerValue clone = Json.read(bytes, IntegerValue.class); assertNotNull(clone); assertEquals(integerValue, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), number); }
[*] target: assertEquals(integerValue.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( integerValue. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { LanguagesFeature feature = new LanguagesFeature("test"); LanguagesValue value = new LanguagesValue(feature, new Languages(Language.JAVA, Language.C)); LanguagesValue clone = Json.read(Json.toBytes(value), LanguagesValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), languages); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { LgtmGradeFeature feature = new LgtmGradeFeature("feature"); LgtmGradeValue a = feature.value(LgtmGrade.A_PLUS); byte[] bytes = Json.toBytes(a); assertNotNull(bytes); assertTrue(bytes.length > 0);  Object clone = Json.read(bytes, LgtmGradeValue.class); assertNotNull(clone); assertEquals(a, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), value); }
[*] target: assertEquals(a.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( a. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: testEqualsAndHashCode() { OwaspDependencyCheckCvssThresholdValue one = new OwaspDependencyCheckCvssThresholdValue(FEATURE, 1.23, true); assertEquals(one, one);  OwaspDependencyCheckCvssThresholdValue two = new OwaspDependencyCheckCvssThresholdValue(FEATURE, 1.23, true); assertEquals(one, two); "<AssertPlaceHolder>";  OwaspDependencyCheckCvssThresholdValue three = new OwaspDependencyCheckCvssThresholdValue(FEATURE, 2.34, true); assertNotEquals(one, three);  OwaspDependencyCheckCvssThresholdValue four = new OwaspDependencyCheckCvssThresholdValue(FEATURE, 1.23, false); assertNotEquals(one, four);  assertNotEquals(three, four); }
hashCode() { return Objects.hash(super.hashCode(), specified); }
[*] target: assertEquals(one.hashCode(), two.hashCode())
[-] pred: org. junit. Assert. assertEquals ( one. hashCode(), two. hashCode() )
************************************
************************************
[+] input: IOException { OwaspDependencyCheckCvssThresholdValue value = FEATURE.value(5.7); OwaspDependencyCheckCvssThresholdValue clone = Json.read( Json.toBytes(value), OwaspDependencyCheckCvssThresholdValue.class); assertEquals(value, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), specified); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { PackageManagersFeature feature = new PackageManagersFeature("test"); PackageManagersValue value = new PackageManagersValue( feature, new PackageManagers(PackageManager.MAVEN, PackageManager.OTHER)); PackageManagersValue clone = Json.read(Json.toBytes(value), PackageManagersValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), packageManagers); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { SecurityReview review = new SecurityReview(TEST_REVIEW_DATE, 0.0); SecurityReview clone = Yaml.read(Json.toBytes(review), SecurityReview.class); assertTrue(review.equals(clone) && clone.equals(review)); assertEquals(review.hashCode(), clone.hashCode());  review = new SecurityReview(TEST_REVIEW_DATE, null); clone = Yaml.read(Json.toBytes(review), SecurityReview.class); assertTrue(review.equals(clone) && clone.equals(review)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(date, changes); }
[*] target: assertEquals(review.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( review. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { StringFeature feature = new StringFeature("test"); StringValue value = new StringValue(feature, "2.3.3"); StringValue clone = Json.read(Json.toBytes(value), StringValue.class); assertTrue(value.equals(clone) && clone.equals(value)); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), content); }
[*] target: assertEquals(value.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( value. hashCode ( ), clone. hashCode ( ) )
************************************
************************************
[+] input: IOException { VulnerabilitiesValue vulnerabilityValue = new VulnerabilitiesValue( VULNERABILITIES_IN_PROJECT, new Vulnerabilities( newVulnerability("https://bugtracker/1").make(), newVulnerability("https://bugtracker/2").make())); byte[] bytes = Json.toBytes(vulnerabilityValue); assertNotNull(bytes); assertTrue(bytes.length > 0); String content = new String(bytes); assertTrue(content.contains("https://bugtracker/1")); assertTrue(content.contains("https://bugtracker/2")); VulnerabilitiesValue clone = Json.read(bytes, VulnerabilitiesValue.class); assertEquals(vulnerabilityValue, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hash(super.hashCode(), vulnerabilities); }
[*] target: assertEquals(vulnerabilityValue.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( vulnerabilityValue. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { Vulnerability vulnerability = createBasicVulnerability(7.1, "2.3.4", "2.4.1"); Vulnerability clone = Json.read(Json.toBytes(vulnerability), Vulnerability.class); assertEquals(vulnerability, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hashCode(id); }
[*] target: assertEquals(vulnerability.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( vulnerability. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { Vulnerability vulnerability = createBasicVulnerability(7.1, "2.3.4", "2.4.1"); Vulnerability clone = Yaml.read(Yaml.toBytes(vulnerability), Vulnerability.class); assertEquals(vulnerability, clone); "<AssertPlaceHolder>"; }
hashCode() { return Objects.hashCode(id); }
[*] target: assertEquals(vulnerability.hashCode(), clone.hashCode())
[-] pred: org. junit. Assert. assertEquals ( vulnerability. hashCode(), clone. hashCode() )
************************************
************************************
[+] input: IOException { Files.write(CONFIG_PATH, RULE_IDS.getBytes()); try { RatingValue ratingValue = RATING.calculate(allRulesPassed()); assertEquals(OssRulesOfPlayLabel.PASSED, ratingValue.label()); OssRulesOfPlayRatingMarkdownFormatter formatter = new OssRulesOfPlayRatingMarkdownFormatter(CONFIG_PATH, new OssRulesOfPlayAdvisor()); String text = formatter.print(ratingValue, emptyList()); "<AssertPlaceHolder>"; assertFalse(text.isEmpty()); String lowerCaseText = text.toLowerCase(); assertTrue(lowerCaseText.contains("status")); assertTrue(lowerCaseText.contains("pass")); assertFalse(lowerCaseText.contains("fail")); assertFalse(lowerCaseText.contains("unclear")); assertFalse(lowerCaseText.contains("unknown")); assertFalse(lowerCaseText.contains("explanation")); checkRuleIds(text); } finally { FileUtils.forceDeleteOnExit(CONFIG_PATH.toFile()); } }
print(RatingValue ratingValue, List<Advice> advice) { List<FormattedRule> violations = formatted(violationsIn(ratingValue), advice); List<FormattedRule> warnings = formatted(warningsIn(ratingValue), advice); List<FormattedRule> passedRules = formatted(passedRulesIn(ratingValue), advice); List<FormattedRule> unclearRules = formatted(unclearRulesIn(ratingValue), advice);  return template .replace("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%STATUS%", formatted(ratingValue.label())) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%VIOLATED_RULES%", makeListFrom(violations, "Violated rules")) .replace("%WARNINGS%", makeListFrom(warnings, "Warnings")) .replace("%PASSED_RULES%", makeListFrom(passedRules, "Passed rules")) .replace("%UNCLEAR_RULES%", makeListFrom(unclearRules, "Unclear")) .replace("%ADVICE%", makeAdviceFrom(violations, warnings, passedRules, unclearRules)); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: IOException { Files.write(CONFIG_PATH, RULE_IDS.getBytes()); try { ValueSet values = allRulesPassed(); values.update(OssRulesOfPlayScore.RECOMMENDED_FALSE.iterator().next().value(true)); RatingValue ratingValue = RATING.calculate(values); assertEquals(OssRulesOfPlayLabel.PASSED_WITH_WARNING, ratingValue.label()); OssRulesOfPlayRatingMarkdownFormatter formatter = new OssRulesOfPlayRatingMarkdownFormatter(CONFIG_PATH, new OssRulesOfPlayAdvisor()); String text = formatter.print(ratingValue, emptyList()); "<AssertPlaceHolder>"; assertFalse(text.isEmpty()); String lowerCaseText = text.toLowerCase(); assertTrue(lowerCaseText.contains("status")); assertTrue(lowerCaseText.contains("pass")); assertTrue(lowerCaseText.contains("warning")); assertFalse(lowerCaseText.contains("fail")); assertFalse(lowerCaseText.contains("unclear")); assertFalse(lowerCaseText.contains("unknown")); checkRuleIds(text); } finally { FileUtils.forceDeleteOnExit(CONFIG_PATH.toFile()); } }
print(RatingValue ratingValue, List<Advice> advice) { List<FormattedRule> violations = formatted(violationsIn(ratingValue), advice); List<FormattedRule> warnings = formatted(warningsIn(ratingValue), advice); List<FormattedRule> passedRules = formatted(passedRulesIn(ratingValue), advice); List<FormattedRule> unclearRules = formatted(unclearRulesIn(ratingValue), advice);  return template .replace("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%STATUS%", formatted(ratingValue.label())) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%VIOLATED_RULES%", makeListFrom(violations, "Violated rules")) .replace("%WARNINGS%", makeListFrom(warnings, "Warnings")) .replace("%PASSED_RULES%", makeListFrom(passedRules, "Passed rules")) .replace("%UNCLEAR_RULES%", makeListFrom(unclearRules, "Unclear")) .replace("%ADVICE%", makeAdviceFrom(violations, warnings, passedRules, unclearRules)); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: IOException { Files.write(CONFIG_PATH, RULE_IDS.getBytes()); try { ValueSet values = allRulesPassed(); values.update(OssRulesOfPlayScore.EXPECTED_FALSE.iterator().next().value(true)); RatingValue ratingValue = RATING.calculate(values); assertEquals(OssRulesOfPlayLabel.FAILED, ratingValue.label()); OssRulesOfPlayRatingMarkdownFormatter formatter = new OssRulesOfPlayRatingMarkdownFormatter(CONFIG_PATH, new OssRulesOfPlayAdvisor()); String text = formatter.print(ratingValue, emptyList()); "<AssertPlaceHolder>"; assertFalse(text.isEmpty()); String lowerCaseText = text.toLowerCase(); assertTrue(lowerCaseText.contains("status")); assertTrue(lowerCaseText.contains("fail")); assertTrue(lowerCaseText.contains("violated")); assertFalse(lowerCaseText.contains("unclear")); assertFalse(lowerCaseText.contains("unknown")); assertFalse(lowerCaseText.contains("explanation")); checkRuleIds(text); } finally { FileUtils.forceDeleteOnExit(CONFIG_PATH.toFile()); } }
print(RatingValue ratingValue, List<Advice> advice) { List<FormattedRule> violations = formatted(violationsIn(ratingValue), advice); List<FormattedRule> warnings = formatted(warningsIn(ratingValue), advice); List<FormattedRule> passedRules = formatted(passedRulesIn(ratingValue), advice); List<FormattedRule> unclearRules = formatted(unclearRulesIn(ratingValue), advice);  return template .replace("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%STATUS%", formatted(ratingValue.label())) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%VIOLATED_RULES%", makeListFrom(violations, "Violated rules")) .replace("%WARNINGS%", makeListFrom(warnings, "Warnings")) .replace("%PASSED_RULES%", makeListFrom(passedRules, "Passed rules")) .replace("%UNCLEAR_RULES%", makeListFrom(unclearRules, "Unclear")) .replace("%ADVICE%", makeAdviceFrom(violations, warnings, passedRules, unclearRules)); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: IOException { Files.write(CONFIG_PATH, RULE_IDS.getBytes()); try { RatingValue ratingValue = RATING.calculate(allUnknown(RATING.allFeatures())); assertEquals(OssRulesOfPlayLabel.UNCLEAR, ratingValue.label()); OssRulesOfPlayRatingMarkdownFormatter formatter = new OssRulesOfPlayRatingMarkdownFormatter(CONFIG_PATH, new OssRulesOfPlayAdvisor()); String text = formatter.print(ratingValue, emptyList()); "<AssertPlaceHolder>"; assertFalse(text.isEmpty()); String lowerCaseText = text.toLowerCase(); assertTrue(lowerCaseText.contains("status")); assertTrue(lowerCaseText.contains("unclear")); assertFalse(lowerCaseText.contains("pass")); assertFalse(lowerCaseText.contains("fail")); checkRuleIds(text); } finally { FileUtils.forceDeleteOnExit(CONFIG_PATH.toFile()); } }
print(RatingValue ratingValue, List<Advice> advice) { List<FormattedRule> violations = formatted(violationsIn(ratingValue), advice); List<FormattedRule> warnings = formatted(warningsIn(ratingValue), advice); List<FormattedRule> passedRules = formatted(passedRulesIn(ratingValue), advice); List<FormattedRule> unclearRules = formatted(unclearRulesIn(ratingValue), advice);  return template .replace("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%STATUS%", formatted(ratingValue.label())) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%VIOLATED_RULES%", makeListFrom(violations, "Violated rules")) .replace("%WARNINGS%", makeListFrom(warnings, "Warnings")) .replace("%PASSED_RULES%", makeListFrom(passedRules, "Passed rules")) .replace("%UNCLEAR_RULES%", makeListFrom(unclearRules, "Unclear")) .replace("%ADVICE%", makeAdviceFrom(violations, warnings, passedRules, unclearRules)); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: testWithDefaultTemplate() { RatingValue ratingValue = RATING.calculate(TEST_VALUES); PROJECT.set(ratingValue);  OssSecurityRatingMarkdownFormatter formatter = new OssSecurityRatingMarkdownFormatter(new OssSecurityGithubAdvisor()); String text = formatter.print(PROJECT);  "<AssertPlaceHolder>"; assertFalse(text.isEmpty()); }
print(Subject subject) { if (!subject.ratingValue().isPresent()) { return StringUtils.EMPTY; }  MarkdownElement advice = markdownAdviceFor(subject); RatingValue ratingValue = subject.ratingValue().get(); ScoreValue scoreValue = ratingValue.scoreValue();  return template .replaceAll("%MAX_SCORE%", formatted(Score.MAX)) .replaceAll("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%SCORE_VALUE%", formatted(scoreValue.get())) .replace("%RATING_LABEL%", ratingValue.label().name()) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%MAIN_SCORE_NAME%", scoreValue.score().name().toLowerCase()) .replace("%MAIN_SCORE_VALUE_DETAILS%", highLevelDescriptionOf(scoreValue).make()) .replace("%MAIN_SCORE_DESCRIPTION%", scoreValue.score().description()) .replace("%MAIN_SCORE_EXPLANATION%", explanationOf(scoreValue).make()) .replace("%SUB_SCORE_DETAILS%", descriptionOfSubScoresIn(scoreValue).make()) .replace("%ADVICE%", advice.make()) .replace("%INFO_ABOUT_VULNERABILITIES%", infoAboutVulnerabilitiesIn(scoreValue).make()); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: testWithCustomTemplate() {  // Needed to ensure that decimal points are exactly as expected below... Locale.setDefault(new Locale("en", "US"));  RatingValue ratingValue = RATING.calculate(TEST_VALUES); GitHubProject project = new GitHubProject("org", "test"); project.set(ratingValue);  String template = "%RATING_LABEL%|%SCORE_VALUE%|%MAX_SCORE%|%CONFIDENCE_LABEL%" + "|%CONFIDENCE_VALUE%|%MAX_CONFIDENCE%|%MAIN_SCORE_NAME%" + "|%MAIN_SCORE_DESCRIPTION%|%MAIN_SCORE_EXPLANATION%";  OssSecurityRatingMarkdownFormatter formatter = new OssSecurityRatingMarkdownFormatter(new OssSecurityGithubAdvisor(), template); String text = formatter.print(project);  "<AssertPlaceHolder>"; assertEquals("BAD|3.4|10.0|Max|10.0|10.0|security score for open-source projects||", text); }
print(Subject subject) { if (!subject.ratingValue().isPresent()) { return StringUtils.EMPTY; }  MarkdownElement advice = markdownAdviceFor(subject); RatingValue ratingValue = subject.ratingValue().get(); ScoreValue scoreValue = ratingValue.scoreValue();  return template .replaceAll("%MAX_SCORE%", formatted(Score.MAX)) .replaceAll("%MAX_CONFIDENCE%", formatted(Confidence.MAX)) .replace("%SCORE_VALUE%", formatted(scoreValue.get())) .replace("%RATING_LABEL%", ratingValue.label().name()) .replace("%CONFIDENCE_LABEL%", confidenceLabelFor(ratingValue.confidence())) .replace("%CONFIDENCE_VALUE%", formatted(ratingValue.confidence())) .replace("%MAIN_SCORE_NAME%", scoreValue.score().name().toLowerCase()) .replace("%MAIN_SCORE_VALUE_DETAILS%", highLevelDescriptionOf(scoreValue).make()) .replace("%MAIN_SCORE_DESCRIPTION%", scoreValue.score().description()) .replace("%MAIN_SCORE_EXPLANATION%", explanationOf(scoreValue).make()) .replace("%SUB_SCORE_DETAILS%", descriptionOfSubScoresIn(scoreValue).make()) .replace("%ADVICE%", advice.make()) .replace("%INFO_ABOUT_VULNERABILITIES%", infoAboutVulnerabilitiesIn(scoreValue).make()); }
[*] target: assertNotNull(text)
[-] pred: org. junit. Assert. assertNotNull ( text )
************************************
************************************
[+] input: resolveTest() { CipherSuite cipherSuite = CipherSuite.resolve(0xe0, 0x13, ProtocolVersion.NTLS_1_1); Assert.assertEquals(cipherSuite, CipherSuite.NTLS_SM2_WITH_SM4_SM3);  cipherSuite = CipherSuite.resolve(0x00, 0x13, ProtocolVersion.NTLS_1_1); Assert.assertNull(cipherSuite);  cipherSuite = CipherSuite.resolve(0xe0, 0xe3, ProtocolVersion.NTLS_1_1); Assert."<AssertPlaceHolder>"; }
resolve(int id1, int id2, ProtocolVersion version) { if (version == ProtocolVersion.NTLS_1_1) { if (id1 == 0xe0) { switch (id2) { case 0x13: return NTLS_SM2_WITH_SM4_SM3; default: break; } } } return null; }
[*] target: assertNull(cipherSuite)
[-] pred: org. junit. Assert. assertNull ( cipherSuite )
************************************
************************************
[+] input: validValuesOfTest() { try { CipherSuite.validValuesOf(null); Assert.fail(); } catch (Exception ex) { Assert.assertEquals("CipherSuites cannot be null", ex.getMessage()); }  try { CipherSuite.validValuesOf(new String[] { "" }); Assert.fail(); } catch (Exception ex) { Assert.assertEquals("The specified CipherSuites array contains invalid null or empty string elements", ex.getMessage()); }  try { CipherSuite.validValuesOf(new String[] { null }); Assert.fail(); } catch (Exception ex) { Assert.assertEquals("The specified CipherSuites array contains invalid null or empty string elements", ex.getMessage()); }  try { CipherSuite.validValuesOf(new String[] { "test" }); Assert.fail(); } catch (Exception ex) { Assert.assertEquals("Unsupported CipherSuite: test", ex.getMessage()); }  List<CipherSuite> suites = CipherSuite.validValuesOf(new String[] { "ECC-SM2-WITH-SM4-SM3" }); Assert."<AssertPlaceHolder>"; }
validValuesOf(String[] names) { if (names == null) { throw new IllegalArgumentException("CipherSuites cannot be null"); }  List<CipherSuite> cipherSuites = new ArrayList<>(names.length); for (String name : names) { if (name == null || name.isEmpty()) { throw new IllegalArgumentException( "The specified CipherSuites array contains " + "invalid null or empty string elements"); }  boolean found = false;  for (CipherSuite cs : all) { if (!cs.supportedProtocols.isEmpty()) { if (cs.name.equals(name)) { cipherSuites.add(cs); found = true; break; } } else { // values() is ordered, remaining cipher suites are // not supported. break; } } if (!found) { throw new IllegalArgumentException( "Unsupported CipherSuite: "  + name); } }  return Collections.unmodifiableList(cipherSuites); }
[*] target: assertEquals(1, suites.size())
[-] pred: org. junit. Assert. assertEquals ( 1, suites. size ( ) )
************************************
************************************
[+] input: testEmptyPathSequence() { PathSequence pathSequence = new PathSequence(pathSequenceList); assertTrue(pathSequence.pathSequence.isEmpty()); "<AssertPlaceHolder>"; }
size() { return this.pathSequence.size(); }
[*] target: assertEquals(0, pathSequence.size())
[-] pred: org. junit. Assert. assertEquals ( 0, pathSequence. size ( ) )
************************************
************************************
[+] input: binaryExpressionTest() { // Create the mock data. Map<String, Object> argMaps = createBinaryFilterArgMap("firstName", "contains", "ABC");  // Invoke method under test. FilterExpressionParser expressionParser = new FilterExpressionParser(); Expression expression = expressionParser.parseFilterExpression(argMaps);  // Verify assertions. Assert."<AssertPlaceHolder>"; Assert.assertEquals("(firstName contains ABC)", expression.infix()); }
parseFilterExpression(Map filterArgs) { return createExpressionTree(filterArgs); }
[*] target: assertNotNull(expression)
[-] pred: org. junit. Assert. assertNotNull ( expression )
************************************
************************************
[+] input: compoundExpressionTest() { // Create the mock data. Map<String, Object> argMaps = createCompoundFilterArgMap();  // Invoke method under test. FilterExpressionParser expressionParser = new FilterExpressionParser(); Expression expression = expressionParser.parseFilterExpression(argMaps);  // Verify assertions. Assert."<AssertPlaceHolder>"; Assert.assertEquals("((firstName contains ABC) or (lastName equals XYZ))", expression.infix()); }
parseFilterExpression(Map filterArgs) { return createExpressionTree(filterArgs); }
[*] target: assertNotNull(expression)
[-] pred: org. junit. Assert. assertNotNull ( expression )
************************************
************************************
[+] input: IOException { String webpathStr = "projects/foo/location/earth/datasets/bar/dicomStores/" + "fee/dicomWeb/studies/abc/series/xyz/instances/123";  WebPathParser parser = new WebPathParser(); WebPathParser.DicomWebPath dicomWebPath = parser.parseDicomWebpath(webpathStr);  Assert."<AssertPlaceHolder>"; Assert.assertEquals("foo", dicomWebPath.project); Assert.assertEquals("earth", dicomWebPath.location); Assert.assertEquals("bar", dicomWebPath.dataset); Assert.assertEquals("fee", dicomWebPath.storeId); Assert.assertEquals("abc", dicomWebPath.studyId); Assert.assertEquals("xyz", dicomWebPath.seriesId); Assert.assertEquals("123", dicomWebPath.instanceId); Assert.assertEquals( "projects/foo/location/earth/datasets/bar/dicomStores/fee", dicomWebPath.dicomStorePath); }
parseDicomWebpath(String unparsedWebpath) throws IOException { String[] webPathSplit = unparsedWebpath.split("/dicomWeb/");  if (webPathSplit.length != 2) { throw new IOException("Invalid DICOM web path"); }  DicomWebPath dicomWebPath = new DicomWebPath();  dicomWebPath.dicomStorePath = webPathSplit[0]; String[] storePathElements = dicomWebPath.dicomStorePath.split("/");  if (storePathElements.length < 8) { throw new IOException("Invalid DICOM web path"); } dicomWebPath.project = storePathElements[1]; dicomWebPath.location = storePathElements[3]; dicomWebPath.dataset = storePathElements[5]; dicomWebPath.storeId = storePathElements[7];  String[] searchParameters; searchParameters = webPathSplit[1].split("/"); if (searchParameters.length < 6) { throw new IOException("Invalid DICOM web path"); } dicomWebPath.studyId = searchParameters[1]; dicomWebPath.seriesId = searchParameters[3]; dicomWebPath.instanceId = searchParameters[5];  return dicomWebPath; }
[*] target: assertNotNull(dicomWebPath)
[-] pred: org. junit. Assert. assertNotNull ( dicomWebPath )
************************************
************************************
[+] input: testExtractMessages_Coincidence() { final Data raw = Data.fromHexEncodedString("02011a020a0c0aff4c0010050814ff4c00"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; assertEquals("10050814FF4C00", messages.get(0).hexEncodedString());  assertNotNull(BLEDeviceFilter.match(BLEDeviceFilter.compilePatterns(new String[]{"^10....04", "^10....14"}), raw)); }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertEquals(1, messages.size())
[-] pred: org. junit. Assert. assertEquals ( 1, messages. size ( ) )
************************************
************************************
[+] input: testMatch_iPhoneX_F() { final Data raw = Data.fromHexEncodedString("02011A020A0C0BFF4C001006071EA3DD89E014FF4C0001000000000000000000002000000000000000000000000000000000000000000000000000000000"); final List<Data> messages = BLEDeviceFilter.extractMessages(raw.value); "<AssertPlaceHolder>"; assertEquals("1006071EA3DD89E0", messages.get(0).hexEncodedString()); assertEquals("0100000000000000000000200000000000", messages.get(1).hexEncodedString()); }
extractMessages(@Nullable final byte[] rawScanRecordData) { // Parse raw scan record data in scan response data if (null == rawScanRecordData || 0 == rawScanRecordData.length) { return null; } final BLEScanResponseData bleScanResponseData = BLEAdvertParser.parseScanResponse(rawScanRecordData, 0); // Parse scan response data into manufacturer specific data //noinspection ConstantConditions if (null == bleScanResponseData || null == bleScanResponseData.segments || bleScanResponseData.segments.isEmpty()) { return null; } final List<BLEAdvertManufacturerData> bleAdvertManufacturerDataList = BLEAdvertParser.extractManufacturerData(bleScanResponseData.segments); // Parse manufacturer specific data into messages //noinspection ConstantConditions if (null == bleAdvertManufacturerDataList || bleAdvertManufacturerDataList.isEmpty()) { return null; } final List<BLEAdvertAppleManufacturerSegment> bleAdvertAppleManufacturerSegments = BLEAdvertParser.extractAppleManufacturerSegments(bleAdvertManufacturerDataList); // Convert segments to messages //noinspection ConstantConditions if (null == bleAdvertAppleManufacturerSegments || bleAdvertAppleManufacturerSegments.isEmpty()) { return null; } final List<Data> messages = new ArrayList<>(bleAdvertAppleManufacturerSegments.size()); for (final BLEAdvertAppleManufacturerSegment segment : bleAdvertAppleManufacturerSegments) { //noinspection ConstantConditions if (null != segment && null != segment.raw && segment.raw.value.length > 0) { messages.add(segment.raw); } } return messages; }
[*] target: assertEquals(2, messages.size())
[-] pred: org. junit. Assert. assertEquals ( 2, messages. size ( ) )
************************************
************************************
[+] input: testDeserializeMap() { Schema schema = new Schema(required(1, "map_type", Types.MapType .ofRequired(18, 19, Types.StringType.get(), Types.StringType.get()))); Map<String, String> expected = ImmutableMap.of("foo", "bar"); List<Map> data = new ArrayList<>(); data.add(expected);  Record record = TestHelpers.createCustomRecord(schema, data); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> deserialized = (List<Object>) serDe.deserialize(writable); Map result = (Map) deserialized.get(0);  "<AssertPlaceHolder>"; assertTrue(result.containsKey("foo")); assertTrue(result.containsValue("bar")); }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testDeserializeNestedList() { Schema schema = new Schema(required(1, "map_type", Types.MapType .ofRequired(18, 19, Types.StringType.get(), Types.ListType.ofRequired(17, Types.LongType.get())))); Map<String, List> expected = ImmutableMap.of("foo", Arrays.asList(1000L, 2000L, 3000L)); List<Map> data = new ArrayList<>(); data.add(expected);  Record record = TestHelpers.createCustomRecord(schema, data); IcebergWritable writable = new IcebergWritable(); writable.setRecord(record); writable.setSchema(schema);  IcebergSerDe serDe = new IcebergSerDe(); List<Object> deserialized = (List<Object>) serDe.deserialize(writable); Map result = (Map) deserialized.get(0);  "<AssertPlaceHolder>"; assertTrue(result.containsKey("foo")); assertTrue(result.containsValue(Arrays.asList(1000L, 2000L, 3000L))); }
deserialize(Writable writable) { IcebergWritable icebergWritable = (IcebergWritable) writable; Schema schema = icebergWritable.getSchema(); List<Types.NestedField> fields = schema.columns(); List<Object> row = new ArrayList<>();  for(Types.NestedField field: fields){ Object obj = ((IcebergWritable) writable).getRecord().getField(field.name()); row.add(obj); } return Collections.unmodifiableList(row); }
[*] target: assertEquals(expected, result)
[-] pred: org. junit. Assert. assertEquals ( expected, result )
************************************
************************************
[+] input: testJoins() { String protocolFirst = "https"; String protocolSecond = "telnet"; AttackRecord attackRecord = new AttackRecord(); AttackRecord attackRecordSecond = new AttackRecord();  attackRecord.setAttack_id(2); attackRecord.setAttack_id(2); attackRecord.setProtocol(protocolFirst); attackRecordSecond.setAttack_id(3); attackRecordSecond.setProtocol(protocolSecond);  record.setId(1); record.setAttack_id(2); record.setRecord(attackRecord); daoSession.insert(attackRecord); daoSession.insert(attackRecordSecond); daoSession.insert(record);  ArrayList<AttackRecord> records = messageRecordDAO.joinAttacks(protocolFirst); "<AssertPlaceHolder>"; assertEquals(protocolFirst,records.get(0).getProtocol());  }
joinAttacks(String protocol){ AttackRecordDao messageRecordDao = this.daoSession.getAttackRecordDao();  QueryBuilder<AttackRecord> qb = messageRecordDao.queryBuilder(); qb.join(MessageRecord.class , MessageRecordDao.Properties.Attack_id);  ArrayList<AttackRecord> attacks = (ArrayList<AttackRecord>) qb.list();  return attacks;  }
[*] target: assertEquals(1,records.size())
[-] pred: org. junit. Assert. assertEquals ( 1, records. size ( ) )
************************************
************************************
[+] input: testJoins() { AttackRecord attackRecord = new AttackRecord();  String bssid = "dk/aau/netsec/hostage/fragment"; String protocol = "protocol"; String packet = "packet";  attackRecord.setAttack_id(2); attackRecord.setProtocol(protocol); attackRecord.setBssid(bssid); attackRecord.setTimestampLocation(9); record.setBssid(bssid); record.setTimestampLocation(9); record.setPacket(packet);  daoSession.insert(attackRecord); daoSession.insert(record);  ArrayList<NetworkRecord> records = networkRecorDAO.joinAttacks(protocol);  "<AssertPlaceHolder>"; assertEquals(bssid,records.get(0).getBssid()); assertEquals(packet,records.get(0).getPacket());  }
joinAttacks(String protocol){ NetworkRecordDao networkRecordDao = this.daoSession.getNetworkRecordDao();  QueryBuilder<NetworkRecord> qb = networkRecordDao.queryBuilder(); qb.join(AttackRecord.class ,AttackRecordDao.Properties.TimestampLocation).where(AttackRecordDao.Properties.Protocol.eq(protocol));  ArrayList<NetworkRecord> attacks = (ArrayList<NetworkRecord>) qb.list();  return attacks;  }
[*] target: assertEquals(1,records.size())
[-] pred: org. junit. Assert. assertEquals ( 1, records. size ( ) )
************************************
************************************
[+] input: testClear() { ListValue<IntValue> value = new ListValue<>(ValueType.INT); value.add(new IntValue(101)); value.add(new IntValue(102)); value.add(new IntValue(103)); Assert.assertEquals(3, value.size());  value.clear(); Assert."<AssertPlaceHolder>"; }
size() { return this.values.size(); }
[*] target: assertEquals(0, value.size())
[-] pred: org. junit. Assert. assertEquals ( 0, value. size() )
************************************
************************************
[+] input: testValue() { NullValue value1 = NullValue.get(); NullValue value2 = NullValue.get();  Assert.assertEquals(value1, value2); Assert.assertEquals(value1.value(), value2.value()); Assert.assertNull(value1.value()); Assert."<AssertPlaceHolder>"; }
value() { return null; }
[*] target: assertNull(value2.value())
[-] pred: org. junit. Assert. assertNull ( value2. value() )
************************************
************************************
[+] input: testEquals() { StringValue value1 = new StringValue("test"); StringValue value2 = new StringValue("test");  Assert.assertEquals(value1, value2);  DoubleValue value3 = new DoubleValue(1.1); Assert."<AssertPlaceHolder>"; }
equals(Object obj) { if (!(obj instanceof StringValue)) { return false; } return ((StringValue) obj).value.equals(this.value); }
[*] target: assertFalse(value1.equals(value3))
[-] pred: org. junit. Assert. assertFalse ( value1. equals ( value3 ) )
************************************
************************************
[+] input: testRemoteAddressWithNull() { Channel channel = null; String address = TransportUtil.remoteAddress(channel); Assert.assertNull(address);  Channel channel2 = new EmbeddedChannel(); channel2.close(); String address2 = TransportUtil.remoteAddress(channel2); Assert."<AssertPlaceHolder>"; }
remoteAddress(Channel channel) { if (channel == null || channel.remoteAddress() == null) { return null; } if (channel.remoteAddress() instanceof InetSocketAddress) { return formatAddress((InetSocketAddress) channel.remoteAddress()); } else { return channel.toString(); } }
[*] target: assertNull(address2)
[-] pred: org. junit. Assert. assertNull ( address2 )
************************************
************************************
[+] input: testRemoteConnectionIDWithNull() { Channel channel = null; ConnectionId connectionId = TransportUtil.remoteConnectionId(channel); Assert.assertNull(connectionId);  Channel channel2 = new EmbeddedChannel(); channel2.close(); ConnectionId connectionId2 = TransportUtil.remoteConnectionId(channel2); Assert."<AssertPlaceHolder>"; }
remoteConnectionId(Channel channel) { if (channel == null || channel.remoteAddress() == null) { return null; } InetSocketAddress address = (InetSocketAddress) channel.remoteAddress(); return ConnectionId.parseConnectionId(address.getHostName(), address.getPort()); }
[*] target: assertNull(connectionId2)
[-] pred: org. junit. Assert. assertNull ( connectionId2 )
************************************
************************************
[+] input: IOException { NettyTransportClient client = (NettyTransportClient) this.oneClient(); client.startSession();  Mockito.doThrow(new RuntimeException("test exception")).when(serverHandler) .handle(Mockito.any(), Mockito.anyInt(), Mockito.any());  ByteBuffer buffer = ByteBuffer.wrap(StringEncodeUtil.encode("test data")); boolean send = client.send(MessageType.MSG, 1, buffer); Assert."<AssertPlaceHolder>";  Whitebox.setInternalState(client, "timeoutFinishSession", 1000L);  Assert.assertThrows(TransportException.class, client::finishSession, e -> { Assert.assertContains("finish-response", e.getMessage()); });  Mockito.verify(serverHandler, Mockito.timeout(10_000L).times(1)) .exceptionCaught(Mockito.any(), Mockito.any()); }
send(MessageType messageType, int partition, ByteBuffer buffer) throws TransportException { if (!this.checkSendAvailable()) { return false; } this.session.sendAsync(messageType, partition, buffer); return true; }
[*] target: assertTrue(send)
[-] pred: org. junit. Assert. assertTrue ( send )
************************************
************************************
[+] input: testSubmitJob() { Map<String, String> params = new HashMap<>(); params.put(KubeSpecOptions.WORKER_INSTANCES.name(), "10"); String jobId = this.driver.submitJob("PageRank", params); HugeGraphComputerJob computerJob = this.operation.withName(KubeUtil.crName(jobId)).get(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(computerJob.getSpec().getAlgorithmName(), "PageRank"); Assert.assertEquals(computerJob.getSpec().getJobId(), jobId); }
submitJob(String algorithmName, Map<String, String> params) { HugeGraphComputerJob computerJob = new HugeGraphComputerJob(); String jobId = KubeUtil.genJobId(algorithmName); String crName = KubeUtil.crName(jobId);  ObjectMeta meta = new ObjectMetaBuilder().withNamespace(this.namespace) .withName(crName) .build(); computerJob.setMetadata(meta);  ComputerJobSpec spec = this.computerJobSpec(this.defaultSpec, params);  Map<String, String> computerConf = this.computerConf(this.defaultConf, params); this.checkComputerConf(computerConf, spec);  spec.withAlgorithmName(algorithmName) .withJobId(jobId) .withComputerConf(computerConf);  if (this.enableInternalAlgorithm && this.internalAlgorithms.contains(algorithmName)) { spec.withImage(this.internalAlgorithmImageUrl); } else if (StringUtils.isNotBlank(spec.getRemoteJarUri())) { spec.withImage(this.frameworkImageUrl); } else { String imageUrl = this.buildImageUrl(algorithmName); String jarFileDir = this.conf.get(KubeDriverOptions.JAR_FILE_DIR); String jarFile = this.buildJarFile(jarFileDir, algorithmName); spec.withImage(imageUrl) .withJarFile(jarFile); }  computerJob.setSpec(spec);  this.operation.createOrReplace(computerJob); return jobId; }
[*] target: assertNotNull(computerJob)
[-] pred: org. junit. Assert. assertNotNull ( computerJob )
************************************
************************************
[+] input: testCounting() { final ThreadSafeCounter counter = new ThreadSafeCounter(); counter.inc(); assertEquals(1, counter.getCount()); counter.inc(100); assertEquals(101, counter.getCount()); counter.dec(); assertEquals(100, counter.getCount()); counter.dec(99); "<AssertPlaceHolder>"; }
getCount() { return count.get(); }
[*] target: assertEquals(1, counter.getCount())
[-] pred: org. junit. Assert. assertEquals ( 1, counter. getCount() )
************************************
************************************
[+] input: testDeSeSchema() { final CsvRowDataDeserializationSchema expectedDeSer = new CsvRowDataDeserializationSchema.Builder( testFormatInfo, testTypeInformation) .setCharset("UTF-8") .setFieldDelimiter(';') .setQuoteCharacter(''') .setEscapeCharacter('\') .setNullLiteral("n/a") .build(); final Map<String, String> options = getAllOptions(); DeserializationSchema<RowData> actualDeser = createDeserializationSchema(options); assertEquals(expectedDeSer, actualDeser);  final CsvRowDataSerializationSchema expectedSer = new CsvRowDataSerializationSchema.Builder(testFormatInfo) .setCharset("UTF-8") .setFieldDelimiter(';') .setQuoteCharacter(''') .setEscapeCharacter('\') .setNullLiteral("n/a") .build(); SerializationSchema<RowData> actualSer = createSerializationSchema(options); "<AssertPlaceHolder>"; }
createSerializationSchema( Map<String, String> properties) { DescriptorProperties descriptorProperties = getValidatedProperties(properties); RowFormatInfo rowFormatInfo = getValidatedRowFormatInfo(descriptorProperties);  return buildSerializationSchema(rowFormatInfo, descriptorProperties); }
[*] target: assertEquals(expectedSer, actualSer)
[-] pred: org. junit. Assert. assertEquals ( expectedSer, actualSer )
************************************
************************************
[+] input: IOException { JsonRowDataSerializationSchema.Builder serBuilder = JsonRowDataSerializationSchema.builder(rowType); JsonRowDataSerializationSchema serializationSchema = serBuilder.setCharset(CHARSET.defaultValue()) .setTimestampFormat(ISO_8601) .build(); byte[] serialize = serializationSchema.serialize(testRowData);  ObjectMapper objectMapper = new ObjectMapper(); JsonNode expectedNode = objectMapper.readTree(testJson); JsonNode actualNode = objectMapper.readTree(new String(serialize)); "<AssertPlaceHolder>"; assertFalse(serializationSchema.skipCurrentRecord(testRowData)); }
build() { return new JsonRowDataSerializationSchema( rowType, timestampFormat, mapNullKeyMode, mapNullKeyLiteral, charset, objectMapper, ignoreErrors); }
[*] target: assertEquals(expectedNode, actualNode)
[-] pred: org. junit. Assert. assertEquals ( expectedNode, actualNode )
************************************
************************************
[+] input: Exception { TubeClientConfig clientConfig = mock(TubeClientConfig.class); PowerMockito.mockStatic(AddressUtils.class); PowerMockito.when(AddressUtils.getLocalAddress()).thenReturn("127.0.0.1");  when(clientConfig.getMasterInfo()).thenReturn(new MasterInfo("127.0.0.1:18080")); ConsumerConfig config = new ConsumerConfig("127.0.0.1:18080", "test"); ClientFactory clientFactory = new NettyClientFactory(); TubeBaseSessionFactory factory = new TubeBaseSessionFactory(clientFactory, clientConfig); SimplePushMessageConsumer consumer = new SimplePushMessageConsumer(factory, config); MessageFetchManager fetchManager = new MessageFetchManager(config, consumer);  Assert.assertFalse(fetchManager.isShutdown()); fetchManager.startFetchWorkers(); fetchManager.stopFetchWorkers(true); Assert."<AssertPlaceHolder>"; }
isShutdown() { return this.managerStatus.get() == 0; }
[*] target: assertTrue(fetchManager.isShutdown())
[-] pred: org. junit. Assert. assertTrue ( fetchManager. isShutdown() )
************************************
************************************
[+] input: Exception { RpcServiceFactory rpcServiceFactory = mock(RpcServiceFactory.class); when(rpcServiceFactory.getForbiddenAddrMap()).thenReturn(new ConcurrentHashMap<String, Long>()); when(rpcServiceFactory.getUnavailableBrokerMap()).thenReturn(new ConcurrentHashMap<Integer, Long>());  TubeClientConfig config = mock(TubeClientConfig.class); when(config.getSessionMaxAllowedDelayedMsgCount()).thenReturn(1000L);  DefaultBrokerRcvQltyStats stats = new DefaultBrokerRcvQltyStats(rpcServiceFactory, config); stats.startBrokerStatistic(); assertFalse(stats.isStopped());  stats.addSendStatistic(0); stats.addReceiveStatistic(0, true);  stats.statisticDltBrokerStatus();  // Test getAllowedBrokerPartitions Map<Integer, List<Partition>> brokerPartList = new HashMap<>(); List<Partition> partitions = new ArrayList<>(); partitions.add(new Partition(new BrokerInfo("0:127.0.0.1:18080"), "test_topic", 1)); brokerPartList.put(0, partitions);  List<Partition> actualPartitions = stats.getAllowedBrokerPartitions(brokerPartList); assertEquals(1, actualPartitions.size()); assertEquals(1, actualPartitions.get(0).getPartitionId());  // Unregister and stop statistic server stats.removeUnRegisteredBroker(new ArrayList<Integer>()); stats.stopBrokerStatistic(); "<AssertPlaceHolder>"; }
isStopped() { return (this.statusId.get() > 0); }
[*] target: assertTrue(stats.isStopped())
[-] pred: org. junit. Assert. assertTrue ( stats. isStopped() )
************************************
************************************
[+] input: Exception { final BrokerConfig brokerConfig = new BrokerConfig(); Path configUrl = Paths.get(Objects.requireNonNull( getClass().getClassLoader().getResource("broker_audit_prom_1.ini")).toURI()); brokerConfig.loadFromFile(configUrl.toString());  final ADConfig auditConfig = brokerConfig.getAuditConfig(); Assert.assertTrue(auditConfig.isAuditEnable()); Assert.assertEquals(auditConfig.getAuditIdProduce(), 3); Assert.assertEquals(auditConfig.getAuditIdConsume(), 4); Assert.assertEquals(auditConfig.getAuditCacheMaxRows(), 20000); Assert.assertEquals(auditConfig.getAuditCacheFilePath(), "/data/inlong/audit/test"); HashSet<String> valueSet = new HashSet<>(Arrays.asList("127.0.0.2:10081", "127.0.0.3:10081")); Assert.assertEquals(auditConfig.getAuditProxyAddrSet(), valueSet);  final PrometheusConfig promConfig = brokerConfig.getPrometheusConfig(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(promConfig.getPromHttpPort(), 9088); Assert.assertEquals(promConfig.getPromClusterName(), "Test"); }
isPromEnable() { return this.prometheusConfig.isPromEnable(); }
[*] target: assertTrue(promConfig.isPromEnable())
[-] pred: org. junit. Assert. assertTrue ( promConfig. isPromEnable ( ) )
************************************
************************************
[+] input: Exception { Try<Integer> tr = Try.of(() -> 1).andFinally(() -> System.out.println("Finally")); assertTrue(tr.isSuccess());  Try.CheckedRunnable er = () -> {throw new FileNotFoundException();}; tr = Try.of(() -> 1).andFinally(er); "<AssertPlaceHolder>"; }
isFailure() {return !isSuccess();}
[*] target: assertTrue(tr.isFailure())
[-] pred: org. junit. Assert. assertTrue ( tr. isFailure() )
************************************
************************************
[+] input: Exception { Try.of(() -> 1).peek(t -> assertTrue(t.isSuccess()));  Try<Integer> tr = Try.of(() -> 1).peek(t -> {throw new NoPermissionException();}); "<AssertPlaceHolder>"; }
isFailure() {return !isSuccess();}
[*] target: assertTrue(tr.isFailure())
[-] pred: org. junit. Assert. assertTrue ( tr. isFailure() )
************************************
************************************
[+] input: keyPairWithPasswd() { try { SM2Util instance = new SM2Util(); KeyPair keyPair = instance.generatekeyPair(); String privateKeyPem = SM2Util.pemFrom(keyPair.getPrivate(), passwd); Files.write(Paths.get(encryptedprivFileName), privateKeyPem.getBytes()); PrivateKey key = SM2Util.loadPrivFromFile(encryptedprivFileName, passwd); Assert."<AssertPlaceHolder>"; Assert.assertEquals(keyEqualHint, keyPair.getPrivate(), key); } catch (Exception e) { e.printStackTrace(); Assert.fail(exceptionHappened); } }
loadPrivFromFile(String filename, String password) throws IOException, OperatorCreationException, PKCSException { return loadPriv(password, () -> { try { return new FileReader(filename); } catch (FileNotFoundException e) { throw new RuntimeException("Private key "" + filename + "" not found", e); } }); }
[*] target: assertNotNull(key)
[-] pred: org. junit. Assert. assertNotNull ( key )
************************************
************************************
[+] input: Exception { Map<String, Object> javagm = this.configMap.get("javagm"); Object testdata = javagm.get("testdata");  String cert = (String) ((Map<String, Object>) testdata).get("cert"); Assert.assertNotNull(cert);  X509Certificate certificate = SM2Util.loadX509CertificateFromString(cert); Assert."<AssertPlaceHolder>"; Assert.assertEquals("SM3WITHSM2", certificate.getSigAlgName()); }
loadX509CertificateFromString(String cert) throws IOException, CertificateException, NoSuchProviderException { try (InputStream in = new ByteArrayInputStream(cert.getBytes())) { CertificateFactory cf = CertificateFactory.getInstance("X.509", BouncyCastleProvider.PROVIDER_NAME); return (X509Certificate) cf.generateCertificate(in); } }
[*] target: assertNotNull(certificate)
[-] pred: org. junit. Assert. assertNotNull ( certificate )
************************************
************************************
[+] input: Exception { Topic expectedResponse = Topic.newBuilder() .setName(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartitionConfig(Topic.PartitionConfig.newBuilder().build()) .setRetentionConfig(Topic.RetentionConfig.newBuilder().build()) .setReservationConfig(Topic.ReservationConfig.newBuilder().build()) .build(); mockAdminService.addResponse(expectedResponse);  Topic topic = Topic.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Topic actualResponse = client.updateTopic(topic, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateTopicRequest actualRequest = ((UpdateTopicRequest) actualRequests.get(0));  Assert.assertEquals(topic, actualRequest.getTopic()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateTopic(Topic topic, FieldMask updateMask) { UpdateTopicRequest request = UpdateTopicRequest.newBuilder().setTopic(topic).setUpdateMask(updateMask).build(); return updateTopic(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { Subscription expectedResponse = Subscription.newBuilder() .setName(SubscriptionName.of("[PROJECT]", "[LOCATION]", "[SUBSCRIPTION]").toString()) .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setDeliveryConfig(Subscription.DeliveryConfig.newBuilder().build()) .setExportConfig(ExportConfig.newBuilder().build()) .build(); mockAdminService.addResponse(expectedResponse);  Subscription subscription = Subscription.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Subscription actualResponse = client.updateSubscription(subscription, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateSubscriptionRequest actualRequest = ((UpdateSubscriptionRequest) actualRequests.get(0));  Assert.assertEquals(subscription, actualRequest.getSubscription()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateSubscription(Subscription subscription, FieldMask updateMask) { UpdateSubscriptionRequest request = UpdateSubscriptionRequest.newBuilder() .setSubscription(subscription) .setUpdateMask(updateMask) .build(); return updateSubscription(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { SeekSubscriptionResponse expectedResponse = SeekSubscriptionResponse.newBuilder().build(); Operation resultOperation = Operation.newBuilder() .setName("seekSubscriptionTest") .setDone(true) .setResponse(Any.pack(expectedResponse)) .build(); mockAdminService.addResponse(resultOperation);  SeekSubscriptionRequest request = SeekSubscriptionRequest.newBuilder() .setName(SubscriptionName.of("[PROJECT]", "[LOCATION]", "[SUBSCRIPTION]").toString()) .build();  SeekSubscriptionResponse actualResponse = client.seekSubscriptionAsync(request).get(); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); SeekSubscriptionRequest actualRequest = ((SeekSubscriptionRequest) actualRequests.get(0));  Assert.assertEquals(request.getName(), actualRequest.getName()); Assert.assertEquals(request.getNamedTarget(), actualRequest.getNamedTarget()); Assert.assertEquals(request.getTimeTarget(), actualRequest.getTimeTarget()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
seekSubscriptionAsync( SeekSubscriptionRequest request) { return seekSubscriptionOperationCallable().futureCall(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { Reservation expectedResponse = Reservation.newBuilder() .setName(ReservationName.of("[PROJECT]", "[LOCATION]", "[RESERVATION]").toString()) .setThroughputCapacity(-1174790353) .build(); mockAdminService.addResponse(expectedResponse);  Reservation reservation = Reservation.newBuilder().build(); FieldMask updateMask = FieldMask.newBuilder().build();  Reservation actualResponse = client.updateReservation(reservation, updateMask); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockAdminService.getRequests(); Assert.assertEquals(1, actualRequests.size()); UpdateReservationRequest actualRequest = ((UpdateReservationRequest) actualRequests.get(0));  Assert.assertEquals(reservation, actualRequest.getReservation()); Assert.assertEquals(updateMask, actualRequest.getUpdateMask()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
updateReservation(Reservation reservation, FieldMask updateMask) { UpdateReservationRequest request = UpdateReservationRequest.newBuilder() .setReservation(reservation) .setUpdateMask(updateMask) .build(); return updateReservation(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { CommitCursorResponse expectedResponse = CommitCursorResponse.newBuilder().build(); mockCursorService.addResponse(expectedResponse);  CommitCursorRequest request = CommitCursorRequest.newBuilder() .setSubscription("subscription341203229") .setPartition(-1799810326) .setCursor(Cursor.newBuilder().build()) .build();  CommitCursorResponse actualResponse = client.commitCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockCursorService.getRequests(); Assert.assertEquals(1, actualRequests.size()); CommitCursorRequest actualRequest = ((CommitCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getSubscription(), actualRequest.getSubscription()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getCursor(), actualRequest.getCursor()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
commitCursor(CommitCursorRequest request) { return commitCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeMessageStatsResponse expectedResponse = ComputeMessageStatsResponse.newBuilder() .setMessageCount(-1229303081) .setMessageBytes(-1229929933) .setMinimumPublishTime(Timestamp.newBuilder().build()) .setMinimumEventTime(Timestamp.newBuilder().build()) .build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeMessageStatsRequest request = ComputeMessageStatsRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .setStartCursor(Cursor.newBuilder().build()) .setEndCursor(Cursor.newBuilder().build()) .build();  ComputeMessageStatsResponse actualResponse = client.computeMessageStats(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeMessageStatsRequest actualRequest = ((ComputeMessageStatsRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getStartCursor(), actualRequest.getStartCursor()); Assert.assertEquals(request.getEndCursor(), actualRequest.getEndCursor()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeMessageStats(ComputeMessageStatsRequest request) { return computeMessageStatsCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeHeadCursorResponse expectedResponse = ComputeHeadCursorResponse.newBuilder().setHeadCursor(Cursor.newBuilder().build()).build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeHeadCursorRequest request = ComputeHeadCursorRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .build();  ComputeHeadCursorResponse actualResponse = client.computeHeadCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeHeadCursorRequest actualRequest = ((ComputeHeadCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeHeadCursor(ComputeHeadCursorRequest request) { return computeHeadCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: Exception { ComputeTimeCursorResponse expectedResponse = ComputeTimeCursorResponse.newBuilder().setCursor(Cursor.newBuilder().build()).build(); mockTopicStatsService.addResponse(expectedResponse);  ComputeTimeCursorRequest request = ComputeTimeCursorRequest.newBuilder() .setTopic(TopicName.of("[PROJECT]", "[LOCATION]", "[TOPIC]").toString()) .setPartition(-1799810326) .setTarget(TimeTarget.newBuilder().build()) .build();  ComputeTimeCursorResponse actualResponse = client.computeTimeCursor(request); Assert."<AssertPlaceHolder>";  List<AbstractMessage> actualRequests = mockTopicStatsService.getRequests(); Assert.assertEquals(1, actualRequests.size()); ComputeTimeCursorRequest actualRequest = ((ComputeTimeCursorRequest) actualRequests.get(0));  Assert.assertEquals(request.getTopic(), actualRequest.getTopic()); Assert.assertEquals(request.getPartition(), actualRequest.getPartition()); Assert.assertEquals(request.getTarget(), actualRequest.getTarget()); Assert.assertTrue( channelProvider.isHeaderSent( ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), GaxGrpcProperties.getDefaultApiClientHeaderPattern())); }
computeTimeCursor(ComputeTimeCursorRequest request) { return computeTimeCursorCallable().call(request); }
[*] target: assertEquals(expectedResponse, actualResponse)
[-] pred: org. junit. Assert. assertEquals ( expectedResponse, actualResponse )
************************************
************************************
[+] input: print_json_diffInputNotNullZeroNotNullZeroNotNullOutputNotNull() {  // Arrange final LogBuffer buffer = new LogBuffer(); final long len = 0L; final String columnName = ","; final int columnIndex = 0; final String charsetName = "1a 2b 3c";  // Act final StringBuilder actual = JsonDiffConversion.print_json_diff(buffer, len, columnName, columnIndex, charsetName);  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertEquals(",", actual.toString()); }
print_json_diff(LogBuffer buffer, long len, String columnName, int columnIndex, String charsetName) { int position = buffer.position(); List<String> operation_names = new ArrayList<String>(); while (buffer.hasRemaining()) { int operation_int = buffer.getUint8(); if (operation_int >= JSON_DIFF_OPERATION_COUNT) { throw new IllegalArgumentException("reading operation type (invalid operation code)"); }  // skip path long path_length = buffer.getPackedLong(); if (path_length > len) { throw new IllegalArgumentException("skipping path"); }  // compute operation name byte[] lastP = buffer.getData(buffer.position() + (int) path_length - 1, 1); String operation_name = json_diff_operation_name(operation_int, lastP[0]); operation_names.add(operation_name);  buffer.forward((int) path_length); // skip value if (operation_int != DIFF_OPERATION_REMOVE) { long value_length = buffer.getPackedLong(); if (value_length > len) { throw new IllegalArgumentException("skipping path"); }  buffer.forward((int) value_length); } }  // Print function names in reverse order. StringBuilder builder = new StringBuilder(); for (int i = operation_names.size() - 1; i >= 0; i--) { if (i == 0 || operation_names.get(i - 1) != operation_names.get(i)) { builder.append(operation_names.get(i)).append("("); } }  // Print column id if (columnName != null) { builder.append(columnName); } else { builder.append("@").append(columnIndex); }  // In case this vector is empty (a no-op), make an early return // after printing only the column name if (operation_names.size() == 0) { return builder; }  // Print comma between column name and next function argument builder.append(", "); // Print paths and values. buffer.position(position); int diff_i = 0; while (buffer.hasRemaining()) { // Read operation int operation_int = buffer.getUint8();  // Read path length long path_length = buffer.getPackedLong(); // Print path builder.append(''').append(buffer.getFixString((int) path_length)).append(''');  if (operation_int != DIFF_OPERATION_REMOVE) { // Print comma between path and value builder.append(", "); // Read value length long value_length = buffer.getPackedLong();  Json_Value jsonValue = JsonConversion.parse_value(buffer.getUint8(), buffer, value_length - 1, charsetName); buffer.forward((int) value_length - 1); // Read value if (jsonValue.m_type == Json_enum_type.ERROR) { throw new IllegalArgumentException("parsing json value"); } StringBuilder jsonBuilder = new StringBuilder(); jsonValue.toJsonString(jsonBuilder, charsetName); builder.append(jsonBuilder); }  // Print closing parenthesis if (!buffer.hasRemaining() || operation_names.get(diff_i + 1) != operation_names.get(diff_i)) { builder.append(")"); }  if (buffer.hasRemaining()) { builder.append(", "); } diff_i++; }  return builder; }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: testRemove() { map.put(1, "a"); map.put(2, "b"); Assert.assertEquals("a", map.get(1));  Assert.assertEquals("a", map.remove(1)); Assert.assertEquals(1, map.size()); Assert.assertEquals("b", map.remove(2)); Assert.assertNull(map.remove(2)); Assert."<AssertPlaceHolder>"; }
isEmpty() { return lowestNode() != null; }
[*] target: assertTrue(map.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( map. isEmpty() )
************************************
************************************
[+] input: testTailMap() { for (int i = 0; i < 100; i++) { map.put(i, String.valueOf(i)); } SortedMap<Integer, String> tailMap = map.tailMap(21); Assert.assertEquals(79, tailMap.size()); for (int i = 21; i < 100; i++) { Assert.assertTrue(tailMap.containsKey(i)); }  SortedMap<Integer, String> tailTailMap = tailMap.tailMap(59); Assert.assertEquals(41, tailTailMap.size()); for (int i = 59; i < 100; i++) { Assert."<AssertPlaceHolder>"; }  }
containsKey(Object key) { return findClosestNode((K) key, Relation.EQ) != null; }
[*] target: assertTrue(tailTailMap.containsKey(i))
[-] pred: org. junit. Assert. assertTrue ( tailTailMap. containsKey ( i ) )
************************************
************************************
[+] input: () { OffsetBitSet b1 = new OffsetBitSet(); OffsetBitSet b2 = new OffsetBitSet();  b1.add(1); b2.add(1);  assertEquals(b1.hashCode(), b2.hashCode()); assertEquals(b1, b2);  // temporarily setting/clearing a single bit causing // the backing array to grow b2.add(420); b2.deactivate(420);  assertEquals(b1.hashCode(), b2.hashCode()); assertEquals(b1, b2);  b1.add(810); b1.deactivate(810);  assertEquals(b1.hashCode(), b2.hashCode()); assertEquals(b1, b2);  OffsetBitSet o1 = new OffsetBitSet(100, 200); OffsetBitSet o2 = new OffsetBitSet(100, 200);  o1.add(100); o2.add(100);  assertEquals(o1.hashCode(), o2.hashCode()); assertEquals(o1, o2);  o2.add(420); o2.deactivate(420);  assertEquals(o1.hashCode(), o2.hashCode()); assertEquals(o1, o2);  o1.add(810); o1.deactivate(810);  "<AssertPlaceHolder>"; assertEquals(o1, o2); }
hashCode () { final int word = (length() >>> 6) - offset; long hash = offset; for (int i = 0; i <= word; i++) { hash += bits[i]; } return (int)(hash ^ hash >>> 32); }
[*] target: assertEquals(o1.hashCode(), o2.hashCode())
[-] pred: org. junit. Assert. assertEquals ( o1. hashCode ( ), o2. hashCode ( ) )
************************************
************************************
[+] input: () { OffsetBitSet b1 = new OffsetBitSet(); b1.add(50); b1.add(100); b1.add(150); b1.changeOffset(1000);  OffsetBitSet b2 = new OffsetBitSet(b1); assertNotSame(b1, b2); assertTrue(b1.containsAll(b2)); "<AssertPlaceHolder>"; assertEquals(b1, b2); }
containsAll (OffsetBitSet other) { if (offset == other.offset) { long[] bits = this.bits; long[] otherBits = other.bits; int otherBitsLength = otherBits.length; int bitsLength = bits.length;  for (int i = bitsLength; i < otherBitsLength; i++) { if (otherBits[i] != 0) { return false; } } for (int i = Math.min(bitsLength, otherBitsLength) - 1; i >= 0; i--) { if ((bits[i] & otherBits[i]) != otherBits[i]) { return false; } } return true; } else return ((PrimitiveCollection.OfInt)this).containsAll(other); }
[*] target: assertTrue(b2.containsAll(b1))
[-] pred: org. junit. Assert. assertTrue ( b2. containsAll ( b1 ) )
************************************
************************************
[+] input: testTimeSync() { Message message = codec.decode(createMessageContext(SimpleMqttMessage .builder() .topic("/product1/device1/time-sync") .payload(Unpooled.wrappedBuffer("{"messageId":"test"}" .getBytes())) .build())) .blockFirst();  Assert."<AssertPlaceHolder>";  Assert.assertNotNull(currentReply);  Assert.assertEquals(((MqttMessage) currentReply).getTopic(), "/product1/device1/time-sync/reply"); Assert.assertTrue(currentReply.payloadAsString().contains("timestamp"));  }
decode(@Nonnull MessageDecodeContext context) { MqttMessage message = (MqttMessage) context.getMessage(); byte[] payload = message.payloadAsBytes();  return TopicMessageCodec .decode(mapper, TopicMessageCodec.removeProductPath(message.getTopic()), payload) //如果不能直接解码，可能是其他设备功能 .switchIfEmpty(FunctionalTopicHandlers .handle(context.getDevice(), message.getTopic().split("/"), payload, mapper, reply -> doReply(context, reply))) ;  }
[*] target: assertNull(message)
[-] pred: org. junit. Assert. assertNull ( message )
************************************
************************************
[+] input: fieldsFor2() { String klass = Class2.class.getCanonicalName(); List<FieldData> classFields = classData.fieldsFor(klass); "<AssertPlaceHolder>"; assertEquals(klass, classFields.get(0).hostClass()); assertEquals(klass, classFields.get(1).hostClass()); assertEquals(klass, classFields.get(2).hostClass()); assertEquals("[" + PREFIX + "2.f1: int, " + PREFIX + "2.f2: int, " + PREFIX + "2.f3: int]", classFields.toString()); }
fieldsFor(String klass) { List<FieldData> r = new ArrayList<>(); for (FieldData f : fields) { if (f.hostClass().equals(klass)) { r.add(f); } } return r; }
[*] target: assertEquals(3, classFields.size())
[-] pred: org. junit. Assert. assertEquals ( 3, classFields. size ( ) )
************************************
************************************
[+] input: fieldsFor3() { String klass = Class3.class.getCanonicalName(); List<FieldData> classFields = classData.fieldsFor(klass); "<AssertPlaceHolder>"; assertEquals(klass, classFields.get(0).hostClass()); assertEquals(klass, classFields.get(1).hostClass()); assertEquals(klass, classFields.get(2).hostClass()); assertEquals(klass, classFields.get(3).hostClass()); assertEquals("[" + PREFIX + "3.f1: int, " +  PREFIX + "3.f2: int, " + PREFIX + "3.f3: int, " + PREFIX + "3.f4: java.lang.Object]", classFields.toString()); }
fieldsFor(String klass) { List<FieldData> r = new ArrayList<>(); for (FieldData f : fields) { if (f.hostClass().equals(klass)) { r.add(f); } } return r; }
[*] target: assertEquals(4, classFields.size())
[-] pred: org. junit. Assert. assertEquals ( 4, classFields. size ( ) )
************************************
************************************
[+] input: UnknownHostException { // Try connecting connectionStates.connecting(nodeId1, time.milliseconds(), "localhost", ClientDnsLookup.DEFAULT);  time.sleep(100);  connectionStates.authenticationFailed(nodeId1, time.milliseconds(), new AuthenticationException("No path to CA for certificate!")); time.sleep(1000); assertEquals(connectionStates.connectionState(nodeId1), ConnectionState.AUTHENTICATION_FAILED); assertTrue(connectionStates.authenticationException(nodeId1) instanceof AuthenticationException); assertFalse(connectionStates.hasReadyNodes(time.milliseconds())); assertFalse(connectionStates.canConnect(nodeId1, time.milliseconds()));  time.sleep(connectionStates.connectionDelay(nodeId1, time.milliseconds()) + 1);  assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds())); connectionStates.ready(nodeId1); "<AssertPlaceHolder>"; }
authenticationException(String id) { NodeConnectionState state = nodeState.get(id); return state != null ? state.authenticationException : null; }
[*] target: assertNull(connectionStates.authenticationException(nodeId1))
[-] pred: org. junit. Assert. assertNull ( connectionStates. authenticationException(nodeId1) )
************************************
************************************
[+] input: Exception { client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE)); coordinator.ensureCoordinatorReady(time.timer(Long.MAX_VALUE));  int numRequests = 1000; TopicPartition tp = new TopicPartition("foo", 0); final AtomicInteger responses = new AtomicInteger(0);  for (int i = 0; i < numRequests; i++) { Map<TopicPartition, OffsetAndMetadata> offsets = singletonMap(tp, new OffsetAndMetadata(i)); coordinator.commitOffsetsAsync(offsets, new OffsetCommitCallback() { @Override public void onComplete(Map<TopicPartition, OffsetAndMetadata> offsets, Exception exception) { responses.incrementAndGet(); Throwable cause = exception.getCause(); assertTrue("Unexpected exception cause type: " + (cause == null ? null : cause.getClass()), cause instanceof DisconnectException); } }); }  coordinator.markCoordinatorUnknown(); consumerClient.pollNoWakeup(); coordinator.invokeCompletedOffsetCommitCallbacks(); "<AssertPlaceHolder>"; }
invokeCompletedOffsetCommitCallbacks() { while (true) { OffsetCommitCompletion completion = completedOffsetCommits.poll(); if (completion == null) break; completion.invoke(); } }
[*] target: assertEquals(numRequests, responses.get())
[-] pred: org. junit. Assert. assertEquals ( numRequests, responses. get ( ) )
************************************
************************************
[+] input: testBasicCompletion() { RequestFuture<String> future = new RequestFuture<>(); String value = "foo"; future.complete(value); assertTrue(future.isDone()); "<AssertPlaceHolder>"; }
value() { if (!succeeded()) throw new IllegalStateException("Attempt to retrieve value from future which hasn't successfully completed"); return (T) result.get(); }
[*] target: assertEquals(value, future.value())
[-] pred: org. junit. Assert. assertEquals ( value, future. value() )
************************************
************************************
[+] input: testVoidFuture() { RequestFuture<Void> future = new RequestFuture<>(); future.complete(null); assertTrue(future.isDone()); "<AssertPlaceHolder>"; }
value() { if (!succeeded()) throw new IllegalStateException("Attempt to retrieve value from future which hasn't successfully completed"); return (T) result.get(); }
[*] target: assertNull(future.value())
[-] pred: org. junit. Assert. assertNull ( future. value() )
************************************
************************************
[+] input: testChecksumNullForMagicV2() { ProducerBatch batch = new ProducerBatch(new TopicPartition("topic", 1), memoryRecordsBuilder, now); FutureRecordMetadata future = batch.tryAppend(now, null, new byte[10], Record.EMPTY_HEADERS, null, now); "<AssertPlaceHolder>"; assertNull(future.checksumOrNull()); }
tryAppend(long timestamp, byte[] key, byte[] value, Header[] headers, Callback callback, long now) { if (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) { return null; } else { Long checksum = this.recordsBuilder.append(timestamp, key, value, headers); this.maxRecordSize = Math.max(this.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(), recordsBuilder.compressionType(), key, value, headers)); this.lastAppendTime = now; FutureRecordMetadata future = new FutureRecordMetadata(this.produceFuture, this.recordCount, timestamp, checksum, key == null ? -1 : key.length, value == null ? -1 : value.length, Time.SYSTEM); // we have to keep every future returned to the users in case the batch needs to be // split to several new batches and resent. thunks.add(new Thunk(callback, future)); this.recordCount++; return future; } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: testAppendedChecksumMagicV0AndV1() { for (byte magic : Arrays.asList(MAGIC_VALUE_V0, MAGIC_VALUE_V1)) { MemoryRecordsBuilder builder = MemoryRecords.builder(ByteBuffer.allocate(128), magic, CompressionType.NONE, TimestampType.CREATE_TIME, 0L); ProducerBatch batch = new ProducerBatch(new TopicPartition("topic", 1), builder, now); byte[] key = "hi".getBytes(); byte[] value = "there".getBytes();  FutureRecordMetadata future = batch.tryAppend(now, key, value, Record.EMPTY_HEADERS, null, now); "<AssertPlaceHolder>"; byte attributes = LegacyRecord.computeAttributes(magic, CompressionType.NONE, TimestampType.CREATE_TIME); long expectedChecksum = LegacyRecord.computeChecksum(magic, attributes, now, key, value); assertEquals(expectedChecksum, future.checksumOrNull().longValue()); } }
tryAppend(long timestamp, byte[] key, byte[] value, Header[] headers, Callback callback, long now) { if (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) { return null; } else { Long checksum = this.recordsBuilder.append(timestamp, key, value, headers); this.maxRecordSize = Math.max(this.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(), recordsBuilder.compressionType(), key, value, headers)); this.lastAppendTime = now; FutureRecordMetadata future = new FutureRecordMetadata(this.produceFuture, this.recordCount, timestamp, checksum, key == null ? -1 : key.length, value == null ? -1 : value.length, Time.SYSTEM); // we have to keep every future returned to the users in case the batch needs to be // split to several new batches and resent. thunks.add(new Thunk(callback, future)); this.recordCount++; return future; } }
[*] target: assertNotNull(future)
[-] pred: org. junit. Assert. assertNotNull ( future )
************************************
************************************
[+] input: IOException { RecordHeaders headers = new RecordHeaders(); headers.add(new RecordHeader("key", "value".getBytes())); headers.add(new RecordHeader("key1", "key1value".getBytes())); headers.add(new RecordHeader("key", "value2".getBytes())); headers.add(new RecordHeader("key2", "key2value".getBytes()));   Iterator<Header> keyHeaders = headers.headers("key").iterator(); assertHeader("key", "value", keyHeaders.next()); assertHeader("key", "value2", keyHeaders.next()); assertFalse(keyHeaders.hasNext());  keyHeaders = headers.headers("key1").iterator(); assertHeader("key1", "key1value", keyHeaders.next()); assertFalse(keyHeaders.hasNext());  keyHeaders = headers.headers("key2").iterator(); assertHeader("key2", "key2value", keyHeaders.next()); "<AssertPlaceHolder>";  }
hasNext() { return original.hasNext(); }
[*] target: assertFalse(keyHeaders.hasNext())
[-] pred: org. junit. Assert. assertFalse ( keyHeaders. hasNext ( ) )
************************************
************************************
[+] input: testSetLogAppendTimeV1() { MemoryRecords records = MemoryRecords.withRecords(RecordBatch.MAGIC_VALUE_V1, 0L, CompressionType.GZIP, TimestampType.CREATE_TIME, new SimpleRecord(1L, "a".getBytes(), "1".getBytes()), new SimpleRecord(2L, "b".getBytes(), "2".getBytes()), new SimpleRecord(3L, "c".getBytes(), "3".getBytes()));  long logAppendTime = 15L;  ByteBufferLegacyRecordBatch batch = new ByteBufferLegacyRecordBatch(records.buffer()); batch.setMaxTimestamp(TimestampType.LOG_APPEND_TIME, logAppendTime); assertEquals(TimestampType.LOG_APPEND_TIME, batch.timestampType()); assertEquals(logAppendTime, batch.maxTimestamp()); assertTrue(batch.isValid());  List<MutableRecordBatch> recordBatches = Utils.toList(records.batches().iterator()); assertEquals(1, recordBatches.size()); assertEquals(TimestampType.LOG_APPEND_TIME, recordBatches.get(0).timestampType()); assertEquals(logAppendTime, recordBatches.get(0).maxTimestamp());  for (Record record : records.records()) "<AssertPlaceHolder>"; }
timestamp() { return outerRecord().timestamp(); }
[*] target: assertEquals(logAppendTime, record.timestamp())
[-] pred: org. junit. Assert. assertEquals ( logAppendTime, record. timestamp() )
************************************
************************************
[+] input: IOException { String dest = "1"; int numChunks = 4; int chunkSize = 32; int totalSize = numChunks * chunkSize;  Queue<Send> sends = new LinkedList<>(); ByteBuffer[] chunks = new ByteBuffer[numChunks];  for (int i = 0; i < numChunks; i++) { ByteBuffer buffer = ByteBuffer.wrap(TestUtils.randomBytes(chunkSize)); chunks[i] = buffer; sends.add(new ByteBufferSend(dest, buffer)); }  MultiRecordsSend send = new MultiRecordsSend(dest, sends); assertEquals(totalSize, send.size());  for (int i = 0; i < numChunks; i++) { assertEquals(numChunks - i, send.numResidentSends()); NonOverflowingByteBufferChannel out = new NonOverflowingByteBufferChannel(chunkSize); send.writeTo(out); out.close(); assertEquals(chunks[i], out.buffer()); }  assertEquals(0, send.numResidentSends()); "<AssertPlaceHolder>"; }
completed() { return current == null; }
[*] target: assertTrue(send.completed())
[-] pred: org. junit. Assert. assertTrue ( send. completed() )
************************************
************************************
[+] input: testMixedTransactionalData() { final long producerId = 15L; final short producerEpoch = 5; final int sequence = 10; final String transactionalId = "txnlId";  final MemoryRecords nonTxnRecords = MemoryRecords.withRecords(CompressionType.NONE, new SimpleRecord("foo".getBytes())); final MemoryRecords txnRecords = MemoryRecords.withTransactionalRecords(CompressionType.NONE, producerId, producerEpoch, sequence, new SimpleRecord("bar".getBytes()));  final Map<TopicPartition, MemoryRecords> recordsByPartition = new LinkedHashMap<>(); recordsByPartition.put(new TopicPartition("foo", 0), txnRecords); recordsByPartition.put(new TopicPartition("foo", 1), nonTxnRecords);  final ProduceRequest.Builder builder = ProduceRequest.Builder.forMagic(RecordVersion.current().value, (short) -1, 5000, recordsByPartition, transactionalId);  final ProduceRequest request = builder.build(); assertTrue(request.hasTransactionalRecords()); "<AssertPlaceHolder>"; }
hasIdempotentRecords() { return hasIdempotentRecords; }
[*] target: assertTrue(request.hasIdempotentRecords())
[-] pred: org. junit. Assert. assertTrue ( request. hasIdempotentRecords ( ) )
************************************
************************************
[+] input: testMixedIdempotentData() { final long producerId = 15L; final short producerEpoch = 5; final int sequence = 10;  final MemoryRecords nonTxnRecords = MemoryRecords.withRecords(CompressionType.NONE, new SimpleRecord("foo".getBytes())); final MemoryRecords txnRecords = MemoryRecords.withIdempotentRecords(CompressionType.NONE, producerId, producerEpoch, sequence, new SimpleRecord("bar".getBytes()));  final Map<TopicPartition, MemoryRecords> recordsByPartition = new LinkedHashMap<>(); recordsByPartition.put(new TopicPartition("foo", 0), txnRecords); recordsByPartition.put(new TopicPartition("foo", 1), nonTxnRecords);  final ProduceRequest.Builder builder = ProduceRequest.Builder.forMagic(RecordVersion.current().value, (short) -1, 5000, recordsByPartition, null);  final ProduceRequest request = builder.build(); assertFalse(request.hasTransactionalRecords()); "<AssertPlaceHolder>"; }
hasIdempotentRecords() { return hasIdempotentRecords; }
[*] target: assertTrue(request.hasIdempotentRecords())
[-] pred: org. junit. Assert. assertTrue ( request. hasIdempotentRecords ( ) )
************************************
************************************
[+] input: testToken() { OAuthBearerTokenCallback callback = new OAuthBearerTokenCallback(); callback.token(TOKEN); assertSame(TOKEN, callback.token()); assertNull(callback.errorCode()); assertNull(callback.errorDescription()); "<AssertPlaceHolder>"; }
errorUri() { return errorUri; }
[*] target: assertNull(callback.errorUri())
[-] pred: org. junit. Assert. assertNull ( callback. errorUri() )
************************************
************************************
[+] input: testError() { String errorStatus = "errorStatus"; String errorScope = "errorScope"; String errorOpenIDConfiguration = "errorOpenIDConfiguration"; OAuthBearerValidatorCallback callback = new OAuthBearerValidatorCallback(TOKEN.value()); callback.error(errorStatus, errorScope, errorOpenIDConfiguration); assertEquals(errorStatus, callback.errorStatus()); assertEquals(errorScope, callback.errorScope()); assertEquals(errorOpenIDConfiguration, callback.errorOpenIDConfiguration()); "<AssertPlaceHolder>"; }
token() { return token; }
[*] target: assertNull(callback.token())
[-] pred: org. junit. Assert. assertNull ( callback. token() )
************************************
************************************
[+] input: testToken() { OAuthBearerValidatorCallback callback = new OAuthBearerValidatorCallback(TOKEN.value()); callback.token(TOKEN); assertSame(TOKEN, callback.token()); assertNull(callback.errorStatus()); assertNull(callback.errorScope()); "<AssertPlaceHolder>"; }
errorOpenIDConfiguration() { return errorOpenIDConfiguration; }
[*] target: assertNull(callback.errorOpenIDConfiguration())
[-] pred: org. junit. Assert. assertNull ( callback. errorOpenIDConfiguration() )
************************************
************************************
[+] input: fromGoodConfig() { ExpiringCredentialRefreshConfig expiringCredentialRefreshConfig = new ExpiringCredentialRefreshConfig( new ConfigDef().withClientSaslSupport().parse(Collections.emptyMap()), true); assertEquals(Double.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_WINDOW_FACTOR), Double.valueOf(expiringCredentialRefreshConfig.loginRefreshWindowFactor())); assertEquals(Double.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_WINDOW_JITTER), Double.valueOf(expiringCredentialRefreshConfig.loginRefreshWindowJitter())); assertEquals(Short.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_MIN_PERIOD_SECONDS), Short.valueOf(expiringCredentialRefreshConfig.loginRefreshMinPeriodSeconds())); assertEquals(Short.valueOf(SaslConfigs.DEFAULT_LOGIN_REFRESH_BUFFER_SECONDS), Short.valueOf(expiringCredentialRefreshConfig.loginRefreshBufferSeconds())); "<AssertPlaceHolder>"; }
loginRefreshReloginAllowedBeforeLogout() { return loginRefreshReloginAllowedBeforeLogout; }
[*] target: assertTrue(expiringCredentialRefreshConfig.loginRefreshReloginAllowedBeforeLogout())
[-] pred: org. junit. Assert. assertTrue ( expiringCredentialRefreshConfig. loginRefreshReloginAllowedBeforeLogout() )
************************************
************************************
[+] input: Exception { File trustStoreFile = File.createTempFile("truststore", ".jks"); Map<String, Object> serverSslConfig = TestSslUtils.createSslConfig(false, true, Mode.SERVER, trustStoreFile, "server"); SslFactory sslFactory = new SslFactory(Mode.SERVER); sslFactory.configure(serverSslConfig); //host and port are hints SSLEngine engine = sslFactory.createSslEngine("localhost", 0); "<AssertPlaceHolder>"; String[] expectedProtocols = {"TLSv1.2"}; assertArrayEquals(expectedProtocols, engine.getEnabledProtocols()); assertEquals(false, engine.getUseClientMode()); }
createSslEngine(String peerHost, int peerPort) { return createSslEngine(sslContext, peerHost, peerPort); }
[*] target: assertNotNull(engine)
[-] pred: org. junit. Assert. assertNotNull ( engine )
************************************
************************************
[+] input: testIterator() { int max = 10; List<Integer> l = new ArrayList<Integer>(); for (int i = 0; i < max; i++) l.add(i); ListIterator<Integer> iter = new ListIterator<Integer>(l); for (int i = 0; i < max; i++) { Integer value = i; assertEquals(value, iter.peek()); assertTrue(iter.hasNext()); assertEquals(value, iter.next()); } "<AssertPlaceHolder>"; }
hasNext() { switch (state) { case FAILED: throw new IllegalStateException("Iterator is in failed state"); case DONE: return false; case READY: return true; default: return maybeComputeNext(); } }
[*] target: assertFalse(iter.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iter. hasNext() )
************************************
************************************
[+] input: testTimeoutOverflow() { Timer timer = time.timer(Long.MAX_VALUE); assertEquals(Long.MAX_VALUE - timer.currentTimeMs(), timer.remainingMs()); "<AssertPlaceHolder>"; }
elapsedMs() { return currentTimeMs - startMs; }
[*] target: assertEquals(0, timer.elapsedMs())
[-] pred: org. junit. Assert. assertEquals ( 0, timer. elapsedMs() )
************************************
************************************
[+] input: testEmptyStruct() { final SchemaBuilder emptyStructSchemaBuilder = SchemaBuilder.struct(); assertEquals(0, emptyStructSchemaBuilder.fields().size()); new Struct(emptyStructSchemaBuilder);  final Schema emptyStructSchema = emptyStructSchemaBuilder.build(); "<AssertPlaceHolder>"; new Struct(emptyStructSchema); }
fields() { if (type != Type.STRUCT) throw new DataException("Cannot list fields on non-struct type"); return new ArrayList<>(fields.values()); }
[*] target: assertEquals(0, emptyStructSchema.fields().size())
[-] pred: org. junit. Assert. assertEquals ( 0, emptyStructSchema. fields ( ). size ( ) )
************************************
************************************
[+] input: testSourceTasksStdin() { EasyMock.replay(ctx);  sourceProperties.remove(FileStreamSourceConnector.FILE_CONFIG); connector.start(sourceProperties); List<Map<String, String>> taskConfigs = connector.taskConfigs(1); "<AssertPlaceHolder>"; assertNull(taskConfigs.get(0).get(FileStreamSourceConnector.FILE_CONFIG));  EasyMock.verify(ctx); }
taskConfigs(int maxTasks) { ArrayList<Map<String, String>> configs = new ArrayList<>(); // Only one input stream makes sense. Map<String, String> config = new HashMap<>(); if (filename != null) config.put(FILE_CONFIG, filename); config.put(TOPIC_CONFIG, topic); config.put(TASK_BATCH_SIZE_CONFIG, String.valueOf(batchSize)); configs.add(config); return configs; }
[*] target: assertEquals(1, taskConfigs.size())
[-] pred: org. junit. Assert. assertEquals ( 1, taskConfigs. size ( ) )
************************************
************************************
[+] input: shouldInstantiateAndConfigureExplicitlySetHeaderConverterWithCurrentClassLoader() { assertNotNull(props.get(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG)); HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNotNull(headerConverter); assertTrue(headerConverter instanceof TestHeaderConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config"));  headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertTrue(headerConverter instanceof TestHeaderConverter); this.headerConverter = (TestHeaderConverter) headerConverter;  // Validate extra configs got passed through to overridden converters assertConverterType(ConverterType.HEADER, this.headerConverter.configs); assertEquals("baz", this.headerConverter.configs.get("extra.config")); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { HeaderConverter plugin = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) plugin = getInstance(config, classPropertyName, HeaderConverter.class); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); Class<? extends HeaderConverter> klass; try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(delegatingLoader.headerConverters()) ); } plugin = newPlugin(klass); } if (plugin == null) { throw new ConnectException("Unable to instantiate the Converter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration:{}{}", System.lineSeparator(), converterConfig); plugin.configure(converterConfig); return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: shouldInstantiateAndConfigureConnectRestExtension() { props.put(WorkerConfig.REST_EXTENSION_CLASSES_CONFIG, TestConnectRestExtension.class.getName()); createConfig();  List<ConnectRestExtension> connectRestExtensions = plugins.newPlugins(config.getList(WorkerConfig.REST_EXTENSION_CLASSES_CONFIG), config, ConnectRestExtension.class); "<AssertPlaceHolder>"; assertEquals("One Rest Extension expected", 1, connectRestExtensions.size()); assertNotNull(connectRestExtensions.get(0)); assertTrue("Should be instance of TestConnectRestExtension", connectRestExtensions.get(0) instanceof TestConnectRestExtension); assertNotNull(((TestConnectRestExtension) connectRestExtensions.get(0)).configs); assertEquals(config.originals(), ((TestConnectRestExtension) connectRestExtensions.get(0)).configs); }
newPlugins(List<String> klassNames, AbstractConfig config, Class<T> pluginKlass) { List<T> plugins = new ArrayList<>(); if (klassNames != null) { for (String klassName : klassNames) { plugins.add(newPlugin(klassName, config, pluginKlass)); } } return plugins; }
[*] target: assertNotNull(connectRestExtensions)
[-] pred: org. junit. Assert. assertNotNull ( connectRestExtensions )
************************************
************************************
[+] input: shouldInstantiateAndConfigureDefaultHeaderConverter() { props.remove(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG); createConfig();  // Because it's not explicitly set on the supplied configuration, the logic to use the current classloader for the connector // will exit immediately, and so this method always returns null HeaderConverter headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.CURRENT_CLASSLOADER); assertNull(headerConverter); // But we should always find it (or the worker's default) when using the plugins classloader ... headerConverter = plugins.newHeaderConverter(config, WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, ClassLoaderUsage.PLUGINS); "<AssertPlaceHolder>"; assertTrue(headerConverter instanceof SimpleHeaderConverter); }
newHeaderConverter(AbstractConfig config, String classPropertyName, ClassLoaderUsage classLoaderUsage) { HeaderConverter plugin = null; switch (classLoaderUsage) { case CURRENT_CLASSLOADER: if (!config.originals().containsKey(classPropertyName)) { // This connector configuration does not define the header converter via the specified property name return null; } // Attempt to load first with the current classloader, and plugins as a fallback. // Note: we can't use config.getConfiguredInstance because we have to remove the property prefixes // before calling config(...) plugin = getInstance(config, classPropertyName, HeaderConverter.class); break; case PLUGINS: // Attempt to load with the plugin class loader, which uses the current classloader as a fallback. // Note that there will always be at least a default header converter for the worker String converterClassOrAlias = config.getClass(classPropertyName).getName(); Class<? extends HeaderConverter> klass; try { klass = pluginClass( delegatingLoader, converterClassOrAlias, HeaderConverter.class ); } catch (ClassNotFoundException e) { throw new ConnectException( "Failed to find any class that implements HeaderConverter and which name matches " + converterClassOrAlias + ", available header converters are: " + pluginNames(delegatingLoader.headerConverters()) ); } plugin = newPlugin(klass); } if (plugin == null) { throw new ConnectException("Unable to instantiate the Converter specified in '" + classPropertyName + "'"); }  String configPrefix = classPropertyName + "."; Map<String, Object> converterConfig = config.originalsWithPrefix(configPrefix); converterConfig.put(ConverterConfig.TYPE_CONFIG, ConverterType.HEADER.getName()); log.debug("Configuring the header converter with configuration:{}{}", System.lineSeparator(), converterConfig); plugin.configure(converterConfig); return plugin; }
[*] target: assertNotNull(headerConverter)
[-] pred: org. junit. Assert. assertNotNull ( headerConverter )
************************************
************************************
[+] input: statelessTopologyShouldNotHavePersistentStore() { final TopologyWrapper topology = new TopologyWrapper(); final ProcessorTopology processorTopology = topology.getInternalBuilder("anyAppId").build(); assertFalse(processorTopology.hasPersistentLocalStore()); "<AssertPlaceHolder>"; }
hasPersistentGlobalStore() { for (final StateStore store : globalStateStores) { if (store.persistent()) { return true; } } return false; }
[*] target: assertFalse(processorTopology.hasPersistentGlobalStore())
[-] pred: org. junit. Assert. assertFalse ( processorTopology. hasPersistentGlobalStore() )
************************************
************************************
[+] input: shouldCreateTaskStateDirectory() { final TaskId taskId = new TaskId(0, 0); final File taskDirectory = directory.directoryForTask(taskId); "<AssertPlaceHolder>"; assertTrue(taskDirectory.isDirectory()); }
directoryForTask(final TaskId taskId) { final File taskDir = new File(stateDir, taskId.toString()); if (createStateDirectory && !taskDir.exists() && !taskDir.mkdir()) { throw new ProcessorStateException( String.format("task directory [%s] doesn't exist and couldn't be created", taskDir.getPath())); } return taskDir; }
[*] target: assertTrue(taskDirectory.exists())
[-] pred: org. junit. Assert. assertTrue ( taskDirectory. exists ( ) )
************************************
************************************
[+] input: shouldGetAllStreamInstances() { final StreamsMetadata one = new StreamsMetadata(hostOne, Utils.mkSet(globalTable, "table-one", "table-two", "merged-table"), Utils.mkSet(topic1P0, topic2P1, topic4P0)); final StreamsMetadata two = new StreamsMetadata(hostTwo, Utils.mkSet(globalTable, "table-two", "table-one", "merged-table"), Utils.mkSet(topic2P0, topic1P1)); final StreamsMetadata three = new StreamsMetadata(hostThree, Utils.mkSet(globalTable, "table-three"), Collections.singleton(topic3P0));  final Collection<StreamsMetadata> actual = metadataState.getAllMetadata(); "<AssertPlaceHolder>"; assertTrue("expected " + actual + " to contain " + one, actual.contains(one)); assertTrue("expected " + actual + " to contain " + two, actual.contains(two)); assertTrue("expected " + actual + " to contain " + three, actual.contains(three)); }
getAllMetadata() { return allMetadata; }
[*] target: assertEquals(3, actual.size())
[-] pred: org. junit. Assert. assertEquals ( 3, actual. size ( ) )
************************************
************************************
[+] input: shouldCreateWriteBatches() { final String key = "a"; final Collection<KeyValue<byte[], byte[]>> records = new ArrayList<>(); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[0])).get(), serializeValue(50L))); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[3])).get(), serializeValue(100L))); final Map<KeyValueSegment, WriteBatch> writeBatchMap = bytesStore.getWriteBatches(records); "<AssertPlaceHolder>"; for (final WriteBatch batch : writeBatchMap.values()) { assertEquals(1, batch.count()); } }
getWriteBatches(final Collection<KeyValue<byte[], byte[]>> records) { // advance stream time to the max timestamp in the batch for (final KeyValue<byte[], byte[]> record : records) { final long timestamp = keySchema.segmentTimestamp(Bytes.wrap(record.key)); observedStreamTime = Math.max(observedStreamTime, timestamp); }  final Map<KeyValueSegment, WriteBatch> writeBatchMap = new HashMap<>(); for (final KeyValue<byte[], byte[]> record : records) { final long timestamp = keySchema.segmentTimestamp(Bytes.wrap(record.key)); final long segmentId = segments.segmentId(timestamp); final KeyValueSegment segment = segments.getOrCreateSegmentIfLive(segmentId, context, observedStreamTime); if (segment != null) { // This handles the case that state store is moved to a new client and does not // have the local RocksDB instance for the segment. In this case, toggleDBForBulkLoading // will only close the database and open it again with bulk loading enabled. if (!bulkLoadSegments.contains(segment)) { segment.toggleDbForBulkLoading(true); // If the store does not exist yet, the getOrCreateSegmentIfLive will call openDB that // makes the open flag for the newly created store. // if the store does exist already, then toggleDbForBulkLoading will make sure that // the store is already open here. bulkLoadSegments = new HashSet<>(segments.allSegments()); } try { final WriteBatch batch = writeBatchMap.computeIfAbsent(segment, s -> new WriteBatch()); if (record.value == null) { batch.delete(record.key); } else { batch.put(record.key, record.value); } } catch (final RocksDBException e) { throw new ProcessorStateException("Error restoring batch to store " + this.name, e); } } } return writeBatchMap; }
[*] target: assertEquals(2, writeBatchMap.size())
[-] pred: org. junit. Assert. assertEquals ( 2, writeBatchMap. size ( ) )
************************************
************************************
[+] input: shouldRestoreToByteStore() { // 0 segments initially. assertEquals(0, bytesStore.getSegments().size()); final String key = "a"; final Collection<KeyValue<byte[], byte[]>> records = new ArrayList<>(); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[0])).get(), serializeValue(50L))); records.add(new KeyValue<>(serializeKey(new Windowed<>(key, windows[3])).get(), serializeValue(100L))); bytesStore.restoreAllInternal(records);  // 2 segments are created during restoration. assertEquals(2, bytesStore.getSegments().size());  // Bulk loading is enabled during recovery. for (final KeyValueSegment segment : bytesStore.getSegments()) { Assert.assertThat(segment.getOptions().level0FileNumCompactionTrigger(), equalTo(1 << 30)); }  final List<KeyValue<Windowed<String>, Long>> expected = new ArrayList<>(); expected.add(new KeyValue<>(new Windowed<>(key, windows[0]), 50L)); expected.add(new KeyValue<>(new Windowed<>(key, windows[3]), 100L));  final List<KeyValue<Windowed<String>, Long>> results = toList(bytesStore.all()); "<AssertPlaceHolder>"; }
all() { final List<KeyValueSegment> searchSpace = segments.allSegments();  return new SegmentIterator<>(searchSpace.iterator(), keySchema.hasNextCondition(null, null, 0, Long.MAX_VALUE), null, null); }
[*] target: assertEquals(expected, results)
[-] pred: org. junit. Assert. assertEquals ( expected, results )
************************************
************************************
[+] input: testGetTaskRunDetail() { TaskRun taskRun = prepareData(); TaskRunVO existedRun = taskRunService.getTaskRunDetail(taskRun.getId()).get(); "<AssertPlaceHolder>"; assertNotNull(existedRun.getTask()); }
getTaskRunDetail(Long taskRunId) { Optional<TaskRun> taskRun = taskRunDao.fetchTaskRunById(taskRunId); return taskRun.map(this::convertToVO); }
[*] target: assertNotNull(existedRun)
[-] pred: org. junit. Assert. assertNotNull ( existedRun )
************************************
************************************
[+] input: getAppShortcutInfo_dontAllowMissing_validComponent() { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = mLauncherApps.getActivityList(null, mLoaderCursor.user) .get(0).getComponentName(); ShortcutInfo info = mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), false /* allowMissingTarget */, true); "<AssertPlaceHolder>"; assertTrue(Utilities.isLauncherAppTarget(info.intent)); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { if (user == null) { Log.d(TAG, "Null user found in getShortcutInfo"); return null; }  ComponentName componentName = intent.getComponent(); if (componentName == null) { Log.d(TAG, "Missing component found in getShortcutInfo"); return null; }  Intent newIntent = new Intent(Intent.ACTION_MAIN, null); newIntent.addCategory(Intent.CATEGORY_LAUNCHER); newIntent.setComponent(componentName); LauncherActivityInfo lai = LauncherAppsCompat.getInstance(mContext) .resolveActivity(newIntent, user); if ((lai == null) && !allowMissingTarget) { Log.d(TAG, "Missing activity found in getShortcutInfo: " + componentName); return null; }  final ShortcutInfo info = new ShortcutInfo(); info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION; info.user = user; info.intent = newIntent;  mIconCache.getTitleAndIcon(info, lai, useLowResIcon); if (mIconCache.isDefaultIcon(info.iconBitmap, user)) { loadIcon(info); }  if (lai != null) { AppInfo.updateRuntimeFlagsForActivityTarget(info, lai); }  // from the db if (TextUtils.isEmpty(info.title)) { info.title = getTitle(); }  // fall back to the class name of the activity if (info.title == null) { info.title = componentName.getClassName(); }  info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user); return info; }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: getAppShortcutInfo_allowMissing_invalidComponent() { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = new ComponentName(mContext.getPackageName(), "dummy-do"); ShortcutInfo info = mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), true  /* allowMissingTarget */, true); "<AssertPlaceHolder>"; assertTrue(Utilities.isLauncherAppTarget(info.intent)); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { if (user == null) { Log.d(TAG, "Null user found in getShortcutInfo"); return null; }  ComponentName componentName = intent.getComponent(); if (componentName == null) { Log.d(TAG, "Missing component found in getShortcutInfo"); return null; }  Intent newIntent = new Intent(Intent.ACTION_MAIN, null); newIntent.addCategory(Intent.CATEGORY_LAUNCHER); newIntent.setComponent(componentName); LauncherActivityInfo lai = LauncherAppsCompat.getInstance(mContext) .resolveActivity(newIntent, user); if ((lai == null) && !allowMissingTarget) { Log.d(TAG, "Missing activity found in getShortcutInfo: " + componentName); return null; }  final ShortcutInfo info = new ShortcutInfo(); info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION; info.user = user; info.intent = newIntent;  mIconCache.getTitleAndIcon(info, lai, useLowResIcon); if (mIconCache.isDefaultIcon(info.iconBitmap, user)) { loadIcon(info); }  if (lai != null) { AppInfo.updateRuntimeFlagsForActivityTarget(info, lai); }  // from the db if (TextUtils.isEmpty(info.title)) { info.title = getTitle(); }  // fall back to the class name of the activity if (info.title == null) { info.title = componentName.getClassName(); }  info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user); return info; }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: SemanticException { SubstringDomain assume1 = domainB.assume(YSubstringOfX, null, null, null); SubstringDomain assume2 = domainB.assume(XEndsWithY, null, null, null); SubstringDomain assume3 = domainB.assume(XStartsWithY, null, null, null);  "<AssertPlaceHolder>"; assertEquals(assume1, assume3); assertTrue(assume1.getState(x).contains(y)); assertTrue(assume1.getState(x).contains(w)); assertTrue(assume1.getState(x).contains(z)); assertTrue(assume1.getState(y).contains(z)); }
assume( ValueExpression expression, ProgramPoint src, ProgramPoint dest, SemanticOracle oracle) throws SemanticException {  /* * Assume only binary expressions */ if (expression instanceof BinaryExpression) {  BinaryExpression binaryExpression = (BinaryExpression) expression; BinaryOperator binaryOperator = binaryExpression.getOperator();  SymbolicExpression left = binaryExpression.getLeft(); SymbolicExpression right = binaryExpression.getRight();  /* * The string type is unique and can be retrieved from the type * system. */ Type strType; if (src != null) // Correct: get the string type from the program // point strType = src.getProgram().getTypes().getStringType(); else // Used in tests where src is null, get the string type from // the expression strType = left.getStaticType();  if (binaryOperator instanceof StringContains || binaryOperator instanceof StringStartsWith || binaryOperator instanceof StringEndsWith) {  /* * Evaluate only if the left operand is an identidier */  if (!(left instanceof Identifier)) return this;  if (!(right instanceof ValueExpression)) throw new SemanticException("instanceof right");  Set<SymbolicExpression> extracted = extrPlus((ValueExpression) right, src, oracle, strType); SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.add(extracted, (Identifier) left); result = result.closure(); return result.clear();  } else if (binaryOperator instanceof StringEquals) {  // case both operands are identifiers if ((left instanceof Identifier) && (right instanceof Identifier)) { SubstringDomain result = mk(lattice, mkNewFunction(function, false)); result = result.add(left, (Identifier) right); result = result.add(right, (Identifier) left); result = result.closure(); return result.clear(); } // case where only one is an identifier else if ((left instanceof Identifier) || (right instanceof Identifier)) { if (right instanceof Identifier) { // make left the identifier SymbolicExpression temp = left; left = right; right = temp; }  if (!(right instanceof ValueExpression)) throw new SemanticException("instanceof right != ValueExpression.class");  Set<SymbolicExpression> add = extrPlus((ValueExpression) right, src, oracle, strType);  SubstringDomain result = mk(lattice, mkNewFunction(function, false));  result = result.add(add, (Identifier) left); result = result.closure(); return result.clear();  } } else if (binaryOperator instanceof LogicalOr || binaryOperator instanceof LogicalAnd) {  if (!(left instanceof ValueExpression) || !(right instanceof ValueExpression)) throw new SemanticException( "!(left instanceof ValueExpression) || !(right instanceof ValueExpression)");  ValueExpression rightValueExpression = (ValueExpression) right; ValueExpression leftValueExpression = (ValueExpression) left; SubstringDomain leftDomain = assume(leftValueExpression, src, dest, oracle); SubstringDomain rightDomain = assume(rightValueExpression, src, dest, oracle);  if (binaryOperator instanceof LogicalOr) { return leftDomain.lub(rightDomain).clear(); } else { return leftDomain.glb(rightDomain).clear(); } }  }  return this; }
[*] target: assertEquals(assume1, assume2)
[-] pred: org. junit. Assert. assertEquals ( assume1, assume2 )
************************************
************************************
[+] input: testFetchingExecutorForValidCommand() { final CommandExecutor commandExecutor = factory.getCommandExecutor(new Command("leave 1")); "<AssertPlaceHolder>"; assertTrue(commandExecutor instanceof LeaveCommandExecutor); }
getCommandExecutor(final Command command) { final CommandExecutor commandExecutor = commands.get(command.getCommandName()); if (commandExecutor == null) { throw new InvalidCommandException(); } return commandExecutor; }
[*] target: assertNotNull(commandExecutor)
[-] pred: org. junit. Assert. assertNotNull ( commandExecutor )
************************************
************************************
[+] input: InterruptedException { Path file = Paths.get(getTestLog("utf8.log"));  byte[] data = Files.readAllBytes(file);  int nonLatinCharOffset = -1; for (int i = 0; i < data.length; i++) { if (data[i] < 0) { assert data[i + 1] < 0; nonLatinCharOffset = i; break; } }  assert nonLatinCharOffset >= 0;  Log log = getLogService().openLog(file, new SimpleLogFormat(StandardCharsets.UTF_8));  Pair<String, Integer> pair = log.loadContent(0, nonLatinCharOffset + 1).get();  int dataLen = pair.getSecond();  "<AssertPlaceHolder>"; assertEquals(new String(Arrays.copyOf(data, dataLen), StandardCharsets.UTF_8), pair.getFirst()); }
loadContent(long offset, int length) { CompletableFuture<Pair<String, Integer>> res = new CompletableFuture<>();  executor.submit(() -> { try { if (!accessManager.isFileVisible(file)) { res.completeExceptionally(new SecurityException(accessManager.errorMessage(file))); return; }  if (length > ParserConfig.MAX_LINE_LENGTH) throw new IllegalStateException();  try (RandomAccessFile input = new RandomAccessFile(file.toFile(), "r")) { input.seek(offset);  byte[] data = new byte[length]; input.readFully(data);  res.complete(Utils.decode(data, encoding)); } } catch (Throwable e) { res.completeExceptionally(e); } });  return res; }
[*] target: assertEquals(nonLatinCharOffset, dataLen)
[-] pred: org. junit. Assert. assertEquals ( nonLatinCharOffset, dataLen )
************************************
************************************
[+] input: testSelectById() { try (SqlSession sqlSession = getSqlSession()) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class);  User user = userMapper.getById(1L); Assert.assertNotNull(user); Assert.assertEquals("张无忌", user.getUsername()); Assert.assertNull(user.getSex());  user.setId(999L); Assert.assertEquals(1, userMapper.insert(user));  int count = userMapper.deleteById(user); Assert."<AssertPlaceHolder>"; sqlSession.rollback(); } }
deleteById(User user);
[*] target: assertEquals(1, count)
[-] pred: org. junit. Assert. assertEquals ( 1, count )
************************************
************************************
[+] input: Exception { assertTrue(sManager.getDataFlowHistory().isEmpty()); startEmitter(); DataFlowID flowID = sManager.createDataFlow(new DataRequest[]{ new DataRequest(EmitterModuleFactory.INSTANCE_URN,"send this data") }); //Wait until sink receives this data while(sSink.getData().length < 1) { Thread.sleep(500); } sManager.cancel(flowID); EmitterModule module = (EmitterModule) ModuleBase.getInstance( EmitterModuleFactory.INSTANCE_URN); DataEmitterSupport support = module.getLastTask().getSupport(); "<AssertPlaceHolder>"; int numData = sSink.getData().length; support.send(new Object()); //verify that the sink doesn't get it. assertEquals(numData, sSink.getData().length); //verify nothing happens if you try to emit error, its silently ignored support.dataEmitError(TestMessages.BAD_DATA, true); module.clear(); }
cancel(ModuleURN inStopRequester) throws DataFlowException { SLF4JLoggerProxy.debug(this, "Stopping flow {} requested by {}",  //$NON-NLS-1$ getFlowID(), inStopRequester ); //Only allow one thread to carry out cancellation at a time. synchronized (this) { if(mCancelling) { throw new DataFlowException(new I18NBoundMessage1P( Messages.DATA_FLOW_ALREADY_CANCELING, getFlowID().toString())); } else { mCancelling = true; } } // Go through each of the requests and cancel the requests // from first to last for(AbstractDataCoupler coupler: mCouplers) { coupler.cancelRequest(); } mStopRequesterURN = inStopRequester; mStopped = new Date(); }
[*] target: assertNotNull(support)
[-] pred: org. junit. Assert. assertNotNull ( support )
************************************
************************************
[+] input: testEquals() { RoleDTO roleDTO = new RoleDTO(1L, "USER"); RoleDTO roleDTO2 = new RoleDTO(1L, "USER");  assertTrue(roleDTO.equals(roleDTO)); assertFalse(roleDTO.equals("WRONG")); "<AssertPlaceHolder>"; }
equals(Object o) { if (this == o) return true; if (!(o instanceof RoleDTO)) return false; return id != null && id.equals(((RoleDTO) o).getId()); }
[*] target: assertTrue(roleDTO.equals(roleDTO2))
[-] pred: org. junit. Assert. assertTrue ( roleDTO. equals ( roleDTO2 ) )
************************************
************************************
[+] input: given_existing_roleId_when_getRoleById_return_Role() { Long roleId = 99L; Role role = new Role(roleId, "TEST ROLE");  given(roleRepository.findById(roleId)).willReturn(Optional.of(role));  Role returnRole = roleService.getRoleById(roleId);  "<AssertPlaceHolder>"; assertEquals(role.getId(), returnRole.getId()); }
getRoleById(Long id) { if (id == null) { throw new InvalidRoleIdentifierException("Id role cannot be null"); } Optional<Role> roleOpt = roleRepository.findById(id); if (roleOpt.isPresent()) { return roleOpt.get(); } throw new RoleNotFoundException(String.format("Role not found for Id = %s", id)); }
[*] target: assertNotNull(returnRole)
[-] pred: org. junit. Assert. assertNotNull ( returnRole )
************************************
************************************
[+] input: given_valid_not_used_name_when_createRole_returnRole() { Long genId = 123L; Role roleData = new Role(genId, "TEST");  when(roleRepository.save(any(Role.class))).thenReturn(new Role(genId, roleData.getRole()));  Role role = roleService.createRole("TEST");  "<AssertPlaceHolder>"; assertEquals(genId, role.getId()); assertEquals("TEST", role.getRole()); }
createRole(String roleStr) { validateRoleName(roleStr);  // check roleStr not in use if (roleRepository.findByRole(roleStr).isPresent()) { String errMsg = String.format("The role %s already exists", roleStr); log.error(errMsg); throw new RoleInUseException(errMsg); }  Role role = new Role(); role.setRole(roleStr);  role = roleRepository.save(role); log.info(String.format("Role %s %s has been created.", role.getId(), role.getRole()));  return role; }
[*] target: assertNotNull(role)
[-] pred: org. junit. Assert. assertNotNull ( role )
************************************
************************************
[+] input: given_existing_role_existing_permission_not_used_when_removePermissionOnRole_return_Role() { Role role = new Role(1L, "TEST"); given(roleRepository.findById(1L)).willReturn(Optional.of(role));  Permission permission = new Permission(); permission.setId(1L); permission.setPermission("PERMISSION");  given(permissionRepository.findByPermission("PERMISSION")).willReturn(Optional.of(permission));  Role roleUpdated = roleService.removePermissionOnRole(1L, "PERMISSION");  "<AssertPlaceHolder>"; // role data assertEquals(Long.valueOf(1L), roleUpdated.getId()); assertEquals("TEST", roleUpdated.getRole());  // permissions assertEquals(0L, roleUpdated.getPermissions().size()); }
removePermissionOnRole(Long roleId, String permissionKey) { validatePermissionKey(permissionKey);  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); } Role role = roleOpt.get();  // check permission Optional<Permission> permissionOpt = permissionRepository.findByPermission(permissionKey); if (!permissionOpt.isPresent()) { throw new PermissionNotFoundException(String.format("Permission not found with Id = %s on role %s", permissionKey, roleId)); }  Permission permission = permissionOpt.get();  role.getPermissions().remove(permission); roleRepository.save(role);  log.info(String.format("Removed permission %s from role id = %s", permissionKey, roleId)); return roleRepository.findById(roleId).get(); }
[*] target: assertNotNull(roleUpdated)
[-] pred: org. junit. Assert. assertNotNull ( roleUpdated )
************************************
************************************
[+] input: given_existing_role_existing_permission_in_used_when_removePermissionOnRole_return_Role() { Role role = new Role(1L, "TEST"); given(roleRepository.findById(1L)).willReturn(Optional.of(role));  Permission permission = new Permission(); permission.setId(1L); permission.setPermission("PERMISSION");  given(permissionRepository.findByPermission("PERMISSION")).willReturn(Optional.of(permission));  Role roleUpdated = roleService.removePermissionOnRole(1L, "PERMISSION");  "<AssertPlaceHolder>"; // role data assertEquals(Long.valueOf(1L), roleUpdated.getId()); assertEquals("TEST", roleUpdated.getRole());  // permissions assertEquals(0L, roleUpdated.getPermissions().size()); }
removePermissionOnRole(Long roleId, String permissionKey) { validatePermissionKey(permissionKey);  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); } Role role = roleOpt.get();  // check permission Optional<Permission> permissionOpt = permissionRepository.findByPermission(permissionKey); if (!permissionOpt.isPresent()) { throw new PermissionNotFoundException(String.format("Permission not found with Id = %s on role %s", permissionKey, roleId)); }  Permission permission = permissionOpt.get();  role.getPermissions().remove(permission); roleRepository.save(role);  log.info(String.format("Removed permission %s from role id = %s", permissionKey, roleId)); return roleRepository.findById(roleId).get(); }
[*] target: assertNotNull(roleUpdated)
[-] pred: org. junit. Assert. assertNotNull ( roleUpdated )
************************************
************************************
[+] input: given_existing_user_when_getUserById_returnUser() { Long userId = 1L;  User user = getUserTestData(userId, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findById(userId)).willReturn(Optional.of(user));  User userRet = userService.getUserById(userId);  "<AssertPlaceHolder>"; assertEquals(userId, userRet.getId()); assertEquals("andrea", userRet.getUsername()); assertEquals("Andrea", userRet.getName()); assertEquals("Giassi", userRet.getSurname()); assertEquals("andrea.test@gmail.com", userRet.getContact().getEmail()); assertEquals("+3531122334455", userRet.getContact().getPhone()); }
getUserById(Long id) { if (id == null) { throw new InvalidUserIdentifierException("User Id cannot be null"); } Optional<User> userOpt = userRepository.findById(id); if (userOpt.isPresent()) { return userOpt.get(); } throw new UserNotFoundException(String.format("User not found for Id = %s", id)); }
[*] target: assertNotNull(userRet)
[-] pred: org. junit. Assert. assertNotNull ( userRet )
************************************
************************************
[+] input: given_existing_username_when_getUserByUsername_return_user() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findByUsername("andrea")).willReturn(userDataForTest);  User user = userService.getUserByUsername("andrea");  "<AssertPlaceHolder>"; assertEquals(Long.valueOf(1L), user.getId()); assertEquals("andrea", user.getUsername()); assertEquals("Andrea", user.getName()); assertEquals("Giassi", user.getSurname()); assertEquals("andrea.test@gmail.com", user.getContact().getEmail()); assertEquals("+3531122334455", user.getContact().getPhone()); }
getUserByUsername(String username) { if (username == null) { throw new InvalidUsernameException("username cannot be null"); } return userRepository.findByUsername(username); }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_existing_email_when_getUserByEmail_return_user() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findByEmail("andrea.test@gmail.com")).willReturn(userDataForTest);  User user = userService.getUserByEmail("andrea.test@gmail.com");  "<AssertPlaceHolder>"; assertEquals(Long.valueOf(1L), user.getId()); assertEquals("andrea", user.getUsername()); assertEquals("Andrea", user.getName()); assertEquals("Giassi", user.getSurname()); assertEquals("andrea.test@gmail.com", user.getContact().getEmail()); assertEquals("+3531122334455", user.getContact().getPhone()); }
getUserByEmail(String email) { if (email == null) { throw new InvalidEmailException("email cannot be null"); } return userRepository.findByEmail(email); }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_valid_login_when_login_return_User() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findByUsername("andrea")).willReturn(userDataForTest);  User user = userService.login("andrea", UserTestHelper.TEST_PASSWORD_DECRYPTED);  "<AssertPlaceHolder>"; assertEquals("andrea", user.getUsername()); }
login(String username, String password) { if ((Strings.isNullOrEmpty(username)) || (Strings.isNullOrEmpty(password))) { throw new InvalidLoginException("Username or Password cannot be null or empty"); }  User user = getUserByUsername(username); if (user == null) { // invalid username throw new InvalidLoginException("Invalid username or password"); }  log.info(String.format("Login request from %s", username));  // check the password if (EncryptionService.isPasswordValid(password, user.getPassword(), salt)) { // check if the user is enabled if (!user.isEnabled()) { // not enabled throw new InvalidLoginException("User is not enabled"); }  // update the last login timestamp user.setLoginDt(LocalDateTime.now()); userRepository.save(user);  log.info(String.format("Valid login for %s", username)); } else { throw new InvalidLoginException("Invalid username or password"); } return user; }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_validUserAndRoleIds_when_addRole_returnUser() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  given(userRepository.findById(1L)).willReturn(Optional.of(userDataForTest));  Role roleAdmin = new Role(Role.ADMINISTRATOR, "Administrator");  given(roleRepository.findById(2L)).willReturn(Optional.of(roleAdmin));  User user = userService.addRole(1L, 2L);  "<AssertPlaceHolder>";  // check the new added role Set<Role> roleSet = user.getRoles();  assertNotNull(roleSet); assertEquals(2, roleSet.size()); assertTrue(roleSet.contains(roleAdmin)); }
addRole(Long id, Long roleId) { // check user Optional<User> userOpt = userRepository.findById(id); if (!userOpt.isPresent()) { throw new UserNotFoundException(String.format("User not found with Id = %s", id)); } User user = userOpt.get();  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); }  Role role = roleOpt.get();  user.getRoles().add(role); user.setUpdatedDt(LocalDateTime.now());  userRepository.save(user); log.info(String.format("Added role %s on user id = %s", role.getRole(), user.getId()));  return user; }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: given_validUserAndRoleIds_when_removeRole_returnUser() { User userDataForTest = getUserTestData(1L, "andrea", "Andrea", "Giassi", "andrea.test@gmail.com", "+3531122334455");  Role roleAdmin = new Role(Role.ADMINISTRATOR, "Administrator"); userDataForTest.getRoles().add(roleAdmin);  given(userRepository.findById(1L)).willReturn(Optional.of(userDataForTest)); given(roleRepository.findById(2L)).willReturn(Optional.of(roleAdmin));  User user = userService.removeRole(1L, 2L);  "<AssertPlaceHolder>";  // check the remove role Set<Role> roleSet = user.getRoles();  assertNotNull(roleSet); assertEquals(1, roleSet.size()); assertTrue(!roleSet.contains(roleAdmin)); }
removeRole(Long id, Long roleId) { // check user Optional<User> userOpt = userRepository.findById(id); if (!userOpt.isPresent()) { throw new UserNotFoundException(String.format("User not found with Id = %s", id)); } User user = userOpt.get();  // check role Optional<Role> roleOpt = roleRepository.findById(roleId); if (!roleOpt.isPresent()) { throw new RoleNotFoundException(String.format("Role not found with Id = %s", roleId)); }  Role role = roleOpt.get();  user.getRoles().remove(role); user.setUpdatedDt(LocalDateTime.now());  userRepository.save(user); log.info(String.format("Removed role %s on user id = %s", role.getRole(), user.getId()));  return user; }
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: Exception { ComponentName cn = new ComponentName(getContext(), TEST_ACTIVITY); initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), false  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: Exception { initCursor(ITEM_TYPE_APPLICATION, ""); assertTrue(mLoaderCursor.moveToNext());  ComponentName cn = new ComponentName(mContext.getPackageName(), "placeholder-do"); WorkspaceItemInfo info = Executors.MODEL_EXECUTOR.submit(() -> mLoaderCursor.getAppShortcutInfo( new Intent().setComponent(cn), true  /* allowMissingTarget */, true)) .get(); "<AssertPlaceHolder>"; assertTrue(PackageManagerHelper.isLauncherAppTarget(info.getIntent())); }
getAppShortcutInfo( Intent intent, boolean allowMissingTarget, boolean useLowResIcon) { return getAppShortcutInfo(intent, allowMissingTarget, useLowResIcon, true); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: backupAccountToKeyStoreTest() { //Create password accounts Chain chain = new Chain(); chain.setConfig(new ConfigBean(chainId, assetId)); List<Account> accountList = accountService.createAccount(chain, 1, password); String address = accountList.get(0).getAddress().getBase58(); //Test not specifying backup path String pathDir = ""; //Backup accountkeystore  backup account keyStore String path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); assertNotNull(path);  //Test specified nonwindowsBackup path pathDir = "test1/back/up"; //Backup accountkeystore  backup account keyStore path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); assertNotNull(path);  //Test specifiedwindowsBackup path pathDir = "D:\\workspace\\github\\nuls_2.0\\test2\\back\\up"; //Create an unencrypted account for test accountList = accountService.createAccount(chain, 1, null); address = accountList.get(0).getAddress().getBase58(); //Backup accountkeystore  backup account keyStore path = accountKeyStoreService.backupAccountToKeyStore(pathDir, chainId, address, password); "<AssertPlaceHolder>";  }
backupAccountToKeyStore(String path, int chainId, String address, String password);
[*] target: assertNotNull(path)
[-] pred: org. junit. Assert. assertNotNull ( path )
************************************
************************************
[+] input: getAccountTest() { //create account List<Account> accountList = accountService.createAccount(chain, 1, password); //query account Account account = accountService.getAccount(chainId, accountList.get(0).getAddress().getBase58()); "<AssertPlaceHolder>"; assertEquals(accountList.get(0).getAddress().getBase58(), account.getAddress().getBase58()); }
getAccount(int chainId, String address);
[*] target: assertNotNull(account)
[-] pred: org. junit. Assert. assertNotNull ( account )
************************************
************************************
[+] input: setRemarkTest() { try { String remark = "test remark"; String errorRemark = "test error remark test error remark test error remark test error remarktest"; //Create password accounts List<Account> accountList = accountService.createAccount(chain, 1, password); //Set the correct remarks for the account boolean result = accountService.setRemark(chainId, accountList.get(0).getAddress().getBase58(), remark); Account account = accountService.getAccount(chainId, accountList.get(0).getAddress().getBase58()); assertTrue(result); assertEquals(remark, account.getRemark()); //Set the correct remarks for the account result = accountService.setRemark(chainId, accountList.get(0).getAddress().getBase58(), ""); assertTrue(result); //Set incorrect remarks for the account >60 bytes result = accountService.setRemark(chainId, accountList.get(0).getAddress().getBase58(), errorRemark); "<AssertPlaceHolder>"; } catch (NulsRuntimeException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } }
setRemark(int chainId, String address, String remark);
[*] target: assertFalse(result)
[-] pred: org. junit. Assert. assertFalse ( result )
************************************
************************************
[+] input: Exception { // create account Alias alias = AliasStorageServiceTest.createAlias(); boolean result = aliasService.aliasTxCommit(chainId,alias); "<AssertPlaceHolder>"; Account account = accountService.getAccount(chainId, AddressTool.getStringAddressByBytes(alias.getAddress())); assertNotNull(account); assertEquals(account.getAlias(),alias.getAlias()); }
aliasTxCommit(int chainId, Alias alias) throws NulsException;
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { List<AccountPO> accountPOs = new ArrayList<>(); int count = 10; String password = "a2678"; for (int i = 0; i < count; i++) { //create account Account account = AccountTool.createAccount(chainId); if (StringUtils.isNotBlank(password)) { account.encrypt(password); } AccountPO po = new AccountPO(account); accountPOs.add(po); } //Batch Save Account Data boolean result = accountStorageService.saveAccountList(accountPOs); "<AssertPlaceHolder>"; assertEquals(accountPOs.size(), count); for (AccountPO account : accountPOs) { System.out.println(account.getAddress()); } }
saveAccountList(List<AccountPO> accountPOList);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: Exception { Account account = AccountTool.createAccount(chainId); accountStorageService.saveAccount(new AccountPO(account)); AccountPO accountPo = accountStorageService.getAccount(account.getAddress().getAddressBytes()); "<AssertPlaceHolder>"; assertEquals(account.getAddress().getBase58(), accountPo.getAddress()); }
getAccount(byte[] address);
[*] target: assertNotNull(accountPo)
[-] pred: org. junit. Assert. assertNotNull ( accountPo )
************************************
************************************
[+] input: Exception { Alias alias1 = createAlias(); boolean result = aliasStorageService.saveAlias(chainId,alias1); assertTrue(result); Alias alias2 = createAlias(); result = aliasStorageService.saveAlias(chainId,alias2); "<AssertPlaceHolder>"; }
saveAlias(int chainId, Alias alias);
[*] target: assertTrue(result)
[-] pred: org. junit. Assert. assertTrue ( result )
************************************
************************************
[+] input: dumpSites() { final Context context = ServiceLocator.getInstance().getAppContext();  for (final Site.Type type : Site.Type.values()) { final List<Site> sites = type.getSites(); Log.d(TAG, "\n------------------------------------------\n\n" + type);  for (final Site site : sites) { final EngineId engineId = site.getEngineId(); final SearchEngineConfig config = engineId.getConfig(); assertNotNull(config); final SearchEngine searchEngine = engineId.createSearchEngine(context); "<AssertPlaceHolder>";  Log.d(TAG, "\n" + config + "\n\n" + site + "\n\n" + searchEngine); } } }
createSearchEngine(@NonNull final Context context) { try { final Constructor<? extends SearchEngine> c = clazz.getConstructor(Context.class, SearchEngineConfig.class); return c.newInstance(context.getApplicationContext(), config);  } catch (@NonNull final NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) { throw new IllegalStateException( clazz + " must implement SearchEngine(Context, SearchEngineConfig)", e); } }
[*] target: assertNotNull(searchEngine)
[-] pred: org. junit. Assert. assertNotNull ( searchEngine )
************************************
************************************
[+] input: testSecondIsNull() { Pair<String, String> p = Pair.of(null, null); assertTrue(p.secondIsNull()); "<AssertPlaceHolder>"; }
secondNonNull() { return this.second != null; }
[*] target: assertFalse(p.secondNonNull())
[-] pred: org. junit. Assert. assertFalse ( p. secondNonNull() )
************************************
************************************
[+] input: testMessageCountValidity() { int cutBackCount = CAPACITY / 2; testBuffer.setCutBackCount(cutBackCount); // Fill the buffer to its capacity. for (int i = 1; i <= CAPACITY; i++) { testBuffer.addNotification(new UserNotification("message text", UserNotification.Level.INFORMATIONAL)); assertEquals(i, testBuffer.getMessageCount()); List<UserNotification> messages = testBuffer.getNotifications(); assertEquals(i, messages.size()); } // Add one more message to exceed the capacity. testBuffer.addNotification(new UserNotification("message text", UserNotification.Level.INFORMATIONAL)); assertEquals(cutBackCount, testBuffer.getMessageCount()); List<UserNotification> messages = testBuffer.getNotifications(); "<AssertPlaceHolder>"; }
getNotifications() { LOG.debug("method entry"); return new LinkedList<>(notifications); }
[*] target: assertEquals(cutBackCount, messages.size())
[-] pred: org. junit. Assert. assertEquals ( cutBackCount, messages. size ( ) )
************************************
************************************
[+] input: shouldReturnObjectsByClassAndPattern() { Point point1 = new Point("Point-00001"); pool.addObject(point1); Point point2 = new Point("Point-00002"); pool.addObject(point2); Path path1 = new Path("Point-00003", point1.getReference(), point2.getReference()); pool.addObject(path1);  Set<Point> points = pool.getObjects(Point.class, Pattern.compile("Point.*"));  assertEquals(2, points.size()); assertTrue(points.contains(point1)); "<AssertPlaceHolder>"; }
contains(String objectName) { requireNonNull(objectName, "objectName");  return objectsByName.containsKey(objectName); }
[*] target: assertTrue(points.contains(point2))
[-] pred: org. junit. Assert. assertTrue ( points. contains ( point2 ) )
************************************
************************************
[+] input: shouldReturnObjectsByClass() { Point point1 = new Point("Point-00001"); pool.addObject(point1); Point point2 = new Point("Point-00002"); pool.addObject(point2); Path path1 = new Path("Path-00001", point1.getReference(), point2.getReference()); pool.addObject(path1);  Set<Point> points = pool.getObjects(Point.class);  assertEquals(2, points.size()); assertTrue(points.contains(point1)); "<AssertPlaceHolder>"; }
contains(String objectName) { requireNonNull(objectName, "objectName");  return objectsByName.containsKey(objectName); }
[*] target: assertTrue(points.contains(point2))
[-] pred: org. junit. Assert. assertTrue ( points. contains ( point2 ) )
************************************
************************************
[+] input: shouldReturnObjectsByPattern() { Point point1 = new Point("Point-00001"); pool.addObject(point1); Point point2 = new Point("Point-00002"); pool.addObject(point2); Point point3 = new Point("Punkt-00003"); pool.addObject(point3);  Set<Point> points = pool.getObjects(Point.class, Pattern.compile("Point.*"));  assertEquals(2, points.size()); assertTrue(points.contains(point1)); "<AssertPlaceHolder>"; }
contains(String objectName) { requireNonNull(objectName, "objectName");  return objectsByName.containsKey(objectName); }
[*] target: assertTrue(points.contains(point2))
[-] pred: org. junit. Assert. assertTrue ( points. contains ( point2 ) )
************************************
************************************
[+] input: findExistingRechargePosition() { Point currentVehiclePoint = new Point("Current vehicle point") .withType(Point.Type.HALT_POSITION); Vehicle vehicle = new Vehicle("Some vehicle") .withRechargeOperation("Do some recharging") .withCurrentPosition(currentVehiclePoint.getReference());  Point locationAccessPoint = new Point("Location access point") .withType(Point.Type.HALT_POSITION);  LocationType rechargeLocType = new LocationType("Recharge location type") .withAllowedOperations(Collections.singletonList(vehicle.getRechargeOperation())); Location location = new Location("Recharge location", rechargeLocType.getReference());  Location.Link link = new Location.Link(location.getReference(), locationAccessPoint.getReference()); location = location.withAttachedLinks(new HashSet<>(Arrays.asList(link)));  locationAccessPoint = locationAccessPoint.withAttachedLinks(new HashSet<>(Arrays.asList(link)));  when(plantModelService.fetchObjects(Location.class)) .thenReturn(Collections.singleton(location)); when(plantModelService.fetchObject(LocationType.class, rechargeLocType.getReference())) .thenReturn(rechargeLocType); when(plantModelService.fetchObject(Point.class, currentVehiclePoint.getReference())) .thenReturn(currentVehiclePoint); when(plantModelService.fetchObject(Point.class, locationAccessPoint.getReference())) .thenReturn(locationAccessPoint);  rechargePosSupplier.initialize();  List<Destination> result = rechargePosSupplier.findRechargeSequence(vehicle); "<AssertPlaceHolder>"; assertThat(result, is(not(empty()))); }
findRechargeSequence(Vehicle vehicle) { requireNonNull(vehicle, "vehicle");  if (vehicle.getCurrentPosition() == null) { return new ArrayList<>(); }  Map<Location, Set<Point>> rechargeLocations = findLocationsForOperation(vehicle.getRechargeOperation(), vehicle, router.getTargetedPoints());  String assignedRechargeLocationName = vehicle.getProperty(PROPKEY_ASSIGNED_RECHARGE_LOCATION); if (assignedRechargeLocationName != null) { Location location = pickLocationWithName(assignedRechargeLocationName, rechargeLocations.keySet()); if (location == null) { return new ArrayList<>(); } // XXX Strictly, we should check whether there is a viable route to the location. return Arrays.asList(createDestination(location, vehicle.getRechargeOperation())); }  String preferredRechargeLocationName = vehicle.getProperty(PROPKEY_PREFERRED_RECHARGE_LOCATION); if (assignedRechargeLocationName != null) { Location location = pickLocationWithName(preferredRechargeLocationName, rechargeLocations.keySet()); if (location != null) { // XXX Strictly, we should check whether there is a viable route to the location. return Arrays.asList(createDestination(location, vehicle.getRechargeOperation())); } }  Location bestLocation = findCheapestLocation(rechargeLocations, vehicle); if (bestLocation != null) { return Arrays.asList(createDestination(bestLocation, vehicle.getRechargeOperation())); }  return new ArrayList<>(); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: returnEmptyRouteIfDestinationIsSource() { List<Step> steps = pointRouter.getRouteSteps(pointA, pointA); "<AssertPlaceHolder>"; assertThat(steps, is(empty())); }
getRouteSteps(Point srcPoint, Point destPoint) { requireNonNull(srcPoint, "srcPoint"); requireNonNull(destPoint, "destPoint");  long timeBefore = System.currentTimeMillis(); if (Objects.equals(srcPoint.getName(), destPoint.getName())) { return new ArrayList<>(); }  GraphPath<String, ModelEdge> graphPath = algo.getPath(srcPoint.getName(), destPoint.getName()); if (graphPath == null) { return null; }  List<Route.Step> result = translateToSteps(graphPath);  LOG.debug("Looking up route from {} to {} took {} milliseconds.", srcPoint.getName(), destPoint.getName(), System.currentTimeMillis() - timeBefore);  return result; }
[*] target: assertNotNull(steps)
[-] pred: org. junit. Assert. assertNotNull ( steps )
************************************
************************************
[+] input: returnGraphPathStepsForExistingRoute() { List<Step> steps = pointRouter.getRouteSteps(pointA, pointC); "<AssertPlaceHolder>"; assertThat(steps, is(not(empty()))); }
getRouteSteps(Point srcPoint, Point destPoint) { requireNonNull(srcPoint, "srcPoint"); requireNonNull(destPoint, "destPoint");  long timeBefore = System.currentTimeMillis(); if (Objects.equals(srcPoint.getName(), destPoint.getName())) { return new ArrayList<>(); }  GraphPath<String, ModelEdge> graphPath = algo.getPath(srcPoint.getName(), destPoint.getName()); if (graphPath == null) { return null; }  List<Route.Step> result = translateToSteps(graphPath);  LOG.debug("Looking up route from {} to {} took {} milliseconds.", srcPoint.getName(), destPoint.getName(), System.currentTimeMillis() - timeBefore);  return result; }
[*] target: assertNotNull(steps)
[-] pred: org. junit. Assert. assertNotNull ( steps )
************************************
************************************
[+] input: IOException { try (MockedStatic<MetricServiceClient> mockedServiceClientClass = mockStatic(MetricServiceClient.class)) { MetricServiceSettings.Builder builder = MetricServiceSettings.newBuilder(); builder .setCredentialsProvider(FixedCredentialsProvider.create(aFakeCredential)) .setEndpoint(MetricConfiguration.DEFAULT_METRIC_SERVICE_ENDPOINT) .createMetricDescriptorSettings() .setSimpleTimeoutNoRetries( Duration.ofMillis(MetricConfiguration.DEFAULT_DEADLINE.toMillis())); MetricServiceSettings serviceSettings = builder.build();  MetricConfiguration configuration = MetricConfiguration.builder() .setProjectId(aProjectId) .setMetricServiceEndpoint("https://fake-endpoint") .setInsecureEndpoint(true) .setCredentials(null) .setMetricServiceSettings(serviceSettings) .setDescriptorStrategy(MetricDescriptorStrategy.SEND_ONCE) .build(); assertNotNull(configuration.getMetricServiceSettings());  // Mock the static method to create a MetricServiceClient to return a mocked object mockedServiceClientClass .when(() -> MetricServiceClient.create(eq(configuration.getMetricServiceSettings()))) .thenReturn(mockMetricServiceClient);  MetricExporter exporter = InternalMetricExporter.createWithConfiguration(configuration); "<AssertPlaceHolder>";  // verify that the MetricServiceClient used in the exporter was created using the // MetricServiceSettings provided in configuration mockedServiceClientClass.verify( times(1), () -> MetricServiceClient.create(eq(configuration.getMetricServiceSettings())));  // verify that export operation on the resulting exporter can still be called CompletableResultCode result = exporter.export(ImmutableList.of(aMetricData, aHistogram)); assertTrue(result.isSuccess());  // verify that the CreateTimeseries call was invoked on the client generated from the supplied // MetricServiceSettings object verify(mockMetricServiceClient, times(1)) .createTimeSeries(projectNameArgCaptor.capture(), timeSeriesArgCaptor.capture()); } }
createWithConfiguration(MetricConfiguration configuration) { return new GoogleCloudMetricExporter(configuration); }
[*] target: assertNotNull(exporter)
[-] pred: org. junit. Assert. assertNotNull ( exporter )
************************************
************************************
[+] input: testMapConstantLabelWithBooleanValueSucceeds() { LabelDescriptor actualLabel = MetricTranslator.mapAttribute(booleanKey("label1"), CUSTOM_PREFIX); LabelDescriptor expectedLabel = LabelDescriptor.newBuilder().setKey("label1").setValueType(ValueType.BOOL).build(); assertEquals(expectedLabel, actualLabel);  LabelDescriptor actualLabel2 = MetricTranslator.mapAttribute(booleanKey("label1"), CUSTOM_PREFIX); "<AssertPlaceHolder>"; }
mapAttribute(AttributeKey<T> key, String descriptorTypePrefix) { LabelDescriptor.Builder builder = LabelDescriptor.newBuilder().setKey(cleanAttributeKey(key.getKey())); // Only CUSTOM_PREFIX allows for a descriptor type other than String. if (descriptorTypePrefix.equals(CUSTOM_PREFIX)) { switch (key.getType()) { case BOOLEAN: builder.setValueType(LabelDescriptor.ValueType.BOOL); break; case LONG: builder.setValueType(LabelDescriptor.ValueType.INT64); break; default: // All other attribute types will be converted to String builder.setValueType(LabelDescriptor.ValueType.STRING); break; } } else { // all other descriptor types only allow String Label descriptors. builder.setValueType(LabelDescriptor.ValueType.STRING); } return builder.build(); }
[*] target: assertEquals(expectedLabel, actualLabel2)
[-] pred: org. junit. Assert. assertEquals ( expectedLabel, actualLabel2 )
************************************
************************************
[+] input: testGetStepAndSectionIdentifier1() { Element procedureEl = TestUtils.stringToXom( "<PROCEDURE>" + "<NN-EXAMPLE>Example</NN-EXAMPLE>" + "<CD>3</CD>" + "<COLON>:</COLON>" + "<NN-METHOD>Step</NN-METHOD>" + "<CD>2</CD>" + "</PROCEDURE>"); SectionAndStepIdentifier sectionAndStepIdentifier = parser.getSectionAndStepIdentifier(procedureEl); "<AssertPlaceHolder>"; assertEquals("3", sectionAndStepIdentifier.getSectionIdentifier()); assertEquals("2", sectionAndStepIdentifier.getStepIdentifier()); }
getSectionAndStepIdentifier(Element procedureEl) { List<Element> stepIdentifiers = XomUtils.getDescendantElementsWithTagNames(procedureEl, new String[]{NN_IDENTIFIER, CD, CD_ALPHANUM}); if (stepIdentifiers.size() == 1){ Element stepIdentifier = stepIdentifiers.get(0); if (isSectionIdentifier(stepIdentifier)){ return new SectionAndStepIdentifier(stepIdentifier.getValue(), null); } else{ String sectionIdentifier = getSectionIdentifier(experimentalSection.getProcedureElement()); return new SectionAndStepIdentifier(sectionIdentifier, stepIdentifier.getValue()); } } if (stepIdentifiers.size() == 2){ boolean firstIsSectionIdentifier = isSectionIdentifier(stepIdentifiers.get(0)); boolean secondIsSectionIdentifier = isSectionIdentifier(stepIdentifiers.get(1)); if (firstIsSectionIdentifier && !secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(0).getValue(), stepIdentifiers.get(1).getValue()); } if (!firstIsSectionIdentifier && secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(1).getValue(), stepIdentifiers.get(0).getValue()); } if (!firstIsSectionIdentifier && !secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(0).getValue(), stepIdentifiers.get(1).getValue()); } //both being section identifiers is not intentionally not interpretable } return null; }
[*] target: assertNotNull(sectionAndStepIdentifier)
[-] pred: org. junit. Assert. assertNotNull ( sectionAndStepIdentifier )
************************************
************************************
[+] input: testGetStepAndSectionIdentifier2() { Element procedureEl = TestUtils.stringToXom( "<PROCEDURE>" + "<NN-EXAMPLE>Example</NN-EXAMPLE>" + "<CD>3</CD>" + "</PROCEDURE>"); SectionAndStepIdentifier sectionAndStepIdentifier = parser.getSectionAndStepIdentifier(procedureEl); "<AssertPlaceHolder>"; assertEquals("3", sectionAndStepIdentifier.getSectionIdentifier()); assertEquals(null, sectionAndStepIdentifier.getStepIdentifier()); }
getSectionAndStepIdentifier(Element procedureEl) { List<Element> stepIdentifiers = XomUtils.getDescendantElementsWithTagNames(procedureEl, new String[]{NN_IDENTIFIER, CD, CD_ALPHANUM}); if (stepIdentifiers.size() == 1){ Element stepIdentifier = stepIdentifiers.get(0); if (isSectionIdentifier(stepIdentifier)){ return new SectionAndStepIdentifier(stepIdentifier.getValue(), null); } else{ String sectionIdentifier = getSectionIdentifier(experimentalSection.getProcedureElement()); return new SectionAndStepIdentifier(sectionIdentifier, stepIdentifier.getValue()); } } if (stepIdentifiers.size() == 2){ boolean firstIsSectionIdentifier = isSectionIdentifier(stepIdentifiers.get(0)); boolean secondIsSectionIdentifier = isSectionIdentifier(stepIdentifiers.get(1)); if (firstIsSectionIdentifier && !secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(0).getValue(), stepIdentifiers.get(1).getValue()); } if (!firstIsSectionIdentifier && secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(1).getValue(), stepIdentifiers.get(0).getValue()); } if (!firstIsSectionIdentifier && !secondIsSectionIdentifier){ return new SectionAndStepIdentifier(stepIdentifiers.get(0).getValue(), stepIdentifiers.get(1).getValue()); } //both being section identifiers is not intentionally not interpretable } return null; }
[*] target: assertNotNull(sectionAndStepIdentifier)
[-] pred: org. junit. Assert. assertNotNull ( sectionAndStepIdentifier )
************************************
************************************
[+] input: IOException { ExperimentalSectionsCreator sectionCreator = new ExperimentalSectionsCreator(new ArrayList<Element>()); Document taggedDoc = Utils.buildXmlFromString("<Document><Sentence><NounPhrase><UNNAMEDMOLECULE><REFERENCETOCOMPOUND></REFERENCETOCOMPOUND></UNNAMEDMOLECULE><MOLECULE></MOLECULE></NounPhrase><STOP>.</STOP></Sentence></Document>"); Element heading = sectionCreator.findAndDetachHiddenHeadingContent(taggedDoc); "<AssertPlaceHolder>"; assertEquals(2, heading.getChildElements().size()); assertEquals(0, taggedDoc.getRootElement().getFirstChildElement("Sentence").getChildElements().size()); }
findAndDetachHiddenHeadingContent(Document taggedDoc) { Element firstSentence = taggedDoc.getRootElement().getFirstChildElement(SENTENCE_Container); Element heading = null; if (firstSentence != null){ List<Element> elementsToConsider = expandActionPhrases(firstSentence.getChildElements()); if (elementsToConsider.size() >= 1){ Element firstPhrase =elementsToConsider.get(0); if (firstPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(firstPhrase)){ if (elementsToConsider.size() >= 2){ Element secondPhrase = elementsToConsider.get(1); if (isPeriodOrSemiColonOrColon(secondPhrase)){ heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); detachElementAndEmptySentenceAndActionPhraseParents(secondPhrase); heading.appendChild(firstPhrase); heading.appendChild(secondPhrase); if(elementsToConsider.size() >= 4){ Element thirdPhrase = elementsToConsider.get(2); Element fourthPhrase = elementsToConsider.get(3); if (thirdPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(thirdPhrase) && isPeriodOrSemiColonOrColon(fourthPhrase)){ detachElementAndEmptySentenceAndActionPhraseParents(thirdPhrase); detachElementAndEmptySentenceAndActionPhraseParents(fourthPhrase); heading.appendChild(thirdPhrase); heading.appendChild(fourthPhrase); } } } } else{//a sentence which is just a heading e.g. "3)" heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); heading.appendChild(firstPhrase); } } } } return heading; }
[*] target: assertNotNull(heading)
[-] pred: org. junit. Assert. assertNotNull ( heading )
************************************
************************************
[+] input: IOException { ExperimentalSectionsCreator sectionCreator = new ExperimentalSectionsCreator(new ArrayList<Element>()); Document taggedDoc = Utils.buildXmlFromString("<Document><Sentence><NounPhrase><MOLECULE></MOLECULE></NounPhrase><COLON>:</COLON></Sentence></Document>"); Element heading = sectionCreator.findAndDetachHiddenHeadingContent(taggedDoc); "<AssertPlaceHolder>"; assertEquals(2, heading.getChildElements().size()); assertEquals(0, taggedDoc.getRootElement().getFirstChildElement("Sentence").getChildElements().size()); }
findAndDetachHiddenHeadingContent(Document taggedDoc) { Element firstSentence = taggedDoc.getRootElement().getFirstChildElement(SENTENCE_Container); Element heading = null; if (firstSentence != null){ List<Element> elementsToConsider = expandActionPhrases(firstSentence.getChildElements()); if (elementsToConsider.size() >= 1){ Element firstPhrase =elementsToConsider.get(0); if (firstPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(firstPhrase)){ if (elementsToConsider.size() >= 2){ Element secondPhrase = elementsToConsider.get(1); if (isPeriodOrSemiColonOrColon(secondPhrase)){ heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); detachElementAndEmptySentenceAndActionPhraseParents(secondPhrase); heading.appendChild(firstPhrase); heading.appendChild(secondPhrase); if(elementsToConsider.size() >= 4){ Element thirdPhrase = elementsToConsider.get(2); Element fourthPhrase = elementsToConsider.get(3); if (thirdPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(thirdPhrase) && isPeriodOrSemiColonOrColon(fourthPhrase)){ detachElementAndEmptySentenceAndActionPhraseParents(thirdPhrase); detachElementAndEmptySentenceAndActionPhraseParents(fourthPhrase); heading.appendChild(thirdPhrase); heading.appendChild(fourthPhrase); } } } } else{//a sentence which is just a heading e.g. "3)" heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); heading.appendChild(firstPhrase); } } } } return heading; }
[*] target: assertNotNull(heading)
[-] pred: org. junit. Assert. assertNotNull ( heading )
************************************
************************************
[+] input: IOException { ExperimentalSectionsCreator sectionCreator = new ExperimentalSectionsCreator(new ArrayList<Element>()); Document taggedDoc = Utils.buildXmlFromString("<Document><Sentence><NounPhrase><PROCEDURE><NN-EXAMPLE>Example</NN-EXAMPLE><CD>3</CD></PROCEDURE></NounPhrase><STOP>.</STOP></Sentence><Sentence><NounPhrase></NounPhrase><STOP></STOP></Sentence></Document>"); Element heading = sectionCreator.findAndDetachHiddenHeadingContent(taggedDoc); "<AssertPlaceHolder>"; assertEquals(2, heading.getChildElements().size()); assertEquals(0, taggedDoc.getRootElement().getFirstChildElement("Sentence").getChildElements().size()); assertEquals(2, taggedDoc.getRootElement().getChildElements("Sentence").size()); }
findAndDetachHiddenHeadingContent(Document taggedDoc) { Element firstSentence = taggedDoc.getRootElement().getFirstChildElement(SENTENCE_Container); Element heading = null; if (firstSentence != null){ List<Element> elementsToConsider = expandActionPhrases(firstSentence.getChildElements()); if (elementsToConsider.size() >= 1){ Element firstPhrase =elementsToConsider.get(0); if (firstPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(firstPhrase)){ if (elementsToConsider.size() >= 2){ Element secondPhrase = elementsToConsider.get(1); if (isPeriodOrSemiColonOrColon(secondPhrase)){ heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); detachElementAndEmptySentenceAndActionPhraseParents(secondPhrase); heading.appendChild(firstPhrase); heading.appendChild(secondPhrase); if(elementsToConsider.size() >= 4){ Element thirdPhrase = elementsToConsider.get(2); Element fourthPhrase = elementsToConsider.get(3); if (thirdPhrase.getLocalName().equals(NOUN_PHRASE_Container) && nounphraseContainsRecognisedHeadingForm(thirdPhrase) && isPeriodOrSemiColonOrColon(fourthPhrase)){ detachElementAndEmptySentenceAndActionPhraseParents(thirdPhrase); detachElementAndEmptySentenceAndActionPhraseParents(fourthPhrase); heading.appendChild(thirdPhrase); heading.appendChild(fourthPhrase); } } } } else{//a sentence which is just a heading e.g. "3)" heading = new Element(XMLTags.HEADING); detachElementAndEmptySentenceAndActionPhraseParents(firstPhrase); heading.appendChild(firstPhrase); } } } } return heading; }
[*] target: assertNotNull(heading)
[-] pred: org. junit. Assert. assertNotNull ( heading )
************************************
************************************
[+] input: testGetById() { try (SqlSession sqlSession = getSqlSession()) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.getById(1L); Assert."<AssertPlaceHolder>"; Assert.assertEquals("张无忌", user.getUsername()); Assert.assertEquals("男", user.getSex()); Assert.assertEquals("明教", user.getAddress().get(0)); Assert.assertEquals("教主", user.getAddress().get(1)); } }
getById(Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: testFindTransportWithSelectionHiPriority() { byte[] dummyMessage = new byte[0];  TransportInfo dummyTransport = TransportInfo.of("DUMMY", StaticTransportMetadata.empty()); TransportInfo udpTransport = TransportInfo.of(UDPConstants.NAME, StaticTransportMetadata.empty());  List<TransportInfo> transports = ImmutableList.of(dummyTransport, udpTransport);  Peer peer1 = mock(Peer.class); doAnswer(invocation -> transports.stream()).when(peer1).supportedTransports(); doAnswer( invocation -> "DUMMY".equals(invocation.getArgument(0)) || UDPConstants.NAME.equals(invocation.getArgument(0)) ).when(peer1).supportsTransport(any()); @SuppressWarnings("resource") Transport found = transportManager.findTransport(peer1, dummyMessage); "<AssertPlaceHolder>"; assertEquals("DUMMY", found.name()); }
findTransport(Peer peer, byte[] bytes) { if (peer != null) { // Could probably do something a bit more efficient here with caching and such // once the list of transports supported gets reasonably long.  // Check in priority order for first capable matching transport return this.transports.stream() .filter(t -> peer.supportsTransport(t.name())) .filter(t -> t.canHandle(bytes)) .findFirst() .orElse(this.defaultTransport); } return this.defaultTransport; }
[*] target: assertNotNull(found)
[-] pred: org. junit. Assert. assertNotNull ( found )
************************************
************************************
[+] input: testComplete() { SendResult complete = SendResult.complete();  assertThat(complete.toString(), containsString("Complete")); "<AssertPlaceHolder>"; }
isComplete() { return this.throwable == null; }
[*] target: assertTrue(complete.isComplete())
[-] pred: org. junit. Assert. assertTrue ( complete. isComplete() )
************************************
************************************
[+] input: testGetSelf() { when(this.serialization.toJsonObject(any(), any())).thenReturn(new JSONObject()); JSONObject json = this.services.getSelf();  "<AssertPlaceHolder>"; assertTrue(json.has("system"));  verify(this.serialization, times(1)).toJsonObject(this.localSystem, Output.WIRE); }
getSelf() { JSONObject self = new JSONObject(); self.put("system", serialization.toJsonObject(localSystem, Output.WIRE)); return self; }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: createNoRowsTest() { ExampleTable table = new ColumnarExampleTable(Arrays.asList(ExampleTestTools.attributeInt()));  assertEquals(1, table.getAttributeCount()); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(0, table.size())
[-] pred: org. junit. Assert. assertEquals ( 0, table. size() )
************************************
************************************
[+] input: createNoRowsTwoAttributesRemoveTest() { ExampleTable table = new ColumnarExampleTable( Arrays.asList(ExampleTestTools.attributeInt(), ExampleTestTools.attributeReal())); table.removeAttribute(1);  assertEquals(1, table.getAttributeCount()); "<AssertPlaceHolder>"; }
size() { return size; }
[*] target: assertEquals(0, table.size())
[-] pred: org. junit. Assert. assertEquals ( 0, table. size() )
************************************
************************************
[+] input: testBooleanBoth() { final DictionaryInfo dictionaryInfo = new BooleanDictionaryInfo("bla", "blup"); assertEquals(new HashSet<>(Arrays.asList("bla", "blup")), dictionaryInfo.getValueSet()); assertEquals(MetaDataInfo.YES, dictionaryInfo.hasNegative()); assertEquals(MetaDataInfo.YES, dictionaryInfo.hasPositive()); assertTrue(dictionaryInfo.getNegativeValue().isPresent()); assertTrue(dictionaryInfo.getPositiveValue().isPresent()); assertEquals("bla",dictionaryInfo.getPositiveValue().get()); assertEquals("blup",dictionaryInfo.getNegativeValue().get()); "<AssertPlaceHolder>"; }
isBoolean() { return false; }
[*] target: assertTrue(dictionaryInfo.isBoolean())
[-] pred: org. junit. Assert. assertTrue ( dictionaryInfo. isBoolean() )
************************************
************************************
[+] input: testBooleanPositive() { final DictionaryInfo dictionaryInfo = new BooleanDictionaryInfo("bla", null); assertEquals(new HashSet<>(Collections.singletonList("bla")), dictionaryInfo.getValueSet()); assertEquals(MetaDataInfo.NO, dictionaryInfo.hasNegative()); assertEquals(MetaDataInfo.YES, dictionaryInfo.hasPositive()); assertFalse(dictionaryInfo.getNegativeValue().isPresent()); assertTrue(dictionaryInfo.getPositiveValue().isPresent()); assertEquals("bla",dictionaryInfo.getPositiveValue().get()); "<AssertPlaceHolder>"; }
isBoolean() { return false; }
[*] target: assertTrue(dictionaryInfo.isBoolean())
[-] pred: org. junit. Assert. assertTrue ( dictionaryInfo. isBoolean() )
************************************
************************************
[+] input: testBooleanNegative() { final DictionaryInfo dictionaryInfo = new BooleanDictionaryInfo(null, "blup"); assertEquals(new HashSet<>(Collections.singletonList("blup")), dictionaryInfo.getValueSet()); assertEquals(MetaDataInfo.YES, dictionaryInfo.hasNegative()); assertEquals(MetaDataInfo.NO, dictionaryInfo.hasPositive()); assertTrue(dictionaryInfo.getNegativeValue().isPresent()); assertFalse(dictionaryInfo.getPositiveValue().isPresent()); assertEquals("blup",dictionaryInfo.getNegativeValue().get()); "<AssertPlaceHolder>"; }
isBoolean() { return false; }
[*] target: assertTrue(dictionaryInfo.isBoolean())
[-] pred: org. junit. Assert. assertTrue ( dictionaryInfo. isBoolean() )
************************************
************************************
[+] input: shouldHaveLivenessWithRecordAudioParameters() { // Arrange final ReadableMap flowStepsMock = mock(ReadableMap.class); when(flowStepsMock.hasKey("welcome")).thenReturn(false); when(flowStepsMock.getBoolean("captureDocument")).thenReturn(false); when(flowStepsMock.hasKey("captureFace")).thenReturn(true);  ReadableMap livenessMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(livenessMock.getString("sdkToken")).thenReturn(sdkToken); String captureFaceType = "MOTION";  when(livenessMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  when(flowStepsMock.getMap("captureFace")).thenAnswer( (Answer<ReadableMap>) invocation -> { final ReadableMap flowStepsMock1 = mock(ReadableMap.class);  when(flowStepsMock1.getBoolean("recordAudio")).thenReturn(true); when(flowStepsMock1.hasKey("recordAudio")).thenReturn(true); when(flowStepsMock1.hasKey("type")).thenReturn(true); when(flowStepsMock1.getString("type")).thenReturn(captureFaceType); when(flowStepsMock1.hasKey("options")).thenReturn(true); return flowStepsMock1; });  Activity currentActivityMock = mock(Activity.class); OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(livenessMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); "<AssertPlaceHolder>"; assertNotNull(createdConfig.getFlowSteps()); assertNotNull(createdConfig.getFlowSteps().get(0)); FlowStep videoCaptureFlowStep = createdConfig.getFlowSteps().get(0); assertEquals(videoCaptureFlowStep.getAction(), FlowAction.ACTIVE_VIDEO_CAPTURE); assertNotNull(videoCaptureFlowStep.getOptions()); MotionCaptureVariantOptions options = (MotionCaptureVariantOptions) videoCaptureFlowStep.getOptions(); assertNotNull(options); assertNotNull(options.getAudioEnabled()); assertTrue(options.getAudioEnabled());  }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(createdConfig)
[-] pred: org. junit. Assert. assertNotNull ( createdConfig )
************************************
************************************
[+] input: shouldIncludeWelcomeScreenWhenConfiguredTo_singleFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", true, "captureDocument", mock(ReadableMap.class) ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps();  "<AssertPlaceHolder>"; assertEquals(FlowStep.WELCOME, resultingFlowSteps.get(0)); assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(1)); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: shouldIncludeWelcomeScreenWhenConfiguredTo_withAllowedDocumentTypesFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  JavaOnlyMap map = JavaOnlyMap.of( "allowedDocumentTypes", JavaOnlyArray.of("NATIONAL_IDENTITY_CARD", "PASSPORT") ); final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", true, "captureDocument", map ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps();  "<AssertPlaceHolder>"; assertEquals(FlowStep.WELCOME, resultingFlowSteps.get(0)); assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(1)); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: shouldHideWelcomeScreenWhenConfiguredTo_singleFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", false, "captureDocument", mock(ReadableMap.class) ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps();  "<AssertPlaceHolder>"; assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(0)); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: shouldHideWelcomeScreenWhenConfiguredTo_withAllowedDocumentTypesFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  JavaOnlyMap map = JavaOnlyMap.of( "allowedDocumentTypes", JavaOnlyArray.of("NATIONAL_IDENTITY_CARD", "PASSPORT") ); final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", false, "captureDocument", map ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps();  "<AssertPlaceHolder>"; assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(0)); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: shouldIncludeFlowStepsInTheRightOrder_singleFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", true, "proofOfAddress", true, "captureDocument", mock(ReadableMap.class), "captureFace", mock(ReadableMap.class) ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps(); "<AssertPlaceHolder>";  // Expected flow steps order: welcome - doc capture - POA - face capture  assertEquals(FlowStep.WELCOME, resultingFlowSteps.get(0)); assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(1)); assertEquals(FlowStep.PROOF_OF_ADDRESS, resultingFlowSteps.get(2));  FlowStep faceCaptureStep = resultingFlowSteps.get(3); assertEquals(FlowAction.CAPTURE_FACE, faceCaptureStep.getAction()); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: shouldIncludeFlowStepsInTheRightOrder_withAllowedDocumentTypesFiltering() { ReadableMap configMock = mock(ReadableMap.class); String sdkToken = "mockSdkToken123"; when(configMock.getString("sdkToken")).thenReturn(sdkToken);  JavaOnlyMap map = JavaOnlyMap.of( "allowedDocumentTypes", JavaOnlyArray.of("NATIONAL_IDENTITY_CARD", "PASSPORT") ); final ReadableMap flowStepsMock = JavaOnlyMap.of( "welcome", true, "proofOfAddress", true, "captureDocument", map, "captureFace", mock(ReadableMap.class) ); when(configMock.getMap("flowSteps")).thenAnswer( (Answer<ReadableMap>) invocation -> flowStepsMock );  // Use a spy to mock the internal call to getCurrentActivity Activity currentActivityMock = mock(Activity.class);  OnfidoSdkModule onfidoSdkModuleSpy = spy(onfidoSdkModule); when(onfidoSdkModuleSpy.getCurrentActivityInParentClass()).thenReturn(currentActivityMock);  // Act OnfidoConfig.builder(currentActivityMock) .withSDKToken(sdkToken) .withCustomFlow(new FlowStep[0]) .build();  onfidoSdkModuleSpy.start(configMock, promiseMock);  ArgumentCaptor<OnfidoConfig> configCaptor = ArgumentCaptor.forClass(OnfidoConfig.class);  verify(onfidoClientMock).startActivityForResult( eq(currentActivityMock), eq(OnfidoSdkActivityEventListener.checksActivityCode), configCaptor.capture() );  // Assert OnfidoConfig createdConfig = configCaptor.getValue(); List<FlowStep> resultingFlowSteps = createdConfig.getFlowSteps(); "<AssertPlaceHolder>";  // Expected flow steps order: welcome - doc capture - POA - face capture  assertEquals(FlowStep.WELCOME, resultingFlowSteps.get(0)); assertEquals(FlowStep.CAPTURE_DOCUMENT, resultingFlowSteps.get(1)); assertEquals(FlowStep.PROOF_OF_ADDRESS, resultingFlowSteps.get(2));  FlowStep faceCaptureStep = resultingFlowSteps.get(3); assertEquals(FlowAction.CAPTURE_FACE, faceCaptureStep.getAction()); }
start(final ReadableMap config, final Promise promise) {  setPromise(promise);  try { final String sdkToken; try { sdkToken = getSdkTokenFromConfig(config); } catch (Exception e) { currentPromise.reject("config_error", e); currentPromise = null; return; }  Activity currentActivity = getCurrentActivityInParentClass(); if (currentActivity == null) { currentPromise.reject("error", new Exception("Android activity does not exist")); currentPromise = null; return; }  try { final String workflowRunId = getWorkflowRunIdFromConfig(config);  if (!workflowRunId.isEmpty()) { workflowSDKConfiguration(config, currentActivity, sdkToken); } else { defaultSDKConfiguration(config, currentActivity, sdkToken); } } catch (final EnterpriseFeaturesInvalidLogoCobrandingException e) { currentPromise.reject("error", new EnterpriseFeaturesInvalidLogoCobrandingException()); currentPromise = null; } catch (final EnterpriseFeatureNotEnabledException e) { currentPromise.reject("error", new EnterpriseFeatureNotEnabledException("logoCobrand")); currentPromise = null; } catch (final Exception e) { currentPromise.reject("error", new Exception(e.getMessage(), e)); currentPromise = null; }  } catch (final Exception e) { e.printStackTrace(); // Wrap all unexpected exceptions. currentPromise.reject("error", new Exception("Unexpected error starting Onfido page", e)); currentPromise = null; } }
[*] target: assertNotNull(resultingFlowSteps)
[-] pred: org. junit. Assert. assertNotNull ( resultingFlowSteps )
************************************
************************************
[+] input: InvocationTargetException { Field f = RestrictionBypass.getDeclaredField(this.getClass(), "testField1"); "<AssertPlaceHolder>"; assertSame(f.get(this), testField1); }
getDeclaredField(Class obj, String name) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) { return NativeReflectionBypass.getDeclaredField(obj, name); } else { Method getDeclaredField = Class.class.getMethod("getDeclaredField", String.class); return (Field) getDeclaredField.invoke(obj, name); } }
[*] target: assertNotNull(f)
[-] pred: org. junit. Assert. assertNotNull ( f )
************************************
************************************
[+] input: InvocationTargetException { Field f = RestrictionBypass.getDeclaredField(this.getClass(), "testField2"); "<AssertPlaceHolder>"; assertSame(f.get(this), testField2); }
getDeclaredField(Class obj, String name) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) { return NativeReflectionBypass.getDeclaredField(obj, name); } else { Method getDeclaredField = Class.class.getMethod("getDeclaredField", String.class); return (Field) getDeclaredField.invoke(obj, name); } }
[*] target: assertNotNull(f)
[-] pred: org. junit. Assert. assertNotNull ( f )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = userService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserError() { mockServerReturnObject(USER_MIKE, 0, ERROR_CODE); User user = userService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserAsync() { mockServerReturnObject(USER_MIKE); CompletableFuture<User> userCompletableFuture = userService.getUserAsync(Long100); "<AssertPlaceHolder>"; User user; try { user = userCompletableFuture.get(); } catch (Exception e) { throw new IllegalStateException("userCompletableFuture get error"); } assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserAsync(@Query("id") Long id);
[*] target: assertNotNull(userCompletableFuture)
[-] pred: org. junit. Assert. assertNotNull ( userCompletableFuture )
************************************
************************************
[+] input: getUserReturnResponse() { mockServerReturnObject(USER_MIKE); Response<User> userReturnResponse = userService.getUserReturnResponse(Long100); "<AssertPlaceHolder>"; assertEquals(SUCCESS_CODE, userReturnResponse.code()); User user = userReturnResponse.body(); assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserReturnResponse(@Query("id") Long id);
[*] target: assertNotNull(userReturnResponse)
[-] pred: org. junit. Assert. assertNotNull ( userReturnResponse )
************************************
************************************
[+] input: getUserReturnCall() { mockServerReturnObject(USER_MIKE); Call<User> userReturnCall = userService.getUserReturnCall(Long100); "<AssertPlaceHolder>"; try { Response<User> userResponse = userReturnCall.execute(); assertEquals(SUCCESS_CODE, userResponse.code()); User user = userResponse.body(); assertNotNull(user); assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); } catch (IOException e) { throw new IllegalStateException("userReturnCall execute error"); } }
getUserReturnCall(@Query("id") Long id);
[*] target: assertNotNull(userReturnCall)
[-] pred: org. junit. Assert. assertNotNull ( userReturnCall )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = chooserOkHttpUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = logUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE); User user = metaAnnotationUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserReturnSingleForRx2() { mockServerReturnObject(USER_MIKE); Single<User> userReturnSingle = rxJava2UserService.getUserReturnSingleForRx2(Long100); User user = userReturnSingle.blockingGet(); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserReturnSingleForRx2(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUserReturnSingleForRx3() { mockServerReturnObject(USER_MIKE); Single<User> userReturnSingle = rxJava3UserService.getUserReturnSingleForRx3(Long100); User user = userReturnSingle.blockingGet(); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUserReturnSingleForRx3(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: getUser() { mockServerReturnObject(USER_MIKE, 0, ERROR_CODE); mockServerReturnObject(USER_MIKE, 0, ERROR_CODE); mockServerReturnObject(USER_MIKE, 0, SUCCESS_CODE); User user = globalRetryUserService.getUser(Long100); "<AssertPlaceHolder>"; assertEquals(Long100, user.getId()); assertEquals(MIKE, user.getName()); assertEquals(INT20, user.getAge()); assertTrue(user.isMale()); }
getUser(@Query("id") Long id);
[*] target: assertNotNull(user)
[-] pred: org. junit. Assert. assertNotNull ( user )
************************************
************************************
[+] input: distribution() {  SLD.Distribution<Object> actual = SLD.extractDistributions(graph)[0];  SLD.Distribution<Object> expected = new DistributionBuilder(""). access("ws://localhost:4567/access/colours", false) .format(Format.STRING) .license(License.CC) .protocol(Protocol.WebSocket) .security(Security.SSL) .publisher(SLD.extractPublisher(g)) .buildSource(g);   //        expected.describe().stream().forEach(triple -> { //            assertTrue(actual.describe().contains(triple)); //        }); // //        actual.describe().stream().forEach(triple -> { //            assertTrue(expected.describe().contains(triple)); // //        });   SLD.WebDataStream<Object> expectedWebStream = expected.getWebStream(); SLD.WebDataStream<Object> actualWebStream = actual.getWebStream();  "<AssertPlaceHolder>"; }
getWebStream(); }   public interface WebStream<E> extends Describable, Named {  SLD.Publisher publisher();  WebDataStream<E> serve();  }
[*] target: assertEquals(expectedWebStream, actualWebStream)
[-] pred: org. junit. Assert. assertEquals ( expectedWebStream, actualWebStream )
************************************
************************************
[+] input: testLoadUserBySAML() { // given NameID mockNameID = mock(NameID.class); when(mockNameID.getValue()).thenReturn(USER_NAME);  SAMLCredential credentialsMock = mock(SAMLCredential.class); when(credentialsMock.getNameID()).thenReturn(mockNameID);  // when Object actual = userDetailsService.loadUserBySAML(credentialsMock);  // / then "<AssertPlaceHolder>"; assertTrue(actual instanceof User);  User user = (User) actual; assertEquals(USER_NAME, user.getUsername()); assertEquals(USER_PASSWORD, user.getPassword()); assertTrue(user.isEnabled()); assertTrue(user.isAccountNonExpired()); assertTrue(user.isCredentialsNonExpired()); assertTrue(user.isAccountNonLocked()); assertEquals(1, user.getAuthorities().size());  List<GrantedAuthority> authorities = new ArrayList<>(user.getAuthorities()); Object authority = authorities.get(0);  assertTrue(authority instanceof SimpleGrantedAuthority); assertEquals(USER_ROLE, ((SimpleGrantedAuthority) authority).getAuthority()); }
loadUserBySAML(SAMLCredential credential) {  // The method is supposed to identify local account of user referenced by // data in the SAML assertion and return UserDetails object describing the user.  String userID = credential.getNameID().getValue();  LOG.info("{} is logged in", userID); List<GrantedAuthority> authorities = new ArrayList<>(); GrantedAuthority authority = new SimpleGrantedAuthority("ROLE_USER"); authorities.add(authority);  // In a real scenario, this implementation has to locate user in a arbitrary // dataStore based on information present in the SAMLCredential and // returns such a date in a form of application specific UserDetails object. return new User(userID, "<abc123>", true, true, true, true, authorities); }
[*] target: assertNotNull(actual)
[-] pred: org. junit. Assert. assertNotNull ( actual )
************************************
************************************
[+] input: testHashCodeAndEquals() { List<CrontabEntry> entries = ImmutableList.of( CrontabEntry.parse("* * * * *"), CrontabEntry.parse("0-59 * * * *"), CrontabEntry.parse("0-57,58,59 * * * *"), CrontabEntry.parse("* 23,1,2,4,0-22 * * *"), CrontabEntry.parse("1-50,0,51-59 * * * sun-sat"));  for (CrontabEntry lhs : entries) { for (CrontabEntry rhs : entries) { "<AssertPlaceHolder>"; } }  assertEquals(1, ImmutableSet.copyOf(entries).size()); }
parse(String schedule) throws IllegalArgumentException { return new Parser(schedule).get(); }
[*] target: assertEquals(lhs, rhs)
[-] pred: org. junit. Assert. assertEquals ( lhs, rhs )
************************************
************************************
[+] input: testWildcards() { CrontabEntry wildcardMinuteEntry = CrontabEntry.parse("* 1 1 1 *"); assertEquals("*", wildcardMinuteEntry.getMinuteAsString()); assertTrue(wildcardMinuteEntry.hasWildcardMinute()); assertFalse(wildcardMinuteEntry.hasWildcardHour()); assertFalse(wildcardMinuteEntry.hasWildcardDayOfMonth()); assertFalse(wildcardMinuteEntry.hasWildcardMonth()); assertTrue(wildcardMinuteEntry.hasWildcardDayOfWeek());  CrontabEntry wildcardHourEntry = CrontabEntry.parse("1 * 1 1 *"); assertEquals("*", wildcardHourEntry.getHourAsString()); assertFalse(wildcardHourEntry.hasWildcardMinute()); assertTrue(wildcardHourEntry.hasWildcardHour()); assertFalse(wildcardHourEntry.hasWildcardDayOfMonth()); assertFalse(wildcardHourEntry.hasWildcardMonth()); assertTrue(wildcardHourEntry.hasWildcardDayOfWeek());  CrontabEntry wildcardDayOfMonth = CrontabEntry.parse("1 1 * 1 *"); assertEquals("*", wildcardDayOfMonth.getDayOfMonthAsString()); assertFalse(wildcardDayOfMonth.hasWildcardMinute()); assertFalse(wildcardDayOfMonth.hasWildcardHour()); assertTrue(wildcardDayOfMonth.hasWildcardDayOfMonth()); assertFalse(wildcardDayOfMonth.hasWildcardMonth()); assertTrue(wildcardDayOfMonth.hasWildcardDayOfWeek());  CrontabEntry wildcardMonth = CrontabEntry.parse("1 1 1 * *"); assertEquals("*", wildcardMonth.getMonthAsString()); assertFalse(wildcardMonth.hasWildcardMinute()); assertFalse(wildcardMonth.hasWildcardHour()); assertFalse(wildcardMonth.hasWildcardDayOfMonth()); assertTrue(wildcardMonth.hasWildcardMonth()); assertTrue(wildcardMonth.hasWildcardDayOfWeek());  CrontabEntry wildcardDayOfWeek = CrontabEntry.parse("1 1 1 1 *"); assertEquals("*", wildcardDayOfWeek.getDayOfWeekAsString()); assertFalse(wildcardDayOfWeek.hasWildcardMinute()); assertFalse(wildcardDayOfWeek.hasWildcardHour()); assertFalse(wildcardDayOfWeek.hasWildcardDayOfMonth()); assertFalse(wildcardDayOfWeek.hasWildcardMonth()); "<AssertPlaceHolder>"; }
hasWildcardDayOfWeek() { return getDayOfWeek().encloses(DAY_OF_WEEK); }
[*] target: assertTrue(wildcardDayOfWeek.hasWildcardDayOfWeek())
[-] pred: org. junit. Assert. assertTrue ( wildcardDayOfWeek. hasWildcardDayOfWeek ( ) )
************************************
************************************
[+] input: testAggregate() { expectGetAttributes( "a1", attribute("host", "a1"), attribute("rack", "a"), attribute("pdu", "p1")); expectGetAttributes( "b1", attribute("host", "b1"), attribute("rack", "b"), attribute("pdu", "p1", "p2")) .times(2); expectGetAttributes( "b2", attribute("host", "b2"), attribute("rack", "b"), attribute("pdu", "p1", "p2")); expectGetAttributes( "c1", attribute("host", "c1"), attribute("rack", "c"), attribute("pdu", "p2"), attribute("ssd", "true"));  control.replay();  Multiset<Pair<String, String>> expected = ImmutableMultiset.<Pair<String, String>>builder() .add(Pair.of("rack", "a")) .addCopies(Pair.of("rack", "b"), 3) .add(Pair.of("rack", "c")) .add(Pair.of("host", "a1")) .addCopies(Pair.of("host", "b1"), 2) .add(Pair.of("host", "b2")) .add(Pair.of("host", "c1")) .addCopies(Pair.of("pdu", "p1"), 4) .addCopies(Pair.of("pdu", "p2"), 4) .add(Pair.of("ssd", "true")) .build(); AttributeAggregate aggregate = aggregate( task("1", "a1"), task("2", "b1"), task("3", "b1"), task("4", "b2"), task("5", "c1")); "<AssertPlaceHolder>"; for (Multiset.Entry<Pair<String, String>> entry : expected.entrySet()) { Pair<String, String> element = entry.getElement(); assertAggregate(aggregate, element.getFirst(), element.getSecond(), entry.getCount()); } assertAggregate(aggregate, "host", "c2", 0L); assertAggregate(aggregate, "hostc", "2", 0L); }
getAggregates() { return aggregate.get(); }
[*] target: assertEquals(expected, aggregate.getAggregates())
[-] pred: org. junit. Assert. assertEquals ( expected, aggregate. getAggregates ( ) )
************************************
************************************
[+] input: Exception { Snapshot snapshot = makeSnapshot(); expect(delegate.from(anyObject())).andReturn(snapshot).times(3);  control.replay();  triggerSnapshot(snapshot); assertBackupCount(0); clock.advance(Amount.of(INTERVAL.as(Time.MILLISECONDS) - 1, Time.MILLISECONDS)); triggerSnapshot(snapshot); assertBackupCount(0); clock.advance(Amount.of(1L, Time.MILLISECONDS)); triggerSnapshot(snapshot); assertBackupCount(1); assertEquals(1, storageBackup.getSuccesses().get());  @Nullable File[] files = config.getDir().listFiles(); "<AssertPlaceHolder>";  Snapshot restored = ThriftBinaryCodec.decode(Snapshot.class, Files.toByteArray(files[0])); assertEquals(snapshot, restored); }
getDir() { return dir; }
[*] target: assertNotNull(files)
[-] pred: org. junit. Assert. assertNotNull ( files )
************************************
************************************
[+] input: testObjectOverrides() { control.replay();  JobDiff a = new JobDiff( ImmutableMap.of(0, makeTask("job", "echo")), ImmutableSet.of(0), ImmutableMap.of()); JobDiff b = new JobDiff( ImmutableMap.of(0, makeTask("job", "echo")), ImmutableSet.of(0), ImmutableMap.of()); JobDiff c = new JobDiff( ImmutableMap.of(0, makeTask("job", "echo1")), ImmutableSet.of(0), ImmutableMap.of()); JobDiff d = new JobDiff( ImmutableMap.of(0, makeTask("job", "echo")), ImmutableSet.of(1), ImmutableMap.of()); assertEquals(a, b); assertEquals(ImmutableSet.of(a), ImmutableSet.of(a, b)); assertNotEquals(a, c); assertNotEquals(a, "a string"); assertNotEquals(a, d); "<AssertPlaceHolder>"; }
toString() { return MoreObjects.toStringHelper(this) .add("replacedInstances", getReplacedInstances()) .add("replacementInstances", getReplacementInstances()) .add("unchangedInstances", getUnchangedInstances()) .toString(); }
[*] target: assertEquals(a.toString(), b.toString())
[-] pred: org. junit. Assert. assertEquals ( a. toString ( ), b. toString ( ) )
************************************
************************************
[+] input: builderShouldSetValues() { User user = new User("ziltoid"); AuthenticationInfo authInfo = helper.createAuthenticationInfo("unit-test", user);  "<AssertPlaceHolder>"; assertEquals("ziltoid", authInfo.getPrincipals().getPrimaryPrincipal()); assertThat(authInfo.getPrincipals().getRealmNames(), hasItem("unit-test")); assertEquals(user, authInfo.getPrincipals().oneByType(User.class)); }
createAuthenticationInfo(String realm, User user) { SimplePrincipalCollection collection = new SimplePrincipalCollection();  collection.add(user.getId(), realm); collection.add(user, realm);  return new SimpleAuthenticationInfo(collection, user.getPassword()); }
[*] target: assertNotNull(authInfo)
[-] pred: org. junit. Assert. assertNotNull ( authInfo )
************************************
************************************
[+] input: IOException { // without default branch, the repository head should be used FileObject root = createCommand().getBrowserResult(new BrowseCommandRequest()).getFile(); assertNotNull(root);  Collection<FileObject> foList = root.getChildren(); "<AssertPlaceHolder>"; assertFalse(foList.isEmpty());  assertThat(foList) .extracting("name") .containsExactly("c", "a.txt", "b.txt", "f.txt"); }
getChildren() { if (!sorted) { sort(children, entry -> entry.type != TreeType.FILE, TreeEntry::getNameString); sorted = true; } return children; }
[*] target: assertNotNull(foList)
[-] pred: org. junit. Assert. assertNotNull ( foList )
************************************
************************************
[+] input: IOException { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(2, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); line = result.getLine(1); assertEquals(2, line.getLineNumber()); assertEquals("2baab8e80280ef05a9aa76c49c76feca2872afb7", line.getRevision()); checkDate(line.getWhen()); assertEquals("line for blame", line.getCode()); assertEquals("added new line for blame", line.getDescription()); assertEquals("Zaphod Beeblebrox", line.getAuthor().getName()); assertEquals("zaphod.beeblebrox@hitchhiker.com", line.getAuthor().getMail()); }
getBlameResult(BlameCommandRequest request) throws IOException { if (logger.isDebugEnabled()) { logger.debug("get blame result for {}", request); }  AnnotateCommand cmd = AnnotateCommand.on(open());  cmd.rev(HgUtil.getRevision(request.getRevision()));  List<BlameLine> blameLines = Lists.newArrayList(); List<AnnotateLine> lines = cmd.execute(request.getPath()); int counter = 0;  for (AnnotateLine line : lines) { blameLines.add(convert(line, ++counter)); }  return new BlameResult(blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt"); request.setRevision("a9bacaf1b7fa0cebfca71fed4e59ed69a6319427");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(1, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); }
getBlameResult(BlameCommandRequest request) throws IOException { if (logger.isDebugEnabled()) { logger.debug("get blame result for {}", request); }  AnnotateCommand cmd = AnnotateCommand.on(open());  cmd.rev(HgUtil.getRevision(request.getRevision()));  List<BlameLine> blameLines = Lists.newArrayList(); List<AnnotateLine> lines = cmd.execute(request.getPath()); int counter = 0;  for (AnnotateLine line : lines) { blameLines.add(convert(line, ++counter)); }  return new BlameResult(blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BrowseCommandRequest request = new BrowseCommandRequest();  request.setPath("c");  BrowserResult result = new HgBrowseCommand(cmdContext).getBrowserResult(request);  "<AssertPlaceHolder>";  FileObject c = result.getFile(); assertEquals("c", c.getName()); Collection<FileObject> foList = c.getChildren();  assertThat(foList) .extracting("name") .containsExactly("d.txt", "e.txt");  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(2, foList.size());  FileObject d = null; FileObject e = null;  for (FileObject f : foList) { if ("d.txt".equals(f.getName())) { d = f; } else if ("e.txt".equals(f.getName())) { e = f; } }  assertNotNull(d); assertFalse(d.isDirectory()); assertEquals("d.txt", d.getName()); assertEquals("c/d.txt", d.getPath()); assertEquals("added file d and e in folder c", d.getDescription().get()); assertTrue(d.getLength().getAsLong() > 0); checkDate(d.getCommitDate().getAsLong()); assertNotNull(e); assertFalse(e.isDirectory()); assertEquals("e.txt", e.getName()); assertEquals("c/e.txt", e.getPath()); assertEquals("added file d and e in folder c", e.getDescription().get()); assertTrue(e.getLength().getAsLong() > 0); checkDate(e.getCommitDate().getAsLong()); }
getBrowserResult(BrowseCommandRequest request) throws IOException { HgFileviewCommand cmd = HgFileviewCommand.on(open());  String revision = MoreObjects.firstNonNull(request.getRevision(), "tip"); Changeset c = LogCommand.on(getContext().open()).rev(revision).limit(1).single();  if (c != null) { cmd.rev(c.getNode()); }  if (!Strings.isNullOrEmpty(request.getPath())) { cmd.path(request.getPath()); }  if (request.isDisableLastCommit()) { cmd.disableLastCommit(); }  if (request.isRecursive()) { cmd.recursive(); }  if (request.isDisableSubRepositoryDetection()) { cmd.disableSubRepositoryDetection(); }  cmd.setLimit(request.getLimit()); cmd.setOffset(request.getOffset());  FileObject file = cmd.execute() .orElseThrow(() -> notFound(entity("File", request.getPath()).in("Revision", revision).in(getRepository()))); return new BrowserResult(c == null? "tip": c.getNode(), revision, file); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { BrowseCommandRequest request = new BrowseCommandRequest();  request.setRecursive(true);  BrowserResult result = new HgBrowseCommand(cmdContext).getBrowserResult(request);  "<AssertPlaceHolder>";  FileObject root = result.getFile(); Collection<FileObject> foList = root.getChildren();  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(4, foList.size());  FileObject c = getFileObject(foList, "c"); assertTrue(c.isDirectory()); assertEquals(2, c.getChildren().size()); }
getBrowserResult(BrowseCommandRequest request) throws IOException { HgFileviewCommand cmd = HgFileviewCommand.on(open());  String revision = MoreObjects.firstNonNull(request.getRevision(), "tip"); Changeset c = LogCommand.on(getContext().open()).rev(revision).limit(1).single();  if (c != null) { cmd.rev(c.getNode()); }  if (!Strings.isNullOrEmpty(request.getPath())) { cmd.path(request.getPath()); }  if (request.isDisableLastCommit()) { cmd.disableLastCommit(); }  if (request.isRecursive()) { cmd.recursive(); }  if (request.isDisableSubRepositoryDetection()) { cmd.disableSubRepositoryDetection(); }  cmd.setLimit(request.getLimit()); cmd.setOffset(request.getOffset());  FileObject file = cmd.execute() .orElseThrow(() -> notFound(entity("File", request.getPath()).in("Revision", revision).in(getRepository()))); return new BrowserResult(c == null? "tip": c.getNode(), revision, file); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: IOException { writeNewFile(outgoing, outgoingDirectory, "a.txt", "Content of file a.txt"); writeNewFile(outgoing, outgoingDirectory, "b.txt", "Content of file b.txt");  Changeset c1 = commit(outgoing, "added a and b");  writeNewFile(outgoing, outgoingDirectory, "c.txt", "Content of file c.txt"); writeNewFile(outgoing, outgoingDirectory, "d.txt", "Content of file d.txt");  Changeset c2 = commit(outgoing, "added c and d");  HgIncomingCommand cmd = createIncomingCommand(); IncomingCommandRequest request = new IncomingCommandRequest();  request.setRemoteRepository(outgoingRepository);  ChangesetPagingResult cpr = cmd.getIncomingChangesets(request);  "<AssertPlaceHolder>"; assertEquals(2, cpr.getTotal()); assertChangesetsEqual(c1, cpr.getChangesets().get(0)); assertChangesetsEqual(c2, cpr.getChangesets().get(1)); }
getIncomingChangesets(IncomingCommandRequest request) { File remoteRepository = handler.getDirectory(request.getRemoteRepository().getId());  org.javahg.Repository repository = open();  // TODO implement paging  List<Changeset> changesets;  try {  changesets = on(repository).execute(remoteRepository.getAbsolutePath());  } catch (ExecutionException ex) { if (ex.getCommand().getReturnCode() == NO_INCOMING_CHANGESETS) { changesets = Collections.emptyList(); } else { throw new InternalRepositoryException(getRepository(), "could not execute incoming command", ex); } }  return new ChangesetPagingResult(changesets.size(), changesets); }
[*] target: assertNotNull(cpr)
[-] pred: org. junit. Assert. assertNotNull ( cpr )
************************************
************************************
[+] input: IOException { HgLogCommand command = createCommand(); String revision = "a9bacaf1b7fa0cebfca71fed4e59ed69a6319427"; Changeset c = command.getChangeset(revision, null);  "<AssertPlaceHolder>"; assertEquals(revision, c.getId()); assertEquals("added a and b files", c.getDescription()); checkDate(c.getDate()); assertEquals("Douglas Adams", c.getAuthor().getName()); assertEquals("douglas.adams@hitchhiker.com", c.getAuthor().getMail()); assertEquals("added a and b files", c.getDescription()); ModificationsCommand modificationsCommand = new HgModificationsCommand(cmdContext); Modifications modifications = modificationsCommand.getModifications(revision);  assertNotNull(modifications); assertTrue("modified list should be empty", modifications.getModified().isEmpty()); assertTrue("removed list should be empty", modifications.getRemoved().isEmpty()); assertFalse("added list should not be empty", modifications.getAdded().isEmpty()); assertEquals(2, modifications.getAdded().size()); assertThat(modifications.getAdded()) .extracting("path") .containsExactly("a.txt", "b.txt"); }
getChangeset(String id, LogCommandRequest request) { org.javahg.Repository repository = open(); HgLogChangesetCommand cmd = on(repository);  return cmd.rev(id).single(); }
[*] target: assertNotNull(c)
[-] pred: org. junit. Assert. assertNotNull ( c )
************************************
************************************
[+] input: IOException { writeNewFile(outgoing, outgoingDirectory, "a.txt", "Content of file a.txt"); writeNewFile(outgoing, outgoingDirectory, "b.txt", "Content of file b.txt");  Changeset c1 = commit(outgoing, "added a and b");  writeNewFile(outgoing, outgoingDirectory, "c.txt", "Content of file c.txt"); writeNewFile(outgoing, outgoingDirectory, "d.txt", "Content of file d.txt");  Changeset c2 = commit(outgoing, "added c and d");  HgOutgoingCommand cmd = createOutgoingCommand(); OutgoingCommandRequest request = new OutgoingCommandRequest();  request.setRemoteRepository(incomingRepository);  ChangesetPagingResult cpr = cmd.getOutgoingChangesets(request);  "<AssertPlaceHolder>"; assertEquals(2, cpr.getTotal()); assertChangesetsEqual(c1, cpr.getChangesets().get(0)); assertChangesetsEqual(c2, cpr.getChangesets().get(1)); }
getOutgoingChangesets( OutgoingCommandRequest request) { File remoteRepository = handler.getDirectory(request.getRemoteRepository().getId());  org.javahg.Repository repository = open();  // TODO implement paging  List<Changeset> changesets;  try { changesets = on(repository).execute(remoteRepository.getAbsolutePath()); } catch (ExecutionException ex) { if (ex.getCommand().getReturnCode() == NO_OUTGOING_CHANGESETS) { changesets = Collections.emptyList(); } else { throw new InternalRepositoryException(getRepository(), "could not execute outgoing command", ex); } }  return new ChangesetPagingResult(changesets.size(), changesets); }
[*] target: assertNotNull(cpr)
[-] pred: org. junit. Assert. assertNotNull ( cpr )
************************************
************************************
[+] input: testDoGetAuthenticationInfo() { User user = UserTestData.createTrillian();  user.setPassword(new Sha1Hash("secret").toHex()); when(userDAO.get("tricia")).thenReturn(user);  AuthenticationToken token = new UsernamePasswordToken("tricia", "secret"); AuthenticationInfo authInfo = realm.doGetAuthenticationInfo(token);  "<AssertPlaceHolder>"; assertEquals("tricia", authInfo.getPrincipals().getPrimaryPrincipal()); }
doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { Preconditions.checkArgument(token instanceof UsernamePasswordToken, "unsupported token"); return returnOnHexCredentials(helper.getAuthenticationInfo(token)); }
[*] target: assertNotNull(authInfo)
[-] pred: org. junit. Assert. assertNotNull ( authInfo )
************************************
************************************
[+] input: testGetBlameResultWithRevision() { BlameCommandRequest request = new BlameCommandRequest();  request.setPath("a.txt"); request.setRevision("3");  BlameResult result = createCommand().getBlameResult(request);  "<AssertPlaceHolder>"; assertEquals(1, result.getTotal());  BlameLine line = result.getLine(0);  checkFirstLine(line); }
getBlameResult(BlameCommandRequest request) { String path = request.getPath(); String revision = request.getRevision(); List<BlameLine> blameLines = Lists.newArrayList(); SVNRevision endRevision = null;  if (Util.isNotEmpty(revision)) { endRevision = SVNRevision.create(Long.parseLong(revision)); } else { endRevision = SVNRevision.HEAD; }  try { SVNURL svnurl = SVNURL.fromFile(new File(context.getDirectory(), path)); SVNRepository svnRepository = SVNRepositoryFactory.create(context.createUrl()); ISVNAuthenticationManager svnManager = svnRepository.getAuthenticationManager(); SVNLogClient svnLogClient = new SVNLogClient(svnManager, null);  svnLogClient.doAnnotate(svnurl, SVNRevision.UNDEFINED, SVNRevision.create(1l), endRevision, new SvnBlameHandler(svnRepository, path, blameLines)); } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not create blame result", ex); }  return new BlameResult(blameLines.size(), blameLines); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testBrowse() { BrowserResult result = createCommand().getBrowserResult(new BrowseCommandRequest());  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("c", "a.txt");  Iterator<FileObject> iterator = foList.iterator(); FileObject c = iterator.next(); FileObject a = iterator.next();  assertFalse(a.isDirectory()); assertEquals("a.txt", a.getName()); assertEquals("a.txt", a.getPath()); assertEquals("added line for blame test", a.getDescription().get()); assertTrue(a.getLength().getAsLong() > 0); checkDate(a.getCommitDate().getAsLong()); assertTrue(c.isDirectory()); assertEquals("c", c.getName()); assertEquals("c", c.getPath()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testBrowseSubDirectory() { BrowseCommandRequest request = new BrowseCommandRequest();  request.setPath("c");  BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("d.txt", "e.txt");  Iterator<FileObject> iterator = foList.iterator(); FileObject d = iterator.next(); FileObject e = iterator.next();  assertNotNull(d); assertFalse(d.isDirectory()); assertEquals("d.txt", d.getName()); assertEquals("c/d.txt", d.getPath()); assertEquals("added d and e in folder c", d.getDescription().get()); assertTrue(d.getLength().getAsLong() > 0); checkDate(d.getCommitDate().getAsLong()); assertNotNull(e); assertFalse(e.isDirectory()); assertEquals("e.txt", e.getName()); assertEquals("c/e.txt", e.getPath()); assertEquals("added d and e in folder c", e.getDescription().get()); assertTrue(e.getLength().getAsLong() > 0); checkDate(e.getCommitDate().getAsLong()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDisableLastCommit() { BrowseCommandRequest request = new BrowseCommandRequest();  request.setDisableLastCommit(true);  BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList1 = result.getFile().getChildren();  assertNotNull(foList1); assertFalse(foList1.isEmpty()); assertEquals(2, foList1.size());  Collection<FileObject> foList = foList1;  FileObject a = getFileObject(foList, "a.txt");  assertFalse(a.getDescription().isPresent()); assertFalse(a.getCommitDate().isPresent()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testRecursive() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setRecursive(true); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertNotNull(foList); assertFalse(foList.isEmpty()); assertEquals(2, foList.size());  FileObject c = getFileObject(foList, "c"); assertEquals("c", c.getName()); assertTrue(c.isDirectory()); assertEquals(2, c.getChildren().size()); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testLimit() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setLimit(1); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).extracting("name").containsExactly("c", "a.txt"); assertThat(result.getFile().isTruncated()).isTrue(); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testOffset() { BrowseCommandRequest request = new BrowseCommandRequest(); request.setOffset(1); BrowserResult result = createCommand().getBrowserResult(request);  "<AssertPlaceHolder>";  Collection<FileObject> foList = result.getFile().getChildren();  assertThat(foList).isEmpty(); }
getBrowserResult(BrowseCommandRequest request) { String path = Strings.nullToEmpty(request.getPath()); long revisionNumber = SvnUtil.getRevisionNumber(request.getRevision(), repository);  if (logger.isDebugEnabled()) { logger.debug("browser repository {} in path "{}" at revision {}", repository, path, revisionNumber); }  resultCount = 0;  BrowserResult result = null;  try { SVNRepository svnRepository = open();  if (revisionNumber == -1) { revisionNumber = svnRepository.getLatestRevision(); }  SVNDirEntry rootEntry = svnRepository.info(path, revisionNumber); FileObject root = createFileObject(request, svnRepository, revisionNumber, rootEntry, path); root.setPath(path);  if (root.isDirectory()) { traverse(svnRepository, revisionNumber, request, root, createBasePath(path)); }   result = new BrowserResult(String.valueOf(revisionNumber), root); } catch (SVNException ex) { if (FS_NO_SUCH_REVISION.equals(ex.getErrorMessage().getErrorCode())) { throw notFound(entity("Revision", Long.toString(revisionNumber)).in(this.repository)); } logger.error("could not open repository: " + repository.getNamespaceAndName(), ex); }  return result; }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testGetCommit() { Changeset c = createCommand().getChangeset("3", null);  "<AssertPlaceHolder>"; assertEquals("3", c.getId()); assertEquals("remove b and modified a", c.getDescription()); checkDate(c.getDate()); assertEquals("perfect", c.getAuthor().getName()); assertNull("douglas.adams@hitchhiker.com", c.getAuthor().getMail()); SvnModificationsCommand modificationsCommand = new SvnModificationsCommand(createContext()); Modifications modifications = modificationsCommand.getModifications("3");  assertNotNull(modifications); assertEquals(1, modifications.getModified().size()); assertEquals(1, modifications.getRemoved().size()); assertTrue("added list should be empty", modifications.getAdded().isEmpty()); assertEquals("a.txt", modifications.getModified().get(0).getPath()); assertEquals("b.txt", modifications.getRemoved().get(0).getPath()); }
getChangeset(String revision, LogCommandRequest request) { Changeset changeset = null;  if (LOG.isDebugEnabled()) { LOG.debug("fetch changeset {}", revision); }  try { long revisioNumber = parseRevision(revision, repository); Preconditions.checkArgument(revisioNumber > 0, "revision must be greater than zero: %d", revisioNumber); SVNRepository repo = open(); Collection<SVNLogEntry> entries = repo.log(null, null, revisioNumber, revisioNumber, true, true);  if (Util.isNotEmpty(entries)) { changeset = SvnUtil.createChangeset(entries.iterator().next()); } } catch (SVNException ex) { throw new InternalRepositoryException(repository, "could not open repository", ex); }  return changeset; }
[*] target: assertNotNull(c)
[-] pred: org. junit. Assert. assertNotNull ( c )
************************************
************************************
[+] input: testHealthyAndDead() { System.setProperty(DashboardConfig.CONFIG_UNHEALTHY_MACHINE_MILLIS, "60000"); System.setProperty(DashboardConfig.CONFIG_AUTO_REMOVE_MACHINE_MILLIS, "600000"); DashboardConfig.clearCache(); MachineInfo machineInfo = new MachineInfo(); machineInfo.setHeartbeatVersion(1); machineInfo.setLastHeartbeat(System.currentTimeMillis() - 10000); assertTrue(machineInfo.isHealthy()); assertFalse(machineInfo.isDead());  machineInfo.setLastHeartbeat(System.currentTimeMillis() - 100000); assertFalse(machineInfo.isHealthy()); assertFalse(machineInfo.isDead());  machineInfo.setLastHeartbeat(System.currentTimeMillis() - 1000000); assertFalse(machineInfo.isHealthy()); "<AssertPlaceHolder>"; }
isDead() { if (DashboardConfig.getAutoRemoveMachineMillis() > 0) { long delta = System.currentTimeMillis() - lastHeartbeat; return delta > DashboardConfig.getAutoRemoveMachineMillis(); } return false; }
[*] target: assertTrue(machineInfo.isDead())
[-] pred: org. junit. Assert. assertTrue ( machineInfo. isDead() )
************************************
************************************
[+] input: reachingMaxSize() { for (long i = 1; i <= counterMetadata.getThreshold(); i++) { alertCounter.update(new AlertContext(i, new Object[]{"secret", i})); Assert.assertEquals(1, alertCounter.getOldest().longValue()); Assert.assertEquals(i, alertCounter.getSize()); }  alertCounter.update(new AlertContext(8, new Object[]{"secret", 1001})); Assert.assertEquals(2, alertCounter.getOldest().longValue()); Assert.assertEquals(counterMetadata.getThreshold(), alertCounter.getSize()); var fieldsToSend = alertCounter.getCorrelatedAlerts(fieldNames); Assert."<AssertPlaceHolder>"; Assert.assertEquals(1000, fieldsToSend.size()); var variableSet = new HashSet<Long>(); for (var stringObjectMap : fieldsToSend) { Assert.assertEquals(2, stringObjectMap.size()); Assert.assertTrue(stringObjectMap.get("constant") instanceof String); Assert.assertTrue(stringObjectMap.get("variable") instanceof Number); Assert.assertEquals("secret", stringObjectMap.get("constant")); variableSet.add(((Number) stringObjectMap.get("variable")).longValue()); } Assert.assertEquals(1000, variableSet.size()); }
isEmpty() { return alertContextHeap.isEmpty(); }
[*] target: assertFalse(fieldsToSend.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( fieldsToSend. isEmpty() )
************************************
************************************
[+] input: cleaningCounterComplete() { alertCounter.update(new AlertContext(1, new Object[]{"secret", 1})); Assert.assertEquals(1, alertCounter.getOldest().longValue()); Assert.assertEquals(1, alertCounter.getSize()); Assert.assertFalse(alertCounter.isEmpty());  alertCounter.clean(2); Assert.assertNull(alertCounter.getOldest()); Assert.assertEquals(0, alertCounter.getSize()); Assert."<AssertPlaceHolder>"; }
isEmpty() { return alertContextHeap.isEmpty(); }
[*] target: assertTrue(alertCounter.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( alertCounter. isEmpty() )
************************************
************************************
[+] input: cleaningCounterVeryOld() { alertCounter.update(new AlertContext(1, new Object[]{"secret", 1})); alertCounter.clean(1002); Assert.assertNull(alertCounter.getOldest()); Assert.assertEquals(0, alertCounter.getSize()); Assert."<AssertPlaceHolder>"; }
isEmpty() { return alertContextHeap.isEmpty(); }
[*] target: assertTrue(alertCounter.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( alertCounter. isEmpty() )
************************************
************************************
[+] input: IOException { AlertingEngineBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof AlertMessages); Assert.assertTrue(values.get(1) instanceof ExceptionMessages);  AlertMessages alerts = (AlertMessages)values.get(0); Assert.assertEquals(1, alerts.size()); Assert.assertTrue(alerts.get(0).isVisibleAlert()); Assert.assertEquals("siembol_alert_generic_v1", alerts.get(0).getFullRuleName()); Assert.assertEquals(Optional.empty(), alerts.get(0).getCorrelationKey()); Assert.assertEquals(100, alerts.get(0).getMaxDayMatches()); Assert.assertEquals(30, alerts.get(0).getMaxHourMatches());  Map<String, Object> parsed = JSON_READER.readValue(alerts.get(0).getAlertJson()); Assert.assertEquals("siembol_alert_generic_v1", parsed.get(AlertingFields.FULL_RULE_NAME.getAlertingName())); Assert.assertEquals(100, parsed.get(AlertingFields.MAX_PER_DAY_FIELD.getAlertingName())); Assert.assertEquals(30, parsed.get(AlertingFields.MAX_PER_HOUR_FIELD.getAlertingName())); Assert.assertEquals("secret", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("secret", parsed.get("sensor")); Assert.assertEquals(1, parsed.get("dummy_field_int")); Assert.assertEquals(false, parsed.get("dummy_field_boolean")); verify(collector, times(1)).ack(eq(tuple)); }
execute(Tuple tuple) { AlertingEngine currentEngine = AlertingEngine.get(); String event = tuple.getStringByField(TupleFieldNames.EVENT.toString()); AlertingResult ret = currentEngine.evaluate(event);  if (ret.getStatusCode() == AlertingResult.StatusCode.OK && ret.getAttributes().getEvaluationResult() == EvaluationResult.NO_MATCH && ret.getAttributes().getExceptionEvents() == null) { LOG.debug(ACK_NO_MATCH_LOG, event); collector.ack(tuple); return; }  AlertMessages matches = new AlertMessages(); ExceptionMessages exceptions = new ExceptionMessages();  if (ret.getStatusCode() != AlertingResult.StatusCode.OK) { exceptions.add(String.format(EXCEPTION_MSG_FORMAT, ret.getAttributes().getException(), event)); }  if (ret.getAttributes().getExceptionEvents() != null) { ret.getAttributes().getExceptionEvents() .forEach( x -> { try { exceptions.add(JSON_WRITER.writeValueAsString(x)); } catch (JsonProcessingException e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  if (ret.getAttributes().getOutputEvents() != null) { ret.getAttributes().getOutputEvents() .forEach( x -> { try { matches.add(new AlertMessage(currentEngine.getAlertingEngineType(), x, JSON_WRITER.writeValueAsString(x))); } catch (Exception e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  collector.emit(tuple, new Values(matches, exceptions)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: IOException { when(zooKeeperConnector.getData()).thenReturn(Collections.singletonList(rulesForCorrelation)); AlertingEngineBolt.prepare(null, null, collector);  AlertingEngineBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof AlertMessages); Assert.assertTrue(values.get(1) instanceof ExceptionMessages);  AlertMessages alerts = (AlertMessages)values.get(0); Assert.assertEquals(1, alerts.size()); Assert.assertTrue(alerts.get(0).isCorrelationAlert()); Assert.assertFalse(alerts.get(0).isVisibleAlert());  Assert.assertEquals("siembol_alert_generic_v1", alerts.get(0).getFullRuleName()); Assert.assertTrue(alerts.get(0).getCorrelationKey().isPresent()); Assert.assertEquals("1", alerts.get(0).getCorrelationKey().get()); Assert.assertEquals(100, alerts.get(0).getMaxDayMatches()); Assert.assertEquals(30, alerts.get(0).getMaxHourMatches());  Map<String, Object> parsed = JSON_READER.readValue(alerts.get(0).getAlertJson()); Assert.assertEquals("siembol_alert_generic_v1", parsed.get(AlertingFields.FULL_RULE_NAME.getAlertingName())); Assert.assertEquals(100, parsed.get(AlertingFields.MAX_PER_DAY_FIELD.getAlertingName())); Assert.assertEquals(30, parsed.get(AlertingFields.MAX_PER_HOUR_FIELD.getAlertingName())); Assert.assertEquals("secret", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("secret", parsed.get("sensor")); Assert.assertEquals(1, parsed.get("dummy_field_int")); Assert.assertEquals(false, parsed.get("dummy_field_boolean")); verify(collector, times(1)).ack(eq(tuple)); }
execute(Tuple tuple) { AlertingEngine currentEngine = AlertingEngine.get(); String event = tuple.getStringByField(TupleFieldNames.EVENT.toString()); AlertingResult ret = currentEngine.evaluate(event);  if (ret.getStatusCode() == AlertingResult.StatusCode.OK && ret.getAttributes().getEvaluationResult() == EvaluationResult.NO_MATCH && ret.getAttributes().getExceptionEvents() == null) { LOG.debug(ACK_NO_MATCH_LOG, event); collector.ack(tuple); return; }  AlertMessages matches = new AlertMessages(); ExceptionMessages exceptions = new ExceptionMessages();  if (ret.getStatusCode() != AlertingResult.StatusCode.OK) { exceptions.add(String.format(EXCEPTION_MSG_FORMAT, ret.getAttributes().getException(), event)); }  if (ret.getAttributes().getExceptionEvents() != null) { ret.getAttributes().getExceptionEvents() .forEach( x -> { try { exceptions.add(JSON_WRITER.writeValueAsString(x)); } catch (JsonProcessingException e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  if (ret.getAttributes().getOutputEvents() != null) { ret.getAttributes().getOutputEvents() .forEach( x -> { try { matches.add(new AlertMessage(currentEngine.getAlertingEngineType(), x, JSON_WRITER.writeValueAsString(x))); } catch (Exception e) { exceptions.add(ExceptionUtils.getStackTrace(e)); } }); }  collector.emit(tuple, new Values(matches, exceptions)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: Exception { exceptionMessages.add("dummy"); writerBolt.execute(tuple); List<String> outputExceptions = kafkaRule.helper().consumeStrings("errors", 1) .get(10, TimeUnit.SECONDS);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, outputExceptions.size()); Map<String, Object> parsedException = JSON_MAP_READER.readValue(outputExceptions.get(0)); Assert.assertEquals("siembol_alerts", parsedException.get("failed_sensor_type")); Assert.assertEquals("alerting_error", parsedException.get("error_type")); Assert.assertEquals("error", parsedException.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("dummy", parsedException.get("message")); Assert.assertEquals(1, metricsTestRegistrarFactory .getCounterValue(SiembolMetrics.ALERTING_ENGINE_ERROR_MATCHES.getMetricName()));  }
execute(Tuple tuple) { Object matchesObject = tuple.getValueByField(TupleFieldNames.ALERTING_MATCHES.toString()); if (!(matchesObject instanceof AlertMessages)) { LOG.error(WRONG_ALERTS_FIELD_MESSAGE); throw new IllegalStateException(WRONG_ALERTS_FIELD_MESSAGE); } AlertMessages matches = (AlertMessages)matchesObject;  Object exceptionsObject = tuple.getValueByField(TupleFieldNames.ALERTING_EXCEPTIONS.toString()); if (!(exceptionsObject instanceof ExceptionMessages)) { LOG.error(WRONG_EXCEPTION_FIELD_MESSAGE); throw new IllegalStateException(WRONG_EXCEPTION_FIELD_MESSAGE); } ExceptionMessages exceptions = (ExceptionMessages)exceptionsObject;  var messages = new ArrayList<KafkaWriterMessage>(); var counters = new ArrayList<String>(); exceptions.forEach(x -> counters.add(SiembolMetrics.ALERTING_ENGINE_ERROR_MATCHES.getMetricName()));  for (var match : matches) { AlertingResult matchesInfo = ruleProtection.incrementRuleMatches(match.getFullRuleName()); int hourlyMatches = matchesInfo.getAttributes().getHourlyMatches(); int dailyMatches = matchesInfo.getAttributes().getDailyMatches(); int hourlyMatchesDiffWithMax = hourlyMatches - match.getMaxHourMatches().intValue(); int dailyMatchesDiffWithMax = dailyMatches - match.getMaxDayMatches().intValue();  if (hourlyMatchesDiffWithMax > 0 || dailyMatchesDiffWithMax > 0) { String msg = String.format(RULE_PROTECTION_ERROR_MESSAGE, match.getFullRuleName(), hourlyMatches, dailyMatches, match.getAlertJson()); LOG.debug(msg);  if ((hourlyMatchesDiffWithMax > 0  && isPowerOfTwo(hourlyMatchesDiffWithMax)) || (dailyMatchesDiffWithMax > 0 && isPowerOfTwo(dailyMatchesDiffWithMax))) { //NOTE: sending message about an alert filtered by rule protection is sampled exponentially exceptions.add(msg); }  counters.add(SiembolMetrics.ALERTING_ENGINE_RULE_PROTECTION.getMetricName()); counters.add(SiembolMetrics.ALERTING_RULE_PROTECTION.getMetricName(match.getRuleName())); continue; }  if (match.isVisibleAlert()) { LOG.debug(SEND_MSG_LOG, match.getAlertJson(), outputTopic); messages.add(new KafkaWriterMessage(outputTopic, match.getAlertJson())); counters.add(SiembolMetrics.ALERTING_ENGINE_MATCHES.getMetricName()); counters.add(SiembolMetrics.ALERTING_RULE_MATCHES.getMetricName(match.getRuleName())); }  if (match.isCorrelationAlert()) { if (match.getCorrelationKey().isEmpty()) { String errorMsg = String.format(MISSING_CORRELATION_KEY_MSG, match.getAlertJson()); LOG.error(errorMsg); throw new IllegalStateException(errorMsg); }  LOG.debug(SEND_MSG_LOG, match.getAlertJson(), correlationTopic); messages.add(new KafkaWriterMessage(correlationTopic, match.getCorrelationKey().get(), match.getAlertJson())); counters.add(SiembolMetrics.ALERTING_ENGINE_CORRELATION_MATCHES.getMetricName()); counters.add(SiembolMetrics.ALERTING_RULE_CORRELATION_MATCHES.getMetricName(match.getRuleName())); } }  for (var exception : exceptions) { String errorMsgToSend = getErrorMessageToSend(exception); LOG.debug(SEND_MSG_LOG, errorMsgToSend, errorTopic); messages.add(new KafkaWriterMessage(errorTopic, errorMsgToSend)); }  var anchor = new KafkaWriterAnchor(tuple); super.writeMessages(messages, counters, anchor); }
[*] target: assertNotNull(outputExceptions)
[-] pred: org. junit. Assert. assertNotNull ( outputExceptions )
************************************
************************************
[+] input: IOException { String enriched = EnrichmentEvaluatorLibrary.mergeEnrichments(simpleEvent, enrichments, Optional.empty()); Assert."<AssertPlaceHolder>"; Map<String, Object> map = JSON_MAP_READER.readValue(enriched); Assert.assertEquals(5, map.size()); Assert.assertEquals(1, map.get("timestamp")); Assert.assertEquals(true, map.get("dummy_bool")); Assert.assertEquals("test", map.get("dummy_str")); Assert.assertEquals("b", map.get("a")); Assert.assertEquals("d", map.get("c")); }
mergeEnrichments(String event, List<Pair<String, String>> enrichments, Optional<String> timestampField) throws IOException { ObjectNode node = (ObjectNode)OBJECT_MAPPER.readTree(event); enrichments.forEach(x -> node.put(x.getKey(), x.getValue())); if (timestampField.isPresent()) { node.put(timestampField.get(), System.currentTimeMillis()); } return node.toString(); }
[*] target: assertNotNull(enriched)
[-] pred: org. junit. Assert. assertNotNull ( enriched )
************************************
************************************
[+] input: IOException { String enriched = EnrichmentEvaluatorLibrary.mergeEnrichments(simpleEvent, enrichments, Optional.of("enrichment_timestamp")); Assert."<AssertPlaceHolder>"; Map<String, Object> map = JSON_MAP_READER.readValue(enriched); Assert.assertEquals(6, map.size()); Assert.assertEquals(1, map.get("timestamp")); Assert.assertEquals(true, map.get("dummy_bool")); Assert.assertEquals("test", map.get("dummy_str")); Assert.assertEquals("b", map.get("a")); Assert.assertEquals("d", map.get("c")); Assert.assertTrue(map.get("enrichment_timestamp") instanceof Number); }
mergeEnrichments(String event, List<Pair<String, String>> enrichments, Optional<String> timestampField) throws IOException { ObjectNode node = (ObjectNode)OBJECT_MAPPER.readTree(event); enrichments.forEach(x -> node.put(x.getKey(), x.getValue())); if (timestampField.isPresent()) { node.put(timestampField.get(), System.currentTimeMillis()); } return node.toString(); }
[*] target: assertNotNull(enriched)
[-] pred: org. junit. Assert. assertNotNull ( enriched )
************************************
************************************
[+] input: IOException { enrichments.clear(); String enriched = EnrichmentEvaluatorLibrary.mergeEnrichments(simpleEvent, enrichments, Optional.empty()); Assert."<AssertPlaceHolder>"; Map<String, Object> map = JSON_MAP_READER.readValue(enriched); Assert.assertEquals(4, map.size()); Assert.assertEquals(1, map.get("timestamp")); Assert.assertEquals(true, map.get("dummy_bool")); Assert.assertEquals("test", map.get("dummy_str")); Assert.assertEquals("conflict", map.get("a")); }
mergeEnrichments(String event, List<Pair<String, String>> enrichments, Optional<String> timestampField) throws IOException { ObjectNode node = (ObjectNode)OBJECT_MAPPER.readTree(event); enrichments.forEach(x -> node.put(x.getKey(), x.getValue())); if (timestampField.isPresent()) { node.put(timestampField.get(), System.currentTimeMillis()); } return node.toString(); }
[*] target: assertNotNull(enriched)
[-] pred: org. junit. Assert. assertNotNull ( enriched )
************************************
************************************
[+] input: testExceptionRule() { when(tuple.getStringByField(eq(EnrichmentTuples.EVENT.toString()))).thenReturn("INVALID"); enrichmentEvaluatorBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(3, values.size()); Assert.assertTrue(values.get(0) instanceof String); Assert.assertTrue(values.get(1) instanceof EnrichmentCommands); Assert.assertTrue(values.get(2) instanceof EnrichmentExceptions); Assert.assertTrue(((EnrichmentCommands)values.get(1)).isEmpty()); Assert.assertFalse(((EnrichmentExceptions)values.get(2)).isEmpty()); Assert.assertEquals(1, ((EnrichmentExceptions)values.get(2)).size()); Assert.assertTrue(((EnrichmentExceptions)values.get(2)).get(0).contains("JsonParseException")); }
execute(Tuple tuple) { EnrichmentEvaluator currentEvaluator = enrichmentEvaluator.get(); String event = tuple.getStringByField(EnrichmentTuples.EVENT.toString()); EnrichmentCommands commands = new EnrichmentCommands(); EnrichmentExceptions exceptions = new EnrichmentExceptions();  try { EnrichmentResult ret = currentEvaluator.evaluate(event); if (ret.getStatusCode() == OK) { if (ret.getAttributes().getEnrichmentCommands() != null) { commands.addAll(ret.getAttributes().getEnrichmentCommands()); } } else { if (ret.getAttributes().getMessage() != null) { exceptions.add(ret.getAttributes().getMessage()); } } } catch (Exception e) { LOG.error(EXCEPTION_RULE_EVALUATION, ExceptionUtils.getStackTrace(e)); exceptions.add(ErrorMessage.createErrorMessage(e, ErrorType.ENRICHMENT_ERROR).toString()); }  collector.emit(tuple, new Values(event, commands, exceptions)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: testEmptyExceptionsNonEmptyEnrichments() { exceptions.add("dummy1"); exceptions.add("dummy2"); enrichments.add(Pair.of("test", "enrichment")); mergerBolt.execute(tuple);  Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0);  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counterValues = (SiembolMetricsCounters)values.get(1); Assert.assertEquals(1, counterValues.size()); Assert.assertEquals("test_counter", counterValues.get(0));  Assert.assertEquals(outputTopic, messages.get(0).getTopic());  Assert.assertEquals(errorTopic, messages.get(1).getTopic()); Assert.assertEquals("dummy1", messages.get(1).getMessage());  Assert.assertEquals(errorTopic, messages.get(2).getTopic()); Assert.assertEquals("dummy2", messages.get(2).getMessage()); }
execute(Tuple tuple) { Object enrichmentsObj = tuple.getValueByField(EnrichmentTuples.ENRICHMENTS.toString()); if (!(enrichmentsObj instanceof EnrichmentPairs)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentPairs enrichments = (EnrichmentPairs)enrichmentsObj;  String event = tuple.getStringByField(EnrichmentTuples.EVENT.toString());  Object exceptionsObj = tuple.getValueByField(EnrichmentTuples.EXCEPTIONS.toString()); if (!(exceptionsObj instanceof EnrichmentExceptions)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentExceptions exceptions = (EnrichmentExceptions)exceptionsObj;  Object countersObj = tuple.getValueByField(EnrichmentTuples.COUNTERS.toString()); if (!(countersObj instanceof SiembolMetricsCounters)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); }  var counters = new SiembolMetricsCounters(); counters.addAll((SiembolMetricsCounters)countersObj);  try { event = EnrichmentEvaluatorLibrary.mergeEnrichments(event, enrichments, Optional.of(SiembolMessageFields.ENRICHING_TIME.toString())); } catch (Exception e) { LOG.error(MERGING_ERROR, event, enrichments); exceptions.add(ErrorMessage.createErrorMessage(e, ErrorType.ENRICHMENT_ERROR).toString()); }  LOG.debug(EVENT_INFO_LOG, event); KafkaWriterMessages messages = new KafkaWriterMessages(); messages.add(new KafkaWriterMessage(outputTopic, event)); exceptions.forEach(x -> messages.add(new KafkaWriterMessage(errorTopic, x))); collector.emit(tuple, new Values(messages, counters)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: testExceptionsNonEmptyEnrichments() { enrichments.add(Pair.of("test", "enrichment")); mergerBolt.execute(tuple);  Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0);  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counterValues = (SiembolMetricsCounters)values.get(1); Assert.assertEquals(1, counterValues.size()); Assert.assertEquals("test_counter", counterValues.get(0));  Assert.assertEquals(outputTopic, messages.get(0).getTopic()); Assert.assertTrue(messages.get(0).getMessage().contains(""test":"enrichment"")); }
execute(Tuple tuple) { Object enrichmentsObj = tuple.getValueByField(EnrichmentTuples.ENRICHMENTS.toString()); if (!(enrichmentsObj instanceof EnrichmentPairs)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentPairs enrichments = (EnrichmentPairs)enrichmentsObj;  String event = tuple.getStringByField(EnrichmentTuples.EVENT.toString());  Object exceptionsObj = tuple.getValueByField(EnrichmentTuples.EXCEPTIONS.toString()); if (!(exceptionsObj instanceof EnrichmentExceptions)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); } EnrichmentExceptions exceptions = (EnrichmentExceptions)exceptionsObj;  Object countersObj = tuple.getValueByField(EnrichmentTuples.COUNTERS.toString()); if (!(countersObj instanceof SiembolMetricsCounters)) { LOG.error(INVALID_TYPE_IN_TUPLES); throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLES); }  var counters = new SiembolMetricsCounters(); counters.addAll((SiembolMetricsCounters)countersObj);  try { event = EnrichmentEvaluatorLibrary.mergeEnrichments(event, enrichments, Optional.of(SiembolMessageFields.ENRICHING_TIME.toString())); } catch (Exception e) { LOG.error(MERGING_ERROR, event, enrichments); exceptions.add(ErrorMessage.createErrorMessage(e, ErrorType.ENRICHMENT_ERROR).toString()); }  LOG.debug(EVENT_INFO_LOG, event); KafkaWriterMessages messages = new KafkaWriterMessages(); messages.add(new KafkaWriterMessage(outputTopic, event)); exceptions.forEach(x -> messages.add(new KafkaWriterMessage(errorTopic, x))); collector.emit(tuple, new Values(messages, counters)); collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: IOException { parsingApplicationBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0); Assert.assertEquals(1, messages.size()); Assert.assertEquals("output", messages.get(0).getTopic());  Map<String, Object> parsed = JSON_READER.readValue(messages.get(0).getMessage()); Assert.assertEquals("RAW_LOG", parsed.get(SiembolMessageFields.ORIGINAL.toString())); Assert.assertEquals("single", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertNull(parsed.get("metadata_is_metadata"));  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counters = (SiembolMetricsCounters)values.get(1); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_APP_PARSED_MESSAGES.getMetricName())); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_SOURCE_TYPE_PARSED_MESSAGES .getMetricName("single"))); Assert.assertEquals(1, metricsTestRegistrarFactory.getCounterValue(SiembolMetrics.PARSING_CONFIGS_UPDATE.getMetricName())); }
execute(Tuple tuple) { ParsingApplicationParser currentParser = parsingApplicationParser.get();  String source = tuple.getStringByField(ParsingApplicationTuples.SOURCE.toString()); String metadata = tuple.getStringByField(ParsingApplicationTuples.METADATA.toString()); Object logObj = tuple.getValueByField(ParsingApplicationTuples.LOG.toString()); if (!(logObj instanceof byte[])) { throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLE); }  byte[] log = (byte[]) logObj; ArrayList<ParsingApplicationResult> results = currentParser.parse(source, metadata, log);  var kafkaWriterMessages = new KafkaWriterMessages(); var counters = new SiembolMetricsCounters(); for (var result : results) { if (result.getResultFlags().contains(ParsingApplicationResult.ResultFlag.FILTERED)) { metricsRegistrar.registerCounter( SiembolMetrics.PARSING_SOURCE_TYPE_FILTERED_MESSAGES.getMetricName(result.getSourceType())) .increment(); metricsRegistrar.registerCounter(SiembolMetrics.PARSING_APP_FILTERED_MESSAGES.getMetricName()) .increment(); } else { result.getMessages().forEach(x -> { kafkaWriterMessages.add(new KafkaWriterMessage(result.getTopic(), x)); addCounters(counters, result.getResultFlags(), result.getSourceType()); }); } }  if (!kafkaWriterMessages.isEmpty()) { collector.emit(tuple, new Values(kafkaWriterMessages, counters)); }  collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: Exception { parsingAttributes.setApplicationParserSpecification(simpleSingleApplicationParser.replace( ""parse_metadata" : false", ""parse_metadata" : true" )); parsingApplicationBolt = new ParsingApplicationBolt(attributes, parsingAttributes, zooKeeperConnectorFactory, metricsTestRegistrarFactory); parsingApplicationBolt.prepare(null, null, collector);  when(tuple.getStringByField(eq(ParsingApplicationTuples.METADATA.toString()))).thenReturn("INVALID"); parsingApplicationBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0); Assert.assertEquals(1, messages.size()); Assert.assertEquals("error", messages.get(0).getTopic());  Map<String, Object> parsed = JSON_READER.readValue(messages.get(0).getMessage()); Assert.assertEquals("RAW_LOG", parsed.get("raw_message")); Assert.assertEquals("error", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals("parser_error", parsed.get("error_type"));  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counters = (SiembolMetricsCounters)values.get(1); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_APP_ERROR_MESSAGES.getMetricName())); }
execute(Tuple tuple) { ParsingApplicationParser currentParser = parsingApplicationParser.get();  String source = tuple.getStringByField(ParsingApplicationTuples.SOURCE.toString()); String metadata = tuple.getStringByField(ParsingApplicationTuples.METADATA.toString()); Object logObj = tuple.getValueByField(ParsingApplicationTuples.LOG.toString()); if (!(logObj instanceof byte[])) { throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLE); }  byte[] log = (byte[]) logObj; ArrayList<ParsingApplicationResult> results = currentParser.parse(source, metadata, log);  var kafkaWriterMessages = new KafkaWriterMessages(); var counters = new SiembolMetricsCounters(); for (var result : results) { if (result.getResultFlags().contains(ParsingApplicationResult.ResultFlag.FILTERED)) { metricsRegistrar.registerCounter( SiembolMetrics.PARSING_SOURCE_TYPE_FILTERED_MESSAGES.getMetricName(result.getSourceType())) .increment(); metricsRegistrar.registerCounter(SiembolMetrics.PARSING_APP_FILTERED_MESSAGES.getMetricName()) .increment(); } else { result.getMessages().forEach(x -> { kafkaWriterMessages.add(new KafkaWriterMessage(result.getTopic(), x)); addCounters(counters, result.getResultFlags(), result.getSourceType()); }); } }  if (!kafkaWriterMessages.isEmpty()) { collector.emit(tuple, new Values(kafkaWriterMessages, counters)); }  collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: Exception { parsingAttributes.setApplicationParserSpecification(simpleSingleApplicationParser.replace( ""parse_metadata" : false", ""parse_metadata" : true" ));  parsingApplicationBolt = new ParsingApplicationBolt(attributes, parsingAttributes, zooKeeperConnectorFactory, metricsTestRegistrarFactory); parsingApplicationBolt.prepare(null, null, collector); parsingApplicationBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0); Assert.assertEquals(1, messages.size()); Assert.assertEquals("output", messages.get(0).getTopic());  Map<String, Object> parsed = JSON_READER.readValue(messages.get(0).getMessage()); Assert.assertEquals("RAW_LOG", parsed.get(SiembolMessageFields.ORIGINAL.toString())); Assert.assertEquals("single", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertEquals(true, parsed.get("metadata_is_metadata"));  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counters = (SiembolMetricsCounters)values.get(1); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_APP_PARSED_MESSAGES.getMetricName())); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_SOURCE_TYPE_PARSED_MESSAGES .getMetricName("single"))); }
execute(Tuple tuple) { ParsingApplicationParser currentParser = parsingApplicationParser.get();  String source = tuple.getStringByField(ParsingApplicationTuples.SOURCE.toString()); String metadata = tuple.getStringByField(ParsingApplicationTuples.METADATA.toString()); Object logObj = tuple.getValueByField(ParsingApplicationTuples.LOG.toString()); if (!(logObj instanceof byte[])) { throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLE); }  byte[] log = (byte[]) logObj; ArrayList<ParsingApplicationResult> results = currentParser.parse(source, metadata, log);  var kafkaWriterMessages = new KafkaWriterMessages(); var counters = new SiembolMetricsCounters(); for (var result : results) { if (result.getResultFlags().contains(ParsingApplicationResult.ResultFlag.FILTERED)) { metricsRegistrar.registerCounter( SiembolMetrics.PARSING_SOURCE_TYPE_FILTERED_MESSAGES.getMetricName(result.getSourceType())) .increment(); metricsRegistrar.registerCounter(SiembolMetrics.PARSING_APP_FILTERED_MESSAGES.getMetricName()) .increment(); } else { result.getMessages().forEach(x -> { kafkaWriterMessages.add(new KafkaWriterMessage(result.getTopic(), x)); addCounters(counters, result.getResultFlags(), result.getSourceType()); }); } }  if (!kafkaWriterMessages.isEmpty()) { collector.emit(tuple, new Values(kafkaWriterMessages, counters)); }  collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: Exception { Assert.assertEquals(1, metricsTestRegistrarFactory.getCounterValue(SiembolMetrics.PARSING_CONFIGS_UPDATE.getMetricName()));  zooKeeperConnectorFactory.getZooKeeperConnector(parsersPath).setData("INVALID");  Assert.assertEquals(1, metricsTestRegistrarFactory.getCounterValue(SiembolMetrics.PARSING_CONFIGS_UPDATE.getMetricName())); Assert.assertEquals(1, metricsTestRegistrarFactory .getCounterValue(SiembolMetrics.PARSING_CONFIGS_ERROR_UPDATE.getMetricName()));  parsingApplicationBolt.execute(tuple); Values values = argumentEmitCaptor.getValue(); Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, values.size()); Assert.assertTrue(values.get(0) instanceof KafkaWriterMessages); KafkaWriterMessages messages = (KafkaWriterMessages)values.get(0); Assert.assertEquals(1, messages.size()); Assert.assertEquals("output", messages.get(0).getTopic());  Map<String, Object> parsed = JSON_READER.readValue(messages.get(0).getMessage()); Assert.assertEquals("RAW_LOG", parsed.get(SiembolMessageFields.ORIGINAL.toString())); Assert.assertEquals("single", parsed.get(SiembolMessageFields.SENSOR_TYPE.toString())); Assert.assertNull(parsed.get("metadata_is_metadata"));  Assert.assertTrue(values.get(1) instanceof SiembolMetricsCounters); var counters = (SiembolMetricsCounters)values.get(1); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_APP_PARSED_MESSAGES.getMetricName())); Assert.assertTrue(counters.contains(SiembolMetrics.PARSING_SOURCE_TYPE_PARSED_MESSAGES .getMetricName("single"))); }
execute(Tuple tuple) { ParsingApplicationParser currentParser = parsingApplicationParser.get();  String source = tuple.getStringByField(ParsingApplicationTuples.SOURCE.toString()); String metadata = tuple.getStringByField(ParsingApplicationTuples.METADATA.toString()); Object logObj = tuple.getValueByField(ParsingApplicationTuples.LOG.toString()); if (!(logObj instanceof byte[])) { throw new IllegalArgumentException(INVALID_TYPE_IN_TUPLE); }  byte[] log = (byte[]) logObj; ArrayList<ParsingApplicationResult> results = currentParser.parse(source, metadata, log);  var kafkaWriterMessages = new KafkaWriterMessages(); var counters = new SiembolMetricsCounters(); for (var result : results) { if (result.getResultFlags().contains(ParsingApplicationResult.ResultFlag.FILTERED)) { metricsRegistrar.registerCounter( SiembolMetrics.PARSING_SOURCE_TYPE_FILTERED_MESSAGES.getMetricName(result.getSourceType())) .increment(); metricsRegistrar.registerCounter(SiembolMetrics.PARSING_APP_FILTERED_MESSAGES.getMetricName()) .increment(); } else { result.getMessages().forEach(x -> { kafkaWriterMessages.add(new KafkaWriterMessage(result.getTopic(), x)); addCounters(counters, result.getResultFlags(), result.getSourceType()); }); } }  if (!kafkaWriterMessages.isEmpty()) { collector.emit(tuple, new Values(kafkaWriterMessages, counters)); }  collector.ack(tuple); }
[*] target: assertNotNull(values)
[-] pred: org. junit. Assert. assertNotNull ( values )
************************************
************************************
[+] input: Exception {    ProcessSimulation processSimulation = new ProcessSimulation(smartEngine);  //3. 部署流程定义 RepositoryCommandService repositoryCommandService = smartEngine .getRepositoryCommandService(); ProcessDefinition processDefinition = repositoryCommandService .deploy("simple-process-simulation.bpmn.xml").getFirstProcessDefinition(); assertEquals(14, processDefinition.getBaseElementList().size());  //List<Activity> activitieList = null;  List<Activity> activitieList = processSimulation.simulateOutcomingActivities(processDefinition.getId(), processDefinition.getVersion(), "receiveTask0", null); Assert.assertNotNull(activitieList); assertEquals(1, activitieList.size()); assertEquals("receiveTask1", activitieList.get(0).getId());  //activitieList =  processSimulation.simulateOutcomingActivities("processSimulation","1.0.0","receiveTask1", // null); //Assert.assertNotNull(activitieList); //Assert.assertEquals(0,activitieList.size());  Map<String, Object> simulationContext = new HashMap<String, Object>(2); simulationContext.put("route", "a"); activitieList = processSimulation.simulateOutcomingActivities("Process_1", "1.0.0", "receiveTask1", simulationContext); Assert.assertNotNull(activitieList); assertEquals(1, activitieList.size()); assertEquals("receiveTask_a", activitieList.get(0).getId());  simulationContext = new HashMap<String, Object>(2); simulationContext.put("route", "b"); activitieList = processSimulation.simulateOutcomingActivities("Process_1", "1.0.0", "receiveTask1", simulationContext); Assert."<AssertPlaceHolder>"; assertEquals(1, activitieList.size()); assertEquals("receiveTask_b", activitieList.get(0).getId());  }
simulateOutcomingActivities(String processDefinitionId, String processDefinitionVersion, String currentActivityId, Map<String, Object> simulationContext) {  PvmProcessDefinition pvmProcessDefinition = smartEngine.getProcessEngineConfiguration() .getAnnotationScanner().getExtensionPoint(ExtensionConstant.SERVICE, ProcessDefinitionContainer.class).getPvmProcessDefinition(processDefinitionId, processDefinitionVersion);  PvmActivity currentPvmActivity = pvmProcessDefinition.getActivities().get(currentActivityId);  if (null == currentPvmActivity) { String exceptionMessage = String.format( "No PvmActivity found for processDefinitionId :%BehaviorUtil,processDefinitionVersion :%BehaviorUtil," + "currentActivityId :%BehaviorUtil", processDefinitionId, processDefinitionVersion, currentActivityId); throw new EngineException(exceptionMessage);  } List<Activity> resultList = new ArrayList<Activity>();  simulation(currentPvmActivity, simulationContext, resultList);  return resultList; }
[*] target: assertNotNull(activitieList)
[-] pred: org. junit. Assert. assertNotNull ( activitieList )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ActivityInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>";   }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  DeploymentInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testUpdate() { dao.insert(entity);  entity.setProcessDefinitionContent("abc_content");  dao.update( entity);  DeploymentInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>";   Assert.assertTrue("abc_content".equals(result.getProcessDefinitionContent())); }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ExecutionInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testUpdate() { dao.insert(entity);  entity.setActive(true);  dao.update(entity);  ExecutionInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; Assert.assertTrue(entity.isActive());  }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  ProcessInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  // 返回删除行数,去掉findAll 接口 dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert.assertNull(result);  result = dao.findOneForUpdate(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOneForUpdate(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testFindOne() { dao.insert(entity);  TaskInstanceEntity result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.getClaimTime()); Assert.assertEquals("comment",result.getComment()); Assert.assertEquals("extension",result.getExtension()); }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testDelete() { dao.insert(entity);  TaskInstanceEntity result = dao.findOne(entity.getId()); Assert.assertNotNull(result);  dao.delete(entity.getId());  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; }
findOne(@Param("id") Long id);
[*] target: assertNull(result)
[-] pred: org. junit. Assert. assertNull ( result )
************************************
************************************
[+] input: testUpdate() { dao.insert(entity);  TaskInstanceEntity result = dao.findOne(entity.getId());  Assert.assertEquals("title", result.getTitle());   entity.setClaimUserId("assign_id_new"); Date claimTime = new Date();  entity.setClaimTime(new Date(claimTime.getTime())); Date endTime = new Date(claimTime.getTime() + 1000000); entity.setCompleteTime(endTime); entity.setPriority(333444); entity.setComment("new_comment"); entity.setExtension("new_extension"); entity.setTitle("new_title"); dao.update(entity);  result = dao.findOne(entity.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals("assign_id_new", entity.getClaimUserId()); Assert.assertEquals(claimTime, entity.getClaimTime()); Assert.assertEquals(endTime, entity.getCompleteTime()); Assert.assertEquals(333444, entity.getPriority().intValue()); Assert.assertEquals("new_comment", result.getComment()); Assert.assertEquals("new_extension", result.getExtension()); Assert.assertEquals("new_title", result.getTitle());  }
findOne(@Param("id") Long id);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testQuery() { dao.insert(entity); TaskInstanceQueryParam param = new TaskInstanceQueryParam(); param.setExtension("extension1"); List<TaskInstanceEntity> result = dao.findTaskList(param);  Assert.assertNotNull(result); Assert.assertTrue(result.size() == 0);  param = new TaskInstanceQueryParam(); param.setExtension("extension"); param.setTitle("title"); param.setTag("tag"); param.setComment("comment"); param.setPriority(333); param.setClaimUserId("assign_id");  result = dao.findTaskList(param);  Assert."<AssertPlaceHolder>"; Assert.assertTrue(result.size() == 1); Assert.assertTrue(  result.get(0).getExtension().equals("extension")); }
findTaskList(TaskInstanceQueryParam taskInstanceQueryParam);
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: createCustomMusicList() { final String name = "TestMusicList";  MusicList musicList = mMusicStore.createCustomMusicList(name);  assertEquals(name, musicList.getName());  boolean exception = false; try { mMusicStore.createCustomMusicList(MusicStore.MUSIC_LIST_FAVORITE); } catch (IllegalArgumentException e) { exception = true; }  "<AssertPlaceHolder>"; }
createCustomMusicList(@NonNull String name) throws IllegalArgumentException { Preconditions.checkNotNull(name); Preconditions.checkArgument(!name.isEmpty(), "name must not empty"); checkThread();  if (isBuiltInName(name)) { throw new IllegalArgumentException("Illegal music list name, conflicts with built-in name."); }  name = trimName(name);  if (isMusicListExists(name)) { MusicList musicList = getCustomMusicList(name); assert musicList != null; return musicList; }  mAllCustomMusicListName.add(name); MusicListEntity entity = new MusicListEntity(0, name, 0, MusicList.SortOrder.BY_ADD_TIME, new byte[0]); mMusicListEntityBox.put(entity); return new MusicList(entity); }
[*] target: assertTrue(exception)
[-] pred: org. junit. Assert. assertTrue ( exception )
************************************
************************************
[+] input: getCustomMusicList() { final String name = "TestMusicList";  mMusicStore.createCustomMusicList(name); MusicList musicList = mMusicStore.getCustomMusicList(name);  "<AssertPlaceHolder>"; assertEquals(name, musicList.getName()); }
getCustomMusicList(@NonNull String name) { Preconditions.checkNotNull(name); checkThread();  if (isBuiltInName(name)) { return null; }  MusicListEntity entity = mMusicListEntityBox.query() .equal(MusicListEntity_.name, name, QueryBuilder.StringOrder.CASE_SENSITIVE) .build() .findUnique();  if (entity == null) { return null; }  return new MusicList(entity); }
[*] target: assertNotNull(musicList)
[-] pred: org. junit. Assert. assertNotNull ( musicList )
************************************
************************************
[+] input: deleteMusicList() { final String name = "TestMusicList"; mMusicStore.createCustomMusicList(name);  MusicList musicList = mMusicStore.getCustomMusicList(name);  assertNotNull(musicList);  mMusicStore.deleteMusicList(musicList); musicList = mMusicStore.getCustomMusicList(name);  "<AssertPlaceHolder>"; }
getCustomMusicList(@NonNull String name) { Preconditions.checkNotNull(name); checkThread();  if (isBuiltInName(name)) { return null; }  MusicListEntity entity = mMusicListEntityBox.query() .equal(MusicListEntity_.name, name, QueryBuilder.StringOrder.CASE_SENSITIVE) .build() .findUnique();  if (entity == null) { return null; }  return new MusicList(entity); }
[*] target: assertNull(musicList)
[-] pred: org. junit. Assert. assertNull ( musicList )
************************************
************************************
[+] input: deleteMusicList_name() { final String name = "TestMusicList"; mMusicStore.createCustomMusicList(name);  MusicList musicList = mMusicStore.getCustomMusicList(name);  assertNotNull(musicList);  mMusicStore.deleteMusicList(name); musicList = mMusicStore.getCustomMusicList(name);  "<AssertPlaceHolder>"; }
getCustomMusicList(@NonNull String name) { Preconditions.checkNotNull(name); checkThread();  if (isBuiltInName(name)) { return null; }  MusicListEntity entity = mMusicListEntityBox.query() .equal(MusicListEntity_.name, name, QueryBuilder.StringOrder.CASE_SENSITIVE) .build() .findUnique();  if (entity == null) { return null; }  return new MusicList(entity); }
[*] target: assertNull(musicList)
[-] pred: org. junit. Assert. assertNull ( musicList )
************************************
************************************
[+] input: defaultConstructorTest() { MusicItem musicItem = new MusicItem();  assertNotNull(musicItem.getMusicId()); assertNotNull(musicItem.getTitle()); assertNotNull(musicItem.getArtist()); assertNotNull(musicItem.getAlbum()); assertNotNull(musicItem.getUri()); assertNotNull(musicItem.getIconUri()); assertEquals(0, musicItem.getDuration()); "<AssertPlaceHolder>"; }
isForbidSeek() { return forbidSeek; }
[*] target: assertFalse(musicItem.isForbidSeek())
[-] pred: org. junit. Assert. assertFalse ( musicItem. isForbidSeek ( ) )
************************************
************************************
[+] input: toBytes() { StarlarkBytes big = null; try (Mutability mu = Mutability.create("test")) { StarlarkThread thread = new StarlarkThread(mu, StarlarkSemantics.DEFAULT); big = CryptoMathModule.INSTANCE.toBytes(StarlarkInt.of(0x1122334455667788L), StarlarkInt.of(0), "big", false, thread); } catch (EvalException e) { fail(e.getMessageWithStack()); } "<AssertPlaceHolder>"; int[] unsignedBytes = big.getUnsignedBytes(); assertArrayEquals(unsignedBytes, new int[]{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88});  }
toBytes(StarlarkInt integer, StarlarkInt byteCount, String byteorder, boolean signed, StarlarkThread thread) throws EvalException { // if we're trying to pack a very big integer.. BigInteger value = integer.toBigInteger(); byte[] bytes; int nbytes = byteCount.toInt("toBytes()"); boolean minimizeLeadingZeroPads = false; if (nbytes == 0) { minimizeLeadingZeroPads = true; nbytes = NumOpsUtils.bytesToPackValueToPrimitive(value); } try { if (MAX_LONG.compareTo(value) > 0) { bytes = NumOpsUtils.longlong2byte( value.longValueExact(), nbytes, isBigEndian(byteorder), signed); } else { bytes = NumOpsUtils.bigint2byte( value, nbytes, isBigEndian(byteorder), signed); } } catch (IllegalArgumentException ex) { throw new EvalException( String.format("ValueError or OverflowError: %s", ex.getMessage()), ex.fillInStackTrace()); }  //System.out.printf("bytes.length: %d, nbytes: %s, array: %s %n", bytes.length, nbytes, Arrays.toString(bytes)); if (minimizeLeadingZeroPads) { bytes = ByteArrayUtil.lstrip(bytes, new byte[]{0x00}); } return StarlarkBytes.of(thread.mutability(), bytes); //    return StarlarkBytes.builder(thread).setSequence(bytes).build(); }
[*] target: assertNotNull(big)
[-] pred: org. junit. Assert. assertNotNull ( big )
************************************
************************************
[+] input: testNormalizeValidPhoneNumber() { { String inputPhoneNumber = "+1 650-555-1234"; String expectedNormalizedPhoneNumber = "+16505551234"; String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); assertEquals(expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber); } { String inputPhoneNumber = "+640223334444"; String expectedNormalizedPhoneNumber = "+64223334444"; String actualNormalizedPhoneNumber = io.supertokens.utils.Utils.normalizeIfPhoneNumber(inputPhoneNumber); "<AssertPlaceHolder>"; } }
normalizeIfPhoneNumber(String phoneNumber) { if (phoneNumber == null) { return null; }  PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();  try { // Attempt to parse the phone number with default region code "ZZ" (unknown // region) Phonenumber.PhoneNumber parsedPhoneNumber = phoneNumberUtil.parse(phoneNumber.trim(), "ZZ");  // Format the parsed phone number according to E.164 standard phoneNumber = phoneNumberUtil.format(parsedPhoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164); } catch (NumberParseException e) { // Parsing failed, use the original trimmed phone number phoneNumber = phoneNumber.trim(); }  return phoneNumber; }
[*] target: assertEquals(expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber)
[-] pred: org. junit. Assert. assertEquals ( expectedNormalizedPhoneNumber, actualNormalizedPhoneNumber )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // format for Firebase SCrypt hashes stored in supertokens. // $f_scrypt$passwordHash$salt$m=memory$r=rounds$s=saltSeparator  String passwordHash = "passwordHash"; String salt = "salt"; int memory = 14; int rounds = 8; String saltSeparator = "Bw==";  // when password hash is in the regular format { String validPasswordHash = "$" + ParsedFirebaseSCryptResponse.FIREBASE_SCRYPT_PREFIX + "$" + passwordHash + "$" + salt + "$" + "m=" + memory + "$" + "r=" + rounds + "$" + "s=" + saltSeparator;  ParsedFirebaseSCryptResponse response = ParsedFirebaseSCryptResponse.fromHashString(validPasswordHash); assertNotNull(response);  assertEquals(passwordHash, response.passwordHash); assertEquals(salt, response.salt); assertEquals(memory, response.memCost); assertEquals(saltSeparator, response.saltSeparator); }  // with memory, rounds and saltSeparator switched around { String validPasswordHash = "$" + ParsedFirebaseSCryptResponse.FIREBASE_SCRYPT_PREFIX + "$" + passwordHash + "$" + salt + "$" + "s=" + saltSeparator + "$" + "m=" + memory + "$" + "r=" + rounds;  ParsedFirebaseSCryptResponse response = ParsedFirebaseSCryptResponse.fromHashString(validPasswordHash); "<AssertPlaceHolder>";  assertEquals(passwordHash, response.passwordHash); assertEquals(salt, response.salt); assertEquals(memory, response.memCost); assertEquals(saltSeparator, response.saltSeparator); }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
fromHashString(String hash) { try { String[] separatedPasswordHash = hash.split(FIREBASE_SCRYPT_SEPARATOR);  // check that stored password hash contains 7 fields and after splitting, the first field is empty and the // second field has the firebase scrypt prefix if (!(separatedPasswordHash.length == 7 && separatedPasswordHash[0].equals("") && separatedPasswordHash[1].equals(FIREBASE_SCRYPT_PREFIX))) { return null; }  String passwordHash = separatedPasswordHash[2]; String salt = separatedPasswordHash[3]; String saltSeparator = null; Integer memCost = null; Integer rounds = null;  for (int i = 4; i < separatedPasswordHash.length; i++) { if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_MEM_COST_SEPARATOR)) { memCost = Integer.parseInt(separatedPasswordHash[i].split(FIREBASE_SCRYPT_MEM_COST_SEPARATOR)[1]); continue; } if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_ROUNDS_SEPARATOR)) { rounds = Integer.parseInt(separatedPasswordHash[i].split(FIREBASE_SCRYPT_ROUNDS_SEPARATOR)[1]); continue; } if (separatedPasswordHash[i].startsWith(FIREBASE_SCRYPT_SALT_SEPARATOR)) { saltSeparator = separatedPasswordHash[i].split(FIREBASE_SCRYPT_SALT_SEPARATOR)[1]; } }  if (passwordHash == null || salt == null || saltSeparator == null || memCost == null || rounds == null) { return null; } return new ParsedFirebaseSCryptResponse(passwordHash, salt, saltSeparator, rounds, memCost); } catch (Throwable e) { return null; } }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: IOException { String[] args = {"../"};  Utils.setValueInConfig("access_token_validity", "-1"); TestingProcessManager.TestingProcess process = TestingProcessManager.start(args, false); FeatureFlagTestContent.getInstance(process.getProcess()) .setKeyValue(FeatureFlagTestContent.ENABLED_FEATURES, new EE_FEATURES[]{EE_FEATURES.MULTI_TENANCY}); process.startProcess();  ProcessState.EventAndException e = process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.INIT_FAILURE); "<AssertPlaceHolder>"; assertEquals(e.exception.getCause().getMessage(), "'access_token_validity' must be between 1 and 86400000 seconds inclusive. The config file can be " + "found here: " + getConfigFileLocation(process.getProcess()));  assertNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.LOADING_ALL_TENANT_CONFIG, 1000));  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getInstance(Start start) { return (Config) start.getResourceDistributor() .getResource(RESOURCE_KEY); }
[*] target: assertNotNull(e)
[-] pred: org. junit. Assert. assertNotNull ( e )
************************************
************************************
[+] input: Exception { { TestInput input = new TestInput("value"); io.supertokens.utils.Utils.PubPriKey rsa = io.supertokens.utils.Utils.generateNewPubPriKey(); String token = JWT.createAndSignLegacyAccessToken(new Gson().toJsonTree(input), rsa.privateKey, AccessToken.VERSION.V1); TestInput output = new Gson().fromJson( JWT.verifyJWTAndGetPayload(JWT.preParseJWTInfo(token), rsa.publicKey).payload, TestInput.class); assertEquals(input, output); }  { TestInput input = new TestInput("value"); io.supertokens.utils.Utils.PubPriKey rsa = io.supertokens.utils.Utils.generateNewPubPriKey(); String token = JWT.createAndSignLegacyAccessToken(new Gson().toJsonTree(input), rsa.privateKey, AccessToken.VERSION.V2); TestInput output = new Gson().fromJson( JWT.verifyJWTAndGetPayload(JWT.preParseJWTInfo(token), rsa.publicKey).payload, TestInput.class); "<AssertPlaceHolder>"; } }
preParseJWTInfo(String jwt) throws JWTException { initHeader(); String[] splittedInput = jwt.split("\\."); if (splittedInput.length != 3) { throw new JWTException("Invalid JWT"); }  if (splittedInput[0].equals(JWT.HEADERv1)) { return new JWTPreParseInfo(splittedInput, AccessToken.VERSION.V1, null); }  if (splittedInput[0].equals(JWT.HEADERv2)) { return new JWTPreParseInfo(splittedInput, AccessToken.VERSION.V2, null); }  JsonObject parsedHeader = new JsonParser().parse(Utils.convertFromBase64(splittedInput[0])).getAsJsonObject();  if (parsedHeader.get("typ") == null) { throw new JWTException("JWT header missing - typ"); } JsonPrimitive typ = parsedHeader.get("typ").getAsJsonPrimitive(); if (!typ.isString() || !typ.getAsString().equals("JWT")) { throw new JWTException("JWT header mismatch - typ"); }  if (parsedHeader.get("alg") == null) { throw new JWTException("JWT header missing - alg"); } JsonPrimitive alg = parsedHeader.get("alg").getAsJsonPrimitive(); if (!alg.isString() || !alg.getAsString().equals("RS256")) { throw new JWTException("JWT header mismatch - alg"); }  JsonElement versionElement = parsedHeader.get("version"); // We default to using the latest access token version here for JWTs not created by the session recipe String versionString = AccessToken.getVersionStringFromAccessTokenVersion(AccessToken.getLatestVersion());  if (versionElement != null) { JsonPrimitive version = versionElement.getAsJsonPrimitive(); if (!version.isString() || version.getAsString().equals("1") || version.getAsString().equals("2")) { throw new JWTException("JWT header mismatch - version"); }  versionString = version.getAsString(); }  JsonPrimitive kid = parsedHeader.get("kid").getAsJsonPrimitive(); if (parsedHeader.get("kid") == null) { throw new JWTException("JWT header missing - kid"); } if (!kid.isString()) { throw new JWTException("JWT header mismatch - kid"); } return new JWTPreParseInfo(splittedInput, AccessToken.getVersionFromString(versionString), kid.getAsString()); }
[*] target: assertEquals(input, output)
[-] pred: org. junit. Assert. assertEquals ( input, output )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create a user AuthRecipeUserInfo userInfo = EmailPassword.signUp(process.main, "test@example.com", "testPassword");  String externalUserId = "external-test";  UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), externalUserId, null, false);  { // duplicate exception with both supertokensUserId and externalUserId Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), externalUserId, null, false); } catch (Exception e) { error = e; }  assertNotNull(error); assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertTrue(usersIdMappingExistsError.doesExternalUserIdExist); assertTrue(usersIdMappingExistsError.doesSuperTokensUserIdExist); }  { // duplicate exception with superTokensUserId Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, userInfo.getSupertokensUserId(), "newExternalId", null, false); } catch (Exception e) { error = e; }  assertNotNull(error); assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertFalse(usersIdMappingExistsError.doesExternalUserIdExist); assertTrue(usersIdMappingExistsError.doesSuperTokensUserIdExist);  }  { // duplicate exception with externalUserId  AuthRecipeUserInfo newUser = EmailPassword.signUp(process.main, "test2@example.com", "testPass123"); Exception error = null; try { UserIdMapping.createUserIdMapping(process.main, newUser.getSupertokensUserId(), externalUserId, null, false); } catch (Exception e) { error = e; }  "<AssertPlaceHolder>"; assertTrue(error instanceof UserIdMappingAlreadyExistsException);  UserIdMappingAlreadyExistsException usersIdMappingExistsError = (UserIdMappingAlreadyExistsException) error; assertTrue(usersIdMappingExistsError.doesExternalUserIdExist); assertFalse(usersIdMappingExistsError.doesSuperTokensUserIdExist);  }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(error)
[-] pred: org. junit. Assert. assertNotNull ( error )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  ArrayList<String> nonAuthRecipesWhichDontNeedUserIdMapping = new ArrayList<>( List.of("io.supertokens.pluginInterface.jwt.JWTRecipeStorage", ActiveUsersStorage.class.getName())); Reflections reflections = new Reflections("io.supertokens.pluginInterface"); Set<Class<? extends NonAuthRecipeStorage>> classes = reflections.getSubTypesOf(NonAuthRecipeStorage.class); List<String> names = classes.stream().map(Class::getCanonicalName).collect(Collectors.toList()); List<String> classNames = new ArrayList<>(); for (String name : names) { if (!name.contains("SQLStorage")) { classNames.add(name); } } String externalId = "externalId"; for (String className : classNames) { // Create a User AuthRecipeUserInfo user = EmailPassword.signUp(process.main, "test@example.com", "testPass123");  // create a mapping with the user UserIdMapping.createUserIdMapping(process.main, user.getSupertokensUserId(), externalId, null, false);  // create entry in nonAuth table with externalId StorageLayer.getStorage(process.main) .addInfoToNonAuthRecipesBasedOnUserId(TenantIdentifier.BASE_TENANT, className, externalId);  // try to delete UserIdMapping String errorMessage = null; try { UserIdMapping.deleteUserIdMapping(process.main, user.getSupertokensUserId(), UserIdType.SUPERTOKENS, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } if (!nonAuthRecipesWhichDontNeedUserIdMapping.contains(className)) { "<AssertPlaceHolder>"; assertTrue(errorMessage.contains("UserId is already in use")); } // delete user data AuthRecipe.deleteUser(process.main, user.getSupertokensUserId()); }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
deleteUserIdMapping(Main main, String userId, UserIdType userIdType, boolean force) throws StorageQueryException, ServletException { Storage storage = StorageLayer.getStorage(main); return deleteUserIdMapping( new AppIdentifier(null, null), storage, userId, userIdType, force); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create an EmailPassword User AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123"); // create a mapping for the EmailPassword User UserIdMapping.createUserIdMapping(process.main, user_1.getSupertokensUserId(), "externalId", null, false);  // create some metadata for the user JsonObject data = new JsonObject(); data.addProperty("test", "testData"); UserMetadata.updateUserMetadata(process.main, "externalId", data);  // Create another User AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@example.com", "testPass123");  // try and map user_2 to user_1s superTokensUserId String errorMessage = null; try { UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } "<AssertPlaceHolder>"; assertEquals("Cannot create a userId mapping where the externalId is also a SuperTokens userID", errorMessage);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create user 1 AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123");  // create user 2 AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@example.com", "testPass123");  // create a mapping between User_1 and User_2 with force UserIdMapping.createUserIdMapping(process.main, user_1.getSupertokensUserId(), user_2.getSupertokensUserId(), null, true);  // try and create a mapping between User_2 and User_1 without force String errorMessage = null; try { UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, false); } catch (ServletException e) { errorMessage = e.getRootCause().getMessage(); } "<AssertPlaceHolder>"; assertEquals("Cannot create a userId mapping where the externalId is also a SuperTokens userID", errorMessage);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
createUserIdMapping(Main main, String superTokensUserId, String externalUserId, String externalUserIdInfo, boolean force) throws ServletException, UnknownSuperTokensUserIdException, UserIdMappingAlreadyExistsException, StorageQueryException, UnknownUserIdException { createUserIdMapping(main, superTokensUserId, externalUserId, externalUserIdInfo, force, false); }
[*] target: assertNotNull(errorMessage)
[-] pred: org. junit. Assert. assertNotNull ( errorMessage )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create User_1 and User_2 AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123"); AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@exmaple.com", "testPass123");  // create a mapping between User_2 and User_1 with force UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, true);  // check that mapping exists { io.supertokens.pluginInterface.useridmapping.UserIdMapping mapping = UserIdMapping .getUserIdMapping(process.main, user_2.getSupertokensUserId(), UserIdType.SUPERTOKENS); assertNotNull(mapping); assertEquals(mapping.superTokensUserId, user_2.getSupertokensUserId()); assertEquals(mapping.externalUserId, user_1.getSupertokensUserId()); }  // delete mapping with User_1s Id and UserIdType set to ANY, it should delete the mapping assertTrue( UserIdMapping.deleteUserIdMapping(process.main, user_1.getSupertokensUserId(), UserIdType.ANY, false));  // check that mapping is deleted { io.supertokens.pluginInterface.useridmapping.UserIdMapping mapping = UserIdMapping .getUserIdMapping(process.main, user_2.getSupertokensUserId(), UserIdType.SUPERTOKENS); "<AssertPlaceHolder>"; }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserIdMapping( Main main, String userId, UserIdType userIdType) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserIdMapping(new AppIdentifier(null, null), storage, userId, userIdType); }
[*] target: assertNull(mapping)
[-] pred: org. junit. Assert. assertNull ( mapping )
************************************
************************************
[+] input: Exception { String[] args = {"../"}; TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  // create User_1 and User_2 AuthRecipeUserInfo user_1 = EmailPassword.signUp(process.main, "test@example.com", "testPass123"); AuthRecipeUserInfo user_2 = EmailPassword.signUp(process.main, "test123@exmaple.com", "testPass123");  // create a mapping between User_2 and User_1 with force UserIdMapping.createUserIdMapping(process.main, user_2.getSupertokensUserId(), user_1.getSupertokensUserId(), null, true);  // check that mapping exists { io.supertokens.pluginInterface.useridmapping.UserIdMapping mapping = UserIdMapping .getUserIdMapping(process.main, user_2.getSupertokensUserId(), UserIdType.SUPERTOKENS); assertNotNull(mapping); assertEquals(mapping.superTokensUserId, user_2.getSupertokensUserId()); assertEquals(mapping.externalUserId, user_1.getSupertokensUserId()); }  // delete mapping with User_1s Id and UserIdType set to ANY, it should delete the mapping assertTrue( UserIdMapping.deleteUserIdMapping(process.main, user_1.getSupertokensUserId(), UserIdType.SUPERTOKENS, false));  // check that mapping is deleted { io.supertokens.pluginInterface.useridmapping.UserIdMapping mapping = UserIdMapping .getUserIdMapping(process.main, user_2.getSupertokensUserId(), UserIdType.SUPERTOKENS); "<AssertPlaceHolder>"; }  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserIdMapping( Main main, String userId, UserIdType userIdType) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserIdMapping(new AppIdentifier(null, null), storage, userId, userIdType); }
[*] target: assertNull(mapping)
[-] pred: org. junit. Assert. assertNull ( mapping )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  String userId = "userId"; JsonObject metadata = UserMetadata.getUserMetadata(process.getProcess(), userId);  "<AssertPlaceHolder>"; assertEquals(metadata.entrySet().size(), 0);  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserMetadata(Main main, @Nonnull String userId) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserMetadata(new AppIdentifier(null, null), storage, userId); }
[*] target: assertNotNull(metadata)
[-] pred: org. junit. Assert. assertNotNull ( metadata )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  String userId = "userId"; JsonObject update = new JsonObject(); update.addProperty("test", "123"); update.add("testNull", JsonNull.INSTANCE); JsonObject updateResult = UserMetadata.updateUserMetadata(process.getProcess(), userId, update);  JsonObject newMetadata = UserMetadata.getUserMetadata(process.getProcess(), userId);  "<AssertPlaceHolder>"; assertEquals(1, updateResult.entrySet().size()); assertEquals("123", updateResult.get("test").getAsString()); assert (!updateResult.has("testNull"));  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserMetadata(Main main, @Nonnull String userId) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserMetadata(new AppIdentifier(null, null), storage, userId); }
[*] target: assertEquals(updateResult, newMetadata)
[-] pred: org. junit. Assert. assertEquals ( updateResult, newMetadata )
************************************
************************************
[+] input: Exception { String[] args = {"../"};  TestingProcessManager.TestingProcess process = TestingProcessManager.start(args); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STARTED));  if (StorageLayer.getStorage(process.getProcess()).getType() != STORAGE_TYPE.SQL) { return; }  String userId = "userId";  JsonObject originalMetadata = new JsonObject(); JsonObject subObject = new JsonObject(); subObject.addProperty("subsub", "123"); originalMetadata.add("testUpdate", subObject); originalMetadata.addProperty("unmodified", "123"); originalMetadata.addProperty("cleared", 123);  // First we create the original UserMetadata.updateUserMetadata(process.getProcess(), userId, originalMetadata);  JsonObject update = new JsonObject(); JsonObject updateSubObject = new JsonObject(); updateSubObject.addProperty("subsubupdate", "subnew!"); update.add("testUpdate", updateSubObject); update.addProperty("testNew", "new!"); update.add("cleared", JsonNull.INSTANCE);  JsonObject updateResult = UserMetadata.updateUserMetadata(process.getProcess(), userId, update);  JsonObject newMetadata = UserMetadata.getUserMetadata(process.getProcess(), userId);  "<AssertPlaceHolder>";  // We removed what we set to null assert (!newMetadata.has("cleared"));  // The old metadata is left intact assertEquals("123", newMetadata.get("unmodified").getAsString());  JsonObject newSubObj = newMetadata.getAsJsonObject("testUpdate"); // The up assertEquals(1, newSubObj.entrySet().size()); assertEquals("subnew!", newSubObj.get("subsubupdate").getAsString());  assert (newMetadata.has("testNew")); assertEquals("new!", newMetadata.get("testNew").getAsString());  process.kill(); assertNotNull(process.checkOrWaitForEvent(ProcessState.PROCESS_STATE.STOPPED)); }
getUserMetadata(Main main, @Nonnull String userId) throws StorageQueryException { Storage storage = StorageLayer.getStorage(main); return getUserMetadata(new AppIdentifier(null, null), storage, userId); }
[*] target: assertEquals(updateResult, newMetadata)
[-] pred: org. junit. Assert. assertEquals ( updateResult, newMetadata )
************************************
************************************
[+] input: testCollectUniqueSharedSubscriptions() { List<String> topics = List.of( "test/topic", "my/home/+/bedroom", "home/#", "$share/g1/test/my/#", "$share/g1/test/my/topic", "$share/g2/test/my/topic");  Set<TopicSharedSubscription> sharedSubscriptions = mqttUnsubscribeHandler.collectUniqueSharedSubscriptions(topics);  "<AssertPlaceHolder>"; assertEquals(Set.of( new TopicSharedSubscription("test/my/#", "g1"), new TopicSharedSubscription("test/my/topic", "g1"), new TopicSharedSubscription("test/my/topic", "g2") ), sharedSubscriptions); }
collectUniqueSharedSubscriptions(List<String> topics) { return topics .stream() .filter(NettyMqttConverter::isSharedTopic) .map(topic -> new TopicSharedSubscription( NettyMqttConverter.getTopicName(topic), NettyMqttConverter.getShareName(topic))) .collect(Collectors.toSet()); }
[*] target: assertEquals(3, sharedSubscriptions.size())
[-] pred: org. junit. Assert. assertEquals ( 3, sharedSubscriptions. size ( ) )
************************************
************************************
[+] input: givenMqttPropertiesWithPayloadFormatIndicatorAndContentType_whenGetMqttPropsProtoBuilder_thenGetExpectedResult() { MqttProperties properties = new MqttProperties(); properties.add(new MqttProperties.IntegerProperty(BrokerConstants.PAYLOAD_FORMAT_INDICATOR_PROP_ID, 1)); properties.add(new MqttProperties.StringProperty(BrokerConstants.CONTENT_TYPE_PROP_ID, "test"));  QueueProtos.MqttPropertiesProto.Builder mqttPropsProtoBuilder = ProtoConverter.getMqttPropsProtoBuilder(properties);  "<AssertPlaceHolder>"; QueueProtos.MqttPropertiesProto proto = mqttPropsProtoBuilder.build(); assertEquals("test", proto.getContentType()); assertEquals(1, proto.getPayloadFormatIndicator()); }
getMqttPropsProtoBuilder(MqttProperties properties) { Integer payloadFormatIndicator = getPayloadFormatIndicatorFromMqttProperties(properties); String contentType = getContentTypeFromMqttProperties(properties); String responseTopic = MqttPropertiesUtil.getResponseTopicValue(properties); byte[] correlationData = MqttPropertiesUtil.getCorrelationDataValue(properties); if (payloadFormatIndicator != null || contentType != null || responseTopic != null || correlationData != null) { QueueProtos.MqttPropertiesProto.Builder mqttPropertiesBuilder = QueueProtos.MqttPropertiesProto.newBuilder(); if (payloadFormatIndicator != null) { mqttPropertiesBuilder.setPayloadFormatIndicator(payloadFormatIndicator); } if (contentType != null) { mqttPropertiesBuilder.setContentType(contentType); } if (responseTopic != null) { mqttPropertiesBuilder.setResponseTopic(responseTopic); } if (correlationData != null) { mqttPropertiesBuilder.setCorrelationData(ByteString.copyFrom(correlationData)); } return mqttPropertiesBuilder; } return null; }
[*] target: assertNotNull(mqttPropsProtoBuilder)
[-] pred: org. junit. Assert. assertNotNull ( mqttPropsProtoBuilder )
************************************
************************************
[+] input: givenMqttPropertiesWithResponseTopicAndCorrelationData_whenGetMqttPropsProtoBuilder_thenGetExpectedResult() { MqttProperties properties = new MqttProperties(); properties.add(new MqttProperties.BinaryProperty(BrokerConstants.CORRELATION_DATA_PROP_ID, "test".getBytes(StandardCharsets.UTF_8))); properties.add(new MqttProperties.StringProperty(BrokerConstants.RESPONSE_TOPIC_PROP_ID, "test/"));  QueueProtos.MqttPropertiesProto.Builder mqttPropsProtoBuilder = ProtoConverter.getMqttPropsProtoBuilder(properties);  "<AssertPlaceHolder>"; QueueProtos.MqttPropertiesProto proto = mqttPropsProtoBuilder.build(); assertEquals("test/", proto.getResponseTopic()); assertEquals("test", proto.getCorrelationData().toString(StandardCharsets.UTF_8)); }
getMqttPropsProtoBuilder(MqttProperties properties) { Integer payloadFormatIndicator = getPayloadFormatIndicatorFromMqttProperties(properties); String contentType = getContentTypeFromMqttProperties(properties); String responseTopic = MqttPropertiesUtil.getResponseTopicValue(properties); byte[] correlationData = MqttPropertiesUtil.getCorrelationDataValue(properties); if (payloadFormatIndicator != null || contentType != null || responseTopic != null || correlationData != null) { QueueProtos.MqttPropertiesProto.Builder mqttPropertiesBuilder = QueueProtos.MqttPropertiesProto.newBuilder(); if (payloadFormatIndicator != null) { mqttPropertiesBuilder.setPayloadFormatIndicator(payloadFormatIndicator); } if (contentType != null) { mqttPropertiesBuilder.setContentType(contentType); } if (responseTopic != null) { mqttPropertiesBuilder.setResponseTopic(responseTopic); } if (correlationData != null) { mqttPropertiesBuilder.setCorrelationData(ByteString.copyFrom(correlationData)); } return mqttPropertiesBuilder; } return null; }
[*] target: assertNotNull(mqttPropsProtoBuilder)
[-] pred: org. junit. Assert. assertNotNull ( mqttPropsProtoBuilder )
************************************
************************************
[+] input: givenMqttPropertiesWithPayloadFormatIndicatorAndNoContentType_whenGetMqttPropsProtoBuilder_thenGetExpectedResult() { MqttProperties properties = new MqttProperties(); properties.add(new MqttProperties.IntegerProperty(BrokerConstants.PAYLOAD_FORMAT_INDICATOR_PROP_ID, 1));  QueueProtos.MqttPropertiesProto.Builder mqttPropsProtoBuilder = ProtoConverter.getMqttPropsProtoBuilder(properties);  "<AssertPlaceHolder>"; QueueProtos.MqttPropertiesProto proto = mqttPropsProtoBuilder.build(); assertFalse(proto.hasContentType()); assertEquals(1, proto.getPayloadFormatIndicator()); }
getMqttPropsProtoBuilder(MqttProperties properties) { Integer payloadFormatIndicator = getPayloadFormatIndicatorFromMqttProperties(properties); String contentType = getContentTypeFromMqttProperties(properties); String responseTopic = MqttPropertiesUtil.getResponseTopicValue(properties); byte[] correlationData = MqttPropertiesUtil.getCorrelationDataValue(properties); if (payloadFormatIndicator != null || contentType != null || responseTopic != null || correlationData != null) { QueueProtos.MqttPropertiesProto.Builder mqttPropertiesBuilder = QueueProtos.MqttPropertiesProto.newBuilder(); if (payloadFormatIndicator != null) { mqttPropertiesBuilder.setPayloadFormatIndicator(payloadFormatIndicator); } if (contentType != null) { mqttPropertiesBuilder.setContentType(contentType); } if (responseTopic != null) { mqttPropertiesBuilder.setResponseTopic(responseTopic); } if (correlationData != null) { mqttPropertiesBuilder.setCorrelationData(ByteString.copyFrom(correlationData)); } return mqttPropertiesBuilder; } return null; }
[*] target: assertNotNull(mqttPropsProtoBuilder)
[-] pred: org. junit. Assert. assertNotNull ( mqttPropsProtoBuilder )
************************************
************************************
[+] input: testDevicePersistedMsgsBucketConfiguration() { DevicePersistedMsgsRateLimitsConfiguration config = new DevicePersistedMsgsRateLimitsConfiguration(); config.setEnabled(true); config.setConfig("100:60,200:120");  BucketConfiguration bucketConfig = config.devicePersistedMsgsBucketConfiguration();  "<AssertPlaceHolder>"; assertEquals(2, bucketConfig.getBandwidths().length);  Bandwidth bw1 = bucketConfig.getBandwidths()[0]; assertEquals(100, bw1.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(60), bw1.getRefillPeriodNanos());  Bandwidth bw2 = bucketConfig.getBandwidths()[1]; assertEquals(200, bw2.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(120), bw2.getRefillPeriodNanos()); }
devicePersistedMsgsBucketConfiguration() { return getBucketConfiguration(); }
[*] target: assertNotNull(bucketConfig)
[-] pred: org. junit. Assert. assertNotNull ( bucketConfig )
************************************
************************************
[+] input: testTotalMsgsBucketConfiguration() { TotalMsgsRateLimitsConfiguration config = new TotalMsgsRateLimitsConfiguration(); config.setEnabled(true); config.setConfig("100:60,200:120");  BucketConfiguration bucketConfig = config.totalMsgsBucketConfiguration();  "<AssertPlaceHolder>"; assertEquals(2, bucketConfig.getBandwidths().length);  Bandwidth bw1 = bucketConfig.getBandwidths()[0]; assertEquals(100, bw1.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(60), bw1.getRefillPeriodNanos());  Bandwidth bw2 = bucketConfig.getBandwidths()[1]; assertEquals(200, bw2.getCapacity()); assertEquals(TimeUnit.SECONDS.toNanos(120), bw2.getRefillPeriodNanos()); }
totalMsgsBucketConfiguration() { return getBucketConfiguration(); }
[*] target: assertNotNull(bucketConfig)
[-] pred: org. junit. Assert. assertNotNull ( bucketConfig )
************************************
************************************
[+] input: testConvertToSharedSubscriptionList() { Set<Subscription> subscriptions = Set.of( newSubscription(0, "group1"), newSubscription(1, "group1"), newSubscription(2, "group2"), newSubscription(0, "group2"), newSubscription(1, "group3"), newSubscription(2, "group3") ); List<SharedSubscription> sharedSubscriptionList = msgDispatcherService.toSharedSubscriptionList(subscriptions); "<AssertPlaceHolder>"; sharedSubscriptionList.forEach(sharedSubscription -> assertEquals(2, sharedSubscription.getSubscriptions().size())); }
toSharedSubscriptionList(Set<Subscription> sharedSubscriptions) { return sharedSubscriptions.stream() .collect(Collectors.groupingBy(subscription -> new TopicSharedSubscription(subscription.getTopicFilter(), subscription.getShareName(), subscription.getQos()))) .entrySet().stream() .map(entry -> new SharedSubscription(entry.getKey(), entry.getValue())) .collect(Collectors.toList()); }
[*] target: assertEquals(3, sharedSubscriptionList.size())
[-] pred: org. junit. Assert. assertEquals ( 3, sharedSubscriptionList. size ( ) )
************************************
************************************
[+] input: givenPubMsgAndSubscriptionWithSameQosAndRetainAsPublish_whenProcessUpdatePublishMsg_thenReturnSameMsg() { Subscription subscription = new Subscription( "test/topic", 2, ClientSessionInfo.builder().build(), null, new SubscriptionOptions( false, true, SubscriptionOptions.RetainHandlingPolicy.SEND_AT_SUBSCRIBE));  QueueProtos.PublishMsgProto beforePublishMsgProto = QueueProtos.PublishMsgProto.newBuilder().setQos(2).setRetain(true).build();  QueueProtos.PublishMsgProto afterPublishMsgProto = downLinkProxy.updatePublishMsg(subscription, beforePublishMsgProto);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(2, afterPublishMsgProto.getQos()); Assert.assertTrue(afterPublishMsgProto.getRetain()); }
updatePublishMsg(Subscription subscription, PublishMsgProto publishMsgProto) { var minQos = Math.min(subscription.getQos(), publishMsgProto.getQos()); var retain = subscription.getOptions().isRetain(publishMsgProto.getRetain());  if (minQos != publishMsgProto.getQos() || retain != publishMsgProto.getRetain()) { return publishMsgProto.toBuilder() .setQos(minQos) .setRetain(retain) .build(); } else { return publishMsgProto; } }
[*] target: assertEquals(beforePublishMsgProto, afterPublishMsgProto)
[-] pred: org. junit. Assert. assertEquals ( beforePublishMsgProto, afterPublishMsgProto )
************************************
************************************
[+] input: testCleanUpBySize() { int maxPersistedMessages = 10;  deviceMsgCleanUpDao.cleanUpBySize(maxPersistedMessages);  List<DevicePublishMsgEntity> remainingMessages = deviceMsgRepository.findAll(); Assert."<AssertPlaceHolder>";  for (int i = 0; i < maxPersistedMessages; i++) { Assert.assertEquals(i + 10, remainingMessages.get(i).getSerialNumber().intValue()); } }
cleanUpBySize(int maxPersistedMessages) { if (maxPersistedMessages <= 0) { log.error("Only positive numbers are allowed."); return; } log.trace("Cleaning up device publish messages to match max size {}.", maxPersistedMessages);  Page<DeviceSessionCtxEntity> deviceSessionCtxEntities; int pageCounter = 0; do { deviceSessionCtxEntities = deviceSessionCtxRepository.findAll(PageRequest.of(pageCounter++, sessionCtxPageSize)); for (DeviceSessionCtxEntity deviceSessionCtxEntity : deviceSessionCtxEntities) { String clientId = deviceSessionCtxEntity.getClientId(); DevicePublishMsgEntity earliestPersistedMsg = deviceMsgRepository.findEntityByClientIdAfterOffset(clientId, maxPersistedMessages - 1); if (earliestPersistedMsg == null) { log.trace("[{}] No messages to clean up.", clientId); } else { log.trace("[{}] Clearing messages with serial number less than {}.", clientId, earliestPersistedMsg.getSerialNumber()); int removed = deviceMsgRepository.removeAllByClientIdAndSerialNumberLessThan(clientId, earliestPersistedMsg.getSerialNumber()); log.debug("[{}] Removed {} messages.", clientId, removed); } } } while (!deviceSessionCtxEntities.isLast());  }
[*] target: assertEquals(maxPersistedMessages, remainingMessages.size())
[-] pred: org. junit. Assert. assertEquals ( maxPersistedMessages, remainingMessages. size ( ) )
************************************
************************************
[+] input: Exception { String entityId = RandomStringUtils.randomAlphabetic(20);  saveEntries(entityId, TS - 2); saveEntries(entityId, TS - 1); saveEntries(entityId, TS);  List<TsKvEntry> entries = tsService.findLatest(entityId, Collections.singleton(LONG_KEY)).get(MAX_TIMEOUT, TimeUnit.SECONDS); Assert."<AssertPlaceHolder>"; Assert.assertEquals(toTsEntry(TS, longKvEntry), entries.get(0)); }
findLatest(String entityId, Collection<String> keys);
[*] target: assertEquals(1, entries.size())
[-] pred: org. junit. Assert. assertEquals ( 1, entries. size ( ) )
************************************
************************************
[+] input: testFindUserById() { User user = userService.findUserByEmail("sysadmin@thingsboard.org"); Assert.assertNotNull(user); User foundUser = userService.findUserById(user.getId()); Assert."<AssertPlaceHolder>"; Assert.assertEquals(user, foundUser); }
findUserById(UUID userId);
[*] target: assertNotNull(foundUser)
[-] pred: org. junit. Assert. assertNotNull ( foundUser )
************************************
************************************
[+] input: testFindUserCredentials() { User user = userService.findUserByEmail("sysadmin@thingsboard.org"); Assert.assertNotNull(user); UserCredentials userCredentials = userService.findUserCredentialsByUserId(user.getId()); Assert."<AssertPlaceHolder>"; }
findUserCredentialsByUserId(UUID userId);
[*] target: assertNotNull(userCredentials)
[-] pred: org. junit. Assert. assertNotNull ( userCredentials )
************************************
************************************
[+] input: testDeleteUser() { User user = new User(); user.setAuthority(Authority.SYS_ADMIN); user.setEmail("admin2@thingsboard.org"); User savedUser = userService.saveUser(user); Assert.assertNotNull(savedUser); Assert.assertNotNull(savedUser.getId());  User foundUser = userService.findUserById(savedUser.getId()); Assert.assertNotNull(foundUser);  UserCredentials userCredentials = userService.findUserCredentialsByUserId(foundUser.getId()); Assert.assertNotNull(userCredentials);  userService.deleteUser(foundUser.getId());  userCredentials = userService.findUserCredentialsByUserId(foundUser.getId()); foundUser = userService.findUserById(foundUser.getId()); Assert."<AssertPlaceHolder>"; Assert.assertNull(userCredentials); }
findUserById(UUID userId);
[*] target: assertNull(foundUser)
[-] pred: org. junit. Assert. assertNull ( foundUser )
************************************
************************************
[+] input: testEquals() { final MutableSensorRegistry sensorRegistry1 = this.getSensorRegistry(); final MutableSensorRegistry sensorRegistry2 = this.getSensorRegistry(); assertFalse(sensorRegistry1 == sensorRegistry2); assertTrue(sensorRegistry1.equals(sensorRegistry2)); "<AssertPlaceHolder>"; }
equals(final Object obj) { if (obj == this) { return true; } if (obj instanceof SensorRegistry) { final SensorRegistry other = (SensorRegistry) obj; return Objects.equals(this.getTopLevelSensor(), other.getTopLevelSensor()); } return false; }
[*] target: assertTrue(sensorRegistry2.equals(sensorRegistry1))
[-] pred: org. junit. Assert. assertTrue ( sensorRegistry2. equals ( sensorRegistry1 ) )
************************************
************************************
[+] input: BadMessageException { // Assume that we are Bob = the responder createSessions();  Assert.assertNotNull(this.responderDHSession.getPeerRatchet2DH()); Assert.assertNotNull(this.responderDHSession.getPeerRatchet4DH());  // Store the responder session, including the 2DH ratchet store.storeDHSession(this.responderDHSession);  // There should still be a 2DH ratchet at this point DHSession retrievedSession = store.getDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), this.responderDHSession.getId(), taskCodec); Assert.assertNotNull(retrievedSession); Assert.assertNotNull(retrievedSession.getPeerRatchet2DH());  // Discard the 2DH ratchet (assume Bob has received a 4DH message from Alice) this.responderDHSession.discardPeerRatchet2DH(); Assert.assertNull(this.responderDHSession.getPeerRatchet2DH());  // Store the responder session again without the 2DH ratchet store.storeDHSession(this.responderDHSession);  // Ensure that the 2DH ratchet is really gone retrievedSession = store.getDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), this.responderDHSession.getId(), taskCodec); Assert."<AssertPlaceHolder>"; Assert.assertNull(retrievedSession.getPeerRatchet2DH()); }
getDHSession(String myIdentity, String peerIdentity, @Nullable DHSessionId sessionId, @NonNull ActiveTaskCodec handle) throws DHSessionStoreException { String selection = COLUMN_MY_IDENTITY + "=? and " + COLUMN_PEER_IDENTITY + "=?";  if (sessionId != null) { selection += " and " + COLUMN_SESSION_ID + "=x'" + Utils.byteArrayToHexString(sessionId.get()) + "'"; }  try (Cursor cursor = this.getReadableDatabase().query( SESSION_TABLE, new String[]{ COLUMN_SESSION_ID, COLUMN_MY_IDENTITY, COLUMN_PEER_IDENTITY, COLUMN_MY_CURRENT_VERSION_4_DH, COLUMN_LAST_OUTGOING_MESSAGE_TIMESTAMP, COLUMN_MY_EPHEMERAL_PRIVATE_KEY, COLUMN_MY_EPHEMERAL_PUBLIC_KEY, COLUMN_MY_CURRENT_CHAIN_KEY_2_DH, COLUMN_MY_COUNTER_2_DH, COLUMN_MY_CURRENT_CHAIN_KEY_4_DH, COLUMN_MY_COUNTER_4_DH, COLUMN_PEER_CURRENT_VERSION_4_DH, COLUMN_PEER_CURRENT_CHAIN_KEY_2_DH, COLUMN_PEER_COUNTER_2_DH, COLUMN_PEER_CURRENT_CHAIN_KEY_4_DH, COLUMN_PEER_COUNTER_4_DH }, selection, new String[] { myIdentity, peerIdentity }, null, null, null )) {  if (cursor != null) { if (cursor.moveToFirst()) { return dhSessionFromCursor(cursor, handle); } }  return null; } catch (SQLException e) { throw new DHSessionStoreException("Cannot load session", e); } }
[*] target: assertNotNull(retrievedSession)
[-] pred: org. junit. Assert. assertNotNull ( retrievedSession )
************************************
************************************
[+] input: parseWithRel() { final String candidate = "candidate:373990095 1 udp 41885439 5.148.189.205 63293 typ relay raddr 1.2.3.4 rport 5432"; final IceCandidateParser.CandidateData result = IceCandidateParser.parse(candidate); "<AssertPlaceHolder>"; assertEquals("1.2.3.4", result.relAddr); assertEquals(Integer.valueOf(5432), result.relPort); }
parse(@NonNull String candidateString) { final Matcher matcher = CANDIDATE_ATTRIBUTE.matcher(candidateString); if (!matcher.matches()) { return null; }  // Unfortunately the Regex module shipped with Android does not support // named capture groups, therefore we need to stick with the brittle and hacky // numbered capture group approach. Fortunately there are tests.  // Extract extensions final String extensionsString = matcher.group(12); final Map<String, String> extensions = new HashMap<>(); if (extensionsString != null) { String key = null; for (String segment : extensionsString.trim().split(" ")) { if (key == null) { key = segment; } else { extensions.put(key, segment); key = null; } } }  // Extract rest of data, return data POJO return new CandidateData( matcher.group(1), Integer.parseInt(matcher.group(2)), matcher.group(3), extensions.get("tcptype"), Integer.parseInt(matcher.group(4)), matcher.group(5), Integer.parseInt(matcher.group(6)), matcher.group(7), matcher.group(9), matcher.group(11) == null ? null : Integer.parseInt(matcher.group(11)), extensions ); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: parseWithRelAddr() { final String candidate = "candidate:373990095 1 udp 41885439 5.148.189.205 63293 typ relay raddr ::1"; final IceCandidateParser.CandidateData result = IceCandidateParser.parse(candidate); "<AssertPlaceHolder>"; assertEquals("::1", result.relAddr); assertEquals(null, result.relPort); }
parse(@NonNull String candidateString) { final Matcher matcher = CANDIDATE_ATTRIBUTE.matcher(candidateString); if (!matcher.matches()) { return null; }  // Unfortunately the Regex module shipped with Android does not support // named capture groups, therefore we need to stick with the brittle and hacky // numbered capture group approach. Fortunately there are tests.  // Extract extensions final String extensionsString = matcher.group(12); final Map<String, String> extensions = new HashMap<>(); if (extensionsString != null) { String key = null; for (String segment : extensionsString.trim().split(" ")) { if (key == null) { key = segment; } else { extensions.put(key, segment); key = null; } } }  // Extract rest of data, return data POJO return new CandidateData( matcher.group(1), Integer.parseInt(matcher.group(2)), matcher.group(3), extensions.get("tcptype"), Integer.parseInt(matcher.group(4)), matcher.group(5), Integer.parseInt(matcher.group(6)), matcher.group(7), matcher.group(9), matcher.group(11) == null ? null : Integer.parseInt(matcher.group(11)), extensions ); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: parseFull() { final String candidate = "candidate:842163049 1 udp 1686052607 1.2.3.4 46154 typ srflx raddr 10.0.0.17 rport 46154 generation 0 ufrag EEtu network-id 3 network-cost 10"; final IceCandidateParser.CandidateData result = IceCandidateParser.parse(candidate); "<AssertPlaceHolder>"; assertEquals("842163049", result.foundation); assertEquals(1, result.componentId); assertEquals("udp", result.transport); assertNull("udp", result.tcptype); assertEquals(1686052607, result.priority); assertEquals("1.2.3.4", result.connectionAddress); assertEquals(46154, result.port); assertEquals("srflx", result.candType); assertEquals("10.0.0.17", result.relAddr); assertEquals(Integer.valueOf(46154), result.relPort); assertEquals(new HashMap<String, String>() {{ put("generation", "0"); put("ufrag", "EEtu"); put("network-id", "3"); put("network-cost", "10"); }}, result.extensions); }
parse(@NonNull String candidateString) { final Matcher matcher = CANDIDATE_ATTRIBUTE.matcher(candidateString); if (!matcher.matches()) { return null; }  // Unfortunately the Regex module shipped with Android does not support // named capture groups, therefore we need to stick with the brittle and hacky // numbered capture group approach. Fortunately there are tests.  // Extract extensions final String extensionsString = matcher.group(12); final Map<String, String> extensions = new HashMap<>(); if (extensionsString != null) { String key = null; for (String segment : extensionsString.trim().split(" ")) { if (key == null) { key = segment; } else { extensions.put(key, segment); key = null; } } }  // Extract rest of data, return data POJO return new CandidateData( matcher.group(1), Integer.parseInt(matcher.group(2)), matcher.group(3), extensions.get("tcptype"), Integer.parseInt(matcher.group(4)), matcher.group(5), Integer.parseInt(matcher.group(6)), matcher.group(7), matcher.group(9), matcher.group(11) == null ? null : Integer.parseInt(matcher.group(11)), extensions ); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: getAllReceivers_message_without_affected_receivers() { ContactMessageReceiver contactMessageReceiver = createContactMessageReceiver();  // Message receiver without affected receivers List<MessageReceiver> allReceivers = MessageUtil.getAllReceivers(contactMessageReceiver); "<AssertPlaceHolder>"; assertEquals(contactMessageReceiver, allReceivers.get(0)); }
getAllReceivers(final MessageReceiver messageReceiver) {  ArrayList<MessageReceiver> allReceivers = new ArrayList<>(); allReceivers.add(messageReceiver);  List<MessageReceiver> affectedReceivers = messageReceiver.getAffectedMessageReceivers(); if (affectedReceivers != null && affectedReceivers.size() > 0) { allReceivers.addAll(Functional.filter(affectedReceivers, new IPredicateNonNull<>() { @Override public boolean apply(@NonNull MessageReceiver type) { return !type.isEqual(messageReceiver); } })); } return allReceivers; }
[*] target: assertEquals(1, allReceivers.size())
[-] pred: org. junit. Assert. assertEquals ( 1, allReceivers. size ( ) )
************************************
************************************
[+] input: Exception { String base64QrCodeContent = "BTkCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkIjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIxM3EzcTNxM3EzcTNxM3EzcTNxM3EzcTNxM3EzcTNxM3BNJzYWx0eXJ0Yy5leGFtcGxlLm9yZw==";  QRCodeParser service = new QRCodeParserImpl(); QRCodeParser.Result result = service.parse(Base64.decode(base64QrCodeContent)); "<AssertPlaceHolder>"; assertEquals("saltyrtc.example.org", result.saltyRtcHost); assertEquals(1234, result.saltyRtcPort); assertEquals(true, result.isPermanent); assertTrue(Arrays.equals(result.authToken, new byte[]{ 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35 })); assertTrue(Arrays.equals(result.key, new byte[]{ 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66 })); assertTrue(Arrays.equals(result.serverKey, new byte[] { 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55, 19, 55 })); }
parse(@Nullable byte[] payload) throws InvalidQrCodeException {  if(payload == null) { throw new InvalidQrCodeException("invalid payload string"); }  int fixedLength = PROTOCOL_VERSION_LENGTH + OPTIONS_LENGTH + KEY_LENGTH + AUTH_TOKEN_LENGTH + SERVER_KEY_LENGTH + SALTY_RTC_PORT_LENGTH ;  if(payload.length < fixedLength+1) { throw new InvalidQrCodeException("invalid payload length"); }  try { ByteArrayInputStream bis = new ByteArrayInputStream(payload);  byte[] protocolVersionBytes = new byte[PROTOCOL_VERSION_LENGTH]; bis.read(protocolVersionBytes);  int protocolVersion = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(protocolVersionBytes).getShort());  byte[] options = new byte[OPTIONS_LENGTH]; bis.read(options);  boolean isSelfHosted = (options[0] & 0x01) != 0; boolean isPermanent = (options[0] & 0x02) != 0;  byte[] key = new byte[KEY_LENGTH]; bis.read(key);  byte[] authToken = new byte[AUTH_TOKEN_LENGTH]; bis.read(authToken);  // Note: Server public key may consist of only 0 bytes if not defined in Threema Web byte[] serverKey = null; byte[] serverKeyTemporary = new byte[SERVER_KEY_LENGTH]; bis.read(serverKeyTemporary); for (byte b : serverKeyTemporary) { if (b != 0) { serverKey = serverKeyTemporary; break; } }  byte[] portBytes = new byte[SALTY_RTC_PORT_LENGTH]; bis.read(portBytes); int port = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(portBytes).getShort());  String host = new String(payload, fixedLength, payload.length - fixedLength);  return new Result( protocolVersion, isSelfHosted, isPermanent, key, authToken, serverKey, port, host); } catch (IOException x) { throw new InvalidQrCodeException("Invalid Threema Web QR code contents"); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { String base64QrCodeContent = "BTkCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkIjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABNJzYWx0eXJ0Yy5leGFtcGxlLm9yZw==";  QRCodeParser service = new QRCodeParserImpl(); QRCodeParser.Result result = service.parse(Base64.decode(base64QrCodeContent)); "<AssertPlaceHolder>"; assertEquals("saltyrtc.example.org", result.saltyRtcHost); assertEquals(1234, result.saltyRtcPort); assertEquals(true, result.isPermanent); assertTrue(Arrays.equals(result.authToken, new byte[]{ 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35 })); assertTrue(Arrays.equals(result.key, new byte[]{ 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66 }));  //no server key assertNull(result.serverKey); }
parse(@Nullable byte[] payload) throws InvalidQrCodeException {  if(payload == null) { throw new InvalidQrCodeException("invalid payload string"); }  int fixedLength = PROTOCOL_VERSION_LENGTH + OPTIONS_LENGTH + KEY_LENGTH + AUTH_TOKEN_LENGTH + SERVER_KEY_LENGTH + SALTY_RTC_PORT_LENGTH ;  if(payload.length < fixedLength+1) { throw new InvalidQrCodeException("invalid payload length"); }  try { ByteArrayInputStream bis = new ByteArrayInputStream(payload);  byte[] protocolVersionBytes = new byte[PROTOCOL_VERSION_LENGTH]; bis.read(protocolVersionBytes);  int protocolVersion = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(protocolVersionBytes).getShort());  byte[] options = new byte[OPTIONS_LENGTH]; bis.read(options);  boolean isSelfHosted = (options[0] & 0x01) != 0; boolean isPermanent = (options[0] & 0x02) != 0;  byte[] key = new byte[KEY_LENGTH]; bis.read(key);  byte[] authToken = new byte[AUTH_TOKEN_LENGTH]; bis.read(authToken);  // Note: Server public key may consist of only 0 bytes if not defined in Threema Web byte[] serverKey = null; byte[] serverKeyTemporary = new byte[SERVER_KEY_LENGTH]; bis.read(serverKeyTemporary); for (byte b : serverKeyTemporary) { if (b != 0) { serverKey = serverKeyTemporary; break; } }  byte[] portBytes = new byte[SALTY_RTC_PORT_LENGTH]; bis.read(portBytes); int port = UnsignedHelper.readUnsignedShort(ByteBuffer.wrap(portBytes).getShort());  String host = new String(payload, fixedLength, payload.length - fixedLength);  return new Result( protocolVersion, isSelfHosted, isPermanent, key, authToken, serverKey, port, host); } catch (IOException x) { throw new InvalidQrCodeException("Invalid Threema Web QR code contents"); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: testConvertList() { doCallRealMethod().when(factory).convertList(any(Cursor.class));  Cursor cursorMock = mock(Cursor.class); BallotModel ballotModelMock1 = mock(BallotModel.class); BallotModel ballotModelMock2 = mock(BallotModel.class); BallotModel ballotModelMock3 = mock(BallotModel.class);   // Loop three times when(cursorMock.moveToNext()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false); when(factory.convert(cursorMock)).thenReturn(ballotModelMock1).thenReturn(ballotModelMock2).thenReturn(ballotModelMock3); List<BallotModel> result = factory.convertList(cursorMock);  verify(factory, times(3)).convert(cursorMock);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(ballotModelMock1, result.get(0)); Assert.assertEquals(ballotModelMock2, result.get(1)); Assert.assertEquals(ballotModelMock3, result.get(2)); }
convert(Cursor cursor) { if(cursor != null && cursor.getPosition() >= 0) { final BallotModel c = new BallotModel();  //convert default new CursorHelper(cursor, this.getColumnIndexCache()).current(new CursorHelper.Callback() { @Override public boolean next(CursorHelper cursorHelper) { c .setId(cursorHelper.getInt(BallotModel.COLUMN_ID)) .setApiBallotId(cursorHelper.getString(BallotModel.COLUMN_API_BALLOT_ID)) .setCreatorIdentity(cursorHelper.getString(BallotModel.COLUMN_CREATOR_IDENTITY)) .setName(cursorHelper.getString(BallotModel.COLUMN_NAME)) .setCreatedAt(cursorHelper.getDate(BallotModel.COLUMN_CREATED_AT)) .setModifiedAt(cursorHelper.getDate(BallotModel.COLUMN_MODIFIED_AT)) .setLastViewedAt(cursorHelper.getDate(BallotModel.COLUMN_LAST_VIEWED_AT));  String stateString = cursorHelper.getString(BallotModel.COLUMN_STATE); if (!TestUtil.empty(stateString)) { c.setState(BallotModel.State.valueOf(stateString)); } String assessment = cursorHelper.getString(BallotModel.COLUMN_ASSESSMENT); if (!TestUtil.empty(assessment)) { c.setAssessment(BallotModel.Assessment.valueOf(assessment)); }  String type = cursorHelper.getString(BallotModel.COLUMN_TYPE); if (!TestUtil.empty(type)) { c.setType(BallotModel.Type.valueOf(type)); }  String choiceType = cursorHelper.getString(BallotModel.COLUMN_CHOICE_TYPE); if (!TestUtil.empty(choiceType)) { c.setChoiceType(BallotModel.ChoiceType.valueOf(choiceType)); }  String displayType = cursorHelper.getString(BallotModel.COLUMN_DISPLAY_TYPE); if (!TestUtil.empty(displayType)) { c.setDisplayType(BallotModel.DisplayType.valueOf(displayType)); }  return false; } });  return c; }  return null; }
[*] target: assertEquals(3, result.size())
[-] pred: org. junit. Assert. assertEquals ( 3, result. size ( ) )
************************************
************************************
[+] input: testUnsignedLongToBigInteger() { final BigInteger bigInteger = new BigInteger("18446744073709551610"); final long unsignedLong = bigInteger.longValue(); Assert.assertTrue(unsignedLong < 0); final BigInteger bigInteger2 = UnsignedHelper.unsignedLongToBigInteger(unsignedLong); Assert."<AssertPlaceHolder>"; }
unsignedLongToBigInteger(long val) { if (val >= 0L) { return BigInteger.valueOf(val); } else { int upper = (int) (val >>> 32); int lower = (int) val; return (BigInteger.valueOf(Integer.toUnsignedLong(upper))).shiftLeft(32). add(BigInteger.valueOf(Integer.toUnsignedLong(lower))); } }
[*] target: assertEquals(bigInteger, bigInteger2)
[-] pred: org. junit. Assert. assertEquals ( bigInteger, bigInteger2 )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"support":"the-support-url"}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertEquals("the-support-url", result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject .put("username", "u") .put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"logo":{"dark": "the-dark-logo"}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertEquals("the-dark-logo", result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"logo":{"light": "the-light-logo"}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertEquals("the-light-logo", result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size()); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn( new PostJsonResult( "{"contacts":[" + "{"id":"id1","pk":"AQ=="}," + "{"id":"id2","pk":"Aq==","first":"id2-firstname"}," + "{"id":"id3","pk":"Aw==","last":"id3-lastname"}," + "{"id":"id4","pk":"BA==","first": "id4-firstname", "last":"id4-lastname"}" + "]}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(4, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertFalse(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(0, result.mdm.parameters.size());  // Verify contacts Assert.assertEquals("id1", result.workContacts.get(0).threemaId); Assert.assertArrayEquals(new byte[]{0x01}, result.workContacts.get(0).publicKey); Assert.assertNull(result.workContacts.get(0).firstName); Assert.assertNull(result.workContacts.get(0).lastName);  Assert.assertEquals("id2", result.workContacts.get(1).threemaId); Assert.assertArrayEquals(new byte[]{0x02}, result.workContacts.get(1).publicKey); Assert.assertEquals("id2-firstname", result.workContacts.get(1).firstName); Assert.assertNull(result.workContacts.get(1).lastName);  Assert.assertEquals("id3", result.workContacts.get(2).threemaId); Assert.assertArrayEquals(new byte[]{0x03}, result.workContacts.get(2).publicKey); Assert.assertNull(result.workContacts.get(2).firstName); Assert.assertEquals("id3-lastname", result.workContacts.get(2).lastName);  Assert.assertEquals("id4", result.workContacts.get(3).threemaId); Assert.assertArrayEquals(new byte[]{0x04}, result.workContacts.get(3).publicKey); Assert.assertEquals("id4-firstname", result.workContacts.get(3).firstName); Assert.assertEquals("id4-lastname", result.workContacts.get(3).lastName); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"mdm":{" + ""override": true," + ""params":{" + ""param-string": "string-param"," + ""param-bool": true," + ""param-int": 123" + "}}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNull(result.supportUrl); Assert.assertNull(result.logoDark); Assert.assertNull(result.logoLight); Assert.assertEquals(0, result.workContacts.size()); Assert.assertNotNull(result.mdm); Assert.assertTrue(result.mdm.override); Assert.assertNotNull(result.mdm.parameters); Assert.assertEquals(3, result.mdm.parameters.size());  Assert.assertTrue(result.mdm.parameters.containsKey("param-string")); Assert.assertEquals("string-param", result.mdm.parameters.get("param-string")); Assert.assertTrue(result.mdm.parameters.containsKey("param-bool")); Assert.assertEquals(true, result.mdm.parameters.get("param-bool")); Assert.assertTrue(result.mdm.parameters.containsKey("param-int")); Assert.assertEquals(123, result.mdm.parameters.get("param-int")); }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock();  when(connector.fetchIdentity(eq("ERIC4911"))).thenCallRealMethod(); when(connector.doGet(eq("https://server.url/identity/ERIC4911"))) .thenReturn("{" + ""identity": "ERIC4911"," + ""publicKey": "aGVsbG8="," + ""featureLevel": 3," + ""featureMask": 15," + ""state": 1," + ""type": 2" + "}"); APIConnector.FetchIdentityResult result = connector.fetchIdentity("ERIC4911"); Assert."<AssertPlaceHolder>"; Assert.assertEquals("ERIC4911", result.identity); Assert.assertEquals(15, result.featureMask); Assert.assertEquals(1, result.state); Assert.assertEquals(2, result.type); }
fetchIdentity(String identity) throws ThreemaException, NetworkException, HttpConnectionException { try { String responseStr = doGet(getServerUrl() + "identity/" + identity); JSONObject jsonResponse = new JSONObject(responseStr);  FetchIdentityResult result = new FetchIdentityResult(); result.publicKey = Base64.decode(jsonResponse.getString("publicKey")); result.featureLevel = jsonResponse.optInt("featureLevel"); result.featureMask = jsonResponse.optInt("featureMask"); result.identity = jsonResponse.getString("identity"); result.state = jsonResponse.optInt("state"); result.type = jsonResponse.optInt("type"); return result; } catch (JSONException | IOException e) { throw new NetworkException(e); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { final APIConnector connector = getApiConnectorMock(); final IdentityStoreInterface identityStore = getIdentityStoreInterfaceMock();  when(identityStore.getIdentity()).thenReturn("FOOBAR12"); when(identityStore.calcSharedSecret(any())).thenReturn(new byte[32]); System.out.println(identityStore.getIdentity()); when(connector.obtainTurnServers(eq(identityStore), eq("voip"))).thenCallRealMethod(); when(connector.postJson(eq("https://server.url/identity/turn_cred"), ArgumentMatchers.any())) .thenReturn("{" + ""token": "/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="," + ""tokenRespKeyPub": "dummy"" + "}") .thenReturn("{" + ""success": true," + ""turnUrls": ["turn:foo", "turn:bar"]," + ""turnUrlsDualStack": ["turn:ds-foo", "turn:ds-bar"]," + ""turnUsername": "s00perturnuser"," + ""turnPassword": "t0psecret"," + ""expiration": 86400" + "}");  APIConnector.TurnServerInfo result = connector.obtainTurnServers(identityStore, "voip"); Assert."<AssertPlaceHolder>"; Assert.assertArrayEquals(new String[] {"turn:foo", "turn:bar"}, result.turnUrls); Assert.assertArrayEquals(new String[] {"turn:ds-foo", "turn:ds-bar"}, result.turnUrlsDualStack); Assert.assertEquals("s00perturnuser", result.turnUsername); Assert.assertEquals("t0psecret", result.turnPassword);  Date expectedExpirationDate = new Date(new Date().getTime() + 86400*1000); Assert.assertTrue(Math.abs(expectedExpirationDate.getTime() - result.expirationDate.getTime()) < 10000); }
obtainTurnServers(IdentityStoreInterface identityStore, String type) throws Exception { if (identityStore == null || identityStore.getIdentity() == null || identityStore.getIdentity().isEmpty()) { return null; }  String url = getServerUrl() + "identity/turn_cred";  // Phase 1: send identity and type JSONObject request = new JSONObject(); request.put("identity", identityStore.getIdentity()); request.put("type", type);  logger.debug("Obtain TURN servers phase 1: sending to server: {}", request); JSONObject p1Result = new JSONObject(this.postJson(url, request)); logger.debug("Obtain TURN servers phase 1: response from server: {}", p1Result);  makeTokenResponse(p1Result, request, identityStore);  // Phase 2: send token response logger.debug("Obtain TURN servers phase 2: sending to server: {}", request); JSONObject p2Result = new JSONObject(this.postJson(url, request)); logger.debug("Obtain TURN servers phase 2: response from server: {}", p2Result);  if (!p2Result.getBoolean("success")) { throw new ThreemaException(p2Result.getString("error")); }  String[] turnUrls = jsonArrayToStringArray(p2Result.getJSONArray("turnUrls")); String[] turnUrlsDualStack = jsonArrayToStringArray(p2Result.getJSONArray("turnUrlsDualStack")); String turnUsername = p2Result.getString("turnUsername"); String turnPassword = p2Result.getString("turnPassword"); int expiration = p2Result.getInt("expiration"); Date expirationDate = new Date(new Date().getTime() + expiration * 1000L);  return new TurnServerInfo(turnUrls, turnUrlsDualStack, turnUsername, turnPassword, expirationDate); }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{"org":{" + ""name": "monkeybusiness"" + "}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertEquals("monkeybusiness", result.organization.name);  }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertNull(result.organization.name);  }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); JSONObject requiredObject = new JSONObject(); requiredObject.put("username", "u").put("password", "eric") .put("contacts", (new JSONArray()).put("identity1").put("identity2"));  when(connector.fetchWorkData(any(), any(), any())).thenCallRealMethod(); when(connector.postJsonWithResult( eq("https://api-work.threema.ch/fetch2"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn(new PostJsonResult("{" + "directory:{" + "enabled: true," + "cat: {" + ""c1": "Category 1"," + ""c2": "Category 2"," + ""c3": "Category 3"" + "}}}", 0)); WorkData result = connector.fetchWorkData("u", "eric", new String[]{ "identity1", "identity2" }); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(result.organization); Assert.assertNull(result.organization.name); Assert.assertTrue(result.directory.enabled); Assert.assertNotNull(result.directory.categories); Assert.assertEquals(3, result.directory.categories.size());  boolean c1 = false; boolean c2 = false; boolean c3 = false;  for(WorkDirectoryCategory c: result.directory.categories) { switch (c.id) { case "c1": Assert.assertFalse("c1 already found", c1); c1 = true; Assert.assertEquals("Category 1", c.name); break; case "c2": Assert.assertFalse("c1 already found", c2); c2 = true; Assert.assertEquals("Category 2", c.name); break; case "c3": Assert.assertFalse("c1 already found", c3); c3 = true; Assert.assertEquals("Category 3", c.name); break; default: Assert.fail("Invalid category " + c.id); } } }
postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException { final URL url = new URL(urlStr);  final HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); if (urlConnection instanceof HttpsURLConnection) { ((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.sslSocketFactoryFactory.makeFactory(url.getHost())); } urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000); urlConnection.setRequestMethod("POST"); urlConnection.setRequestProperty("Content-Type", "application/json"); urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion()); if (this.language != null) { urlConnection.setRequestProperty("Accept-Language", this.language); } if (this.authenticator != null) { this.authenticator.addAuthenticationToConnection(urlConnection); } urlConnection.setDoOutput(true); urlConnection.setDoInput(true);  try { // Send request try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) { osw.write(body.toString()); }  // Read response body PostJsonResult result = new PostJsonResult(); try (InputStream inputStream = urlConnection.getInputStream()) { result.responseBody = IOUtils.toString(inputStream, StandardCharsets.UTF_8); } catch (IOException e) { result.responseCode = urlConnection.getResponseCode(); } return result; } finally { urlConnection.disconnect(); } }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: Exception { APIConnector connector = getApiConnectorMock(); final IdentityStoreInterface identityStore = getIdentityStoreInterfaceMock(); when(identityStore.getIdentity()).thenReturn("IDENTITY"); JSONObject requiredObject = new JSONObject(); requiredObject .put("username", "u") .put("password", "eric") .put("identity", "IDENTITY") .put("query", "Query String") .put("categories", (new JSONArray()).put("c100")) .put("sort", (new JSONObject()) .put("asc", true) .put("by", "firstName")) .put("page", 1);  when(connector.fetchWorkDirectory(any(), any(), any(), any())).thenCallRealMethod(); when(connector.postJson( eq("https://api-work.threema.ch/directory"), argThat(new ToStringEqualityArgumentMatcher<>(requiredObject)) )).thenReturn( "{\n" + "   "contacts": [\n" + "      {\n" + "         "id": "ECHOECHO",\n" + "         "pk": "base64",\n" + "         "first": "Hans",\n" + "         "last": "Nötig",\n" + "         "csi": "CSI_NR",\n" + "         "org": { "name": "Name der Firma/Organisation" },\n" + "         "cat": [\n" + "            "catId1",\n" + "            "catId2"\n" + "         ]\n" + "      }\n" + "   ],\n" + "   "paging": {\n" + "      "size": 10,\n" + "      "total": 8923,\n" + "      "next": 2,\n" + "      "prev": 0\n" + "   }\n" + "}" );  WorkDirectoryFilter filter = new WorkDirectoryFilter(); filter.addCategory(new WorkDirectoryCategory("c100", "Category 100")); filter.query("Query String"); filter.page(1); WorkDirectory result = connector.fetchWorkDirectory("u", "eric", identityStore, filter);  Assert."<AssertPlaceHolder>"; Assert.assertEquals(1, result.workContacts.size()); Assert.assertEquals("ECHOECHO", result.workContacts.get(0).threemaId); Assert.assertEquals("Hans", result.workContacts.get(0).firstName); Assert.assertEquals("Nötig", result.workContacts.get(0).lastName); Assert.assertEquals("CSI_NR", result.workContacts.get(0).csi); Assert.assertEquals("Name der Firma/Organisation", result.workContacts.get(0).organization.name); Assert.assertEquals(2, result.workContacts.get(0).categoryIds.size()); Assert.assertEquals("catId1", result.workContacts.get(0).categoryIds.get(0)); Assert.assertEquals("catId2", result.workContacts.get(0).categoryIds.get(1)); Assert.assertEquals(10, result.pageSize); Assert.assertEquals(8923, result.totalRecord); Assert.assertEquals(2, result.nextFilter.getPage()); Assert.assertEquals(filter.getQuery(), result.nextFilter.getQuery()); Assert.assertEquals(filter.getCategories(), result.nextFilter.getCategories()); Assert.assertEquals(0, result.previousFilter.getPage()); Assert.assertEquals(filter.getQuery(), result.previousFilter.getQuery()); Assert.assertEquals(filter.getCategories(), result.previousFilter.getCategories()); }
fetchWorkDirectory( @NonNull String username, @NonNull String password, @NonNull IdentityStoreInterface identityStore, @NonNull WorkDirectoryFilter filter ) throws Exception { JSONObject request = new JSONObject(); request.put("username", username); request.put("password", password); request.put("identity", identityStore.getIdentity()); request.put("query", filter.getQuery());  // Filter category if (filter.getCategories() != null && filter.getCategories().size() > 0) { JSONArray jsonCategories = new JSONArray(); for (WorkDirectoryCategory category: filter.getCategories()) { jsonCategories.put(category.id); } request.put("categories", jsonCategories); }  // Sorting JSONObject jsonSort = new JSONObject();  jsonSort.put("asc", filter.isSortAscending()); //noinspection SwitchStatementWithTooFewBranches switch (filter.getSortBy()) { case WorkDirectoryFilter.SORT_BY_LAST_NAME: jsonSort.put("by", "lastName"); break; default: jsonSort.put("by", "firstName"); break; }  request.put("sort", jsonSort);  // Paging request.put("page", filter.getPage());  String data = this.postJson(getWorkServerUrl() + "directory", request);  // Verify request if (data == null || data.length() == 0) { return null; }  JSONObject jsonResponse = new JSONObject(data);  if (jsonResponse.has("contacts") && !jsonResponse.isNull("contacts")) {  // Verify content JSONArray contacts = jsonResponse.getJSONArray("contacts");  int total = contacts.length(); int pageSize = total; WorkDirectoryFilter filterNext = null; WorkDirectoryFilter filterPrevious = null;  if (jsonResponse.has("paging") && !jsonResponse.isNull("paging")) { JSONObject paging = jsonResponse.getJSONObject("paging");  pageSize = paging.optInt("size", pageSize); total = paging.optInt("total", total); if (paging.has("next")) { // Next filter filterNext = filter.copy() .page(jsonResponse.optInt("next", filter.getPage() + 1)); } if (paging.has("prev")) { // Next filter filterPrevious = filter.copy() .page(jsonResponse.optInt("prev", filter.getPage() - 1)); } }  WorkDirectory workDirectory = new WorkDirectory( total, pageSize, filter, filterNext, filterPrevious );  for (int n = 0; n < contacts.length(); n++) { JSONObject contact = contacts.getJSONObject(n);  //validate fields if (contact.has("id") && contact.has("pk")) { WorkDirectoryContact directoryContact = new WorkDirectoryContact( contact.getString("id"), Base64.decode(contact.getString("pk")), contact.has("first") ? (contact.isNull("first") ? null : contact.optString("first")) : null, contact.has("last") ? (contact.isNull("last") ? null : contact.optString("last")) : null, contact.has("csi") ? (contact.isNull("csi") ? null : contact.optString("csi")) : null );  if (!contact.isNull("org")) { JSONObject jsonResponseOrganization = contact.optJSONObject("org");  if (jsonResponseOrganization != null && !jsonResponseOrganization.isNull("name")) { directoryContact.organization.name = jsonResponseOrganization.optString("name"); } }  JSONArray categoryArray = contact.optJSONArray("cat"); if (categoryArray != null) { for (int cN = 0; cN < categoryArray.length(); cN++) { directoryContact.categoryIds.add(categoryArray.getString(cN)); } }  workDirectory.workContacts.add(directoryContact); } }  return workDirectory; }  // Invalid request return null;  }
[*] target: assertNotNull(result)
[-] pred: org. junit. Assert. assertNotNull ( result )
************************************
************************************
[+] input: DecodingException { SMLReader smlReader = new SMLReader(); SMLSignature signature = smlReader.parsePayloadData(EncodingType.BASE64.decode(SML_DATA_FULL_NEW)); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(signature.getProvidedSignature()); Assert.assertEquals(2918, signature.getMeterPositionAsLong()); Assert.assertEquals("09 01 45 4D 48 00 00 7A C6 62", Utils.toFormattedHex(signature.getServerId())); Assert.assertEquals(65, new BigInteger(Utils.reverseByteOrder(signature.getPagination())).intValue()); Assert.assertEquals(340285, new BigInteger(Utils.reverseByteOrder(signature.getSecondsIndex())).intValue()); Assert.assertEquals(10, new BigInteger(signature.getBytesLog()).intValue()); Assert.assertEquals(8, new BigInteger(new byte[]{signature.getStatus()}).intValue());  LocalDateTime dateTime = LocalDateTime.of(2018, Month.AUGUST, 28, 18, 57, 37); OffsetDateTime offsetDateTime = OffsetDateTime.of(dateTime, ZoneOffset.of("+02:00")); Assert.assertEquals(offsetDateTime, signature.getTimestampAsDate());   }
parsePayloadData(byte[] smlData) throws ValidationException { try { final SMLSignature smlSignature = parseRawSMLBytes(smlData); if (smlSignature == null) { throw new SMLValidationException("Could not read sml data incomplete data", "error.sml.incomplete"); } // will throw an sml validation exception if check fails smlSignature.isDataComplete();  if (smlSignature.getUnit() != 30) { throw new SMLValidationException("Invalid unit present in sml data", "error.sml.invalid.unit"); } return smlSignature; } catch (final IOException e) { throw new SMLValidationException("Could not read sml data, invalid format", e); }  }
[*] target: assertNotNull(signature)
[-] pred: org. junit. Assert. assertNotNull ( signature )
************************************
************************************
[+] input: DecodingException { SMLReader smlReader = new SMLReader(); SMLSignature signature = smlReader.parsePayloadData(EncodingType.BASE64.decode(SML_DATA_TECHNAGON)); Assert."<AssertPlaceHolder>"; Assert.assertNotNull(signature.getProvidedSignature()); Assert.assertEquals(46201, signature.getMeterPositionAsLong()); Assert.assertEquals("09 01 45 4D 48 00 00 7F 92 03", Utils.toFormattedHex(signature.getServerId())); Assert.assertEquals(14, new BigInteger(Utils.reverseByteOrder(signature.getPagination())).intValue()); Assert.assertEquals(83696, new BigInteger(Utils.reverseByteOrder(signature.getSecondsIndex())).intValue()); Assert.assertEquals(59, new BigInteger(signature.getBytesLog()).intValue()); Assert.assertEquals(8, new BigInteger(new byte[]{signature.getStatus()}).intValue());  LocalDateTime dateTime = LocalDateTime.of(2017, Month.NOVEMBER, 23, 15, 13, 07); OffsetDateTime offsetDateTime = OffsetDateTime.of(dateTime, ZoneOffset.of("+00:00")); Assert.assertEquals(offsetDateTime, signature.getTimestampAsDate());   }
parsePayloadData(byte[] smlData) throws ValidationException { try { final SMLSignature smlSignature = parseRawSMLBytes(smlData); if (smlSignature == null) { throw new SMLValidationException("Could not read sml data incomplete data", "error.sml.incomplete"); } // will throw an sml validation exception if check fails smlSignature.isDataComplete();  if (smlSignature.getUnit() != 30) { throw new SMLValidationException("Invalid unit present in sml data", "error.sml.invalid.unit"); } return smlSignature; } catch (final IOException e) { throw new SMLValidationException("Could not read sml data, invalid format", e); }  }
[*] target: assertNotNull(signature)
[-] pred: org. junit. Assert. assertNotNull ( signature )
************************************
************************************
[+] input: ValidationException { URL url = this.getClass().getResource("/xml/test_mennekes_full.xml"); File testfile = new File(url.getFile()); String testData = TestUtils.readFile(testfile); XMLReader xmlReader = new XMLReader(); Billing billing = xmlReader.readFromString(testData);  Assert."<AssertPlaceHolder>"; Customer customer = billing.getCustomer();  Assert.assertNotNull(customer); Assert.assertEquals(11, customer.getCustomerId()); Assert.assertEquals("ptb ptb", customer.getName1()); Assert.assertEquals("Bundesallee 100", customer.getStreet()); Assert.assertEquals("Braunschweig", customer.getTown());   Supplier supplier = billing.getSupplier(); Assert.assertNotNull(supplier); Assert.assertEquals("57399", supplier.getZipCode()); Assert.assertEquals("MENNEKES Elektrotechnik GmbH & Co. KG", supplier.getName1()); Assert.assertEquals("Aloys-Mennekes-Straße 1", supplier.getStreet()); Assert.assertEquals("+49 27 23 / 41 - 1", supplier.getPhone()); Assert.assertEquals("+49 27 23 / 41 - 214", supplier.getFax()); Assert.assertEquals("Kirchhundem", supplier.getTown()); Assert.assertEquals("info@MENNEKES.de", supplier.getMailAddress()); Assert.assertEquals("test", supplier.getMailSubject()); Assert.assertEquals("test", supplier.getMailBody()); Assert.assertEquals("https://www.chargeupyourday.com/", supplier.getWebAddress()); Assert.assertEquals("https://www.chargeupyourday.com/", supplier.getWebAddressLinkText());   Assert.assertNotNull(billing.getBillingPeriods()); Assert.assertEquals(1, billing.getBillingPeriods().size()); BillingPeriod period = billing.getBillingPeriods().get(0);  Assert.assertEquals("RE2017-01", period.getBillingNo()); Assert.assertEquals("1.8.0", period.getObisCode());  Assert.assertEquals("Lieferung Strom", period.getTitle());  LocalDateTime dateTimePeriodStart = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 22, 14); OffsetDateTime periodStart = OffsetDateTime.of(dateTimePeriodStart, ZoneOffset.of("+02:00")); Assert.assertEquals(periodStart, period.getBegin());  LocalDateTime dateTimePeriodEnd = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 26, 45); OffsetDateTime periodEnd = OffsetDateTime.of(dateTimePeriodEnd, ZoneOffset.of("+02:00")); Assert.assertEquals(periodEnd, period.getEnd());  Assert.assertEquals(1, period.getChargingProcesses().size()); ChargingProcess chargingProcess = period.getChargingProcesses().get(0); Assert.assertEquals("0901454D4800005BAE2F", chargingProcess.getServerId()); Assert.assertEquals("6DACB9C5466A25B3EB9F6466B53457C84A27448B01A64A278C0A28DAC95F2B45DF39B79918A9A4D2E3551F3FE925D09D", chargingProcess.getPublicKey()); Assert.assertEquals("DE*PWC*E00003*005", chargingProcess.getMeteringPoint());  SiteAddress siteAddress = chargingProcess.getSiteAddress(); Assert.assertNotNull(siteAddress); Assert.assertEquals("38116", siteAddress.getZipCode()); Assert.assertEquals("Bundesallee 100", siteAddress.getStreet()); Assert.assertEquals("Braunschweig", siteAddress.getTown());  Assert.assertEquals("874AD0FE", chargingProcess.getCustomerIdent());  LocalDateTime dateTimeCustomerIdent = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 22, 10); OffsetDateTime customerIdentTime = OffsetDateTime.of(dateTimeCustomerIdent, ZoneOffset.of("+02:00")); Assert.assertEquals(customerIdentTime, chargingProcess.getTimestampCustomerIdent());  Measurement measurementStart = chargingProcess.getMeasurementStart(); Assert.assertNotNull(measurementStart);  LocalDateTime measurementStartDT = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 22, 10); OffsetDateTime measurementStartTime = OffsetDateTime.of(measurementStartDT, ZoneOffset.of("+02:00")); Assert.assertEquals(measurementStartTime, measurementStart.getTimestampCustomerIdent());  LocalDateTime measurementStartDTTs = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 22, 14); OffsetDateTime measurementStartTimeTs = OffsetDateTime.of(measurementStartDTTs, ZoneOffset.of("+02:00")); Assert.assertEquals(measurementStartTimeTs, measurementStart.getTimestamp());  Assert.assertEquals("55CB60BB5E8AC580516F6A3DA5D6BB0365FD9DC04D50BE53B79FD95A2A92D749C36839B0A507E63A48E0A956A6FEFDB5", measurementStart.getSignature()); Assert.assertEquals(new Long(8), measurementStart.getEventCounter()); Assert.assertEquals(new Integer(65800), measurementStart.getMeterStatus()); Assert.assertEquals(new Long(519116), measurementStart.getValue()); Assert.assertEquals(-1, measurementStart.getScaler()); Assert.assertEquals(25, measurementStart.getPagination()); Assert.assertEquals(74650, measurementStart.getSecondIndex());   Measurement measurementEnd = chargingProcess.getMeasurementEnd(); Assert.assertNotNull(measurementEnd);  Assert.assertNull(measurementEnd.getTimestampCustomerIdent());  LocalDateTime measurementEndDTTs = LocalDateTime.of(2018, Month.SEPTEMBER, 4, 12, 26, 45); OffsetDateTime measurementEndTimeTs = OffsetDateTime.of(measurementEndDTTs, ZoneOffset.of("+02:00")); Assert.assertEquals(measurementEndTimeTs, measurementEnd.getTimestamp());  Assert.assertEquals("6574B62680B76639C2EF03CDEA34CCAC5633F3C7E08E5C251463F0DFED38B35A9675126DDA8F4B0CAB017B1A42C5EBDC", measurementEnd.getSignature()); Assert.assertEquals(new Long(8), measurementEnd.getEventCounter()); Assert.assertEquals(new Integer(65800), measurementEnd.getMeterStatus()); Assert.assertEquals(new Long(520535), measurementEnd.getValue()); Assert.assertEquals(-1, measurementEnd.getScaler()); Assert.assertEquals(26, measurementEnd.getPagination()); Assert.assertEquals(74921, measurementEnd.getSecondIndex());   }
readFromString(String xml) throws ValidationException { final StringReader reader = new StringReader(enforceXMLStartingString(xml)); try { return (Billing) unmarshaller.unmarshal(reader); } catch (final JAXBException e) { LOGGER.error("JAXB error on loading mennekes file", e); throw new ValidationException("Could not read mennekes xml data"); } }
[*] target: assertNotNull(billing)
[-] pred: org. junit. Assert. assertNotNull ( billing )
************************************
************************************
[+] input: checkOutgoingAccess() { FlowElement exclusiveGateway= EntityBuilder.buildExclusiveGateway(); FlowElement outgoningSequence = EntityBuilder.buildSequenceFlow2(); FlowElement outgoningSequence1 = EntityBuilder.buildSequenceFlow3(); Map<String, FlowElement> map = new HashMap<>(); map.put(exclusiveGateway.getKey(), exclusiveGateway); map.put(outgoningSequence.getKey(), outgoningSequence); map.put(outgoningSequence1.getKey(), outgoningSequence1); boolean access = false; try { exclusiveGatewayValidator.checkOutgoing(map, exclusiveGateway); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { List<String> outgoing = flowElement.getOutgoing();  if (CollectionUtils.isEmpty(outgoing)) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_LACK_OUTGOING); }  List<String> outgoingList = flowElement.getOutgoing(); int defaultConditionCount = 0;  for (String outgoingKey : outgoingList) { FlowElement outgoingSequenceFlow = FlowModelUtil.getFlowElement(flowElementMap, outgoingKey);  String condition = FlowModelUtil.getConditionFromSequenceFlow(outgoingSequenceFlow); boolean isDefaultCondition = FlowModelUtil.isDefaultCondition(outgoingSequenceFlow);  if (StringUtils.isBlank(condition) && !isDefaultCondition) { throwElementValidatorException(flowElement, ErrorEnum.EMPTY_SEQUENCE_OUTGOING); } if (isDefaultCondition) { defaultConditionCount++; } }  if (defaultConditionCount > 1) { throwElementValidatorException(flowElement, ErrorEnum.TOO_MANY_DEFAULT_SEQUENCE); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: checkEmptyOutgoing() { FlowElement exclusiveGateway= EntityBuilder.buildExclusiveGateway(); FlowElement outgoningSequence = EntityBuilder.buildSequenceFlow2(); Map<String, Object> properties = new HashMap<>(); properties.put("defaultConditions", "false"); properties.put("conditionsequenceflow", ""); outgoningSequence.setProperties(properties); FlowElement outgoningSequence1 = EntityBuilder.buildSequenceFlow3(); Map<String, FlowElement> map = new HashMap<>(); map.put(exclusiveGateway.getKey(), exclusiveGateway); map.put(outgoningSequence.getKey(), outgoningSequence); map.put(outgoningSequence1.getKey(), outgoningSequence1); boolean access = false; try { exclusiveGatewayValidator.checkOutgoing(map, exclusiveGateway); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { List<String> outgoing = flowElement.getOutgoing();  if (CollectionUtils.isEmpty(outgoing)) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_LACK_OUTGOING); }  List<String> outgoingList = flowElement.getOutgoing(); int defaultConditionCount = 0;  for (String outgoingKey : outgoingList) { FlowElement outgoingSequenceFlow = FlowModelUtil.getFlowElement(flowElementMap, outgoingKey);  String condition = FlowModelUtil.getConditionFromSequenceFlow(outgoingSequenceFlow); boolean isDefaultCondition = FlowModelUtil.isDefaultCondition(outgoingSequenceFlow);  if (StringUtils.isBlank(condition) && !isDefaultCondition) { throwElementValidatorException(flowElement, ErrorEnum.EMPTY_SEQUENCE_OUTGOING); } if (isDefaultCondition) { defaultConditionCount++; } }  if (defaultConditionCount > 1) { throwElementValidatorException(flowElement, ErrorEnum.TOO_MANY_DEFAULT_SEQUENCE); } }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: checkTooManySequenceOutgoig() { FlowElement exclusiveGateway= EntityBuilder.buildExclusiveGateway(); FlowElement outgoningSequence = EntityBuilder.buildSequenceFlow2(); Map<String, Object> properties = new HashMap<>(); properties.put("defaultConditions", "true"); properties.put("conditionsequenceflow", ""); outgoningSequence.setProperties(properties); FlowElement outgoningSequence1 = EntityBuilder.buildSequenceFlow3(); Map<String, Object> properties1 = new HashMap<>(); properties.put("defaultConditions", "true"); properties.put("conditionsequenceflow", ""); outgoningSequence1.setProperties(properties); Map<String, FlowElement> map = new HashMap<>(); map.put(exclusiveGateway.getKey(), exclusiveGateway); map.put(outgoningSequence.getKey(), outgoningSequence); map.put(outgoningSequence1.getKey(), outgoningSequence1); boolean access = false; try { exclusiveGatewayValidator.checkOutgoing(map, exclusiveGateway); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { List<String> outgoing = flowElement.getOutgoing();  if (CollectionUtils.isEmpty(outgoing)) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_LACK_OUTGOING); }  List<String> outgoingList = flowElement.getOutgoing(); int defaultConditionCount = 0;  for (String outgoingKey : outgoingList) { FlowElement outgoingSequenceFlow = FlowModelUtil.getFlowElement(flowElementMap, outgoingKey);  String condition = FlowModelUtil.getConditionFromSequenceFlow(outgoingSequenceFlow); boolean isDefaultCondition = FlowModelUtil.isDefaultCondition(outgoingSequenceFlow);  if (StringUtils.isBlank(condition) && !isDefaultCondition) { throwElementValidatorException(flowElement, ErrorEnum.EMPTY_SEQUENCE_OUTGOING); } if (isDefaultCondition) { defaultConditionCount++; } }  if (defaultConditionCount > 1) { throwElementValidatorException(flowElement, ErrorEnum.TOO_MANY_DEFAULT_SEQUENCE); } }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: validateElementKeyNotUnique() { List<FlowElement> flowElementsList = EntityBuilder.buildFlowElementList(); SequenceFlow sequenceFlow1 = new SequenceFlow(); sequenceFlow1.setKey("sequenceFlow1"); sequenceFlow1.setType(FlowElementType.SEQUENCE_FLOW); List<String> sfIncomings = new ArrayList<>(); sfIncomings.add("startEvent1"); sequenceFlow1.setIncoming(sfIncomings); List<String> sfOutgoings = new ArrayList<>(); sfOutgoings.add("userTask1"); sequenceFlow1.setOutgoing(sfOutgoings); flowElementsList.add(sequenceFlow1); FlowModel flowModel = new FlowModel(); flowModel.setFlowElementList(flowElementsList); boolean access = false; try { flowModelValidator.validate(flowModel); access = true; Assert."<AssertPlaceHolder>"; } catch (ProcessException e) { LOGGER.error("", e); Assert.assertFalse(access); } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
validate(FlowModel flowModel) throws ProcessException, DefinitionException { this.validate(flowModel, null); }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: validateStartEventNotOne() { List<FlowElement> flowElementsList = EntityBuilder.buildFlowElementList();  StartEvent startEvent = new StartEvent(); startEvent.setKey("startEvent2"); startEvent.setType(FlowElementType.START_EVENT); List<String> seOutgoings = new ArrayList<>(); seOutgoings.add("sequenceFlow1"); startEvent.setOutgoing(seOutgoings); flowElementsList.add(startEvent); FlowModel flowModel = new FlowModel(); flowModel.setFlowElementList(flowElementsList); boolean access = false; try { flowModelValidator.validate(flowModel); access = true; Assert."<AssertPlaceHolder>"; } catch (ProcessException e) { LOGGER.error("", e); Assert.assertFalse(access); } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
validate(FlowModel flowModel) throws ProcessException, DefinitionException { this.validate(flowModel, null); }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: validateAccess() { String modelStr = EntityBuilder.buildModelStringAccess(); boolean access = false; try { modelValidator.validate(modelStr); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } catch (ProcessException e) { LOGGER.error("", e); Assert.assertTrue(access); }   }
validate(String flowModelStr) throws DefinitionException, ProcessException { this.validate(flowModelStr, null); }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: validateEmptyModel() { String modelStr = null; boolean access = false; try { modelValidator.validate(modelStr); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } catch (ProcessException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
validate(String flowModelStr) throws DefinitionException, ProcessException { this.validate(flowModelStr, null); }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: checkIncomingAccess() { FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkIncoming(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkIncoming(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkIncoming(flowElementMap, flowElement);  List<String> incomingList = flowElement.getIncoming(); if (incomingList.size() >1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_INCOMING); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: checkTooMuchIncoming() { FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); List<String> sfIncomings = new ArrayList<>(); sfIncomings.add("userTask2"); sfIncomings.add("userTask1"); sequenceFlow.setIncoming(sfIncomings); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkIncoming(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
checkIncoming(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkIncoming(flowElementMap, flowElement);  List<String> incomingList = flowElement.getIncoming(); if (incomingList.size() >1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_INCOMING); } }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: checkOutgoingAccess() {  FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkOutgoing(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertTrue(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkOutgoing(flowElementMap, flowElement);  List<String> outgoingList = flowElement.getOutgoing(); if (outgoingList.size() > 1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_OUTGOING); } }
[*] target: assertTrue(access)
[-] pred: org. junit. Assert. assertTrue ( access )
************************************
************************************
[+] input: checkWithoutOutgoing() {  FlowElement sequenceFlow = EntityBuilder.buildSequenceFlow(); sequenceFlow.setOutgoing(null); Map<String, FlowElement> flowElementMap = new HashMap<>(); flowElementMap.put(sequenceFlow.getKey(), sequenceFlow); boolean access = false; try { sequenceFlowValidator.checkOutgoing(flowElementMap, sequenceFlow); access = true; Assert."<AssertPlaceHolder>"; } catch (DefinitionException e) { LOGGER.error("", e); Assert.assertFalse(access); } }
checkOutgoing(Map<String, FlowElement> flowElementMap, FlowElement flowElement) throws DefinitionException { super.checkOutgoing(flowElementMap, flowElement);  List<String> outgoingList = flowElement.getOutgoing(); if (outgoingList.size() > 1) { throwElementValidatorException(flowElement, ErrorEnum.ELEMENT_TOO_MUCH_OUTGOING); } }
[*] target: assertFalse(access)
[-] pred: org. junit. Assert. assertFalse ( access )
************************************
************************************
[+] input: regexPreprocessorTest() { RegexPreprocessor rpp = new RegexPreprocessor("^.*(fakebook\\.com.*)/$", "$1"); String test = "https://www.fakebook.com/personOne/"; String res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "www.fakebook.com/personOne/"; res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "fakebook.com/personOne/"; res = "fakebook.com/personOne"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "personOne/"; res = "personOne/"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = "insertedWithoutAppliedRegex"; res = "insertedWithoutAppliedRegex"; Assert.assertEquals(res, rpp.applyProcessor(test));  test = ""; res = ""; Assert."<AssertPlaceHolder>"; }
applyProcessor(String value) { return value.replaceAll(match, replace); }
[*] target: assertEquals(res, rpp.applyProcessor(test))
[-] pred: org. junit. Assert. assertEquals ( res, rpp. applyProcessor( test ) )
************************************
************************************
[+] input: testDifference() { VariableSet diffAB = VariableSet.difference(fA, fB);  // everything in the difference must be in A assertTrue(fA.containsAll(diffAB));  // nothing in B might be in the difference for (String name : fB.getNames()) { for (Type type : fB.getTypes(name)) { assertFalse(diffAB.contains(name, type)); } }  VariableSet diffBA = VariableSet.difference(fB, fA);  // everything in the difference must be in B assertTrue(fB.containsAll(diffBA));  // nothing in A might be in the difference for (String name : fA.getNames()) { for (Type type : fA.getTypes(name)) { "<AssertPlaceHolder>"; } } }
contains(String name, Type type) { return fEntries.containsKey(name) && fEntries.get(name).contains(type); }
[*] target: assertFalse(diffBA.contains(name, type))
[-] pred: org. junit. Assert. assertFalse ( diffBA. contains ( name, type ) )
************************************
************************************
[+] input: testPolymorphicDifference2() { VariableSet pDiff2 = VariableSet.polymorphicDifference2(fA, fB);  // everything in pDiff2 must be in A assertTrue(fA.containsAll(pDiff2));  // the normal difference is a subset of the second polymorphic difference // (it removes everything a normal difference would + possibly some more) // we want to take a look everything that gets only removed by the // second polymorphic difference  VariableSet diff = VariableSet.difference(fA, fB); VariableSet pDiffExcl = VariableSet.difference(diff, pDiff2);  // for each element in pDiffExcl the following must hold: // - element of A // - not element of B // - B has a variable with that name // - one of its types must be a subtype of the current elements type for (String name : pDiffExcl.getNames()) { for (Type type : pDiffExcl.getTypes(name)) { assertTrue(fA.contains(name, type)); assertFalse(fB.contains(name, type)); assertTrue(fB.contains(name)); boolean containsSubType = false; for (Type otherType : fB.getTypes(name)) { if (otherType.conformsTo(type)) { containsSubType = true; break; } } "<AssertPlaceHolder>"; } } }
getTypes(String name) { return fEntries.get(name); }
[*] target: assertTrue(containsSubType)
[-] pred: org. junit. Assert. assertTrue ( containsSubType )
************************************
************************************
[+] input: testECKey() { ECKey key = new ECKey(); assertTrue(key.isPubKeyCanonical()); "<AssertPlaceHolder>"; assertNotNull(key.getPrivKeyBytes()); logger.info(Hex.toHexString(key.getPrivKeyBytes()) + " :Generated privkey"); logger.info(Hex.toHexString(key.getPubKey()) + " :Generated pubkey"); }
getPubKey() { return pub.getEncoded(/* compressed */ false); }
[*] target: assertNotNull(key.getPubKey())
[-] pred: org. junit. Assert. assertNotNull ( key. getPubKey() )
************************************
************************************
[+] input: Exception { byte[] bytes = new byte[64]; bytes[0] = 15; Node nearNode = new Node(bytes, "127.0.0.19", 18888, 18888); bytes[0] = 70; Node farNode = new Node(bytes, "127.0.0.20", 18888, 18888); nodeTable.addNode(nearNode); nodeTable.addNode(farNode); for (int i = 0; i < KademliaOptions.BUCKET_SIZE - 1; i++) { //To control totally 17 nodes, however closest's capacity is 16 nodeTable.addNode(new Node(ids.get(i), ips[i], 18888, 18888)); TimeUnit.MILLISECONDS.sleep(10); } Assert.assertTrue(nodeTable.getBucketsCount() > 1); //3 buckets, nearnode's distance is 252, far's is 255, others' are 253 List<Node> closest = nodeTable.getClosestNodes(homeNode.getId()); Assert."<AssertPlaceHolder>"; //the farest node should be excluded }
contains(Node n) { NodeEntry e = new NodeEntry(node.getId(), n); for (NodeBucket b : buckets) { if (b.getNodes().contains(e)) { return true; } } return false; }
[*] target: assertTrue(closest.contains(nearNode))
[-] pred: org. junit. Assert. assertTrue ( closest. contains ( nearNode ) )
************************************
************************************
[+] input: pushBlockInvalidMerkelRoot() { Transaction trx = Transaction.newBuilder().build(); TransactionCapsule moreTrans = new TransactionCapsule(trx); blockCapsule2.addTransaction(moreTrans);  // add one more transaction will change merkroot blockCapsule2.sign(ByteArray.fromHexString(Args.getLocalWitnesses() .getPrivateKey())); try { dbManager.pushBlock(blockCapsule2); Assert."<AssertPlaceHolder>"; } catch (BadBlockException e) { Assert.assertTrue(e instanceof BadBlockException); Assert.assertEquals("The merkle hash is not validated", e.getMessage()); } catch (Exception e) { Assert.assertFalse(e instanceof Exception); } }
pushBlock(final BlockCapsule block) throws ValidateSignatureException, ContractValidateException, ContractExeException, UnLinkedBlockException, ValidateScheduleException, AccountResourceInsufficientException, TaposException, TooBigTransactionException, TooBigTransactionResultException, DupTransactionException, TransactionExpirationException, BadNumberBlockException, BadBlockException, NonCommonBlockException, ReceiptCheckErrException, VMIllegalException, ZksnarkException, P2pVersionException, EventBloomException { long start = System.currentTimeMillis(); try (PendingManager pm = new PendingManager(this)) {  if (!block.generatedByMyself) { if (!block.validateSignature(chainBaseManager.getDynamicPropertiesStore(), chainBaseManager.getAccountStore())) { logger.warn("The signature is not validated."); throw new BadBlockException("The signature is not validated"); }  if (!block.calcMerkleRoot().equals(block.getMerkleRoot())) { logger.warn( "The merkle root doesn't match, Calc result is " + block.calcMerkleRoot() + " , the headers is " + block.getMerkleRoot()); throw new BadBlockException("The merkle hash is not validated"); }  consensus.receiveBlock(block); }  if (block.getTransactions().stream().filter(tran -> isShieldedTransaction(tran.getInstance())) .count() > SHIELDED_TRANS_IN_BLOCK_COUNTS) { throw new BadBlockException( "shielded transaction count > " + SHIELDED_TRANS_IN_BLOCK_COUNTS); }  BlockCapsule newBlock; try { newBlock = this.khaosDb.push(block); } catch (UnLinkedBlockException e) { logger.error( "latestBlockHeaderHash:{}, latestBlockHeaderNumber:{}, latestSolidifiedBlockNum:{}", getDynamicPropertiesStore().getLatestBlockHeaderHash(), getDynamicPropertiesStore().getLatestBlockHeaderNumber(), getDynamicPropertiesStore().getLatestSolidifiedBlockNum()); throw e; }  // DB don't need lower block if (getDynamicPropertiesStore().getLatestBlockHeaderHash() == null) { if (newBlock.getNum() != 0) { return; } } else { if (newBlock.getNum() <= getDynamicPropertiesStore().getLatestBlockHeaderNumber()) { return; }  // switch fork if (!newBlock .getParentHash() .equals(getDynamicPropertiesStore().getLatestBlockHeaderHash())) { logger.warn( "switch fork! new head num = {}, block id = {}", newBlock.getNum(), newBlock.getBlockId());  logger.warn( "******** before switchFork ******* push block: " + block.toString() + ", new block:" + newBlock.toString() + ", dynamic head num: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderNumber() + ", dynamic head hash: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderHash() + ", dynamic head timestamp: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderTimestamp() + ", khaosDb head: " + khaosDb.getHead() + ", khaosDb miniStore size: " + khaosDb.getMiniStore().size() + ", khaosDb unlinkMiniStore size: " + khaosDb.getMiniUnlinkedStore().size());  switchFork(newBlock); logger.info(SAVE_BLOCK + newBlock);  logger.warn( "******** after switchFork ******* push block: " + block.toString() + ", new block:" + newBlock.toString() + ", dynamic head num: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderNumber() + ", dynamic head hash: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderHash() + ", dynamic head timestamp: " + chainBaseManager.getDynamicPropertiesStore().getLatestBlockHeaderTimestamp() + ", khaosDb head: " + khaosDb.getHead() + ", khaosDb miniStore size: " + khaosDb.getMiniStore().size() + ", khaosDb unlinkMiniStore size: " + khaosDb.getMiniUnlinkedStore().size());  return; } try (ISession tmpSession = revokingStore.buildSession()) {  applyBlock(newBlock); tmpSession.commit(); // if event subscribe is enabled, post solidity trigger to queue postSolidityTrigger(getDynamicPropertiesStore().getLatestSolidifiedBlockNum()); // if event subscribe is enabled, post block trigger to queue postBlockTrigger(newBlock); } catch (Throwable throwable) { logger.error(throwable.getMessage(), throwable); khaosDb.removeBlk(block.getBlockId()); throw throwable; } } logger.info(SAVE_BLOCK + newBlock); } //clear ownerAddressSet if (CollectionUtils.isNotEmpty(ownerAddressSet)) { Set<String> result = new HashSet<>(); for (TransactionCapsule transactionCapsule : rePushTransactions) { filterOwnerAddress(transactionCapsule, result); } for (TransactionCapsule transactionCapsule : pushTransactionQueue) { filterOwnerAddress(transactionCapsule, result); } ownerAddressSet.clear(); ownerAddressSet.addAll(result); }  MetricsUtil.meterMark(MetricsKey.BLOCKCHAIN_BLOCK_PROCESS_TIME, System.currentTimeMillis() - start);  logger.info("pushBlock block number:{}, cost/txs:{}/{}", block.getNum(), System.currentTimeMillis() - start, block.getTransactions().size()); }
[*] target: assertTrue(false)
[-] pred: org. junit. Assert. assertTrue ( false )
************************************
************************************
[+] input: testCall() { try (Store<Void> store = Store.withoutData(); Engine engine = store.engine(); Module module = new Module(engine, WAT_BYTES_ADD); Instance instance = new Instance(store, module, Collections.emptyList())) { try (Func func = instance.getFunc(store, "add").get()) { Val[] results = func.call(store, Val.fromI32(1), Val.fromI32(2)); "<AssertPlaceHolder>"; assertEquals(Val.fromI32(3), results[0]); } } }
call(Caller<T> caller, Val[] params, Val[] results); }  private static final Val[] EMPTY_VALS = new Val[0]; static final FuncRegistry registry = new FuncRegistry();  @Getter(AccessLevel.PACKAGE) private final long innerPtr;  public <T> Func(Store<T> store, FuncType fnType, Handler<T> func) { this(create(store, fnType, func)); }
[*] target: assertEquals(1, results.length)
[-] pred: org. junit. Assert. assertEquals ( 1, results. length )
************************************
************************************
[+] input: JSONException { OpenWeatherMapSource source = new OpenWeatherMapSource(context); Location location = new SimpleLocation("lat=54.96&lon=73.38", true); JSONObject json = source.queryCurrentWeather(location); "<AssertPlaceHolder>"; assertEquals("Omsk", json.getString("name")); }
queryCurrentWeather(Location location) throws WeatherException { String url = getWeatherUrl(location); return queryJSON(url); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: JSONException { OpenWeatherMapSource source = new OpenWeatherMapSource(context); Location location = new SimpleLocation("q=omsk", false); JSONObject json = source.queryCurrentWeather(location); "<AssertPlaceHolder>"; assertEquals("Omsk", json.getString("name")); }
queryCurrentWeather(Location location) throws WeatherException { String url = getWeatherUrl(location); return queryJSON(url); }
[*] target: assertNotNull(json)
[-] pred: org. junit. Assert. assertNotNull ( json )
************************************
************************************
[+] input: WeatherException { WeatherSource source = new OpenWeatherMapSource(context); Location location = new NameOpenWeatherMapLocation("55.0,73.4"); Weather weather = source.query(location); "<AssertPlaceHolder>"; assertTrue(weather instanceof OpenWeatherMapWeather); assertFalse(weather.isEmpty()); assertEquals("Omsk", weather.getLocation().getText()); assertEquals(8, weather.getConditions().size()); }
query(Location location) throws WeatherException { if (location == null) { throw new WeatherException("null location"); }  if (!location.isGeo()) {    // if the location contains geo coordinates, skipping this test hack try { if (location.getText().startsWith("-")) { return new TestWeather(Integer.parseInt(location.getText())); } if (location.getText().startsWith("+")) { return new TestWeather(Integer.parseInt(location.getText().substring(1))); } } catch (NumberFormatException nfe) { // ignore and continue } }  OpenWeatherMapWeather weather = new OpenWeatherMapWeather(this.context);  weather.parseCurrentWeather(queryCurrentWeather(location)); if (weather.isEmpty()) { return weather; } if (weather.getLocation().isGeo()) {    // extracts geo coord from the weather and do onecall with lat/lon weather.parseOneCallResult(queryOneCallForecast(weather.getLocation())); } return weather; }
[*] target: assertNotNull(weather)
[-] pred: org. junit. Assert. assertNotNull ( weather )
************************************
************************************
[+] input: WeatherException { WeatherSource source = new OpenWeatherMapSource(context); Location location = new NameOpenWeatherMapLocation("-34.8,-56.3"); Weather weather = source.query(location); "<AssertPlaceHolder>"; assertTrue(weather instanceof OpenWeatherMapWeather); assertFalse(weather.isEmpty()); assertEquals("Pajas Blancas", weather.getLocation().getText()); assertEquals(8, weather.getConditions().size()); }
query(Location location) throws WeatherException { if (location == null) { throw new WeatherException("null location"); }  if (!location.isGeo()) {    // if the location contains geo coordinates, skipping this test hack try { if (location.getText().startsWith("-")) { return new TestWeather(Integer.parseInt(location.getText())); } if (location.getText().startsWith("+")) { return new TestWeather(Integer.parseInt(location.getText().substring(1))); } } catch (NumberFormatException nfe) { // ignore and continue } }  OpenWeatherMapWeather weather = new OpenWeatherMapWeather(this.context);  weather.parseCurrentWeather(queryCurrentWeather(location)); if (weather.isEmpty()) { return weather; } if (weather.getLocation().isGeo()) {    // extracts geo coord from the weather and do onecall with lat/lon weather.parseOneCallResult(queryOneCallForecast(weather.getLocation())); } return weather; }
[*] target: assertNotNull(weather)
[-] pred: org. junit. Assert. assertNotNull ( weather )
************************************
************************************
[+] input: WeatherException { JSONTokener parser = new JSONTokener("{ "cod": "404"}"); OpenWeatherMapWeather weather = new OpenWeatherMapWeather(context, (JSONObject)parser.nextValue()); //        assertNotNull(weather); //        "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertTrue(weather.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( weather. isEmpty() )
************************************
************************************
[+] input: testNotNullLocation() { OpenWeatherMapWeather weather = new OpenWeatherMapWeather(context); assertNotNull(weather.getLocation()); "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertTrue(weather.isEmpty())
[-] pred: org. junit. Assert. assertTrue ( weather. isEmpty() )
************************************
************************************
[+] input: Exception { OpenWeatherMapWeather weather = WeatherUtils.createIncompleteOpenWeather(context); assertNotNull(weather); "<AssertPlaceHolder>"; }
isEmpty() { return this.empty; }
[*] target: assertFalse(weather.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( weather. isEmpty() )
************************************
************************************
[+] input: Exception { OpenWeatherMapWeather weather = WeatherUtils.createIncompleteOpenWeather(context); Location location = weather.getLocation(); assertNotNull(location); "<AssertPlaceHolder>"; assertEquals("Omsk", location.getText()); // geo coordinates are taken from the response assertTrue(location.isGeo()); assertEquals("lat=55.0&lon=73.4", location.getQuery()); }
isEmpty() { return this.empty; }
[*] target: assertFalse(location.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( location. isEmpty() )
************************************
************************************
[+] input: Exception { TestBundle testBundle = new TestBundle(); Image image; try { testBundle.setFile("icons/test.png", TestUtils.createImagePNG(1, 1)); testBundle.install(); // work with Bundle { BundleResourceProvider provider = BundleResourceProvider.get(testBundle.getId()); // get Image image = provider.getImage("icons/test.png"); "<AssertPlaceHolder>"; assertFalse(image.isDisposed()); } } finally { testBundle.dispose(); } // wait for events waitEventLoop(0); // Bundle uninstalled, so Image is now disposed assertTrue(image.isDisposed()); }
getImage(String path) { path = normalizePath(path); Image image = m_pathToImage.get(path); if (image == null) { ImageDescriptor imageDescriptor = getImageDescriptor(path); image = imageDescriptor.createImage(); m_pathToImage.put(path, image); } return image; }
[*] target: assertNotNull(image)
[-] pred: org. junit. Assert. assertNotNull ( image )
************************************
************************************
[+] input: Exception { assertTrue(EnvironmentUtils.isTestingTime()); { // switch development time EnvironmentUtils.setTestingTime(false); try { assertFalse(EnvironmentUtils.isTestingTime()); } finally { EnvironmentUtils.setTestingTime(true); } } "<AssertPlaceHolder>"; }
isTestingTime() { return "true".equals(System.getProperty(WBP_TESTING_TIME)); }
[*] target: assertTrue(EnvironmentUtils.isTestingTime())
[-] pred: org. junit. Assert. assertTrue ( EnvironmentUtils. isTestingTime ( ) )
************************************
************************************
[+] input: Exception { ObjectInfo parent = new TestObjectInfo("parent"); ObjectInfo child = new TestObjectInfo("child"); // "child" never was in "parent", so is not deleted assertFalse(child.isDeleted()); // build hierarchy parent.addChild(child); // "child" is in "parent", so again is not deleted assertFalse(child.isDeleted()); // delete parent.removeChild(child); "<AssertPlaceHolder>"; }
isDeleted() { return m_parent != null && !m_parent.m_children.contains(this); }
[*] target: assertTrue(child.isDeleted())
[-] pred: org. junit. Assert. assertTrue ( child. isDeleted() )
************************************
************************************
[+] input: Exception { final AtomicInteger saveCount = new AtomicInteger(); final ObjectInfo object = new TestObjectInfo() { @Override protected void saveEdit() throws Exception { saveCount.getAndIncrement(); } }; // final AtomicBoolean wasFired = new AtomicBoolean(); object.addBroadcastListener(new ObjectEventListener() { @Override public void endEdit_aboutToRefresh() throws Exception { wasFired.set(true); // perform inner edit operation object.startEdit(); try { } finally { object.endEdit(); } } }); // do edit operation object.startEdit(); try { } finally { object.endEdit(); } // verify, only one saveEdit() should be done "<AssertPlaceHolder>"; assertEquals(1, saveCount.get()); }
saveEdit() throws Exception { }
[*] target: assertTrue(wasFired.get())
[-] pred: org. junit. Assert. assertTrue ( wasFired. get ( ) )
************************************
************************************
[+] input: Exception { configureProject(); ContainerInfo panel = parseContainer( "public class Test extends JPanel {", "  public Test() {", "    JButton button = new JButton();", "    MyPanel myPanel = new MyPanel(button, true);", "    add(myPanel);", "  }", "}"); ContainerInfo myPanel = (ContainerInfo) panel.getChildrenComponents().get(0); ComponentInfo button = myPanel.getChildrenComponents().get(0); // do delete "<AssertPlaceHolder>"; button.delete(); // check source assertEditor( "public class Test extends JPanel {", "  public Test() {", "    MyPanel myPanel = new MyPanel(true);", "    add(myPanel);", "  }", "}"); // check constructor properties for "myPanel" { Property constructorProperty = myPanel.getPropertyByTitle("Constructor"); GenericProperty valueProperty = (GenericProperty) getPropertyByTitle(getSubProperties(constructorProperty), "value"); // check accessors { List<ExpressionAccessor> accessors = getGenericPropertyAccessors(valueProperty); assertEquals(1, accessors.size()); assertInstanceOf(ConstructorAccessor.class, accessors.get(0)); } // check value assertSame(Boolean.TRUE, valueProperty.getValue()); // set new value valueProperty.setValue(Boolean.FALSE); assertEditor( "public class Test extends JPanel {", "  public Test() {", "    MyPanel myPanel = new MyPanel(false);", "    add(myPanel);", "  }", "}"); } }
canDelete() { // no need for check if we going to delete parent if (m_javaInfo.getParentJava().isDeleting()) { return true; } // prepare new binding - without this JavaInfo arguments DesignerMethodBinding newBinding; { ConstructorCreationSupport creationSupport = getConstructorCreationSupport(); newBinding = m_editor.getBindingContext().get(creationSupport.getBinding()); List<Expression> arguments = DomGenerics.arguments(getCreation()); for (int i = arguments.size() - 1; i >= 0; i--) { Expression argument = arguments.get(i); if (m_javaInfo.isRepresentedBy(argument)) { newBinding.removeParameterType(i); } } } // we can delete association only if there is alternative constructor, without child return m_javaInfo.getParentJava().getDescription().getConstructor(newBinding) != null; }
[*] target: assertTrue(button.canDelete())
[-] pred: org. junit. Assert. assertTrue ( button. canDelete ( ) )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); RootAssociation association = (RootAssociation) panel.getAssociation(); assertSame(panel, association.getJavaInfo()); assertTrue(association.canDelete()); // try to remove() "<AssertPlaceHolder>"; assertSame(association, panel.getAssociation()); }
remove() throws Exception { return false; }
[*] target: assertFalse(association.remove())
[-] pred: org. junit. Assert. assertFalse ( association. remove ( ) )
************************************
************************************
[+] input: Exception { UnknownAssociation association = new UnknownAssociation(); "<AssertPlaceHolder>"; assertNull(association.getStatement()); }
canDelete() { return false; }
[*] target: assertFalse(association.canDelete())
[-] pred: org. junit. Assert. assertFalse ( association. canDelete() )
************************************
************************************
[+] input: Exception { prepare_separateMethodAndParent(); ContainerInfo panel = parseContainer( "class Test extends MyDialog {", "  Test() {", "    JPanel bar = new JPanel();", "    add(bar);", "    //", "    addButton(bar);", "  }", "}"); assertHierarchy( "{this: test.MyDialog} {this} {/add(bar)/ /addButton(bar)/}", "  {new: javax.swing.JPanel} {local-unique: bar} {/new JPanel()/ /add(bar)/ /addButton(bar)/}", "    {implicit-layout: java.awt.FlowLayout} {implicit-layout} {}", "    {implicit-factory} {empty} {/addButton(bar)/}"); ContainerInfo bar = (ContainerInfo) panel.getChildrenComponents().get(0); ComponentInfo button = bar.getChildrenComponents().get(0); ImplicitFactoryCreationSupport creationSupport = (ImplicitFactoryCreationSupport) button.getCreationSupport(); // check MethodDescription { MethodDescription description = creationSupport.getDescription(); assertNotNull(description); assertEquals("addButton({java.awt.Container,parent})", description.toString()); } // no copy/paste (at least now we don't support this) { IClipboardCreationSupport clipboard = creationSupport.getClipboard(); "<AssertPlaceHolder>"; } }
getClipboard() throws Exception { // support copy/paste only when target/parent are same if (!m_javaInfo.getParentJava().isRepresentedBy(m_invocation.getExpression())) { return null; } // OK, simple case final String signature = m_signature; final String source = getClipboardSource(); return new IClipboardCreationSupport() { private static final long serialVersionUID = 0L;  @Override public CreationSupport create(JavaInfo rootObject) throws Exception { return new ImplicitFactoryCreationSupport(null, signature, source); } }; }
[*] target: assertNull(clipboard)
[-] pred: org. junit. Assert. assertNull ( clipboard )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "class Test extends JPanel {", "  Test() {", "    addKeyListener(new KeyAdapter() {", "      public void keyPressed(KeyEvent e) {", "        System.out.println('keyPressed!');", "      }", "      public void keyReleased(KeyEvent e) {", "        System.out.println('keyReleased!');", "      }", "    });", "  }", "}"); EventsProperty eventsProperty = (EventsProperty) panel.getPropertyByTitle("Events"); assertNotNull(eventsProperty); assertTrue(eventsProperty.isModified()); assertEquals("[key]", getPropertyText(eventsProperty)); // check listeners Property keyProperty; { Property[] listenerProperties = getSubProperties(eventsProperty); assertEquals(13, listenerProperties.length); // no listener for "focus" { Property focusProperty = getPropertyByTitle(listenerProperties, "focus"); assertNotNull(focusProperty); assertFalse(focusProperty.isModified()); assertEquals("[]", getPropertyText(focusProperty)); } // check "key" listener property keyProperty = getPropertyByTitle(listenerProperties, "key"); assertNotNull(keyProperty); "<AssertPlaceHolder>"; assertEquals("[pressed, released]", getPropertyText(keyProperty)); } // check listener methods { Property[] methodProperties = getSubProperties(keyProperty); assertEquals(3, methodProperties.length); assertEquals("pressed", methodProperties[0].getTitle()); assertEquals("released", methodProperties[1].getTitle()); assertEquals("typed", methodProperties[2].getTitle()); } }
isModified() throws Exception { // check if there are listeners Property[] properties = getSubProperties(); for (Property property : properties) { if (property.isModified()) { return true; } } // not modified return false; }
[*] target: assertTrue(keyProperty.isModified())
[-] pred: org. junit. Assert. assertTrue ( keyProperty. isModified() )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "class Test extends JPanel {", "  Test() {", "    KeyListener listener = new KeyAdapter() {", "      public void keyPressed(KeyEvent e) {", "      }", "    };", "    addKeyListener(listener);", "  }", "}"); Property keyPressedProperty = getEventsListenerMethod(panel, "key", "pressed"); assertNotNull(keyPressedProperty); "<AssertPlaceHolder>"; }
isModified() throws Exception { // check if there are listeners Property[] properties = getSubProperties(); for (Property property : properties) { if (property.isModified()) { return true; } } // not modified return false; }
[*] target: assertTrue(keyPressedProperty.isModified())
[-] pred: org. junit. Assert. assertTrue ( keyPressedProperty. isModified() )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyButton.java", getTestSource( "public class MyButton extends JButton {", "  public MyButton(String text, FocusListener listener) {", "  }", "}")); setFileContentSrc( "test/MyButton.wbp-component.xml", getSourceDQ( "<?xml version='1.0' encoding='UTF-8'?>", "<component xmlns='http://www.eclipse.org/wb/WBPComponent'>", "  <constructors>", "    <constructor>", "      <parameter type='java.lang.String'/>", "      <parameter type='java.awt.event.FocusListener'>", "        <tag name='events: add listener method' value='addFocusListener(java.awt.event.FocusListener)'/>", "      </parameter>", "    </constructor>", "  </constructors>", "</component>")); waitForAutoBuild(); // ContainerInfo panel = parseContainer( "public class Test extends JPanel {", "  public Test() {", "    MyButton button = new MyButton('text', new FocusAdapter() {", "      public void focusGained(FocusEvent e) {}", "    });", "    add(button);", "  }", "}"); ComponentInfo button = panel.getChildrenComponents().get(0); // Property focusGainedProperty = getEventsListenerMethod(button, "focus", "gained"); assertNotNull(focusGainedProperty); "<AssertPlaceHolder>"; }
isModified() throws Exception { // check if there are listeners Property[] properties = getSubProperties(); for (Property property : properties) { if (property.isModified()) { return true; } } // not modified return false; }
[*] target: assertTrue(focusGainedProperty.isModified())
[-] pred: org. junit. Assert. assertTrue ( focusGainedProperty. isModified() )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "class Test extends JPanel {", "  Test() {", "    addKeyListener(new KeyAdapter() {", "      public void keyReleased(KeyEvent e) {", "      }", "    });", "  }", "}"); DesignPageSite.Helper.setSite(panel, DesignPageSite.EMPTY); // prepare properties Property keyPressedProperty = getEventsListenerMethod(panel, "key", "pressed"); Property keyReleasedProperty = getEventsListenerMethod(panel, "key", "released"); assertNull(getPropertyText(keyPressedProperty)); assertEquals("line 8", getPropertyText(keyReleasedProperty)); // prepare context menu IMenuManager manager; { manager = getDesignerMenuManager(); panel.getBroadcastObject().addContextMenu(null, panel, manager); } // check action for existing "keyReleased" event { IAction keyReleasedAction = findChildAction(manager, "keyReleased -> line 8"); "<AssertPlaceHolder>"; assertSame( EventsPropertyUtils.LISTENER_METHOD_IMAGE_DESCRIPTOR, keyReleasedAction.getImageDescriptor()); // run, no change expected String expectedSource = m_lastEditor.getSource(); keyReleasedAction.run(); assertEditor(expectedSource, m_lastEditor); } // add new handler using action { IMenuManager manager2 = findChildMenuManager(manager, "Add event handler"); manager2 = findChildMenuManager(manager2, "key"); assertSame(EventsPropertyUtils.EXISTING_CLASS_IMAGE, ((MenuManagerEx) manager2).getImage()); // IAction keyPressedAction = findChildAction(manager2, "keyPressed"); assertNotNull(keyPressedAction); // run, new handler should be added keyPressedAction.run(); assertEditor( "class Test extends JPanel {", "  Test() {", "    addKeyListener(new KeyAdapter() {", "      public void keyReleased(KeyEvent e) {", "      }", "      @Override", "      public void keyPressed(KeyEvent e) {", "      }", "    });", "  }", "}"); } // check for images { IMenuManager manager2 = findChildMenuManager(manager, "Add event handler"); assertSame( EventsPropertyUtils.LISTENER_INTERFACE_IMAGE, ((MenuManagerEx) findChildMenuManager(manager2, "ancestor")).getImage()); } }
addContextMenu(List<? extends ObjectInfo> objects, ObjectInfo object, IMenuManager manager) throws Exception { if (object == m_javaInfo) { contributeActions(manager, ModelMessages.EventsProperty_menuManagerName); } }
[*] target: assertNotNull(keyReleasedAction)
[-] pred: org. junit. Assert. assertNotNull ( keyReleasedAction )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); final GenericProperty enabledProperty = (GenericProperty) panel.getPropertyByTitle("enabled"); final AtomicBoolean wasFired = new AtomicBoolean(); // add listener panel.addBroadcastListener(new JavaEventListener() { @Override public void propertyValueWasSet(GenericPropertyImpl property) throws Exception { if (property == enabledProperty) { wasFired.set(true); } } }); // set value for "enabled" to "false" wasFired.set(false); enabledProperty.setValue(false); assertTrue(wasFired.get()); assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); // set value for "enabled" to "true" wasFired.set(false); enabledProperty.setValue(true); "<AssertPlaceHolder>"; assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); // set value for "enabled" to "false" wasFired.set(false); enabledProperty.setExpression("false", Property.UNKNOWN_VALUE); assertTrue(wasFired.get()); assertEditor( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); }
setValue(Object value) throws Exception;  //////////////////////////////////////////////////////////////////////////// // // Editor // //////////////////////////////////////////////////////////////////////////// /** * @return the {@link PropertyEditor}
[*] target: assertTrue(wasFired.get())
[-] pred: org. junit. Assert. assertTrue ( wasFired. get ( ) )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyPanel.java", getTestSource( "// filler filler filler filler filler", "// filler filler filler filler filler", "public class MyPanel extends JPanel {", "  public int foo;", "}")); waitForAutoBuild(); // parse // parse ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("foo"); FieldAccessor accessor = (FieldAccessor) getGenericPropertyAccessors(property).get(0); // check that IAccessibleExpressionAccessor is available // note, that we don't check it, I just don't know how to do this more easy than perform full check // but we expect that it should be from IAccessibleExpressionAccessor.Utils.forField() IAccessibleExpressionAccessor accessibleAccessor = accessor.getAdapter(IAccessibleExpressionAccessor.class); "<AssertPlaceHolder>"; assertNotNull(ReflectionUtils.getFieldByName(accessibleAccessor.getClass(), "val$field")); }
getAdapter(Class<T> adapter) { if (adapter == IAccessibleExpressionAccessor.class) { return adapter.cast(m_accessibleAccessor); } if (adapter == IExposableExpressionAccessor.class) { return adapter.cast(m_exposableAccessor); } if (adapter == PropertyTooltipProvider.class) { return adapter.cast(m_tooltipProvider); } // other return super.getAdapter(adapter); }
[*] target: assertNotNull(accessibleAccessor)
[-] pred: org. junit. Assert. assertNotNull ( accessibleAccessor )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "public class Test extends JPanel {", "  public Test() {", "    setEnabled(false);", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("enabled"); SetterAccessor accessor = (SetterAccessor) getGenericPropertyAccessors(property).get(0); // check Method getter = accessor.getGetter(); "<AssertPlaceHolder>"; assertEquals("isEnabled", getter.getName()); }
getGetter() { return m_getter; }
[*] target: assertNotNull(getter)
[-] pred: org. junit. Assert. assertNotNull ( getter )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); GenericProperty property = (GenericProperty) panel.getPropertyByTitle("enabled"); SetterAccessor accessor = (SetterAccessor) getGenericPropertyAccessors(property).get(0); // check that IAccessibleExpressionAccessor is available // note, that we don't check it, I just don't know how to do this more easy than perform full check // but we expect that it should be from IAccessibleExpressionAccessor.Utils.forMethod() IAccessibleExpressionAccessor accessibleAccessor = accessor.getAdapter(IAccessibleExpressionAccessor.class); "<AssertPlaceHolder>"; assertNotNull(ReflectionUtils.getFieldByName(accessibleAccessor.getClass(), "val$method")); }
getAdapter(Class<T> adapter) { if (adapter == IAccessibleExpressionAccessor.class) { return adapter.cast(m_accessibleAccessor); } if (adapter == IExposableExpressionAccessor.class) { return adapter.cast(m_exposableAccessor); } if (adapter == PropertyTooltipProvider.class) { return adapter.cast(m_tooltipProvider); } // other return super.getAdapter(adapter); }
[*] target: assertNotNull(accessibleAccessor)
[-] pred: org. junit. Assert. assertNotNull ( accessibleAccessor )
************************************
************************************
[+] input: Exception { prepareBooleanPanel(); ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "    setFoo(true);", "  }", "}"); panel.refresh(); // prepare property Property property = panel.getPropertyByTitle("foo"); BooleanObjectPropertyEditor editor = (BooleanObjectPropertyEditor) property.getEditor(); // true -> false boolean activated = editor.activate(null, property, null); "<AssertPlaceHolder>"; assertEditor( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "    setFoo(false);", "  }", "}"); }
activate(PropertyTable propertyTable, Property property, Point location) throws Exception { // check that user clicked on image if (location == null || location.x < m_trueImage.getBounds().width + 2) { invertValue(property); } // don't activate return false; }
[*] target: assertFalse(activated)
[-] pred: org. junit. Assert. assertFalse ( activated )
************************************
************************************
[+] input: Exception { prepareBooleanPanel(); ContainerInfo panel = parseContainer( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "    setFoo(true);", "  }", "}"); panel.refresh(); // prepare property Property property = panel.getPropertyByTitle("foo"); BooleanPropertyEditor editor = (BooleanPropertyEditor) property.getEditor(); // true -> false boolean activated = editor.activate(null, property, null); "<AssertPlaceHolder>"; assertEditor( "// filler filler filler", "public class Test extends MyPanel {", "  public Test() {", "    setFoo(false);", "  }", "}"); }
activate(PropertyTable propertyTable, Property property, Point location) throws Exception { // check that user clicked on image if (location == null || location.x < m_trueImage.getBounds().width + 2) { invertValue(property); } // don't activate return false; }
[*] target: assertFalse(activated)
[-] pred: org. junit. Assert. assertFalse ( activated )
************************************
************************************
[+] input: Exception { IFile file = getFileSrc("test/messages.properties"); // prepare file in UTF-8 with Russian characters String key = "key"; String value = "" + (char) 0x410 + (char) 0x411 + (char) 0x412; String newValue = "" + (char) 0x430 + (char) 0x431 + (char) 0x432; { String content = key + "=" + value; setFileContent(file, content.getBytes("UTF-8")); file.setCharset("UTF-8", null); } // use BundleInfo, session #1 // check for initial value { BundleInfo bundle = BundleInfo.createBundle( StandardPropertiesAccessor.INSTANCE, "test.messages", LocaleInfo.DEFAULT, new IFile[]{file}); assertNotNull(bundle); assertEquals(value, bundle.getValue(key)); // set new value bundle.setValue(key, newValue); bundle.save(""); assertEquals("UTF-8", file.getCharset()); } // use BundleInfo, session #2 // check for new value { BundleInfo bundle = BundleInfo.createBundle( StandardPropertiesAccessor.INSTANCE, "test.messages", LocaleInfo.DEFAULT, new IFile[]{file}); assertNotNull(bundle); "<AssertPlaceHolder>"; } }
getValue(String key) throws Exception { return getProperties().get(key); }
[*] target: assertEquals(newValue, bundle.getValue(key))
[-] pred: org. junit. Assert. assertEquals ( newValue, bundle. getValue( key ) )
************************************
************************************
[+] input: Exception { NlsTestUtils.create_EclipseOld_Accessor(this, false); setFileContentSrc( "test/messages.properties", getSourceDQ("frame.title=My JFrame", "frame.name=My name")); waitForAutoBuild(); // ContainerInfo frame = parseContainer( "class Test extends JFrame {", "  Test() {", "    setTitle(Messages.getString('frame.title')); //$NON-NLS-1$", "    setName(Messages.getString('frame.name')); //$NON-NLS-1$", "  }", "}"); // prepare NLS NlsSupport support = NlsSupport.get(frame); EditableSupport editableSupport = (EditableSupport) support.getEditable(); // prepare editable source IEditableSource editableSource; { List<IEditableSource> editableSources = editableSupport.getEditableSources(); "<AssertPlaceHolder>"; editableSource = editableSources.get(0); } // check keys assertStringSet(editableSource.getKeys(), new String[]{"frame.title", "frame.name"}); // rename - two times editableSource.renameKey("frame.name", "frame.name2"); editableSource.renameKey("frame.title", "frame.title2"); editableSource.renameKey("frame.title2", "frame.title3"); // apply commands support.applyEditable(editableSupport); // check assertStringSet(editableSource.getKeys(), new String[]{"frame.title3", "frame.name2"}); { String newProperties = getFileContentSrc("test/messages.properties"); // assertFalse(newProperties.contains("frame.name=My name")); assertTrue(newProperties.contains("frame.name2=My name")); // assertFalse(newProperties.contains("frame.title=My JFrame")); assertFalse(newProperties.contains("frame.title2=My JFrame")); assertTrue(newProperties.contains("frame.title3=My JFrame")); } assertEditor( "class Test extends JFrame {", "  Test() {", "    setTitle(Messages.getString('frame.title3')); //$NON-NLS-1$", "    setName(Messages.getString('frame.name2')); //$NON-NLS-1$", "  }", "}"); }
getEditableSources() { List<IEditableSource> editableSources = new ArrayList<>(); // add existing and new sources editableSources.addAll(m_sourceToEditable.values()); editableSources.addAll(m_newEditableSources); // if we have "real" editable sources, return them if (!editableSources.isEmpty()) { return editableSources; } // return "possible" editable sources return getPossibleEditableSources(); }
[*] target: assertEquals(1, editableSources.size())
[-] pred: org. junit. Assert. assertEquals ( 1, editableSources. size ( ) )
************************************
************************************
[+] input: Exception { NlsTestUtils.create_EclipseOld_Accessor(this, false); setFileContentSrc( "test/messages.properties", getSourceDQ("frame.title=My JFrame", "frame.name=My name")); waitForAutoBuild(); // ContainerInfo frame = parseContainer( "class Test extends JFrame {", "  Test() {", "    setTitle(Messages.getString('frame.title')); //$NON-NLS-1$", "    setName(Messages.getString('frame.name')); //$NON-NLS-1$", "  }", "}"); // prepare NLS NlsSupport support = NlsSupport.get(frame); EditableSupport editableSupport = (EditableSupport) support.getEditable(); // prepare editable source IEditableSource editableSource; { List<IEditableSource> editableSources = editableSupport.getEditableSources(); "<AssertPlaceHolder>"; editableSource = editableSources.get(0); } // check keys assertStringSet(editableSource.getKeys(), new String[]{"frame.title", "frame.name"}); // internalize editableSource.internalizeKey("frame.title"); editableSource.internalizeKey("frame.name"); // apply commands support.applyEditable(editableSupport); // check assertStringSet(editableSource.getKeys(), new String[]{}); { String newProperties = getFileContentSrc("test/messages.properties"); assertFalse(newProperties.contains("frame.name=My name")); assertFalse(newProperties.contains("frame.title=My JFrame")); } assertEditor( "class Test extends JFrame {", "  Test() {", "    setTitle('My JFrame');", "    setName('My name');", "  }", "}"); }
getEditableSources() { List<IEditableSource> editableSources = new ArrayList<>(); // add existing and new sources editableSources.addAll(m_sourceToEditable.values()); editableSources.addAll(m_newEditableSources); // if we have "real" editable sources, return them if (!editableSources.isEmpty()) { return editableSources; } // return "possible" editable sources return getPossibleEditableSources(); }
[*] target: assertEquals(1, editableSources.size())
[-] pred: org. junit. Assert. assertEquals ( 1, editableSources. size ( ) )
************************************
************************************
[+] input: Exception { m_testProject.addPlugin("org.eclipse.osgi"); NlsTestUtils.create_EclipseModern_AccessorAndProperties(); String[] lines = { "class Test extends JFrame {", "  Test() {", "    setTitle(Messages.frame_title);", "  }", "}"}; ContainerInfo frame = parseContainer(lines); String frameSource = m_lastEditor.getSource(); // prepare NLS NlsSupport support = NlsSupport.get(frame); EditableSupport editableSupport = (EditableSupport) support.getEditable(); // prepare editable source IEditableSource editableSource; { List<IEditableSource> editableSources = editableSupport.getEditableSources(); "<AssertPlaceHolder>"; editableSource = editableSources.get(0); } // add key editableSource.addKey("newKey", "newValue"); Assertions.assertThat(editableSource.getKeys()).contains("newKey"); { LocaleInfo[] locales = editableSource.getLocales(); Assertions.assertThat(locales).hasSize(2); assertEquals("newValue", editableSource.getValue(locales[0], "newKey")); assertEquals("newValue", editableSource.getValue(locales[1], "newKey")); } // apply commands support.applyEditable(editableSupport); assertEditor(frameSource, m_lastEditor); // checks { String accessor = getFileContentSrc("test/Messages.java"); Assertions.assertThat(accessor).contains("public static String newKey;"); } { String newProperties = getFileContentSrc("test/messages.properties"); Assertions.assertThat(newProperties).contains("newKey=newValue"); } { String newProperties = getFileContentSrc("test/messages_it.properties"); Assertions.assertThat(newProperties).contains("newKey=newValue"); } }
getEditableSources() { List<IEditableSource> editableSources = new ArrayList<>(); // add existing and new sources editableSources.addAll(m_sourceToEditable.values()); editableSources.addAll(m_newEditableSources); // if we have "real" editable sources, return them if (!editableSources.isEmpty()) { return editableSources; } // return "possible" editable sources return getPossibleEditableSources(); }
[*] target: assertEquals(1, editableSources.size())
[-] pred: org. junit. Assert. assertEquals ( 1, editableSources. size ( ) )
************************************
************************************
[+] input: Exception { CategoryInfo category = new CategoryInfo(); assertFalse(category.isOpen()); category.setOpen(true); "<AssertPlaceHolder>"; }
isOpen() { return m_open; }
[*] target: assertTrue(category.isOpen())
[-] pred: org. junit. Assert. assertTrue ( category. isOpen() )
************************************
************************************
[+] input: Exception { addPaletteExtension(new String[]{"<category id='id_1' name='name 1' description='description 1'/>"}); PaletteInfo palette = loadPalette(); // check category CategoryInfo category = palette.getCategory("id_1"); assertEquals("id_1", category.getId()); assertEquals("name 1", category.getName()); assertEquals("description 1", category.getDescription()); assertTrue(category.isVisible()); assertTrue(category.isOpen()); "<AssertPlaceHolder>"; }
isOptional() { return m_optional; }
[*] target: assertFalse(category.isOptional())
[-] pred: org. junit. Assert. assertFalse ( category. isOptional() )
************************************
************************************
[+] input: Exception { ChooseComponentEntryInfo entry = new ChooseComponentEntryInfo(); "<AssertPlaceHolder>"; assertNotNull(entry.getName()); assertNotNull(entry.getDescription()); }
getIcon() { return ICON; }
[*] target: assertNotNull(entry.getIcon())
[-] pred: org. junit. Assert. assertNotNull ( entry. getIcon() )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyAbstractButton.java", getTestSource( "// filler filler filler filler filler", "// filler filler filler filler filler", "public abstract class MyAbstractButton extends JButton {", "}")); waitForAutoBuild(); // prepare palette addPaletteExtension(new String[]{ "<category id='category_1' name='category 1'>", "  <component class='test.MyAbstractButton'/>", "</category>"}); PaletteInfo palette = loadPalette(); // prepare component final CategoryInfo category = palette.getCategory("category_1"); final ComponentEntryInfo componentEntry = (ComponentEntryInfo) category.getEntries().get(0); // set palette site IPaletteSite.Helper.setSite(m_lastParseInfo, new IPaletteSite.Empty() { @Override public Shell getShell() { return DesignerPlugin.getShell(); } }); // do initialize assertTrue(componentEntry.initialize(null, m_lastParseInfo)); // create tool new UiContext().executeAndCheck(new UIRunnable() { @Override public void run(UiContext context) throws Exception { CreationTool creationTool = (CreationTool) componentEntry.createTool(); "<AssertPlaceHolder>"; } }, new UIRunnable() { @Override public void run(UiContext context) throws Exception { context.useShell("Error"); context.clickButton("OK"); } }); }
createTool() throws Exception { if (!ensureDescriptions()) { return null; } if (ReflectionUtils.isAbstract(m_class) && !m_creation.hasTrueTag("createAnonymous")) { Shell parentShell = IPaletteSite.Helper.getSite(m_rootJavaInfo).getShell(); UiUtils.openError( parentShell, Messages.ComponentEntryInfo_abstractTitle, Messages.ComponentEntryInfo_abstractMessage); return null; } // prepare generics final Map<String, String> genericArguments = getTypeArguments(); if (genericArguments == null) { return null; } // prepare factory ICreationFactory factory = new ICreationFactory() { private JavaInfo m_javaInfo;  @Override public void activate() throws Exception { CreationSupport creationSupport = new ConstructorCreationSupport(m_creationId, true); m_javaInfo = JavaInfoUtils.createJavaInfo(m_editor, m_description, creationSupport); m_javaInfo.putTemplateArguments(genericArguments); m_javaInfo = JavaInfoUtils.getWrapped(m_javaInfo); m_javaInfo.putArbitraryValue(JavaInfo.FLAG_MANUAL_COMPONENT, Boolean.TRUE); }  @Override public Object getNewObject() { return m_javaInfo; } }; // return tool ensureLibraries(); return new CreationTool(factory); }
[*] target: assertNull(creationTool)
[-] pred: org. junit. Assert. assertNull ( creationTool )
************************************
************************************
[+] input: Exception { setFileContentSrc( "test/MyAbstractButton.java", getTestSource( "// filler filler filler filler filler", "// filler filler filler filler filler", "public abstract class MyAbstractButton extends JButton {", "}")); setFileContentSrc( "test/MyAbstractButton.wbp-component.xml", getSourceDQ( "<?xml version='1.0' encoding='UTF-8'?>", "<component xmlns='http://www.eclipse.org/wb/WBPComponent'>", "  <creation>", "    <source><![CDATA[new test.MyAbstractButton(){}]]></source>", "    <tag name='createAnonymous' value='true'/>", "  </creation>", "</component>")); waitForAutoBuild(); // prepare palette addPaletteExtension(new String[]{ "<category id='category_1' name='category 1'>", "  <component class='test.MyAbstractButton'/>", "</category>"}); PaletteInfo palette = loadPalette(); // prepare component final CategoryInfo category = palette.getCategory("category_1"); final ComponentEntryInfo componentEntry = (ComponentEntryInfo) category.getEntries().get(0); // set palette site IPaletteSite.Helper.setSite(m_lastParseInfo, new IPaletteSite.Empty() { @Override public Shell getShell() { return DesignerPlugin.getShell(); } }); // do initialize assertTrue(componentEntry.initialize(null, m_lastParseInfo)); // create tool CreationTool creationTool = (CreationTool) componentEntry.createTool(); "<AssertPlaceHolder>"; }
createTool() throws Exception { if (!ensureDescriptions()) { return null; } if (ReflectionUtils.isAbstract(m_class) && !m_creation.hasTrueTag("createAnonymous")) { Shell parentShell = IPaletteSite.Helper.getSite(m_rootJavaInfo).getShell(); UiUtils.openError( parentShell, Messages.ComponentEntryInfo_abstractTitle, Messages.ComponentEntryInfo_abstractMessage); return null; } // prepare generics final Map<String, String> genericArguments = getTypeArguments(); if (genericArguments == null) { return null; } // prepare factory ICreationFactory factory = new ICreationFactory() { private JavaInfo m_javaInfo;  @Override public void activate() throws Exception { CreationSupport creationSupport = new ConstructorCreationSupport(m_creationId, true); m_javaInfo = JavaInfoUtils.createJavaInfo(m_editor, m_description, creationSupport); m_javaInfo.putTemplateArguments(genericArguments); m_javaInfo = JavaInfoUtils.getWrapped(m_javaInfo); m_javaInfo.putArbitraryValue(JavaInfo.FLAG_MANUAL_COMPONENT, Boolean.TRUE); }  @Override public Object getNewObject() { return m_javaInfo; } }; // return tool ensureLibraries(); return new CreationTool(factory); }
[*] target: assertNotNull(creationTool)
[-] pred: org. junit. Assert. assertNotNull ( creationTool )
************************************
************************************
[+] input: Exception { addPaletteExtension(new String[]{ "<category id='category_1' name='category 1'>", "  <component class='no.such.Class'/>", "</category>"}); PaletteInfo palette = loadPalette(); // prepare component CategoryInfo category = palette.getCategory("category_1"); ComponentEntryInfo componentEntry = (ComponentEntryInfo) category.getEntries().get(0); // do initialize m_lastParseInfo.putArbitraryValue(ComponentEntryInfo.KEY_SIMULATE_PRESENTATION, true); assertTrue(componentEntry.initialize(null, m_lastParseInfo)); // create tool Assertions.assertThat(m_lastState.getWarnings()).hasSize(0); CreationTool creationTool = (CreationTool) componentEntry.createTool(); "<AssertPlaceHolder>"; Assertions.assertThat(m_lastState.getWarnings()).hasSize(1); }
createTool() throws Exception { if (!ensureDescriptions()) { return null; } if (ReflectionUtils.isAbstract(m_class) && !m_creation.hasTrueTag("createAnonymous")) { Shell parentShell = IPaletteSite.Helper.getSite(m_rootJavaInfo).getShell(); UiUtils.openError( parentShell, Messages.ComponentEntryInfo_abstractTitle, Messages.ComponentEntryInfo_abstractMessage); return null; } // prepare generics final Map<String, String> genericArguments = getTypeArguments(); if (genericArguments == null) { return null; } // prepare factory ICreationFactory factory = new ICreationFactory() { private JavaInfo m_javaInfo;  @Override public void activate() throws Exception { CreationSupport creationSupport = new ConstructorCreationSupport(m_creationId, true); m_javaInfo = JavaInfoUtils.createJavaInfo(m_editor, m_description, creationSupport); m_javaInfo.putTemplateArguments(genericArguments); m_javaInfo = JavaInfoUtils.getWrapped(m_javaInfo); m_javaInfo.putArbitraryValue(JavaInfo.FLAG_MANUAL_COMPONENT, Boolean.TRUE); }  @Override public Object getNewObject() { return m_javaInfo; } }; // return tool ensureLibraries(); return new CreationTool(factory); }
[*] target: assertNull(creationTool)
[-] pred: org. junit. Assert. assertNull ( creationTool )
************************************
************************************
[+] input: Exception { // some other class { Throwable e = new NoClassDefFoundError("not/designer/Class"); assertFalse(isIncompleteProductException(e)); } // Designer { Throwable e = new NoClassDefFoundError("org/eclipse/wb/Foo"); assertTrue(isIncompleteProductException(e)); // even wrapped e = new Error(e); assertTrue(isIncompleteProductException(e)); } // JDT { Throwable e = new NoClassDefFoundError("org/eclipse/jdt/core/dom/AnonymousTypeDeclaration2"); assertTrue(isIncompleteProductException(e)); // even wrapped e = new Error(e); "<AssertPlaceHolder>"; } }
isIncompleteProductException(Throwable e) { if (e instanceof NoSuchMethodError) { return e.getMessage().startsWith("org.eclipse.wb."); } if (e instanceof NoClassDefFoundError) { String message = e.getMessage(); return message.startsWith("org/eclipse/wb/") || message.startsWith("org/eclipse/jdt/"); } return false; }
[*] target: assertTrue(isIncompleteProductException(e))
[-] pred: org. junit. Assert. assertTrue ( isIncompleteProductException( e) )
************************************
************************************
[+] input: Exception { TestBundle testBundle = new TestBundle(); try { testBundle.addExtension(POINT_ID, "<testObject icon='res/path/test.png'/>"); testBundle.setFile("res/path/test.png", TestUtils.createImagePNG(2, 3)); testBundle.install(); // work with Bundle { IConfigurationElement element = ExternalFactoriesHelper.getElements(POINT_ID, "testObject").get(0); ImageDescriptor descriptor = ExternalFactoriesHelper.getImageDescriptor(element, "icon"); "<AssertPlaceHolder>"; // validate Image image = descriptor.createImage(); try { assertEquals(2, image.getBounds().width); assertEquals(3, image.getBounds().height); } finally { image.dispose(); } } } finally { testBundle.dispose(); } }
getImageDescriptor(IConfigurationElement element, String attribute) { String path = element.getAttribute(attribute); if (path != null) { Bundle bundle = getExtensionBundle(element); BundleResourceProvider resourceProvider = BundleResourceProvider.get(bundle); return resourceProvider.getImageDescriptor(path); } return null; }
[*] target: assertNotNull(descriptor)
[-] pred: org. junit. Assert. assertNotNull ( descriptor )
************************************
************************************
[+] input: Exception { // prepare objects List<Object> objects; { objects = new ArrayList<>(); objects.add("123"); objects.add(555); } // prepare selection provider ISelectionProvider selectionProvider; { final ISelection selection = new StructuredSelection(objects); selectionProvider = new ISelectionProvider() { @Override public ISelection getSelection() { return selection; }  @Override public void setSelection(ISelection _selection) { }  @Override public void removeSelectionChangedListener(ISelectionChangedListener listener) { }  @Override public void addSelectionChangedListener(ISelectionChangedListener listener) { } }; } // get iterable Iterable<Object> iterable = GenericsUtils.iterableSelection(selectionProvider); // iterate { // prepare iterator Iterator<Object> iterator = iterable.iterator(); // first element assertTrue(iterator.hasNext()); assertSame(objects.get(0), iterator.next()); // second element assertTrue(iterator.hasNext()); assertSame(objects.get(1), iterator.next()); // not more elements "<AssertPlaceHolder>"; } }
hasNext() { return iterator.hasNext(); }
[*] target: assertFalse(iterator.hasNext())
[-] pred: org. junit. Assert. assertFalse ( iterator. hasNext() )
************************************
************************************
[+] input: Exception { Map<String, String> options = ProjectUtils.getOptions(m_testProject.getJavaProject()); "<AssertPlaceHolder>"; // check one option assertEquals("error", options.get("org.eclipse.jdt.core.incompleteClasspath")); }
getOptions(IJavaProject project) { return project.getOptions(true); }
[*] target: assertNotNull(options)
[-] pred: org. junit. Assert. assertNotNull ( options )
************************************
************************************
[+] input: Exception { scope.setIncludesBinaries(true); scope.setIncludesClasspaths(true); assertTrue(scope.includesBinaries()); "<AssertPlaceHolder>"; }
includesClasspaths() { return m_hierarchyScope.includesClasspaths(); }
[*] target: assertTrue(scope.includesClasspaths())
[-] pred: org. junit. Assert. assertTrue ( scope. includesClasspaths() )
************************************
************************************
[+] input: Exception { ContainerInfo panel = parseContainer( "// filler filler filler filler filler", "public class Test extends JPanel {", "  public Test() {", "  }", "}"); panel.refresh(); // initial "active" assertSame(panel, GlobalState.getActiveObject()); // use "live" manager { ComponentInfo button = createJButton(); Component component = button.getComponent(); "<AssertPlaceHolder>"; } // "active" is not changed assertSame(panel, GlobalState.getActiveObject()); }
getComponent() { return ((SwingLiveCacheEntry) getCachedEntry()).getComponent(); }
[*] target: assertNotNull(component)
[-] pred: org. junit. Assert. assertNotNull ( component )
************************************
************************************
[+] input: Exception { Class<?> SWTClass = m_lastLoader.loadClass("org.eclipse.swt.SWT"); ColorInfo info = ColorSupport.createInfo(ReflectionUtils.getFieldByName(SWTClass, "COLOR_RED")); // check create "<AssertPlaceHolder>"; // check color name assertEquals("COLOR_RED", info.m_name); // check special data assertEquals("org.eclipse.swt.SWT.COLOR_RED", info.getData()); // check RGB assertNotNull(info.m_rgb); assertEquals(255, info.m_rgb.red); assertEquals(0, info.m_rgb.green); assertEquals(0, info.m_rgb.blue); }
createInfo(String name, Object color) throws Exception { return new ColorInfo(name, getRed(color), getGreen(color), getBlue(color)); }
[*] target: assertNotNull(info)
[-] pred: org. junit. Assert. assertNotNull ( info )
************************************
************************************
[+] input: Exception { Object shell = ContainerSupport.createShell(); Image rcpImage = ImageDescriptor.createFromFile(Object.class, "/javax/swing/plaf/basic/icons/JavaCup16.png") .createImage(); try { assertNull(ReflectionUtils.invokeMethod(shell, "getImage()")); // ContainerSupport.setShellImage(shell, rcpImage); // check newly set image { Object image = ReflectionUtils.invokeMethod(shell, "getImage()"); // exists... "<AssertPlaceHolder>"; // ..and has same size { Object bounds = ReflectionUtils.invokeMethod(image, "getBounds()"); assertEquals(rcpImage.getBounds().width, ReflectionUtils.getFieldInt(bounds, "width")); assertEquals(rcpImage.getBounds().height, ReflectionUtils.getFieldInt(bounds, "height")); } } } finally { rcpImage.dispose(); ControlSupport.dispose(shell); } }
setShellImage(Object shell, Image swtImage) throws Exception { Object image = SWT_TO_TOOLKIT_IMAGES.get(swtImage); if (image == null) { image = ToolkitSupport.createToolkitImage(swtImage); SWT_TO_TOOLKIT_IMAGES.put(swtImage, image); } ReflectionUtils.invokeMethod(shell, "setImage(org.eclipse.swt.graphics.Image)", image); }
[*] target: assertNotNull(image)
[-] pred: org. junit. Assert. assertNotNull ( image )
************************************
************************************
[+] input: Exception { Object button = getButton(); Object toDisplayPoint = ReflectionUtils.invokeMethod(button, "toDisplay(int,int)", 5, 5); Point toDisplayPointTest = ControlSupport.toDisplay(button, 5, 5); "<AssertPlaceHolder>"; assertEquals(ReflectionUtils.getFieldInt(toDisplayPoint, "x"), toDisplayPointTest.x); assertEquals(ReflectionUtils.getFieldInt(toDisplayPoint, "y"), toDisplayPointTest.y); }
toDisplay(Object control, int x, int y) throws Exception { Object location = ReflectionUtils.invokeMethod(control, "toDisplay(int,int)", x, y); return PointSupport.getPoint(location); }
[*] target: assertNotNull(toDisplayPointTest)
[-] pred: org. junit. Assert. assertNotNull ( toDisplayPointTest )
************************************
************************************
[+] input: Exception { Object button = getButton(); Object preferredSize = ControlSupport.computeSize_DEFAULT(button); Dimension preferredSizeTest = ControlSupport.getPreferredSize(button); "<AssertPlaceHolder>"; assertEquals(ReflectionUtils.getFieldInt(preferredSize, "x"), preferredSizeTest.width); assertEquals(ReflectionUtils.getFieldInt(preferredSize, "y"), preferredSizeTest.height); }
getPreferredSize(Object control) throws Exception { Object size = ReflectionUtils.invokeMethod( control, "computeSize(int,int)", SwtSupport.DEFAULT, SwtSupport.DEFAULT); Point pointSize = PointSupport.getPoint(size); return new Dimension(pointSize.x, pointSize.y); }
[*] target: assertNotNull(preferredSizeTest)
[-] pred: org. junit. Assert. assertNotNull ( preferredSizeTest )
************************************
************************************
[+] input: Exception { disposeLastModel(); CompositeInfo shellInfo = (CompositeInfo) parseSource( "test", "Test2.java", getTestSource( "public class Test2 extends Shell {", "  public Test2() {", "    setLayout(new RowLayout());", "    Button button = new Button(this, SWT.NONE);", "    button.setLayoutData(new RowData(100, 50));", "  }", "}")); shellInfo.refresh(); ControlInfo buttonInfo = shellInfo.getChildrenControls().get(0); Object button = buttonInfo.getObject(); // call getLayoutData() Object layoutData = ControlSupport.getLayoutData(button); "<AssertPlaceHolder>"; assertEquals("org.eclipse.swt.layout.RowData", layoutData.getClass().getName()); }
getLayoutData(Object control) { return ReflectionUtils.invokeMethodEx(control, "getLayoutData()"); }
[*] target: assertNotNull(layoutData)
[-] pred: org. junit. Assert. assertNotNull ( layoutData )
************************************
************************************
[+] input: Exception { Figure testFigure = new Figure(); // // check tooltip for new Figure assertNull(testFigure.getToolTipText()); // // check set tooltip testFigure.setToolTipText("JLabel("123")"); assertEquals("JLabel("123")", testFigure.getToolTipText()); // // check set other tooltip testFigure.setToolTipText("new Button()"); assertEquals("new Button()", testFigure.getToolTipText()); // // check set 'null' tooltip testFigure.setToolTipText(null); "<AssertPlaceHolder>"; }
getToolTipText() { return m_toolTipText; }
[*] target: assertNull(testFigure.getToolTipText())
[-] pred: org. junit. Assert. assertNull ( testFigure. getToolTipText() )
************************************
************************************
[+] input: Exception { LineBorder border = new LineBorder(3); // check init state properties for border constructor(int) assertNull(border.getColor()); "<AssertPlaceHolder>"; assertEquals(new Insets(3), border.getInsets(null)); }
getWidth() { return m_width; }
[*] target: assertEquals(3, border.getWidth())
[-] pred: org. junit. Assert. assertEquals ( 3, border. getWidth() )
************************************
************************************
[+] input: Exception { LineBorder border = new LineBorder(red); // check init state properties for border constructor(Color) assertSame(red, border.getColor()); "<AssertPlaceHolder>"; assertEquals(new Insets(1), border.getInsets(null)); }
getWidth() { return m_width; }
[*] target: assertEquals(1, border.getWidth())
[-] pred: org. junit. Assert. assertEquals ( 1, border. getWidth() )
************************************
************************************
[+] input: Exception { // check reset state during addPoint() m_polyline.addPoint(new Point(10, 20)); // m_expectedLogger.log("invalidate"); m_expectedLogger.log("repaint(10, 20, 1, 1)"); m_actualLogger.assertEquals(m_expectedLogger); // // check reset state during addPoint() m_polyline.addPoint(new Point(-90, 0)); // m_expectedLogger.log("invalidate"); m_expectedLogger.log("repaint(-90, 0, 101, 21)"); m_actualLogger.assertEquals(m_expectedLogger); // // check reset state during addPoint() m_polyline.addPoint(new Point(120, -70)); // m_expectedLogger.log("invalidate"); m_expectedLogger.log("repaint(-90, -70, 211, 91)"); m_actualLogger.assertEquals(m_expectedLogger); // // check add null point and not reset state try { m_polyline.addPoint(null); fail(); } catch (NullPointerException e) { m_actualLogger.assertEmpty(); } // // check work getPoint(int) PointList list = m_polyline.getPoints(); "<AssertPlaceHolder>"; assertEquals(3, list.size()); assertEquals(new Point(10, 20), list.getPoint(0)); assertEquals(new Point(-90, 0), list.getPoint(1)); assertEquals(new Point(120, -70), list.getPoint(2)); }
getPoints() { return m_points; }
[*] target: assertNotNull(list)
[-] pred: org. junit. Assert. assertNotNull ( list )
************************************
************************************
[+] input: isCacheableContent() { final Cache cache = new Cache(); final Map<String, String> headers = new HashMap<>(); final WebResponse response = new WebResponseMock(null, headers);  assertFalse(cache.isCacheableContent(response));  headers.put(LAST_MODIFIED, "Sun, 15 Jul 2007 20:46:27 GMT"); assertTrue(cache.isCacheableContent(response));  headers.put(LAST_MODIFIED, formatDate(DateUtils.addMinutes(new Date(), -5))); assertTrue(cache.isCacheableContent(response));  headers.put(LAST_MODIFIED, formatDate(new Date())); assertFalse(cache.isCacheableContent(response));  headers.put(LAST_MODIFIED, formatDate(DateUtils.addMinutes(new Date(), 10))); assertFalse(cache.isCacheableContent(response));  headers.put(EXPIRES, formatDate(DateUtils.addMinutes(new Date(), 5))); assertFalse(cache.isCacheableContent(response));  headers.put(EXPIRES, formatDate(DateUtils.addHours(new Date(), 1))); assertTrue(cache.isCacheableContent(response));  headers.remove(LAST_MODIFIED); assertTrue(cache.isCacheableContent(response));  headers.put(EXPIRES, "0"); assertFalse(cache.isCacheableContent(response));  headers.put(EXPIRES, "-1"); assertFalse(cache.isCacheableContent(response));  headers.put(CACHE_CONTROL, "no-store"); "<AssertPlaceHolder>"; }
isCacheableContent(final WebResponse response) { if (HeaderUtils.containsNoStore(response)) { return false; }  final long now = getCurrentTimestamp(); return isWithinCacheWindow(response, now, now); }
[*] target: assertFalse(cache.isCacheableContent(response))
[-] pred: org. junit. Assert. assertFalse ( cache. isCacheableContent ( response ) )
************************************
************************************
[+] input: Exception { final List<NameValuePair> emptyList = Collections.emptyList(); final WebResponseData webResponseData = new WebResponseData( ArrayUtils.EMPTY_BYTE_ARRAY, HttpClientConverter.NOT_FOUND, "not found", emptyList); final WebResponse webResponse = new WebResponse(webResponseData, URL_FIRST, HttpMethod.GET, 10); final FailingHttpStatusCodeException e = new FailingHttpStatusCodeException(webResponse);  assertEquals(webResponse, e.getResponse()); assertEquals(webResponse.getStatusMessage(), e.getStatusMessage()); "<AssertPlaceHolder>"; assertTrue("message doesn't contain failing url", e.getMessage().indexOf(URL_FIRST.toExternalForm()) > -1); }
getStatusCode() { return response_.getStatusCode(); }
[*] target: assertEquals(webResponse.getStatusCode(), e.getStatusCode())
[-] pred: org. junit. Assert. assertEquals ( webResponse. getStatusCode ( ), e. getStatusCode ( ) )
************************************
************************************
[+] input: Exception { final WebClient client = getWebClient();  final MockWebConnection conn = new MockWebConnection(); final String html = "<html><body onload='document.getElementById("f").src="frame.html";'>\n" + "<iframe id='f'></iframe></body></html>"; conn.setResponse(URL_FIRST, html); final URL frameUrl = new URL(URL_FIRST, "frame.html"); conn.setResponse(frameUrl, "<html><body></body></html>"); conn.setResponse(URL_SECOND, "<html><body></body></html>"); client.setWebConnection(conn);  client.getPage(URL_FIRST); assertEquals(2, client.getWebWindows().size()); assertEquals(frameUrl, client.getCurrentWindow().getEnclosedPage().getUrl());  // loading a new page should be done in the top window client.getPage(URL_SECOND); assertTrue(client.getCurrentWindow() instanceof TopLevelWindow); "<AssertPlaceHolder>"; }
getWebWindows() { return Collections.unmodifiableList(new ArrayList<>(windows_)); }
[*] target: assertEquals(1, client.getWebWindows().size())
[-] pred: org. junit. Assert. assertEquals ( 1, client. getWebWindows ( ). size ( ) )
************************************
************************************
[+] input: Exception { final WebRequest request = new WebRequest(new URL("http://localhost/test")); request.setHttpMethod(HttpMethod.POST); request.setEncodingType(FormEncodingType.MULTIPART);  final List<NameValuePair> requestParams = new ArrayList<>(); requestParams.add(new NameValuePair("test", null)); requestParams.add(new KeyDataPair("file", null, null, null, StandardCharsets.UTF_8)); request.setRequestParameters(requestParams);  final List<NameValuePair> expectedResults = new ArrayList<>(); expectedResults.add(new NameValuePair("test", "")); // the constructor of the KeyDataPair already creates normalized object // where the value is set to empty string if the passed file is null. expectedResults.add(new KeyDataPair("file", null, null, null, StandardCharsets.UTF_8));  final List<NameValuePair> normalizedParams = request.getParameters(); "<AssertPlaceHolder>";  // check that the value of the KeyDataPair is really normalized to empty string assertEquals("", normalizedParams.get(1).getValue()); }
getParameters() { // developer note: // this has to be in sync with // org.htmlunit.HttpWebConnection.makeHttpMethod(WebRequest, HttpClientBuilder)  if (HttpMethod.POST != getHttpMethod() && HttpMethod.PUT != getHttpMethod() && HttpMethod.PATCH != getHttpMethod()) {  if (!getRequestParameters().isEmpty()) { return normalize(getRequestParameters()); }  return normalize(HttpClientConverter.parseUrlQuery(getUrl().getQuery(), getCharset()));  }  if (getEncodingType() == FormEncodingType.URL_ENCODED && HttpMethod.POST == getHttpMethod()) { if (getRequestBody() == null) { return normalize(getRequestParameters()); }  return normalize(HttpClientConverter.parseUrlQuery(getRequestBody(), getCharset())); }  if (getEncodingType() == FormEncodingType.TEXT_PLAIN  && HttpMethod.POST == getHttpMethod()) { if (getRequestBody() == null) { return normalize(getRequestParameters()); }  return Collections.emptyList(); }  if (FormEncodingType.MULTIPART == getEncodingType()) { return normalize(getRequestParameters()); }  // for instance a PUT or PATCH request return Collections.emptyList(); }
[*] target: assertEquals(expectedResults, normalizedParams)
[-] pred: org. junit. Assert. assertEquals ( expectedResults, normalizedParams )
************************************
************************************
[+] input: Exception { final String html = "<html><head>\n" + "<style>\n" + "#d2:hover { display: none; }\n" + "#d3:hover { visibility: hidden; }\n" + "</style>\n" + "<div id='d1'>hello</div>\n" + "<div id='d2'>world</div>\n" + "<div id='d3'>again</div>\n" + "<div id='d4' style='display: none' >important</div>\n" + "</body></html>";  final HtmlPage page = loadPage(html); assertTrue(page.getElementById("d1").isDisplayed());  HtmlElement elem = page.getHtmlElementById("d2"); assertTrue(elem.isDisplayed()); elem.mouseOver(); assertFalse(elem.isDisplayed()); elem.mouseOut(); assertTrue(elem.isDisplayed());  elem = page.getHtmlElementById("d3"); assertTrue(elem.isDisplayed()); elem.mouseOver(); assertFalse(elem.isDisplayed()); elem.mouseOut(); "<AssertPlaceHolder>"; }
isDisplayed() { if (!mayBeDisplayed()) { return false; }  final Page page = getPage(); final WebWindow window = page.getEnclosingWindow(); final WebClient webClient = window.getWebClient(); if (webClient.getOptions().isCssEnabled()) { // display: iterate top to bottom, because if a parent is display:none, // there's nothing that a child can do to override it final List<Node> ancestors = getAncestors(); final ArrayList<ComputedCssStyleDeclaration> styles = new ArrayList<>(ancestors.size());  for (final Node node : ancestors) { if (node instanceof HtmlElement) { final HtmlElement elem = (HtmlElement) node; if (elem.isHidden()) { return false; }  if (elem instanceof HtmlDialog) { if (!((HtmlDialog) elem).isOpen()) { return false; } } else { final ComputedCssStyleDeclaration style = window.getComputedStyle(elem, null); if (DisplayStyle.NONE.value().equals(style.getDisplay())) { return false; } styles.add(style); } } }  // visibility: iterate bottom to top, because children can override // the visibility used by parent nodes for (int i = styles.size() - 1; i >= 0; i--) { final ComputedCssStyleDeclaration style = styles.get(i); final String visibility = style.getStyleAttribute(StyleAttributes.Definition.VISIBILITY, true); if (visibility.length() > 5) { if ("visible".equals(visibility)) { return true; } if ("hidden".equals(visibility) || "collapse".equals(visibility)) { return false; } } } } return true; }
[*] target: assertTrue(elem.isDisplayed())
[-] pred: org. junit. Assert. assertTrue ( elem. isDisplayed ( ) )
************************************
************************************
[+] input: Exception { final String html = "<html><head><title>Page A</title></head>\n" + "<body>\n" + "  <img id='myImg' usemap='#imgmap' style='display: none'" + " src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAA" + "HElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=='>\n" + "  <map id='myMap' name='imgmap'>\n" + "    <area id='myArea' shape='rect' coords='0,0,1,1'>\n" + "  </map>\n" + "</body></html>";  final WebDriver driver = loadPage2(html);  boolean displayed = driver.findElement(By.id("myImg")).isDisplayed(); assertFalse(displayed);  displayed = driver.findElement(By.id("myMap")).isDisplayed(); "<AssertPlaceHolder>"; }
isDisplayed() { final HtmlImage image = findReferencingImage(); if (null != image) { return image.isDisplayed(); } return false; }
[*] target: assertFalse(displayed)
[-] pred: org. junit. Assert. assertFalse ( displayed )
************************************
************************************
[+] input: Exception { final String htmlContent = "<html><body>\n" + "  <form id='form1'>\n" + "    <select name='select1' id='select1'>\n" + "      <option id='option1'>Option1</option>\n" + "      <option id='option2' selected>Number Two</option>\n" + "    </select>\n" + "</form></body></html>"; final HtmlPage page = loadPage(htmlContent);  final HtmlOption option1 = page.getHtmlElementById("option1"); assertFalse(option1.isSelected()); option1.click(); assertTrue(option1.isSelected()); option1.click(); "<AssertPlaceHolder>"; }
isSelected() { return selected_; }
[*] target: assertTrue(option1.isSelected())
[-] pred: org. junit. Assert. assertTrue ( option1. isSelected() )
************************************
************************************
[+] input: Exception { final String html = "<html><body>" + "  <select multiple><option value='a'>a</option><option value='b'>b</option></select>\n" + "</body></html>";  final HtmlPage page = loadPage(html); final HtmlSelect select = (HtmlSelect) page.getElementsByTagName("select").get(0); assertTrue(select.isMultipleSelectEnabled());  final List<HtmlOption> options = select.getOptions(); for (final HtmlOption option : options) { option.setSelected(true); }  for (final HtmlOption option : options) { "<AssertPlaceHolder>"; } }
isSelected() { return selected_; }
[*] target: assertTrue(option.isSelected())
[-] pred: org. junit. Assert. assertTrue ( option. isSelected() )
************************************
************************************
[+] input: performanceManyReplaces() { final String expected = StringUtils.repeat("x\n", 100_000).trim();  final long time = System.currentTimeMillis();  final HtmlSerializerTextBuilder serializer = new HtmlSerializerVisibleText.HtmlSerializerTextBuilder();  for (int i = 0; i < 100_000; i++) { serializer.append(" x ", Mode.WHITE_SPACE_NORMAL); serializer.appendBlockSeparator(); }  "<AssertPlaceHolder>";  final long runTime = System.currentTimeMillis() - time; assertTrue("cleanUp() took too much time", runTime < 200); }
getText() { return builder_.substring(0, trimRightPos_); }
[*] target: assertEquals(expected, serializer.getText())
[-] pred: org. junit. Assert. assertEquals ( expected, serializer. getText ( ) )
************************************
************************************
[+] input: noGlobalContextFactoryUsed() { final WebClient client1 = getWebClient(); final WebClient client2 = createNewWebClient();  final HtmlUnitContextFactory cf1 = ((JavaScriptEngine) client1.getJavaScriptEngine()).getContextFactory(); final HtmlUnitContextFactory cf2 = ((JavaScriptEngine) client2.getJavaScriptEngine()).getContextFactory();  "<AssertPlaceHolder>"; assertFalse(cf1 == ContextFactory.getGlobal()); assertFalse(cf2 == ContextFactory.getGlobal()); }
getContextFactory() { return contextFactory_; }
[*] target: assertFalse(cf1 == cf2)
[-] pred: org. junit. Assert. assertFalse ( cf1 == cf2 )
************************************
************************************
[+] input: Exception { final Cookie cookie1 = new Cookie("localhost", "a", "one"); final Cookie cookie2 = new Cookie("localhost", "a", "one", null, null, false); final Cookie cookie3 = new Cookie("localhost", "a", "one", "/", null, false); assertEquals(cookie1, cookie2); assertEquals(cookie2, cookie3); assertEquals(cookie1.hashCode(), cookie2.hashCode()); "<AssertPlaceHolder>"; }
hashCode() { final String path = getPath() == null ? "/" : getPath(); return new HashCodeBuilder() .append(getName()) .append(getDomain()) .append(path) .toHashCode(); }
[*] target: assertEquals(cookie2.hashCode(), cookie3.hashCode())
[-] pred: org. junit. Assert. assertEquals ( cookie2. hashCode ( ), cookie3. hashCode ( ) )
************************************
************************************
[+] input: containsKey_True_content_based() { // same hash and different content final OrderedFastHashMap<MockKey<String>, String> m = new OrderedFastHashMap<>(); final MockKey<String> mockKey1 = new MockKey<>(10, "akey1"); m.put(mockKey1, "any1"); m.put(new MockKey<>(10, "akey2"), "any2"); m.put(new MockKey<>(10, "akey3"), "any3"); m.put(new MockKey<>(10, "akey4"), "any4"); "<AssertPlaceHolder>"; assertTrue(m.containsKey(new MockKey<>(10, "akey1"))); }
containsKey(final Object key) { return get(key) != null; }
[*] target: assertTrue(m.containsKey(mockKey1))
[-] pred: org. junit. Assert. assertTrue ( m. containsKey ( mockKey1 ) )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/empty_service.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertNull(model.getNamespace()); assertEquals(model.getEntities().size(), 0); assertFalse(model.isEnableOData4SAPAnnotations()); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/empty_service_with_namespace.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertEquals(model.getNamespace(), "my.demo.namespace"); assertEquals(model.getEntities().size(), 0); assertFalse(model.isEnableOData4SAPAnnotations()); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/empty_service_with_annotations.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertNull(model.getNamespace()); assertEquals(model.getEntities().size(), 0); assertTrue(model.isEnableOData4SAPAnnotations()); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/entity_with_keys.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertEquals(model.getEntities().size(), 4);  XSKHDBXSODATAEntity actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sample.odata::view")); actualEntity.setAlias("MyView"); actualEntity.setKeyList(Arrays.asList("ID", "Text")); assertEquals(model.getEntities().get(0), actualEntity); assertEquals(model.getEntities().get(1), actualEntity);   actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sample.odata::view")); actualEntity.setAlias("MyView"); actualEntity.setKeyGenerated("GenID"); assertEquals(model.getEntities().get(2), actualEntity);  actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("test/AN_AGENCY.analyticView")); actualEntity.setAlias("Revenue"); actualEntity.setKeyGenerated("GENERATED_ID"); assertEquals(model.getEntities().get(3), actualEntity); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/entity_with_events.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertEquals(model.getEntities().size(), 4);  XSKHDBXSODATAEntity actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sample.odata::table")); XSKHDBXSODATAModification updateModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.UPDATE); updateModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Arrays.asList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.BEFORE, "sample.odata::beforeMethod"), new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.PRECOMMIT, "sample.odata::beforeMethod")))); XSKHDBXSODATAModification deleteModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.DELETE); deleteModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.AFTER, "sample.odata::afterMethod")))); XSKHDBXSODATAModification createModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.CREATE); createModification.setSpecification(new XSKHDBXSODATAModificationSpec().setForbidden(true)); actualEntity.setModifications(Arrays.asList(updateModification, deleteModification, createModification)); assertEquals(model.getEntities().get(0), actualEntity);  actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sample.odata::table")); createModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.CREATE); createModification.setSpecification(new XSKHDBXSODATAModificationSpec().setModificationAction("sample.odata::createMethod").setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.AFTER, "sample.odata::afterMethod")))); updateModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.UPDATE); updateModification.setSpecification(new XSKHDBXSODATAModificationSpec().setModificationAction("sample.odata::updateMethod")); deleteModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.DELETE); deleteModification.setSpecification(new XSKHDBXSODATAModificationSpec().setModificationAction("sample.odata::deleteMethod")); actualEntity.setModifications(Arrays.asList(createModification, updateModification, deleteModification)); assertEquals(model.getEntities().get(1), actualEntity);  actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sample.odata::table")); createModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.CREATE); createModification.setSpecification(new XSKHDBXSODATAModificationSpec().setModificationAction("sample.odata::createMethod")); updateModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.UPDATE); updateModification.setSpecification(new XSKHDBXSODATAModificationSpec().setEvents(Collections.singletonList(new XSKHDBXSODATAEvent(XSKHDBXSODATAEventType.PRECOMMIT, "sample.odata::precommitMethod")))); deleteModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.DELETE).setSpecification(new XSKHDBXSODATAModificationSpec().setForbidden(true)); actualEntity.setModifications(Arrays.asList(createModification, updateModification, deleteModification)); assertEquals(model.getEntities().get(2), actualEntity);  actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sample.odata::table")); createModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.CREATE).setSpecification(new XSKHDBXSODATAModificationSpec().setForbidden(true)); updateModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.UPDATE).setSpecification(new XSKHDBXSODATAModificationSpec().setForbidden(true)); deleteModification = new XSKHDBXSODATAModification().setMethod(XSKHDBXSODATAHandlerMethod.DELETE).setSpecification(new XSKHDBXSODATAModificationSpec().setForbidden(true)); actualEntity.setModifications(Arrays.asList(createModification, updateModification, deleteModification)); assertEquals(model.getEntities().get(3), actualEntity); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/empty_service_with_etag.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertEquals(model.getEntities().size(), 4);  XSKHDBXSODATAEntity actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("xsodata.test.tables::all_types")); actualEntity.setAlias("all_types_etag"); actualEntity.setConcurrencyToken(true); assertEquals(model.getEntities().get(0), actualEntity);  actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("xsodata.test.tables::BusinessPartner.BusinessPartner")); actualEntity.setAlias("BusinessPartner"); actualEntity.setConcurrencyToken(true); actualEntity.setWithoutPropertyProjections(Collections.singletonList("isContactPerson")); XSKHDBXSODATANavigation nav1 = new XSKHDBXSODATANavigation().setAssociation("BusinessPartner_To_N_BPRole").setAliasNavigation("Roles"); actualEntity.setNavigates(Collections.singletonList(nav1)); assertEquals(model.getEntities().get(1), actualEntity);  actualEntity = new XSKHDBXSODATAEntity(); actualEntity.setRepositoryObject(new XSKHDBXSODATARepositoryObject().setCatalogObjectName("sap.test.odata.db.views::Etag")); actualEntity.setAlias("EtagAll"); actualEntity.setConcurrencyToken(true); actualEntity.setKeyList(Arrays.asList("KEY_00", "KEY_01")); assertEquals(model.getEntities().get(2), actualEntity);  actualEntity.setETags(Arrays.asList("NVARCHAR_01", "INTEGER_02")); assertEquals(model.getEntities().get(3), actualEntity); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { HdbxsodataParser parser = parseSampleFile("xsodata/entity_with_no_associations.xsodata");  XSKHDBXSODATAService model = listener.getServiceModel(); "<AssertPlaceHolder>"; assertEquals(parser.getNumberOfSyntaxErrors(), 0); assertEquals(model.getEntities().size(), 20); }
getServiceModel() { return serviceModel; }
[*] target: assertNotNull(model)
[-] pred: org. junit. Assert. assertNotNull ( model )
************************************
************************************
[+] input: Exception { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken); // Act final ReturnT<String> retval = executorBiz.beat();  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(200, retval.getCode()); Assert.assertNull(retval.getMsg()); }
beat();
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: idleBeat() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.idleBeat(new IdleBeatParam(jobId));  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(500, retval.getCode()); Assert.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(IdleBeatParam idleBeatParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: kill() { ExecutorBiz executorBiz = new ExecutorBizClient(addressUrl, accessToken);  final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.kill(new KillParam(jobId));  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(200, retval.getCode()); Assert.assertNull(retval.getMsg()); }
kill(KillParam killParam);
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: idleBeat() { final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.idleBeat(jobId);  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(500, retval.getCode()); Assert.assertEquals("job thread is running or has trigger queue.", retval.getMsg()); }
idleBeat(int jobId) {  // isRunningOrHasQueue boolean isRunningOrHasQueue = false; JobThread jobThread = XxlJobExecutor.loadJobThread(jobId); if (jobThread != null && jobThread.isRunningOrHasQueue()) { isRunningOrHasQueue = true; }  if (isRunningOrHasQueue) { return new ReturnT<String>(ReturnT.FAIL_CODE, "job thread is running or has trigger queue."); } return ReturnT.SUCCESS; }
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: kill() { final int jobId = 0;  // Act final ReturnT<String> retval = executorBiz.kill(jobId);  // Assert result Assert."<AssertPlaceHolder>"; Assert.assertNull(((ReturnT<String>) retval).getContent()); Assert.assertEquals(200, retval.getCode()); Assert.assertNull(retval.getMsg()); }
kill(int jobId) { // kill handlerThread, and create new one JobThread jobThread = XxlJobExecutor.loadJobThread(jobId); if (jobThread != null) { XxlJobExecutor.removeJobThread(jobId, "scheduling center kill job."); return ReturnT.SUCCESS; }  return new ReturnT<String>(ReturnT.SUCCESS_CODE, "job thread aleady killed."); }
[*] target: assertNotNull(retval)
[-] pred: org. junit. Assert. assertNotNull ( retval )
************************************
************************************
[+] input: testIsEmpty() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); assertTrue(map.isEmpty()); map.put("key1", "value1"); "<AssertPlaceHolder>"; }
isEmpty() { return size.get() == 0; }
[*] target: assertFalse(map.isEmpty())
[-] pred: org. junit. Assert. assertFalse ( map. isEmpty() )
************************************
************************************
[+] input: testClear() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); map.put("key1", "value1"); map.put("key2", "value2"); map.clear(); assertTrue(map.isEmpty()); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size() )
************************************
************************************
[+] input: testPut() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); assertNull(map.put("key1", "value1")); assertEquals("value1", map.get("key1")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, map.size())
[-] pred: org. junit. Assert. assertEquals ( 1, map. size() )
************************************
************************************
[+] input: testPutIfAbsent() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); assertNull(map.putIfAbsent("key1", "value1")); assertEquals("value1", map.get("key1")); assertEquals("value1", map.putIfAbsent("key1", "value2")); assertEquals("value1", map.get("key1")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, map.size())
[-] pred: org. junit. Assert. assertEquals ( 1, map. size() )
************************************
************************************
[+] input: testRemove() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); map.put("key1", "value1"); assertEquals("value1", map.remove("key1")); assertNull(map.remove("key1")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(0, map.size())
[-] pred: org. junit. Assert. assertEquals ( 0, map. size ( ) )
************************************
************************************
[+] input: testReplace() { ConcurrentHashMapOrdered<String, String> map = new ConcurrentHashMapOrdered<>(); map.put("key1", "value1"); assertEquals("value1", map.replace("key1", "value2")); assertEquals("value2", map.get("key1")); assertNull(map.replace("key2", "value3")); "<AssertPlaceHolder>"; }
size() { return size.get(); }
[*] target: assertEquals(1, map.size())
[-] pred: org. junit. Assert. assertEquals ( 1, map. size ( ) )
************************************
************************************
[+] input: testSyncMintNFT() { Provider provider = wallet.getProvider(); Token token = defaultToken(); EthSignature ethSignature = new EthSignature(SignatureType.EthereumSignature, "0xac4f8b1ad65ea143dd2a940c72dd778ba3e07ee766355ed237a89a0b7e925fe76ead0a04e23db1cc1593399ee69faeb31b2e7e0c6fbec70d5061d6fbc431d64a1b"); when(provider.getTokens()).thenReturn(new Tokens(Collections.singletonMap(token.getAddress(), token))); when(provider.submitTx(defaultZkSyncTransaction_MintNFT(), ethSignature, false)).thenReturn("success:hash"); String response = wallet.syncMintNFT( "0x19aa2ed8712072e918632259780e587698ef58df", "0x0000000000000000000000000000000000000000000000000000000000000123", defaultTransactionFee(1000000), 12 ); "<AssertPlaceHolder>"; assertEquals(response, "success:hash"); }
syncMintNFT(String recipient, String contentHash, TransactionFee fee, Integer nonce) { final Integer nonceToUse = nonce == null ? getNonce() : nonce;  final SignedTransaction<MintNFT> signedMintNFT = buildSignedMintNFTTx(recipient, contentHash, fee.getFeeToken(), fee.getFee(), nonceToUse);  return submitSignedTransaction(signedMintNFT.getTransaction(), signedMintNFT.getEthereumSignature()); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
[+] input: testSyncSwap() { Provider provider = mock(Provider.class); when(provider.getState(anyString())).thenReturn(defaultAccountState(5)); ZkSyncWallet wallet = ZkSyncWallet.build(ethSigner, zkSigner, provider);  Token token = new Token(3, Address.DEFAULT.getValue(), "USDT", 1); EthSignature ethSignature = new EthSignature(SignatureType.EthereumSignature, "0x3a459b40838e9445adc59e0cba4bf769b68deda8dadfedfe415f9e8be1c55443090f66cfbd13d96019b9faafb996a5a69d1bc0d1061f08ebf7cb8a1687e09a0f1c"); when(provider.getTokens()).thenReturn(new Tokens(Collections.singletonMap(token.getAddress(), token))); when(provider.submitTx(defaultZkSyncTransaction_Swap(), new EthSignature[]{ethSignature, null, null})).thenReturn("success:hash"); String response = wallet.syncSwap( defaultOrderA(), defaultOrderB(), BigInteger.valueOf(1000000), BigInteger.valueOf(2500000), defaultTransactionFee(123), 1 ); "<AssertPlaceHolder>"; assertEquals(response, "success:hash"); }
syncSwap(Order order1, Order order2, BigInteger amount1, BigInteger amount2, TransactionFee fee, Integer nonce) { final Integer nonceToUse = nonce == null ? getNonce() : nonce;  final SignedTransaction<Swap> signedSwap = buildSignedSwapTx(order1, order2, amount1, amount2, fee.getFeeToken(), fee.getFee(), nonceToUse);  return submitSignedTransaction(signedSwap.getTransaction(), signedSwap.getEthereumSignature()[0], order1.getEthereumSignature(), order2.getEthereumSignature()); }
[*] target: assertNotNull(response)
[-] pred: org. junit. Assert. assertNotNull ( response )
************************************
************************************
